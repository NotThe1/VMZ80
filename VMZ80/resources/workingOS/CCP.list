0001: E000         ;		File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
0002: E000         ;		C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm
0003: E000
0004: E000         ; CCP.Z80
0005: E000         ;
0006: E000         ; 2019-03-03 Fixed UserCommand not putting 'COM' in Token1
0007: E000         ; 2019-03-02 Version 1.0
0008: E000         ; 2019-03-02 Refactored constants and removed header files
0009: E000         ; 2019-03-01 Finished refactor to Z80 idiom
0010: E000         ; 2019-02-19 Started to refactor to Z80 idiom
0011: E000
0012: E000         ; 2017-03-02 Refactored the CP/M Suite
0013: E000         ; 2014-01-16
0014: E000         ; 2014-05-01  :  Frank Martyn
0015: E000
0016: E000         ; replace systemFile with fcbSystemFileIndex
0017: E000
0018: E000                        Include ./stdHeader.Z80
0019: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E000         ; stdHeader.Z80
0023: E000         ; standard equates for use by CP/M
0024: E000
0025: E000         ; 2019-03-02 Removed any unused constants
0026: E000         ; 2017-03-02 Refactored the CP/M Suite
0027: E000
0028: E000
0029: E000             TRUE       EQU    -1                   ; Not false
0030: E000             FALSE      EQU    0000H
0031: E000             LO_NIBBLE_MASK EQU    0FH                  ; Mask used to obtain the bytes low four bits
0032: E000
0033: E000             BYTE       EQU    1                    ; Number of bytes for "byte" type
0034: E000             WORD       EQU    2                    ; Number of bytes for "word" type
0035: E000
0036: E000
0037: E000             ASCII_MASK EQU    7FH                  ; ASCII mask 7 bits
0038: E000             EndOfMessage EQU    00H
0039: E000
0040: E000             CTRL_C     EQU    03H                  ; ETX
0041: E000             CTRL_E     EQU    05H                  ; Physical EOL
0042: E000             CTRL_H     EQU    08H                  ; Backspace
0043: E000             CTRL_L     EQU    0CH                  ; FF - Form feed
0044: E000             CTRL_P     EQU    10H                  ; Print toggle
0045: E000             CTRL_R     EQU    12H                  ; Repeat line
0046: E000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0047: E000             CTRL_U     EQU    15H                  ; Line delete
0048: E000             CTRL_X     EQU    18H                  ; Logical line delete
0049: E000             CTRL_Z     EQU    1AH                  ; End of file
0050: E000
0051: E000             TAB        EQU    09H                  ; Tab
0052: E000             LF         EQU    0AH                  ; Line Feed
0053: E000             CR         EQU    0DH                  ; Carriage Return
0054: E000             SPACE      EQU    20H                  ; Space
0055: E000             HASH_TAG   EQU    23H                  ; Sharp sign #
0056: E000             DOLLAR     EQU    24H                  ; Dollar Sign
0057: E000             PERCENT    EQU    25H                  ; Percent Sign
0058: E000             ASTERISK   EQU    2AH                  ; Asterisk *
0059: E000             PERIOD     EQU    2EH                  ; Period
0060: E000             ASCII_ZERO EQU    30H                  ; zero
0061: E000             COLON      EQU    3AH                  ; Colon
0062: E000
0063: E000             SEMICOLON  EQU    3BH                  ; Semi Colon
0064: E000             LESS_THAN  EQU    3CH                  ; Less Than <
0065: E000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0066: E000             GREATER_THAN EQU    3EH                  ; Greater Than >
0067: E000             QMARK      EQU    3FH                  ; Question Mark
0068: E000             UNDER_SCORE EQU    5FH                  ; under score _
0069: E000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0070: E000             RUBOUT     EQU    7FH                  ; Delete Key
0071: E000
0072: E000
0073: E000             ASCII_A    EQU    'A'
0074: E000             ASCII_C    EQU    'C'
0075: E000             ASCII_M    EQU    'M'
0076: E000             ASCII_O    EQU    'O'
0077: E000             ASCII_Y    EQU    'Y'
0078: E000             CARET      EQU    '^'
0079: E000
0080: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0081: E000                        Include ./osHeader.Z80
0082: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0083: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0084: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0085: E000         ; osHeader.Z80
0086: E000
0087: E000         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0088: E000         ; 2017-03-02 Refactored the CP/M Suite
0089: E000
0090: E000         ; Contains the Equates used by the CP/M system
0091: E000
0092: E000         ;------------------------Page Zero Constants ---------------------------------
0093: E000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0094: E000
0095: E000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0096: E000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0097: E000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0098: E000
0099: E000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0100: E000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0101: E000
0102: E000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0103: E000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0104: E000
0105: E000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0106: E000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0107: E000
0108: E000             ComTail    EQU    RAM + 080H           ; Complete command tail
0109: E000             ComTailCount EQU    ComTail              ; Count of the number of char in tail
0110: E000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0111: E000         ;-----------------------------------------------------------------------
0112: E000
0113: E000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0114: E000         ;-----------------------------------------------------------------------
0115: E000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0116: E000         ;-----------------------------------------------------------------------
0117: E000             END_OF_FILE EQU    1AH                  ; end of file
0118: E000         ;-----------------------------------------------------------------------
0119: E000
0120: E000         ;--------------- CP/M Constants -----------------------------------------
0121: E000
0122: E000             CCPLength  EQU    0800H                ; Constant
0123: E000             BDOSLength EQU    0E00H                ; Constant 0E00H
0124: E000             BIOSLength EQU    0A00H                ; Constant 0900H
0125: E000
0126: E000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0127: E000             LengthInK  EQU    (LengthInBytes/1024) + 1
0128: E000
0129: E000             MemorySize EQU    64
0130: E000
0131: E000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0132: E000
0133: E000             BDOSBase   EQU    CCPEntry + CCPLength
0134: E000             BDOSEntry  EQU    BDOSBase
0135: E000
0136: E000             BIOSBase   EQU    BDOSBase + BDOSLength
0137: E000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0138: E000         ;-----------------------------------------------------------------------
0139: E000
0140: E000         ;? ;------------------- BDOS System Call Equates --------------------------
0141: E000         ;? fConsoleIn			EQU		01H			; rcharf - Console Input
0142: E000         ;? fConsoleOut			EQU		02H			; pcharf - Console Output
0143: E000         ;? fPrintString		EQU		09H			; pbuff	- Print String
0144: E000         ;? fReadString			EQU		0AH			; rbuff	- Read Console String
0145: E000         ;? fGetConsoleStatus	EQU		0BH			; breakf - Get Console Status
0146: E000         ;? fGetVersion			EQU		0CH			; liftf	- Return Version Number
0147: E000         ;? fResetSystem		EQU		0DH			; initf	- Reset Disk System
0148: E000         ;? fSelectDisk			EQU		0EH			; self	- Select Disk
0149: E000         ;? fOpenFile			EQU		0FH			; openf	- Open File
0150: E000         ;? fCloseFile			EQU		10H			; closef - Close File
0151: E000         ;? fSearchFirst		EQU		11H			; searf	- Search For First
0152: E000         ;? fSearchNext			EQU		12H			; searnf - Search for Next
0153: E000         ;? fDeleteFile			EQU		13H			; delf - Delete File
0154: E000         ;? fReadSeq			EQU		14H			; dreadf - Read Sequential
0155: E000         ;? fWriteSeq			EQU		15H			; dwritf - Write Sequential
0156: E000         ;? fMakeFile			EQU		16H			; makef	- Make File
0157: E000         ;? fRenameFile			EQU		17H			; renf	- Rename File
0158: E000         ;? fGetLoginVector		EQU		18H			; logf	- Return Login Vector
0159: E000         ;? fGetCurrentDisk		EQU		19H			; cself	- Return Current Disk
0160: E000         ;? fSetDMA				EQU		1AH			; dmaf	- Set DMA address
0161: E000         ;? fGetSetUserNumber	EQU		20H			; userf	- Set/Get User Code
0162: E000         ;? ;-----------------------------------------------------------------------
0163: E000         ;?
0164: E000         ;?
0165: E000         ;?
0166: E000         ;?
0167: E000         ;?
0168: E000         ;? ;*******************************************************************************
0169: E000         ;? ; These are the values handed over by the BDOS when it calls the Writer operation
0170: E000         ;? ; The allocated.unallocated indicates whether the BDOS is set to write to an
0171: E000         ;? ; unallocated allocation block (it only indicates this for the first 128 byte
0172: E000         ;? ; sector write) or to an allocation block that has already been allocated to a
0173: E000         ;? ; file. The BDOS also indicates if it is set to write to the file directory
0174: E000         ;? ;*******************************************************************************
0175: E000         ;? WriteAllocated		EQU	00H
0176: E000         ;? WriteDirectory		EQU	01H
0177: E000         ;? WriteCleanBuffer	EQU	02H
0178: E000
0179: E000
0180: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0181: E000
0182: E000
0183: E000             BDOS       EQU    0005H                ; BDOS Vector in Page 00000
0184: E000
0185: E000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0186: E000             fcbSystemFileIndex EQU    0AH                  ; extent number field index
0187: E000             FILE_NAME_SIZE EQU    08H                  ; Max size of file Name
0188: E000             FILE_TYPE_SIZE EQU    03H                  ; Max size of file Type
0189: E000
0190: E000         ;------------------- BDOS System Call Equates --------------------------
0191: E000             fConsoleIn EQU    01H                  ; Console Input
0192: E000             fConsoleOut EQU    02H                  ; Console Output
0193: E000             fPrintString EQU    09H                  ; Print String
0194: E000             fReadString EQU    0AH                  ; Read Console String
0195: E000             fGetConsoleStatus EQU    0BH                  ; Get Console Status
0196: E000             fGetVersion EQU    0CH                  ; Return Version Number
0197: E000             fResetSystem EQU    0DH                  ; Reset Disk System
0198: E000             fSelectDisk EQU    0EH                  ; Select Disk
0199: E000             fOpenFile  EQU    0FH                  ; Open File
0200: E000             fCloseFile EQU    10H                  ; Close File
0201: E000             fSearchFirst EQU    11H                  ; Search For First
0202: E000             fSearchNext EQU    12H                  ; Search for Next
0203: E000             fDeleteFile EQU    13H                  ; Delete File
0204: E000             fReadSeq   EQU    14H                  ; Read Sequential
0205: E000             fWriteSeq  EQU    15H                  ; Write Sequential
0206: E000             fMakeFile  EQU    16H                  ; Make File
0207: E000             fRenameFile EQU    17H                  ; Rename File
0208: E000             fGetLoginVector EQU    18H                  ; Return Login Vector
0209: E000             fGetCurrentDisk EQU    19H                  ; Return Current Disk
0210: E000             fSetDMA    EQU    1AH                  ; Set DMA address
0211: E000             fGetSetUserNumber EQU    20H                  ; Set/Get User Code
0212: E000         ;-----------------------------------------------------------------------
0213: E000
0214: E000
0215: E000                        ORG    CCPEntry
0216: E000             CcpBoundary EQU    $
0217: E000         ;========================== CCP Entry ======================================;
0218: E000
0219: E000         ;	JP		CcpStart						;start CCP with possible initial command
0220: E000         ;*****************************************************************
0221: E000         ;enter here from boot loader
0222: E000         ; On Entry	C(HiNibble) = User Number
0223: E000         ;			C(LoNibble) = Disk (0=A, 1=B...F=P)
0224: E000             CcpStart:
0225: E000 31 F0 E7               LD     SP,Stack             ; Set CCP's Stack
0226: E003 C5                     PUSH   BC                   ; Save Disk Number
0227: E004 59                     LD     E,C                  ; Get User Number
0228: E005 CB 3B                  SRL    E
0229: E007 CB 3B                  SRL    E                    ; Move user number
0230: E009 CB 3B                  SRL    E                    ;  to Lo Nibble
0231: E00B CB 3B                  SRL    E
0232: E00D CD 2A E6               CALL   SetUser              ; Set initial User
0233: E010         ; Initialize will completely reset the disk file system
0234: E010 CD E9 E5               CALL   Initialize           ; A = 0FFH if Submit file found
0235: E013 32 9D E2               LD     (submitFlag),A       ; Save return value in Flag
0236: E016 C1                     POP    BC                   ; Recall disk number
0237: E017 79                     LD     A,C                  ; Put into Acc
0238: E018 E6 0F                  AND    LO_NIBBLE_MASK       ; Remove User Number
0239: E01A 32 04 00               LD     (Pg0CurentDisk),A    ; Puts disk number into Page 0
0240: E01D CD EE E5               CALL   SelectDisk           ; Set default Disk From Acc
0241: E020 3A 1A E2               LD     A,(commandLength)    ; check for initial command
0242: E023 B7                     OR     A                    ; See if there is a Command
0243: E024 20 16                  JR     NZ,CcpParseCommand   ;  Skip if yes
0244: E026
0245: E026             ccpMainEntry:
0246: E026 31 F0 E7               LD     SP,Stack             ; (re)Establish CCP's Stack
0247: E029 CD 46 E6               CALL   PrintCrLf            ; Send CRLF to the Console
0248: E02C CD 23 E6               CALL   GetSelectedDrive     ; Get current disk number
0249: E02F C6 41                  ADD    A,ASCII_A            ; Make ASCII form of Drive
0250: E031 CD 3B E6               CALL   PrintCharInA         ; Send Drive letter to console
0251: E034 3E 3E                  LD     A,GREATER_THAN       ; Load '>'
0252: E036 CD 3B E6               CALL   PrintCharInA         ; Send to Console
0253: E039 CD 65 E0               CALL   ReadCommand          ; Command Buffer filled, Pointer set
0254: E03C
0255: E03C             CcpParseCommand:
0256: E03C 11 80 00               LD     DE,DMABuffer         ; Default in page 0
0257: E03F CD 1E E6               CALL   SetDMA               ; Set the DMA address
0258: E042 CD 23 E6               CALL   GetSelectedDrive     ; Get current drive
0259: E045 32 27 E7               LD     (currentDisk),A      ; Save
0260: E048 CD 21 E1               CALL   ParseToken1          ; Get first token in command buffer
0261: E04B C4 F5 E1               CALL   NZ,CommandError      ; The name must be unambiguous
0262: E04E 3A 24 E7               LD     A,(selectedDisk)     ; Get the Disk:
0263: E051 B7                     OR     A                    ; If not default,
0264: E052 C2 0C E5               JP     NZ,ccpUserCommand    ;   must be user CMD
0265: E055
0266: E055 CD D0 E1               CALL   IntrinsicFunction    ; Get CMD index into ACC
0267: E058 21 D8 E2               LD     HL,builtInCMDVector  ; Base of Vector
0268: E05B 5F                     LD     E,A
0269: E05C 16 00                  LD     D,0                  ; Index in DE
0270: E05E 19                     ADD    HL,DE
0271: E05F 19                     ADD    HL,DE                ; Vector is a word, need 2 ADDs
0272: E060 7E                     LD     A,(HL)               ; Pointing at Address
0273: E061 23                     INC    HL
0274: E062 66                     LD     H,(HL)
0275: E063 6F                     LD     L,A                  ; Get address to HL
0276: E064 E9                     JP     (HL)                 ;  Go to the Function
0277: E065
0278: E065
0279: E065         ;------------------------------ Read Command -------------------------------;
0280: E065         ;
0281: E065         ;read the next command into the command buffer								;
0282: E065         ;check for submit file														;
0283: E065             ReadCommand:                      ;
0284: E065 3A 9D E2               LD     A,(submitFlag)       ; Get the Submit File Flag			;
0285: E068 B7                     OR     A                    ; Is it Set ?						;
0286: E069 28 54                  JR     Z,NotSubmitFile      ;  skip if not						;
0287: E06B         ; scanning a submit file change drives to open and read the file			;
0288: E06B 3A 27 E7               LD     A,(currentDisk)      ; Get current disk					;
0289: E06E B7                     OR     A                    ; Is it default ?					;
0290: E06F 3E 00                  LD     A,0                  ; Prepare to set Disk A				;
0291: E071 C4 EE E5               CALL   NZ,SelectDisk        ; Select it if needed				;
0292: E074         ; have to open again in case xsub present									;
0293: E074 11 9E E2               LD     DE,submitFCB         ; Point at the Submits's FCB		;
0294: E077 CD F4 E5               CALL   OpenFile             ; Open it							;
0295: E07A 28 43                  JR     Z,NotSubmitFile      ; Skip if no submit file present	;
0296: E07C 3A AE E2               LD     A,(submitRC)         ; Get Number of records in file		;
0297: E07F 3D                     DEC    A                    ; read last record(s) first		;
0298: E080 32 BF E2               LD     (submitCR),A         ; current record to read			;
0299: E083 11 9E E2               LD     DE,submitFCB         ; Point at the Submits's FCB		;
0300: E086 CD FE E5               CALL   DiskRead             ; Read from back to front			;
0301: E089 20 34                  JR     NZ,NotSubmitFile     ; Skip EOF ??						;
0302: E08B         ;
0303: E08B         ; disk read is OK, transfer to commandBuffer								;
0304: E08B 21 80 00               LD     HL,DMABuffer         ; From								;
0305: E08E 11 1A E2               LD     DE,commandLength     ; TO								;
0306: E091 01 80 00               LD     BC,cpmRecordSize     ; For this many bytes				;
0307: E094 ED B0                  LDIR                        ; Move to command buffer			;
0308: E096         ;
0309: E096         ; line is transferred, close the file with a deleted record					;
0310: E096 21 AD E2               LD     HL,submitFWF         ; Point at the WriteFileFlag		;
0311: E099 CB BE                  RES    7,(HL)               ; Clear the WriteFileFlag					;
0312: E09B         ;	LD		HL,submitFWF				; Bit 7 is FileWriteFlag			;
0313: E09B         ;	LD		(HL),0															;
0314: E09B         ;	INC		HL																;
0315: E09B 21 AE E2               LD     HL,submitRC          ; Point at FCB record Count			;
0316: E09E 35                     DEC    M                    ; Make it one less record			;
0317: E09F 11 9E E2               LD     DE,submitFCB         ; Point at the Submits's FCB		;
0318: E0A2 CD F9 E5               CALL   CloseFile            ; Close it							;
0319: E0A5 28 18                  JR     Z,NotSubmitFile      ; Skip if not clean close			;
0320: E0A7         ; CloseFile went ok, return to original drive								;
0321: E0A7 3A 27 E7               LD     A,(currentDisk)      ; Get the current disk				;
0322: E0AA B7                     OR     A                    ; Is it the default disk ?			;
0323: E0AB C4 EE E5               CALL   NZ,SelectDisk        ;  no, then go select it			;
0324: E0AE         ; print to the 00															;
0325: E0AE 21 1B E2               LD     HL,commandBuffer     ; Point at the command buffer		;
0326: E0B1 CD 5C E6               CALL   PrintStringNull      ; Display it on the Console			;
0327: E0B4 CD 74 E6               CALL   CheckForConsoleChar  ; User input a character ?			;
0328: E0B7 28 17                  JR     Z,NoRead             ;  skip if not						;
0329: E0B9 CD EE E0               CALL   DeleteSubmitFile     ; Remove file and reset submit flag ;
0330: E0BC C3 26 E0               JP     ccpMainEntry         ; Start a new CCP session			;
0331: E0BF         ;   ---		------------				;-----------------------------------;
0332: E0BF             NotSubmitFile:                      ;
0333: E0BF CD EE E0               CALL   DeleteSubmitFile     ; Delete any submit file			;
0334: E0C2 CD 06 E1               CALL   SaveUserAndDisk      ; Save User & Disk to page 0		;
0335: E0C5 11 19 E2               LD     DE,commandMaxLength  ; Point to Start of Buffer			;
0336: E0C8 0E 0A                  LD     C,fReadString        ; Load Function Number				;
0337: E0CA CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
0338: E0CD CD 15 E1               CALL   SetPage0CurDisk      ; No Cntl C, so restore Pg0CurentDis;
0339: E0D0         ;
0340: E0D0             NoRead:                         ;
0341: E0D0         ; set the last character to zero for later scans							;
0342: E0D0 21 1A E2               LD     HL,commandLength     ; Point to length of command		;
0343: E0D3 46                     LD     B,(HL)               ; Put it into B						;
0344: E0D4             UpCaseLoop:                      ;
0345: E0D4 23                     INC    HL                   ; Point at next byte in buffer		;
0346: E0D5 7E                     LD     A,(HL)               ; Get the Character					;
0347: E0D6 CD E5 E0               CALL   UpCase               ; If between a-z, up-case it		;
0348: E0D9 77                     LD     (HL),A               ; Replace character					;
0349: E0DA 10 F8                  DJNZ   UpCaseLoop           ; go thru all of the CMD buffer		;
0350: E0DC         ;end of scan, h,l address end of command									;
0351: E0DC         ;ReadCommand2:																;
0352: E0DC 23                     INC    HL                   ; Point at last char + 1			;
0353: E0DD 70                     LD     (HL),B               ; Stuff Zero to terminate the CMD   ;
0354: E0DE 21 1B E2               LD     HL,commandBuffer     ; go back to start of com			;
0355: E0E1 22 9B E2               LD     (commandBufferPointer),HL ; Place in current CMD address		;
0356: E0E4 C9                     RET                         ;
0357: E0E5         ;------------------------------ Read Command -------------------------------;
0358: E0E5
0359: E0E5         ;--------------------------------- UpCase ----------------------------------;
0360: E0E5         ;convert character in register A (a to z) to upper case						;
0361: E0E5             UpCase:                         ;
0362: E0E5 FE 61                  CP     061H                 ;
0363: E0E7 D8                     RET    C                    ; Return if below lower case 'a'	;
0364: E0E8 FE 7B                  CP     07BH                 ;
0365: E0EA D0                     RET    NC                   ; Return if above lower case 'z'	;
0366: E0EB E6 5F                  AND    05FH                 ; Drop bit 5/ makes q->Q etc		;
0367: E0ED C9                     RET                         ;
0368: E0EE         ;--------------------------------- UpCase ----------------------------------;
0369: E0EE         ;---------------------------- Delete SubmitFile ----------------------------;
0370: E0EE         ;delete the submit file, and set submit flag to false						;
0371: E0EE             DeleteSubmitFile:                      ;
0372: E0EE 21 9D E2               LD     HL,submitFlag        ; Point at Submit flag				;
0373: E0F1 7E                     LD     A,(HL)               ; Get the Flag						;
0374: E0F2 B7                     OR     A                    ; Is it Set ?						;
0375: E0F3 C8                     RET    Z                    ;  return if not set				;
0376: E0F4 36 00                  LD     (HL),0               ; Clear Flag						;
0377: E0F6 AF                     XOR    A                    ; Drive 0 = A:						;
0378: E0F7 CD EE E5               CALL   SelectDisk           ; Select drive						;
0379: E0FA 11 9E E2               LD     DE,submitFCB         ; Load the submits FCB				;
0380: E0FD CD 05 E6               CALL   DeleteFile           ; Go delete it						;
0381: E100 3A 27 E7               LD     A,(currentDisk)      ; Determine the current disk		;
0382: E103 C3 EE E5               JP     SelectDisk           ; Reselect back to original drive   ;
0383: E106         ;---------------------------- Delete SubmitFile ----------------------------;
0384: E106         ;-------------------------------- Save User --------------------------------;
0385: E106         ;save user#/disk# before possible ^c or transient							;
0386: E106             SaveUserAndDisk:                      ;
0387: E106 CD 28 E6               CALL   GetUser              ; Get the user number into Acc		;
0388: E109 87                     ADD    A,A                  ;
0389: E10A 87                     ADD    A,A                  ;
0390: E10B 87                     ADD    A,A                  ;
0391: E10C 87                     ADD    A,A                  ; Move user to Hi Nibble			;
0392: E10D 21 27 E7               LD     HL,currentDisk       ; Current disk (Lo Nibble)			;
0393: E110 B6                     OR     M                    ; Acc -> User & Disk				;
0394: E111 32 04 00               LD     (Pg0CurentDisk),A    ; Stored in Page0 for later			;
0395: E114 C9                     RET                         ;
0396: E115         ;-------------------------------- Save User --------------------------------;
0397: E115         ;------------------------- Set Page 0 Current Disk -------------------------;
0398: E115         ;set Pg0CurentDisk to current disk											;
0399: E115             SetPage0CurDisk:                      ;
0400: E115 3A 27 E7               LD     A,(currentDisk)      ; Get CCP's current disk			;
0401: E118 32 04 00               LD     (Pg0CurentDisk),A    ; Put into Page 0					;
0402: E11B C9                     RET                         ;
0403: E11C         ;------------------------- Set Page 0 Current Disk -------------------------;
0404: E11C
0405: E11C         ;--------------------------------- Parse Token -----------------------------;
0406: E11C         ; Parse command buffer.														;
0407: E11C         ; Used to isolate the command												;
0408: E11C         ;
0409: E11C             ParseToken2:                      ;
0410: E11C 21 13 E7               LD     HL,Token2            ; Point at Token2 start				;
0411: E11F 18 03                  JR     ParseToken           ;
0412: E121             ParseToken1:                      ;
0413: E121 21 03 E7               LD     HL,Token1            ; Point at Token1 start				;
0414: E124             ParseToken:                      ;
0415: E124 E5                     PUSH   HL                   ; Start of Token's Pointer			;
0416: E125 E5                     PUSH   HL                   ; Start of Token's Pointer			;
0417: E126 AF                     XOR    A                    ; Set A to 0						;
0418: E127 32 24 E7               LD     (selectedDisk),A     ; Assume default disk				;
0419: E12A 2A 9B E2               LD     HL,(commandBufferPointer) ; Buffer's Pointer					;
0420: E12D CD A8 E1               CALL   NextNonBlankChar     ; Get printable character			;
0421: E130 22 25 E7               LD     (tokenStart),HL      ; Save token's address				;
0422: E133 EB                     EX     DE,HL                ; DE -> Buffer						;
0423: E134 E1                     POP    HL                   ; DE -> Buffer,						;
0424: E135         ;  HL -> Start of Token's Pointer   ;
0425: E135         ; Disk ?																	;
0426: E135 1A                     LD     A,(DE)               ; Get 1st character from buffer		;
0427: E136 B7                     OR     A                    ; Is it the default Disk ?			;
0428: E137 28 0A                  JR     Z,UseCurrentDisk     ; Use current disk if empty			;
0429: E139 DE 40                  SBC    A,040H               ; Convert to number					;
0430: E13B 47                     LD     B,A                  ; Hold disk number in B				;
0431: E13C 13                     INC    DE                   ;
0432: E13D 1A                     LD     A,(DE)               ; Look at next character			;
0433: E13E FE 3A                  CP     COLON                ; Is it a ':' ?						;
0434: E140 28 08                  JR     Z,UseTokensDisk      ;  if yes, set disk number			;
0435: E142         ; No Disk																	;
0436: E142 1B                     DEC    DE                   ; Back to start of buffer			;
0437: E143         ;
0438: E143             UseCurrentDisk:                      ;
0439: E143 3A 27 E7               LD     A,(currentDisk)      ; Get current Disk					;
0440: E146 77                     LD     (HL),A               ; Put into the Token				;
0441: E147 C3 50 E1               JP     SetFileName          ;
0442: E14A         ;
0443: E14A             UseTokensDisk:                      ;
0444: E14A 78                     LD     A,B                  ; Get disk from this parse			;
0445: E14B 32 24 E7               LD     (selectedDisk),A     ; Mark as disk selected				;
0446: E14E 70                     LD     (HL),B               ; Put it into the token				;
0447: E14F 13                     INC    DE                   ; Move past the ':'					;
0448: E150         ;
0449: E150             SetFileName:                      ;
0450: E150 06 08                  LD     B,FILE_NAME_SIZE     ; File name length (max)			;
0451: E152 CD 78 E1               CALL   FormatElement        ; Format file name					;
0452: E155         ;
0453: E155             SetType:                        ;
0454: E155 06 03                  LD     B,FILE_TYPE_SIZE     ; File type length (max)			;
0455: E157 CD 95 E1               CALL   IsItDot              ; is it a '.' ?						;
0456: E15A CC 78 E1               CALL   Z,FormatElement      ;  Yes,Format it					;
0457: E15D         ;
0458: E15D         ; Zero Rest of token														;
0459: E15D 06 03                  LD     B,3                  ;
0460: E15F AF                     XOR    A                    ;
0461: E160 CD A3 E1               CALL   FillWithAcc          ;
0462: E163 EB                     EX     DE,HL                ;
0463: E164 22 9B E2               LD     (commandBufferPointer),HL ; Set new starting point			;
0464: E167         ; Recover the start address of the FCB and count ?'s						;
0465: E167 E1                     POP    HL                   ; Restore start of Token			;
0466: E168 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Loop size					;
0467: E16A 0E 00                  LD     C,00                 ; Counter							;
0468: E16C 3E 3F                  LD     A,QMARK              ; We want to count '?'s				;
0469: E16E             QuestionMarkCount:                      ;
0470: E16E 23                     INC    HL                   ; Adjust token pointer				;
0471: E16F BE                     CP     (HL)                 ; Is it a '?'						;
0472: E170 20 01                  JR     NZ,QuestionMarkCount1 ;  no, then skip					;
0473: E172 0C                     INC    C                    ;  else increment the count			;
0474: E173             QuestionMarkCount1:                      ;
0475: E173 10 F9                  DJNZ   QuestionMarkCount    ; Manage the Loop					;
0476: E175 79                     LD     A,C                  ;
0477: E176 B7                     OR     A                    ;
0478: E177 C9                     RET                         ;
0479: E178         ;-------------------------------- Parse Token ------------------------------;
0480: E178         ;------------------------------- Format Element ----------------------------;
0481: E178         ; Put element in a Left Justified, Space Padded field.						;
0482: E178         ; If it encounters an asterisk, it will pad the rest of the field with '?'s ;
0483: E178         ; Enter With:	B  = Element size											;
0484: E178         ;				DE = Element source											;
0485: E178         ;				HL = Element destination									;
0486: E178             FormatElement:                      ;
0487: E178 CD B1 E1               CALL   IsItADelimiter       ; Is character a delimiter ?		;
0488: E17B 28 14                  JR     Z,PadTheElement      ;  yes, pad rest of Element			;
0489: E17D         ;
0490: E17D 23                     INC    HL                   ;  else move the Token's pointer	;
0491: E17E FE 2A                  CP     ASTERISK             ; Is it an '*'						;
0492: E180 20 04                  JR     NZ,FormatElement1    ;  no, then just put in Token   ;
0493: E182 36 3F                  LD     (HL),QMARK           ;  else Put a '?' in token			;
0494: E184 18 02                  JR     FormatElement2       ;  for rest of Element				;
0495: E186         ;
0496: E186             FormatElement1:                      ;
0497: E186 77                     LD     (HL),A               ; Put character in token			;
0498: E187 13                     INC    DE                   ; Increment the buffer pointer		;
0499: E188             FormatElement2:                      ;
0500: E188 10 EE                  DJNZ   FormatElement        ; Loop if more						;
0501: E18A         ;
0502: E18A             TruncateElement:                      ;
0503: E18A CD B1 E1               CALL   IsItADelimiter       ; We expect a delimiter				;
0504: E18D C8                     RET    Z                    ; If we get one, we are done		;
0505: E18E 13                     INC    DE                   ;  skip forward in buffer			;
0506: E18F 18 F9                  JR     TruncateElement      ; Keep looking for delimiter		;
0507: E191         ;
0508: E191             PadTheElement:                      ;
0509: E191 CD A1 E1               CALL   FillWithSpace        ; Pad the rest of Element			;
0510: E194 C9                     RET                         ;
0511: E195         ;------------------------------- Format Element ----------------------------;
0512: E195         ;-------------------------------- Is It a Dot ------------------------------;
0513: E195         ; Check to see if char is buffer is a period. If it is it returns with		;
0514: E195         ; the Z-Flag set., and the DE pointer advanced beyond the '.'.  If it is	;
0515: E195         ; not a period. It will fill the buffer with spaces and return with the		;
0516: E195         ; Z-Flag reset.																;
0517: E195         ;																			;
0518: E195         ; Enter With:	DE = Pointer for buffer										;
0519: E195         ;					B = buffer size											;
0520: E195         ; Return With:	DE = Past the period										;
0521: E195         ;				Z-Flag =  set if Period										;
0522: E195         ; 				Z-Flag = reset if not Period								;
0523: E195             IsItDot:                        ;
0524: E195 1A                     LD     A,(DE)               ;
0525: E196 13                     INC    DE                   ; Assume it is a '.'				;
0526: E197 FE 2E                  CP     PERIOD               ; Is it '.' ?						;
0527: E199 C8                     RET    Z                    ;  if yes exit with Z-Flag set		;
0528: E19A         ;
0529: E19A 1B                     DEC    DE                   ; Adjust, wrong assumption			;
0530: E19B CD A1 E1               CALL   FillWithSpace        ;  else make all spaces				;
0531: E19E AF                     XOR    A                    ;
0532: E19F 3C                     INC    A                    ; Reset the Z-Flag					;
0533: E1A0 C9                     RET                         ; Exit with Z-Flag reset			;
0534: E1A1         ;-------------------------------- Is It a Dot ------------------------------;
0535: E1A1         ;-------------------------- Fill With Space/Acc ----------------------------;
0536: E1A1         ; fills buffer with SPACE or contents of Acc.								;
0537: E1A1         ; Enters with:	HL = less than start of fill area							;
0538: E1A1         ;				B  = fill Count												;
0539: E1A1         ;				A  = fill character (FillWithAcc)							;
0540: E1A1             FillWithSpace:                      ;
0541: E1A1 3E 20                  LD     A,SPACE              ;
0542: E1A3             FillWithAcc:                      ;
0543: E1A3 23                     INC    HL                   ;
0544: E1A4 77                     LD     (HL),A               ;
0545: E1A5 10 FC                  DJNZ   FillWithAcc          ;
0546: E1A7 C9                     RET                         ;
0547: E1A8         ;-------------------------- Fill With Space/Acc ----------------------------;
0548: E1A8         ;------------------------ Next Non Blank Character -------------------------;
0549: E1A8         ;find the next non blank character in line pointed to by DE					;
0550: E1A8             NextNonBlankChar:                      ;
0551: E1A8 7E                     LD     A,(HL)               ; Get the character					;
0552: E1A9 B7                     OR     A                    ; Is it End of buffer ?				;
0553: E1AA C8                     RET    Z                    ;  if yes, return					;
0554: E1AB FE 20                  CP     SPACE                ; is it a blank ?					;
0555: E1AD C0                     RET    NZ                   ;  if not, return					;
0556: E1AE 23                     INC    HL                   ;  else increment pointer			;
0557: E1AF 18 F7                  JR     NextNonBlankChar     ; Loop for next character			;
0558: E1B1         ;------------------------ Next Non Blank Character -------------------------;
0559: E1B1         ;---------------------------- Is It A Delimiter ----------------------------;
0560: E1B1         ; Returns with Z-flag set if (DE) pointing at a delimiter					;
0561: E1B1         ; Does an error exit if not valid ASCII character							;
0562: E1B1             IsItADelimiter:                      ;
0563: E1B1 1A                     LD     A,(DE)               ; Get the character					;
0564: E1B2 B7                     OR     A                    ;
0565: E1B3 C8                     RET    Z                    ; End of Buffer is a delimiter		;
0566: E1B4 FE 20                  CP     SPACE                ;
0567: E1B6 DA F5 E1               JP     C,CommandError       ; Error exit if not ASCII			;
0568: E1B9 C8                     RET    Z                    ; SPACE is a delimiter				;
0569: E1BA FE 3D                  CP     EQUAL_SIGN           ;
0570: E1BC C8                     RET    Z                    ; '=' is a delimiter				;
0571: E1BD FE 5F                  CP     UNDER_SCORE          ;
0572: E1BF C8                     RET    Z                    ; '_' is a delimiter				;
0573: E1C0 FE 2E                  CP     PERIOD               ;
0574: E1C2 C8                     RET    Z                    ; '.' is a delimiter				;
0575: E1C3 FE 3A                  CP     COLON                ;
0576: E1C5 C8                     RET    Z                    ; ':' is a delimiter				;
0577: E1C6 FE 3B                  CP     SEMICOLON            ;
0578: E1C8 C8                     RET    Z                    ; ';' is a delimiter				;
0579: E1C9 FE 3C                  CP     LESS_THAN            ;
0580: E1CB C8                     RET    Z                    ; '<' is a delimiter				;
0581: E1CC FE 3E                  CP     GREATER_THAN         ;
0582: E1CE C8                     RET    Z                    ; '>' is a delimiter				;
0583: E1CF C9                     RET                         ; Not a delimiter					;
0584: E1D0         ;---------------------------- Is It A Delimiter ----------------------------;
0585: E1D0
0586: E1D0         ;---------------------------- Intrinsic Function ---------------------------;
0587: E1D0         ;look for intrinsic functions (Token1 has been filled)						;
0588: E1D0             IntrinsicFunction:                      ;
0589: E1D0 21 C0 E2               LD     HL,builtInCMDNames   ; Point at List of CMDs				;
0590: E1D3 0E 00                  LD     C,0                  ; Initialize counter				;
0591: E1D5             IntrinsicFunction1:                      ;
0592: E1D5 79                     LD     A,C                  ; Get Counter						;
0593: E1D6 FE 06                  CP     builtInCMDCount      ; Past number of commands ?			;
0594: E1D8 D0                     RET    NC                   ;  exit if yes						;
0595: E1D9 11 04 E7               LD     DE,Token1+1          ; Beginning of name						;
0596: E1DC 06 04                  LD     B,builtInCMDNameSize ; Length of match					;
0597: E1DE             IntrinsicFunction2:                      ;
0598: E1DE 1A                     LD     A,(DE)               ;
0599: E1DF BE                     CP     M                    ; Is there a match ?				;
0600: E1E0 20 0C                  JR     NZ,IntrinsicFunction3 ;  skip if no match					;
0601: E1E2 13                     INC    DE                   ;
0602: E1E3 23                     INC    HL                   ; Point at next characters			;
0603: E1E4 05                     DEC    B                    ; Decrement the counter				;
0604: E1E5 20 F7                  JR     NZ,IntrinsicFunction2 ; Loop while matching				;
0605: E1E7         ; complete match on name, check for blank in FCB							;
0606: E1E7 1A                     LD     A,(DE)               ;
0607: E1E8 FE 20                  CP     SPACE                ; Blank in CMD ?					;
0608: E1EA 20 06                  JR     NZ,IntrinsicFunction4 ;  No ,then no match				;
0609: E1EC 79                     LD     A,C                  ;  Else they match,					;
0610: E1ED C9                     RET                         ; Return with index in A			;
0611: E1EE         ;
0612: E1EE             IntrinsicFunction3:                      ;
0613: E1EE 23                     INC    HL                   ; Move to next in list				;
0614: E1EF 05                     DEC    B                    ;
0615: E1F0 20 FC                  JR     NZ,IntrinsicFunction3 ; Loop thru this one				;
0616: E1F2         ;
0617: E1F2             IntrinsicFunction4:                      ;
0618: E1F2 0C                     INC    C                    ; Update the index					;
0619: E1F3 18 E0                  JR     IntrinsicFunction1   ;  loop for another round			;
0620: E1F5         ;---------------------------- Intrinsic Function ---------------------------;
0621: E1F5
0622: E1F5         ; cmd
0623: E1F5         ;------------------------------ Command Error ------------------------------;
0624: E1F5         ;error in command string starting at position;'tokenStart' and ending 		;
0625: E1F5         ; with first delimiter														;
0626: E1F5         ;
0627: E1F5             CommandError:                      ;
0628: E1F5 CD 46 E6               CALL   PrintCrLf            ; Next Line						;
0629: E1F8 2A 25 E7               LD     HL,(tokenStart)      ; Start of error token					;
0630: E1FB             CommandErrorLoop:                      ;
0631: E1FB 7E                     LD     A,(HL)               ; Get character						;
0632: E1FC FE 20                  CP     SPACE                ; Past offending token ?			;
0633: E1FE 28 0B                  JR     Z,CommandErrorExit   ;  done if yes						;
0634: E200 B7                     OR     A                    ; At end of command ?				;
0635: E201 28 08                  JR     Z,CommandErrorExit   ;  done if yes						;
0636: E203 E5                     PUSH   HL                   ; Save pointer						;
0637: E204 CD 3B E6               CALL   PrintCharInA         ; Display on console				;
0638: E207 E1                     POP    HL                   ; Restore pointer					;
0639: E208 23                     INC    HL                   ; Update it							;
0640: E209 18 F0                  JR     CommandErrorLoop     ; Keep going						;
0641: E20B         ;
0642: E20B             CommandErrorExit:                      ;
0643: E20B 3E 3F                  LD     A,QMARK              ;
0644: E20D CD 3B E6               CALL   PrintCharInA         ; Send '?' to console				;
0645: E210 CD 46 E6               CALL   PrintCrLf            ; Next Line						;
0646: E213 CD EE E0               CALL   DeleteSubmitFile     ; Remove any submit file			;
0647: E216 C3 26 E0               JP     ccpMainEntry         ; Go back for another command		;
0648: E219         ;------------------------------ Command Error ------------------------------;
0649: E219
0650: E219         ;------------------------------ Command Buffer -----------------------------;
0651: E219             maximumBufferSize EQU    07FH                 ; Max Length of Buffer			;
0652: E219 7F          commandMaxLength: DB     maximumBufferSize    ;
0653: E21A 00          commandLength: DB     00H                  ; Actual size of input			;
0654: E21B             commandBuffer: DS     maximumBufferSize + 1 ; The Command Buffer			;
0655: E29B         ;
0656: E29B 1B E2       commandBufferPointer: DW     commandBuffer        ; Address of next to char		;
0657: E29D         ;------------------------------ Command Buffer -----------------------------;
0658: E29D         ;------------------------- Submit File Control Block -----------------------;
0659: E29D         ;																			;
0660: E29D 00          submitFlag: DB     00H                  ; 00 if no submit file,				;
0661: E29E         ;  0FFH if submitting				;
0662: E29E 24 24 24 09 09     submitFCB: DB     '$$$		'              ; File name is $$$				;
0663: E2A3 53 55 42 20 20 20 20 20     submitType: DB     'SUB     '           ; Type is 'SUB'						;
0664: E2AB 00          submitExtent: DB     00H                  ; Extent							;
0665: E2AC 00          submitS1:  DB     00H                  ; S1								;
0666: E2AD             submitFWF:                      ; Bit7 = FileWriteFlag				;
0667: E2AD 00          submitS2:  DB     00H                  ; S2 (bit7 = FileWriteFlag)			;
0668: E2AE 00          submitRC:  DB     00H                  ; RC								;
0669: E2AF             submitMap: DS     010H                 ; Allocation Map					;
0670: E2BF 00          submitCR:  DB     00H                  ; Current Record					;
0671: E2C0         ;------------------------- Submit File Control Block -----------------------;
0672: E2C0         ;--------------------------- Built In Command Data -------------------------;
0673: E2C0         ;intrinsic function names four characters each								;
0674: E2C0             builtInCMDNameSize EQU    04                   ; Size of intrinsic function names  ;
0675: E2C0         ;
0676: E2C0             builtInCMDNames:                      ;
0677: E2C0 44 49 52 20                DB     'DIR '               ;
0678: E2C4 45 52 41 20                DB     'ERA '               ;
0679: E2C8 54 59 50 45                DB     'TYPE'               ;
0680: E2CC 53 41 56 45                DB     'SAVE'               ;
0681: E2D0 52 45 4E 20                DB     'REN '               ;
0682: E2D4 55 53 45 52                DB     'USER'               ;
0683: E2D8             builtInCMDCount EQU    (($-builtInCMDNames)/builtInCMDNameSize) + 1 ;
0684: E2D8         ;
0685: E2D8             builtInCMDVector:                      ;
0686: E2D8 E6 E2                  DW     ccpDirectory         ; Directory List					;
0687: E2DA 79 E3                  DW     ccpErase             ; File erase						;
0688: E2DC A9 E4                  DW     ccpType              ; Type file on Console				;
0689: E2DE 2B E4                  DW     ccpSave              ; Save memory image					;
0690: E2E0 B6 E3                  DW     ccpRename            ; File rename						;
0691: E2E2 F5 E4                  DW     ccpUser              ; User number						;
0692: E2E4 0C E5                  DW     ccpUserCommand       ; User-defined function				;
0693: E2E6         ;
0694: E2E6         ;--------------------------- Built In Command Data -------------------------;
0695: E2E6
0696: E2E6         ;===========================================================================;
0697: E2E6         ;============================== CCP Commands ===============================;
0698: E2E6         ;===========================================================================;
0699: E2E6
0700: E2E6         ;----------------------------- Directory Listing ---------------------------;
0701: E2E6         ; SYNTAX: DIR afn															;
0702: E2E6         ;																			;
0703: E2E6         ;  The 'DIR' command causes the names of all the files that satisfy the		;
0704: E2E6         ; ambiguous filename afn to be listed on the console device					;
0705: E2E6         ;																			;
0706: E2E6             ccpDirectory:                      ;
0707: E2E6 CD 21 E1               CALL   ParseToken1          ; Token1 gets file name				;
0708: E2E9 CD 82 E6               CALL   SetDiskForCmd        ; Change disk if needed				;
0709: E2EC 21 04 E7               LD     HL,Token1+1          ; Point at 1st char of parameter	;
0710: E2EF 7E                     LD     A,(HL)               ; Get the value						;
0711: E2F0 FE 20                  CP     SPACE                ; Is it Blank ?						;
0712: E2F2 20 07                  JR     NZ,ccpDirQualified   ;  skip there is a parameter		;
0713: E2F4         ;
0714: E2F4         ; set Token1 to all ??? for current disk									;
0715: E2F4 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Set Limit					;
0716: E2F6             ccpDirAll:                      ;
0717: E2F6 36 3F                  LD     (HL),QMARK           ; Put '?' in Token					;
0718: E2F8 23                     INC    HL                   ; Increment pointer					;
0719: E2F9 10 FB                  DJNZ   ccpDirAll            ; Loop till done					;
0720: E2FB         ;
0721: E2FB             ccpDirQualified:                      ;
0722: E2FB AF                     XOR    A                    ; Set Acc to 0						;
0723: E2FC 32 77 E3               LD     (dirFileCount),A     ; Initialize File Count				;
0724: E2FF         ;	LD		(dirCharCount),A			; Initialize char count				;
0725: E2FF CD E9 E6               CALL   FindFirstToken1File  ; Look for directory entry			;
0726: E302 CC 67 E6               CALL   Z,PrintNoFile        ;  if not found send message		;
0727: E305         ;
0728: E305             ccpDirLoopTop:                      ;
0729: E305 28 6D                  JR     Z,ccpDirEnd          ; Exit if directory exhausted		;
0730: E307         ; found, but may be system file												;
0731: E307 3A 28 E7               LD     A,(directoryEntryNumber) ; Get directory entry number		;
0732: E30A 0F                     RRCA                        ;
0733: E30B 0F                     RRCA                        ;
0734: E30C 0F                     RRCA                        ; Multiply by 20H					;
0735: E30D 4F                     LD     C,A                  ;
0736: E30E 06 00                  LD     B,0                  ; BC has index into Dir Buffer		;
0737: E310 DD 21 80 00               LD     IX,DMABuffer         ;
0738: E314 DD 09                  ADD    IX,BC                ; IX Points at the Dir Entry		;
0739: E316 DD CB 0A 7E               BIT    7,(IX+fcbSystemFileIndex) ; Is this a System File				;
0740: E31A 20 4C                  JR     NZ,ccpDirLoopBottom  ;  if yes, Skip to next iteration   ;
0741: E31C         ;
0742: E31C DD E5                  PUSH   IX                   ; IX Points at the Dir Entry		;
0743: E31E AF                     XOR    A                    ;
0744: E31F 32 78 E3               LD     (dirCharCount),A     ; Initialize char count				;
0745: E322         ;
0746: E322 21 77 E3               LD     HL,dirFileCount      ; Point at dirFileCount				;
0747: E325 7E                     LD     A,(HL)               ; Get the dirFileCount				;
0748: E326 34                     INC    (HL)                 ; Increment dirFileCount			;
0749: E327 E6 03                  AND    11B                  ; Perform Mod(E,4)					;
0750: E329 20 14                  JR     NZ,ccpDirDisplayFile0 ; Skip header if not 0				;
0751: E32B         ;
0752: E32B         ; print the header: new Line followed by drive with Colon - A :				;
0753: E32B CD 46 E6               CALL   PrintCrLf            ; New Line						;
0754: E32E C5                     PUSH   BC                   ;
0755: E32F CD 23 E6               CALL   GetSelectedDrive     ; Get Active drive number			;
0756: E332 C1                     POP    BC                   ;
0757: E333 C6 41                  ADD    A,ASCII_A            ; Make it ASCII						;
0758: E335 CD 3B E6               CALL   PrintCharInA         ; Send it to the console		;
0759: E338 3E 3A                  LD     A,COLON              ;
0760: E33A CD 3B E6               CALL   PrintCharInA         ; Send ':' to the console		;
0761: E33D 18 08                  JR     ccpDirDisplayFile    ; Skip ':' display					;
0762: E33F         ;
0763: E33F             ccpDirDisplayFile0:                      ;
0764: E33F CD 37 E6               CALL   PrintSpace           ; Send Space to console				;
0765: E342 3E 3A                  LD     A,COLON              ;
0766: E344 CD 3B E6               CALL   PrintCharInA         ; Send ':' to the console		;
0767: E347             ccpDirDisplayFile:                      ;
0768: E347 CD 37 E6               CALL   PrintSpace           ; Send Space to console				;
0769: E34A         ;
0770: E34A             ccpDirDisplayFileLoop:                      ;
0771: E34A DD E1                  POP    IX                   ; Get to Dir Entry Pointer			;
0772: E34C DD 7E 00               LD     A,(IX+0)             ; Put char in ACC					;
0773: E34F DD 23                  INC    IX                   ; Adjust pointer for next iteration ;
0774: E351 DD E5                  PUSH   IX                   ; Save till then					;
0775: E353 E6 7F                  AND    ASCII_MASK           ; Make sure char is ASCII			;
0776: E355 CD 3B E6               CALL   PrintCharInA         ; Send it to the console			;
0777: E358 21 78 E3               LD     HL,dirCharCount      ; Where are we in Token ?			;
0778: E35B 7E                     LD     A,(HL)               ; Get index							;
0779: E35C 34                     INC    (HL)                 ; Update for next time				;
0780: E35D 47                     LD     B,A                  ; Save count						;
0781: E35E FE 08                  CP     8                    ; End of Name ?						;
0782: E360 CC 37 E6               CALL   Z,PrintSpace         ; Separate Name and Type			;
0783: E363 78                     LD     A,B                  ; Retrieve count					;
0784: E364 FE 0B                  CP     11                   ; At the end of this dir entry ?	;
0785: E366 20 E2                  JR     NZ,ccpDirDisplayFileLoop ;  if no continue the iteration		;
0786: E368         ;
0787: E368             ccpDirLoopBottom:                      ;
0788: E368 DD E1                  POP    IX                   ; Balance stack						;
0789: E36A CD 74 E6               CALL   CheckForConsoleChar  ; Interrupt at keyboard ?			;
0790: E36D 20 05                  JR     NZ,ccpDirEnd         ;  yes, abort directory search		;
0791: E36F CD F4 E6               CALL   SearchForNext        ; Look for more entries				;
0792: E372 18 91                  JR     ccpDirLoopTop        ;  and loop thru					;
0793: E374             ccpDirEnd:                      ;
0794: E374 C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Wrap up and start over			;
0795: E377         ;
0796: E377             dirFileCount:                      ;
0797: E377 00                     DB     0                    ;
0798: E378             dirCharCount:                      ;
0799: E378 00                     DB     0                    ;
0800: E379         ;----------------------------- Directory Listing ---------------------------;
0801: E379
0802: E379         ;-------------------------------- Erase Files ------------------------------;
0803: E379         ; SYNTAX: ERA afn															;
0804: E379         ;																			;
0805: E379         ;  The 'ERA' command removes files from the currently logged-in disk. The   ;
0806: E379         ; files that are erased are those that satisfy the ambiguous filename		;
0807: E379         ; reference afn.															;
0808: E379         ;																			;
0809: E379             ccpErase:                       ;
0810: E379 CD 21 E1               CALL   ParseToken1          ; Parse the command					;
0811: E37C FE 0B                  CP     FILE_NAME_SIZE+FILE_TYPE_SIZE ; All '?'s ?					;
0812: E37E 20 1B                  JR     NZ,ccpEraseFile      ;  skip if not						;
0813: E380         ; Want to be sure															;
0814: E380 01 AB E3               LD     BC,msgEraseAll       ; Point at the message				;
0815: E383 CD 57 E6               CALL   PrintCrLfStringNull  ; Display it on the console			;
0816: E386         ;
0817: E386 CD 65 E0               CALL   ReadCommand          ; Get the operator's response		;
0818: E389 21 1A E2               LD     HL,commandLength     ; Point at size of response			;
0819: E38C 35                     DEC    M                    ; Test the size						;
0820: E38D C2 26 E0               JP     NZ,ccpMainEntry      ; Exit, wrong answer					;
0821: E390 23                     INC    HL                   ; point at the 1 char response		;
0822: E391 7E                     LD     A,(HL)               ; Get it into ACC					;
0823: E392 FE 59                  CP     ASCII_Y              ; Is it 'Y'							;
0824: E394 C2 26 E0               JP     NZ,ccpMainEntry      ;  exit if not						;
0825: E397         ;
0826: E397 23                     INC    HL                   ; Adjust the pointer				;
0827: E398 22 9B E2               LD     (commandBufferPointer),HL ; Restore buffer pointer			;
0828: E39B             ccpEraseFile:                      ;
0829: E39B CD 82 E6               CALL   SetDiskForCmd        ; Change disks for this command		;
0830: E39E 11 03 E7               LD     DE,Token1            ; Point to target FCB				;
0831: E3A1 CD 05 E6               CALL   DeleteFile           ; Call BDOS to delete				;
0832: E3A4 3C                     INC    A                    ; 255 returned if not found			;
0833: E3A5 CC 67 E6               CALL   Z,PrintNoFile        ; Report if file not found			;
0834: E3A8 C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Wrap up and start over			;
0835: E3AB         ;
0836: E3AB             msgEraseAll:                      ;
0837: E3AB 41 4C 4C 20 28 59 2F 4E 29 3F 00                DB     'ALL (Y/N)?',0       ;
0838: E3B6         ;-------------------------------- Erase Files ------------------------------;
0839: E3B6
0840: E3B6         ;-------------------------------- Rename Files -----------------------------;
0841: E3B6         ; SYNTAX: REN ufn1=ufn2														;
0842: E3B6         ;																			;
0843: E3B6         ;  The 'REN' command allows you to change the name of files on disk. The	;
0844: E3B6         ; file satisfying ufn2 is changed to ufn1. The currently logged disk is		;
0845: E3B6         ; assumed to contain the file to rename (ufn2).								;
0846: E3B6             ccpRename:                      ;
0847: E3B6 CD 21 E1               CALL   ParseToken1          ; Get ufn1							;
0848: E3B9 C2 F5 E1               JP     NZ,CommandError      ; Must be unambiguous. No '?'s		;
0849: E3BC 3A 24 E7               LD     A,(selectedDisk)     ; Get saved disk					;
0850: E3BF F5                     PUSH   AF                   ; Save for later compare			;
0851: E3C0 CD 82 E6               CALL   SetDiskForCmd        ; Change disks for this command		;
0852: E3C3 CD E9 E6               CALL   FindFirstToken1File  ; Is ufn1 already there?			;
0853: E3C6 20 4E                  JR     NZ,ccpRenameError3   ;  if yes, report error				;
0854: E3C8         ;
0855: E3C8             ccpRenameFCB1:                      ;
0856: E3C8         ; file doesn't exist, move to second half of FCB							;
0857: E3C8 21 03 E7               LD     HL,Token1            ; Point at FCB for ufn1				;
0858: E3CB 11 13 E7               LD     DE,Token2            ; Point where to put it				;
0859: E3CE 01 10 00               LD     BC,16                ; FCB F1...F8,T1...T3,EXT,S1,S2,RC  ;
0860: E3D1 ED B0                  LDIR   ccpRenameFCB1        ; Move the FCB						;
0861: E3D3         ; check for = or left arrow													;
0862: E3D3 2A 9B E2               LD     HL,(commandBufferPointer) ; Get pointer						;
0863: E3D6         ;	EX		DE,HL															;
0864: E3D6 CD A8 E1               CALL   NextNonBlankChar     ; Get a live character				;
0865: E3D9 FE 3D                  CP     EQUAL_SIGN           ; is it '=' ?						;
0866: E3DB 28 04                  JR     Z,ccpRenameFCB2      ;  do FCB2 if yes					;
0867: E3DD FE 5F                  CP     LEFT_ARROW           ; is it '<-' ?						;
0868: E3DF 20 2F                  JR     NZ,ccpRenameError2   ;  error if no						;
0869: E3E1         ;
0870: E3E1             ccpRenameFCB2:                      ;
0871: E3E1         ;	EX		DE,HL															;
0872: E3E1 23                     INC    HL                   ; Move to start of ufn2				;
0873: E3E2 22 9B E2               LD     (commandBufferPointer),HL ; Save for parser					;
0874: E3E5 CD 21 E1               CALL   ParseToken1          ; Get ufn2							;
0875: E3E8 20 26                  JR     NZ,ccpRenameError2   ; Must be unambiguous. No '?'s		;
0876: E3EA         ;
0877: E3EA F1                     POP    AF                   ; Get saved disk					;
0878: E3EB 47                     LD     B,A                  ; Save a copy						;
0879: E3EC 21 24 E7               LD     HL,selectedDisk      ; Point at current selected disk	;
0880: E3EF 7E                     LD     A,(HL)               ; Get it							;
0881: E3F0 B7                     OR     A                    ; Was it the default disk ?			;
0882: E3F1 28 04                  JR     Z,ccpRename2         ;  skip if yes						;
0883: E3F3         ; drive name was specified.  same one?										;
0884: E3F3 B8                     CP     B                    ; Are they the same ?				;
0885: E3F4 70                     LD     (HL),B               ; Update to new selected disk		;
0886: E3F5 20 19                  JR     NZ,ccpRenameError2   ; Not the same, error exit			;
0887: E3F7             ccpRename2:                      ;
0888: E3F7 70                     LD     (HL),B               ; Update to new selected disk		;
0889: E3F8 AF                     XOR    A                    ; Set ACC = 0						;
0890: E3F9 32 03 E7               LD     (Token1),A           ; FCB2's disk is default			;
0891: E3FC CD E9 E6               CALL   FindFirstToken1File  ; Get ufn2'ss directory Entry		;
0892: E3FF 28 09                  JR     Z,ccpRenameError1    ; Error exit if not there			;
0893: E401         ;
0894: E401 11 03 E7               LD     DE,Token1            ; Point at both FCBs				;
0895: E404 CD 16 E6               CALL   RenameFile           ; Let BDOS do the rename			;
0896: E407 C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Exit gracefully					;
0897: E40A         ;
0898: E40A             ccpRenameError1:                      ;
0899: E40A CD 67 E6               CALL   PrintNoFile          ; Inform operator there is no file	;
0900: E40D C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Exit cleanly						;
0901: E410         ;
0902: E410             ccpRenameError2:                      ;
0903: E410 CD D8 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
0904: E413 C3 F5 E1               JP     CommandError         ; Error exit						;
0905: E416         ;
0906: E416             ccpRenameError3:                      ;
0907: E416 01 1F E4               LD     BC,msgFileExists     ; Load message						;
0908: E419 CD 57 E6               CALL   PrintCrLfStringNull  ; Display message on console		;
0909: E41C C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Exit cleanly						;
0910: E41F         ;
0911: E41F             msgFileExists:                      ;
0912: E41F 46 49 4C 45 20 45 58 49 53 54 53 00                DB     'FILE EXISTS',0      ;
0913: E42B         ;-------------------------------- Rename Files -----------------------------;
0914: E42B
0915: E42B         ;---------------------------------- Save File ------------------------------;
0916: E42B         ; SYNTAX: SAVE n ufn														;
0917: E42B         ;																			;
0918: E42B         ;  The 'SAVE' command places n pages(256-bytes) onto disk from the			;
0919: E42B         ; TPA (Location 0100H) and names the file ufn.								;
0920: E42B         ;
0921: E42B             ccpSave:                        ;
0922: E42B CD A9 E6               CALL   GetNumberFromCmdLine ; Value returned in Acc.			;
0923: E42E F5                     PUSH   AF                   ; Save value						;
0924: E42F CD 21 E1               CALL   ParseToken1          ; Parse to get ufn					;
0925: E432 C2 F5 E1               JP     NZ,CommandError      ; Must be unambiguous. No '?'s		;
0926: E435 CD 82 E6               CALL   SetDiskForCmd        ; Change disks for this command		;
0927: E438 11 03 E7               LD     DE,Token1            ; Get the FCB						;
0928: E43B D5                     PUSH   DE                   ; Save FCB							;
0929: E43C CD 05 E6               CALL   DeleteFile           ; Deleted file if it exists			;
0930: E43F D1                     POP    DE                   ; Restore FCB						;
0931: E440 CD 11 E6               CALL   MakeFile             ; Create a new file on disk			;
0932: E443 28 2F                  JR     Z,ccpSaveError1      ;  exit, no directory space			;
0933: E445 AF                     XOR    A                    ; Set Acc = 0						;
0934: E446 32 23 E7               LD     (currentRecord),A    ; Clear next record field			;
0935: E449 F1                     POP    AF                   ; # pages to write is in Acc		;
0936: E44A 6F                     LD     L,A                  ; 	change to # sectors				;
0937: E44B 26 00                  LD     H,0                  ; Sector size is 512				;
0938: E44D 29                     ADD    HL,HL                ; Sector Count						;
0939: E44E 11 00 01               LD     DE,TPA               ; Initialize Memory pointer			;
0940: E451         ;
0941: E451             ccpSaveWrite:                      ;
0942: E451 7C                     LD     A,H                  ;
0943: E452 B5                     OR     L                    ; If Sector count = 0				;
0944: E453 28 16                  JR     Z,ccpSaveClose       ;  we are finished writing			;
0945: E455 2B                     DEC    HL                   ; Decrement Sector count			;
0946: E456 E5                     PUSH   HL                   ; Sector count						;
0947: E457 21 80 00               LD     HL,cpmRecordSize     ; Get bytes to write				;
0948: E45A 19                     ADD    HL,DE                ; Add to memory pointer				;
0949: E45B E5                     PUSH   HL                   ; memory pointer					;
0950: E45C CD 1E E6               CALL   SetDMA               ; Set DMA							;
0951: E45F 11 03 E7               LD     DE,Token1            ; Point at the FCB					;
0952: E462 CD 0A E6               CALL   WriteSeq             ; Write a sector from DMA			;
0953: E465 D1                     POP    DE                   ; memory pointer					;
0954: E466 E1                     POP    HL                   ; Sector count						;
0955: E467 20 13                  JR     NZ,ccpSaveError2     ; If disk full, exit				;
0956: E469 18 E6                  JR     ccpSaveWrite         ; Keep on writing					;
0957: E46B         ;
0958: E46B         ;
0959: E46B             ccpSaveClose:                      ;
0960: E46B 11 03 E7               LD     DE,Token1            ; Point at the FCB					;
0961: E46E CD F9 E5               CALL   CloseFile            ; Close the File					;
0962: E471 3C                     INC    A                    ; Check return code					;
0963: E472 20 0E                  JR     NZ,ccpSaveExit       ; If OK, clean exit					;
0964: E474         ;
0965: E474             ccpSaveError1:                      ;
0966: E474 01 88 E4               LD     BC,msgNoDirSpace     ; Load Error Message				;
0967: E477 CD 57 E6               CALL   PrintCrLfStringNull  ; Send it to the console			;
0968: E47A 18 06                  JR     ccpSaveExit          ; Do a clean exit					;
0969: E47C             ccpSaveError2:                      ;
0970: E47C 01 9B E4               LD     BC,msgNoDiskSpace    ; Load Error Message				;
0971: E47F CD 57 E6               CALL   PrintCrLfStringNull  ; Send it to the console			;
0972: E482         ;
0973: E482             ccpSaveExit:                      ;
0974: E482 CD 1B E6               CALL   SetDefaultDMA        ; Reset the DMA						;
0975: E485 C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Perform a clean exit				;
0976: E488         ;
0977: E488             msgNoDirSpace:                      ;
0978: E488 4E 4F 20 44 49 52 45 43 54 4F 52 59 20 53 50 41 43 45 00                DB     'NO DIRECTORY SPACE',0 ;
0979: E49B             msgNoDiskSpace:                      ;
0980: E49B 4E 4F 20 44 49 53 4B 20 53 50 41 43 45 00                DB     'NO DISK SPACE',0    ;
0981: E4A9         ;---------------------------------- Save File ------------------------------;
0982: E4A9
0983: E4A9         ;---------------------------------- Type File ------------------------------;
0984: E4A9         ; SYNTAX: TYPE ufn															;
0985: E4A9         ;																			;
0986: E4A9         ;  The 'TYPE' command displays the content of the ASCII source file ufn on  ;
0987: E4A9         ; the currently logged disk at the console device.							;
0988: E4A9         ;
0989: E4A9             ccpType:                        ;
0990: E4A9 CD 21 E1               CALL   ParseToken1          ; Setup the ufn's FCB				;
0991: E4AC C2 F5 E1               JP     NZ,CommandError      ; Must be unambiguous. No '?'s		;
0992: E4AF CD 82 E6               CALL   SetDiskForCmd        ; Change disks for this command		;
0993: E4B2 CD F9 E6               CALL   OpenToken1File       ; Open the file at Token1			;
0994: E4B5 28 2D                  JR     Z,ccpTypeError       ;  error exit if not successful		;
0995: E4B7         ;
0996: E4B7 CD 46 E6               CALL   PrintCrLf            ; Send new  NewLine to console  ;
0997: E4BA         ;
0998: E4BA             ccpTypeRead:                      ;
0999: E4BA 11 03 E7               LD     DE,Token1            ; Point at Token1's FCB				;
1000: E4BD CD FE E5               CALL   DiskRead             ; Read next Record					;
1001: E4C0 20 18                  JR     NZ,ccpTypeEOF        ; Hard End Of File					;
1002: E4C2         ;
1003: E4C2 06 80                  LD     B,cpmRecordSize      ; Load Character count				;
1004: E4C4 0E 02                  LD     C,fConsoleOut        ; Load Function Number				;
1005: E4C6 21 80 00               LD     HL,DMABuffer         ; Point at the read buffer			;
1006: E4C9 E5                     PUSH   HL                   ; Buffer Pointer					;
1007: E4CA             ccpTypeRecord:                      ;
1008: E4CA E1                     POP    HL                   ; Buffer Pointer					;
1009: E4CB 7E                     LD     A,(HL)               ; Get the Character					;
1010: E4CC FE 1A                  CP     END_OF_FILE          ; Are we at EOF ?					;
1011: E4CE CA 94 E6               JP     Z,RestoreDiskAtCmdEnd ;  yes, exit						;
1012: E4D1         ;
1013: E4D1 23                     INC    HL                   ; Increment the Buffer Pointer		;
1014: E4D2 E5                     PUSH   HL                   ; Buffer Pointer					;
1015: E4D3 CD 3B E6               CALL   PrintCharInA         ; Preserve BC						;
1016: E4D6 10 F2                  DJNZ   ccpTypeRecord        ; Iterate over the record		;
1017: E4D8 18 E0                  JR     ccpTypeRead          ; Iterate over the file				;
1018: E4DA         ;
1019: E4DA             ccpTypeEOF:                      ;
1020: E4DA 3D                     DEC    A                    ; Error returned ?					;
1021: E4DB CA 94 E6               JP     Z,RestoreDiskAtCmdEnd ;  no, Restore Disk and exit		;
1022: E4DE 01 EA E4               LD     BC,msgReadErr        ; Load Message						;
1023: E4E1 CD 57 E6               CALL   PrintCrLfStringNull  ; Send it to the console			;
1024: E4E4         ;
1025: E4E4             ccpTypeError:                      ;
1026: E4E4 CD D8 E6               CALL   RestoreDisk          ; Restore Disk						;
1027: E4E7 C3 F5 E1               JP     CommandError         ; Report error and exit				;
1028: E4EA         ;
1029: E4EA             msgReadErr:                      ;
1030: E4EA 52 45 41 44 20 45 52 52 4F 52 00                DB     'READ ERROR',0       ;
1031: E4F5         ;
1032: E4F5         ;---------------------------------- Type File ------------------------------;
1033: E4F5
1034: E4F5         ;------------------------------- User Function -----------------------------;
1035: E4F5         ; SYNTAX: USER n															;
1036: E4F5         ;																			;
1037: E4F5         ;  The User command allows maintenance of separate files in the same		;
1038: E4F5         ; directory. In the syntax line, n is an integer value in the range of 0-15	;
1039: E4F5         ; On cold start, the operator is automatically logged into user area		;
1040: E4F5         ; number 0.																	;
1041: E4F5         ;  The active user number is maintained until changed by a subsequent USER	;
1042: E4F5         ; command, or until a cold start when user 0 is again assumed				;
1043: E4F5         ;
1044: E4F5             ccpUser:                        ;
1045: E4F5 CD A9 E6               CALL   GetNumberFromCmdLine ; Value returned in Acc.			;
1046: E4F8 FE 10                  CP     16                   ; Greater than 16 ?					;
1047: E4FA D2 F5 E1               JP     NC,CommandError      ;  if yes, Error exit				;
1048: E4FD 5F                     LD     E,A                  ; Prepare for SetUser call			;
1049: E4FE 3A 04 E7               LD     A,(Token1)+1         ; Look past the number				;
1050: E501 FE 20                  CP     SPACE                ; Is it a Space ?					;
1051: E503 CA F5 E1               JP     Z,CommandError       ;  yes, error exit					;
1052: E506 CD 2A E6               CALL   SetUser              ; Call BDOS to set new user			;
1053: E509 C3 97 E6               JP     EndCommand           ; Exit cleanly						;
1054: E50C         ;------------------------------- User Function -----------------------------;
1055: E50C
1056: E50C         ;------------------------------- User Command ------------------------------;
1057: E50C             ccpUserCommand:                      ;
1058: E50C 3A 04 E7               LD     A,(Token1)+1         ; Point at start CMD File name		;
1059: E50F FE 20                  CP     SPACE                ; Is it a Space ?					;
1060: E511 20 14                  JR     NZ,ccpUserCmdFileType ;  skip if not						;
1061: E513         ;
1062: E513         ; Disk change A:, B: C: .....												;
1063: E513 3A 24 E7               LD     A,(selectedDisk)     ; Get selected disk					;
1064: E516 B7                     OR     A                    ; Is it the default disk ?			;
1065: E517 CA 97 E6               JP     Z,EndCommand         ; Exit if not						;
1066: E51A 3D                     DEC    A                    ; Adjust so A=>0, B=>1, C=>2		;
1067: E51B 32 27 E7               LD     (currentDisk),A      ; Update current Disk indicator		;
1068: E51E CD 15 E1               CALL   SetPage0CurDisk      ; Set user/disk in page 0			;
1069: E521 CD EE E5               CALL   SelectDisk           ;  Go select this disk				;
1070: E524 C3 97 E6               JP     EndCommand           ; Exit Cleanly						;
1071: E527         ;
1072: E527         ;
1073: E527             ccpUserCmdFileType:                      ;
1074: E527 DD 21 03 E7               LD     IX,Token1            ; Point at Token1					;
1075: E52B DD 7E 09               LD     A,(IX+9)             ; Get 1st char of CMD file type		;
1076: E52E FE 20                  CP     SPACE                ; Is it a SPACE ?					;
1077: E530 C2 F5 E1               JP     NZ,CommandError      ;  Error exit (no type allowed)		;
1078: E533 DD E5                  PUSH   IX                   ; Save Token1 start					;
1079: E535 CD 82 E6               CALL   SetDiskForCmd        ; Change disk if needed				;
1080: E538 DD E1                  POP    IX                   ; Restore Token1 start				;
1081: E53A DD 36 09 43               LD     (IX+9),ASCII_C       ;
1082: E53E DD 36 0A 4F               LD     (IX+10),ASCII_O      ;
1083: E542 DD 36 0B 4D               LD     (IX+11),ASCII_M      ; Set Token1's type to 'COM'		;
1084: E546 CD F9 E6               CALL   OpenToken1File       ; Open the CMD File					;
1085: E549 CA D1 E5               JP     Z,ccpUserCmdError    ;  if error, then exit				;
1086: E54C         ; file opened properly, read it into memory									;
1087: E54C         ;
1088: E54C 21 00 01               LD     HL,TPA               ; Set Read buffer to TPA start		;
1089: E54F             ccpUserCmdReadFile:                      ;
1090: E54F E5                     PUSH   HL                   ; Save current read buffer pointer  ;
1091: E550 EB                     EX     DE,HL                ; Load buffer pointer for BDOS call ;
1092: E551 CD 1E E6               CALL   SetDMA               ; Set the DMA						;
1093: E554 11 03 E7               LD     DE,Token1            ; Point at Token1's FCB				;
1094: E557 CD FE E5               CALL   DiskRead             ; Read int the buffer				;
1095: E55A 20 10                  JR     NZ,ccpUserCmdSetFCBs ;  finished ?, skip					;
1096: E55C         ;
1097: E55C E1                     POP    HL                   ; Get prior Pointer					;
1098: E55D 11 80 00               LD     DE,cpmRecordSize     ; Get Record size					;
1099: E560 19                     ADD    HL,DE                ; Need to make new pointer			;
1100: E561 11 00 E0               LD     DE,CcpBoundary       ;  Are we still in TPA ?			;
1101: E564 7D                     LD     A,L                  ;
1102: E565 93                     SUB    E                    ;
1103: E566 7C                     LD     A,H                  ;
1104: E567 9A                     SBC    A,D                  ;
1105: E568 30 6D                  JR     NC,ccpUserCmdErrorBadLoad ;  no, error exit					;
1106: E56A 18 E3                  JR     ccpUserCmdReadFile   ;  else go for another sector		;
1107: E56C         ;
1108: E56C             ccpUserCmdSetFCBs:                      ;
1109: E56C E1                     POP    HL                   ; Balance the Stack					;
1110: E56D 3D                     DEC    A                    ; Test DiskRead return value		;
1111: E56E 20 67                  JR     NZ,ccpUserCmdErrorBadLoad ;  error exit if problem			;
1112: E570 CD D8 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
1113: E573 CD 21 E1               CALL   ParseToken1          ; Parse FCB1 from command line		;
1114: E576 21 24 E7               LD     HL,selectedDisk      ; Point at selected disk			;
1115: E579 7E                     LD     A,(HL)               ; Get selected disk					;
1116: E57A 32 03 E7               LD     (Token1),A           ;  and put into FCB1				;
1117: E57D CD 1C E1               CALL   ParseToken2          ; Parse FCB2 from command line		;
1118: E580 21 24 E7               LD     HL,selectedDisk      ; Point at selected disk			;
1119: E583 7E                     LD     A,(HL)               ; Get selected disk					;
1120: E584 32 13 E7               LD     (Token2),A           ;  and put into FCB2				;
1121: E587 AF                     XOR    A                    ; Set Acc to 0						;
1122: E588 32 23 E7               LD     (currentRecord),A    ; Initialize record number			;
1123: E58B         ;
1124: E58B 21 03 E7               LD     HL,Token1            ; Set Source						;
1125: E58E 11 5C 00               LD     DE,FCB1              ; Set destination					;
1126: E591 01 21 00               LD     BC,33                ; Set Size							;
1127: E594 ED B0                  LDIR                        ; Move FCBs to Page 0				;
1128: E596 21 1B E2               LD     HL,commandBuffer     ; Point at raw command input		;
1129: E599             ccpUserCmdFindTailStart:                      ;
1130: E599 7E                     LD     A,(HL)               ; Get byte from raw input			;
1131: E59A B7                     OR     A                    ; Are we at end of input ?			;
1132: E59B 28 07                  JR     Z,ccpUserCmdTailSetUp ;  yes, get out of loop				;
1133: E59D FE 20                  CP     SPACE                ; Is it a Space						;
1134: E59F 28 03                  JR     Z,ccpUserCmdTailSetUp ;  yes, get out						;
1135: E5A1 23                     INC    HL                   ; increment the pointer				;
1136: E5A2 18 F5                  JR     ccpUserCmdFindTailStart ; Go back for more					;
1137: E5A4         ;
1138: E5A4             ccpUserCmdTailSetUp:                      ;
1139: E5A4 06 00                  LD     B,0                  ; Initialize Tail Count				;
1140: E5A6 3E 00                  LD     A,0                  ; Marker for end of buffer			;
1141: E5A8 11 80 00               LD     DE,ComTailCount      ; XXXXXXX ComTailChars				;
1142: E5AB         ; ready for the move														;
1143: E5AB             ccpUserCmdTailMove:                      ;
1144: E5AB BE                     CP     (HL)                 ; Are we at end of Buffer ?			;
1145: E5AC 28 07                  JR     Z,ccpUserCmdTailCount ;  skip if yes						;
1146: E5AE 7E                     LD     A,(HL)               ;
1147: E5AF 12                     LD     (DE),A               ;  else move the character			;
1148: E5B0 04                     INC    B                    ; Adjust the count					;
1149: E5B1 23                     INC    HL                   ; Increment the target pointer		;
1150: E5B2 13                     INC    DE                   ; Increment the source pointer		;
1151: E5B3 18 F6                  JR     ccpUserCmdTailMove   ; Go back for more					;
1152: E5B5         ;
1153: E5B5             ccpUserCmdTailCount:                      ;
1154: E5B5 78                     LD     A,B                  ; Get the character count			;
1155: E5B6 32 80 00               LD     (DMABuffer),A        ; XXXXXXX ComTailCount				;
1156: E5B9         ;
1157: E5B9 CD 46 E6               CALL   PrintCrLf            ; Send new line to console		;
1158: E5BC         ; now go to the loaded program												;
1159: E5BC CD 1B E6               CALL   SetDefaultDMA        ; Reset the DMA						;
1160: E5BF CD 06 E1               CALL   SaveUserAndDisk      ; User code saved in page 0			;
1161: E5C2         ; low memory diska contains user code										;
1162: E5C2         ;
1163: E5C2 CD 00 01               CALL   TPA                  ; Go to the loaded program			;
1164: E5C5 31 F0 E7               LD     SP,Stack             ; May come back here, so			;
1165: E5C8 CD 15 E1               CALL   SetPage0CurDisk      ;  we need to clean things			;
1166: E5CB CD EE E5               CALL   SelectDisk           ;  up.								;
1167: E5CE C3 26 E0               JP     ccpMainEntry         ; And go back to CCP				;
1168: E5D1         ;
1169: E5D1             ccpUserCmdError:                      ;
1170: E5D1 CD D8 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
1171: E5D4 C3 F5 E1               JP     CommandError         ; Exit, and report error			;
1172: E5D7         ;
1173: E5D7             ccpUserCmdErrorBadLoad:                      ;
1174: E5D7 01 E0 E5               LD     BC,msgBadLoad        ; Load error message				;
1175: E5DA CD 57 E6               CALL   PrintCrLfStringNull  ; Send message to console			;
1176: E5DD C3 94 E6               JP     RestoreDiskAtCmdEnd  ; Fall thru to end of command		;
1177: E5E0         ;
1178: E5E0             msgBadLoad:                      ;
1179: E5E0 42 41 44 20 4C 4F 41 44 00                DB     'BAD LOAD',0         ;
1180: E5E9         ;
1181: E5E9         ;------------------------------- User Command ------------------------------;
1182: E5E9
1183: E5E9         ;===========================================================================;
1184: E5E9         ;================================ BDOS API =================================;
1185: E5E9         ;===========================================================================;
1186: E5E9
1187: E5E9         ;------------------------------- Initialize --------------------------------;
1188: E5E9             Initialize:                      ;
1189: E5E9 0E 0D                  LD     C,fResetSystem       ; Load Function Number  - 0D		;
1190: E5EB C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1191: E5EE         ;------------------------------- Initialize --------------------------------;
1192: E5EE         ;------------------------------- Select Disk -------------------------------;
1193: E5EE             SelectDisk:                      ;
1194: E5EE 5F                     LD     E,A                  ; Load Target disk					;
1195: E5EF 0E 0E                  LD     C,fSelectDisk        ; Load Function Number - 0EH		;
1196: E5F1 C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1197: E5F4         ;------------------------------- Select Disk -------------------------------;
1198: E5F4         ;-------------------------------- Open File --------------------------------;
1199: E5F4         ;Open the file																;
1200: E5F4         ; On Entry DE = FCB to read													;
1201: E5F4         ; Exits with Z-Flag Set if file not found									;
1202: E5F4         ;					Reset if file found										;
1203: E5F4             OpenFile:                       ;
1204: E5F4 0E 0F                  LD     C,fOpenFile          ; Load Function Number - 0FH		;
1205: E5F6 C3 2F E6               JP     BDOSandIncA          ; make BDOS call & set dir index	;
1206: E5F9         ;-------------------------------- Open File --------------------------------;
1207: E5F9         ;------------------------------- Close File --------------------------------;
1208: E5F9         ;Close the file																;
1209: E5F9         ; On Entry DE = FCB to Close												;
1210: E5F9         ; Exits with Z-Flag Set if file not found									;
1211: E5F9         ;					Reset if file found										;
1212: E5F9             CloseFile:                      ;
1213: E5F9 0E 10                  LD     C,fCloseFile         ; Load Function Number - 10H		;
1214: E5FB C3 2F E6               JP     BDOSandIncA          ; make BDOS call & set dir index	;
1215: E5FE         ;------------------------------- Close File --------------------------------;
1216: E5FE         ;-------------------------------- Read File --------------------------------;
1217: E5FE         ;Read the next record from the file.										;
1218: E5FE         ; On Entry DE = FCB to read													;
1219: E5FE             DiskRead:                       ;
1220: E5FE 0E 14                  LD     C,fReadSeq           ; Load Function Number - 14H		;
1221: E600 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
1222: E603 B7                     OR     A                    ; set return code flags				;
1223: E604 C9                     RET                         ;
1224: E605         ;-------------------------------- Read File --------------------------------;
1225: E605         ;----------------------------- Delete The File -----------------------------;
1226: E605         ;Delete the file given by DE												;
1227: E605             DeleteFile:                      ;
1228: E605 0E 13                  LD     C,fDeleteFile        ; Load Function Number - 13H			;
1229: E607 C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1230: E60A         ;----------------------------- Delete The File -----------------------------;
1231: E60A         ;------------------------------- Disk Write --------------------------------;
1232: E60A         ;Write the next record to the file given by DE								;
1233: E60A             WriteSeq:                       ;
1234: E60A 0E 15                  LD     C,fWriteSeq          ; Load Function Number - 15H		;
1235: E60C CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
1236: E60F B7                     OR     A                    ; set return code flags				;
1237: E610 C9                     RET                         ;
1238: E611         ;------------------------------- Disk Write --------------------------------;
1239: E611         ;-------------------------------- Make File --------------------------------;
1240: E611         ;Make the file given by DE													;
1241: E611             MakeFile:                       ;
1242: E611 0E 16                  LD     C,fMakeFile          ; Load Function Number - 16H		;
1243: E613 C3 2F E6               JP     BDOSandIncA          ; make BDOS call & set dir index	;
1244: E616         ;-------------------------------- Make File --------------------------------;
1245: E616         ;------------------------------- Rename File -------------------------------;
1246: E616         ; Rename a file give by DE													;
1247: E616             RenameFile:                      ;
1248: E616 0E 17                  LD     C,fRenameFile        ; Load Function Number - 17H		;
1249: E618 C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1250: E61B         ;------------------------------- Rename File -------------------------------;
1251: E61B         ;---------------------------- Set (Default) DMA ----------------------------;
1252: E61B         ;Set default buffer DMA address (0080H)										;
1253: E61B             SetDefaultDMA:                      ;
1254: E61B 11 80 00               LD     DE,DMABuffer         ;
1255: E61E         ;---------																	;
1256: E61E         ;Set DMA address to DE														;
1257: E61E             SetDMA:                         ;
1258: E61E 0E 1A                  LD     C,fSetDMA            ; Load Function Number - 1AH		;
1259: E620 C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1260: E623         ;---------------------------- Set (Default) DMA ----------------------------;
1261: E623         ;----------------------------- Get Current Disk ----------------------------;
1262: E623         ;Exits with current drive number to A (0=A,1=B....F=P)						;
1263: E623             GetSelectedDrive:                      ;
1264: E623 0E 19                  LD     C,fGetCurrentDisk    ; Load Function Number - 19H	;
1265: E625 C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1266: E628         ;----------------------------- Get Current Disk ----------------------------;
1267: E628         ;------------------------------ Get/Set User -------------------------------;
1268: E628         ;return current user code in A												;
1269: E628             GetUser:                        ;
1270: E628 1E FF                  LD     E,0FFH               ; Set Entry Parameter for Get		;
1271: E62A         ; If E <> -1 then Set user number found in E								;
1272: E62A             SetUser:                        ;
1273: E62A 0E 20                  LD     C,fGetSetUserNumber  ; Load Function Number - 20H		;
1274: E62C C3 05 00               JP     BDOS                 ;  and let BDOS do its work			;
1275: E62F         ;------------------------------ Get/Set User -------------------------------;
1276: E62F
1277: E62F         ;------------------------------ BDOS and Inc A -----------------------------;
1278: E62F         ; Call B DOS																;
1279: E62F         ;  Store returned directory index											;
1280: E62F         ;  Increment result.														;
1281: E62F         ; Exits with	A =  0 if File Not Found									;
1282: E62F         ;					<> 0 if file found										;
1283: E62F             BDOSandIncA:                      ;
1284: E62F CD 05 00               CALL   BDOS                 ; Make call to BDOS					;
1285: E632 32 28 E7               LD     (directoryEntryNumber),A ; Save return value					;
1286: E635 3C                     INC    A                    ; Increment & (Re)Set Z-Flag		;
1287: E636 C9                     RET                         ;
1288: E637         ;------------------------------ BDOS and Inc A -----------------------------;
1289: E637
1290: E637         ;===========================================================================;
1291: E637         ;=============================== Utilities =================================;
1292: E637
1293: E637         ;===========================================================================;
1294: E637
1295: E637         ;------------------------------- Print Space -------------------------------;
1296: E637             PrintSpace:                      ;
1297: E637 1E 20                  LD     E,SPACE              ; Load Space						;
1298: E639 18 03                  JR     PrintCharInE         ; Go Print it  * Save BC			;
1299: E63B         ;------------------------------- Print Space -------------------------------;
1300: E63B         ;------------------------------- PrintCharInA ------------------------------;
1301: E63B         ; Print character															;
1302: E63B         ; On Entry A = Character to Send to Console									;
1303: E63B             PrintCharInA:                      ;
1304: E63B 5F                     LD     E,A                  ; move char to E					;
1305: E63C 18 00                  JR     PrintCharInE         ;
1306: E63E         ;------------------------------- PrintCharInA ------------------------------;
1307: E63E         ;------------------------------- PrintCharInE ------------------------------;
1308: E63E         ; Print character															;
1309: E63E         ; On Entry E = Character to Send to Console									;
1310: E63E         ; Preserves BC								;								;
1311: E63E             PrintCharInE:                      ;
1312: E63E C5                     PUSH   BC                   ; Preserve BC						;
1313: E63F 0E 02                  LD     C,fConsoleOut        ; Load Function Number				;
1314: E641 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
1315: E644 C1                     POP    BC                   ; Restore BC						;
1316: E645 C9                     RET                         ;
1317: E646         ;------------------------------- PrintCharInE ------------------------------;
1318: E646         ;-------------------------------- CR / LF ----------------------------------;
1319: E646         ;Sent Carriage Return Line Feed to Console									;
1320: E646             PrintCrLf:                      ;
1321: E646 C5                     PUSH   BC                   ; Preserve BC						;
1322: E647 1E 0D                  LD     E,CR                 ; Load Carriage Ceturn				;
1323: E649 0E 02                  LD     C,fConsoleOut        ; Load Function Number				;
1324: E64B CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
1325: E64E 1E 0A                  LD     E,LF                 ; Load Line Feed					;
1326: E650 0E 02                  LD     C,fConsoleOut        ; Load Function Number				;
1327: E652 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
1328: E655 C1                     POP    BC                   ; Restore BC						;
1329: E656 C9                     RET                         ;
1330: E657         ;-------------------------------- CR / LF ----------------------------------;
1331: E657         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1332: E657         ;print CRLF then null terminated string at (BC)								;
1333: E657             PrintCrLfStringNull:                      ;
1334: E657 C5                     PUSH   BC                   ; Save string pointer				;
1335: E658 CD 46 E6               CALL   PrintCrLf            ; Send CR/LF					;
1336: E65B E1                     POP    HL                   ; Restore pointer & fall thru		;
1337: E65C         ;print null terminated string from (HL)										;
1338: E65C             PrintStringNull:                      ;
1339: E65C 7E                     LD     A,(HL)               ; Get the next character			;
1340: E65D B7                     OR     A                    ; Is it the Null terminator ?		;
1341: E65E C8                     RET    Z                    ;  exit if yes						;
1342: E65F 23                     INC    HL                   ; Move string pointer				;
1343: E660 E5                     PUSH   HL                   ; Save for next iteration			;
1344: E661 CD 3B E6               CALL   PrintCharInA         ; Send the character to the console ;
1345: E664 E1                     POP    HL                   ; string pointer					;
1346: E665 18 F5                  JR     PrintStringNull      ; Loop for more						;
1347: E667         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1348: E667         ;-------------------------- Print 'No File' Message ------------------------;
1349: E667         ;print 'no file' message on console										;
1350: E667             PrintNoFile:                      ;
1351: E667 01 6C E6               LD     BC,msgNoFile         ; Point to the message				;
1352: E66A 18 EB                  JR     PrintCrLfStringNull  ; Go print it & return to caller	;
1353: E66C         ;
1354: E66C 4E 4F 20 46 49 4C 45 00     msgNoFile: DB     'NO FILE',0          ;
1355: E674         ;-------------------------- Print 'No File' Message ------------------------;
1356: E674
1357: E674         ;------------------------- Check For Console Input -------------------------;
1358: E674         ;check for a character ready at the console									;
1359: E674         ;Exits with	Z-Flag  set if there has been no character input				;
1360: E674         ;					reset if there is a character waiting					;
1361: E674         ;			A = character input, if Z-Flag reset							;
1362: E674             CheckForConsoleChar:                      ;
1363: E674 0E 0B                  LD     C,fGetConsoleStatus  ; Load Function Number - 0BH		;
1364: E676 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work			;
1365: E679 B7                     OR     A                    ; Check return value				;
1366: E67A C8                     RET    Z                    ; Return if no char waiting			;
1367: E67B         ;
1368: E67B 0E 01                  LD     C,fConsoleIn         ; Load Function Number - 01H		;
1369: E67D CD 05 00               CALL   BDOS                 ; character cleared				;
1370: E680 B7                     OR     A                    ; Resets the Z-Flag					;
1371: E681 C9                     RET                         ;
1372: E682         ;------------------------- Check For Console Input -------------------------;
1373: E682         ;--------------------------- Set Disk For Command --------------------------;
1374: E682         ;change disks for this command, if requested								;
1375: E682             SetDiskForCmd:                      ;
1376: E682 AF                     XOR    A                    ; Set to 0							;
1377: E683 32 03 E7               LD     (Token1),A           ; Set Token's disk to default		;
1378: E686 3A 24 E7               LD     A,(selectedDisk)     ; Get the selected disk				;
1379: E689 B7                     OR     A                    ; Is it also set for default ?		;
1380: E68A C8                     RET    Z                    ;  exit if yes						;
1381: E68B 3D                     DEC    A                    ; Adjust so A=0,B=2....				;
1382: E68C 21 27 E7               LD     HL,currentDisk       ; Point at the current disk			;
1383: E68F BE                     CP     M                    ; Are they the same ?				;
1384: E690 C8                     RET    Z                    ;  exit if yes						;
1385: E691 C3 EE E5               JP     SelectDisk           ;  else go select the disk			;
1386: E694         ;
1387: E694         ;--------------------------- Set Disk For Command --------------------------;
1388: E694         ;------------------------ Restore Disk at Command End ----------------------;
1389: E694         ;Restore disk from before command, fall thru to end of command				;
1390: E694             RestoreDiskAtCmdEnd:                      ;
1391: E694 CD D8 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
1392: E697         ;
1393: E697         ;End of intrinsic command													;
1394: E697             EndCommand:                      ;
1395: E697 CD 21 E1               CALL   ParseToken1          ; Check for garbage at end of line  ;
1396: E69A 3A 04 E7               LD     A,(Token1)+1         ; Point at 1st character			;
1397: E69D D6 20                  SUB    SPACE                ; Get ??							;
1398: E69F 21 24 E7               LD     HL,selectedDisk      ;
1399: E6A2 B6                     OR     M                    ; Are they equal ?					;
1400: E6A3         ; 0 in accumulator if no disk selected, and blank FCB						;
1401: E6A3 C2 F5 E1               JP     NZ,CommandError      ;  no, report error					;
1402: E6A6 C3 26 E0               JP     ccpMainEntry         ;  else go back to the Start		;
1403: E6A9         ;------------------------ Restore Disk at Command End ----------------------;
1404: E6A9
1405: E6A9         ;------------------------ Get Number From Command Line ---------------------;
1406: E6A9         ; Get number from the command line											;
1407: E6A9         ; Exits with A = Value														;
1408: E6A9             GetNumberFromCmdLine:                      ;
1409: E6A9 CD 21 E1               CALL   ParseToken1          ; Get token							;
1410: E6AC 3A 24 E7               LD     A,(selectedDisk)     ; Get currently selected disk		;
1411: E6AF B7                     OR     A                    ; Is it current default disk ?		;
1412: E6B0 C2 F5 E1               JP     NZ,CommandError      ;  no, then error exit				;
1413: E6B3         ; convert the byte value in Token1 to binary								;
1414: E6B3         ;
1415: E6B3 21 00 00               LD     HL,0000              ;
1416: E6B6 01 00 00               LD     BC,0000              ; Clear the registers				;
1417: E6B9         ;
1418: E6B9 DD 21 04 E7               LD     IX,Token1+1          ;
1419: E6BD             CalculateNumber:                      ;
1420: E6BD DD 7E 00               LD     A,(IX+0)             ; Get Character						;
1421: E6C0 DD 23                  INC    IX                   ; Adjust for next time around		;
1422: E6C2 FE 20                  CP     SPACE                ; Terminating character ?			;
1423: E6C4 28 10                  JR     Z,ReturnNumericValue ;  get out if yes					;
1424: E6C6 D6 30                  SUB    ASCII_ZERO           ; Make binary						;
1425: E6C8 FE 0A                  CP     0AH                  ; Is it a digit ?					;
1426: E6CA 30 0A                  JR     NC,ReturnNumericValue ;  get out if no					;
1427: E6CC 29                     ADD    HL,HL                ; Prior value * 2					;
1428: E6CD E5                     PUSH   HL                   ; Move *2							;
1429: E6CE D1                     POP    DE                   ;  to DE							;
1430: E6CF 29                     ADD    HL,HL                ; Prior value * 4					;
1431: E6D0 29                     ADD    HL,HL                ; Prior value * 8					;
1432: E6D1 19                     ADD    HL,DE                ; Add * 2 gives Prior value * 10	;
1433: E6D2 4F                     LD     C,A                  ; Get this digit					;
1434: E6D3 09                     ADD    HL,BC                ; and add it						;
1435: E6D4 18 E7                  JR     CalculateNumber      ;
1436: E6D6         ;
1437: E6D6             ReturnNumericValue:                      ;
1438: E6D6 7D                     LD     A,L                  ; Put result in Acc					;
1439: E6D7 C9                     RET                         ;
1440: E6D8         ;
1441: E6D8         ;------------------------ Get Number From Command Line ---------------------;
1442: E6D8         ;-------------------------------- Restore Disk -----------------------------;
1443: E6D8         ; Restore Disk from before command											;
1444: E6D8             RestoreDisk:                      ;
1445: E6D8 3A 24 E7               LD     A,(selectedDisk)     ; Get disk selected by command		;
1446: E6DB B7                     OR     A                    ; Is it the Default ?				;
1447: E6DC C8                     RET    Z                    ;  yes, the nothing to do			;
1448: E6DD 3D                     DEC    A                    ; Change to 0=A, 1=B....			;
1449: E6DE 21 27 E7               LD     HL,currentDisk       ;
1450: E6E1 BE                     CP     M                    ; Is it the current disk ?			;
1451: E6E2 C8                     RET    Z                    ;  yes, the nothing to do			;
1452: E6E3 3A 27 E7               LD     A,(currentDisk)      ;  else get current disk			;
1453: E6E6 C3 EE E5               JP     SelectDisk           ; Select it							;
1454: E6E9         ;-------------------------------- Restore Disk -----------------------------;
1455: E6E9         ;-------------------------- Find First Token1 Entry ------------------------;
1456: E6E9         ;Search for Token1 file														;
1457: E6E9             FindFirstToken1File:                      ;
1458: E6E9 11 03 E7               LD     DE,Token1            ; Point at Token1					;
1459: E6EC C3 EF E6               JP     SearchForFirst       ; Go look for it					;
1460: E6EF         ;-------------------------- Find First Token1 Entry ------------------------;
1461: E6EF         ;----------------------------- Find First Entry ----------------------------;
1462: E6EF         ;Search for the first directory entry given by DE							;
1463: E6EF         ;Upon entry  DE = FCB														;
1464: E6EF             SearchForFirst:                      ;
1465: E6EF 0E 11                  LD     C,fSearchFirst       ; Load Function Number - 11H		;
1466: E6F1 C3 2F E6               JP     BDOSandIncA          ; make BDOS call & set dir index	;
1467: E6F4         ;----------------------------- Find First Entry ----------------------------;
1468: E6F4         ;----------------------------- Find  Next Entry ----------------------------;
1469: E6F4         ;Search for the next occurrence of the file given DE						;
1470: E6F4         ;Upon entry  DE = FCB														;
1471: E6F4             SearchForNext:                      ;
1472: E6F4 0E 12                  LD     C,fSearchNext        ; Load Function Number - 12H		;
1473: E6F6 C3 2F E6               JP     BDOSandIncA          ; make BDOS call & set dir index	;
1474: E6F9         ;----------------------------- Find  Next Entry ----------------------------;
1475: E6F9         ;----------------------------- Open Token1 File ----------------------------;
1476: E6F9             OpenToken1File:                      ;
1477: E6F9 AF                     XOR    A                    ; Clear Acc							;
1478: E6FA 32 23 E7               LD     (currentRecord),A    ; Initialize  next record for I/O   ;
1479: E6FD 11 03 E7               LD     DE,Token1            ; Point at the FCB					;
1480: E700 C3 F4 E5               JP     OpenFile             ; Let BDOS open the file			;
1481: E703         ;----------------------------- Open Token1 File ----------------------------;
1482: E703
1483: E703         ;*****************************************************************
1484: E703         ;************************ Data Area ******************************
1485: E703         ;*****************************************************************
1486: E703
1487: E703
1488: E703             Token1:    DS     16                   ; Command Token
1489: E713             Token2:    DS     16                   ; Command Token
1490: E723
1491: E723
1492: E723
1493: E723 00          currentRecord: DB     00H                  ; Current record for I/O
1494: E724 00          selectedDisk: DB     00H                  ; Selected disk for current
1495: E725
1496: E725 00 00       tokenStart: DW     0000H                ; Token's pointer
1497: E727 00          currentDisk: DB     00H                  ; Current disk
1498: E728 00          directoryEntryNumber: DB     00H                  ; Index into Directory Buffer
1499: E729
1500: E729             endOfCode:
1501: E729                        ORG    BDOSBase-10H
1502: E7F0             Stack:                          ; Top Of Stack
1503: E7F0
1504: E7F0         ;Z_HighestLocation:
1505: E7F0             ZZ_MemoryLeft EQU    (BDOSBase-1) - endOfCode
           ************************   Xref   ************************
0000: $               E7F0   0683
0073: ASCII_A         0041   0249 0757
0074: ASCII_C         0043   1081
0075: ASCII_M         004D   1083
0037: ASCII_MASK      007F   0775
0076: ASCII_O         004F   1082
0077: ASCII_Y         0059   0823
0060: ASCII_ZERO      0030   1424
0058: ASTERISK        002A   0491
0183: BDOS            0005   0337 1190 1196 1221 1229 1235 1249 1259 1265 1274 1284 1314 1324 1327 1364 1369
1283: BDOSandIncA     E62F   1205 1214 1243 1466 1473
0133: BDOSBase        E800   0134 0136 1501 1505
0102: BDOSE           0005   0103
0134: BDOSEntry       E800
0123: BDOSLength      0E00   0126 0136 0137
0136: BIOSBase        F600
0124: BIOSLength      0A00   0126
0096: BIOSPAGE        0002
0137: BIOSStart       F600
0683: builtInCMDCount 0006   0593
0676: builtInCMDNames E2C0   0589 0683
0674: builtInCMDNameSize 0004   0596 0683
0685: builtInCMDVector E2D8   0267
0033: BYTE            0001
1419: CalculateNumber E6BD   1435
0078: CARET           005E
0216: CcpBoundary     E000   1100
0716: ccpDirAll       E2F6   0719
0767: ccpDirDisplayFile E347   0761
0763: ccpDirDisplayFile0 E33F   0750
0770: ccpDirDisplayFileLoop E34A   0785
0706: ccpDirectory    E2E6   0686
0793: ccpDirEnd       E374   0729 0790
0787: ccpDirLoopBottom E368   0740
0728: ccpDirLoopTop   E305   0792
0721: ccpDirQualified E2FB   0712
0131: CCPEntry        E000   0133 0137 0215
0809: ccpErase        E379   0687
0828: ccpEraseFile    E39B   0812
0122: CCPLength       0800   0126 0133 0137
0245: ccpMainEntry    E026   0330 0647 0820 0824 1167 1402
0255: CcpParseCommand E03C   0243
0846: ccpRename       E3B6   0690
0887: ccpRename2      E3F7   0882
0898: ccpRenameError1 E40A   0892
0902: ccpRenameError2 E410   0868 0875 0886
0906: ccpRenameError3 E416   0853
0855: ccpRenameFCB1   E3C8
0870: ccpRenameFCB2   E3E1   0866
0921: ccpSave         E42B   0689
0959: ccpSaveClose    E46B   0944
0965: ccpSaveError1   E474   0932
0969: ccpSaveError2   E47C   0955
0973: ccpSaveExit     E482   0963 0968
0941: ccpSaveWrite    E451   0956
0224: CcpStart        E000
0989: ccpType         E4A9   0688
1019: ccpTypeEOF      E4DA   1001
1025: ccpTypeError    E4E4   0994
0998: ccpTypeRead     E4BA   1017
1007: ccpTypeRecord   E4CA   1016
1044: ccpUser         E4F5   0691
1169: ccpUserCmdError E5D1   1085
1173: ccpUserCmdErrorBadLoad E5D7   1105 1111
1073: ccpUserCmdFileType E527   1060
1129: ccpUserCmdFindTailStart E599   1136
1089: ccpUserCmdReadFile E54F   1106
1108: ccpUserCmdSetFCBs E56C   1095
1153: ccpUserCmdTailCount E5B5   1145
1143: ccpUserCmdTailMove E5AB   1151
1138: ccpUserCmdTailSetUp E5A4   1132 1134
1057: ccpUserCommand  E50C   0264 0692
1362: CheckForConsoleChar E674   0327 0789
1212: CloseFile       E5F9   0318 0961
0061: COLON           003A   0433 0575 0759 0765
0654: commandBuffer   E21B   0325 0354 0656 1128
0656: commandBufferPointer E29B   0355 0419 0463 0827 0862 0873
0627: CommandError    E1F5   0261 0567 0848 0904 0925 0991 1027 1047 1051 1077 1171 1401 1412
0642: CommandErrorExit E20B   0633 0635
0630: CommandErrorLoop E1FB   0640
0653: commandLength   E21A   0241 0305 0342 0818
0652: commandMaxLength E219   0335
0108: ComTail         0080   0109
0110: ComTailChars    0081
0109: ComTailCount    0080   0110 1141
0185: cpmRecordSize   0080   0306 0947 1003 1098
0053: CR              000D   1322
0040: CTRL_C          0003
0041: CTRL_E          0005
0042: CTRL_H          0008
0043: CTRL_L          000C
0044: CTRL_P          0010
0045: CTRL_R          0012
0046: CTRL_S          0013
0047: CTRL_U          0015
0048: CTRL_X          0018
0049: CTRL_Z          001A
1497: currentDisk     E727   0259 0288 0321 0381 0392 0400 0439 1067 1382 1449 1452
1493: currentRecord   E723   0934 1122 1478
1227: DeleteFile      E605   0380 0831 0929
0371: DeleteSubmitFile E0EE   0329 0333 0646
0798: dirCharCount    E378   0744 0777
1498: directoryEntryNumber E728   0731 1285
0796: dirFileCount    E377   0723 0746
1219: DiskRead        E5FE   0300 1000 1094
0113: DMABuffer       0080   0256 0304 0737 1005 1155 1254
0056: DOLLAR          0024
0117: END_OF_FILE     001A   1010
1394: EndCommand      E697   1053 1065 1070
1500: endOfCode       E729   1505
0038: EndOfMessage    0000
0065: EQUAL_SIGN      003D   0569 0865
0030: FALSE           0000
0105: FCB1            005C   0106 1125
0106: FCB2            006C
0186: fcbSystemFileIndex 000A   0739
0200: fCloseFile      0010   1213
0191: fConsoleIn      0001   1368
0192: fConsoleOut     0002   1004 1313 1323 1326
0203: fDeleteFile     0013   1228
0195: fGetConsoleStatus 000B   1363
0209: fGetCurrentDisk 0019   1264
0208: fGetLoginVector 0018
0211: fGetSetUserNumber 0020   1273
0196: fGetVersion     000C
0187: FILE_NAME_SIZE  0008   0450 0466 0715 0811
0188: FILE_TYPE_SIZE  0003   0454 0466 0715 0811
0542: FillWithAcc     E1A3   0461 0545
0540: FillWithSpace   E1A1   0509 0530
1457: FindFirstToken1File E6E9   0725 0852 0891
0206: fMakeFile       0016   1242
0199: fOpenFile       000F   1204
0486: FormatElement   E178   0451 0456 0500
0496: FormatElement1  E186   0492
0499: FormatElement2  E188   0494
0193: fPrintString    0009
0204: fReadSeq        0014   1220
0194: fReadString     000A   0336
0207: fRenameFile     0017   1248
0197: fResetSystem    000D   1189
0201: fSearchFirst    0011   1465
0202: fSearchNext     0012   1472
0198: fSelectDisk     000E   1195
0210: fSetDMA         001A   1258
0205: fWriteSeq       0015   1234
1408: GetNumberFromCmdLine E6A9   0922 1045
1263: GetSelectedDrive E623   0248 0258 0755
1269: GetUser         E628   0387
0066: GREATER_THAN    003E   0251 0581
0055: HASH_TAG        0023
1188: Initialize      E5E9   0234
0588: IntrinsicFunction E1D0   0266
0591: IntrinsicFunction1 E1D5   0619
0597: IntrinsicFunction2 E1DE   0604
0612: IntrinsicFunction3 E1EE   0600 0615
0617: IntrinsicFunction4 E1F2   0608
0097: IOBYTE          0003
0562: IsItADelimiter  E1B1   0487 0503
0523: IsItDot         E195   0455
0069: LEFT_ARROW      005F   0867
0126: LengthInBytes   2000   0127 0131
0127: LengthInK       0009
0064: LESS_THAN       003C   0579
0052: LF              000A   1325
0031: LO_NIBBLE_MASK  000F   0238
1241: MakeFile        E611   0931
0651: maximumBufferSize 007F   0652 0654
0129: MemorySize      0040   0131
1178: msgBadLoad      E5E0   1174
0836: msgEraseAll     E3AB   0814
0911: msgFileExists   E41F   0907
0977: msgNoDirSpace   E488   0966
0979: msgNoDiskSpace  E49B   0970
1354: msgNoFile       E66C   1351
1029: msgReadErr      E4EA   1022
0550: NextNonBlankChar E1A8   0420 0557 0864
0340: NoRead          E0D0   0328
0332: NotSubmitFile   E0BF   0286 0295 0301 0319
1203: OpenFile        E5F4   0294 1480
1476: OpenToken1File  E6F9   0993 1084
0508: PadTheElement   E191   0488
0414: ParseToken      E124   0411
0412: ParseToken1     E121   0260 0707 0810 0847 0874 0924 0990 1113 1395 1409
0409: ParseToken2     E11C   1117
0057: PERCENT         0025
0059: PERIOD          002E   0526 0573
0100: Pg0CurentDisk   0004   0239 0394 0401
0099: Pg0CurentUser   0004   0100
1303: PrintCharInA    E63B   0250 0252 0637 0644 0758 0760 0766 0776 1015 1344
1311: PrintCharInE    E63E   1298 1305
1320: PrintCrLf       E646   0247 0628 0645 0753 0996 1157 1335
1333: PrintCrLfStringNull E657   0815 0908 0967 0971 1023 1175 1352
1350: PrintNoFile     E667   0726 0833 0899
1296: PrintSpace      E637   0764 0768 0782
1338: PrintStringNull E65C   0326 1346
0067: QMARK           003F   0468 0493 0643 0717
0469: QuestionMarkCount E16E   0475
0474: QuestionMarkCount1 E173   0472
0093: RAM             0000   0095 0096 0097 0099 0102 0105 0108 0113 0115
0283: ReadCommand     E065   0253 0817
1247: RenameFile      E616   0895
1444: RestoreDisk     E6D8   0903 1026 1112 1170 1391
1390: RestoreDiskAtCmdEnd E694   0794 0834 0896 0900 0909 0975 1011 1021 1176
1437: ReturnNumericValue E6D6   1423 1426
0070: RUBOUT          007F
0386: SaveUserAndDisk E106   0334 1160
1464: SearchForFirst  E6EF   1459
1471: SearchForNext   E6F4   0791
1193: SelectDisk      E5EE   0240 0291 0323 0378 0382 1069 1166 1385 1453
1494: selectedDisk    E724   0262 0418 0445 0849 0879 1063 1114 1118 1378 1398 1410 1445
0063: SEMICOLON       003B   0577
1253: SetDefaultDMA   E61B   0974 1159
1375: SetDiskForCmd   E682   0708 0829 0851 0926 0992 1079
1257: SetDMA          E61E   0257 0950 1092
0449: SetFileName     E150   0441
0399: SetPage0CurDisk E115   0338 1068 1165
0453: SetType         E155
1272: SetUser         E62A   0232 1052
0054: SPACE           0020   0541 0554 0566 0607 0632 0711 1050 1059 1076 1133 1297 1397 1422
1502: Stack           E7F0   0225 0246 1164
0670: submitCR        E2BF   0298
0664: submitExtent    E2AB
0662: submitFCB       E29E   0293 0299 0317 0379
0660: submitFlag      E29D   0235 0284 0372
0666: submitFWF       E2AD   0310
0669: submitMap       E2AF
0668: submitRC        E2AE   0296 0315
0665: submitS1        E2AC
0667: submitS2        E2AD
0663: submitType      E2A3
0051: TAB             0009
1488: Token1          E703   0413 0595 0709 0830 0857 0890 0894 0927 0951 0960 0999 1049 1058 1074 1093 1116 1124 1377 1396 1418 1458 1479
1489: Token2          E713   0410 0858 1120
1496: tokenStart      E725   0421 0629
0103: TopRAM          0007
0115: TPA             0100   0939 1088 1163
0029: TRUE            FFFF
0502: TruncateElement E18A   0506
0068: UNDER_SCORE     005F   0571
0361: UpCase          E0E5   0347
0344: UpCaseLoop      E0D4   0349
0438: UseCurrentDisk  E143   0428
0443: UseTokensDisk   E14A   0434
0095: WarmBoot        0000
0034: WORD            0002
1233: WriteSeq        E60A   0952
1505: ZZ_MemoryLeft   00D6
