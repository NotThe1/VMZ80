0001: E000         ;     File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
0002: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm
0003: E000
0004: E000         ; Intrinsic Commands
0005: E000         ;	DIR
0006: E000
0007: E000         ; CCP.Z80
0008: E000         ;
0009: E000         ; 2019-02-19 Started to refactor to Z80 idiom
0010: E000
0011: E000         ; 2017-03-02 Refactored the CP/M Suite
0012: E000         ; 2014-01-16
0013: E000         ; 2014-05-01  :  Frank Martyn
0014: E000
0015: E000         ; replace systemFile with fcbSystemFileIndex
0016: E000
0017: E000                        Include ./stdHeader.Z80
0018: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0019: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0020: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0021: E000         ; stdHeader.asm
0022: E000         ; standard equates
0023: E000
0024: E000         ; 2017-03-02 Refactored the CP/M Suite
0025: E000
0026: E000
0027: E000             TRUE       EQU    -1                   ; not false
0028: E000             FALSE      EQU    0000H
0029: E000             ON         EQU    -1
0030: E000             OFF        EQU    0000H
0031: E000             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0032: E000
0033: E000             BYTE       EQU    1                    ; number of bytes for "byte" type
0034: E000             WORD       EQU    2                    ; number of bytes for "word" type
0035: E000
0036: E000
0037: E000             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0038: E000             ZERO       EQU    00H                  ; Zero
0039: E000             EndOfMessage EQU    00H
0040: E000
0041: E000             CTRL_C     EQU    03H                  ; ETX
0042: E000             CTRL_E     EQU    05H                  ; physical eol
0043: E000             CTRL_H     EQU    08H                  ; backspace
0044: E000             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0045: E000             CTRL_L     EQU    0CH                  ; FF - Form feed
0046: E000             CTRL_P     EQU    10H                  ; prnt toggle
0047: E000             CTRL_R     EQU    12H                  ; repeat line
0048: E000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0049: E000             CTRL_U     EQU    15H                  ; line delete
0050: E000             CTRL_X     EQU    18H                  ; =ctl-u
0051: E000             CTRL_Z     EQU    1AH                  ; end of file
0052: E000
0053: E000             NULL       EQU    00H                  ; Null
0054: E000             SOH        EQU    01H                  ; Start of Heading
0055: E000             BELL       EQU    07H                  ; Bell
0056: E000             TAB        EQU    09H                  ; Tab
0057: E000             LF         EQU    0AH                  ; Line Feed
0058: E000             CR         EQU    0DH                  ; Carriage Return
0059: E000             SPACE      EQU    20H                  ; Space
0060: E000             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0061: E000             HASH_TAG   EQU    23H                  ; Sharp sign #
0062: E000             DOLLAR     EQU    24H                  ; Dollar Sign
0063: E000             PERCENT    EQU    25H                  ; Percent Sign
0064: E000             L_PAREN    EQU    28H                  ; Left Paenthesis (
0065: E000             R_PAREN    EQU    29H                  ; Right Paenthesis )
0066: E000             ASTERISK   EQU    2AH                  ; Asterisk *
0067: E000             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0068: E000             COMMA      EQU    2CH                  ; Comma
0069: E000             DASH       EQU    2DH                  ; Dash Hyphen -
0070: E000             PERIOD     EQU    2EH                  ; Period
0071: E000             SLASH      EQU    2FH                  ; /
0072: E000             ASCII_ZERO EQU    30H                  ; zero
0073: E000             COLON      EQU    3AH                  ; Colon
0074: E000
0075: E000             SEMICOLON  EQU    3BH                  ; Semi Colon
0076: E000             LESS_THAN  EQU    3CH                  ; Less Than <
0077: E000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0078: E000             GREATER_THAN EQU    3EH                  ; Greater Than >
0079: E000             QMARK      EQU    3FH                  ; Question Mark
0080: E000             UNDER_SCORE EQU    5FH                  ; under score _
0081: E000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0082: E000             RUBOUT     EQU    7FH                  ; Delete Key
0083: E000
0084: E000
0085: E000             ASCII_A    EQU    'A'
0086: E000             ASCII_C    EQU    'C'
0087: E000             ASCII_K    EQU    'K'
0088: E000             ASCII_N    EQU    'N'
0089: E000             ASCII_Q    EQU    'Q'
0090: E000             ASCII_R    EQU    'R'
0091: E000             ASCII_W    EQU    'W'
0092: E000             ASCII_Y    EQU    'Y'
0093: E000             CARET      EQU    '^'
0094: E000             ASCII_LO_A EQU    'a'
0095: E000             ASCII_LO_K EQU    'k'
0096: E000             ASCII_LO_P EQU    'p'
0097: E000             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0098: E000
0099: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0100: E000                        Include ./osHeader.Z80
0101: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0102: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0103: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0104: E000         ; osHeader.Z80
0105: E000
0106: E000         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0107: E000         ; 2017-03-02 Refactored the CP/M Suite
0108: E000
0109: E000         ; Contains the Equates used by the CP/M system
0110: E000
0111: E000         ;------------------------Page Zero Constants ---------------------------------
0112: E000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0113: E000
0114: E000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0115: E000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0116: E000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0117: E000
0118: E000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0119: E000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0120: E000
0121: E000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0122: E000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0123: E000
0124: E000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0125: E000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0126: E000
0127: E000             ComTail    EQU    RAM + 080H           ; Complete command tail
0128: E000             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0129: E000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0130: E000         ;-----------------------------------------------------------------------
0131: E000
0132: E000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0133: E000         ;-----------------------------------------------------------------------
0134: E000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0135: E000         ;-----------------------------------------------------------------------
0136: E000             END_OF_FILE EQU    1AH                  ; end of file
0137: E000         ;-----------------------------------------------------------------------
0138: E000
0139: E000         ;--------------- CP/M Constants -----------------------------------------
0140: E000
0141: E000             CCPLength  EQU    0800H                ; Constant
0142: E000             BDOSLength EQU    0E00H                ; Constant 0E00H
0143: E000             BIOSLength EQU    0A00H                ; Constant 0900H
0144: E000
0145: E000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0146: E000             LengthInK  EQU    (LengthInBytes/1024) + 1
0147: E000
0148: E000             MemorySize EQU    64
0149: E000
0150: E000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0151: E000
0152: E000             BDOSBase   EQU    CCPEntry + CCPLength
0153: E000             BDOSEntry  EQU    BDOSBase
0154: E000
0155: E000             BIOSBase   EQU    BDOSBase + BDOSLength
0156: E000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0157: E000         ;-----------------------------------------------------------------------
0158: E000
0159: E000         ;------------------- BDOS System Call Equates --------------------------
0160: E000             fConsoleIn EQU    01H                  ; rcharf - Console Input
0161: E000             fConsoleOut EQU    02H                  ; pcharf - Console Output
0162: E000             fPrintString EQU    09H                  ; pbuff	- Print String
0163: E000             fReadString EQU    0AH                  ; rbuff	- Read Console String
0164: E000             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0165: E000             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0166: E000             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0167: E000             fSelectDisk EQU    0EH                  ; self	- Select Disk
0168: E000             fOpenFile  EQU    0FH                  ; openf	- Open File
0169: E000             fCloseFile EQU    10H                  ; closef - Close File
0170: E000             fSearchFirst EQU    11H                  ; searf	- Search For First
0171: E000             fSearchNext EQU    12H                  ; searnf - Search for Next
0172: E000             fDeleteFile EQU    13H                  ; delf - Delete File
0173: E000             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0174: E000             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0175: E000             fMakeFile  EQU    16H                  ; makef	- Make File
0176: E000             fRenameFile EQU    17H                  ; renf	- Rename File
0177: E000             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0178: E000             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0179: E000             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0180: E000             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0181: E000         ;-----------------------------------------------------------------------
0182: E000
0183: E000
0184: E000
0185: E000
0186: E000
0187: E000         ;*******************************************************************************
0188: E000         ; These are the values handed over by the BDOS when it calls the Writer operation
0189: E000         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0190: E000         ; unallocated allocation block (it only indicates this for the first 128 byte
0191: E000         ; sector write) or to an allocation block that has already been allocated to a
0192: E000         ; file. The BDOS also indicates if it is set to write to the file directory
0193: E000         ;*******************************************************************************
0194: E000             WriteAllocated EQU    00H
0195: E000             WriteDirectory EQU    01H
0196: E000             WriteCleanBuffer EQU    02H
0197: E000
0198: E000
0199: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0200: E000                        Include ./diskHeader.Z80
0201: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0202: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0203: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0204: E000         ; diskHeader.asm
0205: E000
0206: E000         ; 2017-03-02 Refactored the CP/M Suite
0207: E000
0208: E000         ; needs osHeader.asm declared before this is used !!!!!!!
0209: E000
0210: E000         ; Contains the Equates used by the CP/M system to handle disks
0211: E000
0212: E000
0213: E000         ;*******************************************************************************
0214: E000         ;
0215: E000         ;     Disk related values
0216: E000         ;
0217: E000         ;
0218: E000         ;*******************************************************************************
0219: E000             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0220: E000             DiskControlByte EQU    045H                 ; control byte for disk I/O
0221: E000             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0222: E000         ; for boot
0223: E000             DiskControlTable EQU    0040H
0224: E000
0225: E000             DiskReadCode EQU    01H                  ; Code for Read
0226: E000             DiskWriteCode EQU    02H                  ; Code for Write
0227: E000
0228: E000
0229: E000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0230: E000             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0231: E000             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0232: E000
0233: E000             DirEntrySize EQU    20H                  ; (32)
0234: E000             DirBuffSize EQU    cpmRecordSize
0235: E000
0236: E000             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0237: E000
0238: E000             RecordsPerExtent EQU    080H                 ; extent Record capacity
0239: E000
0240: E000
0241: E000         ;-------------------------------------------------------------------------------------
0242: E000             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0243: E000
0244: E000         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0245: E000             NumberOfHeads EQU    02H                  ; number of heads
0246: E000             TracksPerHead EQU    50H                  ; 80
0247: E000             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0248: E000             SectorsPerBlock EQU    04H                  ; 2048 bytes
0249: E000             DirectoryBlockCount EQU    02H                  ;
0250: E000         ;-----------------------------------------------------------------------
0251: E000
0252: E000             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0253: E000
0254: E000             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0255: E000
0256: E000             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0257: E000             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0258: E000             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0259: E000
0260: E000             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0261: E000             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0262: E000             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0263: E000             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0264: E000
0265: E000         ;-----------------------------------------------------------------------
0266: E000         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0267: E000         ;-----------------------------------------------------------------------
0268: E000         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0269: E000             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0270: E000             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0271: E000             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0272: E000             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0273: E000             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0274: E000             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0275: E000             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0276: E000             dpb3hdAL1  EQU    00H                  ;  for each file directory
0277: E000             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0278: E000             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0279: E000             dpb3hdNOH  EQU    NumberOfHeads
0280: E000
0281: E000         ;*******************************************************************************
0282: E000
0283: E000             SectorMask EQU    SectorsPerBlock - 1
0284: E000
0285: E000         ;***************************************************************************
0286: E000
0287: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0288: E000
0289: E000             BDOS       EQU    0005H                ; BDOS Vector in Page 00000
0290: E000
0291: E000             fcbSystemFileIndex EQU    0AH                  ; extent number field index
0292: E000             FILE_NAME_SIZE EQU    08H                  ; Max size of file Name
0293: E000             FILE_TYPE_SIZE EQU    03H                  ; Max size of file Type
0294: E000
0295: E000             ASCII_M    EQU    'M'
0296: E000             ASCII_O    EQU    'O'
0297: E000
0298: E000                        ORG    CCPEntry
0299: E000             CcpBoundary EQU    $
0300: E000         ;========================== CCP Entry ======================================;
0301: E000
0302: E000         ; 	JP		CcpStart						;start ccp with possible initial command
0303: E000         ;*****************************************************************
0304: E000         ;enter here from boot loader
0305: E000         ; On Entry	C(HiNibble) = User Number
0306: E000         ;			C(LoNibble) = Disk (0=A, 1=B...F=P)
0307: E000             CcpStart:
0308: E000 31 F0 E7               LD     SP,Stack             ; Set CCP's Stack
0309: E003 C5                     PUSH   BC                   ; Save Disk Number
0310: E004 59                     LD     E,C                  ; Get User Number
0311: E005 CB 3B                  SRL    E
0312: E007 CB 3B                  SRL    E                    ; Move user number
0313: E009 CB 3B                  SRL    E                    ;  to Lo Nibble
0314: E00B CB 3B                  SRL    E
0315: E00D CD 25 E6               CALL   SetUser              ; Set initial User
0316: E010         ; Initialize will completely reset the disk file system
0317: E010 CD 02 E6               CALL   Initialize           ; A = 0FFH if Submit file found
0318: E013 32 B0 E2               LD     (submitFlag),A       ; Save return value in Flag
0319: E016 C1                     POP    BC                   ; Recall disk number
0320: E017 79                     LD     A,C                  ; Put into Acc
0321: E018 E6 0F                  AND    LO_NIBBLE_MASK       ; Remove User Number
0322: E01A 32 04 00               LD     (Pg0CurentDisk),A    ; Puts disk number into Page 0
0323: E01D CD 07 E6               CALL   SelectDisk           ; Set default Disk From Acc											; check for initial command
0324: E020 3A 2D E2               LD     A,(commandLength)
0325: E023 B7                     OR     A                    ; See if there is a Command
0326: E024 20 16                  JR     NZ,CcpParseCommand   ;  Skip if yes
0327: E026
0328: E026             ccpMainEntry:
0329: E026 31 F0 E7               LD     SP,Stack             ; (re)Establish CCP's Stack
0330: E029 CD 85 E6               CALL   CrLf                 ; Send CRLF to the Console
0331: E02C CD 1E E6               CALL   GetSelectedDrive     ; Get current disk number
0332: E02F C6 41                  ADD    A,ASCII_A            ; Make ASCII form of Drive
0333: E031 CD 8E E6               CALL   PrintCharInA         ; Send Drive letter to console
0334: E034 3E 3E                  LD     A,GREATER_THAN       ; Load '>'
0335: E036 CD 8E E6               CALL   PrintCharInA         ; Send to Console
0336: E039 CD 65 E0               CALL   ReadCommand          ; Command Buffer filled, Pointer set
0337: E03C
0338: E03C             CcpParseCommand:
0339: E03C 11 80 00               LD     DE,DMABuffer         ; Default in page 0
0340: E03F CD 4B E6               CALL   SetDMA               ; Set the DMA address
0341: E042 CD 1E E6               CALL   GetSelectedDrive     ; Get current drive
0342: E045 32 6B E7               LD     (currentDisk),A      ; Save
0343: E048 CD 26 E1               CALL   ParseToken1          ; Get first token in command buffer
0344: E04B C4 06 E2               CALL   NZ,CommandError      ; The name must be unambiguous
0345: E04E 3A 68 E7               LD     A,(selectedDisk)     ; Get the Disk:
0346: E051 B7                     OR     A                    ; If not default,
0347: E052 C2 25 E5               JP     NZ,ccpUserCommand    ;   must be user CMD
0348: E055
0349: E055 CD DC E1               CALL   IntrinsicFunction    ; Get CMD index into ACC
0350: E058 21 E9 E2               LD     HL,builtInCMDVector  ; Base of Vector
0351: E05B 5F                     LD     E,A
0352: E05C 16 00                  LD     D,0                  ; Index in DE
0353: E05E 19                     ADD    HL,DE
0354: E05F 19                     ADD    HL,DE                ; Vector is a word, need 2 ADDs
0355: E060 7E                     LD     A,(HL)               ; Pointing at Address
0356: E061 23                     INC    HL
0357: E062 66                     LD     H,(HL)
0358: E063 6F                     LD     L,A                  ; Get address to HL
0359: E064 E9                     JP     (HL)                 ;  Go to the Function
0360: E065
0361: E065
0362: E065         ;------------------------------ Read Command -------------------------------;
0363: E065         ;
0364: E065         ;read the next command into the command buffer                             ;
0365: E065         ;check for submit file                                                     ;
0366: E065             ReadCommand:                      ;
0367: E065 3A B0 E2               LD     A,(submitFlag)       ; Get the Submit File Flag          ;
0368: E068 B7                     OR     A                    ; Is it Set ?                       ;
0369: E069 CA C4 E0               JP     Z,NotSubmitFile      ;  skip if not                      ;
0370: E06C         ; scanning a submit file change drives to open and read the file            ;
0371: E06C 3A 6B E7               LD     A,(currentDisk)      ; Get current disk                  ;
0372: E06F B7                     OR     A                    ; Is it default ?                   ;
0373: E070 3E 00                  LD     A,0                  ; Prepare to set Disk A             ;
0374: E072 C4 07 E6               CALL   NZ,SelectDisk        ; Select it if needed               ;
0375: E075         ; have to open again in case xsub present                                   ;
0376: E075 11 B1 E2               LD     DE,submitFCB         ; Point at the Submits's FCB        ;
0377: E078 CD 0D E6               CALL   OpenFile             ; Open it                           ;
0378: E07B CA C4 E0               JP     Z,NotSubmitFile      ; Skip if no submit file present    ;
0379: E07E 3A BF E2               LD     A,(submitRC)         ; Get Number of records in file     ;
0380: E081 3D                     DEC    A                    ; read last record(s) first     ;
0381: E082 32 D0 E2               LD     (submitCR),A         ; current record to read            ;
0382: E085 11 B1 E2               LD     DE,submitFCB         ; Point at the Submits's FCB        ;
0383: E088 CD 17 E6               CALL   DiskRead             ; Read from back to front           ;
0384: E08B C2 C4 E0               JP     NZ,NotSubmitFile     ; Skip EOF ??                       ;
0385: E08E         ;
0386: E08E         ; disk read is OK, transfer to commandBuffer                                ;
0387: E08E 21 80 00               LD     HL,DMABuffer         ; From                              ;
0388: E091 11 2D E2               LD     DE,commandLength     ; TO	                            ;
0389: E094 01 80 00               LD     BC,cpmRecordSize     ; For this many bytes               ;
0390: E097 ED B0                  LDIR                        ; Move to command buffer            ;
0391: E099         ;	LD		B,cpmRecordSize					; number of bytes to Copy       ;
0392: E099         ;	CALL	CopyHL2DEforBXX                                                   ;
0393: E099         ;
0394: E099         ; line is transferred, close the file with a deleted record                 ;
0395: E099 21 BE E2               LD     HL,submitFWF         ; Point at the WriteFileFlag        ;
0396: E09C CB BE                  RES    7,(HL)               ; Clear the WriteFileFlag                   ;
0397: E09E         ;	LD		HL,submitFWF				; Bit 7 is FileWriteFlag            ;
0398: E09E         ;	LD		(HL),0						                                    ;
0399: E09E         ;	INC		HL                                                              ;
0400: E09E 21 BF E2               LD     HL,submitRC          ; Point at FCB record Count         ;
0401: E0A1 35                     DEC    M                    ; Make it one less record           ;
0402: E0A2 11 B1 E2               LD     DE,submitFCB         ; Point at the Submits's FCB        ;
0403: E0A5 CD 12 E6               CALL   CloseFile            ; Close it                          ;
0404: E0A8 CA C4 E0               JP     Z,NotSubmitFile      ; Skip if not clean close           ;
0405: E0AB         ; CloseFile went ok, return to original drive                               ;
0406: E0AB 3A 6B E7               LD     A,(currentDisk)      ; Get the current disk              ;
0407: E0AE B7                     OR     A                    ; Is it the default disk ?          ;
0408: E0AF C4 07 E6               CALL   NZ,SelectDisk        ;  no, then go select it            ;
0409: E0B2         ; print to the 00                                                           ;
0410: E0B2 21 2E E2               LD     HL,commandBuffer     ; Point at the command buffer       ;
0411: E0B5 CD 9E E6               CALL   PrintStringNull      ; Display it on the Console         ;
0412: E0B8 CD B8 E6               CALL   CheckForConsoleChar  ; User input a character ?          ;
0413: E0BB CA D5 E0               JP     Z,NoRead             ;  skip if not                      ;
0414: E0BE CD F3 E0               CALL   DeleteSubmitFile     ; Remove file and reset submit flag ;
0415: E0C1 C3 26 E0               JP     ccpMainEntry         ; Start a new CCP session           ;
0416: E0C4         ;   ---     ------------                ;-----------------------------------;
0417: E0C4             NotSubmitFile:                      ;
0418: E0C4 CD F3 E0               CALL   DeleteSubmitFile     ; Delete any submit file            ;
0419: E0C7 CD 0B E1               CALL   SaveUserAndDisk      ; Save User & Disk to page 0        ;
0420: E0CA 11 2C E2               LD     DE,commandMaxLength  ; Point to Start of Buffer          ;
0421: E0CD 0E 0A                  LD     C,fReadString        ; Load Function Number	            ;
0422: E0CF CD 05 00               CALL   BDOS                 ;  and let BDOS do its work	        ;
0423: E0D2 CD 1A E1               CALL   SetPage0CurDisk      ; No Cntl C, so restore Pg0CurentDis;
0424: E0D5         ;
0425: E0D5             NoRead:                         ;
0426: E0D5         ; set the last character to zero for later scans                            ;
0427: E0D5 21 2D E2               LD     HL,commandLength     ; Point to length of command        ;
0428: E0D8 46                     LD     B,(HL)               ; Put it into B                     ;
0429: E0D9             UpCaseLoop:                      ;
0430: E0D9 23                     INC    HL                   ; Point at next byte in buffer      ;
0431: E0DA 7E                     LD     A,(HL)               ; Get the Character                 ;
0432: E0DB CD EA E0               CALL   UpCase               ; If between a-z, up-case it        ;
0433: E0DE 77                     LD     (HL),A               ; Replace character                 ;
0434: E0DF 10 F8                  DJNZ   UpCaseLoop           ; go thru all of the CMD buffer     ;
0435: E0E1         ;end of scan, h,l address end of command                                    ;
0436: E0E1         ;ReadCommand2:                                                              ;
0437: E0E1 23                     INC    HL                   ; Point at last char + 1            ;
0438: E0E2 70                     LD     (HL),B               ; Stuff Zero to terminate the CMD   ;
0439: E0E3 21 2E E2               LD     HL,commandBuffer     ; go back to start of com           ;
0440: E0E6 22 AE E2               LD     (commandBufferPointer),HL ; Place in current CMD address      ;
0441: E0E9 C9                     RET                         ;
0442: E0EA         ;------------------------------ Read Command -------------------------------;
0443: E0EA
0444: E0EA         ;--------------------------------- UpCase ----------------------------------;
0445: E0EA         ;convert character in register A (a to z) to upper case                     ;
0446: E0EA             UpCase:                         ;
0447: E0EA FE 61                  CP     061H                 ;
0448: E0EC D8                     RET    C                    ; Return if below lower case 'a'    ;
0449: E0ED FE 7B                  CP     07BH                 ;
0450: E0EF D0                     RET    NC                   ; Return if above lower case 'z'    ;
0451: E0F0 E6 5F                  AND    05FH                 ; Drop bit 5/ makes q->Q etc        ;
0452: E0F2 C9                     RET                         ;
0453: E0F3         ;--------------------------------- UpCase ----------------------------------;
0454: E0F3         ;---------------------------- Delete SubmitFile ----------------------------;
0455: E0F3         ;delete the submit file, and set submit flag to false                       ;
0456: E0F3             DeleteSubmitFile:                      ;
0457: E0F3 21 B0 E2               LD     HL,submitFlag        ; Point at Submit flag              ;
0458: E0F6 7E                     LD     A,(HL)               ; Get the Flag                      ;
0459: E0F7 B7                     OR     A                    ; Is it Set ?                       ;
0460: E0F8 C8                     RET    Z                    ;  return if not set                ;
0461: E0F9 36 00                  LD     (HL),0               ; Clear Flag                        ;
0462: E0FB AF                     XOR    A                    ; Drive 0 = A:                      ;
0463: E0FC CD 07 E6               CALL   SelectDisk           ; Select drive                      ;
0464: E0FF 11 B1 E2               LD     DE,submitFCB         ; Load the submits FCB              ;
0465: E102 CD 32 E6               CALL   DeleteFile           ; Go delete it                      ;
0466: E105 3A 6B E7               LD     A,(currentDisk)      ; Determine the current disk        ;
0467: E108 C3 07 E6               JP     SelectDisk           ; Reselect back to original drive   ;
0468: E10B         ;---------------------------- Delete SubmitFile ----------------------------;
0469: E10B         ;-------------------------------- Save User --------------------------------;
0470: E10B         ;save user#/disk# before possible ^c or transient                           ;
0471: E10B             SaveUserAndDisk:                      ;
0472: E10B CD 23 E6               CALL   GetUser              ; Get the user number into Acc      ;
0473: E10E 87                     ADD    A,A                  ;
0474: E10F 87                     ADD    A,A                  ;
0475: E110 87                     ADD    A,A                  ;
0476: E111 87                     ADD    A,A                  ; Move user to Hi Nibble            ;
0477: E112 21 6B E7               LD     HL,currentDisk       ; Current disk (Lo Nibble)          ;
0478: E115 B6                     OR     M                    ; Acc -> User & Disk                ;
0479: E116 32 04 00               LD     (Pg0CurentDisk),A    ; Stored in Page0 for later         ;
0480: E119 C9                     RET                         ;
0481: E11A         ;-------------------------------- Save User --------------------------------;
0482: E11A         ;------------------------- Set Page 0 Current Disk -------------------------;
0483: E11A         ;set Pg0CurentDisk to current disk                                          ;
0484: E11A             SetPage0CurDisk:                      ;
0485: E11A 3A 6B E7               LD     A,(currentDisk)      ; Get CCP's current disk            ;
0486: E11D 32 04 00               LD     (Pg0CurentDisk),A    ; Put into Page 0	                ;
0487: E120 C9                     RET                         ;
0488: E121         ;------------------------- Set Page 0 Current Disk -------------------------;
0489: E121
0490: E121         ;--------------------------------- Parse Token -----------------------------;
0491: E121         ; Parse command buffer.                                                     ;
0492: E121         ; Used to isolate the command                                               ;
0493: E121         ;
0494: E121             ParseToken2:                      ;
0495: E121 21 57 E7               LD     HL,Token2            ; Point at Token2 start             ;
0496: E124 18 03                  JR     ParseToken           ;
0497: E126             ParseToken1:                      ;
0498: E126 21 47 E7               LD     HL,Token1            ; Point at Token1 start             ;
0499: E129             ParseToken:                      ;
0500: E129 E5                     PUSH   HL                   ; Start of Token's Pointer          ;
0501: E12A E5                     PUSH   HL                   ; Start of Token's Pointer          ;
0502: E12B AF                     XOR    A                    ; Set A to 0                        ;
0503: E12C 32 68 E7               LD     (selectedDisk),A     ; Assume default disk               ;
0504: E12F 2A AE E2               LD     HL,(commandBufferPointer) ; Buffer's Pointer                  ;
0505: E132 CD B3 E1               CALL   NextNonBlankChar     ; Get printable character			;
0506: E135 22 69 E7               LD     (tokenStart),HL      ; Save token's address              ;
0507: E138 EB                     EX     DE,HL                ; DE -> Buffer                      ;
0508: E139 E1                     POP    HL                   ; DE -> Buffer,                     ;
0509: E13A         ;  HL -> Start of Token's Pointer   ;
0510: E13A         ; Disk ?                                                                    ;
0511: E13A 1A                     LD     A,(DE)               ; Get 1st character from buffer     ;
0512: E13B B7                     OR     A                    ; Is it the default Disk ?          ;
0513: E13C CA 4A E1               JP     Z,UseCurrentDisk     ; Use current disk if empty         ;
0514: E13F DE 40                  SBC    A,040H               ; Convert to number                 ;
0515: E141 47                     LD     B,A                  ; Hold disk number in B             ;
0516: E142 13                     INC    DE                   ;
0517: E143 1A                     LD     A,(DE)               ; Look at next character            ;
0518: E144 FE 3A                  CP     COLON                ; Is it a ':' ?                     ;
0519: E146 CA 51 E1               JP     Z,UseTokensDisk      ;  if yes, set disk number          ;
0520: E149         ; No Disk                                                                   ;
0521: E149 1B                     DEC    DE                   ; Back to start of buffer           ;
0522: E14A         ;
0523: E14A             UseCurrentDisk:                      ;
0524: E14A 3A 6B E7               LD     A,(currentDisk)      ; Get current Disk                  ;
0525: E14D 77                     LD     (HL),A               ; Put into the Token                ;
0526: E14E C3 57 E1               JP     SetFileName          ;
0527: E151         ;
0528: E151             UseTokensDisk:                      ;
0529: E151 78                     LD     A,B                  ; Get disk from this parse          ;
0530: E152 32 68 E7               LD     (selectedDisk),A     ; Mark as disk selected             ;
0531: E155 70                     LD     (HL),B               ; Put it into the token             ;
0532: E156 13                     INC    DE                   ; Move past the ':'                 ;
0533: E157         ;
0534: E157             SetFileName:                      ;
0535: E157 06 08                  LD     B,FILE_NAME_SIZE     ; File name length (max)            ;
0536: E159 CD 7F E1               CALL   FormatElement        ; Format file name                  ;
0537: E15C         ;
0538: E15C             SetType:                        ;
0539: E15C 06 03                  LD     B,FILE_TYPE_SIZE     ; File type length (max)            ;
0540: E15E CD A0 E1               CALL   IsItDot              ; is it a '.' ?	                    ;
0541: E161 CC 7F E1               CALL   Z,FormatElement      ;  Yes,Format it                    ;
0542: E164         ;
0543: E164         ; Zero Rest of token                                                        ;
0544: E164 06 03                  LD     B,3                  ;
0545: E166 AF                     XOR    A                    ;
0546: E167 CD AE E1               CALL   FillWithAcc          ;
0547: E16A EB                     EX     DE,HL                ;
0548: E16B 22 AE E2               LD     (commandBufferPointer),HL ; Set new starting point	        ;
0549: E16E         ; Recover the start address of the FCB and count ?'s                        ;
0550: E16E E1                     POP    HL                   ; Restore start of Token            ;
0551: E16F 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Loop size                   ;
0552: E171 0E 00                  LD     C,00                 ; Counter                           ;
0553: E173 3E 3F                  LD     A,QMARK              ; We want to count '?'s             ;
0554: E175             QuestionMarkCount:                      ;
0555: E175 23                     INC    HL                   ; Adjust token pointer				;
0556: E176 BE                     CP     (HL)                 ; Is it a '?'                       ;
0557: E177 20 01                  JR     NZ,QuestionMarkCount1 ;  no, then skip                    ;
0558: E179 0C                     INC    C                    ;  else increment the count         ;
0559: E17A             QuestionMarkCount1:                      ;
0560: E17A 10 F9                  DJNZ   QuestionMarkCount    ; Manage the Loop	                ;
0561: E17C 79                     LD     A,C                  ;
0562: E17D B7                     OR     A                    ;
0563: E17E C9                     RET                         ;
0564: E17F         ;-------------------------------- Parse Token ------------------------------;
0565: E17F         ;------------------------------- Format Element ----------------------------;
0566: E17F         ; Put element in a Left Justified, Space Padded field.                      ;
0567: E17F         ; If it encounters an asterisk, it will pad the rest of the field with '?'s ;
0568: E17F         ; Enter With:	B  = Element size                                           ;
0569: E17F         ;				DE = Element source                                         ;
0570: E17F         ;				HL = Element destination                                    ;
0571: E17F             FormatElement:                      ;
0572: E17F CD BD E1               CALL   IsItADelimiter       ; Is character a delimiter ?        ;
0573: E182 CA 9C E1               JP     Z,PadTheElement      ;  yes, pad rest of Element         ;
0574: E185         ;
0575: E185 23                     INC    HL                   ;  else move the Token's pointer    ;
0576: E186 FE 2A                  CP     ASTERISK             ; Is it an '*'					    ;
0577: E188 C2 90 E1               JP     NZ,FormatElement1    ;  no, then just put in Token   ;
0578: E18B 36 3F                  LD     (HL),QMARK           ;  else Put a '?' in token          ;
0579: E18D C3 92 E1               JP     FormatElement2       ;  for rest of Element              ;
0580: E190         ;
0581: E190             FormatElement1:                      ;
0582: E190 77                     LD     (HL),A               ; Put character in token            ;
0583: E191 13                     INC    DE                   ; Increment the buffer pointer      ;
0584: E192             FormatElement2:                      ;
0585: E192 10 EB                  DJNZ   FormatElement        ; Loop if more                      ;
0586: E194         ;
0587: E194             TruncateElement:                      ;
0588: E194 CD BD E1               CALL   IsItADelimiter       ; We expect a delimiter             ;
0589: E197 C8                     RET    Z                    ; If we get one, we are done        ;
0590: E198 13                     INC    DE                   ;  skip forward in buffer           ;
0591: E199 C3 94 E1               JP     TruncateElement      ; Keep looking for delimiter        ;
0592: E19C         ;
0593: E19C             PadTheElement:                      ;
0594: E19C CD AC E1               CALL   FillWithSpace        ; Pad the rest of Element           ;
0595: E19F C9                     RET                         ;
0596: E1A0         ;------------------------------- Format Element ----------------------------;
0597: E1A0         ;-------------------------------- Is It a Dot ------------------------------;
0598: E1A0         ; Check to see if char is buffer is a period. If it is it returns with      ;
0599: E1A0         ; the Z-Flag set., and the DE pointer advanced beyond the '.'.  If it is    ;
0600: E1A0         ; not a period. It will fill the buffer with spaces and return with the     ;
0601: E1A0         ; Z-Flag reset.                                                             ;
0602: E1A0         ;                                                                           ;
0603: E1A0         ; Enter With:	DE = Pointer for buffer                                     ;
0604: E1A0         ;				 B = buffer size	                                        ;
0605: E1A0         ; Return With:	DE = Past the period                                        ;
0606: E1A0         ;			   	Z-Flag =  set if Period                                     ;
0607: E1A0         ;  				Z-Flag = reset if not Period                                ;
0608: E1A0             IsItDot:                        ;
0609: E1A0 1A                     LD     A,(DE)               ;
0610: E1A1 13                     INC    DE                   ; Assume it is a '.'                ;
0611: E1A2 FE 2E                  CP     PERIOD               ; Is it '.' ?                       ;
0612: E1A4 C8                     RET    Z                    ;  if yes exit with Z-Flag set      ;
0613: E1A5         ;
0614: E1A5 1B                     DEC    DE                   ; Adjust, wrong assumption          ;
0615: E1A6 CD AC E1               CALL   FillWithSpace        ;  else make all spaces             ;
0616: E1A9 AF                     XOR    A                    ;
0617: E1AA 3C                     INC    A                    ; Reset the Z-Flag                  ;
0618: E1AB C9                     RET                         ; Exit with Z-Flag reset            ;
0619: E1AC         ;-------------------------------- Is It a Dot ------------------------------;
0620: E1AC         ;-------------------------- Fill With Space/Acc ----------------------------;
0621: E1AC         ; fills buffer with SPACE or contents of Acc.                               ;
0622: E1AC         ; Enters with:	HL = less than start of fill area                           ;
0623: E1AC         ;				B  = fill Count                                             ;
0624: E1AC         ;				A  = fill character (FillWithAcc)                           ;
0625: E1AC             FillWithSpace:                      ;
0626: E1AC 3E 20                  LD     A,SPACE              ;
0627: E1AE             FillWithAcc:                      ;
0628: E1AE 23                     INC    HL                   ;
0629: E1AF 77                     LD     (HL),A               ;
0630: E1B0 10 FC                  DJNZ   FillWithAcc          ;
0631: E1B2 C9                     RET                         ;
0632: E1B3         ;-------------------------- Fill With Space/Acc ----------------------------;
0633: E1B3         ;------------------------ Next Non Blank Character -------------------------;
0634: E1B3         ;find the next non blank character in line pointed to by DE                 ;
0635: E1B3             NextNonBlankChar:                      ;
0636: E1B3 7E                     LD     A,(HL)               ; Get the character                 ;
0637: E1B4 B7                     OR     A                    ; Is it End of buffer ?             ;
0638: E1B5 C8                     RET    Z                    ;  if yes, return                   ;
0639: E1B6 FE 20                  CP     SPACE                ; is it a blank ?                   ;
0640: E1B8 C0                     RET    NZ                   ;  if not, return                   ;
0641: E1B9 23                     INC    HL                   ;  else increment pointer           ;
0642: E1BA C3 B3 E1               JP     NextNonBlankChar     ; Loop for next character           ;
0643: E1BD         ;------------------------ Next Non Blank Character -------------------------;
0644: E1BD         ;---------------------------- Is It A Delimiter ----------------------------;
0645: E1BD         ; Returns with Z-flag set if (DE) pointing at a delimiter                   ;
0646: E1BD         ; Does an error exit if not valid ASCII character                           ;
0647: E1BD             IsItADelimiter:                      ;
0648: E1BD 1A                     LD     A,(DE)               ; Get the character                 ;
0649: E1BE B7                     OR     A                    ;
0650: E1BF C8                     RET    Z                    ; End of Buffer is a delimiter      ;
0651: E1C0 FE 20                  CP     SPACE                ;
0652: E1C2 DA 06 E2               JP     C,CommandError       ; Error exit if not ASCII           ;
0653: E1C5 C8                     RET    Z                    ; SPACE is a delimiter              ;
0654: E1C6 FE 3D                  CP     EQUAL_SIGN           ;
0655: E1C8 C8                     RET    Z                    ; '=' is a delimiter                ;
0656: E1C9 FE 5F                  CP     UNDER_SCORE          ;
0657: E1CB C8                     RET    Z                    ; '_' is a delimiter                ;
0658: E1CC FE 2E                  CP     PERIOD               ;
0659: E1CE C8                     RET    Z                    ; '.' is a delimiter                ;
0660: E1CF FE 3A                  CP     COLON                ;
0661: E1D1 C8                     RET    Z                    ; ':' is a delimiter                ;
0662: E1D2 FE 3B                  CP     SEMICOLON            ;
0663: E1D4 C8                     RET    Z                    ; ';' is a delimiter                ;
0664: E1D5 FE 3C                  CP     LESS_THAN            ;
0665: E1D7 C8                     RET    Z                    ; '<' is a delimiter                ;
0666: E1D8 FE 3E                  CP     GREATER_THAN         ;
0667: E1DA C8                     RET    Z                    ; '>' is a delimiter                ;
0668: E1DB C9                     RET                         ; Not a delimiter                   ;
0669: E1DC         ;---------------------------- Is It A Delimiter ----------------------------;
0670: E1DC
0671: E1DC         ;---------------------------- Intrinsic Function ---------------------------;
0672: E1DC         ;look for intrinsic functions (Token1 has been filled)                 		;
0673: E1DC             IntrinsicFunction:                      ;
0674: E1DC 21 D1 E2               LD     HL,builtInCMDNames   ; Point at List of CMDs             ;
0675: E1DF 0E 00                  LD     C,0                  ; Initialize counter                ;
0676: E1E1             IntrinsicFunction1:                      ;
0677: E1E1 79                     LD     A,C                  ; Get Counter                       ;
0678: E1E2 FE 06                  CP     builtInCMDCount      ; Past number of commands ?         ;
0679: E1E4 D0                     RET    NC                   ;  exit if yes                      ;
0680: E1E5 11 48 E7               LD     DE,Token1+1          ; Beginning of name                 	;
0681: E1E8 06 04                  LD     B,builtInCMDNameSize ; Length of match                   ;
0682: E1EA             IntrinsicFunction2:                      ;
0683: E1EA 1A                     LD     A,(DE)               ;
0684: E1EB BE                     CP     M                    ; Is there a match ?                ;
0685: E1EC C2 FD E1               JP     NZ,IntrinsicFunction3 ;  skip if no match                 ;
0686: E1EF 13                     INC    DE                   ;
0687: E1F0 23                     INC    HL                   ; Point at next characters          ;
0688: E1F1 05                     DEC    B                    ; Decrement the counter             ;
0689: E1F2 C2 EA E1               JP     NZ,IntrinsicFunction2 ; Loop while matching               ;
0690: E1F5         ; complete match on name, check for blank in FCB                            ;
0691: E1F5 1A                     LD     A,(DE)               ;
0692: E1F6 FE 20                  CP     SPACE                ; Blank in CMD ?                    ;
0693: E1F8 C2 02 E2               JP     NZ,IntrinsicFunction4 ;  No ,then no match                ;
0694: E1FB 79                     LD     A,C                  ;  Else they match,                 ;
0695: E1FC C9                     RET                         ; Return with index in A            ;
0696: E1FD         ;
0697: E1FD             IntrinsicFunction3:                      ;
0698: E1FD 23                     INC    HL                   ; Move to next in list              ;
0699: E1FE 05                     DEC    B                    ;
0700: E1FF C2 FD E1               JP     NZ,IntrinsicFunction3 ; Loop thru this one                ;
0701: E202         ;
0702: E202             IntrinsicFunction4:                      ;
0703: E202 0C                     INC    C                    ; Update the index                  ;
0704: E203 C3 E1 E1               JP     IntrinsicFunction1   ;  loop for another round           ;
0705: E206         ;---------------------------- Intrinsic Function ---------------------------;
0706: E206
0707: E206         ; cmd
0708: E206         ;------------------------------ Command Error ------------------------------;
0709: E206         ;error in command string starting at position;'tokenStart' and ending    	;
0710: E206         ; with first delimiter                                                      ;
0711: E206         ;
0712: E206             CommandError:                      ;
0713: E206 CD 85 E6               CALL   CrLf                 ; Next Line                         ;
0714: E209 2A 69 E7               LD     HL,(tokenStart)      ; Start of error token             		;
0715: E20C             CommandErrorLoop:                      ;
0716: E20C 7E                     LD     A,(HL)               ; Get character                     ;
0717: E20D FE 20                  CP     SPACE                ; Past offending token ?            ;
0718: E20F CA 1E E2               JP     Z,CommandErrorExit   ;  done if yes                      ;
0719: E212 B7                     OR     A                    ; At end of command ?               ;
0720: E213 CA 1E E2               JP     Z,CommandErrorExit   ;  done if yes                      ;
0721: E216 E5                     PUSH   HL                   ; Save pointer                      ;
0722: E217 CD 8E E6               CALL   PrintCharInA         ; Display on console                ;
0723: E21A E1                     POP    HL                   ; Restore pointer                   ;
0724: E21B 23                     INC    HL                   ; Update it                         ;
0725: E21C 18 EE                  JR     CommandErrorLoop     ; Keep going                        ;
0726: E21E         ;
0727: E21E             CommandErrorExit:                      ;
0728: E21E 3E 3F                  LD     A,QMARK              ;
0729: E220 CD 8E E6               CALL   PrintCharInA         ; Send '?' to console               ;
0730: E223 CD 85 E6               CALL   CrLf                 ; Next Line                         ;
0731: E226 CD F3 E0               CALL   DeleteSubmitFile     ; Remove any submit file            ;
0732: E229 C3 26 E0               JP     ccpMainEntry         ; Go back for another command       ;
0733: E22C         ;------------------------------ Command Error ------------------------------;
0734: E22C
0735: E22C         ;------------------------------ Command Buffer -----------------------------;
0736: E22C             maximumBufferSize EQU    07FH                 ; Max Length of Buffer          ;
0737: E22C 7F          commandMaxLength: DB     maximumBufferSize    ;
0738: E22D 00          commandLength: DB     00H                  ; Actual size of input          ;
0739: E22E             commandBuffer: DS     maximumBufferSize + 1 ; The Command Buffer           ;
0740: E2AE         ;
0741: E2AE 2E E2       commandBufferPointer: DW     commandBuffer        ; Address of next to char       ;
0742: E2B0         ;------------------------------ Command Buffer -----------------------------;
0743: E2B0         ;------------------------- Submit File Control Block -----------------------;
0744: E2B0         ;	                                                                        ;
0745: E2B0 00          submitFlag: DB     00H                  ; 00 if no submit file,             ;
0746: E2B1         ;  0FFH if submitting               ;
0747: E2B1 24 24 24 20 20 20 20 20     submitFCB: DB     '$$$     '           ; File name is $$$                  ;
0748: E2B9 53 55 42     submitType: DB     'SUB'                ; Type is 'SUB'                     ;
0749: E2BC 00          submitExtent: DB     00H                  ; Extent                            ;
0750: E2BD 00          submitS1:  DB     00H                  ; S1                                ;
0751: E2BE             submitFWF:                      ; Bit7 = FileWriteFlag
0752: E2BE 00          submitS2:  DB     00H                  ; S2 (bit7 = FileWriteFlag)         ;
0753: E2BF 00          submitRC:  DB     00H                  ; RC                                ;
0754: E2C0             submitMap: DS     010H                 ; Allocation Map                    ;
0755: E2D0 00          submitCR:  DB     00H                  ; Current Record                    ;
0756: E2D1         ;------------------------- Submit File Control Block -----------------------;
0757: E2D1         ;--------------------------- Built In Command Data -------------------------;
0758: E2D1         ;intrinsic function names four characters each                              ;
0759: E2D1             builtInCMDNameSize EQU    04                   ; Size of intrinsic function names  ;
0760: E2D1         ;
0761: E2D1             builtInCMDNames:                      ;
0762: E2D1 44 49 52 20                DB     'DIR '               ;
0763: E2D5 45 52 41 20                DB     'ERA '               ;
0764: E2D9 54 59 50 45                DB     'TYPE'               ;
0765: E2DD 53 41 56 45                DB     'SAVE'               ;
0766: E2E1 52 45 4E 20                DB     'REN '               ;
0767: E2E5 55 53 45 52                DB     'USER'               ;
0768: E2E9             builtInCMDCount EQU    (($-builtInCMDNames)/builtInCMDNameSize) + 1 ;
0769: E2E9         ;
0770: E2E9             builtInCMDVector:                      ;
0771: E2E9 F7 E2                  DW     ccpDirectory         ; Directory List                    ;
0772: E2EB 91 E3                  DW     ccpErase             ; File erase                        ;
0773: E2ED CE E4                  DW     ccpType              ; Type file on Console              ;
0774: E2EF 4B E4                  DW     ccpSave              ; Save memory image                 ;
0775: E2F1 CF E3                  DW     ccpRename            ; File rename                       ;
0776: E2F3 0E E5                  DW     ccpUser              ; User number                       ;
0777: E2F5 25 E5                  DW     ccpUserCommand       ; User-defined function             ;
0778: E2F7         ;
0779: E2F7         ;--------------------------- Built In Command Data -------------------------;
0780: E2F7
0781: E2F7         ;==============================              ===============================;
0782: E2F7         ;============================== CCP Commands ===============================;
0783: E2F7         ;==============================              ===============================;
0784: E2F7
0785: E2F7         ;----------------------------- Directory Listing ---------------------------;
0786: E2F7         ; SYNTAX: DIR afn                                                           ;
0787: E2F7         ;                                                                           ;
0788: E2F7         ;  The 'DIR' command causes the names of all the files that satisfy the     ;
0789: E2F7         ; ambiguous filename afn to be listed on the console device                 ;
0790: E2F7         ;                                                                           ;
0791: E2F7             ccpDirectory:                      ;
0792: E2F7 CD 26 E1               CALL   ParseToken1          ; Token1 gets file name             ;
0793: E2FA CD C6 E6               CALL   SetDiskForCmd        ; Change disk if needed             ;
0794: E2FD 21 48 E7               LD     HL,Token1+1          ; Point at 1st char of parameter    ;
0795: E300 7E                     LD     A,(HL)               ; Get the value                     ;
0796: E301 FE 20                  CP     SPACE                ; Is it Blank ?                     ;
0797: E303 C2 0D E3               JP     NZ,ccpDirQualified   ;  skip there is a parameter        ;
0798: E306         ;
0799: E306         ; set Token1 to all ??? for current disk                                    ;
0800: E306 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Set Limit	                ;
0801: E308             ccpDirAll:                      ;
0802: E308 36 3F                  LD     (HL),QMARK           ; Put '?' in Token                  ;
0803: E30A 23                     INC    HL                   ; Increment pointer                 ;
0804: E30B 10 FB                  DJNZ   ccpDirAll            ; Loop till done                    ;
0805: E30D         ;
0806: E30D             ccpDirQualified:                      ;
0807: E30D AF                     XOR    A                    ; Set Acc to 0                      ;
0808: E30E 32 8F E3               LD     (dirFileCount),A     ; Initialize File Count             ;
0809: E311         ;	LD		(dirCharCount),A			; Initialize char count             ;
0810: E311 CD 2D E7               CALL   FindFirstToken1File  ; Look for directory entry          ;
0811: E314 CC AA E6               CALL   Z,PrintNoFile        ;  if not found send message        ;
0812: E317         ;
0813: E317             ccpDirLoopTop:                      ;
0814: E317 CA 8C E3               JP     Z,ccpDirEnd          ; Exit if directory exhausted       ;
0815: E31A         ; found, but may be system file                                             ;
0816: E31A 3A 6C E7               LD     A,(directoryEntryNumber) ; Get directory entry number        ;
0817: E31D 0F                     RRCA                        ;
0818: E31E 0F                     RRCA                        ;
0819: E31F 0F                     RRCA                        ; Multiply by 20H                   ;
0820: E320 4F                     LD     C,A                  ;
0821: E321 06 00                  LD     B,0                  ; BC has index into Dir Buffer      ;
0822: E323 DD 21 80 00               LD     IX,DMABuffer         ;
0823: E327 DD 09                  ADD    IX,BC                ; IX Points at the Dir Entry        ;
0824: E329 DD CB 0A 7E               BIT    7,(IX+fcbSystemFileIndex) ; Is this a System File             ;
0825: E32D C2 7E E3               JP     NZ,ccpDirLoopBottom  ;  if yes, Skip to next iteration   ;
0826: E330         ;
0827: E330 DD E5                  PUSH   IX                   ; IX Points at the Dir Entry        ;
0828: E332 AF                     XOR    A                    ;
0829: E333 32 90 E3               LD     (dirCharCount),A     ; Initialize char count             ;
0830: E336         ;
0831: E336 21 8F E3               LD     HL,dirFileCount      ; Point at dirFileCount             ;
0832: E339 7E                     LD     A,(HL)               ; Get the dirFileCount              ;
0833: E33A 34                     INC    (HL)                 ; Increment dirFileCount            ;
0834: E33B E6 03                  AND    11B                  ; Perform Mod(E,4)                  ;
0835: E33D C2 55 E3               JP     NZ,ccpDirDisplayFile0 ; Skip header if not 0              ;
0836: E340         ;
0837: E340         ; print the header: new Line followed by drive with Colon - A :             ;
0838: E340 CD 85 E6               CALL   CrLf                 ; New Line                          ;
0839: E343 C5                     PUSH   BC                   ;
0840: E344 CD 1E E6               CALL   GetSelectedDrive     ; Get Active drive number           ;
0841: E347 C1                     POP    BC                   ;
0842: E348 C6 41                  ADD    A,ASCII_A            ; Make it ASCII                     ;
0843: E34A CD 55 E6               CALL   PrintSaveBC          ; Send it to the console            ;
0844: E34D 3E 3A                  LD     A,COLON              ;
0845: E34F CD 55 E6               CALL   PrintSaveBC          ; Send ':' to the console           ;
0846: E352 C3 5D E3               JP     ccpDirDisplayFile    ; Skip ':' display                  ;
0847: E355         ;
0848: E355             ccpDirDisplayFile0:                      ;
0849: E355 CD 50 E6               CALL   PrintSpace           ; Send Space to console             ;
0850: E358 3E 3A                  LD     A,COLON              ;
0851: E35A CD 55 E6               CALL   PrintSaveBC          ; Send ':' to the console			;
0852: E35D             ccpDirDisplayFile:                      ;
0853: E35D CD 50 E6               CALL   PrintSpace           ; Send Space to console             ;
0854: E360         ;
0855: E360             ccpDirDisplayFileLoop:                      ;
0856: E360 DD E1                  POP    IX                   ; Get to Dir Entry Pointer          ;
0857: E362 DD 7E 00               LD     A,(IX+0)             ; Put char in ACC                   ;
0858: E365 DD 23                  INC    IX                   ; Adjust pointer for next iteration ;
0859: E367 DD E5                  PUSH   IX                   ; Save till then                    ;
0860: E369 E6 7F                  AND    ASCII_MASK           ; Make sure char is ASCII           ;
0861: E36B CD 8E E6               CALL   PrintCharInA         ; Send it to the console            ;
0862: E36E 21 90 E3               LD     HL,dirCharCount      ; Where are we in Token ?           ;
0863: E371 7E                     LD     A,(HL)               ; Get index                         ;
0864: E372 34                     INC    (HL)                 ; Update for next time              ;
0865: E373 47                     LD     B,A                  ; Save count                        ;
0866: E374 FE 08                  CP     8                    ; End of Name ?                     ;
0867: E376 CC 50 E6               CALL   Z,PrintSpace         ; Separate Name and Type            ;
0868: E379 78                     LD     A,B                  ; Retrieve count                    ;
0869: E37A FE 0B                  CP     11                   ; At the end of this dir entry ?    ;
0870: E37C 20 E2                  JR     NZ,ccpDirDisplayFileLoop ;  if no continue the iteration     ;
0871: E37E         ;
0872: E37E             ccpDirLoopBottom:                      ;
0873: E37E DD E1                  POP    IX                   ; Balance stack                     ;
0874: E380 CD B8 E6               CALL   CheckForConsoleChar  ; Interrupt at keyboard ?           ;
0875: E383 C2 8C E3               JP     NZ,ccpDirEnd         ;  yes, abort directory search      ;
0876: E386 CD 38 E7               CALL   SearchForNext        ; Look for more entries             ;
0877: E389 C3 17 E3               JP     ccpDirLoopTop        ;  and loop thru                    ;
0878: E38C             ccpDirEnd:                      ;
0879: E38C C3 D8 E6               JP     RestoreDiskAtCmdEnd  ; Wrap up and start over            ;
0880: E38F         ;
0881: E38F             dirFileCount:                      ;
0882: E38F 00                     DB     0                    ;
0883: E390             dirCharCount:                      ;
0884: E390 00                     DB     0                    ;
0885: E391         ;----------------------------- Directory Listing ---------------------------;
0886: E391
0887: E391         ;-------------------------------- Erase Files ------------------------------;
0888: E391         ; SYNTAX: ERA afn                                                           ;
0889: E391         ;                                                                           ;
0890: E391         ;  The 'ERA' command removes files from the currently logged-in disk. The   ;
0891: E391         ; files that are erased are those that satisfy the ambiguous filename       ;
0892: E391         ; reference afn.                                                            ;
0893: E391         ;                                                                           ;
0894: E391             ccpErase:                       ;
0895: E391 CD 26 E1               CALL   ParseToken1          ; Parse the command                 ;
0896: E394 FE 0B                  CP     FILE_NAME_SIZE+FILE_TYPE_SIZE ; All '?'s ?                    ;
0897: E396 C2 B4 E3               JP     NZ,ccpEraseFile      ;  skip if not                      ;
0898: E399         ; Want to be sure											                ;
0899: E399 01 C4 E3               LD     BC,msgEraseAll       ; Point at the message              ;
0900: E39C CD 99 E6               CALL   PrintCrLfStringNull  ; Display it on the console         ;
0901: E39F         ;
0902: E39F CD 65 E0               CALL   ReadCommand          ; Get the operator's response       ;
0903: E3A2 21 2D E2               LD     HL,commandLength     ; Point at size of response         ;
0904: E3A5 35                     DEC    M                    ; Test the size                     ;
0905: E3A6 C2 26 E0               JP     NZ,ccpMainEntry      ; Exit, wrong answer                ;
0906: E3A9 23                     INC    HL                   ; point at the 1 char response      ;
0907: E3AA 7E                     LD     A,(HL)               ; Get it into ACC                   ;
0908: E3AB FE 59                  CP     ASCII_Y              ; Is it 'Y'                         ;
0909: E3AD C2 26 E0               JP     NZ,ccpMainEntry      ;  exit if not                      ;
0910: E3B0         ;
0911: E3B0 23                     INC    HL                   ; Adjust the pointer                ;
0912: E3B1 22 AE E2               LD     (commandBufferPointer),HL ; Restore buffer pointer            ;
0913: E3B4             ccpEraseFile:                      ;
0914: E3B4 CD C6 E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
0915: E3B7 11 47 E7               LD     DE,Token1            ; Point to target FCB               ;
0916: E3BA CD 32 E6               CALL   DeleteFile           ; Call BDOS to delete               ;
0917: E3BD 3C                     INC    A                    ; 255 returned if not found         ;
0918: E3BE CC AA E6               CALL   Z,PrintNoFile        ; Report if file not found          ;
0919: E3C1 C3 D8 E6               JP     RestoreDiskAtCmdEnd  ; Wrap up and start over            ;
0920: E3C4         ;
0921: E3C4             msgEraseAll:                      ;
0922: E3C4 41 4C 4C 20 28 59 2F 4E 29 3F 00                DB     'ALL (Y/N)?',0       ;
0923: E3CF         ;-------------------------------- Erase Files ------------------------------;
0924: E3CF
0925: E3CF         ;-------------------------------- Rename Files -----------------------------;
0926: E3CF         ; SYNTAX: REN ufn1=ufn2                                                     ;
0927: E3CF         ;                                                                           ;
0928: E3CF         ;  The 'REN' command allows you to change the name of files on disk. The    ;
0929: E3CF         ; file satisfying ufn2 is changed to ufn1. The currently logged disk is     ;
0930: E3CF         ; assumed to contain the file to rename (ufn2).                             ;
0931: E3CF             ccpRename:                      ;
0932: E3CF CD 26 E1               CALL   ParseToken1          ; Get ufn1                          ;
0933: E3D2 C2 06 E2               JP     NZ,CommandError      ; Must be unambiguous. No '?'s      ;
0934: E3D5 3A 68 E7               LD     A,(selectedDisk)     ; Get saved disk                    ;
0935: E3D8 F5                     PUSH   AF                   ; Save for later compare            ;
0936: E3D9 CD C6 E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
0937: E3DC CD 2D E7               CALL   FindFirstToken1File  ; Is ufn1 already there?            ;
0938: E3DF C2 36 E4               JP     NZ,ccpRenameError3   ;  if yes, report error             ;
0939: E3E2         ;
0940: E3E2             ccpRenameFCB1:                      ;
0941: E3E2         ; file doesn't exist, move to second half of FCB                            ;
0942: E3E2 21 47 E7               LD     HL,Token1            ; Point at FCB for ufn1             ;
0943: E3E5 11 57 E7               LD     DE,Token2            ; Point where to put it             ;
0944: E3E8 01 10 00               LD     BC,16                ; FCB F1...F8,T1...T3,EXT,S1,S2,RC  ;
0945: E3EB         ;	CALL	CopyHL2DEforBXX                                                 ;
0946: E3EB ED B0                  LDIR   ccpRenameFCB1        ; Move the FCB                      ;
0947: E3ED         ; check for = or left arrow                                                 ;
0948: E3ED 2A AE E2               LD     HL,(commandBufferPointer) ; Get pointer                       ;
0949: E3F0         ;	EX		DE,HL                                                           ;
0950: E3F0 CD B3 E1               CALL   NextNonBlankChar     ; Get a live character              ;
0951: E3F3 FE 3D                  CP     EQUAL_SIGN           ; is it '=' ?                       ;
0952: E3F5 CA FD E3               JP     Z,ccpRenameFCB2      ;  do FCB2 if yes                   ;
0953: E3F8 FE 5F                  CP     LEFT_ARROW           ; is it '<-' ?                      ;
0954: E3FA C2 30 E4               JP     NZ,ccpRenameError2   ;  error if no                      ;
0955: E3FD         ;
0956: E3FD             ccpRenameFCB2:                      ;
0957: E3FD         ;	EX		DE,HL                                                           ;
0958: E3FD 23                     INC    HL                   ; Move to start of ufn2             ;
0959: E3FE 22 AE E2               LD     (commandBufferPointer),HL ; Save for parser                   ;
0960: E401 CD 26 E1               CALL   ParseToken1          ; Get ufn2                          ;
0961: E404 C2 30 E4               JP     NZ,ccpRenameError2   ; Must be unambiguous. No '?'s      ;
0962: E407         ;
0963: E407 F1                     POP    AF                   ; Get saved disk                    ;
0964: E408 47                     LD     B,A                  ; Save a copy                       ;
0965: E409 21 68 E7               LD     HL,selectedDisk      ; Point at current selected disk    ;
0966: E40C 7E                     LD     A,(HL)               ; Get it                            ;
0967: E40D B7                     OR     A                    ; Was it the default disk ?         ;
0968: E40E CA 16 E4               JP     Z,ccpRename2         ;  skip if yes                      ;
0969: E411         ; drive name was specified.  same one?                                      ;
0970: E411 B8                     CP     B                    ; Are they the same ?               ;
0971: E412 70                     LD     (HL),B               ; Update to new selected disk       ;
0972: E413 C2 30 E4               JP     NZ,ccpRenameError2   ; Not the same, error exit			;
0973: E416             ccpRename2:                      ;
0974: E416 70                     LD     (HL),B               ; Update to new selected disk       ;
0975: E417 AF                     XOR    A                    ; Set ACC = 0                       ;
0976: E418 32 47 E7               LD     (Token1),A           ; FCB2's disk is default            ;
0977: E41B CD 2D E7               CALL   FindFirstToken1File  ; Get ufn2'ss directory Entry       ;
0978: E41E CA 2A E4               JP     Z,ccpRenameError1    ; Error exit if not there           ;
0979: E421         ;
0980: E421 11 47 E7               LD     DE,Token1            ; Point at both FCBs                ;
0981: E424 CD 43 E6               CALL   RenameFile           ; Let BDOS do the rename            ;
0982: E427 C3 D8 E6               JP     RestoreDiskAtCmdEnd  ; Exit gracefully                   ;
0983: E42A         ;
0984: E42A             ccpRenameError1:                      ;
0985: E42A CD AA E6               CALL   PrintNoFile          ; Inform operator there is no file	;
0986: E42D C3 D8 E6               JP     RestoreDiskAtCmdEnd  ; Exit cleanly                      ;
0987: E430         ;
0988: E430             ccpRenameError2:                      ;
0989: E430 CD 1C E7               CALL   RestoreDisk          ; Restore Disk from before command  ;
0990: E433 C3 06 E2               JP     CommandError         ; Error exit                        ;
0991: E436         ;
0992: E436             ccpRenameError3:                      ;
0993: E436 01 3F E4               LD     BC,msgFileExists     ; Load message                      ;
0994: E439 CD 99 E6               CALL   PrintCrLfStringNull  ; Display message on console        ;
0995: E43C C3 D8 E6               JP     RestoreDiskAtCmdEnd  ; Exit cleanly                      ;
0996: E43F         ;
0997: E43F             msgFileExists:                      ;
0998: E43F 46 49 4C 45 20 45 58 49 53 54 53 00                DB     'FILE EXISTS',0      ;
0999: E44B         ;-------------------------------- Rename Files -----------------------------;
1000: E44B
1001: E44B         ;---------------------------------- Save File ------------------------------;
1002: E44B         ; SYNTAX: SAVE n ufn                                                    	;
1003: E44B         ;                                                                           ;
1004: E44B         ;  The 'SAVE' command places n pages(256-bytes) onto disk from the   		;
1005: E44B         ; TPA (Location 0100H) and names the file ufn.                              ;
1006: E44B         ;
1007: E44B             ccpSave:                        ;
1008: E44B CD ED E6               CALL   GetNumberFromCmdLine ; Value returned in Acc.            ;
1009: E44E F5                     PUSH   AF                   ; Save value                        ;
1010: E44F CD 26 E1               CALL   ParseToken1          ; Parse to get ufn                  ;
1011: E452 C2 06 E2               JP     NZ,CommandError      ; Must be unambiguous. No '?'s      ;
1012: E455 CD C6 E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
1013: E458 11 47 E7               LD     DE,Token1            ; Get the FCB                       ;
1014: E45B D5                     PUSH   DE                   ; Save FCB                          ;
1015: E45C CD 32 E6               CALL   DeleteFile           ; Deleted file if it exists         ;
1016: E45F D1                     POP    DE                   ; Restore FCB                       ;
1017: E460 CD 37 E6               CALL   MakeFile             ; Create a new file on disk         ;
1018: E463 CA 99 E4               JP     Z,ccpSaveError1      ;  exit, no directory space         ;
1019: E466 AF                     XOR    A                    ; Set Acc = 0                       ;
1020: E467 32 67 E7               LD     (currentRecord),A    ; Clear next record field           ;
1021: E46A F1                     POP    AF                   ; # pages to write is in Acc        ;
1022: E46B 6F                     LD     L,A                  ;  	change to # sectors             ;
1023: E46C 26 00                  LD     H,0                  ; Sector size is 512				;
1024: E46E 29                     ADD    HL,HL                ; Sector Count	                    ;
1025: E46F 11 00 01               LD     DE,TPA               ; Initialize Memory pointer         ;
1026: E472         ;
1027: E472             ccpSaveWrite:                      ;
1028: E472 7C                     LD     A,H                  ;
1029: E473 B5                     OR     L                    ; If Sector count = 0               ;
1030: E474 CA 8F E4               JP     Z,ccpSaveClose       ;  we are finished writing          ;
1031: E477 2B                     DEC    HL                   ; Decrement Sector count            ;
1032: E478 E5                     PUSH   HL                   ; Sector count                      ;
1033: E479 21 80 00               LD     HL,cpmRecordSize     ; Get bytes to write                ;
1034: E47C 19                     ADD    HL,DE                ; Add to memory pointer             ;
1035: E47D E5                     PUSH   HL                   ; memory pointer                    ;
1036: E47E CD 4B E6               CALL   SetDMA               ; Set DMA                           ;
1037: E481 11 47 E7               LD     DE,Token1            ; Point at the FCB                  ;
1038: E484 CD 3C E6               CALL   DiskWrite            ; Write a sector from DMA           ;
1039: E487 D1                     POP    DE                   ; memory pointer                    ;
1040: E488 E1                     POP    HL                   ; Sector count                      ;
1041: E489 C2 A1 E4               JP     NZ,ccpSaveError2     ; If disk full, exit                ;
1042: E48C C3 72 E4               JP     ccpSaveWrite         ; Keep on writing                   ;
1043: E48F         ;
1044: E48F         ;
1045: E48F             ccpSaveClose:                      ;
1046: E48F 11 47 E7               LD     DE,Token1            ; Point at the FCB                  ;
1047: E492 CD 12 E6               CALL   CloseFile            ; Close the File                    ;
1048: E495 3C                     INC    A                    ; Check return code                 ;
1049: E496 C2 A7 E4               JP     NZ,ccpSaveExit       ; If OK, clean exit                 ;
1050: E499         ;
1051: E499             ccpSaveError1:                      ;
1052: E499 01 AD E4               LD     BC,msgNoDirSpace     ; Load Error Message                ;
1053: E49C CD 99 E6               CALL   PrintCrLfStringNull  ; Send it to the console            ;
1054: E49F 18 06                  JR     ccpSaveExit          ; Do a clean exit                   ;
1055: E4A1             ccpSaveError2:                      ;
1056: E4A1 01 C0 E4               LD     BC,msgNoDiskSpace    ; Load Error Message                ;
1057: E4A4 CD 99 E6               CALL   PrintCrLfStringNull  ; Send it to the console            ;
1058: E4A7         ;
1059: E4A7             ccpSaveExit:                      ;
1060: E4A7 CD 48 E6               CALL   SetDefaultDMA        ; Reset the DMA                     ;
1061: E4AA C3 D8 E6               JP     RestoreDiskAtCmdEnd  ; Perform a clean exit              ;
1062: E4AD         ;
1063: E4AD             msgNoDirSpace:                      ;
1064: E4AD 4E 4F 20 44 49 52 45 43 54 4F 52 59 20 53 50 41 43 45 00                DB     'NO DIRECTORY SPACE',0 ;
1065: E4C0             msgNoDiskSpace:                      ;
1066: E4C0 4E 4F 20 44 49 53 4B 20 53 50 41 43 45 00                DB     'NO DISK SPACE',0    ;
1067: E4CE         ;---------------------------------- Save File ------------------------------;
1068: E4CE
1069: E4CE         ;---------------------------------- Type File ------------------------------;
1070: E4CE         ; SYNTAX: TYPE ufn                                                    		;
1071: E4CE         ;                                                                           ;
1072: E4CE         ;  The 'TYPE' command displays the content of the ASCII source file ufn on  ;
1073: E4CE         ; the currently logged disk at the console device.                          ;
1074: E4CE         ;
1075: E4CE             ccpType:                        ;
1076: E4CE CD 26 E1               CALL   ParseToken1          ; Setup the ufn's FCB               ;
1077: E4D1 C2 06 E2               JP     NZ,CommandError      ; Must be unambiguous. No '?'s      ;
1078: E4D4 CD C6 E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
1079: E4D7 CD 3D E7               CALL   OpenToken1File       ; Open the file at Token1           ;
1080: E4DA CA 08 E5               JP     Z,ccpTypeError       ;  error exit if not successful     ;
1081: E4DD         ;
1082: E4DD CD 85 E6               CALL   CrLf                 ; Send new  NewLine to console      ;
1083: E4E0         ;
1084: E4E0             ccpTypeRead:                      ;
1085: E4E0 11 47 E7               LD     DE,Token1            ; Point at Token1's FCB             ;
1086: E4E3 CD 17 E6               CALL   DiskRead             ; Read next Record                  ;
1087: E4E6 C2 01 E5               JP     NZ,ccpTypeEOF        ; Hard End Of File                  ;
1088: E4E9         ;
1089: E4E9 06 80                  LD     B,cpmRecordSize      ; Load Character count              ;
1090: E4EB 0E 02                  LD     C,fConsoleOut        ; Load Function Number              ;
1091: E4ED 21 80 00               LD     HL,DMABuffer         ; Point at the read buffer          ;
1092: E4F0 E5                     PUSH   HL                   ; Buffer Pointer                    ;
1093: E4F1             ccpTypeRecord:                      ;
1094: E4F1 E1                     POP    HL                   ; Buffer Pointer                    ;
1095: E4F2 7E                     LD     A,(HL)               ; Get the Character                 ;
1096: E4F3 FE 1A                  CP     END_OF_FILE          ; Are we at EOF ?                   ;
1097: E4F5 CA D8 E6               JP     Z,RestoreDiskAtCmdEnd ;  yes, exit                        ;
1098: E4F8         ;
1099: E4F8 23                     INC    HL                   ; Increment the Buffer Pointer      ;
1100: E4F9 E5                     PUSH   HL                   ; Buffer Pointer                    ;
1101: E4FA CD 8E E6               CALL   PrintCharInA         ; Preserve BC                       ;
1102: E4FD 10 F2                  DJNZ   ccpTypeRecord        ; Iterate over the record       ;
1103: E4FF 18 DF                  JR     ccpTypeRead          ; Iterate over the file             ;
1104: E501         ;
1105: E501             ccpTypeEOF:                      ;
1106: E501 3D                     DEC    A                    ; Error returned ?                  ;
1107: E502 CA D8 E6               JP     Z,RestoreDiskAtCmdEnd ;  no, Restore Disk and exit        ;
1108: E505 CD 74 E6               CALL   PrintReadError       ; Report Error                      ;
1109: E508             ccpTypeError:                      ;
1110: E508 CD 1C E7               CALL   RestoreDisk          ; Restore Disk                      ;
1111: E50B C3 06 E2               JP     CommandError         ; Report error and exit             ;
1112: E50E         ;
1113: E50E         ;---------------------------------- Type File ------------------------------;
1114: E50E
1115: E50E         ;------------------------------- User Function -----------------------------;
1116: E50E         ; SYNTAX: USER n		                                             		;
1117: E50E         ;                                                                           ;
1118: E50E         ;  The User command allows maintenance of separate files in the same        ;
1119: E50E         ; directory. In the syntax line, n is an integer value in the range of 0-15 ;
1120: E50E         ; On cold start, the operator is automatically logged into user area        ;
1121: E50E         ; number 0.                                                                 ;
1122: E50E         ;  The active user number is maintained until changed by a subsequent USER  ;
1123: E50E         ; command, or until a cold start when user 0 is again assumed               ;
1124: E50E         ;
1125: E50E             ccpUser:                        ;
1126: E50E CD ED E6               CALL   GetNumberFromCmdLine ; Value returned in Acc.            ;
1127: E511 FE 10                  CP     16                   ; Greater than 16 ?                 ;
1128: E513 D2 06 E2               JP     NC,CommandError      ;  if yes, Error exit               ;
1129: E516 5F                     LD     E,A                  ; Prepare for SetUser call          ;
1130: E517 3A 48 E7               LD     A,(Token1)+1         ; Look past the number              ;
1131: E51A FE 20                  CP     SPACE                ; Is it a Space ?                   ;
1132: E51C CA 06 E2               JP     Z,CommandError       ;  yes, error exit                  ;
1133: E51F CD 25 E6               CALL   SetUser              ; Call BDOS to set new user         ;
1134: E522 C3 DB E6               JP     EndCommand           ; Exit cleanly                      ;
1135: E525         ;------------------------------- User Function -----------------------------;
1136: E525
1137: E525         ;------------------------------- User Command ------------------------------;
1138: E525             ccpUserCommand:
1139: E525 3A 48 E7               LD     A,(Token1)+1         ; Point at start CMD File name
1140: E528 FE 20                  CP     SPACE                ; Is it a Space ?
1141: E52A C2 41 E5               JP     NZ,ccpUseCmdrFileType ;  skip if not
1142: E52D
1143: E52D         ; Disk change A:, B: C: .....
1144: E52D 3A 68 E7               LD     A,(selectedDisk)     ; Get selected disk
1145: E530 B7                     OR     A                    ; Is it the default disk ?
1146: E531 CA DB E6               JP     Z,EndCommand         ; Exit if not
1147: E534 3D                     DEC    A                    ; Adjust so A=>0, B=>1, C=>2
1148: E535 32 6B E7               LD     (currentDisk),A      ; Update current Disk indicator
1149: E538 CD 1A E1               CALL   SetPage0CurDisk      ; Set user/disk in page 0
1150: E53B CD 07 E6               CALL   SelectDisk           ;  Go select this disk
1151: E53E C3 DB E6               JP     EndCommand           ; Exit Cleanly
1152: E541
1153: E541
1154: E541             ccpUseCmdrFileType:
1155: E541 DD 21 47 E7               LD     IX,Token1            ; Point at Token1
1156: E545 DD 7E 09               LD     A,(IX+9)             ; Get 1st char of CMD file type
1157: E548 FE 20                  CP     SPACE                ; Is it a SPACE ?
1158: E54A C2 06 E2               JP     NZ,CommandError      ;  Error exit (no type allowed)
1159: E54D CD C6 E6               CALL   SetDiskForCmd        ; Change disk if needed
1160: E550 DD 36 09 43               LD     (IX+9),ASCII_C
1161: E554 DD 36 0A 4F               LD     (IX+10),ASCII_O
1162: E558 DD 36 0B 4D               LD     (IX+11),ASCII_M      ; Set Token1's type to 'COM'
1163: E55C
1164: E55C
1165: E55C
1166: E55C
1167: E55C         ;/	LD		DE,Token1 + 9				; Point at CMD file's type
1168: E55C         ;/	LD		A,(DE)						; Get the 1st char
1169: E55C         ;/	CP		SPACE						; Is It a space ?
1170: E55C         ;/	JP		NZ,CommandError				;  Error exit (no type allowed)
1171: E55C         ;/	PUSH	DE							; Save the pointer
1172: E55C         ;/	CALL	SetDiskForCmd				; Change disk if needed
1173: E55C         ;/	POP		DE							; Restore the pointer
1174: E55C         ;/	LD		HL,comFileType					; .com
1175: E55C         ;/	CALL	CopyHL2DE3						; file type is set to .com
1176: E55C CD 3D E7               CALL   OpenToken1File       ; Open the CMD File
1177: E55F CA EA E5               JP     Z,ccpUserCmdError    ;  if error, then exit
1178: E562         ; file opened properly, read it into memory
1179: E562
1180: E562 21 00 01               LD     HL,TPA               ; Set Read buffer to TPA start
1181: E565             ccpUserReadCmdFile:
1182: E565 E5                     PUSH   HL                   ; Save current read buffer pointer
1183: E566 EB                     EX     DE,HL                ; Load buffer pointer for BDOS call
1184: E567 CD 4B E6               CALL   SetDMA               ; Set the DMA
1185: E56A 11 47 E7               LD     DE,Token1            ; Point at Token1's FCB
1186: E56D CD 17 E6               CALL   DiskRead             ; Read int the buffer
1187: E570 C2 85 E5               JP     NZ,ccpUserSetFCB1    ;  finished ?, skip
1188: E573
1189: E573 E1                     POP    HL                   ; Get prior Pointer
1190: E574 11 80 00               LD     DE,cpmRecordSize     ; Get Record size
1191: E577 19                     ADD    HL,DE                ; Need to make new pointer
1192: E578 11 00 E0               LD     DE,CcpBoundary       ;  Are we still in TPA ?
1193: E57B 7D                     LD     A,L
1194: E57C 93                     SUB    E
1195: E57D 7C                     LD     A,H
1196: E57E 9A                     SBC    A,D
1197: E57F D2 F0 E5               JP     NC,ccpUserCmdErrorBadLoad ;  no, error exit
1198: E582 C3 65 E5               JP     ccpUserReadCmdFile   ;  else go for another sector
1199: E585
1200: E585             ccpUserSetFCB1:
1201: E585 E1                     POP    HL                   ; Balance the Stack
1202: E586 3D                     DEC    A                    ; Test DiskRead return value
1203: E587 C2 F0 E5               JP     NZ,ccpUserCmdErrorBadLoad ;  error exit if problem
1204: E58A CD 1C E7               CALL   RestoreDisk          ; Restore Disk from before command
1205: E58D CD 26 E1               CALL   ParseToken1          ; Parse FCB1 from command line
1206: E590 CD 21 E1               CALL   ParseToken2          ; Parse FCB2 from command line
1207: E593 21 68 E7               LD     HL,selectedDisk      ; Point at selected disk
1208: E596         ;	PUSH	HL							; Save selected disk
1209: E596 7E                     LD     A,(HL)               ; Get selected disk
1210: E597 32 47 E7               LD     (Token1),A           ;  and put into FCB1
1211: E59A         ;	POP		HL
1212: E59A         ;	LD		A,(HL)
1213: E59A 32 57 E7               LD     (Token2),A           ;  and put into FCB2
1214: E59D AF                     XOR    A
1215: E59E 32 67 E7               LD     (currentRecord),A    ; record number set to zero
1216: E5A1 11 5C 00               LD     DE,FCB1              ; default FCB in page 0
1217: E5A4 21 47 E7               LD     HL,Token1
1218: E5A7 06 21                  LD     B,33
1219: E5A9 CD 5D E6               CALL   CopyHL2DEforB
1220: E5AC         ; move command line to buff
1221: E5AC 21 2E E2               LD     HL,commandBuffer
1222: E5AF             ccpUserFunction4:
1223: E5AF 7E                     LD     A,(HL)
1224: E5B0 B7                     OR     A
1225: E5B1 CA BD E5               JP     Z,ccpUserFunction5
1226: E5B4 FE 20                  CP     SPACE
1227: E5B6 CA BD E5               JP     Z,ccpUserFunction5
1228: E5B9 23                     INC    HL
1229: E5BA C3 AF E5               JP     ccpUserFunction4     ; for another scan
1230: E5BD         ; first blank position found
1231: E5BD             ccpUserFunction5:
1232: E5BD 06 00                  LD     B,0
1233: E5BF 11 81 00               LD     DE,DMABuffer+1
1234: E5C2         ; ready for the move
1235: E5C2             ccpUserFunction6:
1236: E5C2 7E                     LD     A,(HL)
1237: E5C3 12                     LD     (DE),AE
1238: E5C4 B7                     OR     A
1239: E5C5 CA CE E5               JP     Z,ccpUserFunction7
1240: E5C8         ;more to move
1241: E5C8 04                     INC    B
1242: E5C9 23                     INC    HL
1243: E5CA 13                     INC    DE
1244: E5CB C3 C2 E5               JP     ccpUserFunction6
1245: E5CE             ccpUserFunction7:                      ; B has character count
1246: E5CE 78                     LD     A,B
1247: E5CF 32 80 00               LD     (DMABuffer),A
1248: E5D2 CD 85 E6               CALL   CrLf
1249: E5D5         ; now go to the loaded program
1250: E5D5 CD 48 E6               CALL   SetDefaultDMA        ; default dma
1251: E5D8 CD 0B E1               CALL   SaveUserAndDisk      ; user code saved
1252: E5DB         ; low memory diska contains user code
1253: E5DB CD 00 01               CALL   TPA                  ; gone to the loaded program
1254: E5DE 31 F0 E7               LD     SP,Stack             ; may come back here
1255: E5E1 CD 1A E1               CALL   SetPage0CurDisk
1256: E5E4 CD 07 E6               CALL   SelectDisk
1257: E5E7 C3 26 E0               JP     ccpMainEntry
1258: E5EA
1259: E5EA             ccpUserCmdError:
1260: E5EA CD 1C E7               CALL   RestoreDisk
1261: E5ED C3 06 E2               JP     CommandError
1262: E5F0
1263: E5F0             ccpUserCmdErrorBadLoad:                      ; cannot load the program
1264: E5F0 01 F9 E5               LD     BC,msgBadLoad
1265: E5F3 CD 99 E6               CALL   PrintCrLfStringNull
1266: E5F6 C3 D8 E6               JP     RestoreDiskAtCmdEnd
1267: E5F9
1268: E5F9             msgBadLoad:
1269: E5F9 42 41 44 20 4C 4F 41 44 00                DB     'BAD LOAD',0
1270: E602         ;/comFileType:
1271: E602         ;/	DB		'COM' ;for com files
1272: E602         ;
1273: E602
1274: E602
1275: E602
1276: E602         ;------------------------------- User Command ------------------------------;
1277: E602
1278: E602
1279: E602         ;================================ BDOS API =================================;
1280: E602         ;------------------------------- Initialize --------------------------------;
1281: E602             Initialize:                      ;
1282: E602 0E 0D                  LD     C,fResetSystem       ; Load Function Number  - 0D        ;
1283: E604 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1284: E607         ;------------------------------- Initialize --------------------------------;
1285: E607         ;------------------------------- Select Disk -------------------------------;
1286: E607             SelectDisk:                      ;
1287: E607 5F                     LD     E,A                  ; Load Target disk                  ;
1288: E608 0E 0E                  LD     C,fSelectDisk        ; Load Function Number - 0EH        ;
1289: E60A C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1290: E60D         ;------------------------------- Select Disk -------------------------------;
1291: E60D         ;-------------------------------- Open File --------------------------------;
1292: E60D         ;Open the file				                                                ;
1293: E60D         ; On Entry DE = FCB to read 						                        ;
1294: E60D         ; Exits with Z-Flag Set if file not found									;
1295: E60D         ;					Reset if file found										;
1296: E60D             OpenFile:                       ;
1297: E60D 0E 0F                  LD     C,fOpenFile          ; Load Function Number - 0FH        ;
1298: E60F C3 2A E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1299: E612         ;-------------------------------- Open File --------------------------------;
1300: E612         ;------------------------------- Close File --------------------------------;
1301: E612         ;Close the file				                                                ;
1302: E612         ; On Entry DE = FCB to Close						                        ;
1303: E612         ; Exits with Z-Flag Set if file not found									;
1304: E612         ;					Reset if file found										;
1305: E612             CloseFile:                      ;
1306: E612 0E 10                  LD     C,fCloseFile         ; Load Function Number - 10H        ;
1307: E614 C3 2A E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1308: E617         ;------------------------------- Close File --------------------------------;
1309: E617         ;-------------------------------- Read File --------------------------------;
1310: E617         ;Read the next record from the file.										;
1311: E617         ; On Entry DE = FCB to read 						                        ;
1312: E617             DiskRead:                       ;
1313: E617 0E 14                  LD     C,fReadSeq           ; Load Function Number - 14H        ;
1314: E619 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1315: E61C B7                     OR     A                    ; set return code flags             ;
1316: E61D C9                     RET                         ;
1317: E61E         ;-------------------------------- Read File --------------------------------;
1318: E61E         ;----------------------------- Get Current Disk ----------------------------;
1319: E61E         ;Exits with current drive number to A (0=A,1=B....F=P)                      ;
1320: E61E             GetSelectedDrive:                      ;
1321: E61E 0E 19                  LD     C,fGetCurrentDisk    ; Load Function Number - 19H    ;
1322: E620 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1323: E623         ;----------------------------- Get Current Disk ----------------------------;
1324: E623         ;------------------------------ Get/Set User -------------------------------;
1325: E623         ;return current user code in A                                              ;
1326: E623             GetUser:                        ;
1327: E623 1E FF                  LD     E,0FFH               ; Set Entry Parameter for Get       ;
1328: E625         ; If E <> -1 then Set user number found in E                                ;
1329: E625             SetUser:                        ;
1330: E625 0E 20                  LD     C,fGetSetUserNumber  ; Load Function Number - 20H        ;
1331: E627 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1332: E62A         ;------------------------------ Get/Set User -------------------------------;
1333: E62A         ;------------------------------ BDOS and Inc A -----------------------------;
1334: E62A         ; Call B DOS                                                                ;
1335: E62A         ;  Store returned directory index                                           ;
1336: E62A         ;  Increment result.                                                        ;
1337: E62A         ; Exits with 	A =  0 if File Not Found                                    ;
1338: E62A         ;				  <> 0 if file found                                        ;
1339: E62A             BDOSandIncA:                      ;
1340: E62A CD 05 00               CALL   BDOS                 ; Make call to BDOS                 ;
1341: E62D 32 6C E7               LD     (directoryEntryNumber),A ; Save return value                 ;
1342: E630 3C                     INC    A                    ; Increment & (Re)Set Z-Flag        ;
1343: E631 C9                     RET                         ;
1344: E632         ;------------------------------ BDOS and Inc A -----------------------------;
1345: E632
1346: E632         ;-----------------------------
1347: E632         ;delete the file given by (DE)
1348: E632             DeleteFile:
1349: E632 0E 13                  LD     C,fDeleteFile
1350: E634 C3 05 00               JP     BDOS
1351: E637         ;-----------------------------
1352: E637         ;make the file given by (DE)
1353: E637             MakeFile:
1354: E637 0E 16                  LD     C,fMakeFile
1355: E639 C3 2A E6               JP     BDOSandIncA
1356: E63C         ;-----------
1357: E63C         ;/ ;read next record from Command FCB
1358: E63C         ;/ DiskReadCmdFCB:
1359: E63C         ;/ 	LD		DE,Token1
1360: E63C         ;/ 	JP		DiskRead
1361: E63C         ;-----------------------------
1362: E63C         ;write the next record to the file given by (DE)
1363: E63C             DiskWrite:
1364: E63C 0E 15                  LD     C,fWriteSeq
1365: E63E CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1366: E641 B7                     OR     A                    ; set return code flags
1367: E642 C9                     RET
1368: E643         ; rename a file give bu (DE)
1369: E643             RenameFile:
1370: E643 0E 17                  LD     C,fRenameFile
1371: E645 C3 05 00               JP     BDOS
1372: E648         ;-----------------------------
1373: E648         ;set default buffer dma address
1374: E648             SetDefaultDMA:
1375: E648 11 80 00               LD     DE,DMABuffer
1376: E64B         ;---------
1377: E64B         ;set dma address to d,e
1378: E64B             SetDMA:
1379: E64B 0E 1A                  LD     C,fSetDMA
1380: E64D C3 05 00               JP     BDOS
1381: E650         ;-----------------------------
1382: E650         ;----------------------------------------------------------------
1383: E650         ;-----------------------------
1384: E650         ;-----------------------------
1385: E650         ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1386: E650
1387: E650
1388: E650         ;-----------------------------
1389: E650         ;*****************************************************************
1390: E650
1391: E650
1392: E650             PrintSpace:
1393: E650 3E 20                  LD     A,SPACE
1394: E652 C3 55 E6               JP     PrintSaveBC
1395: E655         ;-----------------------------
1396: E655         ;print character, but save b,c registers
1397: E655             PrintSaveBC:
1398: E655 C5                     PUSH   BC
1399: E656 CD 8E E6               CALL   PrintCharInA
1400: E659 C1                     POP    BC
1401: E65A C9                     RET
1402: E65B         ;-----------------------------
1403: E65B         ;move 3 characters from h,l to d,e addresses
1404: E65B             CopyHL2DE3:                      ;XXXXXXXXX
1405: E65B 06 03                  LD     B,3
1406: E65D             CopyHL2DEforB:
1407: E65D 7E                     LD     A,(HL)
1408: E65E 12                     LD     (DE),AE
1409: E65F 23                     INC    HL
1410: E660 13                     INC    DE
1411: E661 05                     DEC    B
1412: E662 C2 5D E6               JP     NZ,CopyHL2DEforB
1413: E665 C9                     RET
1414: E666         ;-----------------------------
1415: E666         ;return (HL) = (A) + (HL)
1416: E666             AddA2HL:
1417: E666 85                     ADD    A,L
1418: E667 6F                     LD     L,A
1419: E668 D0                     RET    NC
1420: E669 24                     INC    H
1421: E66A C9                     RET
1422: E66B         ;-----------------------------
1423: E66B         ;DMABuffer + a + c to h,l followed by fetch
1424: E66B             GetByteAtAandCandDMA:
1425: E66B 21 80 00               LD     HL,DMABuffer         ; 0080H
1426: E66E 81                     ADD    A,C
1427: E66F CD 66 E6               CALL   AddA2HL
1428: E672 7E                     LD     A,(HL)
1429: E673 C9                     RET
1430: E674         ;-----------------------------
1431: E674         ;-----------------------------
1432: E674         ;*****************************************************************
1433: E674         ;************************ Error messages ******************************
1434: E674         ;*****************************************************************
1435: E674         ;print the read error message
1436: E674             PrintReadError:
1437: E674 01 7A E6               LD     BC,msgReadErr
1438: E677 C3 99 E6               JP     PrintCrLfStringNull
1439: E67A             msgReadErr:
1440: E67A 52 45 41 44 20 45 52 52 4F 52 00                DB     'READ ERROR',0
1441: E685         ;-----------------------------
1442: E685
1443: E685
1444: E685         ;*****************************************************************
1445: E685         ;*****************************************************************
1446: E685         ;*****************************************************************
1447: E685         ; save save memory image
1448: E685         ;*****************************************************************
1449: E685         ;*****************************************************************
1450: E685         ;User defined function
1451: E685         ;*****************************************************************
1452: E685
1453: E685         ;*****************************************************************
1454: E685         ;*****************************************************************
1455: E685         ;*****************************************************************
1456: E685         ;=============================== Utilities =================================;
1457: E685         ;-------------------------------- CR / LF ----------------------------------;
1458: E685         ;Sent Carriage Return Line Feed to Console                                  ;
1459: E685             CrLf:                           ;
1460: E685 1E 0D                  LD     E,CR                 ; Carriage Return                   ;
1461: E687 CD 91 E6               CALL   PrintCharInE         ;
1462: E68A 1E 0A                  LD     E,LF                 ; Line Feed                         ;
1463: E68C 18 03                  JR     PrintCharInE         ;
1464: E68E         ;-------------------------------- CR / LF ----------------------------------;
1465: E68E         ;------------------------------- PrintCharInA ------------------------------;
1466: E68E         ; Print character                                                           ;
1467: E68E         ; On Entry A = Character to Send to Console                                 ;
1468: E68E             PrintCharInA:                      ;
1469: E68E 5F                     LD     E,A                  ; move char to E                    ;
1470: E68F 18 00                  JR     PrintCharInE         ;
1471: E691         ;------------------------------- PrintCharInA ------------------------------;
1472: E691         ;------------------------------- PrintCharInE ------------------------------;
1473: E691         ; Print character                                                           ;
1474: E691         ; On Entry E = Character to Send to Console                                 ;
1475: E691         ; Preserves BC                                ;                             ;
1476: E691             PrintCharInE:                      ;
1477: E691 C5                     PUSH   BC                   ; Preserve BC                       ;
1478: E692 0E 02                  LD     C,fConsoleOut        ; Load Function Number         		;
1479: E694 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1480: E697 C1                     POP    BC                   ; Restore BC                        ;
1481: E698 C9                     RET                         ;
1482: E699         ;------------------------------- PrintCharInE ------------------------------;
1483: E699         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1484: E699         ;print CRLF then null terminated string at (BC)                             ;
1485: E699             PrintCrLfStringNull:                      ;
1486: E699 C5                     PUSH   BC                   ; Save string pointer               ;
1487: E69A CD 85 E6               CALL   CrLf                 ; Send CR/LF                        ;
1488: E69D E1                     POP    HL                   ; Restore pointer & fall thru       ;
1489: E69E         ;print null terminated string from (HL)                                     ;
1490: E69E             PrintStringNull:                      ;
1491: E69E 7E                     LD     A,(HL)               ; Get the next character            ;
1492: E69F B7                     OR     A                    ; Is it the Null terminator ?       ;
1493: E6A0 C8                     RET    Z                    ;  exit if yes                      ;
1494: E6A1 23                     INC    HL                   ; Move string pointer               ;
1495: E6A2 E5                     PUSH   HL                   ; Save for next iteration           ;
1496: E6A3 CD 8E E6               CALL   PrintCharInA         ; Send the character to the console ;
1497: E6A6 E1                     POP    HL                   ; string pointer                    ;
1498: E6A7 C3 9E E6               JP     PrintStringNull      ; Loop for more                     ;
1499: E6AA         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1500: E6AA         ;-------------------------- Print 'No File' Message ------------------------;
1501: E6AA         ;print 'no file' message on console                                        ;
1502: E6AA             PrintNoFile:                      ;
1503: E6AA 01 B0 E6               LD     BC,msgNoFile         ; Point to the message              ;
1504: E6AD C3 99 E6               JP     PrintCrLfStringNull  ; Go print it & return to caller    ;
1505: E6B0         ;
1506: E6B0 4E 4F 20 46 49 4C 45 00     msgNoFile: DB     'NO FILE',0          ;
1507: E6B8         ;-------------------------- Print 'No File' Message ------------------------;
1508: E6B8
1509: E6B8
1510: E6B8
1511: E6B8
1512: E6B8
1513: E6B8
1514: E6B8
1515: E6B8
1516: E6B8         ;------------------------- Check For Console Input -------------------------;
1517: E6B8         ;check for a character ready at the console                                 ;
1518: E6B8         ;Exits with	Z-Flag  set if there has been no character input                ;
1519: E6B8         ;					reset if there is a character waiting                   ;
1520: E6B8         ;			A = character input, if Z-Flag reset                            ;
1521: E6B8             CheckForConsoleChar:                      ;
1522: E6B8 0E 0B                  LD     C,fGetConsoleStatus  ; Load Function Number - 0BH        ;
1523: E6BA CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1524: E6BD B7                     OR     A                    ; Check return value                ;
1525: E6BE C8                     RET    Z                    ; Return if no char waiting         ;
1526: E6BF         ;
1527: E6BF 0E 01                  LD     C,fConsoleIn         ; Load Function Number - 01H        ;
1528: E6C1 CD 05 00               CALL   BDOS                 ; character cleared             ;
1529: E6C4 B7                     OR     A                    ; Resets the Z-Flag                 ;
1530: E6C5 C9                     RET                         ;
1531: E6C6         ;------------------------- Check For Console Input -------------------------;
1532: E6C6         ;--------------------------- Set Disk For Command --------------------------;
1533: E6C6         ;change disks for this command, if requested                                ;
1534: E6C6             SetDiskForCmd:                      ;
1535: E6C6 AF                     XOR    A                    ; Set to 0                          ;
1536: E6C7 32 47 E7               LD     (Token1),A           ; Set Token's disk to default       ;
1537: E6CA 3A 68 E7               LD     A,(selectedDisk)     ; Get the selected disk             ;
1538: E6CD B7                     OR     A                    ; Is it also set for default ?      ;
1539: E6CE C8                     RET    Z                    ;  exit if yes                      ;
1540: E6CF 3D                     DEC    A                    ; Adjust so A=0,B=2....             ;
1541: E6D0 21 6B E7               LD     HL,currentDisk       ; Point at the current disk         ;
1542: E6D3 BE                     CP     M                    ; Are they the same ?               ;
1543: E6D4 C8                     RET    Z                    ;  exit if yes                      ;
1544: E6D5 C3 07 E6               JP     SelectDisk           ;  else go select the disk          ;
1545: E6D8         ;
1546: E6D8         ;--------------------------- Set Disk For Command --------------------------;
1547: E6D8         ;------------------------ Restore Disk at Command End ----------------------;
1548: E6D8         ;Restore disk from before command, fall thru to end of command              ;
1549: E6D8             RestoreDiskAtCmdEnd:                      ;
1550: E6D8 CD 1C E7               CALL   RestoreDisk          ; Restore Disk from before command  ;
1551: E6DB         ;
1552: E6DB         ;End of intrinsic command                                                   ;
1553: E6DB             EndCommand:                      ;
1554: E6DB CD 26 E1               CALL   ParseToken1          ; Check for garbage at end of line  ;
1555: E6DE 3A 48 E7               LD     A,(Token1)+1         ; Point at 1st character            ;
1556: E6E1 D6 20                  SUB    SPACE                ; Get ??                            ;
1557: E6E3 21 68 E7               LD     HL,selectedDisk      ;
1558: E6E6 B6                     OR     M                    ; Are they equal ?                  ;
1559: E6E7         ; 0 in accumulator if no disk selected, and blank FCB                       ;
1560: E6E7 C2 06 E2               JP     NZ,CommandError      ;  no, report error                 ;
1561: E6EA C3 26 E0               JP     ccpMainEntry         ;  else go back to the Start        ;
1562: E6ED         ;------------------------ Restore Disk at Command End ----------------------;
1563: E6ED
1564: E6ED         ;------------------------ Get Number From Command Line ---------------------;
1565: E6ED         ; Get number from the command line                                          ;
1566: E6ED         ; Exits with A = Value                                                      ;
1567: E6ED             GetNumberFromCmdLine:                      ;
1568: E6ED CD 26 E1               CALL   ParseToken1          ; Get token                         ;
1569: E6F0 3A 68 E7               LD     A,(selectedDisk)     ; Get currently selected disk       ;
1570: E6F3 B7                     OR     A                    ; Is it current default disk ?      ;
1571: E6F4 C2 06 E2               JP     NZ,CommandError      ;  no, then error exit              ;
1572: E6F7         ; convert the byte value in Token1 to binary                                ;
1573: E6F7         ;
1574: E6F7 21 00 00               LD     HL,0000              ;
1575: E6FA 01 00 00               LD     BC,0000              ; Clear the registers               ;
1576: E6FD         ;
1577: E6FD DD 21 48 E7               LD     IX,Token1+1          ;
1578: E701             CalculateNumber:                      ;
1579: E701 DD 7E 00               LD     A,(IX+0)             ; Get Character                     ;
1580: E704 DD 23                  INC    IX                   ; Adjust for next time around       ;
1581: E706 FE 20                  CP     SPACE                ; Terminating character ?           ;
1582: E708 28 10                  JR     Z,ReturnNumericValue ;  get out if yes                   ;
1583: E70A D6 30                  SUB    ASCII_ZERO           ; Make binary                       ;
1584: E70C FE 0A                  CP     0AH                  ; Is it a digit ?                   ;
1585: E70E 30 0A                  JR     NC,ReturnNumericValue ;  get out if no                    ;
1586: E710 29                     ADD    HL,HL                ; Prior value * 2                   ;
1587: E711 E5                     PUSH   HL                   ; Move *2                           ;
1588: E712 D1                     POP    DE                   ;  to DE                            ;
1589: E713 29                     ADD    HL,HL                ; Prior value * 4                   ;
1590: E714 29                     ADD    HL,HL                ; Prior value * 8                   ;
1591: E715 19                     ADD    HL,DE                ; Add * 2 gives Prior value * 10    ;
1592: E716 4F                     LD     C,A                  ; Get this digit                    ;
1593: E717 09                     ADD    HL,BC                ; and add it                        ;
1594: E718 18 E7                  JR     CalculateNumber      ;
1595: E71A         ;
1596: E71A             ReturnNumericValue:                      ;
1597: E71A 7D                     LD     A,L                  ; Put result in Acc                 ;
1598: E71B C9                     RET                         ;
1599: E71C         ;
1600: E71C         ;------------------------ Get Number From Command Line ---------------------;
1601: E71C         ;-------------------------------- Restore Disk -----------------------------;
1602: E71C         ; Restore Disk from before command                                          ;
1603: E71C             RestoreDisk:                      ;
1604: E71C 3A 68 E7               LD     A,(selectedDisk)     ; Get disk selected by command      ;
1605: E71F B7                     OR     A                    ; Is it the Default ?               ;
1606: E720 C8                     RET    Z                    ;  yes, the nothing to do           ;
1607: E721 3D                     DEC    A                    ; Change to 0=A, 1=B....            ;
1608: E722 21 6B E7               LD     HL,currentDisk       ;
1609: E725 BE                     CP     M                    ; Is it the current disk ?          ;
1610: E726 C8                     RET    Z                    ;  yes, the nothing to do           ;
1611: E727 3A 6B E7               LD     A,(currentDisk)      ;  else get current disk            ;
1612: E72A C3 07 E6               JP     SelectDisk           ; Select it                         ;
1613: E72D         ;-------------------------------- Restore Disk -----------------------------;
1614: E72D         ;-------------------------- Find First Token1 Entry ------------------------;
1615: E72D         ;Search for Token1 file                                                     ;
1616: E72D             FindFirstToken1File:                      ;
1617: E72D 11 47 E7               LD     DE,Token1            ; Point at Token1                   ;
1618: E730 C3 33 E7               JP     SearchForFirst       ; Go look for it                    ;
1619: E733         ;-------------------------- Find First Token1 Entry ------------------------;
1620: E733         ;----------------------------- Find First Entry ----------------------------;
1621: E733         ;Search for the first directory entry given by DE                           ;
1622: E733         ;Upon entry  DE = FCB                                                       ;
1623: E733             SearchForFirst:                      ;
1624: E733 0E 11                  LD     C,fSearchFirst       ; Load Function Number - 11H        ;
1625: E735 C3 2A E6               JP     BDOSandIncA          ; make BDOS call & set dir index   	;
1626: E738         ;----------------------------- Find First Entry ----------------------------;
1627: E738         ;----------------------------- Find  Next Entry ----------------------------;
1628: E738         ;Search for the next occurrence of the file given DE                        ;
1629: E738         ;Upon entry  DE = FCB                                                       ;
1630: E738             SearchForNext:                      ;
1631: E738 0E 12                  LD     C,fSearchNext        ; Load Function Number - 12H        ;
1632: E73A C3 2A E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1633: E73D         ;----------------------------- Find  Next Entry ----------------------------;
1634: E73D         ;----------------------------- Open Token1 File ----------------------------;
1635: E73D             OpenToken1File:                      ;
1636: E73D AF                     XOR    A                    ; Clear Acc                         ;
1637: E73E 32 67 E7               LD     (currentRecord),A    ; Initialize  next record for I/O   ;
1638: E741 11 47 E7               LD     DE,Token1            ; Point at the FCB                  ;
1639: E744 C3 0D E6               JP     OpenFile             ; Let BDOS open the file            ;
1640: E747         ;----------------------------- Open Token1 File ----------------------------;
1641: E747
1642: E747
1643: E747
1644: E747
1645: E747
1646: E747         ; UT
1647: E747         ;*****************************************************************
1648: E747         ;************************ Data Area ******************************
1649: E747         ;*****************************************************************
1650: E747         ;------------------------------ Command Buffer -----------------------------;
1651: E747         ;;
1652: E747         ;;
1653: E747             Token1:    DS     16                   ; Command Token
1654: E757             Token2:    DS     16                   ; Command Token
1655: E767
1656: E767
1657: E767
1658: E767 00          currentRecord: DB     00H                  ; current record to read/write
1659: E768 00          selectedDisk: DB     00H                  ; selected disk for current operation none=0, a=1, b=2 ...
1660: E769         ;
1661: E769         ; bufferPointer:		DB		00H				; buffer pointer
1662: E769         ;------------------------------------
1663: E769 00 00       tokenStart: DW     0000H                ; staddr starting address of current Fill FCB request
1664: E76B         ;----------------------------
1665: E76B         ; (command executed initially if commandLength non zero)
1666: E76B         ;--------------------------------- Variables -------------------------------;
1667: E76B 00          currentDisk: DB     00H                  ; Current disk
1668: E76C 00          directoryEntryNumber: DB     00H                  ; Index into Directory Buffer
1669: E76D         ;--------------------------------- Variables -------------------------------;
1670: E76D
1671: E76D             endOfCode:
1672: E76D                        ORG    BDOSBase-10H
1673: E7F0             Stack:                          ; Top Of Stack
1674: E7F0
1675: E7F0         ;Z_HighestLocation:
1676: E7F0             ZZ_MemoryLeft EQU    (BDOSBase-1) - endOfCode
1677: E7F0
1678: E7F0
1679: E7F0
1680: E7F0
1681: E7F0
           ************************   Xref   ************************
0000: $               E7F0   0768
1416: AddA2HL         E666   1427
0085: ASCII_A         0041   0332 0842
0086: ASCII_C         0043   1160
0087: ASCII_K         004B
0094: ASCII_LO_A      0061
0095: ASCII_LO_K      006B
0096: ASCII_LO_P      0070
0295: ASCII_M         004D   1162
0037: ASCII_MASK      007F   0860
0088: ASCII_N         004E
0296: ASCII_O         004F   1161
0089: ASCII_Q         0051
0090: ASCII_R         0052
0091: ASCII_W         0057
0092: ASCII_Y         0059   0908
0072: ASCII_ZERO      0030   1583
0066: ASTERISK        002A   0576
0289: BDOS            0005   0422 1283 1289 1314 1322 1331 1340 1350 1365 1371 1380 1479 1523 1528
1339: BDOSandIncA     E62A   1298 1307 1355 1625 1632
0152: BDOSBase        E800   0153 0155 1672 1676
0121: BDOSE           0005   0122
0153: BDOSEntry       E800
0142: BDOSLength      0E00   0145 0155 0156
0055: BELL            0007
0155: BIOSBase        F600
0143: BIOSLength      0A00   0145
0115: BIOSPAGE        0002
0156: BIOSStart       F600
0252: BlockSize       0800   0274
0768: builtInCMDCount 0006   0678
0761: builtInCMDNames E2D1   0674 0768
0759: builtInCMDNameSize 0004   0681 0768
0770: builtInCMDVector E2E9   0350
0033: BYTE            0001
1578: CalculateNumber E701   1594
0093: CARET           005E
0299: CcpBoundary     E000   1192
0801: ccpDirAll       E308   0804
0852: ccpDirDisplayFile E35D   0846
0848: ccpDirDisplayFile0 E355   0835
0855: ccpDirDisplayFileLoop E360   0870
0791: ccpDirectory    E2F7   0771
0878: ccpDirEnd       E38C   0814 0875
0872: ccpDirLoopBottom E37E   0825
0813: ccpDirLoopTop   E317   0877
0806: ccpDirQualified E30D   0797
0150: CCPEntry        E000   0152 0156 0298
0894: ccpErase        E391   0772
0913: ccpEraseFile    E3B4   0897
0141: CCPLength       0800   0145 0152 0156
0328: ccpMainEntry    E026   0415 0732 0905 0909 1257 1561
0338: CcpParseCommand E03C   0326
0931: ccpRename       E3CF   0775
0973: ccpRename2      E416   0968
0984: ccpRenameError1 E42A   0978
0988: ccpRenameError2 E430   0954 0961 0972
0992: ccpRenameError3 E436   0938
0940: ccpRenameFCB1   E3E2
0956: ccpRenameFCB2   E3FD   0952
1007: ccpSave         E44B   0774
1045: ccpSaveClose    E48F   1030
1051: ccpSaveError1   E499   1018
1055: ccpSaveError2   E4A1   1041
1059: ccpSaveExit     E4A7   1049 1054
1027: ccpSaveWrite    E472   1042
0307: CcpStart        E000
1075: ccpType         E4CE   0773
1105: ccpTypeEOF      E501   1087
1109: ccpTypeError    E508   1080
1084: ccpTypeRead     E4E0   1103
1093: ccpTypeRecord   E4F1   1102
1154: ccpUseCmdrFileType E541   1141
1125: ccpUser         E50E   0776
1259: ccpUserCmdError E5EA   1177
1263: ccpUserCmdErrorBadLoad E5F0   1197 1203
1138: ccpUserCommand  E525   0347 0777
1222: ccpUserFunction4 E5AF   1229
1231: ccpUserFunction5 E5BD   1225 1227
1235: ccpUserFunction6 E5C2   1244
1245: ccpUserFunction7 E5CE   1239
1181: ccpUserReadCmdFile E565   1198
1200: ccpUserSetFCB1  E585   1187
1521: CheckForConsoleChar E6B8   0412 0874
1305: CloseFile       E612   0403 1047
0073: COLON           003A   0518 0660 0844 0850
0068: COMMA           002C
0739: commandBuffer   E22E   0410 0439 0741 1221
0741: commandBufferPointer E2AE   0440 0504 0548 0912 0948 0959
0712: CommandError    E206   0344 0652 0933 0990 1011 1077 1111 1128 1132 1158 1261 1560 1571
0727: CommandErrorExit E21E   0718 0720
0715: CommandErrorLoop E20C   0725
0738: commandLength   E22D   0324 0388 0427 0903
0737: commandMaxLength E22C   0420
0127: ComTail         0080   0128
0129: ComTailChars    0082
0128: ComTailCount    0081   0129
1404: CopyHL2DE3      E65B
1406: CopyHL2DEforB   E65D   1219 1412
0229: cpmRecordSize   0080   0231 0234 0236 0389 1033 1089 1190
0058: CR              000D   1460
1459: CrLf            E685   0330 0713 0730 0838 1082 1248 1487
0041: CTRL_C          0003
0042: CTRL_E          0005
0043: CTRL_H          0008
0044: CTRL_K          000B
0045: CTRL_L          000C
0046: CTRL_P          0010
0047: CTRL_R          0012
0048: CTRL_S          0013
0049: CTRL_U          0015
0050: CTRL_X          0018
0051: CTRL_Z          001A
1667: currentDisk     E76B   0342 0371 0406 0466 0477 0485 0524 1148 1541 1608 1611
1658: currentRecord   E767   1020 1215 1637
0069: DASH            002D
0263: DataBlocks      02C7   0273
0262: DataSectors     0B1C   0263
1348: DeleteFile      E632   0465 0916 1015
0456: DeleteSubmitFile E0F3   0414 0418 0731
0234: DirBuffSize     0080
0883: dirCharCount    E390   0829 0862
0249: DirectoryBlockCount 0002   0274
1668: directoryEntryNumber E76C   0816 1341
0236: DirectoryEntryPerRecord 0004   0277
0233: DirEntrySize    0020   0236 0274
0881: dirFileCount    E38F   0808 0831
0221: DiskCommandBlock 0046
0220: DiskControlByte 0045
0223: DiskControlTable 0040
1312: DiskRead        E617   0383 1086 1186
0225: DiskReadCode    0001
0230: diskSectorSize  0200   0231 0252 0260
0219: DiskStatusLocation 0043
1363: DiskWrite       E63C   1038
0226: DiskWriteCode   0002
0132: DMABuffer       0080   0339 0387 0822 1091 1233 1247 1375 1425
0062: DOLLAR          0024
0275: dpb3hdAL0       00C0
0276: dpb3hdAL1       0000
0271: dpb3hdBLM       000F
0270: dpb3hdBSH       0004
0277: dpb3hdCKS       0020
0274: dpb3hdDRM       007F   0277
0273: dpb3hdDSM       02C6
0272: dpb3hdEXM       0000
0279: dpb3hdNOH       0002
0278: dpb3hdOFF       0001
0269: dpb3hdSPT       0090
0136: END_OF_FILE     001A   1096
1553: EndCommand      E6DB   1134 1146 1151
1671: endOfCode       E76D   1676
0039: EndOfMessage    0000
0077: EQUAL_SIGN      003D   0654 0951
0060: EXCLAIM_POINT   0021
0028: FALSE           0000
0124: FCB1            005C   0125 1216
0125: FCB2            006C
0291: fcbSystemFileIndex 000A   0824
0169: fCloseFile      0010   1306
0160: fConsoleIn      0001   1527
0161: fConsoleOut     0002   1090 1478
0172: fDeleteFile     0013   1349
0164: fGetConsoleStatus 000B   1522
0178: fGetCurrentDisk 0019   1321
0177: fGetLoginVector 0018
0180: fGetSetUserNumber 0020   1330
0165: fGetVersion     000C
0292: FILE_NAME_SIZE  0008   0535 0551 0800 0896
0293: FILE_TYPE_SIZE  0003   0539 0551 0800 0896
0627: FillWithAcc     E1AE   0546 0630
0625: FillWithSpace   E1AC   0594 0615
1616: FindFirstToken1File E72D   0810 0937 0977
0175: fMakeFile       0016   1354
0168: fOpenFile       000F   1297
0571: FormatElement   E17F   0536 0541 0585
0581: FormatElement1  E190   0577
0584: FormatElement2  E192   0579
0162: fPrintString    0009
0173: fReadSeq        0014   1313
0163: fReadString     000A   0421
0176: fRenameFile     0017   1370
0166: fResetSystem    000D   1282
0170: fSearchFirst    0011   1624
0171: fSearchNext     0012   1631
0167: fSelectDisk     000E   1288
0179: fSetDMA         001A   1379
0174: fWriteSeq       0015   1364
1424: GetByteAtAandCandDMA E66B
1567: GetNumberFromCmdLine E6ED   1008 1126
1320: GetSelectedDrive E61E   0331 0341 0840
1326: GetUser         E623   0472
0078: GREATER_THAN    003E   0334 0666
0061: HASH_TAG        0023
1281: Initialize      E602   0317
0673: IntrinsicFunction E1DC   0349
0676: IntrinsicFunction1 E1E1   0704
0682: IntrinsicFunction2 E1EA   0689
0697: IntrinsicFunction3 E1FD   0685 0700
0702: IntrinsicFunction4 E202   0693
0116: IOBYTE          0003
0647: IsItADelimiter  E1BD   0572 0588
0608: IsItDot         E1A0   0540
0064: L_PAREN         0028
0081: LEFT_ARROW      005F   0953
0097: LEFT_CURLY      007B
0145: LengthInBytes   2000   0146 0150 0260
0146: LengthInK       0009
0076: LESS_THAN       003C   0664
0057: LF              000A   1462
0031: LO_NIBBLE_MASK  000F   0321
1353: MakeFile        E637   1017
0736: maximumBufferSize 007F   0737 0739
0148: MemorySize      0040   0150
1268: msgBadLoad      E5F9   1264
0921: msgEraseAll     E3C4   0899
0997: msgFileExists   E43F   0993
1063: msgNoDirSpace   E4AD   1052
1065: msgNoDiskSpace  E4C0   1056
1506: msgNoFile       E6B0   1503
1439: msgReadErr      E67A   1437
0261: myOffset        0001   0262 0278
0635: NextNonBlankChar E1B3   0505 0642 0950
0425: NoRead          E0D5   0413
0417: NotSubmitFile   E0C4   0369 0378 0384 0404
0053: NULL            0000
0245: NumberOfHeads   0002   0256 0258 0269 0279
0242: NumberOfLogicalDisks 0004
0030: OFF             0000
0029: ON              FFFF
1296: OpenFile        E60D   0377 1639
1635: OpenToken1File  E73D   1079 1176
0593: PadTheElement   E19C   0573
0499: ParseToken      E129   0496
0497: ParseToken1     E126   0343 0792 0895 0932 0960 1010 1076 1205 1554 1568
0494: ParseToken2     E121   1206
0063: PERCENT         0025
0070: PERIOD          002E   0611 0658
0119: Pg0CurentDisk   0004   0322 0479 0486
0118: Pg0CurentUser   0004   0119
0067: PLUS_SIGN       002B
1468: PrintCharInA    E68E   0333 0335 0722 0729 0861 1101 1399 1496
1476: PrintCharInE    E691   1461 1463 1470
1485: PrintCrLfStringNull E699   0900 0994 1053 1057 1265 1438 1504
1502: PrintNoFile     E6AA   0811 0918 0985
1436: PrintReadError  E674   1108
1397: PrintSaveBC     E655   0843 0845 0851 1394
1392: PrintSpace      E650   0849 0853 0867
1490: PrintStringNull E69E   0411 1498
0079: QMARK           003F   0553 0578 0728 0802
0554: QuestionMarkCount E175   0560
0559: QuestionMarkCount1 E17A   0557
0065: R_PAREN         0029
0112: RAM             0000   0114 0115 0116 0118 0121 0124 0127 0132 0134
0366: ReadCommand     E065   0336 0902
0254: RecordsPerBlock 0010
0238: RecordsPerExtent 0080
0231: recordsPerSector 0004   0254 0269
1369: RenameFile      E643   0981
1603: RestoreDisk     E71C   0989 1110 1204 1260 1550
1549: RestoreDiskAtCmdEnd E6D8   0879 0919 0982 0986 0995 1061 1097 1107 1266
1596: ReturnNumericValue E71A   1582 1585
0082: RUBOUT          007F
0471: SaveUserAndDisk E10B   0419 1251
1623: SearchForFirst  E733   1618
1630: SearchForNext   E738   0876
0283: SectorMask      0003
0248: SectorsPerBlock 0004   0252 0254 0257 0263 0283
0258: SectorsPerCylinder 0024   0261 0262
0247: SectorsPerTrack 0012   0256 0258 0269
1286: SelectDisk      E607   0323 0374 0408 0463 0467 1150 1256 1544 1612
1659: selectedDisk    E768   0345 0503 0530 0934 0965 1144 1207 1537 1557 1569 1604
0075: SEMICOLON       003B   0662
1374: SetDefaultDMA   E648   1060 1250
1534: SetDiskForCmd   E6C6   0793 0914 0936 1012 1078 1159
1378: SetDMA          E64B   0340 1036 1184
0534: SetFileName     E157   0526
0484: SetPage0CurDisk E11A   0423 1149 1255
0538: SetType         E15C
1329: SetUser         E625   0315 1133
0071: SLASH           002F
0054: SOH             0001
0059: SPACE           0020   0626 0639 0651 0692 0717 0796 1131 1140 1157 1226 1393 1556 1581
1673: Stack           E7F0   0308 0329 1254
0755: submitCR        E2D0   0381
0749: submitExtent    E2BC
0747: submitFCB       E2B1   0376 0382 0402 0464
0745: submitFlag      E2B0   0318 0367 0457
0751: submitFWF       E2BE   0395
0754: submitMap       E2C0
0753: submitRC        E2BF   0379 0400
0750: submitS1        E2BD
0752: submitS2        E2BE
0748: submitType      E2B9
0260: SystemSectors   0011   0261
0056: TAB             0009
1653: Token1          E747   0498 0680 0794 0915 0942 0976 0980 1013 1037 1046 1085 1130 1139 1155 1185 1210 1217 1536 1555 1577 1617 1638
1654: Token2          E757   0495 0943 1213
1663: tokenStart      E769   0506 0714
0122: TopRAM          0007
0257: TotalNumberOfBlocks 02D0
0256: TotalNumberOfSectors 0B40   0257 0262
0134: TPA             0100   1025 1180 1253
0246: TracksPerHead   0050   0256
0027: TRUE            FFFF
0587: TruncateElement E194   0591
0080: UNDER_SCORE     005F   0656
0446: UpCase          E0EA   0432
0429: UpCaseLoop      E0D9   0434
0523: UseCurrentDisk  E14A   0513
0528: UseTokensDisk   E151   0519
0114: WarmBoot        0000
0034: WORD            0002
0194: WriteAllocated  0000
0196: WriteCleanBuffer 0002
0195: WriteDirectory  0001
0038: ZERO            0000
1676: ZZ_MemoryLeft   0092
