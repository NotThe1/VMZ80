0001: E000         ;     File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
0002: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm
0003: E000
0004: E000         ; Entering CCP
0005: E000
0006: E000         ; CCP.Z80
0007: E000         ;
0008: E000         ; 2019-02-19 Started to refactor to Z80 idiom
0009: E000
0010: E000         ; 2017-03-02 Refactored the CP/M Suite
0011: E000         ; 2014-01-16
0012: E000         ; 2014-05-01  :  Frank Martyn
0013: E000
0014: E000         ; replace systemFile with fcbSystemFileIndex
0015: E000
0016: E000                        Include ./stdHeader.Z80
0017: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0018: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0019: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0020: E000         ; stdHeader.asm
0021: E000         ; standard equates
0022: E000
0023: E000         ; 2017-03-02 Refactored the CP/M Suite
0024: E000
0025: E000
0026: E000             TRUE       EQU    -1                   ; not false
0027: E000             FALSE      EQU    0000H
0028: E000             ON         EQU    -1
0029: E000             OFF        EQU    0000H
0030: E000             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0031: E000
0032: E000             BYTE       EQU    1                    ; number of bytes for "byte" type
0033: E000             WORD       EQU    2                    ; number of bytes for "word" type
0034: E000
0035: E000
0036: E000             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0037: E000             ZERO       EQU    00H                  ; Zero
0038: E000             EndOfMessage EQU    00H
0039: E000
0040: E000             CTRL_C     EQU    03H                  ; ETX
0041: E000             CTRL_E     EQU    05H                  ; physical eol
0042: E000             CTRL_H     EQU    08H                  ; backspace
0043: E000             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0044: E000             CTRL_L     EQU    0CH                  ; FF - Form feed
0045: E000             CTRL_P     EQU    10H                  ; prnt toggle
0046: E000             CTRL_R     EQU    12H                  ; repeat line
0047: E000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0048: E000             CTRL_U     EQU    15H                  ; line delete
0049: E000             CTRL_X     EQU    18H                  ; =ctl-u
0050: E000             CTRL_Z     EQU    1AH                  ; end of file
0051: E000
0052: E000             NULL       EQU    00H                  ; Null
0053: E000             SOH        EQU    01H                  ; Start of Heading
0054: E000             BELL       EQU    07H                  ; Bell
0055: E000             TAB        EQU    09H                  ; Tab
0056: E000             LF         EQU    0AH                  ; Line Feed
0057: E000             CR         EQU    0DH                  ; Carriage Return
0058: E000             SPACE      EQU    20H                  ; Space
0059: E000             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0060: E000             HASH_TAG   EQU    23H                  ; Sharp sign #
0061: E000             DOLLAR     EQU    24H                  ; Dollar Sign
0062: E000             PERCENT    EQU    25H                  ; Percent Sign
0063: E000             L_PAREN    EQU    28H                  ; Left Paenthesis (
0064: E000             R_PAREN    EQU    29H                  ; Right Paenthesis )
0065: E000             ASTERISK   EQU    2AH                  ; Asterisk *
0066: E000             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0067: E000             COMMA      EQU    2CH                  ; Comma
0068: E000             DASH       EQU    2DH                  ; Dash Hyphen -
0069: E000             PERIOD     EQU    2EH                  ; Period
0070: E000             SLASH      EQU    2FH                  ; /
0071: E000             ASCII_ZERO EQU    30H                  ; zero
0072: E000             COLON      EQU    3AH                  ; Colon
0073: E000
0074: E000             SEMICOLON  EQU    3BH                  ; Semi Colon
0075: E000             LESS_THAN  EQU    3CH                  ; Less Than <
0076: E000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0077: E000             GREATER_THAN EQU    3EH                  ; Greater Than >
0078: E000             QMARK      EQU    3FH                  ; Question Mark
0079: E000             UNDER_SCORE EQU    5FH                  ; under score _
0080: E000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0081: E000             RUBOUT     EQU    7FH                  ; Delete Key
0082: E000
0083: E000
0084: E000             ASCII_A    EQU    'A'
0085: E000             ASCII_C    EQU    'C'
0086: E000             ASCII_K    EQU    'K'
0087: E000             ASCII_N    EQU    'N'
0088: E000             ASCII_Q    EQU    'Q'
0089: E000             ASCII_R    EQU    'R'
0090: E000             ASCII_W    EQU    'W'
0091: E000             ASCII_Y    EQU    'Y'
0092: E000             CARET      EQU    '^'
0093: E000             ASCII_LO_A EQU    'a'
0094: E000             ASCII_LO_K EQU    'k'
0095: E000             ASCII_LO_P EQU    'p'
0096: E000             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0097: E000
0098: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0099: E000                        Include ./osHeader.Z80
0100: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0102: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0103: E000         ; osHeader.Z80
0104: E000
0105: E000         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0106: E000         ; 2017-03-02 Refactored the CP/M Suite
0107: E000
0108: E000         ; Contains the Equates used by the CP/M system
0109: E000
0110: E000         ;------------------------Page Zero Constants ---------------------------------
0111: E000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0112: E000
0113: E000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0114: E000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0115: E000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0116: E000
0117: E000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0118: E000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0119: E000
0120: E000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0121: E000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0122: E000
0123: E000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0124: E000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0125: E000
0126: E000             ComTail    EQU    RAM + 080H           ; Complete command tail
0127: E000             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0128: E000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0129: E000         ;-----------------------------------------------------------------------
0130: E000
0131: E000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0132: E000         ;-----------------------------------------------------------------------
0133: E000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0134: E000         ;-----------------------------------------------------------------------
0135: E000             END_OF_FILE EQU    1AH                  ; end of file
0136: E000         ;-----------------------------------------------------------------------
0137: E000
0138: E000         ;--------------- CP/M Constants -----------------------------------------
0139: E000
0140: E000             CCPLength  EQU    0800H                ; Constant
0141: E000             BDOSLength EQU    0E00H                ; Constant 0E00H
0142: E000             BIOSLength EQU    0A00H                ; Constant 0900H
0143: E000
0144: E000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0145: E000             LengthInK  EQU    (LengthInBytes/1024) + 1
0146: E000
0147: E000             MemorySize EQU    64
0148: E000
0149: E000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0150: E000
0151: E000             BDOSBase   EQU    CCPEntry + CCPLength
0152: E000             BDOSEntry  EQU    BDOSBase
0153: E000
0154: E000             BIOSBase   EQU    BDOSBase + BDOSLength
0155: E000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0156: E000         ;-----------------------------------------------------------------------
0157: E000
0158: E000         ;------------------- BDOS System Call Equates --------------------------
0159: E000             fConsoleIn EQU    01H                  ; rcharf - Console Input
0160: E000             fConsoleOut EQU    02H                  ; pcharf - Console Output
0161: E000             fPrintString EQU    09H                  ; pbuff	- Print String
0162: E000             fReadString EQU    0AH                  ; rbuff	- Read Console String
0163: E000             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0164: E000             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0165: E000             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0166: E000             fSelectDisk EQU    0EH                  ; self	- Select Disk
0167: E000             fOpenFile  EQU    0FH                  ; openf	- Open File
0168: E000             fCloseFile EQU    10H                  ; closef - Close File
0169: E000             fSearchFirst EQU    11H                  ; searf	- Search For First
0170: E000             fSearchNext EQU    12H                  ; searnf - Search for Next
0171: E000             fDeleteFile EQU    13H                  ; delf - Delete File
0172: E000             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0173: E000             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0174: E000             fMakeFile  EQU    16H                  ; makef	- Make File
0175: E000             fRenameFile EQU    17H                  ; renf	- Rename File
0176: E000             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0177: E000             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0178: E000             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0179: E000             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0180: E000         ;-----------------------------------------------------------------------
0181: E000
0182: E000
0183: E000
0184: E000
0185: E000
0186: E000         ;*******************************************************************************
0187: E000         ; These are the values handed over by the BDOS when it calls the Writer operation
0188: E000         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0189: E000         ; unallocated allocation block (it only indicates this for the first 128 byte
0190: E000         ; sector write) or to an allocation block that has already been allocated to a
0191: E000         ; file. The BDOS also indicates if it is set to write to the file directory
0192: E000         ;*******************************************************************************
0193: E000             WriteAllocated EQU    00H
0194: E000             WriteDirectory EQU    01H
0195: E000             WriteCleanBuffer EQU    02H
0196: E000
0197: E000
0198: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0199: E000                        Include ./diskHeader.Z80
0200: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0202: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0203: E000         ; diskHeader.asm
0204: E000
0205: E000         ; 2017-03-02 Refactored the CP/M Suite
0206: E000
0207: E000         ; needs osHeader.asm declared before this is used !!!!!!!
0208: E000
0209: E000         ; Contains the Equates used by the CP/M system to handle disks
0210: E000
0211: E000
0212: E000         ;*******************************************************************************
0213: E000         ;
0214: E000         ;     Disk related values
0215: E000         ;
0216: E000         ;
0217: E000         ;*******************************************************************************
0218: E000             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0219: E000             DiskControlByte EQU    045H                 ; control byte for disk I/O
0220: E000             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0221: E000         ; for boot
0222: E000             DiskControlTable EQU    0040H
0223: E000
0224: E000             DiskReadCode EQU    01H                  ; Code for Read
0225: E000             DiskWriteCode EQU    02H                  ; Code for Write
0226: E000
0227: E000
0228: E000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0229: E000             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0230: E000             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0231: E000
0232: E000             DirEntrySize EQU    20H                  ; (32)
0233: E000             DirBuffSize EQU    cpmRecordSize
0234: E000
0235: E000             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0236: E000
0237: E000             RecordsPerExtent EQU    080H                 ; extent Record capacity
0238: E000
0239: E000
0240: E000         ;-------------------------------------------------------------------------------------
0241: E000             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0242: E000
0243: E000         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0244: E000             NumberOfHeads EQU    02H                  ; number of heads
0245: E000             TracksPerHead EQU    50H                  ; 80
0246: E000             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0247: E000             SectorsPerBlock EQU    04H                  ; 2048 bytes
0248: E000             DirectoryBlockCount EQU    02H                  ;
0249: E000         ;-----------------------------------------------------------------------
0250: E000
0251: E000             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0252: E000
0253: E000             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0254: E000
0255: E000             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0256: E000             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0257: E000             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0258: E000
0259: E000             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0260: E000             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0261: E000             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0262: E000             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0263: E000
0264: E000         ;-----------------------------------------------------------------------
0265: E000         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0266: E000         ;-----------------------------------------------------------------------
0267: E000         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0268: E000             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0269: E000             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0270: E000             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0271: E000             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0272: E000             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0273: E000             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0274: E000             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0275: E000             dpb3hdAL1  EQU    00H                  ;  for each file directory
0276: E000             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0277: E000             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0278: E000             dpb3hdNOH  EQU    NumberOfHeads
0279: E000
0280: E000         ;*******************************************************************************
0281: E000
0282: E000             SectorMask EQU    SectorsPerBlock - 1
0283: E000
0284: E000         ;***************************************************************************
0285: E000
0286: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0287: E000
0288: E000             BDOS       EQU    0005H                ; BDOS Vector in Page 00000
0289: E000
0290: E000             fcbSystemFileIndex EQU    0AH                  ; extent number field index
0291: E000             FILE_NAME_SIZE EQU    08H                  ; Max size of file Name
0292: E000             FILE_TYPE_SIZE EQU    03H                  ; Max size of file Type
0293: E000
0294: E000
0295: E000                        ORG    CCPEntry
0296: E000             CcpBoundary EQU    $
0297: E000         ;========================== CCP Entry ======================================;
0298: E000
0299: E000         ; 	JP		CcpStart						;start ccp with possible initial command
0300: E000         ;*****************************************************************
0301: E000         ;enter here from boot loader
0302: E000         ; On Entry	C(HiNibble) = User Number
0303: E000         ;			C(LoNibble) = Disk (0=A, 1=B...F=P)
0304: E000             CcpStart:
0305: E000 31 F0 E7               LD     SP,Stack             ; Set CCP's Stack
0306: E003 C5                     PUSH   BC                   ; Save Disk Number
0307: E004 59                     LD     E,C                  ; Get User Number
0308: E005 CB 3B                  SRL    E
0309: E007 CB 3B                  SRL    E                    ; Move user number
0310: E009 CB 3B                  SRL    E                    ;  to Lo Nibble
0311: E00B CB 3B                  SRL    E
0312: E00D CD 1C E3               CALL   SetUser              ; Set initial User
0313: E010         ; Initialize will completely reset the disk file system
0314: E010 CD F9 E2               CALL   Initialize           ; A = 0FFH if Submit file found
0315: E013 32 B2 E2               LD     (submitFlag),A       ; Save return value in Flag
0316: E016 C1                     POP    BC                   ; Recall disk number
0317: E017 79                     LD     A,C                  ; Put into Acc
0318: E018 E6 0F                  AND    LO_NIBBLE_MASK       ; Remove User Number
0319: E01A 32 04 00               LD     (Pg0CurentDisk),A    ; Puts disk number into Page 0
0320: E01D CD FE E2               CALL   SelectDisk           ; Set default Disk From Acc											; check for initial command
0321: E020 3A 2F E2               LD     A,(commandLength)
0322: E023 B7                     OR     A                    ; See if there is a Command
0323: E024 20 16                  JR     NZ,CcpParseCommand   ;  Skip if yes
0324: E026
0325: E026             ccpMainEntry:
0326: E026 31 F0 E7               LD     SP,Stack             ; (re)Establish CCP's Stack
0327: E029 CD AF E3               CALL   CrLf                 ; Send CRLF to the Console
0328: E02C CD 15 E3               CALL   GetSelectedDrive     ; Get current disk number
0329: E02F C6 41                  ADD    A,ASCII_A            ; Make ASCII form of Drive
0330: E031 CD B8 E3               CALL   PrintCharInA         ; Send Drive letter to console
0331: E034 3E 3E                  LD     A,GREATER_THAN       ; Load '>'
0332: E036 CD B8 E3               CALL   PrintCharInA         ; Send to Console
0333: E039 CD 65 E0               CALL   ReadCommand          ; Command Buffer filled, Pointer set
0334: E03C
0335: E03C             CcpParseCommand:
0336: E03C 11 80 00               LD     DE,DMABuffer         ; Default in page 0
0337: E03F CD 62 E3               CALL   SetDMA               ; Set the DMA address
0338: E042 CD 15 E3               CALL   GetSelectedDrive     ; Get current drive
0339: E045 32 8C E7               LD     (currentDisk),A      ; Save
0340: E048 CD 26 E1               CALL   ParseToken1          ; Get first token in command buffer
0341: E04B C4 08 E2               CALL   NZ,CommandError      ; The name must be unambiguous
0342: E04E 3A 88 E7               LD     A,(selectedDisk)     ; Get the Disk:
0343: E051 B7                     OR     A                    ; If not default,
0344: E052 C2 79 E6               JP     NZ,ccpUserFunction   ;   must be user CMD
0345: E055
0346: E055 CD DE E1               CALL   IntrinsicFunction    ; Get CMD index into ACC
0347: E058 21 EB E2               LD     HL,builtInCMDVector  ; Base of Vector
0348: E05B 5F                     LD     E,A
0349: E05C 16 00                  LD     D,0                  ; Index in DE
0350: E05E 19                     ADD    HL,DE
0351: E05F 19                     ADD    HL,DE                ; Vector is a word, need 2 ADDs
0352: E060 7E                     LD     A,(HL)               ; Pointing at Address
0353: E061 23                     INC    HL
0354: E062 66                     LD     H,(HL)
0355: E063 6F                     LD     L,A                  ; Get address to HL
0356: E064 E9                     JP     (HL)                 ;  Go to the Function
0357: E065
0358: E065
0359: E065         ;----------------------------------------------------------------
0360: E065         ;------------------------------ Read Command -------------------------------;
0361: E065
0362: E065         ;read the next command into the command buffer
0363: E065         ;check for submit file
0364: E065             ReadCommand:
0365: E065 3A B2 E2               LD     A,(submitFlag)       ; Get the Submit File Flag
0366: E068 B7                     OR     A                    ; Is it Set ?
0367: E069 CA C4 E0               JP     Z,NotSubmitFile      ;  skip if not
0368: E06C         ; scanning a submit file change drives to open and read the file
0369: E06C 3A 8C E7               LD     A,(currentDisk)      ; Get current disk
0370: E06F B7                     OR     A                    ; Is it default ?
0371: E070 3E 00                  LD     A,0                  ; Prepare to set Disk A
0372: E072 C4 FE E2               CALL   NZ,SelectDisk        ; Select it if needed
0373: E075         ; have to open again in case xsub present
0374: E075 11 B3 E2               LD     DE,submitFCB         ; Point at the Submits's FCB
0375: E078 CD 04 E3               CALL   OpenFile             ; Open it
0376: E07B CA C4 E0               JP     Z,NotSubmitFile      ; Skip if no submit file present
0377: E07E 3A C1 E2               LD     A,(submitRC)         ; Get Number of records in file
0378: E081 3D                     DEC    A                    ; read last record(s) first
0379: E082 32 D2 E2               LD     (submitCR),A         ; current record to read
0380: E085 11 B3 E2               LD     DE,submitFCB         ; Point at the Submits's FCB
0381: E088 CD 0E E3               CALL   DiskRead             ; Read from back to front
0382: E08B C2 C4 E0               JP     NZ,NotSubmitFile     ; Skip EOF ??
0383: E08E
0384: E08E         ; disk read is OK, transfer to commandBuffer
0385: E08E 21 80 00               LD     HL,DMABuffer         ; From
0386: E091 11 2F E2               LD     DE,commandLength     ; TO
0387: E094 01 80 00               LD     BC,cpmRecordSize     ; For this many bytes
0388: E097 ED B0                  LDIR                        ; Move to command buffer
0389: E099         ;	LD		B,cpmRecordSize					; number of bytes to Copy
0390: E099         ;	CALL	CopyHL2DEforB
0391: E099
0392: E099         ; line is transferred, close the file with a deleted record
0393: E099 21 C0 E2               LD     HL,submitFWF         ; Point at the WriteFileFlag
0394: E09C CB BE                  RES    7,(HL)               ; Clear the WriteFileFlag
0395: E09E         ;	LD		HL,submitFWF				; Bit 7 is FileWriteFlag
0396: E09E         ;	LD		(HL),0
0397: E09E         ;	INC		HL
0398: E09E 21 C1 E2               LD     HL,submitRC          ; Point at FCB record Count
0399: E0A1 35                     DEC    M                    ; Make it one less record
0400: E0A2 11 B3 E2               LD     DE,submitFCB         ; Point at the Submits's FCB
0401: E0A5 CD 09 E3               CALL   CloseFile            ; Close it
0402: E0A8 CA C4 E0               JP     Z,NotSubmitFile      ; Skip if not clean close
0403: E0AB         ; CloseFile went ok, return to original drive
0404: E0AB 3A 8C E7               LD     A,(currentDisk)      ; Get the current disk
0405: E0AE B7                     OR     A                    ; Is it the default disk ?
0406: E0AF C4 FE E2               CALL   NZ,SelectDisk        ;  no, then go select it
0407: E0B2         ; print to the 00
0408: E0B2 21 30 E2               LD     HL,commandBuffer     ; Point at the command buffer
0409: E0B5 CD C8 E3               CALL   PrintStringNull      ; Display it on the Console
0410: E0B8 CD D4 E3               CALL   CheckForConsoleChar  ; User input a character ?
0411: E0BB CA D5 E0               JP     Z,NoRead             ;  skip if not
0412: E0BE CD F3 E0               CALL   DeleteSubmitFile     ; Remove file and reset submit flag
0413: E0C1 C3 26 E0               JP     ccpMainEntry         ; Start a new CCP session
0414: E0C4         ;--------------------------------------------------------------------------------
0415: E0C4             NotSubmitFile:
0416: E0C4 CD F3 E0               CALL   DeleteSubmitFile     ; Delete any submit file
0417: E0C7 CD 0B E1               CALL   SaveUserAndDisk      ; Save User & Disk to page 0
0418: E0CA 11 2E E2               LD     DE,commandMaxLength  ; Point to Start of Buffer
0419: E0CD 0E 0A                  LD     C,fReadString        ; Load Function Number
0420: E0CF CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0421: E0D2 CD 1A E1               CALL   SetPage0CurDisk      ; No Cntl C, so restore Pg0CurentDisk
0422: E0D5
0423: E0D5             NoRead:
0424: E0D5         ; set the last character to zero for later scans
0425: E0D5 21 2F E2               LD     HL,commandLength     ; Point to length of command
0426: E0D8 46                     LD     B,(HL)               ; Put it into B
0427: E0D9             UpCaseLoop:
0428: E0D9 23                     INC    HL                   ; Point at next byte in buffer
0429: E0DA 7E                     LD     A,(HL)               ; Get the Character
0430: E0DB CD EA E0               CALL   UpCase               ; If between a-z, up-case it
0431: E0DE 77                     LD     (HL),A               ; Replace character
0432: E0DF 10 F8                  DJNZ   UpCaseLoop           ; go thru all of the CMD buffer
0433: E0E1         ;end of scan, h,l address end of command
0434: E0E1         ;ReadCommand2:
0435: E0E1 23                     INC    HL                   ; Point at last char + 1
0436: E0E2 70                     LD     (HL),B               ; Stuff Zero to terminate the CMD
0437: E0E3 21 30 E2               LD     HL,commandBuffer     ; go back to start of com
0438: E0E6 22 B0 E2               LD     (commandBufferPointer),HL ; Place in current CMD address
0439: E0E9 C9                     RET
0440: E0EA         ;------------------------------ Read Command -------------------------------;
0441: E0EA
0442: E0EA         ;--------------------------------- UpCase ----------------------------------;
0443: E0EA         ;convert character in register A (a to z) to upper case                     ;
0444: E0EA             UpCase:                         ;
0445: E0EA FE 61                  CP     061H                 ;
0446: E0EC D8                     RET    C                    ; Return if below lower case 'a'    ;
0447: E0ED FE 7B                  CP     07BH                 ;
0448: E0EF D0                     RET    NC                   ; Return if above lower case 'z'    ;
0449: E0F0 E6 5F                  AND    05FH                 ; Drop bit 5/ makes q->Q etc        ;
0450: E0F2 C9                     RET                         ;
0451: E0F3         ;--------------------------------- UpCase ----------------------------------;
0452: E0F3         ;---------------------------- Delete SubmitFile ----------------------------;
0453: E0F3         ;delete the submit file, and set submit flag to false                       ;
0454: E0F3             DeleteSubmitFile:                      ;
0455: E0F3 21 B2 E2               LD     HL,submitFlag        ; Point at Submit flag              ;
0456: E0F6 7E                     LD     A,(HL)               ; Get the Flag                      ;
0457: E0F7 B7                     OR     A                    ; Is it Set ?                       ;
0458: E0F8 C8                     RET    Z                    ;  return if not set                ;
0459: E0F9 36 00                  LD     (HL),0               ; Clear Flag                        ;
0460: E0FB AF                     XOR    A                    ; Drive 0 = A:                      ;
0461: E0FC CD FE E2               CALL   SelectDisk           ; Select drive                      ;
0462: E0FF 11 B3 E2               LD     DE,submitFCB         ; Load the submits FCB              ;
0463: E102 CD 33 E3               CALL   DeleteFile           ; Go delete it                      ;
0464: E105 3A 8C E7               LD     A,(currentDisk)      ; Determine the current disk        ;
0465: E108 C3 FE E2               JP     SelectDisk           ; Reselect back to original drive   ;
0466: E10B         ;---------------------------- Delete SubmitFile ----------------------------;
0467: E10B         ;-------------------------------- Save User --------------------------------;
0468: E10B         ;save user#/disk# before possible ^c or transient                           ;
0469: E10B             SaveUserAndDisk:                      ;
0470: E10B CD 1A E3               CALL   GetUser              ; Get the user number into Acc      ;
0471: E10E 87                     ADD    A,A                  ;
0472: E10F 87                     ADD    A,A                  ;
0473: E110 87                     ADD    A,A                  ;
0474: E111 87                     ADD    A,A                  ; Move user to Hi Nibble            ;
0475: E112 21 8C E7               LD     HL,currentDisk       ; Current disk (Lo Nibble)          ;
0476: E115 B6                     OR     M                    ; Acc -> User & Disk                ;
0477: E116 32 04 00               LD     (Pg0CurentDisk),A    ; Stored in Page0 for later         ;
0478: E119 C9                     RET                         ;
0479: E11A         ;-------------------------------- Save User --------------------------------;
0480: E11A         ;------------------------- Set Page 0 Current Disk -------------------------;
0481: E11A         ;set Pg0CurentDisk to current disk                                          ;
0482: E11A             SetPage0CurDisk:                      ;
0483: E11A 3A 8C E7               LD     A,(currentDisk)      ; Get CCP's current disk            ;
0484: E11D 32 04 00               LD     (Pg0CurentDisk),A    ; Put into Page 0	                ;
0485: E120 C9                     RET                         ;
0486: E121         ;------------------------- Set Page 0 Current Disk -------------------------;
0487: E121
0488: E121         ;--------------------------------- Parse Token -----------------------------;
0489: E121         ; Parse command buffer.                                                     ;
0490: E121         ; Used to isolate the command                                               ;
0491: E121         ;
0492: E121             ParseToken2:                      ;
0493: E121 21 77 E7               LD     HL,Token2            ; Point at Token2 start             ;
0494: E124 18 03                  JR     ParseToken           ;
0495: E126             ParseToken1:                      ;
0496: E126 21 67 E7               LD     HL,Token1            ; Point at Token1 start             ;
0497: E129             ParseToken:                      ;
0498: E129 E5                     PUSH   HL                   ; Start of Token's Pointer          ;
0499: E12A E5                     PUSH   HL                   ; Start of Token's Pointer          ;
0500: E12B AF                     XOR    A                    ; Set A to 0                        ;
0501: E12C 32 88 E7               LD     (selectedDisk),A     ; Assume default disk               ;
0502: E12F 2A B0 E2               LD     HL,(commandBufferPointer) ; Buffer's Pointer                  ;
0503: E132 EB                     EX     DE,HL                ; DE-> Buffer                       ;
0504: E133 CD B5 E1               CALL   NextNonBlankChar     ; Buffer's next non-blank character ;
0505: E136 EB                     EX     DE,HL                ; DE-> Token , HL -> Buffer         ;
0506: E137 22 8A E7               LD     (tokenStart),HL      ; Save token's address              ;
0507: E13A EB                     EX     DE,HL                ; DE -> Buffer                      ;
0508: E13B E1                     POP    HL                   ; DE -> Buffer,                     ;
0509: E13C         ;  HL -> Start of Token's Pointer   ;
0510: E13C         ; Disk ?                                                                    ;
0511: E13C 1A                     LD     A,(DE)               ; Get 1st character from buffer     ;
0512: E13D B7                     OR     A                    ; Is it the default Disk ?          ;
0513: E13E CA 4C E1               JP     Z,UseCurrentDisk     ; Use current disk if empty         ;
0514: E141 DE 40                  SBC    A,040H               ; Convert to number                 ;
0515: E143 47                     LD     B,A                  ; Hold disk number in B             ;
0516: E144 13                     INC    DE                   ;
0517: E145 1A                     LD     A,(DE)               ; Look at next character            ;
0518: E146 FE 3A                  CP     COLON                ; Is it a ':' ?                     ;
0519: E148 CA 53 E1               JP     Z,UseTokensDisk      ;  if yes, set disk number          ;
0520: E14B         ; No Disk                                                                   ;
0521: E14B 1B                     DEC    DE                   ; Back to start of buffer           ;
0522: E14C         ;
0523: E14C             UseCurrentDisk:                      ;
0524: E14C 3A 8C E7               LD     A,(currentDisk)      ; Get current Disk                  ;
0525: E14F 77                     LD     (HL),A               ; Put into the Token                ;
0526: E150 C3 59 E1               JP     SetFileName          ;
0527: E153         ;
0528: E153             UseTokensDisk:                      ;
0529: E153 78                     LD     A,B                  ; Get disk from this parse          ;
0530: E154 32 88 E7               LD     (selectedDisk),A     ; Mark as disk selected             ;
0531: E157 70                     LD     (HL),B               ; Put it into the token             ;
0532: E158 13                     INC    DE                   ; Move past the ':'                 ;
0533: E159         ;
0534: E159             SetFileName:                      ;
0535: E159 06 08                  LD     B,FILE_NAME_SIZE     ; File name length (max)            ;
0536: E15B CD 81 E1               CALL   FormatElement        ; Format file name                  ;
0537: E15E         ;
0538: E15E             SetType:                        ;
0539: E15E 06 03                  LD     B,FILE_TYPE_SIZE     ; File type length (max)            ;
0540: E160 CD A2 E1               CALL   IsItDot              ; is it a '.' ?	                    ;
0541: E163 CC 81 E1               CALL   Z,FormatElement      ;  Yes,Format it                    ;
0542: E166         ;
0543: E166         ; Zero Rest of token                                                        ;
0544: E166 06 03                  LD     B,3                  ;
0545: E168 AF                     XOR    A                    ;
0546: E169 CD B0 E1               CALL   FillWithAcc          ;
0547: E16C EB                     EX     DE,HL                ;
0548: E16D 22 B0 E2               LD     (commandBufferPointer),HL ; Set new starting point	        ;
0549: E170         ; Recover the start address of the fcb and count ?'s                        ;
0550: E170 E1                     POP    HL                   ; Restore start of Token            ;
0551: E171 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Loop size                   ;
0552: E173 0E 00                  LD     C,00                 ; Counter                           ;
0553: E175 3E 3F                  LD     A,QMARK              ; We want to count '?'s             ;
0554: E177             QuestionMarkCount:                      ;
0555: E177 23                     INC    HL                   ; Adjust token pointer				;
0556: E178 BE                     CP     (HL)                 ; Is it a '?'                       ;
0557: E179 20 01                  JR     NZ,QuestionMarkCount1 ;  no, then skip                    ;
0558: E17B 0C                     INC    C                    ;  else increment the count         ;
0559: E17C             QuestionMarkCount1:                      ;
0560: E17C 10 F9                  DJNZ   QuestionMarkCount    ; Manage the Loop	                ;
0561: E17E 79                     LD     A,C                  ;
0562: E17F B7                     OR     A                    ;
0563: E180 C9                     RET                         ;
0564: E181         ;-------------------------------- Parse Token ------------------------------;
0565: E181         ;------------------------------- Format Element ----------------------------;
0566: E181         ; Put element in a Left Justified, Space Padded field.                      ;
0567: E181         ; If it encounters an asterisk, it will pad the rest of the field with '?'s ;
0568: E181         ; Enter With:	B  = Element size                                           ;
0569: E181         ;				DE = Element source                                         ;
0570: E181         ;				HL = Element destination                                    ;
0571: E181             FormatElement:                      ;
0572: E181 CD BF E1               CALL   IsItADelimiter       ; Is character a delimiter ?        ;
0573: E184 CA 9E E1               JP     Z,PadTheElement      ;  yes, pad rest of Element         ;
0574: E187         ;
0575: E187 23                     INC    HL                   ;  else move the Token's pointer    ;
0576: E188 FE 2A                  CP     ASTERISK             ; Is it an '*'					    ;
0577: E18A C2 92 E1               JP     NZ,FormatElement1    ;  no, then just put in Token   ;
0578: E18D 36 3F                  LD     (HL),QMARK           ;  else Put a '?' in token          ;
0579: E18F C3 94 E1               JP     FormatElement2       ;  for rest of Element              ;
0580: E192         ;
0581: E192             FormatElement1:                      ;
0582: E192 77                     LD     (HL),A               ; Put character in token            ;
0583: E193 13                     INC    DE                   ; Increment the buffer pointer      ;
0584: E194             FormatElement2:                      ;
0585: E194 10 EB                  DJNZ   FormatElement        ; Loop if more                      ;
0586: E196         ;
0587: E196             TruncateElement:                      ;
0588: E196 CD BF E1               CALL   IsItADelimiter       ; We expect a delimiter             ;
0589: E199 C8                     RET    Z                    ; If we get one, we are done        ;
0590: E19A 13                     INC    DE                   ;  skip forward in buffer           ;
0591: E19B C3 96 E1               JP     TruncateElement      ; Keep looking for delimiter        ;
0592: E19E         ;
0593: E19E             PadTheElement:                      ;
0594: E19E CD AE E1               CALL   FillWithSpace        ; Pad the rest of Element           ;
0595: E1A1 C9                     RET                         ;
0596: E1A2         ;------------------------------- Format Element ----------------------------;
0597: E1A2         ;-------------------------------- Is It a Dot ------------------------------;
0598: E1A2         ; Check to see if char is buffer is a period. If it is it returns with      ;
0599: E1A2         ; the Z-Flag set., and the DE pointer advanced beyond the '.'.  If it is    ;
0600: E1A2         ; not a period. It will fill the buffer with spaces and return with the     ;
0601: E1A2         ; Z-Flag reset.                                                             ;
0602: E1A2         ;                                                                           ;
0603: E1A2         ; Enter With:	DE = Pointer for buffer                                     ;
0604: E1A2         ;				 B = buffer size	                                        ;
0605: E1A2         ; Return With:	DE = Past the period                                        ;
0606: E1A2         ;			   	Z-Flag =  set if Period                                     ;
0607: E1A2         ;  				Z-Flag = reset if not Period                                ;
0608: E1A2             IsItDot:                        ;
0609: E1A2 1A                     LD     A,(DE)               ;
0610: E1A3 13                     INC    DE                   ; Assume it is a '.'                ;
0611: E1A4 FE 2E                  CP     PERIOD               ; Is it '.' ?                       ;
0612: E1A6 C8                     RET    Z                    ;  if yes exit with Z-Flag set      ;
0613: E1A7         ;
0614: E1A7 1B                     DEC    DE                   ; Adjust, wrong assumption          ;
0615: E1A8 CD AE E1               CALL   FillWithSpace        ;  else make all spaces             ;
0616: E1AB AF                     XOR    A                    ;
0617: E1AC 3C                     INC    A                    ; Reset the Z-Flag                  ;
0618: E1AD C9                     RET                         ; Exit with Z-Flag reset            ;
0619: E1AE         ;-------------------------------- Is It a Dot ------------------------------;
0620: E1AE         ;-------------------------- Fill With Space/Acc ----------------------------;
0621: E1AE         ; fills buffer with SPACE or contents of Acc.                               ;
0622: E1AE         ; Enters with:	HL = less than start of fill area                           ;
0623: E1AE         ;				B  = fill Count                                             ;
0624: E1AE         ;				A  = fill character (FillWithAcc)                           ;
0625: E1AE             FillWithSpace:                      ;
0626: E1AE 3E 20                  LD     A,SPACE              ;
0627: E1B0             FillWithAcc:                      ;
0628: E1B0 23                     INC    HL                   ;
0629: E1B1 77                     LD     (HL),A               ;
0630: E1B2 10 FC                  DJNZ   FillWithAcc          ;
0631: E1B4 C9                     RET                         ;
0632: E1B5         ;-------------------------- Fill With Space/Acc ----------------------------;
0633: E1B5         ;------------------------ Next Non Blank Character -------------------------;
0634: E1B5         ;find the next non blank character in line pointed to by DE                 ;
0635: E1B5             NextNonBlankChar:                      ;
0636: E1B5 1A                     LD     A,(DE)               ; Get the character                 ;
0637: E1B6 B7                     OR     A                    ; Is it End of buffer ?             ;
0638: E1B7 C8                     RET    Z                    ;  if yes, return                   ;
0639: E1B8 FE 20                  CP     SPACE                ; is it a blank ?                   ;
0640: E1BA C0                     RET    NZ                   ;  if not, return                   ;
0641: E1BB 13                     INC    DE                   ;  else increment pointer           ;
0642: E1BC C3 B5 E1               JP     NextNonBlankChar     ; Loop for next character           ;
0643: E1BF         ;------------------------ Next Non Blank Character -------------------------;
0644: E1BF         ;---------------------------- Is It A Delimiter ----------------------------;
0645: E1BF         ; Returns with Z-flag set if (DE) pointing at a delimiter                   ;
0646: E1BF         ; Does an error exit if not valid ASCII character                           ;
0647: E1BF             IsItADelimiter:                      ;
0648: E1BF 1A                     LD     A,(DE)               ; Get the character                 ;
0649: E1C0 B7                     OR     A                    ;
0650: E1C1 C8                     RET    Z                    ; End of Buffer is a delimiter      ;
0651: E1C2 FE 20                  CP     SPACE                ;
0652: E1C4 DA 08 E2               JP     C,CommandError       ; Error exit if not ASCII           ;
0653: E1C7 C8                     RET    Z                    ; SPACE is a delimiter              ;
0654: E1C8 FE 3D                  CP     EQUAL_SIGN           ;
0655: E1CA C8                     RET    Z                    ; '=' is a delimiter                ;
0656: E1CB FE 5F                  CP     UNDER_SCORE          ;
0657: E1CD C8                     RET    Z                    ; '_' is a delimiter                ;
0658: E1CE FE 2E                  CP     PERIOD               ;
0659: E1D0 C8                     RET    Z                    ; '.' is a delimiter                ;
0660: E1D1 FE 3A                  CP     COLON                ;
0661: E1D3 C8                     RET    Z                    ; ':' is a delimiter                ;
0662: E1D4 FE 3B                  CP     SEMICOLON            ;
0663: E1D6 C8                     RET    Z                    ; ';' is a delimiter                ;
0664: E1D7 FE 3C                  CP     LESS_THAN            ;
0665: E1D9 C8                     RET    Z                    ; '<' is a delimiter                ;
0666: E1DA FE 3E                  CP     GREATER_THAN         ;
0667: E1DC C8                     RET    Z                    ; '>' is a delimiter                ;
0668: E1DD C9                     RET                         ; Not a delimiter                   ;
0669: E1DE         ;---------------------------- Is It A Delimiter ----------------------------;
0670: E1DE
0671: E1DE         ;---------------------------- Intrinsic Function ---------------------------;
0672: E1DE         ;look for intrinsic functions (Token1 has been filled)                 		;
0673: E1DE             IntrinsicFunction:                      ;
0674: E1DE 21 D3 E2               LD     HL,builtInCMDNames   ; Point at List of CMDs             ;
0675: E1E1 0E 00                  LD     C,0                  ; Initialize counter                ;
0676: E1E3             IntrinsicFunction1:                      ;
0677: E1E3 79                     LD     A,C                  ; Get Counter                       ;
0678: E1E4 FE 06                  CP     builtInCMDCount      ; Past number of commands ?         ;
0679: E1E6 D0                     RET    NC                   ;  exit if yes                      ;
0680: E1E7 11 68 E7               LD     DE,Token1+1          ; Beginning of name                 	;
0681: E1EA 06 04                  LD     B,builtInCMDNameSize ; Length of match                   ;
0682: E1EC             IntrinsicFunction2:                      ;
0683: E1EC 1A                     LD     A,(DE)               ;
0684: E1ED BE                     CP     M                    ; Is there a match ?                ;
0685: E1EE C2 FF E1               JP     NZ,IntrinsicFunction3 ;  skip if no match                 ;
0686: E1F1 13                     INC    DE                   ;
0687: E1F2 23                     INC    HL                   ; Point at next characters          ;
0688: E1F3 05                     DEC    B                    ; Decrement the counter             ;
0689: E1F4 C2 EC E1               JP     NZ,IntrinsicFunction2 ; Loop while matching               ;
0690: E1F7         ; complete match on name, check for blank in fcb                            ;
0691: E1F7 1A                     LD     A,(DE)               ;
0692: E1F8 FE 20                  CP     SPACE                ; Blank in CMD ?                    ;
0693: E1FA C2 04 E2               JP     NZ,IntrinsicFunction4 ;  No ,then no match                ;
0694: E1FD 79                     LD     A,C                  ;  Else they match,                 ;
0695: E1FE C9                     RET                         ; Return with index in A            ;
0696: E1FF         ;
0697: E1FF             IntrinsicFunction3:                      ;
0698: E1FF 23                     INC    HL                   ; Move to next in list              ;
0699: E200 05                     DEC    B                    ;
0700: E201 C2 FF E1               JP     NZ,IntrinsicFunction3 ; Loop thru this one                ;
0701: E204         ;
0702: E204             IntrinsicFunction4:                      ;
0703: E204 0C                     INC    C                    ; Update the index                  ;
0704: E205 C3 E3 E1               JP     IntrinsicFunction1   ;  loop for another round           ;
0705: E208         ;---------------------------- Intrinsic Function ---------------------------;
0706: E208
0707: E208         ; cmd
0708: E208         ;------------------------------ Command Error ------------------------------;
0709: E208         ;error in command string starting at position;'tokenStart' and ending    	;
0710: E208         ; with first delimiter                                                      ;
0711: E208         ;
0712: E208             CommandError:                      ;
0713: E208 CD AF E3               CALL   CrLf                 ; Next Line                         ;
0714: E20B 2A 8A E7               LD     HL,(tokenStart)      ; Start of error token             		;
0715: E20E             CommandErrorLoop:                      ;
0716: E20E 7E                     LD     A,(HL)               ; Get character                     ;
0717: E20F FE 20                  CP     SPACE                ; Past offending token ?            ;
0718: E211 CA 20 E2               JP     Z,CommandErrorExit   ;  done if yes                      ;
0719: E214 B7                     OR     A                    ; At end of command ?               ;
0720: E215 CA 20 E2               JP     Z,CommandErrorExit   ;  done if yes                      ;
0721: E218 E5                     PUSH   HL                   ; Save pointer                      ;
0722: E219 CD B8 E3               CALL   PrintCharInA         ; Display on console                ;
0723: E21C E1                     POP    HL                   ; Restore pointer                   ;
0724: E21D 23                     INC    HL                   ; Update it                         ;
0725: E21E 18 EE                  JR     CommandErrorLoop     ; Keep going                        ;
0726: E220         ;
0727: E220             CommandErrorExit:                      ;
0728: E220 3E 3F                  LD     A,QMARK              ;
0729: E222 CD B8 E3               CALL   PrintCharInA         ; Send '?' to console               ;
0730: E225 CD AF E3               CALL   CrLf                 ; Next Line                         ;
0731: E228 CD F3 E0               CALL   DeleteSubmitFile     ; Remove any submit file            ;
0732: E22B C3 26 E0               JP     ccpMainEntry         ; Go back for another command       ;
0733: E22E         ;------------------------------ Command Error ------------------------------;
0734: E22E
0735: E22E         ;------------------------------ Command Buffer -----------------------------;
0736: E22E             maximumBufferSize EQU    07FH                 ; Max Length of Buffer          ;
0737: E22E 7F          commandMaxLength: DB     maximumBufferSize    ;
0738: E22F 00          commandLength: DB     00H                  ; Actual size of input          ;
0739: E230             commandBuffer: DS     maximumBufferSize + 1 ; The Command Buffer           ;
0740: E2B0         ;
0741: E2B0 30 E2       commandBufferPointer: DW     commandBuffer        ; Address of next to char       ;
0742: E2B2         ;------------------------------ Command Buffer -----------------------------;
0743: E2B2         ;------------------------- Submit File Control Block -----------------------;
0744: E2B2         ;	                                                                        ;
0745: E2B2 00          submitFlag: DB     00H                  ; 00 if no submit file,             ;
0746: E2B3         ;  0FFH if submitting               ;
0747: E2B3 24 24 24 20 20 20 20 20     submitFCB: DB     '$$$     '           ; File name is $$$                  ;
0748: E2BB 53 55 42     submitType: DB     'SUB'                ; Type is 'SUB'                     ;
0749: E2BE 00          submitExtent: DB     00H                  ; Extent                            ;
0750: E2BF 00          submitS1:  DB     00H                  ; S1                                ;
0751: E2C0             submitFWF:                      ; Bit7 = FileWriteFlag
0752: E2C0 00          submitS2:  DB     00H                  ; S2 (bit7 = FileWriteFlag)         ;
0753: E2C1 00          submitRC:  DB     00H                  ; RC                                ;
0754: E2C2             submitMap: DS     010H                 ; Allocation Map                    ;
0755: E2D2 00          submitCR:  DB     00H                  ; Current Record                    ;
0756: E2D3         ;------------------------- Submit File Control Block -----------------------;
0757: E2D3         ;--------------------------- Built In Command Data -------------------------;
0758: E2D3         ;intrinsic function names four characters each                              ;
0759: E2D3             builtInCMDNameSize EQU    04                   ; Size of intrinsic function names  ;
0760: E2D3         ;
0761: E2D3             builtInCMDNames:                      ;
0762: E2D3 44 49 52 20                DB     'DIR '               ;
0763: E2D7 45 52 41 20                DB     'ERA '               ;
0764: E2DB 54 59 50 45                DB     'TYPE'               ;
0765: E2DF 53 41 56 45                DB     'SAVE'               ;
0766: E2E3 52 45 4E 20                DB     'REN '               ;
0767: E2E7 55 53 45 52                DB     'USER'               ;
0768: E2EB             builtInCMDCount EQU    (($-builtInCMDNames)/builtInCMDNameSize) + 1 ;
0769: E2EB         ;
0770: E2EB             builtInCMDVector:                      ;
0771: E2EB 4B E4                  DW     ccpDirectory         ; Directory List                    ;
0772: E2ED F3 E4                  DW     ccpErase             ; File erase                        ;
0773: E2EF 31 E5                  DW     ccpType              ; Type file on Console              ;
0774: E2F1 81 E5                  DW     ccpSave              ; Save memory image                 ;
0775: E2F3 E4 E5                  DW     ccpRename            ; File rename                       ;
0776: E2F5 62 E6                  DW     ccpUser              ; User number                       ;
0777: E2F7 79 E6                  DW     ccpUserFunction      ; User-defined function             ;
0778: E2F9         ;
0779: E2F9         ;--------------------------- Built In Command Data -------------------------;
0780: E2F9         ;----------------------------------------------------------------
0781: E2F9         ;----------------------------------------------------------------
0782: E2F9         ;================================ BDOS API =================================;
0783: E2F9         ;------------------------------- Initialize --------------------------------;
0784: E2F9             Initialize:                      ;
0785: E2F9 0E 0D                  LD     C,fResetSystem       ; Load Function Number  - 0D        ;
0786: E2FB C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
0787: E2FE         ;------------------------------- Initialize --------------------------------;
0788: E2FE         ;------------------------------- Select Disk -------------------------------;
0789: E2FE             SelectDisk:                      ;
0790: E2FE 5F                     LD     E,A                  ; Load Target disk                  ;
0791: E2FF 0E 0E                  LD     C,fSelectDisk        ; Load Function Number - 0EH        ;
0792: E301 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
0793: E304         ;------------------------------- Select Disk -------------------------------;
0794: E304         ;-------------------------------- Open File --------------------------------;
0795: E304         ;Open the file				                                                ;
0796: E304         ; On Entry DE = FCB to read 						                        ;
0797: E304         ; Exits with Z-Flag Set if file not found									;
0798: E304         ;					Reset if file found										;
0799: E304             OpenFile:                       ;
0800: E304 0E 0F                  LD     C,fOpenFile          ; Load Function Number - 0FH        ;
0801: E306 C3 21 E3               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
0802: E309         ;-------------------------------- Open File --------------------------------;
0803: E309         ;------------------------------- Close File --------------------------------;
0804: E309         ;Close the file				                                                ;
0805: E309         ; On Entry DE = FCB to Close						                        ;
0806: E309         ; Exits with Z-Flag Set if file not found									;
0807: E309         ;					Reset if file found										;
0808: E309             CloseFile:                      ;
0809: E309 0E 10                  LD     C,fCloseFile         ; Load Function Number - 10H        ;
0810: E30B C3 21 E3               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
0811: E30E         ;------------------------------- Close File --------------------------------;
0812: E30E         ;-------------------------------- Read File --------------------------------;
0813: E30E         ;Read the next record from the file.										;
0814: E30E         ; On Entry DE = FCB to read 						                        ;
0815: E30E             DiskRead:                       ;
0816: E30E 0E 14                  LD     C,fReadSeq           ; Load Function Number - 14H        ;
0817: E310 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
0818: E313 B7                     OR     A                    ; set return code flags             ;
0819: E314 C9                     RET                         ;
0820: E315         ;-------------------------------- Read File --------------------------------;
0821: E315         ;----------------------------- Get Current Disk ----------------------------;
0822: E315         ;Exits with current drive number to A (0=A,1=B....F=P)                      ;
0823: E315             GetSelectedDrive:                      ;
0824: E315 0E 19                  LD     C,fGetCurrentDisk    ; Load Function Number - 19H    ;
0825: E317 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
0826: E31A         ;----------------------------- Get Current Disk ----------------------------;
0827: E31A         ;------------------------------ Get/Set User -------------------------------;
0828: E31A         ;return current user code in A                                              ;
0829: E31A             GetUser:                        ;
0830: E31A 1E FF                  LD     E,0FFH               ; Set Entry Parameter for Get       ;
0831: E31C         ; If E <> -1 then Set user number found in E                                ;
0832: E31C             SetUser:                        ;
0833: E31C 0E 20                  LD     C,fGetSetUserNumber  ; Load Function Number - 20H        ;
0834: E31E C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
0835: E321         ;------------------------------ Get/Set User -------------------------------;
0836: E321
0837: E321         ;  AP i
0838: E321
0839: E321         ;------------------------------ BDOS and Inc A -----------------------------;
0840: E321         ; Call B DOS                                                                ;
0841: E321         ;  Store returned directory index                                           ;
0842: E321         ;  Increment result.                                                        ;
0843: E321         ; Exits with 	A =  0 if File Not Found                                    ;
0844: E321         ;				  <> 0 if file found                                        ;
0845: E321             BDOSandIncA:                      ;
0846: E321 CD 05 00               CALL   BDOS                 ; Make call to BDOS                 ;
0847: E324 32 8D E7               LD     (directoryIndex),A   ; Save return value                 ;
0848: E327 3C                     INC    A                    ; Increment & (Re)Set Z-Flag        ;
0849: E328 C9                     RET                         ;
0850: E329         ;------------------------------ BDOS and Inc A -----------------------------;
0851: E329
0852: E329         ;--------
0853: E329         ;open file for Command FCB
0854: E329             OpenFile4CmdFCB:
0855: E329 AF                     XOR    A
0856: E32A 32 87 E7               LD     (currentRecord),A    ; clear next record to read
0857: E32D 11 67 E7               LD     DE,Token1
0858: E330 C3 04 E3               JP     OpenFile
0859: E333         ;-----------------------------
0860: E333         ;delete the file given by (DE)
0861: E333             DeleteFile:
0862: E333 0E 13                  LD     C,fDeleteFile
0863: E335 C3 05 00               JP     BDOS
0864: E338         ;-----------------------------
0865: E338         ;make the file given by (DE)
0866: E338             MakeFile:
0867: E338 0E 16                  LD     C,fMakeFile
0868: E33A C3 21 E3               JP     BDOSandIncA
0869: E33D         ;-----------
0870: E33D         ;read next record from Command FCB
0871: E33D             DiskReadCmdFCB:
0872: E33D 11 67 E7               LD     DE,Token1
0873: E340 C3 0E E3               JP     DiskRead
0874: E343         ;-----------------------------
0875: E343         ;write the next record to the file given by (DE)
0876: E343             DiskWrite:
0877: E343 0E 15                  LD     C,fWriteSeq
0878: E345 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
0879: E348 B7                     OR     A                    ; set return code flags
0880: E349 C9                     RET
0881: E34A         ;-----------------------------
0882: E34A         ;search for the file given by d,e
0883: E34A             SearchForFirst:
0884: E34A 0E 11                  LD     C,fSearchFirst
0885: E34C C3 21 E3               JP     BDOSandIncA
0886: E34F         ;-----
0887: E34F         ;search for Token1 file
0888: E34F             Searc4CmdFcbFile:
0889: E34F 11 67 E7               LD     DE,Token1
0890: E352 C3 4A E3               JP     SearchForFirst
0891: E355         ;-----------------------------
0892: E355         ;search for the next occurrence of the file given by d,e
0893: E355             SearchForNext:
0894: E355 0E 12                  LD     C,fSearchNext
0895: E357 C3 21 E3               JP     BDOSandIncA
0896: E35A         ;-----------------------------
0897: E35A         ; rename a file give bu (DE)
0898: E35A             RenameFile:
0899: E35A 0E 17                  LD     C,fRenameFile
0900: E35C C3 05 00               JP     BDOS
0901: E35F         ;-----------------------------
0902: E35F         ;set default buffer dma address
0903: E35F             SetDefaultDMA:
0904: E35F 11 80 00               LD     DE,DMABuffer
0905: E362         ;---------
0906: E362         ;set dma address to d,e
0907: E362             SetDMA:
0908: E362 0E 1A                  LD     C,fSetDMA
0909: E364 C3 05 00               JP     BDOS
0910: E367         ;-----------------------------
0911: E367         ;/ ; call B DOS and set Flags
0912: E367         ;/ BDOSsetFlags:
0913: E367         ;/ 	CALL	BDOS
0914: E367         ;/ 	OR		A								; set return code flags
0915: E367         ;/ 	RET
0916: E367         ;----------------------------------------------------------------
0917: E367         ;----------------------------------------------------------------
0918: E367         ;-----------------------------
0919: E367         ; get number from the command line
0920: E367             GetNumberFromCmdLine:
0921: E367 CD 26 E1               CALL   ParseToken1          ; should be number
0922: E36A 3A 88 E7               LD     A,(selectedDisk)
0923: E36D B7                     OR     A
0924: E36E C2 08 E2               JP     NZ,CommandError      ; cannot be prefixed
0925: E371         ; convert the byte value in Token1 to binary
0926: E371 21 68 E7               LD     HL,Token1+1
0927: E374 01 0B 00               LD     BC,11                ;(b=0, c=11)
0928: E377         ; value accumulated in b, c counts name length to zero
0929: E377             GetNumericValue:
0930: E377 7E                     LD     A,(HL)
0931: E378 FE 20                  CP     SPACE
0932: E37A CA A2 E3               JP     Z,GetNumericValue1
0933: E37D         ; more to scan, convert char to binary and add
0934: E37D 23                     INC    HL
0935: E37E D6 30                  SUB    ASCII_ZERO
0936: E380 FE 0A                  CP     10
0937: E382 D2 08 E2               JP     NC,CommandError      ; valid?
0938: E385 57                     LD     D,A                  ; save value
0939: E386 78                     LD     A,B                  ; mult by 10
0940: E387 E6 E0                  AND    11100000B
0941: E389 C2 08 E2               JP     NZ,CommandError
0942: E38C 78                     LD     A,B                  ; recover value
0943: E38D 07                     RLCA
0944: E38E 07                     RLCA
0945: E38F 07                     RLCA                        ; *8
0946: E390 80                     ADD    A,B
0947: E391 DA 08 E2               JP     C,CommandError
0948: E394 80                     ADD    A,B
0949: E395 DA 08 E2               JP     C,CommandError       ; *8+*2 = *10
0950: E398 82                     ADD    A,D
0951: E399 DA 08 E2               JP     C,CommandError       ; +digit
0952: E39C 47                     LD     B,A
0953: E39D 0D                     DEC    C
0954: E39E C2 77 E3               JP     NZ,GetNumericValue   ; for another digit
0955: E3A1 C9                     RET
0956: E3A2             GetNumericValue1:                      ; conv1 end of digits, check for all blanks
0957: E3A2 7E                     LD     A,(HL)
0958: E3A3 FE 20                  CP     SPACE
0959: E3A5 C2 08 E2               JP     NZ,CommandError      ;blanks?
0960: E3A8 23                     INC    HL
0961: E3A9 0D                     DEC    C
0962: E3AA C2 A2 E3               JP     NZ,GetNumericValue1
0963: E3AD 78                     LD     A,B                  ;recover value
0964: E3AE C9                     RET
0965: E3AF         ;-----------------------------
0966: E3AF         ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0967: E3AF
0968: E3AF
0969: E3AF         ;-----------------------------
0970: E3AF         ;*****************************************************************
0971: E3AF
0972: E3AF         ;=============================== Utilities =================================;
0973: E3AF         ;-------------------------------- CR / LF ----------------------------------;
0974: E3AF         ;Sent Carriage Return Line Feed to Console                                  ;
0975: E3AF             CrLf:                           ;
0976: E3AF 1E 0D                  LD     E,CR                 ; Carriage Return                   ;
0977: E3B1 CD BB E3               CALL   PrintCharInE         ;
0978: E3B4 1E 0A                  LD     E,LF                 ; Line Feed                         ;
0979: E3B6 18 03                  JR     PrintCharInE         ;
0980: E3B8         ;-------------------------------- CR / LF ----------------------------------;
0981: E3B8         ;------------------------------- PrintCharInA ------------------------------;
0982: E3B8         ; Print character                                                           ;
0983: E3B8         ; On Entry A = Character to Send to Console                                 ;
0984: E3B8             PrintCharInA:                      ;
0985: E3B8 5F                     LD     E,A                  ; move char to E                    ;
0986: E3B9 18 00                  JR     PrintCharInE         ;
0987: E3BB         ;------------------------------- PrintCharInA -------------------------------;
0988: E3BB         ;------------------------------- PrintCharInE ------------------------------;
0989: E3BB         ; Print character                                                           ;
0990: E3BB         ; On Entry E = Character to Send to Console                                 ;
0991: E3BB         ; Preserves BC                                ;                             ;
0992: E3BB             PrintCharInE:                      ;
0993: E3BB C5                     PUSH   BC                   ; Preserve BC                       ;
0994: E3BC 0E 02                  LD     C,fConsoleOut        ; Load Function Number         		;
0995: E3BE CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
0996: E3C1 C1                     POP    BC                   ; Restore BC                        ;
0997: E3C2 C9                     RET                         ;
0998: E3C3         ;------------------------------- PrintCharInE ------------------------------;
0999: E3C3         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1000: E3C3         ;print CRLF then null terminated string at (BC)                             ;
1001: E3C3             PrintCrLfStringNull:                      ;
1002: E3C3 C5                     PUSH   BC                   ; Save string pointer               ;
1003: E3C4 CD AF E3               CALL   CrLf                 ; Send CR/LF                        ;
1004: E3C7 E1                     POP    HL                   ; Restore pointer & fall thru       ;
1005: E3C8         ;print null terminated string from (HL)                                     ;
1006: E3C8             PrintStringNull:                      ;
1007: E3C8 7E                     LD     A,(HL)               ; Get the next character            ;
1008: E3C9 B7                     OR     A                    ; Is it the Null terminator ?       ;
1009: E3CA C8                     RET    Z                    ;  exit if yes                      ;
1010: E3CB 23                     INC    HL                   ; Move string pointer               ;
1011: E3CC E5                     PUSH   HL                   ; Save for next iteration           ;
1012: E3CD CD B8 E3               CALL   PrintCharInA         ; Send the character to the console ;
1013: E3D0 E1                     POP    HL                   ; string pointer                    ;
1014: E3D1 C3 C8 E3               JP     PrintStringNull      ; Loop for more                     ;
1015: E3D4         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1016: E3D4         ;------------------------- Check For Console Input -------------------------;
1017: E3D4         ;check for a character ready at the console                                 ;
1018: E3D4         ;Exits with	Z-Flag  set if there has been no character input                ;
1019: E3D4         ;					reset if there is a character waiting                   ;
1020: E3D4         ;			A = character input, if Z-Flag reset                            ;
1021: E3D4             CheckForConsoleChar:                      ;
1022: E3D4 0E 0B                  LD     C,fGetConsoleStatus  ; Load Function Number - 0BH        ;
1023: E3D6 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1024: E3D9 B7                     OR     A                    ; Check return value                ;
1025: E3DA C8                     RET    Z                    ; Return if no char waiting         ;
1026: E3DB         ;
1027: E3DB 0E 01                  LD     C,fConsoleIn         ; Load Function Number - 01H        ;
1028: E3DD CD 05 00               CALL   BDOS                 ; character cleared             ;
1029: E3E0 B7                     OR     A                    ; Resets the Z-Flag                 ;
1030: E3E1 C9                     RET                         ;
1031: E3E2         ;------------------------- Check For Console Input -------------------------;
1032: E3E2
1033: E3E2
1034: E3E2
1035: E3E2
1036: E3E2
1037: E3E2         ; UT
1038: E3E2             PrintSpace:
1039: E3E2 3E 20                  LD     A,SPACE
1040: E3E4 C3 E7 E3               JP     PrintSaveBC
1041: E3E7         ;-----------------------------
1042: E3E7         ;print character, but save b,c registers
1043: E3E7             PrintSaveBC:
1044: E3E7 C5                     PUSH   BC
1045: E3E8 CD B8 E3               CALL   PrintCharInA
1046: E3EB C1                     POP    BC
1047: E3EC C9                     RET
1048: E3ED         ;-----------------------------
1049: E3ED         ;-----------------------------
1050: E3ED         ;print no file message
1051: E3ED             PrintNoFile:
1052: E3ED 01 F3 E3               LD     BC,msgNoFile
1053: E3F0 C3 C3 E3               JP     PrintCrLfStringNull
1054: E3F3
1055: E3F3 4E 4F 20 46 49 4C 45 00     msgNoFile: DB     'NO FILE',0
1056: E3FB         ;-----------------------------
1057: E3FB         ;move 3 characters from h,l to d,e addresses
1058: E3FB             CopyHL2DE3:                      ;XXXXXXXXX
1059: E3FB 06 03                  LD     B,3
1060: E3FD             CopyHL2DEforB:
1061: E3FD 7E                     LD     A,(HL)
1062: E3FE 12                     LD     (DE),AE
1063: E3FF 23                     INC    HL
1064: E400 13                     INC    DE
1065: E401 05                     DEC    B
1066: E402 C2 FD E3               JP     NZ,CopyHL2DEforB
1067: E405 C9                     RET
1068: E406         ;-----------------------------
1069: E406         ;return (HL) = (A) + (HL)
1070: E406             AddA2HL:
1071: E406 85                     ADD    A,L
1072: E407 6F                     LD     L,A
1073: E408 D0                     RET    NC
1074: E409 24                     INC    H
1075: E40A C9                     RET
1076: E40B         ;-----------------------------
1077: E40B         ;DMABuffer + a + c to h,l followed by fetch
1078: E40B             GetByteAtAandCandDMA:
1079: E40B 21 80 00               LD     HL,DMABuffer         ; 0080H
1080: E40E 81                     ADD    A,C
1081: E40F CD 06 E4               CALL   AddA2HL
1082: E412 7E                     LD     A,(HL)
1083: E413 C9                     RET
1084: E414         ;-----------------------------
1085: E414         ;-----------------------------
1086: E414         ;*****************************************************************
1087: E414         ;************************ Error messages ******************************
1088: E414         ;*****************************************************************
1089: E414         ;print the read error message
1090: E414             PrintReadError:
1091: E414 01 1A E4               LD     BC,msgReadErr
1092: E417 C3 C3 E3               JP     PrintCrLfStringNull
1093: E41A             msgReadErr:
1094: E41A 52 45 41 44 20 45 52 52 4F 52 00                DB     'READ ERROR',0
1095: E425         ;-----------------------------
1096: E425
1097: E425
1098: E425         ;*****************************************************************
1099: E425         ;--------------------------------------------------------
1100: E425         ;reset disk
1101: E425             ResetDisk:
1102: E425 3A 88 E7               LD     A,(selectedDisk)
1103: E428 B7                     OR     A
1104: E429 C8                     RET    Z                    ; no action if not selected
1105: E42A 3D                     DEC    A
1106: E42B 21 8C E7               LD     HL,currentDisk
1107: E42E BE                     CP     M
1108: E42F C8                     RET    Z                    ; same disk
1109: E430 3A 8C E7               LD     A,(currentDisk)
1110: E433 C3 FE E2               JP     SelectDisk
1111: E436         ;--------------------------------------------------------
1112: E436         ;reset disk before end of command check
1113: E436             ResetDiskAtCmdEnd:
1114: E436 CD 25 E4               CALL   ResetDisk
1115: E439         ;end of intrinsic command
1116: E439             EndCommand:
1117: E439 CD 26 E1               CALL   ParseToken1          ; to check for garbage at end of line
1118: E43C 3A 68 E7               LD     A,(Token1)+1
1119: E43F D6 20                  SUB    SPACE
1120: E441 21 88 E7               LD     HL,selectedDisk
1121: E444 B6                     OR     M
1122: E445         ; 0 in accumulator if no disk selected, and blank fcb
1123: E445 C2 08 E2               JP     NZ,CommandError
1124: E448 C3 26 E0               JP     ccpMainEntry
1125: E44B         ;*****************************************************************
1126: E44B         ;************************ CCP Commands ***************************
1127: E44B         ;*****************************************************************
1128: E44B
1129: E44B         ;******************** Directory Listing ***************************
1130: E44B         ;Directory Listing
1131: E44B             ccpDirectory:
1132: E44B CD 26 E1               CALL   ParseToken1          ; Token1 gets file name
1133: E44E CD 55 E7               CALL   SetDisk4Cmd          ; change disk drives if requested
1134: E451 21 68 E7               LD     HL,Token1+1
1135: E454 7E                     LD     A,(HL)               ; may be empty request
1136: E455 FE 20                  CP     SPACE
1137: E457 C2 63 E4               JP     NZ,ccpDir2           ; skip fill of ??? if not blank
1138: E45A         ; set Token1 to all ??? for current disk
1139: E45A 06 0B                  LD     B,11                 ; length of fill ????????.???
1140: E45C             ccpDir1:
1141: E45C 36 3F                  LD     (HL),QMARK
1142: E45E 23                     INC    HL
1143: E45F 05                     DEC    B
1144: E460 C2 5C E4               JP     NZ,ccpDir1
1145: E463         ; not a blank request, must be in Token1
1146: E463             ccpDir2:
1147: E463 1E 00                  LD     E,0
1148: E465 D5                     PUSH   DE                   ; E counts directory entries
1149: E466 CD 4F E3               CALL   Searc4CmdFcbFile     ; first one has been found
1150: E469 CC ED E3               CALL   Z,PrintNoFile        ; not found message
1151: E46C             ccpDir3:
1152: E46C CA EF E4               JP     Z,ccpDirEnd
1153: E46F         ; found, but may be system file
1154: E46F 3A 8D E7               LD     A,(directoryIndex)   ; get the location of the element
1155: E472 0F                     RRCA
1156: E473 0F                     RRCA
1157: E474 0F                     RRCA
1158: E475 E6 60                  AND    1100000B
1159: E477 4F                     LD     C,A
1160: E478         ; c contains base index into DMABuffer for dir entry
1161: E478 3E 0A                  LD     A,fcbSystemFileIndex ; System File Location in FCB
1162: E47A CD 0B E4               CALL   GetByteAtAandCandDMA ; value to A
1163: E47D 17                     RLA
1164: E47E DA E3 E4               JP     C,ccpDir7            ; skip if system file c holds index into buffer
1165: E481         ;  another fcb found, new line?
1166: E481 D1                     POP    DE                   ; get directory entry count (E)
1167: E482 7B                     LD     A,E
1168: E483 1C                     INC    E
1169: E484 D5                     PUSH   DE                   ; save dir entry count
1170: E485 E6 03                  AND    11B                  ; e=0,1,2,3,...new line if mod 4 = 0
1171: E487 F5                     PUSH   AF                   ; and save the test
1172: E488 C2 A0 E4               JP     NZ,ccpDirHeader      ; header on current line
1173: E48B         ; print the header drive with Colon ie A:
1174: E48B CD AF E3               CALL   CrLf
1175: E48E C5                     PUSH   BC
1176: E48F CD 15 E3               CALL   GetSelectedDrive
1177: E492 C1                     POP    BC
1178: E493 C6 41                  ADD    A,ASCII_A
1179: E495 CD E7 E3               CALL   PrintSaveBC
1180: E498 3E 3A                  LD     A,COLON
1181: E49A CD E7 E3               CALL   PrintSaveBC          ; just printed drive with Colon ie A:
1182: E49D C3 A8 E4               JP     ccpDirHeader1        ; skip current line hdr
1183: E4A0
1184: E4A0             ccpDirHeader:
1185: E4A0 CD E2 E3               CALL   PrintSpace           ; after last one
1186: E4A3 3E 3A                  LD     A,COLON
1187: E4A5 CD E7 E3               CALL   PrintSaveBC
1188: E4A8             ccpDirHeader1:
1189: E4A8 CD E2 E3               CALL   PrintSpace
1190: E4AB         ; compute position of name in buffer
1191: E4AB 06 01                  LD     B,1                  ; start with first character of name
1192: E4AD             ccpDir4:
1193: E4AD 78                     LD     A,B
1194: E4AE CD 0B E4               CALL   GetByteAtAandCandDMA ; DMABuffer+a+c fetched
1195: E4B1 E6 7F                  AND    ASCII_MASK           ; mask flags
1196: E4B3         ; may delete trailing blanks
1197: E4B3 FE 20                  CP     SPACE
1198: E4B5 C2 CD E4               JP     NZ,ccpDir5           ; check for blank type
1199: E4B8 F1                     POP    AF
1200: E4B9 F5                     PUSH   AF                   ; may be 3rd item
1201: E4BA FE 03                  CP     3
1202: E4BC C2 CB E4               JP     NZ,ccpDirSpace       ; place blank at end if not
1203: E4BF 3E 09                  LD     A,9
1204: E4C1 CD 0B E4               CALL   GetByteAtAandCandDMA ; first char of type
1205: E4C4 E6 7F                  AND    ASCII_MASK
1206: E4C6 FE 20                  CP     SPACE
1207: E4C8 CA E2 E4               JP     Z,ccpDir6
1208: E4CB         ; not a blank in the file type field
1209: E4CB             ccpDirSpace:
1210: E4CB 3E 20                  LD     A,SPACE              ; restore trailing filename chr
1211: E4CD             ccpDir5:
1212: E4CD CD E7 E3               CALL   PrintSaveBC          ; char printed
1213: E4D0 04                     INC    B
1214: E4D1 78                     LD     A,B
1215: E4D2 FE 0C                  CP     12
1216: E4D4 D2 E2 E4               JP     NC,ccpDir6
1217: E4D7         ; check for break between names
1218: E4D7 FE 09                  CP     9
1219: E4D9 C2 AD E4               JP     NZ,ccpDir4           ; for another char
1220: E4DC
1221: E4DC CD E2 E3               CALL   PrintSpace           ; print a blank between names
1222: E4DF C3 AD E4               JP     ccpDir4
1223: E4E2
1224: E4E2             ccpDir6:                        ; end of current entry
1225: E4E2 F1                     POP    AF                   ; discard the directory counter (mod 4)
1226: E4E3             ccpDir7:
1227: E4E3 CD D4 E3               CALL   CheckForConsoleChar  ; check for interrupt at keyboard
1228: E4E6 C2 EF E4               JP     NZ,ccpDirEnd         ; abort directory search
1229: E4E9 CD 55 E3               CALL   SearchForNext
1230: E4EC C3 6C E4               JP     ccpDir3              ; for another entry
1231: E4EF             ccpDirEnd:
1232: E4EF D1                     POP    DE                   ; discard directory counter
1233: E4F0 C3 36 E4               JP     ResetDiskAtCmdEnd
1234: E4F3         ;
1235: E4F3
1236: E4F3         ;*****************************************************************
1237: E4F3             ccpErase:
1238: E4F3 CD 26 E1               CALL   ParseToken1          ; cannot be all ???'s
1239: E4F6 FE 0B                  CP     11
1240: E4F8 C2 16 E5               JP     NZ,ccpEraseAll
1241: E4FB         ; erasing all of the disk
1242: E4FB 01 26 E5               LD     BC,msgEraseAll
1243: E4FE CD C3 E3               CALL   PrintCrLfStringNull
1244: E501
1245: E501 CD 65 E0               CALL   ReadCommand
1246: E504 21 2F E2               LD     HL,commandLength
1247: E507 35                     DEC    M
1248: E508 C2 26 E0               JP     NZ,ccpMainEntry      ;bad input
1249: E50B 23                     INC    HL
1250: E50C 7E                     LD     A,(HL)
1251: E50D FE 59                  CP     ASCII_Y
1252: E50F C2 26 E0               JP     NZ,ccpMainEntry
1253: E512         ; ok, erase the entire diskette
1254: E512 23                     INC    HL
1255: E513 22 B0 E2               LD     (commandBufferPointer),HL ; otherwise error at ResetDiskAtCmdEnd
1256: E516             ccpEraseAll:
1257: E516 CD 55 E7               CALL   SetDisk4Cmd
1258: E519 11 67 E7               LD     DE,Token1
1259: E51C CD 33 E3               CALL   DeleteFile
1260: E51F 3C                     INC    A                    ; 255 returned if not found
1261: E520 CC ED E3               CALL   Z,PrintNoFile        ; no file message if so
1262: E523 C3 36 E4               JP     ResetDiskAtCmdEnd
1263: E526         ;
1264: E526             msgEraseAll:
1265: E526 41 4C 4C 20 28 59 2F 4E 29 3F 00                DB     'ALL (Y/N)?',0
1266: E531         ;*****************************************************************
1267: E531         ; Type file
1268: E531             ccpType:
1269: E531 CD 26 E1               CALL   ParseToken1
1270: E534 C2 08 E2               JP     NZ,CommandError      ; don't allow ?'s in file name
1271: E537 CD 55 E7               CALL   SetDisk4Cmd
1272: E53A CD 29 E3               CALL   OpenFile4CmdFCB      ; open the file
1273: E53D CA 7B E5               JP     Z,ccpTypeError       ; zero flag indicates not found
1274: E540         ; file opened, read 'til eof
1275: E540 CD AF E3               CALL   CrLf
1276: E543 21 89 E7               LD     HL,bufferPointer
1277: E546 36 FF                  LD     (HL),255             ; read first buffer
1278: E548             ccpType1:                       ; loop on bufferPointer
1279: E548 21 89 E7               LD     HL,bufferPointer
1280: E54B 7E                     LD     A,(HL)
1281: E54C FE 80                  CP     128                  ; end buffer
1282: E54E DA 5B E5               JP     C,ccpType2
1283: E551 E5                     PUSH   HL                   ; carry if 0,1,...,127
1284: E552         ; read another buffer full
1285: E552 CD 3D E3               CALL   DiskReadCmdFCB
1286: E555 E1                     POP    HL                   ; recover address of bufferPointer
1287: E556 C2 74 E5               JP     NZ,ccpTypeEOF        ; hard end of file
1288: E559 AF                     XOR    A
1289: E55A 77                     LD     (HL),A               ; bufferPointer = 0
1290: E55B         ; read character at bufferPointer and print
1291: E55B             ccpType2:
1292: E55B 34                     INC    M                    ; bufferPointer = bufferPointer + 1
1293: E55C 21 80 00               LD     HL,DMABuffer
1294: E55F CD 06 E4               CALL   AddA2HL              ; h,l addresses char
1295: E562 7E                     LD     A,(HL)
1296: E563 FE 1A                  CP     END_OF_FILE
1297: E565 CA 36 E4               JP     Z,ResetDiskAtCmdEnd
1298: E568 CD B8 E3               CALL   PrintCharInA
1299: E56B CD D4 E3               CALL   CheckForConsoleChar
1300: E56E C2 36 E4               JP     NZ,ResetDiskAtCmdEnd ; abort if break
1301: E571 C3 48 E5               JP     ccpType1             ; for another character
1302: E574
1303: E574             ccpTypeEOF:
1304: E574 3D                     DEC    A
1305: E575 CA 36 E4               JP     Z,ResetDiskAtCmdEnd
1306: E578 CD 14 E4               CALL   PrintReadError
1307: E57B             ccpTypeError:
1308: E57B CD 25 E4               CALL   ResetDisk
1309: E57E C3 08 E2               JP     CommandError
1310: E581         ;*****************************************************************
1311: E581         ; save save memory image
1312: E581         ;*****************************************************************
1313: E581             ccpSave:
1314: E581 CD 67 E3               CALL   GetNumberFromCmdLine ; value to register a
1315: E584 F5                     PUSH   AF                   ; save it for later
1316: E585         ; should be followed by a file to save the memory image
1317: E585 CD 26 E1               CALL   ParseToken1
1318: E588 C2 08 E2               JP     NZ,CommandError      ; cannot be ambiguous
1319: E58B CD 55 E7               CALL   SetDisk4Cmd          ; may be a disk change
1320: E58E 11 67 E7               LD     DE,Token1
1321: E591 D5                     PUSH   DE
1322: E592 CD 33 E3               CALL   DeleteFile           ; existing file removed
1323: E595 D1                     POP    DE
1324: E596 CD 38 E3               CALL   MakeFile             ; create a new file on disk
1325: E599 CA CF E5               JP     Z,ccpSaveError       ; no directory space
1326: E59C AF                     XOR    A
1327: E59D 32 87 E7               LD     (currentRecord),A    ; clear next record field
1328: E5A0 F1                     POP    AF                   ; #pages to write is in a, change to #sectors
1329: E5A1 6F                     LD     L,A
1330: E5A2 26 00                  LD     H,0
1331: E5A4 29                     ADD    HL,HL
1332: E5A5
1333: E5A5 11 00 01               LD     DE,TPA               ; h,l is sector count, d,e is load address
1334: E5A8             ccpSave1:                       ; save0 check for sector count zero
1335: E5A8 7C                     LD     A,H
1336: E5A9 B5                     OR     L
1337: E5AA CA C5 E5               JP     Z,ccpSave2           ; may be completed
1338: E5AD 2B                     DEC    HL                   ; sector count = sector count - 1
1339: E5AE E5                     PUSH   HL                   ; save it for next time around
1340: E5AF 21 80 00               LD     HL,cpmRecordSize
1341: E5B2 19                     ADD    HL,DE
1342: E5B3 E5                     PUSH   HL                   ; next dma address saved
1343: E5B4 CD 62 E3               CALL   SetDMA               ; current dma address set
1344: E5B7 11 67 E7               LD     DE,Token1
1345: E5BA CD 43 E3               CALL   DiskWrite
1346: E5BD D1                     POP    DE
1347: E5BE E1                     POP    HL                   ; dma address, sector count
1348: E5BF C2 CF E5               JP     NZ,ccpSaveError      ; may be disk full case
1349: E5C2 C3 A8 E5               JP     ccpSave1             ; for another sector
1350: E5C5
1351: E5C5         ;  end of dump, close the file
1352: E5C5             ccpSave2:
1353: E5C5 11 67 E7               LD     DE,Token1
1354: E5C8 CD 09 E3               CALL   CloseFile
1355: E5CB 3C                     INC    A                    ; 255 becomes 00 if error
1356: E5CC C2 D5 E5               JP     NZ,ccpSaveExit       ; for another command
1357: E5CF             ccpSaveError:                      ; saverr must be full or read only disk
1358: E5CF 01 DB E5               LD     BC,msgNoSpace
1359: E5D2 CD C3 E3               CALL   PrintCrLfStringNull
1360: E5D5             ccpSaveExit:
1361: E5D5 CD 5F E3               CALL   SetDefaultDMA        ; reset dma buffer
1362: E5D8 C3 36 E4               JP     ResetDiskAtCmdEnd
1363: E5DB
1364: E5DB             msgNoSpace:
1365: E5DB 4E 4F 20 53 50 41 43 45 00                DB     'NO SPACE',0
1366: E5E4         ;*****************************************************************
1367: E5E4             ccpRename:
1368: E5E4 CD 26 E1               CALL   ParseToken1
1369: E5E7 C2 08 E2               JP     NZ,CommandError      ; must be unambiguous
1370: E5EA 3A 88 E7               LD     A,(selectedDisk)
1371: E5ED F5                     PUSH   AF                   ; save for later compare
1372: E5EE CD 55 E7               CALL   SetDisk4Cmd          ; disk selected
1373: E5F1 CD 4F E3               CALL   Searc4CmdFcbFile     ; is new name already there?
1374: E5F4 C2 4D E6               JP     NZ,ccpRenameError3
1375: E5F7         ; file doesn't exist, move to second half of fcb
1376: E5F7 21 67 E7               LD     HL,Token1
1377: E5FA 11 77 E7               LD     DE,Token2
1378: E5FD 06 10                  LD     B,16
1379: E5FF CD FD E3               CALL   CopyHL2DEforB
1380: E602         ; check for = or left arrow
1381: E602 2A B0 E2               LD     HL,(commandBufferPointer)
1382: E605 EB                     EX     DE,HL
1383: E606 CD B5 E1               CALL   NextNonBlankChar
1384: E609 FE 3D                  CP     EQUAL_SIGN
1385: E60B CA 13 E6               JP     Z,ccpRename1         ; ok if =
1386: E60E FE 5F                  CP     LEFT_ARROW           ; la
1387: E610 C2 47 E6               JP     NZ,ccpRenameError2
1388: E613             ccpRename1:
1389: E613 EB                     EX     DE,HL
1390: E614 23                     INC    HL
1391: E615 22 B0 E2               LD     (commandBufferPointer),HL ; past delimiter
1392: E618         ; proper delimiter found
1393: E618 CD 26 E1               CALL   ParseToken1
1394: E61B C2 47 E6               JP     NZ,ccpRenameError2
1395: E61E         ; check for drive conflict
1396: E61E F1                     POP    AF
1397: E61F 47                     LD     B,A                  ; previous drive number
1398: E620 21 88 E7               LD     HL,selectedDisk
1399: E623 7E                     LD     A,(HL)
1400: E624 B7                     OR     A
1401: E625 CA 2D E6               JP     Z,ccpRename2
1402: E628         ; drive name was specified.  same one?
1403: E628 B8                     CP     B
1404: E629 70                     LD     (HL),B
1405: E62A C2 47 E6               JP     NZ,ccpRenameError2
1406: E62D             ccpRename2:
1407: E62D 70                     LD     (HL),B               ; store the name in case drives switched
1408: E62E AF                     XOR    A
1409: E62F 32 67 E7               LD     (Token1),A
1410: E632 CD 4F E3               CALL   Searc4CmdFcbFile     ; is old file there?
1411: E635 CA 41 E6               JP     Z,ccpRenameError1
1412: E638         ; everything is ok, rename the file
1413: E638 11 67 E7               LD     DE,Token1
1414: E63B CD 5A E3               CALL   RenameFile
1415: E63E C3 36 E4               JP     ResetDiskAtCmdEnd
1416: E641
1417: E641             ccpRenameError1:                      ; no file on disk
1418: E641 CD ED E3               CALL   PrintNoFile
1419: E644 C3 36 E4               JP     ResetDiskAtCmdEnd
1420: E647             ccpRenameError2:                      ; ambigous reference/name conflict
1421: E647 CD 25 E4               CALL   ResetDisk
1422: E64A C3 08 E2               JP     CommandError
1423: E64D             ccpRenameError3:                      ; file already exists
1424: E64D 01 56 E6               LD     BC,msgFileExists
1425: E650 CD C3 E3               CALL   PrintCrLfStringNull
1426: E653 C3 36 E4               JP     ResetDiskAtCmdEnd
1427: E656
1428: E656             msgFileExists:
1429: E656 46 49 4C 45 20 45 58 49 53 54 53 00                DB     'FILE EXISTS',0
1430: E662
1431: E662         ;*****************************************************************
1432: E662             ccpUser:
1433: E662 CD 67 E3               CALL   GetNumberFromCmdLine ; leaves the value in the accumulator
1434: E665 FE 10                  CP     16
1435: E667 D2 08 E2               JP     NC,CommandError      ; must be between 0 and 15
1436: E66A 5F                     LD     E,A                  ; save for SetUser call
1437: E66B 3A 68 E7               LD     A,(Token1)+1
1438: E66E FE 20                  CP     SPACE
1439: E670 CA 08 E2               JP     Z,CommandError
1440: E673 CD 1C E3               CALL   SetUser              ;new user number set
1441: E676 C3 39 E4               JP     EndCommand
1442: E679         ;*****************************************************************
1443: E679         ;User defined function
1444: E679         ;*****************************************************************
1445: E679             ccpUserFunction:
1446: E679
1447: E679 3A 68 E7               LD     A,(Token1)+1
1448: E67C FE 20                  CP     SPACE
1449: E67E C2 95 E6               JP     NZ,ccpUserFunction1
1450: E681         ; no file name, but may be disk switch
1451: E681 3A 88 E7               LD     A,(selectedDisk)
1452: E684 B7                     OR     A
1453: E685 CA 39 E4               JP     Z,EndCommand         ; no disk named if 0
1454: E688 3D                     DEC    A                    ; adjust so A=>0, B=>1, C=>2 ......
1455: E689 32 8C E7               LD     (currentDisk),A      ; update current Disk indicator
1456: E68C CD 1A E1               CALL   SetPage0CurDisk      ; set user/disk
1457: E68F CD FE E2               CALL   SelectDisk
1458: E692 C3 39 E4               JP     EndCommand
1459: E695
1460: E695         ;  file name is present
1461: E695             ccpUserFunction1:
1462: E695 11 70 E7               LD     DE,Token1+9
1463: E698 1A                     LD     A,(DE)
1464: E699 FE 20                  CP     SPACE
1465: E69B C2 08 E2               JP     NZ,CommandError      ; type SPACE
1466: E69E D5                     PUSH   DE
1467: E69F CD 55 E7               CALL   SetDisk4Cmd
1468: E6A2 D1                     POP    DE
1469: E6A3 21 52 E7               LD     HL,comFileType       ; .com
1470: E6A6 CD FB E3               CALL   CopyHL2DE3           ; file type is set to .com
1471: E6A9 CD 29 E3               CALL   OpenFile4CmdFCB
1472: E6AC CA 3A E7               JP     Z,ccpUserFunctionError1
1473: E6AF         ; file opened properly, read it into memory
1474: E6AF 21 00 01               LD     HL,TPA               ; transient program base
1475: E6B2             ccpUserFunction2:
1476: E6B2 E5                     PUSH   HL                   ;save dma address
1477: E6B3 EB                     EX     DE,HL
1478: E6B4 CD 62 E3               CALL   SetDMA
1479: E6B7 11 67 E7               LD     DE,Token1
1480: E6BA CD 0E E3               CALL   DiskRead
1481: E6BD C2 D2 E6               JP     NZ,ccpUserFunction3
1482: E6C0         ; sector loaded, set new dma address and compare
1483: E6C0 E1                     POP    HL
1484: E6C1 11 80 00               LD     DE,cpmRecordSize
1485: E6C4 19                     ADD    HL,DE
1486: E6C5 11 00 E0               LD     DE,CcpBoundary       ; has the load overflowed?
1487: E6C8 7D                     LD     A,L
1488: E6C9 93                     SUB    E
1489: E6CA 7C                     LD     A,H
1490: E6CB 9A                     SBC    A,D
1491: E6CC D2 40 E7               JP     NC,ccpUserFunctionError2
1492: E6CF C3 B2 E6               JP     ccpUserFunction2     ; for another sector
1493: E6D2
1494: E6D2             ccpUserFunction3:
1495: E6D2 E1                     POP    HL
1496: E6D3 3D                     DEC    A
1497: E6D4 C2 40 E7               JP     NZ,ccpUserFunctionError2 ; end file is 1
1498: E6D7 CD 25 E4               CALL   ResetDisk            ; back to original disk
1499: E6DA CD 26 E1               CALL   ParseToken1
1500: E6DD 21 88 E7               LD     HL,selectedDisk
1501: E6E0 E5                     PUSH   HL
1502: E6E1 7E                     LD     A,(HL)
1503: E6E2 32 67 E7               LD     (Token1),A           ; drive number set
1504: E6E5         ; 	LD		A,16
1505: E6E5 CD 21 E1               CALL   ParseToken2          ; move entire fcb to memory
1506: E6E8 E1                     POP    HL
1507: E6E9 7E                     LD     A,(HL)
1508: E6EA 32 77 E7               LD     (Token2),A
1509: E6ED AF                     XOR    A
1510: E6EE 32 87 E7               LD     (currentRecord),A    ; record number set to zero
1511: E6F1 11 5C 00               LD     DE,FCB1              ; default FCB in page 0
1512: E6F4 21 67 E7               LD     HL,Token1
1513: E6F7 06 21                  LD     B,33
1514: E6F9 CD FD E3               CALL   CopyHL2DEforB
1515: E6FC         ; move command line to buff
1516: E6FC 21 30 E2               LD     HL,commandBuffer
1517: E6FF             ccpUserFunction4:
1518: E6FF 7E                     LD     A,(HL)
1519: E700 B7                     OR     A
1520: E701 CA 0D E7               JP     Z,ccpUserFunction5
1521: E704 FE 20                  CP     SPACE
1522: E706 CA 0D E7               JP     Z,ccpUserFunction5
1523: E709 23                     INC    HL
1524: E70A C3 FF E6               JP     ccpUserFunction4     ; for another scan
1525: E70D         ; first blank position found
1526: E70D             ccpUserFunction5:
1527: E70D 06 00                  LD     B,0
1528: E70F 11 81 00               LD     DE,DMABuffer+1
1529: E712         ; ready for the move
1530: E712             ccpUserFunction6:
1531: E712 7E                     LD     A,(HL)
1532: E713 12                     LD     (DE),AE
1533: E714 B7                     OR     A
1534: E715 CA 1E E7               JP     Z,ccpUserFunction7
1535: E718         ;more to move
1536: E718 04                     INC    B
1537: E719 23                     INC    HL
1538: E71A 13                     INC    DE
1539: E71B C3 12 E7               JP     ccpUserFunction6
1540: E71E             ccpUserFunction7:                      ; B has character count
1541: E71E 78                     LD     A,B
1542: E71F 32 80 00               LD     (DMABuffer),A
1543: E722 CD AF E3               CALL   CrLf
1544: E725         ; now go to the loaded program
1545: E725 CD 5F E3               CALL   SetDefaultDMA        ; default dma
1546: E728 CD 0B E1               CALL   SaveUserAndDisk      ; user code saved
1547: E72B         ; low memory diska contains user code
1548: E72B CD 00 01               CALL   TPA                  ; gone to the loaded program
1549: E72E 31 F0 E7               LD     SP,Stack             ; may come back here
1550: E731 CD 1A E1               CALL   SetPage0CurDisk
1551: E734 CD FE E2               CALL   SelectDisk
1552: E737 C3 26 E0               JP     ccpMainEntry
1553: E73A
1554: E73A             ccpUserFunctionError1:
1555: E73A CD 25 E4               CALL   ResetDisk
1556: E73D C3 08 E2               JP     CommandError
1557: E740
1558: E740             ccpUserFunctionError2:                      ; cannot load the program
1559: E740 01 49 E7               LD     BC,msgBadLoad
1560: E743 CD C3 E3               CALL   PrintCrLfStringNull
1561: E746 C3 36 E4               JP     ResetDiskAtCmdEnd
1562: E749
1563: E749             msgBadLoad:
1564: E749 42 41 44 20 4C 4F 41 44 00                DB     'BAD LOAD',0
1565: E752             comFileType:
1566: E752 43 4F 4D                DB     'COM'                ;for com files
1567: E755         ;
1568: E755
1569: E755         ;*****************************************************************
1570: E755         ;*****************************************************************
1571: E755         ;change disks for this command, if requested
1572: E755             SetDisk4Cmd:
1573: E755 AF                     XOR    A
1574: E756 32 67 E7               LD     (Token1),A           ; clear disk name from fcb
1575: E759 3A 88 E7               LD     A,(selectedDisk)
1576: E75C B7                     OR     A
1577: E75D C8                     RET    Z                    ; no action if not specified
1578: E75E 3D                     DEC    A
1579: E75F 21 8C E7               LD     HL,currentDisk
1580: E762 BE                     CP     M
1581: E763 C8                     RET    Z                    ;already selected
1582: E764 C3 FE E2               JP     SelectDisk
1583: E767         ;*****************************************************************
1584: E767
1585: E767         ;*****************************************************************
1586: E767         ;************************ Data Area ******************************
1587: E767         ;*****************************************************************
1588: E767         ;------------------------------ Command Buffer -----------------------------;
1589: E767         ;;
1590: E767         ;;
1591: E767             Token1:    DS     16                   ; Command Token
1592: E777             Token2:    DS     16                   ; Command Token
1593: E787
1594: E787
1595: E787
1596: E787 00          currentRecord: DB     00H                  ; current record to read/write
1597: E788 00          selectedDisk: DB     00H                  ; selected disk for current operation none=0, a=1, b=2 ...
1598: E789         ;
1599: E789 00          bufferPointer: DB     00H                  ; buffer pointer
1600: E78A         ;------------------------------------
1601: E78A 00 00       tokenStart: DW     0000H                ; staddr starting address of current Fill FCB request
1602: E78C         ;----------------------------
1603: E78C         ; (command executed initially if commandLength non zero)
1604: E78C         ;--------------------------------- Variables -------------------------------;
1605: E78C 00          currentDisk: DB     00H                  ; Current disk
1606: E78D 00          directoryIndex: DB     00H                  ; Index into Directory Buffer
1607: E78E         ;--------------------------------- Variables -------------------------------;
1608: E78E
1609: E78E             endOfCode:
1610: E78E                        ORG    BDOSBase-10H
1611: E7F0             Stack:                          ; Top Of Stack
1612: E7F0
1613: E7F0         ;Z_HighestLocation:
1614: E7F0             ZZ_MemoryLeft EQU    (BDOSBase-1) - endOfCode
1615: E7F0
1616: E7F0
1617: E7F0
1618: E7F0
1619: E7F0
           ************************   Xref   ************************
0000: $               E7F0   0768
1070: AddA2HL         E406   1081 1294
0084: ASCII_A         0041   0329 1178
0085: ASCII_C         0043
0086: ASCII_K         004B
0093: ASCII_LO_A      0061
0094: ASCII_LO_K      006B
0095: ASCII_LO_P      0070
0036: ASCII_MASK      007F   1195 1205
0087: ASCII_N         004E
0088: ASCII_Q         0051
0089: ASCII_R         0052
0090: ASCII_W         0057
0091: ASCII_Y         0059   1251
0071: ASCII_ZERO      0030   0935
0065: ASTERISK        002A   0576
0288: BDOS            0005   0420 0786 0792 0817 0825 0834 0846 0863 0878 0900 0909 0995 1023 1028
0845: BDOSandIncA     E321   0801 0810 0868 0885 0895
0151: BDOSBase        E800   0152 0154 1610 1614
0120: BDOSE           0005   0121
0152: BDOSEntry       E800
0141: BDOSLength      0E00   0144 0154 0155
0054: BELL            0007
0154: BIOSBase        F600
0142: BIOSLength      0A00   0144
0114: BIOSPAGE        0002
0155: BIOSStart       F600
0251: BlockSize       0800   0273
1599: bufferPointer   E789   1276 1279
0768: builtInCMDCount 0006   0678
0761: builtInCMDNames E2D3   0674 0768
0759: builtInCMDNameSize 0004   0681 0768
0770: builtInCMDVector E2EB   0347
0032: BYTE            0001
0092: CARET           005E
0296: CcpBoundary     E000   1486
1140: ccpDir1         E45C   1144
1146: ccpDir2         E463   1137
1151: ccpDir3         E46C   1230
1192: ccpDir4         E4AD   1219 1222
1211: ccpDir5         E4CD   1198
1224: ccpDir6         E4E2   1207 1216
1226: ccpDir7         E4E3   1164
1131: ccpDirectory    E44B   0771
1231: ccpDirEnd       E4EF   1152 1228
1184: ccpDirHeader    E4A0   1172
1188: ccpDirHeader1   E4A8   1182
1209: ccpDirSpace     E4CB   1202
0149: CCPEntry        E000   0151 0155 0295
1237: ccpErase        E4F3   0772
1256: ccpEraseAll     E516   1240
0140: CCPLength       0800   0144 0151 0155
0325: ccpMainEntry    E026   0413 0732 1124 1248 1252 1552
0335: CcpParseCommand E03C   0323
1367: ccpRename       E5E4   0775
1388: ccpRename1      E613   1385
1406: ccpRename2      E62D   1401
1417: ccpRenameError1 E641   1411
1420: ccpRenameError2 E647   1387 1394 1405
1423: ccpRenameError3 E64D   1374
1313: ccpSave         E581   0774
1334: ccpSave1        E5A8   1349
1352: ccpSave2        E5C5   1337
1357: ccpSaveError    E5CF   1325 1348
1360: ccpSaveExit     E5D5   1356
0304: CcpStart        E000
1268: ccpType         E531   0773
1278: ccpType1        E548   1301
1291: ccpType2        E55B   1282
1303: ccpTypeEOF      E574   1287
1307: ccpTypeError    E57B   1273
1432: ccpUser         E662   0776
1445: ccpUserFunction E679   0344 0777
1461: ccpUserFunction1 E695   1449
1475: ccpUserFunction2 E6B2   1492
1494: ccpUserFunction3 E6D2   1481
1517: ccpUserFunction4 E6FF   1524
1526: ccpUserFunction5 E70D   1520 1522
1530: ccpUserFunction6 E712   1539
1540: ccpUserFunction7 E71E   1534
1554: ccpUserFunctionError1 E73A   1472
1558: ccpUserFunctionError2 E740   1491 1497
1021: CheckForConsoleChar E3D4   0410 1227 1299
0808: CloseFile       E309   0401 1354
0072: COLON           003A   0518 0660 1180 1186
1565: comFileType     E752   1469
0067: COMMA           002C
0739: commandBuffer   E230   0408 0437 0741 1516
0741: commandBufferPointer E2B0   0438 0502 0548 1255 1381 1391
0712: CommandError    E208   0341 0652 0924 0937 0941 0947 0949 0951 0959 1123 1270 1309 1318 1369 1422 1435 1439 1465 1556
0727: CommandErrorExit E220   0718 0720
0715: CommandErrorLoop E20E   0725
0738: commandLength   E22F   0321 0386 0425 1246
0737: commandMaxLength E22E   0418
0126: ComTail         0080   0127
0128: ComTailChars    0082
0127: ComTailCount    0081   0128
1058: CopyHL2DE3      E3FB   1470
1060: CopyHL2DEforB   E3FD   1066 1379 1514
0228: cpmRecordSize   0080   0230 0233 0235 0387 1340 1484
0057: CR              000D   0976
0975: CrLf            E3AF   0327 0713 0730 1003 1174 1275 1543
0040: CTRL_C          0003
0041: CTRL_E          0005
0042: CTRL_H          0008
0043: CTRL_K          000B
0044: CTRL_L          000C
0045: CTRL_P          0010
0046: CTRL_R          0012
0047: CTRL_S          0013
0048: CTRL_U          0015
0049: CTRL_X          0018
0050: CTRL_Z          001A
1605: currentDisk     E78C   0339 0369 0404 0464 0475 0483 0524 1106 1109 1455 1579
1596: currentRecord   E787   0856 1327 1510
0068: DASH            002D
0262: DataBlocks      02C7   0272
0261: DataSectors     0B1C   0262
0861: DeleteFile      E333   0463 1259 1322
0454: DeleteSubmitFile E0F3   0412 0416 0731
0233: DirBuffSize     0080
0248: DirectoryBlockCount 0002   0273
0235: DirectoryEntryPerRecord 0004   0276
1606: directoryIndex  E78D   0847 1154
0232: DirEntrySize    0020   0235 0273
0220: DiskCommandBlock 0046
0219: DiskControlByte 0045
0222: DiskControlTable 0040
0815: DiskRead        E30E   0381 0873 1480
0871: DiskReadCmdFCB  E33D   1285
0224: DiskReadCode    0001
0229: diskSectorSize  0200   0230 0251 0259
0218: DiskStatusLocation 0043
0876: DiskWrite       E343   1345
0225: DiskWriteCode   0002
0131: DMABuffer       0080   0336 0385 0904 1079 1293 1528 1542
0061: DOLLAR          0024
0274: dpb3hdAL0       00C0
0275: dpb3hdAL1       0000
0270: dpb3hdBLM       000F
0269: dpb3hdBSH       0004
0276: dpb3hdCKS       0020
0273: dpb3hdDRM       007F   0276
0272: dpb3hdDSM       02C6
0271: dpb3hdEXM       0000
0278: dpb3hdNOH       0002
0277: dpb3hdOFF       0001
0268: dpb3hdSPT       0090
0135: END_OF_FILE     001A   1296
1116: EndCommand      E439   1441 1453 1458
1609: endOfCode       E78E   1614
0038: EndOfMessage    0000
0076: EQUAL_SIGN      003D   0654 1384
0059: EXCLAIM_POINT   0021
0027: FALSE           0000
0123: FCB1            005C   0124 1511
0124: FCB2            006C
0290: fcbSystemFileIndex 000A   1161
0168: fCloseFile      0010   0809
0159: fConsoleIn      0001   1027
0160: fConsoleOut     0002   0994
0171: fDeleteFile     0013   0862
0163: fGetConsoleStatus 000B   1022
0177: fGetCurrentDisk 0019   0824
0176: fGetLoginVector 0018
0179: fGetSetUserNumber 0020   0833
0164: fGetVersion     000C
0291: FILE_NAME_SIZE  0008   0535 0551
0292: FILE_TYPE_SIZE  0003   0539 0551
0627: FillWithAcc     E1B0   0546 0630
0625: FillWithSpace   E1AE   0594 0615
0174: fMakeFile       0016   0867
0167: fOpenFile       000F   0800
0571: FormatElement   E181   0536 0541 0585
0581: FormatElement1  E192   0577
0584: FormatElement2  E194   0579
0161: fPrintString    0009
0172: fReadSeq        0014   0816
0162: fReadString     000A   0419
0175: fRenameFile     0017   0899
0165: fResetSystem    000D   0785
0169: fSearchFirst    0011   0884
0170: fSearchNext     0012   0894
0166: fSelectDisk     000E   0791
0178: fSetDMA         001A   0908
0173: fWriteSeq       0015   0877
1078: GetByteAtAandCandDMA E40B   1162 1194 1204
0920: GetNumberFromCmdLine E367   1314 1433
0929: GetNumericValue E377   0954
0956: GetNumericValue1 E3A2   0932 0962
0823: GetSelectedDrive E315   0328 0338 1176
0829: GetUser         E31A   0470
0077: GREATER_THAN    003E   0331 0666
0060: HASH_TAG        0023
0784: Initialize      E2F9   0314
0673: IntrinsicFunction E1DE   0346
0676: IntrinsicFunction1 E1E3   0704
0682: IntrinsicFunction2 E1EC   0689
0697: IntrinsicFunction3 E1FF   0685 0700
0702: IntrinsicFunction4 E204   0693
0115: IOBYTE          0003
0647: IsItADelimiter  E1BF   0572 0588
0608: IsItDot         E1A2   0540
0063: L_PAREN         0028
0080: LEFT_ARROW      005F   1386
0096: LEFT_CURLY      007B
0144: LengthInBytes   2000   0145 0149 0259
0145: LengthInK       0009
0075: LESS_THAN       003C   0664
0056: LF              000A   0978
0030: LO_NIBBLE_MASK  000F   0318
0866: MakeFile        E338   1324
0736: maximumBufferSize 007F   0737 0739
0147: MemorySize      0040   0149
1563: msgBadLoad      E749   1559
1264: msgEraseAll     E526   1242
1428: msgFileExists   E656   1424
1055: msgNoFile       E3F3   1052
1364: msgNoSpace      E5DB   1358
1093: msgReadErr      E41A   1091
0260: myOffset        0001   0261 0277
0635: NextNonBlankChar E1B5   0504 0642 1383
0423: NoRead          E0D5   0411
0415: NotSubmitFile   E0C4   0367 0376 0382 0402
0052: NULL            0000
0244: NumberOfHeads   0002   0255 0257 0268 0278
0241: NumberOfLogicalDisks 0004
0029: OFF             0000
0028: ON              FFFF
0799: OpenFile        E304   0375 0858
0854: OpenFile4CmdFCB E329   1272 1471
0593: PadTheElement   E19E   0573
0497: ParseToken      E129   0494
0495: ParseToken1     E126   0340 0921 1117 1132 1238 1269 1317 1368 1393 1499
0492: ParseToken2     E121   1505
0062: PERCENT         0025
0069: PERIOD          002E   0611 0658
0118: Pg0CurentDisk   0004   0319 0477 0484
0117: Pg0CurentUser   0004   0118
0066: PLUS_SIGN       002B
0984: PrintCharInA    E3B8   0330 0332 0722 0729 1012 1045 1298
0992: PrintCharInE    E3BB   0977 0979 0986
1001: PrintCrLfStringNull E3C3   1053 1092 1243 1359 1425 1560
1051: PrintNoFile     E3ED   1150 1261 1418
1090: PrintReadError  E414   1306
1043: PrintSaveBC     E3E7   1040 1179 1181 1187 1212
1038: PrintSpace      E3E2   1185 1189 1221
1006: PrintStringNull E3C8   0409 1014
0078: QMARK           003F   0553 0578 0728 1141
0554: QuestionMarkCount E177   0560
0559: QuestionMarkCount1 E17C   0557
0064: R_PAREN         0029
0111: RAM             0000   0113 0114 0115 0117 0120 0123 0126 0131 0133
0364: ReadCommand     E065   0333 1245
0253: RecordsPerBlock 0010
0237: RecordsPerExtent 0080
0230: recordsPerSector 0004   0253 0268
0898: RenameFile      E35A   1414
1101: ResetDisk       E425   1114 1308 1421 1498 1555
1113: ResetDiskAtCmdEnd E436   1233 1262 1297 1300 1305 1362 1415 1419 1426 1561
0081: RUBOUT          007F
0469: SaveUserAndDisk E10B   0417 1546
0888: Searc4CmdFcbFile E34F   1149 1373 1410
0883: SearchForFirst  E34A   0890
0893: SearchForNext   E355   1229
0282: SectorMask      0003
0247: SectorsPerBlock 0004   0251 0253 0256 0262 0282
0257: SectorsPerCylinder 0024   0260 0261
0246: SectorsPerTrack 0012   0255 0257 0268
0789: SelectDisk      E2FE   0320 0372 0406 0461 0465 1110 1457 1551 1582
1597: selectedDisk    E788   0342 0501 0530 0922 1102 1120 1370 1398 1451 1500 1575
0074: SEMICOLON       003B   0662
0903: SetDefaultDMA   E35F   1361 1545
1572: SetDisk4Cmd     E755   1133 1257 1271 1319 1372 1467
0907: SetDMA          E362   0337 1343 1478
0534: SetFileName     E159   0526
0482: SetPage0CurDisk E11A   0421 1456 1550
0538: SetType         E15E
0832: SetUser         E31C   0312 1440
0070: SLASH           002F
0053: SOH             0001
0058: SPACE           0020   0626 0639 0651 0692 0717 0931 0958 1039 1119 1136 1197 1206 1210 1438 1448 1464 1521
1611: Stack           E7F0   0305 0326 1549
0755: submitCR        E2D2   0379
0749: submitExtent    E2BE
0747: submitFCB       E2B3   0374 0380 0400 0462
0745: submitFlag      E2B2   0315 0365 0455
0751: submitFWF       E2C0   0393
0754: submitMap       E2C2
0753: submitRC        E2C1   0377 0398
0750: submitS1        E2BF
0752: submitS2        E2C0
0748: submitType      E2BB
0259: SystemSectors   0011   0260
0055: TAB             0009
1591: Token1          E767   0496 0680 0857 0872 0889 0926 1118 1134 1258 1320 1344 1353 1376 1409 1413 1437 1447 1462 1479 1503 1512 1574
1592: Token2          E777   0493 1377 1508
1601: tokenStart      E78A   0506 0714
0121: TopRAM          0007
0256: TotalNumberOfBlocks 02D0
0255: TotalNumberOfSectors 0B40   0256 0261
0133: TPA             0100   1333 1474 1548
0245: TracksPerHead   0050   0255
0026: TRUE            FFFF
0587: TruncateElement E196   0591
0079: UNDER_SCORE     005F   0656
0444: UpCase          E0EA   0430
0427: UpCaseLoop      E0D9   0432
0523: UseCurrentDisk  E14C   0513
0528: UseTokensDisk   E153   0519
0113: WarmBoot        0000
0033: WORD            0002
0193: WriteAllocated  0000
0195: WriteCleanBuffer 0002
0194: WriteDirectory  0001
0037: ZERO            0000
1614: ZZ_MemoryLeft   0071
