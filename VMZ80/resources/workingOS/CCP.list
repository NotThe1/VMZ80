0001: E000         ;     File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
0002: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm
0003: E000
0004: E000         ; CCP.Z80
0005: E000         ;
0006: E000         ; 2019-03-01 Finished refactor to Z80 idiom
0007: E000         ; 2019-02-19 Started to refactor to Z80 idiom
0008: E000
0009: E000         ; 2017-03-02 Refactored the CP/M Suite
0010: E000         ; 2014-01-16
0011: E000         ; 2014-05-01  :  Frank Martyn
0012: E000
0013: E000         ; replace systemFile with fcbSystemFileIndex
0014: E000
0015: E000                        Include ./stdHeader.Z80
0016: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0017: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0018: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0019: E000         ; stdHeader.asm
0020: E000         ; standard equates
0021: E000
0022: E000         ; 2017-03-02 Refactored the CP/M Suite
0023: E000
0024: E000
0025: E000             TRUE       EQU    -1                   ; Not false
0026: E000             FALSE      EQU    0000H
0027: E000             LO_NIBBLE_MASK EQU    0FH                  ; Mask used to obtain the bytes low four bits
0028: E000
0029: E000             BYTE       EQU    1                    ; Number of bytes for "byte" type
0030: E000             WORD       EQU    2                    ; Number of bytes for "word" type
0031: E000
0032: E000
0033: E000             ASCII_MASK EQU    7FH                  ; ASCII mask 7 bits
0034: E000             EndOfMessage EQU    00H
0035: E000
0036: E000             CTRL_C     EQU    03H                  ; ETX
0037: E000             CTRL_E     EQU    05H                  ; Physical EOL
0038: E000             CTRL_H     EQU    08H                  ; Backspace
0039: E000             CTRL_L     EQU    0CH                  ; FF - Form feed
0040: E000             CTRL_P     EQU    10H                  ; Print toggle
0041: E000             CTRL_R     EQU    12H                  ; Repeat line
0042: E000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0043: E000             CTRL_U     EQU    15H                  ; Line delete
0044: E000             CTRL_X     EQU    18H                  ; Logical line delete
0045: E000             CTRL_Z     EQU    1AH                  ; End of file
0046: E000
0047: E000             TAB        EQU    09H                  ; Tab
0048: E000             LF         EQU    0AH                  ; Line Feed
0049: E000             CR         EQU    0DH                  ; Carriage Return
0050: E000             SPACE      EQU    20H                  ; Space
0051: E000             HASH_TAG   EQU    23H                  ; Sharp sign #
0052: E000             DOLLAR     EQU    24H                  ; Dollar Sign
0053: E000             PERCENT    EQU    25H                  ; Percent Sign
0054: E000             ASTERISK   EQU    2AH                  ; Asterisk *
0055: E000             PERIOD     EQU    2EH                  ; Period
0056: E000             ASCII_ZERO EQU    30H                  ; zero
0057: E000             COLON      EQU    3AH                  ; Colon
0058: E000
0059: E000             SEMICOLON  EQU    3BH                  ; Semi Colon
0060: E000             LESS_THAN  EQU    3CH                  ; Less Than <
0061: E000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0062: E000             GREATER_THAN EQU    3EH                  ; Greater Than >
0063: E000             QMARK      EQU    3FH                  ; Question Mark
0064: E000             UNDER_SCORE EQU    5FH                  ; under score _
0065: E000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0066: E000             RUBOUT     EQU    7FH                  ; Delete Key
0067: E000
0068: E000
0069: E000             ASCII_A    EQU    'A'
0070: E000             ASCII_C    EQU    'C'
0071: E000             ASCII_M    EQU    'M'
0072: E000             ASCII_O    EQU    'O'
0073: E000             ASCII_Y    EQU    'Y'
0074: E000             CARET      EQU    '^'
0075: E000
0076: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0077: E000                        Include ./osHeader.Z80
0078: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0079: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0080: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0081: E000         ; osHeader.Z80
0082: E000
0083: E000         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0084: E000         ; 2017-03-02 Refactored the CP/M Suite
0085: E000
0086: E000         ; Contains the Equates used by the CP/M system
0087: E000
0088: E000         ;------------------------Page Zero Constants ---------------------------------
0089: E000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0090: E000
0091: E000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0092: E000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0093: E000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0094: E000
0095: E000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0096: E000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0097: E000
0098: E000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0099: E000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0100: E000
0101: E000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0102: E000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0103: E000
0104: E000             ComTail    EQU    RAM + 080H           ; Complete command tail
0105: E000             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0106: E000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0107: E000         ;-----------------------------------------------------------------------
0108: E000
0109: E000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0110: E000         ;-----------------------------------------------------------------------
0111: E000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0112: E000         ;-----------------------------------------------------------------------
0113: E000             END_OF_FILE EQU    1AH                  ; end of file
0114: E000         ;-----------------------------------------------------------------------
0115: E000
0116: E000         ;--------------- CP/M Constants -----------------------------------------
0117: E000
0118: E000             CCPLength  EQU    0800H                ; Constant
0119: E000             BDOSLength EQU    0E00H                ; Constant 0E00H
0120: E000             BIOSLength EQU    0A00H                ; Constant 0900H
0121: E000
0122: E000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0123: E000             LengthInK  EQU    (LengthInBytes/1024) + 1
0124: E000
0125: E000             MemorySize EQU    64
0126: E000
0127: E000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0128: E000
0129: E000             BDOSBase   EQU    CCPEntry + CCPLength
0130: E000             BDOSEntry  EQU    BDOSBase
0131: E000
0132: E000             BIOSBase   EQU    BDOSBase + BDOSLength
0133: E000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0134: E000         ;-----------------------------------------------------------------------
0135: E000
0136: E000         ;------------------- BDOS System Call Equates --------------------------
0137: E000             fConsoleIn EQU    01H                  ; rcharf - Console Input
0138: E000             fConsoleOut EQU    02H                  ; pcharf - Console Output
0139: E000             fPrintString EQU    09H                  ; pbuff	- Print String
0140: E000             fReadString EQU    0AH                  ; rbuff	- Read Console String
0141: E000             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0142: E000             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0143: E000             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0144: E000             fSelectDisk EQU    0EH                  ; self	- Select Disk
0145: E000             fOpenFile  EQU    0FH                  ; openf	- Open File
0146: E000             fCloseFile EQU    10H                  ; closef - Close File
0147: E000             fSearchFirst EQU    11H                  ; searf	- Search For First
0148: E000             fSearchNext EQU    12H                  ; searnf - Search for Next
0149: E000             fDeleteFile EQU    13H                  ; delf - Delete File
0150: E000             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0151: E000             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0152: E000             fMakeFile  EQU    16H                  ; makef	- Make File
0153: E000             fRenameFile EQU    17H                  ; renf	- Rename File
0154: E000             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0155: E000             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0156: E000             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0157: E000             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0158: E000         ;-----------------------------------------------------------------------
0159: E000
0160: E000
0161: E000
0162: E000
0163: E000
0164: E000         ;*******************************************************************************
0165: E000         ; These are the values handed over by the BDOS when it calls the Writer operation
0166: E000         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0167: E000         ; unallocated allocation block (it only indicates this for the first 128 byte
0168: E000         ; sector write) or to an allocation block that has already been allocated to a
0169: E000         ; file. The BDOS also indicates if it is set to write to the file directory
0170: E000         ;*******************************************************************************
0171: E000             WriteAllocated EQU    00H
0172: E000             WriteDirectory EQU    01H
0173: E000             WriteCleanBuffer EQU    02H
0174: E000
0175: E000
0176: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0177: E000                        Include ./diskHeader.Z80
0178: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0179: E000         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0180: E000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0181: E000         ; diskHeader.asm
0182: E000
0183: E000         ; 2017-03-02 Refactored the CP/M Suite
0184: E000
0185: E000         ; needs osHeader.asm declared before this is used !!!!!!!
0186: E000
0187: E000         ; Contains the Equates used by the CP/M system to handle disks
0188: E000
0189: E000
0190: E000         ;*******************************************************************************
0191: E000         ;
0192: E000         ;     Disk related values
0193: E000         ;
0194: E000         ;
0195: E000         ;*******************************************************************************
0196: E000             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0197: E000             DiskControlByte EQU    045H                 ; control byte for disk I/O
0198: E000             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0199: E000         ; for boot
0200: E000             DiskControlTable EQU    0040H
0201: E000
0202: E000             DiskReadCode EQU    01H                  ; Code for Read
0203: E000             DiskWriteCode EQU    02H                  ; Code for Write
0204: E000
0205: E000
0206: E000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0207: E000             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0208: E000             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0209: E000
0210: E000             DirEntrySize EQU    20H                  ; (32)
0211: E000             DirBuffSize EQU    cpmRecordSize
0212: E000
0213: E000             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0214: E000
0215: E000             RecordsPerExtent EQU    080H                 ; extent Record capacity
0216: E000
0217: E000
0218: E000         ;-------------------------------------------------------------------------------------
0219: E000             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0220: E000
0221: E000         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0222: E000             NumberOfHeads EQU    02H                  ; number of heads
0223: E000             TracksPerHead EQU    50H                  ; 80
0224: E000             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0225: E000             SectorsPerBlock EQU    04H                  ; 2048 bytes
0226: E000             DirectoryBlockCount EQU    02H                  ;
0227: E000         ;-----------------------------------------------------------------------
0228: E000
0229: E000             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0230: E000
0231: E000             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0232: E000
0233: E000             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0234: E000             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0235: E000             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0236: E000
0237: E000             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0238: E000             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0239: E000             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0240: E000             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0241: E000
0242: E000         ;-----------------------------------------------------------------------
0243: E000         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0244: E000         ;-----------------------------------------------------------------------
0245: E000         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0246: E000             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0247: E000             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0248: E000             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0249: E000             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0250: E000             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0251: E000             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0252: E000             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0253: E000             dpb3hdAL1  EQU    00H                  ;  for each file directory
0254: E000             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0255: E000             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0256: E000             dpb3hdNOH  EQU    NumberOfHeads
0257: E000
0258: E000         ;*******************************************************************************
0259: E000
0260: E000             SectorMask EQU    SectorsPerBlock - 1
0261: E000
0262: E000         ;***************************************************************************
0263: E000
0264: E000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0265: E000
0266: E000             BDOS       EQU    0005H                ; BDOS Vector in Page 00000
0267: E000
0268: E000             fcbSystemFileIndex EQU    0AH                  ; extent number field index
0269: E000             FILE_NAME_SIZE EQU    08H                  ; Max size of file Name
0270: E000             FILE_TYPE_SIZE EQU    03H                  ; Max size of file Type
0271: E000
0272: E000         ; ASCII_M					EQU    'M'
0273: E000         ; ASCII_O					EQU    'O'
0274: E000
0275: E000                        ORG    CCPEntry
0276: E000             CcpBoundary EQU    $
0277: E000         ;========================== CCP Entry ======================================;
0278: E000
0279: E000         ; 	JP		CcpStart						;start CCP with possible initial command
0280: E000         ;*****************************************************************
0281: E000         ;enter here from boot loader
0282: E000         ; On Entry	C(HiNibble) = User Number
0283: E000         ;			C(LoNibble) = Disk (0=A, 1=B...F=P)
0284: E000             CcpStart:
0285: E000 31 F0 E7               LD     SP,Stack             ; Set CCP's Stack
0286: E003 C5                     PUSH   BC                   ; Save Disk Number
0287: E004 59                     LD     E,C                  ; Get User Number
0288: E005 CB 3B                  SRL    E
0289: E007 CB 3B                  SRL    E                    ; Move user number
0290: E009 CB 3B                  SRL    E                    ;  to Lo Nibble
0291: E00B CB 3B                  SRL    E
0292: E00D CD 24 E6               CALL   SetUser              ; Set initial User
0293: E010         ; Initialize will completely reset the disk file system
0294: E010 CD E3 E5               CALL   Initialize           ; A = 0FFH if Submit file found
0295: E013 32 9D E2               LD     (submitFlag),A       ; Save return value in Flag
0296: E016 C1                     POP    BC                   ; Recall disk number
0297: E017 79                     LD     A,C                  ; Put into Acc
0298: E018 E6 0F                  AND    LO_NIBBLE_MASK       ; Remove User Number
0299: E01A 32 04 00               LD     (Pg0CurentDisk),A    ; Puts disk number into Page 0
0300: E01D CD E8 E5               CALL   SelectDisk           ; Set default Disk From Acc											; check for initial command
0301: E020 3A 1A E2               LD     A,(commandLength)
0302: E023 B7                     OR     A                    ; See if there is a Command
0303: E024 20 16                  JR     NZ,CcpParseCommand   ;  Skip if yes
0304: E026
0305: E026             ccpMainEntry:
0306: E026 31 F0 E7               LD     SP,Stack             ; (re)Establish CCP's Stack
0307: E029 CD 40 E6               CALL   PrintCrLf            ; Send CRLF to the Console
0308: E02C CD 1D E6               CALL   GetSelectedDrive     ; Get current disk number
0309: E02F C6 41                  ADD    A,ASCII_A            ; Make ASCII form of Drive
0310: E031 CD 35 E6               CALL   PrintCharInA         ; Send Drive letter to console
0311: E034 3E 3E                  LD     A,GREATER_THAN       ; Load '>'
0312: E036 CD 35 E6               CALL   PrintCharInA         ; Send to Console
0313: E039 CD 65 E0               CALL   ReadCommand          ; Command Buffer filled, Pointer set
0314: E03C
0315: E03C             CcpParseCommand:
0316: E03C 11 80 00               LD     DE,DMABuffer         ; Default in page 0
0317: E03F CD 18 E6               CALL   SetDMA               ; Set the DMA address
0318: E042 CD 1D E6               CALL   GetSelectedDrive     ; Get current drive
0319: E045 32 21 E7               LD     (currentDisk),A      ; Save
0320: E048 CD 21 E1               CALL   ParseToken1          ; Get first token in command buffer
0321: E04B C4 F5 E1               CALL   NZ,CommandError      ; The name must be unambiguous
0322: E04E 3A 1E E7               LD     A,(selectedDisk)     ; Get the Disk:
0323: E051 B7                     OR     A                    ; If not default,
0324: E052 C2 0A E5               JP     NZ,ccpUserCommand    ;   must be user CMD
0325: E055
0326: E055 CD D0 E1               CALL   IntrinsicFunction    ; Get CMD index into ACC
0327: E058 21 D6 E2               LD     HL,builtInCMDVector  ; Base of Vector
0328: E05B 5F                     LD     E,A
0329: E05C 16 00                  LD     D,0                  ; Index in DE
0330: E05E 19                     ADD    HL,DE
0331: E05F 19                     ADD    HL,DE                ; Vector is a word, need 2 ADDs
0332: E060 7E                     LD     A,(HL)               ; Pointing at Address
0333: E061 23                     INC    HL
0334: E062 66                     LD     H,(HL)
0335: E063 6F                     LD     L,A                  ; Get address to HL
0336: E064 E9                     JP     (HL)                 ;  Go to the Function
0337: E065
0338: E065
0339: E065         ;------------------------------ Read Command -------------------------------;
0340: E065         ;
0341: E065         ;read the next command into the command buffer                             ;
0342: E065         ;check for submit file                                                     ;
0343: E065             ReadCommand:                      ;
0344: E065 3A 9D E2               LD     A,(submitFlag)       ; Get the Submit File Flag          ;
0345: E068 B7                     OR     A                    ; Is it Set ?                       ;
0346: E069 28 54                  JR     Z,NotSubmitFile      ;  skip if not                      ;
0347: E06B         ; scanning a submit file change drives to open and read the file            ;
0348: E06B 3A 21 E7               LD     A,(currentDisk)      ; Get current disk                  ;
0349: E06E B7                     OR     A                    ; Is it default ?                   ;
0350: E06F 3E 00                  LD     A,0                  ; Prepare to set Disk A             ;
0351: E071 C4 E8 E5               CALL   NZ,SelectDisk        ; Select it if needed               ;
0352: E074         ; have to open again in case xsub present                                   ;
0353: E074 11 9E E2               LD     DE,submitFCB         ; Point at the Submits's FCB        ;
0354: E077 CD EE E5               CALL   OpenFile             ; Open it                           ;
0355: E07A 28 43                  JR     Z,NotSubmitFile      ; Skip if no submit file present    ;
0356: E07C 3A AC E2               LD     A,(submitRC)         ; Get Number of records in file     ;
0357: E07F 3D                     DEC    A                    ; read last record(s) first     ;
0358: E080 32 BD E2               LD     (submitCR),A         ; current record to read            ;
0359: E083 11 9E E2               LD     DE,submitFCB         ; Point at the Submits's FCB        ;
0360: E086 CD F8 E5               CALL   DiskRead             ; Read from back to front           ;
0361: E089 20 34                  JR     NZ,NotSubmitFile     ; Skip EOF ??                       ;
0362: E08B         ;
0363: E08B         ; disk read is OK, transfer to commandBuffer                                ;
0364: E08B 21 80 00               LD     HL,DMABuffer         ; From                              ;
0365: E08E 11 1A E2               LD     DE,commandLength     ; TO	                            ;
0366: E091 01 80 00               LD     BC,cpmRecordSize     ; For this many bytes               ;
0367: E094 ED B0                  LDIR                        ; Move to command buffer            ;
0368: E096         ;
0369: E096         ; line is transferred, close the file with a deleted record                 ;
0370: E096 21 AB E2               LD     HL,submitFWF         ; Point at the WriteFileFlag        ;
0371: E099 CB BE                  RES    7,(HL)               ; Clear the WriteFileFlag                   ;
0372: E09B         ;	LD		HL,submitFWF				; Bit 7 is FileWriteFlag            ;
0373: E09B         ;	LD		(HL),0						                                    ;
0374: E09B         ;	INC		HL                                                              ;
0375: E09B 21 AC E2               LD     HL,submitRC          ; Point at FCB record Count         ;
0376: E09E 35                     DEC    M                    ; Make it one less record           ;
0377: E09F 11 9E E2               LD     DE,submitFCB         ; Point at the Submits's FCB        ;
0378: E0A2 CD F3 E5               CALL   CloseFile            ; Close it                          ;
0379: E0A5 28 18                  JR     Z,NotSubmitFile      ; Skip if not clean close           ;
0380: E0A7         ; CloseFile went ok, return to original drive                               ;
0381: E0A7 3A 21 E7               LD     A,(currentDisk)      ; Get the current disk              ;
0382: E0AA B7                     OR     A                    ; Is it the default disk ?          ;
0383: E0AB C4 E8 E5               CALL   NZ,SelectDisk        ;  no, then go select it            ;
0384: E0AE         ; print to the 00                                                           ;
0385: E0AE 21 1B E2               LD     HL,commandBuffer     ; Point at the command buffer       ;
0386: E0B1 CD 56 E6               CALL   PrintStringNull      ; Display it on the Console         ;
0387: E0B4 CD 6E E6               CALL   CheckForConsoleChar  ; User input a character ?          ;
0388: E0B7 28 17                  JR     Z,NoRead             ;  skip if not                      ;
0389: E0B9 CD EE E0               CALL   DeleteSubmitFile     ; Remove file and reset submit flag ;
0390: E0BC C3 26 E0               JP     ccpMainEntry         ; Start a new CCP session           ;
0391: E0BF         ;   ---     ------------                ;-----------------------------------;
0392: E0BF             NotSubmitFile:                      ;
0393: E0BF CD EE E0               CALL   DeleteSubmitFile     ; Delete any submit file            ;
0394: E0C2 CD 06 E1               CALL   SaveUserAndDisk      ; Save User & Disk to page 0        ;
0395: E0C5 11 19 E2               LD     DE,commandMaxLength  ; Point to Start of Buffer          ;
0396: E0C8 0E 0A                  LD     C,fReadString        ; Load Function Number	            ;
0397: E0CA CD 05 00               CALL   BDOS                 ;  and let BDOS do its work	        ;
0398: E0CD CD 15 E1               CALL   SetPage0CurDisk      ; No Cntl C, so restore Pg0CurentDis;
0399: E0D0         ;
0400: E0D0             NoRead:                         ;
0401: E0D0         ; set the last character to zero for later scans                            ;
0402: E0D0 21 1A E2               LD     HL,commandLength     ; Point to length of command        ;
0403: E0D3 46                     LD     B,(HL)               ; Put it into B                     ;
0404: E0D4             UpCaseLoop:                      ;
0405: E0D4 23                     INC    HL                   ; Point at next byte in buffer      ;
0406: E0D5 7E                     LD     A,(HL)               ; Get the Character                 ;
0407: E0D6 CD E5 E0               CALL   UpCase               ; If between a-z, up-case it        ;
0408: E0D9 77                     LD     (HL),A               ; Replace character                 ;
0409: E0DA 10 F8                  DJNZ   UpCaseLoop           ; go thru all of the CMD buffer     ;
0410: E0DC         ;end of scan, h,l address end of command                                    ;
0411: E0DC         ;ReadCommand2:                                                              ;
0412: E0DC 23                     INC    HL                   ; Point at last char + 1            ;
0413: E0DD 70                     LD     (HL),B               ; Stuff Zero to terminate the CMD   ;
0414: E0DE 21 1B E2               LD     HL,commandBuffer     ; go back to start of com           ;
0415: E0E1 22 9B E2               LD     (commandBufferPointer),HL ; Place in current CMD address      ;
0416: E0E4 C9                     RET                         ;
0417: E0E5         ;------------------------------ Read Command -------------------------------;
0418: E0E5
0419: E0E5         ;--------------------------------- UpCase ----------------------------------;
0420: E0E5         ;convert character in register A (a to z) to upper case                     ;
0421: E0E5             UpCase:                         ;
0422: E0E5 FE 61                  CP     061H                 ;
0423: E0E7 D8                     RET    C                    ; Return if below lower case 'a'    ;
0424: E0E8 FE 7B                  CP     07BH                 ;
0425: E0EA D0                     RET    NC                   ; Return if above lower case 'z'    ;
0426: E0EB E6 5F                  AND    05FH                 ; Drop bit 5/ makes q->Q etc        ;
0427: E0ED C9                     RET                         ;
0428: E0EE         ;--------------------------------- UpCase ----------------------------------;
0429: E0EE         ;---------------------------- Delete SubmitFile ----------------------------;
0430: E0EE         ;delete the submit file, and set submit flag to false                       ;
0431: E0EE             DeleteSubmitFile:                      ;
0432: E0EE 21 9D E2               LD     HL,submitFlag        ; Point at Submit flag              ;
0433: E0F1 7E                     LD     A,(HL)               ; Get the Flag                      ;
0434: E0F2 B7                     OR     A                    ; Is it Set ?                       ;
0435: E0F3 C8                     RET    Z                    ;  return if not set                ;
0436: E0F4 36 00                  LD     (HL),0               ; Clear Flag                        ;
0437: E0F6 AF                     XOR    A                    ; Drive 0 = A:                      ;
0438: E0F7 CD E8 E5               CALL   SelectDisk           ; Select drive                      ;
0439: E0FA 11 9E E2               LD     DE,submitFCB         ; Load the submits FCB              ;
0440: E0FD CD FF E5               CALL   DeleteFile           ; Go delete it                      ;
0441: E100 3A 21 E7               LD     A,(currentDisk)      ; Determine the current disk        ;
0442: E103 C3 E8 E5               JP     SelectDisk           ; Reselect back to original drive   ;
0443: E106         ;---------------------------- Delete SubmitFile ----------------------------;
0444: E106         ;-------------------------------- Save User --------------------------------;
0445: E106         ;save user#/disk# before possible ^c or transient                           ;
0446: E106             SaveUserAndDisk:                      ;
0447: E106 CD 22 E6               CALL   GetUser              ; Get the user number into Acc      ;
0448: E109 87                     ADD    A,A                  ;
0449: E10A 87                     ADD    A,A                  ;
0450: E10B 87                     ADD    A,A                  ;
0451: E10C 87                     ADD    A,A                  ; Move user to Hi Nibble            ;
0452: E10D 21 21 E7               LD     HL,currentDisk       ; Current disk (Lo Nibble)          ;
0453: E110 B6                     OR     M                    ; Acc -> User & Disk                ;
0454: E111 32 04 00               LD     (Pg0CurentDisk),A    ; Stored in Page0 for later         ;
0455: E114 C9                     RET                         ;
0456: E115         ;-------------------------------- Save User --------------------------------;
0457: E115         ;------------------------- Set Page 0 Current Disk -------------------------;
0458: E115         ;set Pg0CurentDisk to current disk                                          ;
0459: E115             SetPage0CurDisk:                      ;
0460: E115 3A 21 E7               LD     A,(currentDisk)      ; Get CCP's current disk            ;
0461: E118 32 04 00               LD     (Pg0CurentDisk),A    ; Put into Page 0	                ;
0462: E11B C9                     RET                         ;
0463: E11C         ;------------------------- Set Page 0 Current Disk -------------------------;
0464: E11C
0465: E11C         ;--------------------------------- Parse Token -----------------------------;
0466: E11C         ; Parse command buffer.                                                     ;
0467: E11C         ; Used to isolate the command                                               ;
0468: E11C         ;
0469: E11C             ParseToken2:                      ;
0470: E11C 21 0D E7               LD     HL,Token2            ; Point at Token2 start             ;
0471: E11F 18 03                  JR     ParseToken           ;
0472: E121             ParseToken1:                      ;
0473: E121 21 FD E6               LD     HL,Token1            ; Point at Token1 start             ;
0474: E124             ParseToken:                      ;
0475: E124 E5                     PUSH   HL                   ; Start of Token's Pointer          ;
0476: E125 E5                     PUSH   HL                   ; Start of Token's Pointer          ;
0477: E126 AF                     XOR    A                    ; Set A to 0                        ;
0478: E127 32 1E E7               LD     (selectedDisk),A     ; Assume default disk               ;
0479: E12A 2A 9B E2               LD     HL,(commandBufferPointer) ; Buffer's Pointer                  ;
0480: E12D CD A8 E1               CALL   NextNonBlankChar     ; Get printable character			;
0481: E130 22 1F E7               LD     (tokenStart),HL      ; Save token's address              ;
0482: E133 EB                     EX     DE,HL                ; DE -> Buffer                      ;
0483: E134 E1                     POP    HL                   ; DE -> Buffer,                     ;
0484: E135         ;  HL -> Start of Token's Pointer   ;
0485: E135         ; Disk ?                                                                    ;
0486: E135 1A                     LD     A,(DE)               ; Get 1st character from buffer     ;
0487: E136 B7                     OR     A                    ; Is it the default Disk ?          ;
0488: E137 28 0A                  JR     Z,UseCurrentDisk     ; Use current disk if empty         ;
0489: E139 DE 40                  SBC    A,040H               ; Convert to number                 ;
0490: E13B 47                     LD     B,A                  ; Hold disk number in B             ;
0491: E13C 13                     INC    DE                   ;
0492: E13D 1A                     LD     A,(DE)               ; Look at next character            ;
0493: E13E FE 3A                  CP     COLON                ; Is it a ':' ?                     ;
0494: E140 28 08                  JR     Z,UseTokensDisk      ;  if yes, set disk number          ;
0495: E142         ; No Disk                                                                   ;
0496: E142 1B                     DEC    DE                   ; Back to start of buffer           ;
0497: E143         ;
0498: E143             UseCurrentDisk:                      ;
0499: E143 3A 21 E7               LD     A,(currentDisk)      ; Get current Disk                  ;
0500: E146 77                     LD     (HL),A               ; Put into the Token                ;
0501: E147 C3 50 E1               JP     SetFileName          ;
0502: E14A         ;
0503: E14A             UseTokensDisk:                      ;
0504: E14A 78                     LD     A,B                  ; Get disk from this parse          ;
0505: E14B 32 1E E7               LD     (selectedDisk),A     ; Mark as disk selected             ;
0506: E14E 70                     LD     (HL),B               ; Put it into the token             ;
0507: E14F 13                     INC    DE                   ; Move past the ':'                 ;
0508: E150         ;
0509: E150             SetFileName:                      ;
0510: E150 06 08                  LD     B,FILE_NAME_SIZE     ; File name length (max)            ;
0511: E152 CD 78 E1               CALL   FormatElement        ; Format file name                  ;
0512: E155         ;
0513: E155             SetType:                        ;
0514: E155 06 03                  LD     B,FILE_TYPE_SIZE     ; File type length (max)            ;
0515: E157 CD 95 E1               CALL   IsItDot              ; is it a '.' ?	                    ;
0516: E15A CC 78 E1               CALL   Z,FormatElement      ;  Yes,Format it                    ;
0517: E15D         ;
0518: E15D         ; Zero Rest of token                                                        ;
0519: E15D 06 03                  LD     B,3                  ;
0520: E15F AF                     XOR    A                    ;
0521: E160 CD A3 E1               CALL   FillWithAcc          ;
0522: E163 EB                     EX     DE,HL                ;
0523: E164 22 9B E2               LD     (commandBufferPointer),HL ; Set new starting point	        ;
0524: E167         ; Recover the start address of the FCB and count ?'s                        ;
0525: E167 E1                     POP    HL                   ; Restore start of Token            ;
0526: E168 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Loop size                   ;
0527: E16A 0E 00                  LD     C,00                 ; Counter                           ;
0528: E16C 3E 3F                  LD     A,QMARK              ; We want to count '?'s             ;
0529: E16E             QuestionMarkCount:                      ;
0530: E16E 23                     INC    HL                   ; Adjust token pointer				;
0531: E16F BE                     CP     (HL)                 ; Is it a '?'                       ;
0532: E170 20 01                  JR     NZ,QuestionMarkCount1 ;  no, then skip                    ;
0533: E172 0C                     INC    C                    ;  else increment the count         ;
0534: E173             QuestionMarkCount1:                      ;
0535: E173 10 F9                  DJNZ   QuestionMarkCount    ; Manage the Loop	                ;
0536: E175 79                     LD     A,C                  ;
0537: E176 B7                     OR     A                    ;
0538: E177 C9                     RET                         ;
0539: E178         ;-------------------------------- Parse Token ------------------------------;
0540: E178         ;------------------------------- Format Element ----------------------------;
0541: E178         ; Put element in a Left Justified, Space Padded field.                      ;
0542: E178         ; If it encounters an asterisk, it will pad the rest of the field with '?'s ;
0543: E178         ; Enter With:	B  = Element size                                           ;
0544: E178         ;				DE = Element source                                         ;
0545: E178         ;				HL = Element destination                                    ;
0546: E178             FormatElement:                      ;
0547: E178 CD B1 E1               CALL   IsItADelimiter       ; Is character a delimiter ?        ;
0548: E17B 28 14                  JR     Z,PadTheElement      ;  yes, pad rest of Element         ;
0549: E17D         ;
0550: E17D 23                     INC    HL                   ;  else move the Token's pointer    ;
0551: E17E FE 2A                  CP     ASTERISK             ; Is it an '*'					    ;
0552: E180 20 04                  JR     NZ,FormatElement1    ;  no, then just put in Token   ;
0553: E182 36 3F                  LD     (HL),QMARK           ;  else Put a '?' in token          ;
0554: E184 18 02                  JR     FormatElement2       ;  for rest of Element              ;
0555: E186         ;
0556: E186             FormatElement1:                      ;
0557: E186 77                     LD     (HL),A               ; Put character in token            ;
0558: E187 13                     INC    DE                   ; Increment the buffer pointer      ;
0559: E188             FormatElement2:                      ;
0560: E188 10 EE                  DJNZ   FormatElement        ; Loop if more                      ;
0561: E18A         ;
0562: E18A             TruncateElement:                      ;
0563: E18A CD B1 E1               CALL   IsItADelimiter       ; We expect a delimiter             ;
0564: E18D C8                     RET    Z                    ; If we get one, we are done        ;
0565: E18E 13                     INC    DE                   ;  skip forward in buffer           ;
0566: E18F 18 F9                  JR     TruncateElement      ; Keep looking for delimiter        ;
0567: E191         ;
0568: E191             PadTheElement:                      ;
0569: E191 CD A1 E1               CALL   FillWithSpace        ; Pad the rest of Element           ;
0570: E194 C9                     RET                         ;
0571: E195         ;------------------------------- Format Element ----------------------------;
0572: E195         ;-------------------------------- Is It a Dot ------------------------------;
0573: E195         ; Check to see if char is buffer is a period. If it is it returns with      ;
0574: E195         ; the Z-Flag set., and the DE pointer advanced beyond the '.'.  If it is    ;
0575: E195         ; not a period. It will fill the buffer with spaces and return with the     ;
0576: E195         ; Z-Flag reset.                                                             ;
0577: E195         ;                                                                           ;
0578: E195         ; Enter With:	DE = Pointer for buffer                                     ;
0579: E195         ;				 B = buffer size	                                        ;
0580: E195         ; Return With:	DE = Past the period                                        ;
0581: E195         ;			   	Z-Flag =  set if Period                                     ;
0582: E195         ;  				Z-Flag = reset if not Period                                ;
0583: E195             IsItDot:                        ;
0584: E195 1A                     LD     A,(DE)               ;
0585: E196 13                     INC    DE                   ; Assume it is a '.'                ;
0586: E197 FE 2E                  CP     PERIOD               ; Is it '.' ?                       ;
0587: E199 C8                     RET    Z                    ;  if yes exit with Z-Flag set      ;
0588: E19A         ;
0589: E19A 1B                     DEC    DE                   ; Adjust, wrong assumption          ;
0590: E19B CD A1 E1               CALL   FillWithSpace        ;  else make all spaces             ;
0591: E19E AF                     XOR    A                    ;
0592: E19F 3C                     INC    A                    ; Reset the Z-Flag                  ;
0593: E1A0 C9                     RET                         ; Exit with Z-Flag reset            ;
0594: E1A1         ;-------------------------------- Is It a Dot ------------------------------;
0595: E1A1         ;-------------------------- Fill With Space/Acc ----------------------------;
0596: E1A1         ; fills buffer with SPACE or contents of Acc.                               ;
0597: E1A1         ; Enters with:	HL = less than start of fill area                           ;
0598: E1A1         ;				B  = fill Count                                             ;
0599: E1A1         ;				A  = fill character (FillWithAcc)                           ;
0600: E1A1             FillWithSpace:                      ;
0601: E1A1 3E 20                  LD     A,SPACE              ;
0602: E1A3             FillWithAcc:                      ;
0603: E1A3 23                     INC    HL                   ;
0604: E1A4 77                     LD     (HL),A               ;
0605: E1A5 10 FC                  DJNZ   FillWithAcc          ;
0606: E1A7 C9                     RET                         ;
0607: E1A8         ;-------------------------- Fill With Space/Acc ----------------------------;
0608: E1A8         ;------------------------ Next Non Blank Character -------------------------;
0609: E1A8         ;find the next non blank character in line pointed to by DE                 ;
0610: E1A8             NextNonBlankChar:                      ;
0611: E1A8 7E                     LD     A,(HL)               ; Get the character                 ;
0612: E1A9 B7                     OR     A                    ; Is it End of buffer ?             ;
0613: E1AA C8                     RET    Z                    ;  if yes, return                   ;
0614: E1AB FE 20                  CP     SPACE                ; is it a blank ?                   ;
0615: E1AD C0                     RET    NZ                   ;  if not, return                   ;
0616: E1AE 23                     INC    HL                   ;  else increment pointer           ;
0617: E1AF 18 F7                  JR     NextNonBlankChar     ; Loop for next character           ;
0618: E1B1         ;------------------------ Next Non Blank Character -------------------------;
0619: E1B1         ;---------------------------- Is It A Delimiter ----------------------------;
0620: E1B1         ; Returns with Z-flag set if (DE) pointing at a delimiter                   ;
0621: E1B1         ; Does an error exit if not valid ASCII character                           ;
0622: E1B1             IsItADelimiter:                      ;
0623: E1B1 1A                     LD     A,(DE)               ; Get the character                 ;
0624: E1B2 B7                     OR     A                    ;
0625: E1B3 C8                     RET    Z                    ; End of Buffer is a delimiter      ;
0626: E1B4 FE 20                  CP     SPACE                ;
0627: E1B6 DA F5 E1               JP     C,CommandError       ; Error exit if not ASCII           ;
0628: E1B9 C8                     RET    Z                    ; SPACE is a delimiter              ;
0629: E1BA FE 3D                  CP     EQUAL_SIGN           ;
0630: E1BC C8                     RET    Z                    ; '=' is a delimiter                ;
0631: E1BD FE 5F                  CP     UNDER_SCORE          ;
0632: E1BF C8                     RET    Z                    ; '_' is a delimiter                ;
0633: E1C0 FE 2E                  CP     PERIOD               ;
0634: E1C2 C8                     RET    Z                    ; '.' is a delimiter                ;
0635: E1C3 FE 3A                  CP     COLON                ;
0636: E1C5 C8                     RET    Z                    ; ':' is a delimiter                ;
0637: E1C6 FE 3B                  CP     SEMICOLON            ;
0638: E1C8 C8                     RET    Z                    ; ';' is a delimiter                ;
0639: E1C9 FE 3C                  CP     LESS_THAN            ;
0640: E1CB C8                     RET    Z                    ; '<' is a delimiter                ;
0641: E1CC FE 3E                  CP     GREATER_THAN         ;
0642: E1CE C8                     RET    Z                    ; '>' is a delimiter                ;
0643: E1CF C9                     RET                         ; Not a delimiter                   ;
0644: E1D0         ;---------------------------- Is It A Delimiter ----------------------------;
0645: E1D0
0646: E1D0         ;---------------------------- Intrinsic Function ---------------------------;
0647: E1D0         ;look for intrinsic functions (Token1 has been filled)                 		;
0648: E1D0             IntrinsicFunction:                      ;
0649: E1D0 21 BE E2               LD     HL,builtInCMDNames   ; Point at List of CMDs             ;
0650: E1D3 0E 00                  LD     C,0                  ; Initialize counter                ;
0651: E1D5             IntrinsicFunction1:                      ;
0652: E1D5 79                     LD     A,C                  ; Get Counter                       ;
0653: E1D6 FE 06                  CP     builtInCMDCount      ; Past number of commands ?         ;
0654: E1D8 D0                     RET    NC                   ;  exit if yes                      ;
0655: E1D9 11 FE E6               LD     DE,Token1+1          ; Beginning of name                 	;
0656: E1DC 06 04                  LD     B,builtInCMDNameSize ; Length of match                   ;
0657: E1DE             IntrinsicFunction2:                      ;
0658: E1DE 1A                     LD     A,(DE)               ;
0659: E1DF BE                     CP     M                    ; Is there a match ?                ;
0660: E1E0 20 0C                  JR     NZ,IntrinsicFunction3 ;  skip if no match                 ;
0661: E1E2 13                     INC    DE                   ;
0662: E1E3 23                     INC    HL                   ; Point at next characters          ;
0663: E1E4 05                     DEC    B                    ; Decrement the counter             ;
0664: E1E5 20 F7                  JR     NZ,IntrinsicFunction2 ; Loop while matching               ;
0665: E1E7         ; complete match on name, check for blank in FCB                            ;
0666: E1E7 1A                     LD     A,(DE)               ;
0667: E1E8 FE 20                  CP     SPACE                ; Blank in CMD ?                    ;
0668: E1EA 20 06                  JR     NZ,IntrinsicFunction4 ;  No ,then no match                ;
0669: E1EC 79                     LD     A,C                  ;  Else they match,                 ;
0670: E1ED C9                     RET                         ; Return with index in A            ;
0671: E1EE         ;
0672: E1EE             IntrinsicFunction3:                      ;
0673: E1EE 23                     INC    HL                   ; Move to next in list              ;
0674: E1EF 05                     DEC    B                    ;
0675: E1F0 20 FC                  JR     NZ,IntrinsicFunction3 ; Loop thru this one                ;
0676: E1F2         ;
0677: E1F2             IntrinsicFunction4:                      ;
0678: E1F2 0C                     INC    C                    ; Update the index                  ;
0679: E1F3 18 E0                  JR     IntrinsicFunction1   ;  loop for another round           ;
0680: E1F5         ;---------------------------- Intrinsic Function ---------------------------;
0681: E1F5
0682: E1F5         ; cmd
0683: E1F5         ;------------------------------ Command Error ------------------------------;
0684: E1F5         ;error in command string starting at position;'tokenStart' and ending    	;
0685: E1F5         ; with first delimiter                                                      ;
0686: E1F5         ;
0687: E1F5             CommandError:                      ;
0688: E1F5 CD 40 E6               CALL   PrintCrLf            ; Next Line                     ;
0689: E1F8 2A 1F E7               LD     HL,(tokenStart)      ; Start of error token             		;
0690: E1FB             CommandErrorLoop:                      ;
0691: E1FB 7E                     LD     A,(HL)               ; Get character                     ;
0692: E1FC FE 20                  CP     SPACE                ; Past offending token ?            ;
0693: E1FE 28 0B                  JR     Z,CommandErrorExit   ;  done if yes                      ;
0694: E200 B7                     OR     A                    ; At end of command ?               ;
0695: E201 28 08                  JR     Z,CommandErrorExit   ;  done if yes                      ;
0696: E203 E5                     PUSH   HL                   ; Save pointer                      ;
0697: E204 CD 35 E6               CALL   PrintCharInA         ; Display on console                ;
0698: E207 E1                     POP    HL                   ; Restore pointer                   ;
0699: E208 23                     INC    HL                   ; Update it                         ;
0700: E209 18 F0                  JR     CommandErrorLoop     ; Keep going                        ;
0701: E20B         ;
0702: E20B             CommandErrorExit:                      ;
0703: E20B 3E 3F                  LD     A,QMARK              ;
0704: E20D CD 35 E6               CALL   PrintCharInA         ; Send '?' to console               ;
0705: E210 CD 40 E6               CALL   PrintCrLf            ; Next Line                     ;
0706: E213 CD EE E0               CALL   DeleteSubmitFile     ; Remove any submit file            ;
0707: E216 C3 26 E0               JP     ccpMainEntry         ; Go back for another command       ;
0708: E219         ;------------------------------ Command Error ------------------------------;
0709: E219
0710: E219         ;------------------------------ Command Buffer -----------------------------;
0711: E219             maximumBufferSize EQU    07FH                 ; Max Length of Buffer          ;
0712: E219 7F          commandMaxLength: DB     maximumBufferSize    ;
0713: E21A 00          commandLength: DB     00H                  ; Actual size of input          ;
0714: E21B             commandBuffer: DS     maximumBufferSize + 1 ; The Command Buffer           ;
0715: E29B         ;
0716: E29B 1B E2       commandBufferPointer: DW     commandBuffer        ; Address of next to char       ;
0717: E29D         ;------------------------------ Command Buffer -----------------------------;
0718: E29D         ;------------------------- Submit File Control Block -----------------------;
0719: E29D         ;	                                                                        ;
0720: E29D 00          submitFlag: DB     00H                  ; 00 if no submit file,             ;
0721: E29E         ;  0FFH if submitting               ;
0722: E29E 24 24 24 20 20 20 20 20     submitFCB: DB     '$$$     '           ; File name is $$$                  ;
0723: E2A6 53 55 42     submitType: DB     'SUB'                ; Type is 'SUB'                     ;
0724: E2A9 00          submitExtent: DB     00H                  ; Extent                            ;
0725: E2AA 00          submitS1:  DB     00H                  ; S1                                ;
0726: E2AB             submitFWF:                      ; Bit7 = FileWriteFlag
0727: E2AB 00          submitS2:  DB     00H                  ; S2 (bit7 = FileWriteFlag)         ;
0728: E2AC 00          submitRC:  DB     00H                  ; RC                                ;
0729: E2AD             submitMap: DS     010H                 ; Allocation Map                    ;
0730: E2BD 00          submitCR:  DB     00H                  ; Current Record                    ;
0731: E2BE         ;------------------------- Submit File Control Block -----------------------;
0732: E2BE         ;--------------------------- Built In Command Data -------------------------;
0733: E2BE         ;intrinsic function names four characters each                              ;
0734: E2BE             builtInCMDNameSize EQU    04                   ; Size of intrinsic function names  ;
0735: E2BE         ;
0736: E2BE             builtInCMDNames:                      ;
0737: E2BE 44 49 52 20                DB     'DIR '               ;
0738: E2C2 45 52 41 20                DB     'ERA '               ;
0739: E2C6 54 59 50 45                DB     'TYPE'               ;
0740: E2CA 53 41 56 45                DB     'SAVE'               ;
0741: E2CE 52 45 4E 20                DB     'REN '               ;
0742: E2D2 55 53 45 52                DB     'USER'               ;
0743: E2D6             builtInCMDCount EQU    (($-builtInCMDNames)/builtInCMDNameSize) + 1 ;
0744: E2D6         ;
0745: E2D6             builtInCMDVector:                      ;
0746: E2D6 E4 E2                  DW     ccpDirectory         ; Directory List                    ;
0747: E2D8 77 E3                  DW     ccpErase             ; File erase                        ;
0748: E2DA A7 E4                  DW     ccpType              ; Type file on Console              ;
0749: E2DC 29 E4                  DW     ccpSave              ; Save memory image                 ;
0750: E2DE B4 E3                  DW     ccpRename            ; File rename                       ;
0751: E2E0 F3 E4                  DW     ccpUser              ; User number                       ;
0752: E2E2 0A E5                  DW     ccpUserCommand       ; User-defined function             ;
0753: E2E4         ;
0754: E2E4         ;--------------------------- Built In Command Data -------------------------;
0755: E2E4
0756: E2E4         ;===========================================================================;
0757: E2E4         ;============================== CCP Commands ===============================;
0758: E2E4         ;===========================================================================;
0759: E2E4
0760: E2E4         ;----------------------------- Directory Listing ---------------------------;
0761: E2E4         ; SYNTAX: DIR afn                                                           ;
0762: E2E4         ;                                                                           ;
0763: E2E4         ;  The 'DIR' command causes the names of all the files that satisfy the     ;
0764: E2E4         ; ambiguous filename afn to be listed on the console device                 ;
0765: E2E4         ;                                                                           ;
0766: E2E4             ccpDirectory:                      ;
0767: E2E4 CD 21 E1               CALL   ParseToken1          ; Token1 gets file name             ;
0768: E2E7 CD 7C E6               CALL   SetDiskForCmd        ; Change disk if needed             ;
0769: E2EA 21 FE E6               LD     HL,Token1+1          ; Point at 1st char of parameter    ;
0770: E2ED 7E                     LD     A,(HL)               ; Get the value                     ;
0771: E2EE FE 20                  CP     SPACE                ; Is it Blank ?                     ;
0772: E2F0 20 07                  JR     NZ,ccpDirQualified   ;  skip there is a parameter        ;
0773: E2F2         ;
0774: E2F2         ; set Token1 to all ??? for current disk                                    ;
0775: E2F2 06 0B                  LD     B,FILE_NAME_SIZE+FILE_TYPE_SIZE ; Set Limit	                ;
0776: E2F4             ccpDirAll:                      ;
0777: E2F4 36 3F                  LD     (HL),QMARK           ; Put '?' in Token                  ;
0778: E2F6 23                     INC    HL                   ; Increment pointer                 ;
0779: E2F7 10 FB                  DJNZ   ccpDirAll            ; Loop till done                    ;
0780: E2F9         ;
0781: E2F9             ccpDirQualified:                      ;
0782: E2F9 AF                     XOR    A                    ; Set Acc to 0                      ;
0783: E2FA 32 75 E3               LD     (dirFileCount),A     ; Initialize File Count             ;
0784: E2FD         ;	LD		(dirCharCount),A			; Initialize char count             ;
0785: E2FD CD E3 E6               CALL   FindFirstToken1File  ; Look for directory entry          ;
0786: E300 CC 61 E6               CALL   Z,PrintNoFile        ;  if not found send message        ;
0787: E303         ;
0788: E303             ccpDirLoopTop:                      ;
0789: E303 28 6D                  JR     Z,ccpDirEnd          ; Exit if directory exhausted       ;
0790: E305         ; found, but may be system file                                             ;
0791: E305 3A 22 E7               LD     A,(directoryEntryNumber) ; Get directory entry number        ;
0792: E308 0F                     RRCA                        ;
0793: E309 0F                     RRCA                        ;
0794: E30A 0F                     RRCA                        ; Multiply by 20H                   ;
0795: E30B 4F                     LD     C,A                  ;
0796: E30C 06 00                  LD     B,0                  ; BC has index into Dir Buffer      ;
0797: E30E DD 21 80 00               LD     IX,DMABuffer         ;
0798: E312 DD 09                  ADD    IX,BC                ; IX Points at the Dir Entry        ;
0799: E314 DD CB 0A 7E               BIT    7,(IX+fcbSystemFileIndex) ; Is this a System File             ;
0800: E318 20 4C                  JR     NZ,ccpDirLoopBottom  ;  if yes, Skip to next iteration   ;
0801: E31A         ;
0802: E31A DD E5                  PUSH   IX                   ; IX Points at the Dir Entry        ;
0803: E31C AF                     XOR    A                    ;
0804: E31D 32 76 E3               LD     (dirCharCount),A     ; Initialize char count             ;
0805: E320         ;
0806: E320 21 75 E3               LD     HL,dirFileCount      ; Point at dirFileCount             ;
0807: E323 7E                     LD     A,(HL)               ; Get the dirFileCount              ;
0808: E324 34                     INC    (HL)                 ; Increment dirFileCount            ;
0809: E325 E6 03                  AND    11B                  ; Perform Mod(E,4)                  ;
0810: E327 20 14                  JR     NZ,ccpDirDisplayFile0 ; Skip header if not 0              ;
0811: E329         ;
0812: E329         ; print the header: new Line followed by drive with Colon - A :             ;
0813: E329 CD 40 E6               CALL   PrintCrLf            ; New Line                      ;
0814: E32C C5                     PUSH   BC                   ;
0815: E32D CD 1D E6               CALL   GetSelectedDrive     ; Get Active drive number           ;
0816: E330 C1                     POP    BC                   ;
0817: E331 C6 41                  ADD    A,ASCII_A            ; Make it ASCII                     ;
0818: E333 CD 35 E6               CALL   PrintCharInA         ; Send it to the console        ;
0819: E336 3E 3A                  LD     A,COLON              ;
0820: E338 CD 35 E6               CALL   PrintCharInA         ; Send ':' to the console        ;
0821: E33B 18 08                  JR     ccpDirDisplayFile    ; Skip ':' display                  ;
0822: E33D         ;
0823: E33D             ccpDirDisplayFile0:                      ;
0824: E33D CD 31 E6               CALL   PrintSpace           ; Send Space to console             ;
0825: E340 3E 3A                  LD     A,COLON              ;
0826: E342 CD 35 E6               CALL   PrintCharInA         ; Send ':' to the console		;
0827: E345             ccpDirDisplayFile:                      ;
0828: E345 CD 31 E6               CALL   PrintSpace           ; Send Space to console             ;
0829: E348         ;
0830: E348             ccpDirDisplayFileLoop:                      ;
0831: E348 DD E1                  POP    IX                   ; Get to Dir Entry Pointer          ;
0832: E34A DD 7E 00               LD     A,(IX+0)             ; Put char in ACC                   ;
0833: E34D DD 23                  INC    IX                   ; Adjust pointer for next iteration ;
0834: E34F DD E5                  PUSH   IX                   ; Save till then                    ;
0835: E351 E6 7F                  AND    ASCII_MASK           ; Make sure char is ASCII           ;
0836: E353 CD 35 E6               CALL   PrintCharInA         ; Send it to the console            ;
0837: E356 21 76 E3               LD     HL,dirCharCount      ; Where are we in Token ?           ;
0838: E359 7E                     LD     A,(HL)               ; Get index                         ;
0839: E35A 34                     INC    (HL)                 ; Update for next time              ;
0840: E35B 47                     LD     B,A                  ; Save count                        ;
0841: E35C FE 08                  CP     8                    ; End of Name ?                     ;
0842: E35E CC 31 E6               CALL   Z,PrintSpace         ; Separate Name and Type            ;
0843: E361 78                     LD     A,B                  ; Retrieve count                    ;
0844: E362 FE 0B                  CP     11                   ; At the end of this dir entry ?    ;
0845: E364 20 E2                  JR     NZ,ccpDirDisplayFileLoop ;  if no continue the iteration     ;
0846: E366         ;
0847: E366             ccpDirLoopBottom:                      ;
0848: E366 DD E1                  POP    IX                   ; Balance stack                     ;
0849: E368 CD 6E E6               CALL   CheckForConsoleChar  ; Interrupt at keyboard ?           ;
0850: E36B 20 05                  JR     NZ,ccpDirEnd         ;  yes, abort directory search      ;
0851: E36D CD EE E6               CALL   SearchForNext        ; Look for more entries             ;
0852: E370 18 91                  JR     ccpDirLoopTop        ;  and loop thru                    ;
0853: E372             ccpDirEnd:                      ;
0854: E372 C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Wrap up and start over            ;
0855: E375         ;
0856: E375             dirFileCount:                      ;
0857: E375 00                     DB     0                    ;
0858: E376             dirCharCount:                      ;
0859: E376 00                     DB     0                    ;
0860: E377         ;----------------------------- Directory Listing ---------------------------;
0861: E377
0862: E377         ;-------------------------------- Erase Files ------------------------------;
0863: E377         ; SYNTAX: ERA afn                                                           ;
0864: E377         ;                                                                           ;
0865: E377         ;  The 'ERA' command removes files from the currently logged-in disk. The   ;
0866: E377         ; files that are erased are those that satisfy the ambiguous filename       ;
0867: E377         ; reference afn.                                                            ;
0868: E377         ;                                                                           ;
0869: E377             ccpErase:                       ;
0870: E377 CD 21 E1               CALL   ParseToken1          ; Parse the command                 ;
0871: E37A FE 0B                  CP     FILE_NAME_SIZE+FILE_TYPE_SIZE ; All '?'s ?                    ;
0872: E37C 20 1B                  JR     NZ,ccpEraseFile      ;  skip if not                      ;
0873: E37E         ; Want to be sure											                ;
0874: E37E 01 A9 E3               LD     BC,msgEraseAll       ; Point at the message              ;
0875: E381 CD 51 E6               CALL   PrintCrLfStringNull  ; Display it on the console         ;
0876: E384         ;
0877: E384 CD 65 E0               CALL   ReadCommand          ; Get the operator's response       ;
0878: E387 21 1A E2               LD     HL,commandLength     ; Point at size of response         ;
0879: E38A 35                     DEC    M                    ; Test the size                     ;
0880: E38B C2 26 E0               JP     NZ,ccpMainEntry      ; Exit, wrong answer                ;
0881: E38E 23                     INC    HL                   ; point at the 1 char response      ;
0882: E38F 7E                     LD     A,(HL)               ; Get it into ACC                   ;
0883: E390 FE 59                  CP     ASCII_Y              ; Is it 'Y'                         ;
0884: E392 C2 26 E0               JP     NZ,ccpMainEntry      ;  exit if not                      ;
0885: E395         ;
0886: E395 23                     INC    HL                   ; Adjust the pointer                ;
0887: E396 22 9B E2               LD     (commandBufferPointer),HL ; Restore buffer pointer            ;
0888: E399             ccpEraseFile:                      ;
0889: E399 CD 7C E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
0890: E39C 11 FD E6               LD     DE,Token1            ; Point to target FCB               ;
0891: E39F CD FF E5               CALL   DeleteFile           ; Call BDOS to delete               ;
0892: E3A2 3C                     INC    A                    ; 255 returned if not found         ;
0893: E3A3 CC 61 E6               CALL   Z,PrintNoFile        ; Report if file not found          ;
0894: E3A6 C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Wrap up and start over            ;
0895: E3A9         ;
0896: E3A9             msgEraseAll:                      ;
0897: E3A9 41 4C 4C 20 28 59 2F 4E 29 3F 00                DB     'ALL (Y/N)?',0       ;
0898: E3B4         ;-------------------------------- Erase Files ------------------------------;
0899: E3B4
0900: E3B4         ;-------------------------------- Rename Files -----------------------------;
0901: E3B4         ; SYNTAX: REN ufn1=ufn2                                                     ;
0902: E3B4         ;                                                                           ;
0903: E3B4         ;  The 'REN' command allows you to change the name of files on disk. The    ;
0904: E3B4         ; file satisfying ufn2 is changed to ufn1. The currently logged disk is     ;
0905: E3B4         ; assumed to contain the file to rename (ufn2).                             ;
0906: E3B4             ccpRename:                      ;
0907: E3B4 CD 21 E1               CALL   ParseToken1          ; Get ufn1                          ;
0908: E3B7 C2 F5 E1               JP     NZ,CommandError      ; Must be unambiguous. No '?'s      ;
0909: E3BA 3A 1E E7               LD     A,(selectedDisk)     ; Get saved disk                    ;
0910: E3BD F5                     PUSH   AF                   ; Save for later compare            ;
0911: E3BE CD 7C E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
0912: E3C1 CD E3 E6               CALL   FindFirstToken1File  ; Is ufn1 already there?            ;
0913: E3C4 20 4E                  JR     NZ,ccpRenameError3   ;  if yes, report error             ;
0914: E3C6         ;
0915: E3C6             ccpRenameFCB1:                      ;
0916: E3C6         ; file doesn't exist, move to second half of FCB                            ;
0917: E3C6 21 FD E6               LD     HL,Token1            ; Point at FCB for ufn1             ;
0918: E3C9 11 0D E7               LD     DE,Token2            ; Point where to put it             ;
0919: E3CC 01 10 00               LD     BC,16                ; FCB F1...F8,T1...T3,EXT,S1,S2,RC  ;
0920: E3CF ED B0                  LDIR   ccpRenameFCB1        ; Move the FCB                      ;
0921: E3D1         ; check for = or left arrow                                                 ;
0922: E3D1 2A 9B E2               LD     HL,(commandBufferPointer) ; Get pointer                       ;
0923: E3D4         ;	EX		DE,HL                                                           ;
0924: E3D4 CD A8 E1               CALL   NextNonBlankChar     ; Get a live character              ;
0925: E3D7 FE 3D                  CP     EQUAL_SIGN           ; is it '=' ?                       ;
0926: E3D9 28 04                  JR     Z,ccpRenameFCB2      ;  do FCB2 if yes                   ;
0927: E3DB FE 5F                  CP     LEFT_ARROW           ; is it '<-' ?                      ;
0928: E3DD 20 2F                  JR     NZ,ccpRenameError2   ;  error if no                      ;
0929: E3DF         ;
0930: E3DF             ccpRenameFCB2:                      ;
0931: E3DF         ;	EX		DE,HL                                                           ;
0932: E3DF 23                     INC    HL                   ; Move to start of ufn2             ;
0933: E3E0 22 9B E2               LD     (commandBufferPointer),HL ; Save for parser                   ;
0934: E3E3 CD 21 E1               CALL   ParseToken1          ; Get ufn2                          ;
0935: E3E6 20 26                  JR     NZ,ccpRenameError2   ; Must be unambiguous. No '?'s      ;
0936: E3E8         ;
0937: E3E8 F1                     POP    AF                   ; Get saved disk                    ;
0938: E3E9 47                     LD     B,A                  ; Save a copy                       ;
0939: E3EA 21 1E E7               LD     HL,selectedDisk      ; Point at current selected disk    ;
0940: E3ED 7E                     LD     A,(HL)               ; Get it                            ;
0941: E3EE B7                     OR     A                    ; Was it the default disk ?         ;
0942: E3EF 28 04                  JR     Z,ccpRename2         ;  skip if yes                      ;
0943: E3F1         ; drive name was specified.  same one?                                      ;
0944: E3F1 B8                     CP     B                    ; Are they the same ?               ;
0945: E3F2 70                     LD     (HL),B               ; Update to new selected disk       ;
0946: E3F3 20 19                  JR     NZ,ccpRenameError2   ; Not the same, error exit			;
0947: E3F5             ccpRename2:                      ;
0948: E3F5 70                     LD     (HL),B               ; Update to new selected disk       ;
0949: E3F6 AF                     XOR    A                    ; Set ACC = 0                       ;
0950: E3F7 32 FD E6               LD     (Token1),A           ; FCB2's disk is default            ;
0951: E3FA CD E3 E6               CALL   FindFirstToken1File  ; Get ufn2'ss directory Entry       ;
0952: E3FD 28 09                  JR     Z,ccpRenameError1    ; Error exit if not there           ;
0953: E3FF         ;
0954: E3FF 11 FD E6               LD     DE,Token1            ; Point at both FCBs                ;
0955: E402 CD 10 E6               CALL   RenameFile           ; Let BDOS do the rename            ;
0956: E405 C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Exit gracefully                   ;
0957: E408         ;
0958: E408             ccpRenameError1:                      ;
0959: E408 CD 61 E6               CALL   PrintNoFile          ; Inform operator there is no file	;
0960: E40B C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Exit cleanly                      ;
0961: E40E         ;
0962: E40E             ccpRenameError2:                      ;
0963: E40E CD D2 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
0964: E411 C3 F5 E1               JP     CommandError         ; Error exit                        ;
0965: E414         ;
0966: E414             ccpRenameError3:                      ;
0967: E414 01 1D E4               LD     BC,msgFileExists     ; Load message                      ;
0968: E417 CD 51 E6               CALL   PrintCrLfStringNull  ; Display message on console        ;
0969: E41A C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Exit cleanly                      ;
0970: E41D         ;
0971: E41D             msgFileExists:                      ;
0972: E41D 46 49 4C 45 20 45 58 49 53 54 53 00                DB     'FILE EXISTS',0      ;
0973: E429         ;-------------------------------- Rename Files -----------------------------;
0974: E429
0975: E429         ;---------------------------------- Save File ------------------------------;
0976: E429         ; SYNTAX: SAVE n ufn                                                    	;
0977: E429         ;                                                                           ;
0978: E429         ;  The 'SAVE' command places n pages(256-bytes) onto disk from the   		;
0979: E429         ; TPA (Location 0100H) and names the file ufn.                              ;
0980: E429         ;
0981: E429             ccpSave:                        ;
0982: E429 CD A3 E6               CALL   GetNumberFromCmdLine ; Value returned in Acc.            ;
0983: E42C F5                     PUSH   AF                   ; Save value                        ;
0984: E42D CD 21 E1               CALL   ParseToken1          ; Parse to get ufn                  ;
0985: E430 C2 F5 E1               JP     NZ,CommandError      ; Must be unambiguous. No '?'s      ;
0986: E433 CD 7C E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
0987: E436 11 FD E6               LD     DE,Token1            ; Get the FCB                       ;
0988: E439 D5                     PUSH   DE                   ; Save FCB                          ;
0989: E43A CD FF E5               CALL   DeleteFile           ; Deleted file if it exists         ;
0990: E43D D1                     POP    DE                   ; Restore FCB                       ;
0991: E43E CD 0B E6               CALL   MakeFile             ; Create a new file on disk         ;
0992: E441 28 2F                  JR     Z,ccpSaveError1      ;  exit, no directory space         ;
0993: E443 AF                     XOR    A                    ; Set Acc = 0                       ;
0994: E444 32 1D E7               LD     (currentRecord),A    ; Clear next record field           ;
0995: E447 F1                     POP    AF                   ; # pages to write is in Acc        ;
0996: E448 6F                     LD     L,A                  ;  	change to # sectors             ;
0997: E449 26 00                  LD     H,0                  ; Sector size is 512				;
0998: E44B 29                     ADD    HL,HL                ; Sector Count	                    ;
0999: E44C 11 00 01               LD     DE,TPA               ; Initialize Memory pointer         ;
1000: E44F         ;
1001: E44F             ccpSaveWrite:                      ;
1002: E44F 7C                     LD     A,H                  ;
1003: E450 B5                     OR     L                    ; If Sector count = 0               ;
1004: E451 28 16                  JR     Z,ccpSaveClose       ;  we are finished writing          ;
1005: E453 2B                     DEC    HL                   ; Decrement Sector count            ;
1006: E454 E5                     PUSH   HL                   ; Sector count                      ;
1007: E455 21 80 00               LD     HL,cpmRecordSize     ; Get bytes to write                ;
1008: E458 19                     ADD    HL,DE                ; Add to memory pointer             ;
1009: E459 E5                     PUSH   HL                   ; memory pointer                    ;
1010: E45A CD 18 E6               CALL   SetDMA               ; Set DMA                           ;
1011: E45D 11 FD E6               LD     DE,Token1            ; Point at the FCB                  ;
1012: E460 CD 04 E6               CALL   WriteSeq             ; Write a sector from DMA           ;
1013: E463 D1                     POP    DE                   ; memory pointer                    ;
1014: E464 E1                     POP    HL                   ; Sector count                      ;
1015: E465 20 13                  JR     NZ,ccpSaveError2     ; If disk full, exit                ;
1016: E467 18 E6                  JR     ccpSaveWrite         ; Keep on writing                   ;
1017: E469         ;
1018: E469         ;
1019: E469             ccpSaveClose:                      ;
1020: E469 11 FD E6               LD     DE,Token1            ; Point at the FCB                  ;
1021: E46C CD F3 E5               CALL   CloseFile            ; Close the File                    ;
1022: E46F 3C                     INC    A                    ; Check return code                 ;
1023: E470 20 0E                  JR     NZ,ccpSaveExit       ; If OK, clean exit                 ;
1024: E472         ;
1025: E472             ccpSaveError1:                      ;
1026: E472 01 86 E4               LD     BC,msgNoDirSpace     ; Load Error Message                ;
1027: E475 CD 51 E6               CALL   PrintCrLfStringNull  ; Send it to the console            ;
1028: E478 18 06                  JR     ccpSaveExit          ; Do a clean exit                   ;
1029: E47A             ccpSaveError2:                      ;
1030: E47A 01 99 E4               LD     BC,msgNoDiskSpace    ; Load Error Message                ;
1031: E47D CD 51 E6               CALL   PrintCrLfStringNull  ; Send it to the console            ;
1032: E480         ;
1033: E480             ccpSaveExit:                      ;
1034: E480 CD 15 E6               CALL   SetDefaultDMA        ; Reset the DMA                     ;
1035: E483 C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Perform a clean exit              ;
1036: E486         ;
1037: E486             msgNoDirSpace:                      ;
1038: E486 4E 4F 20 44 49 52 45 43 54 4F 52 59 20 53 50 41 43 45 00                DB     'NO DIRECTORY SPACE',0 ;
1039: E499             msgNoDiskSpace:                      ;
1040: E499 4E 4F 20 44 49 53 4B 20 53 50 41 43 45 00                DB     'NO DISK SPACE',0    ;
1041: E4A7         ;---------------------------------- Save File ------------------------------;
1042: E4A7
1043: E4A7         ;---------------------------------- Type File ------------------------------;
1044: E4A7         ; SYNTAX: TYPE ufn                                                    		;
1045: E4A7         ;                                                                           ;
1046: E4A7         ;  The 'TYPE' command displays the content of the ASCII source file ufn on  ;
1047: E4A7         ; the currently logged disk at the console device.                          ;
1048: E4A7         ;
1049: E4A7             ccpType:                        ;
1050: E4A7 CD 21 E1               CALL   ParseToken1          ; Setup the ufn's FCB               ;
1051: E4AA C2 F5 E1               JP     NZ,CommandError      ; Must be unambiguous. No '?'s      ;
1052: E4AD CD 7C E6               CALL   SetDiskForCmd        ; Change disks for this command     ;
1053: E4B0 CD F3 E6               CALL   OpenToken1File       ; Open the file at Token1           ;
1054: E4B3 28 2D                  JR     Z,ccpTypeError       ;  error exit if not successful     ;
1055: E4B5         ;
1056: E4B5 CD 40 E6               CALL   PrintCrLf            ; Send new  NewLine to console  ;
1057: E4B8         ;
1058: E4B8             ccpTypeRead:                      ;
1059: E4B8 11 FD E6               LD     DE,Token1            ; Point at Token1's FCB             ;
1060: E4BB CD F8 E5               CALL   DiskRead             ; Read next Record                  ;
1061: E4BE 20 18                  JR     NZ,ccpTypeEOF        ; Hard End Of File                  ;
1062: E4C0         ;
1063: E4C0 06 80                  LD     B,cpmRecordSize      ; Load Character count              ;
1064: E4C2 0E 02                  LD     C,fConsoleOut        ; Load Function Number              ;
1065: E4C4 21 80 00               LD     HL,DMABuffer         ; Point at the read buffer          ;
1066: E4C7 E5                     PUSH   HL                   ; Buffer Pointer                    ;
1067: E4C8             ccpTypeRecord:                      ;
1068: E4C8 E1                     POP    HL                   ; Buffer Pointer                    ;
1069: E4C9 7E                     LD     A,(HL)               ; Get the Character                 ;
1070: E4CA FE 1A                  CP     END_OF_FILE          ; Are we at EOF ?                   ;
1071: E4CC CA 8E E6               JP     Z,RestoreDiskAtCmdEnd ;  yes, exit                        ;
1072: E4CF         ;
1073: E4CF 23                     INC    HL                   ; Increment the Buffer Pointer      ;
1074: E4D0 E5                     PUSH   HL                   ; Buffer Pointer                    ;
1075: E4D1 CD 35 E6               CALL   PrintCharInA         ; Preserve BC                       ;
1076: E4D4 10 F2                  DJNZ   ccpTypeRecord        ; Iterate over the record       ;
1077: E4D6 18 E0                  JR     ccpTypeRead          ; Iterate over the file             ;
1078: E4D8         ;
1079: E4D8             ccpTypeEOF:                      ;
1080: E4D8 3D                     DEC    A                    ; Error returned ?                  ;
1081: E4D9 CA 8E E6               JP     Z,RestoreDiskAtCmdEnd ;  no, Restore Disk and exit        ;
1082: E4DC 01 E8 E4               LD     BC,msgReadErr        ; Load Message                      ;
1083: E4DF CD 51 E6               CALL   PrintCrLfStringNull  ; Send it to the console            ;
1084: E4E2         ;
1085: E4E2             ccpTypeError:                      ;
1086: E4E2 CD D2 E6               CALL   RestoreDisk          ; Restore Disk                      ;
1087: E4E5 C3 F5 E1               JP     CommandError         ; Report error and exit             ;
1088: E4E8
1089: E4E8             msgReadErr:
1090: E4E8 52 45 41 44 20 45 52 52 4F 52 00                DB     'READ ERROR',0
1091: E4F3         ;
1092: E4F3         ;---------------------------------- Type File ------------------------------;
1093: E4F3
1094: E4F3         ;------------------------------- User Function -----------------------------;
1095: E4F3         ; SYNTAX: USER n		                                             		;
1096: E4F3         ;                                                                           ;
1097: E4F3         ;  The User command allows maintenance of separate files in the same        ;
1098: E4F3         ; directory. In the syntax line, n is an integer value in the range of 0-15 ;
1099: E4F3         ; On cold start, the operator is automatically logged into user area        ;
1100: E4F3         ; number 0.                                                                 ;
1101: E4F3         ;  The active user number is maintained until changed by a subsequent USER  ;
1102: E4F3         ; command, or until a cold start when user 0 is again assumed               ;
1103: E4F3         ;
1104: E4F3             ccpUser:                        ;
1105: E4F3 CD A3 E6               CALL   GetNumberFromCmdLine ; Value returned in Acc.            ;
1106: E4F6 FE 10                  CP     16                   ; Greater than 16 ?                 ;
1107: E4F8 D2 F5 E1               JP     NC,CommandError      ;  if yes, Error exit               ;
1108: E4FB 5F                     LD     E,A                  ; Prepare for SetUser call          ;
1109: E4FC 3A FE E6               LD     A,(Token1)+1         ; Look past the number              ;
1110: E4FF FE 20                  CP     SPACE                ; Is it a Space ?                   ;
1111: E501 CA F5 E1               JP     Z,CommandError       ;  yes, error exit                  ;
1112: E504 CD 24 E6               CALL   SetUser              ; Call BDOS to set new user         ;
1113: E507 C3 91 E6               JP     EndCommand           ; Exit cleanly                      ;
1114: E50A         ;------------------------------- User Function -----------------------------;
1115: E50A
1116: E50A         ;------------------------------- User Command ------------------------------;
1117: E50A             ccpUserCommand:                      ;
1118: E50A 3A FE E6               LD     A,(Token1)+1         ; Point at start CMD File name      ;
1119: E50D FE 20                  CP     SPACE                ; Is it a Space ?                   ;
1120: E50F 20 14                  JR     NZ,ccpUserCmdFileType ;  skip if not                      ;
1121: E511         ;
1122: E511         ; Disk change A:, B: C: .....                                               ;
1123: E511 3A 1E E7               LD     A,(selectedDisk)     ; Get selected disk                 ;
1124: E514 B7                     OR     A                    ; Is it the default disk ?          ;
1125: E515 CA 91 E6               JP     Z,EndCommand         ; Exit if not                       ;
1126: E518 3D                     DEC    A                    ; Adjust so A=>0, B=>1, C=>2        ;
1127: E519 32 21 E7               LD     (currentDisk),A      ; Update current Disk indicator     ;
1128: E51C CD 15 E1               CALL   SetPage0CurDisk      ; Set user/disk in page 0           ;
1129: E51F CD E8 E5               CALL   SelectDisk           ;  Go select this disk              ;
1130: E522 C3 91 E6               JP     EndCommand           ; Exit Cleanly                      ;
1131: E525         ;
1132: E525         ;
1133: E525             ccpUserCmdFileType:                      ;
1134: E525 DD 21 FD E6               LD     IX,Token1            ; Point at Token1                   ;
1135: E529 DD 7E 09               LD     A,(IX+9)             ; Get 1st char of CMD file type     ;
1136: E52C FE 20                  CP     SPACE                ; Is it a SPACE ?                   ;
1137: E52E C2 F5 E1               JP     NZ,CommandError      ;  Error exit (no type allowed)     ;
1138: E531 CD 7C E6               CALL   SetDiskForCmd        ; Change disk if needed             ;
1139: E534 DD 36 09 43               LD     (IX+9),ASCII_C       ;
1140: E538 DD 36 0A 4F               LD     (IX+10),ASCII_O      ;
1141: E53C DD 36 0B 4D               LD     (IX+11),ASCII_M      ; Set Token1's type to 'COM'        ;
1142: E540 CD F3 E6               CALL   OpenToken1File       ; Open the CMD File		            ;
1143: E543 CA CB E5               JP     Z,ccpUserCmdError    ;  if error, then exit              ;
1144: E546         ; file opened properly, read it into memory                                 ;
1145: E546         ;
1146: E546 21 00 01               LD     HL,TPA               ; Set Read buffer to TPA start      ;
1147: E549             ccpUserCmdReadFile:                      ;
1148: E549 E5                     PUSH   HL                   ; Save current read buffer pointer  ;
1149: E54A EB                     EX     DE,HL                ; Load buffer pointer for BDOS call ;
1150: E54B CD 18 E6               CALL   SetDMA               ; Set the DMA                       ;
1151: E54E 11 FD E6               LD     DE,Token1            ; Point at Token1's FCB             ;
1152: E551 CD F8 E5               CALL   DiskRead             ; Read int the buffer               ;
1153: E554 20 10                  JR     NZ,ccpUserCmdSetFCBs ;  finished ?, skip                 ;
1154: E556         ;
1155: E556 E1                     POP    HL                   ; Get prior Pointer                 ;
1156: E557 11 80 00               LD     DE,cpmRecordSize     ; Get Record size                   ;
1157: E55A 19                     ADD    HL,DE                ; Need to make new pointer          ;
1158: E55B 11 00 E0               LD     DE,CcpBoundary       ;  Are we still in TPA ?            ;
1159: E55E 7D                     LD     A,L                  ;
1160: E55F 93                     SUB    E                    ;
1161: E560 7C                     LD     A,H                  ;
1162: E561 9A                     SBC    A,D                  ;
1163: E562 30 6D                  JR     NC,ccpUserCmdErrorBadLoad ;  no, error exit                   ;
1164: E564 18 E3                  JR     ccpUserCmdReadFile   ;  else go for another sector       ;
1165: E566         ;
1166: E566             ccpUserCmdSetFCBs:                      ;
1167: E566 E1                     POP    HL                   ; Balance the Stack                 ;
1168: E567 3D                     DEC    A                    ; Test DiskRead return value        ;
1169: E568 20 67                  JR     NZ,ccpUserCmdErrorBadLoad ;  error exit if problem            ;
1170: E56A CD D2 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
1171: E56D CD 21 E1               CALL   ParseToken1          ; Parse FCB1 from command line      ;
1172: E570 21 1E E7               LD     HL,selectedDisk      ; Point at selected disk            ;
1173: E573 7E                     LD     A,(HL)               ; Get selected disk                 ;
1174: E574 32 FD E6               LD     (Token1),A           ;  and put into FCB1                ;
1175: E577 CD 1C E1               CALL   ParseToken2          ; Parse FCB2 from command line      ;
1176: E57A 21 1E E7               LD     HL,selectedDisk      ; Point at selected disk            ;
1177: E57D 7E                     LD     A,(HL)               ; Get selected disk                 ;
1178: E57E 32 0D E7               LD     (Token2),A           ;  and put into FCB2                ;
1179: E581 AF                     XOR    A                    ; Set Acc to 0                      ;
1180: E582 32 1D E7               LD     (currentRecord),A    ; Initialize record number          ;
1181: E585         ;
1182: E585 21 FD E6               LD     HL,Token1            ; Set Source                        ;
1183: E588 11 5C 00               LD     DE,FCB1              ; Set destination                   ;
1184: E58B 01 21 00               LD     BC,33                ; Set Size                          ;
1185: E58E ED B0                  LDIR                        ; Move FCBs to Page 0               ;
1186: E590 21 1B E2               LD     HL,commandBuffer     ; Point at raw command input        ;
1187: E593             ccpUserCmdFindTailStart:                      ;
1188: E593 7E                     LD     A,(HL)               ; Get byte from raw input           ;
1189: E594 B7                     OR     A                    ; Are we at end of input ?          ;
1190: E595 28 07                  JR     Z,ccpUserCmdTailSetUp ;  yes, get out of loop             ;
1191: E597 FE 20                  CP     SPACE                ; Is it a Space                     ;
1192: E599 28 03                  JR     Z,ccpUserCmdTailSetUp ;  yes, get out                     ;
1193: E59B 23                     INC    HL                   ; increment the pointer             ;
1194: E59C 18 F5                  JR     ccpUserCmdFindTailStart ; Go back for more                  ;
1195: E59E         ;
1196: E59E             ccpUserCmdTailSetUp:                      ;
1197: E59E 06 00                  LD     B,0                  ; Initialize Tail Count             ;
1198: E5A0 3E 00                  LD     A,0                  ; Marker for end of buffer          ;
1199: E5A2 11 81 00               LD     DE,ComTailCount      ; XXXXXXX ComTailChars              ;
1200: E5A5         ; ready for the move                                                        ;
1201: E5A5             ccpUserCmdTailMove:                      ;
1202: E5A5 BE                     CP     (HL)                 ; Are we at end of Buffer ?         ;
1203: E5A6 28 07                  JR     Z,ccpUserCmdTailCount ;  skip if yes                      ;
1204: E5A8 7E                     LD     A,(HL)               ;
1205: E5A9 12                     LD     (DE),A               ;  else move the character	        ;
1206: E5AA 04                     INC    B                    ; Adjust the count                  ;
1207: E5AB 23                     INC    HL                   ; Increment the target pointer      ;
1208: E5AC 13                     INC    DE                   ; Increment the source pointer      ;
1209: E5AD 18 F6                  JR     ccpUserCmdTailMove   ; Go back for more                  ;
1210: E5AF         ;
1211: E5AF             ccpUserCmdTailCount:                      ;
1212: E5AF 78                     LD     A,B                  ; Get the character count           ;
1213: E5B0 32 80 00               LD     (DMABuffer),A        ; XXXXXXX ComTailCount              ;
1214: E5B3         ;
1215: E5B3 CD 40 E6               CALL   PrintCrLf            ; Send new line to console      ;
1216: E5B6         ; now go to the loaded program                                              ;
1217: E5B6 CD 15 E6               CALL   SetDefaultDMA        ; Reset the DMA                     ;
1218: E5B9 CD 06 E1               CALL   SaveUserAndDisk      ; User code saved in page 0         ;
1219: E5BC         ; low memory diska contains user code                                       ;
1220: E5BC         ;
1221: E5BC CD 00 01               CALL   TPA                  ; Go to the loaded program          ;
1222: E5BF 31 F0 E7               LD     SP,Stack             ; May come back here, so            ;
1223: E5C2 CD 15 E1               CALL   SetPage0CurDisk      ;  we need to clean things          ;
1224: E5C5 CD E8 E5               CALL   SelectDisk           ;  up.                              ;
1225: E5C8 C3 26 E0               JP     ccpMainEntry         ; And go back to CCP                ;
1226: E5CB         ;
1227: E5CB             ccpUserCmdError:                      ;
1228: E5CB CD D2 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
1229: E5CE C3 F5 E1               JP     CommandError         ; Exit, and report error            ;
1230: E5D1         ;
1231: E5D1             ccpUserCmdErrorBadLoad:                      ;
1232: E5D1 01 DA E5               LD     BC,msgBadLoad        ; Load error message                ;
1233: E5D4 CD 51 E6               CALL   PrintCrLfStringNull  ; Send message to console           ;
1234: E5D7 C3 8E E6               JP     RestoreDiskAtCmdEnd  ; Fall thru to end of command       ;
1235: E5DA         ;
1236: E5DA             msgBadLoad:                      ;
1237: E5DA 42 41 44 20 4C 4F 41 44 00                DB     'BAD LOAD',0         ;
1238: E5E3         ;
1239: E5E3         ;------------------------------- User Command ------------------------------;
1240: E5E3
1241: E5E3         ;===========================================================================;
1242: E5E3         ;================================ BDOS API =================================;
1243: E5E3         ;===========================================================================;
1244: E5E3
1245: E5E3         ;------------------------------- Initialize --------------------------------;
1246: E5E3             Initialize:                      ;
1247: E5E3 0E 0D                  LD     C,fResetSystem       ; Load Function Number  - 0D        ;
1248: E5E5 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1249: E5E8         ;------------------------------- Initialize --------------------------------;
1250: E5E8         ;------------------------------- Select Disk -------------------------------;
1251: E5E8             SelectDisk:                      ;
1252: E5E8 5F                     LD     E,A                  ; Load Target disk                  ;
1253: E5E9 0E 0E                  LD     C,fSelectDisk        ; Load Function Number - 0EH        ;
1254: E5EB C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1255: E5EE         ;------------------------------- Select Disk -------------------------------;
1256: E5EE         ;-------------------------------- Open File --------------------------------;
1257: E5EE         ;Open the file				                                                ;
1258: E5EE         ; On Entry DE = FCB to read 						                        ;
1259: E5EE         ; Exits with Z-Flag Set if file not found									;
1260: E5EE         ;					Reset if file found										;
1261: E5EE             OpenFile:                       ;
1262: E5EE 0E 0F                  LD     C,fOpenFile          ; Load Function Number - 0FH        ;
1263: E5F0 C3 29 E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1264: E5F3         ;-------------------------------- Open File --------------------------------;
1265: E5F3         ;------------------------------- Close File --------------------------------;
1266: E5F3         ;Close the file				                                                ;
1267: E5F3         ; On Entry DE = FCB to Close						                        ;
1268: E5F3         ; Exits with Z-Flag Set if file not found									;
1269: E5F3         ;					Reset if file found										;
1270: E5F3             CloseFile:                      ;
1271: E5F3 0E 10                  LD     C,fCloseFile         ; Load Function Number - 10H        ;
1272: E5F5 C3 29 E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1273: E5F8         ;------------------------------- Close File --------------------------------;
1274: E5F8         ;-------------------------------- Read File --------------------------------;
1275: E5F8         ;Read the next record from the file.										;
1276: E5F8         ; On Entry DE = FCB to read 						                        ;
1277: E5F8             DiskRead:                       ;
1278: E5F8 0E 14                  LD     C,fReadSeq           ; Load Function Number - 14H        ;
1279: E5FA CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1280: E5FD B7                     OR     A                    ; set return code flags             ;
1281: E5FE C9                     RET                         ;
1282: E5FF         ;-------------------------------- Read File --------------------------------;
1283: E5FF         ;----------------------------- Delete The File -----------------------------;
1284: E5FF         ;Delete the file given by DE                                                ;
1285: E5FF             DeleteFile:                      ;
1286: E5FF 0E 13                  LD     C,fDeleteFile        ; Load Function Number - 13H            ;
1287: E601 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1288: E604         ;----------------------------- Delete The File -----------------------------;
1289: E604         ;------------------------------- Disk Write --------------------------------;
1290: E604         ;Write the next record to the file given by DE                              ;
1291: E604             WriteSeq:                       ;
1292: E604 0E 15                  LD     C,fWriteSeq          ; Load Function Number - 15H        ;
1293: E606 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1294: E609 B7                     OR     A                    ; set return code flags             ;
1295: E60A C9                     RET                         ;
1296: E60B         ;------------------------------- Disk Write --------------------------------;
1297: E60B         ;-------------------------------- Make File --------------------------------;
1298: E60B         ;Make the file given by DE                                                  ;
1299: E60B             MakeFile:                       ;
1300: E60B 0E 16                  LD     C,fMakeFile          ; Load Function Number - 16H        ;
1301: E60D C3 29 E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1302: E610         ;-------------------------------- Make File --------------------------------;
1303: E610         ;------------------------------- Rename File -------------------------------;
1304: E610         ; Rename a file give by DE                                                  ;
1305: E610             RenameFile:                      ;
1306: E610 0E 17                  LD     C,fRenameFile        ; Load Function Number - 17H        ;
1307: E612 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1308: E615         ;------------------------------- Rename File -------------------------------;
1309: E615         ;---------------------------- Set (Default) DMA ----------------------------;
1310: E615         ;Set default buffer DMA address (0080H)                                     ;
1311: E615             SetDefaultDMA:                      ;
1312: E615 11 80 00               LD     DE,DMABuffer         ;
1313: E618         ;---------                                                                  ;
1314: E618         ;Set DMA address to DE                                                      ;
1315: E618             SetDMA:                         ;
1316: E618 0E 1A                  LD     C,fSetDMA            ; Load Function Number - 1AH        ;
1317: E61A C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1318: E61D         ;---------------------------- Set (Default) DMA ----------------------------;
1319: E61D         ;----------------------------- Get Current Disk ----------------------------;
1320: E61D         ;Exits with current drive number to A (0=A,1=B....F=P)                      ;
1321: E61D             GetSelectedDrive:                      ;
1322: E61D 0E 19                  LD     C,fGetCurrentDisk    ; Load Function Number - 19H    ;
1323: E61F C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1324: E622         ;----------------------------- Get Current Disk ----------------------------;
1325: E622         ;------------------------------ Get/Set User -------------------------------;
1326: E622         ;return current user code in A                                              ;
1327: E622             GetUser:                        ;
1328: E622 1E FF                  LD     E,0FFH               ; Set Entry Parameter for Get       ;
1329: E624         ; If E <> -1 then Set user number found in E                                ;
1330: E624             SetUser:                        ;
1331: E624 0E 20                  LD     C,fGetSetUserNumber  ; Load Function Number - 20H        ;
1332: E626 C3 05 00               JP     BDOS                 ;  and let BDOS do its work         ;
1333: E629         ;------------------------------ Get/Set User -------------------------------;
1334: E629
1335: E629         ;------------------------------ BDOS and Inc A -----------------------------;
1336: E629         ; Call B DOS                                                                ;
1337: E629         ;  Store returned directory index                                           ;
1338: E629         ;  Increment result.                                                        ;
1339: E629         ; Exits with 	A =  0 if File Not Found                                    ;
1340: E629         ;				  <> 0 if file found                                        ;
1341: E629             BDOSandIncA:                      ;
1342: E629 CD 05 00               CALL   BDOS                 ; Make call to BDOS                 ;
1343: E62C 32 22 E7               LD     (directoryEntryNumber),A ; Save return value                 ;
1344: E62F 3C                     INC    A                    ; Increment & (Re)Set Z-Flag        ;
1345: E630 C9                     RET                         ;
1346: E631         ;------------------------------ BDOS and Inc A -----------------------------;
1347: E631
1348: E631         ;===========================================================================;
1349: E631         ;=============================== Utilities =================================;
1350: E631
1351: E631         ;===========================================================================;
1352: E631
1353: E631         ;------------------------------- Print Space -------------------------------;
1354: E631             PrintSpace:                      ;
1355: E631 1E 20                  LD     E,SPACE              ; Load Space                        ;
1356: E633 18 03                  JR     PrintCharInE         ; Go Print it  * Save BC            ;
1357: E635         ;------------------------------- Print Space -------------------------------;
1358: E635         ;------------------------------- PrintCharInA ------------------------------;
1359: E635         ; Print character                                                           ;
1360: E635         ; On Entry A = Character to Send to Console                                 ;
1361: E635             PrintCharInA:                      ;
1362: E635 5F                     LD     E,A                  ; move char to E                    ;
1363: E636 18 00                  JR     PrintCharInE         ;
1364: E638         ;------------------------------- PrintCharInA ------------------------------;
1365: E638         ;------------------------------- PrintCharInE ------------------------------;
1366: E638         ; Print character                                                           ;
1367: E638         ; On Entry E = Character to Send to Console                                 ;
1368: E638         ; Preserves BC                                ;                             ;
1369: E638             PrintCharInE:                      ;
1370: E638 C5                     PUSH   BC                   ; Preserve BC                       ;
1371: E639 0E 02                  LD     C,fConsoleOut        ; Load Function Number         		;
1372: E63B CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1373: E63E C1                     POP    BC                   ; Restore BC                        ;
1374: E63F C9                     RET                         ;
1375: E640         ;------------------------------- PrintCharInE ------------------------------;
1376: E640         ;-------------------------------- CR / LF ----------------------------------;
1377: E640         ;Sent Carriage Return Line Feed to Console                                  ;
1378: E640             PrintCrLf:                      ;
1379: E640 C5                     PUSH   BC                   ; Preserve BC                       ;
1380: E641 1E 0D                  LD     E,CR                 ; Load Carriage Ceturn              ;
1381: E643 0E 02                  LD     C,fConsoleOut        ; Load Function Number         		;
1382: E645 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1383: E648 1E 0A                  LD     E,LF                 ; Load Line Feed                    ;
1384: E64A 0E 02                  LD     C,fConsoleOut        ; Load Function Number         		;
1385: E64C CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1386: E64F C1                     POP    BC                   ; Restore BC                        ;
1387: E650 C9                     RET                         ;
1388: E651         ;-------------------------------- CR / LF ----------------------------------;
1389: E651         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1390: E651         ;print CRLF then null terminated string at (BC)                             ;
1391: E651             PrintCrLfStringNull:                      ;
1392: E651 C5                     PUSH   BC                   ; Save string pointer               ;
1393: E652 CD 40 E6               CALL   PrintCrLf            ; Send CR/LF                    ;
1394: E655 E1                     POP    HL                   ; Restore pointer & fall thru       ;
1395: E656         ;print null terminated string from (HL)                                     ;
1396: E656             PrintStringNull:                      ;
1397: E656 7E                     LD     A,(HL)               ; Get the next character            ;
1398: E657 B7                     OR     A                    ; Is it the Null terminator ?       ;
1399: E658 C8                     RET    Z                    ;  exit if yes                      ;
1400: E659 23                     INC    HL                   ; Move string pointer               ;
1401: E65A E5                     PUSH   HL                   ; Save for next iteration           ;
1402: E65B CD 35 E6               CALL   PrintCharInA         ; Send the character to the console ;
1403: E65E E1                     POP    HL                   ; string pointer                    ;
1404: E65F 18 F5                  JR     PrintStringNull      ; Loop for more                     ;
1405: E661         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
1406: E661         ;-------------------------- Print 'No File' Message ------------------------;
1407: E661         ;print 'no file' message on console                                        ;
1408: E661             PrintNoFile:                      ;
1409: E661 01 66 E6               LD     BC,msgNoFile         ; Point to the message              ;
1410: E664 18 EB                  JR     PrintCrLfStringNull  ; Go print it & return to caller    ;
1411: E666         ;
1412: E666 4E 4F 20 46 49 4C 45 00     msgNoFile: DB     'NO FILE',0          ;
1413: E66E         ;-------------------------- Print 'No File' Message ------------------------;
1414: E66E
1415: E66E
1416: E66E
1417: E66E
1418: E66E
1419: E66E
1420: E66E
1421: E66E
1422: E66E         ;------------------------- Check For Console Input -------------------------;
1423: E66E         ;check for a character ready at the console                                 ;
1424: E66E         ;Exits with	Z-Flag  set if there has been no character input                ;
1425: E66E         ;					reset if there is a character waiting                   ;
1426: E66E         ;			A = character input, if Z-Flag reset                            ;
1427: E66E             CheckForConsoleChar:                      ;
1428: E66E 0E 0B                  LD     C,fGetConsoleStatus  ; Load Function Number - 0BH        ;
1429: E670 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work         ;
1430: E673 B7                     OR     A                    ; Check return value                ;
1431: E674 C8                     RET    Z                    ; Return if no char waiting         ;
1432: E675         ;
1433: E675 0E 01                  LD     C,fConsoleIn         ; Load Function Number - 01H        ;
1434: E677 CD 05 00               CALL   BDOS                 ; character cleared             ;
1435: E67A B7                     OR     A                    ; Resets the Z-Flag                 ;
1436: E67B C9                     RET                         ;
1437: E67C         ;------------------------- Check For Console Input -------------------------;
1438: E67C         ;--------------------------- Set Disk For Command --------------------------;
1439: E67C         ;change disks for this command, if requested                                ;
1440: E67C             SetDiskForCmd:                      ;
1441: E67C AF                     XOR    A                    ; Set to 0                          ;
1442: E67D 32 FD E6               LD     (Token1),A           ; Set Token's disk to default       ;
1443: E680 3A 1E E7               LD     A,(selectedDisk)     ; Get the selected disk             ;
1444: E683 B7                     OR     A                    ; Is it also set for default ?      ;
1445: E684 C8                     RET    Z                    ;  exit if yes                      ;
1446: E685 3D                     DEC    A                    ; Adjust so A=0,B=2....             ;
1447: E686 21 21 E7               LD     HL,currentDisk       ; Point at the current disk         ;
1448: E689 BE                     CP     M                    ; Are they the same ?               ;
1449: E68A C8                     RET    Z                    ;  exit if yes                      ;
1450: E68B C3 E8 E5               JP     SelectDisk           ;  else go select the disk          ;
1451: E68E         ;
1452: E68E         ;--------------------------- Set Disk For Command --------------------------;
1453: E68E         ;------------------------ Restore Disk at Command End ----------------------;
1454: E68E         ;Restore disk from before command, fall thru to end of command              ;
1455: E68E             RestoreDiskAtCmdEnd:                      ;
1456: E68E CD D2 E6               CALL   RestoreDisk          ; Restore Disk from before command  ;
1457: E691         ;
1458: E691         ;End of intrinsic command                                                   ;
1459: E691             EndCommand:                      ;
1460: E691 CD 21 E1               CALL   ParseToken1          ; Check for garbage at end of line  ;
1461: E694 3A FE E6               LD     A,(Token1)+1         ; Point at 1st character            ;
1462: E697 D6 20                  SUB    SPACE                ; Get ??                            ;
1463: E699 21 1E E7               LD     HL,selectedDisk      ;
1464: E69C B6                     OR     M                    ; Are they equal ?                  ;
1465: E69D         ; 0 in accumulator if no disk selected, and blank FCB                       ;
1466: E69D C2 F5 E1               JP     NZ,CommandError      ;  no, report error                 ;
1467: E6A0 C3 26 E0               JP     ccpMainEntry         ;  else go back to the Start        ;
1468: E6A3         ;------------------------ Restore Disk at Command End ----------------------;
1469: E6A3
1470: E6A3         ;------------------------ Get Number From Command Line ---------------------;
1471: E6A3         ; Get number from the command line                                          ;
1472: E6A3         ; Exits with A = Value                                                      ;
1473: E6A3             GetNumberFromCmdLine:                      ;
1474: E6A3 CD 21 E1               CALL   ParseToken1          ; Get token                         ;
1475: E6A6 3A 1E E7               LD     A,(selectedDisk)     ; Get currently selected disk       ;
1476: E6A9 B7                     OR     A                    ; Is it current default disk ?      ;
1477: E6AA C2 F5 E1               JP     NZ,CommandError      ;  no, then error exit              ;
1478: E6AD         ; convert the byte value in Token1 to binary                                ;
1479: E6AD         ;
1480: E6AD 21 00 00               LD     HL,0000              ;
1481: E6B0 01 00 00               LD     BC,0000              ; Clear the registers               ;
1482: E6B3         ;
1483: E6B3 DD 21 FE E6               LD     IX,Token1+1          ;
1484: E6B7             CalculateNumber:                      ;
1485: E6B7 DD 7E 00               LD     A,(IX+0)             ; Get Character                     ;
1486: E6BA DD 23                  INC    IX                   ; Adjust for next time around       ;
1487: E6BC FE 20                  CP     SPACE                ; Terminating character ?           ;
1488: E6BE 28 10                  JR     Z,ReturnNumericValue ;  get out if yes                   ;
1489: E6C0 D6 30                  SUB    ASCII_ZERO           ; Make binary                       ;
1490: E6C2 FE 0A                  CP     0AH                  ; Is it a digit ?                   ;
1491: E6C4 30 0A                  JR     NC,ReturnNumericValue ;  get out if no                    ;
1492: E6C6 29                     ADD    HL,HL                ; Prior value * 2                   ;
1493: E6C7 E5                     PUSH   HL                   ; Move *2                           ;
1494: E6C8 D1                     POP    DE                   ;  to DE                            ;
1495: E6C9 29                     ADD    HL,HL                ; Prior value * 4                   ;
1496: E6CA 29                     ADD    HL,HL                ; Prior value * 8                   ;
1497: E6CB 19                     ADD    HL,DE                ; Add * 2 gives Prior value * 10    ;
1498: E6CC 4F                     LD     C,A                  ; Get this digit                    ;
1499: E6CD 09                     ADD    HL,BC                ; and add it                        ;
1500: E6CE 18 E7                  JR     CalculateNumber      ;
1501: E6D0         ;
1502: E6D0             ReturnNumericValue:                      ;
1503: E6D0 7D                     LD     A,L                  ; Put result in Acc                 ;
1504: E6D1 C9                     RET                         ;
1505: E6D2         ;
1506: E6D2         ;------------------------ Get Number From Command Line ---------------------;
1507: E6D2         ;-------------------------------- Restore Disk -----------------------------;
1508: E6D2         ; Restore Disk from before command                                          ;
1509: E6D2             RestoreDisk:                      ;
1510: E6D2 3A 1E E7               LD     A,(selectedDisk)     ; Get disk selected by command      ;
1511: E6D5 B7                     OR     A                    ; Is it the Default ?               ;
1512: E6D6 C8                     RET    Z                    ;  yes, the nothing to do           ;
1513: E6D7 3D                     DEC    A                    ; Change to 0=A, 1=B....            ;
1514: E6D8 21 21 E7               LD     HL,currentDisk       ;
1515: E6DB BE                     CP     M                    ; Is it the current disk ?          ;
1516: E6DC C8                     RET    Z                    ;  yes, the nothing to do           ;
1517: E6DD 3A 21 E7               LD     A,(currentDisk)      ;  else get current disk            ;
1518: E6E0 C3 E8 E5               JP     SelectDisk           ; Select it                         ;
1519: E6E3         ;-------------------------------- Restore Disk -----------------------------;
1520: E6E3         ;-------------------------- Find First Token1 Entry ------------------------;
1521: E6E3         ;Search for Token1 file                                                     ;
1522: E6E3             FindFirstToken1File:                      ;
1523: E6E3 11 FD E6               LD     DE,Token1            ; Point at Token1                   ;
1524: E6E6 C3 E9 E6               JP     SearchForFirst       ; Go look for it                    ;
1525: E6E9         ;-------------------------- Find First Token1 Entry ------------------------;
1526: E6E9         ;----------------------------- Find First Entry ----------------------------;
1527: E6E9         ;Search for the first directory entry given by DE                           ;
1528: E6E9         ;Upon entry  DE = FCB                                                       ;
1529: E6E9             SearchForFirst:                      ;
1530: E6E9 0E 11                  LD     C,fSearchFirst       ; Load Function Number - 11H        ;
1531: E6EB C3 29 E6               JP     BDOSandIncA          ; make BDOS call & set dir index   	;
1532: E6EE         ;----------------------------- Find First Entry ----------------------------;
1533: E6EE         ;----------------------------- Find  Next Entry ----------------------------;
1534: E6EE         ;Search for the next occurrence of the file given DE                        ;
1535: E6EE         ;Upon entry  DE = FCB                                                       ;
1536: E6EE             SearchForNext:                      ;
1537: E6EE 0E 12                  LD     C,fSearchNext        ; Load Function Number - 12H        ;
1538: E6F0 C3 29 E6               JP     BDOSandIncA          ; make BDOS call & set dir index    ;
1539: E6F3         ;----------------------------- Find  Next Entry ----------------------------;
1540: E6F3         ;----------------------------- Open Token1 File ----------------------------;
1541: E6F3             OpenToken1File:                      ;
1542: E6F3 AF                     XOR    A                    ; Clear Acc                         ;
1543: E6F4 32 1D E7               LD     (currentRecord),A    ; Initialize  next record for I/O   ;
1544: E6F7 11 FD E6               LD     DE,Token1            ; Point at the FCB                  ;
1545: E6FA C3 EE E5               JP     OpenFile             ; Let BDOS open the file            ;
1546: E6FD         ;----------------------------- Open Token1 File ----------------------------;
1547: E6FD
1548: E6FD
1549: E6FD
1550: E6FD
1551: E6FD
1552: E6FD         ; UT
1553: E6FD         ;*****************************************************************
1554: E6FD         ;************************ Data Area ******************************
1555: E6FD         ;*****************************************************************
1556: E6FD         ;------------------------------ Command Buffer -----------------------------;
1557: E6FD         ;;
1558: E6FD         ;;
1559: E6FD             Token1:    DS     16                   ; Command Token
1560: E70D             Token2:    DS     16                   ; Command Token
1561: E71D
1562: E71D
1563: E71D
1564: E71D 00          currentRecord: DB     00H                  ; current record to read/write
1565: E71E 00          selectedDisk: DB     00H                  ; selected disk for current operation none=0, a=1, b=2 ...
1566: E71F         ;
1567: E71F         ; bufferPointer:		DB		00H				; buffer pointer
1568: E71F         ;------------------------------------
1569: E71F 00 00       tokenStart: DW     0000H                ; staddr starting address of current Fill FCB request
1570: E721         ;----------------------------
1571: E721         ; (command executed initially if commandLength non zero)
1572: E721         ;--------------------------------- Variables -------------------------------;
1573: E721 00          currentDisk: DB     00H                  ; Current disk
1574: E722 00          directoryEntryNumber: DB     00H                  ; Index into Directory Buffer
1575: E723         ;--------------------------------- Variables -------------------------------;
1576: E723
1577: E723             endOfCode:
1578: E723                        ORG    BDOSBase-10H
1579: E7F0             Stack:                          ; Top Of Stack
1580: E7F0
1581: E7F0         ;Z_HighestLocation:
1582: E7F0             ZZ_MemoryLeft EQU    (BDOSBase-1) - endOfCode
1583: E7F0
1584: E7F0
1585: E7F0
1586: E7F0
1587: E7F0
           ************************   Xref   ************************
0000: $               E7F0   0743
0069: ASCII_A         0041   0309 0817
0070: ASCII_C         0043   1139
0071: ASCII_M         004D   1141
0033: ASCII_MASK      007F   0835
0072: ASCII_O         004F   1140
0073: ASCII_Y         0059   0883
0056: ASCII_ZERO      0030   1489
0054: ASTERISK        002A   0551
0266: BDOS            0005   0397 1248 1254 1279 1287 1293 1307 1317 1323 1332 1342 1372 1382 1385 1429 1434
1341: BDOSandIncA     E629   1263 1272 1301 1531 1538
0129: BDOSBase        E800   0130 0132 1578 1582
0098: BDOSE           0005   0099
0130: BDOSEntry       E800
0119: BDOSLength      0E00   0122 0132 0133
0132: BIOSBase        F600
0120: BIOSLength      0A00   0122
0092: BIOSPAGE        0002
0133: BIOSStart       F600
0229: BlockSize       0800   0251
0743: builtInCMDCount 0006   0653
0736: builtInCMDNames E2BE   0649 0743
0734: builtInCMDNameSize 0004   0656 0743
0745: builtInCMDVector E2D6   0327
0029: BYTE            0001
1484: CalculateNumber E6B7   1500
0074: CARET           005E
0276: CcpBoundary     E000   1158
0776: ccpDirAll       E2F4   0779
0827: ccpDirDisplayFile E345   0821
0823: ccpDirDisplayFile0 E33D   0810
0830: ccpDirDisplayFileLoop E348   0845
0766: ccpDirectory    E2E4   0746
0853: ccpDirEnd       E372   0789 0850
0847: ccpDirLoopBottom E366   0800
0788: ccpDirLoopTop   E303   0852
0781: ccpDirQualified E2F9   0772
0127: CCPEntry        E000   0129 0133 0275
0869: ccpErase        E377   0747
0888: ccpEraseFile    E399   0872
0118: CCPLength       0800   0122 0129 0133
0305: ccpMainEntry    E026   0390 0707 0880 0884 1225 1467
0315: CcpParseCommand E03C   0303
0906: ccpRename       E3B4   0750
0947: ccpRename2      E3F5   0942
0958: ccpRenameError1 E408   0952
0962: ccpRenameError2 E40E   0928 0935 0946
0966: ccpRenameError3 E414   0913
0915: ccpRenameFCB1   E3C6
0930: ccpRenameFCB2   E3DF   0926
0981: ccpSave         E429   0749
1019: ccpSaveClose    E469   1004
1025: ccpSaveError1   E472   0992
1029: ccpSaveError2   E47A   1015
1033: ccpSaveExit     E480   1023 1028
1001: ccpSaveWrite    E44F   1016
0284: CcpStart        E000
1049: ccpType         E4A7   0748
1079: ccpTypeEOF      E4D8   1061
1085: ccpTypeError    E4E2   1054
1058: ccpTypeRead     E4B8   1077
1067: ccpTypeRecord   E4C8   1076
1104: ccpUser         E4F3   0751
1227: ccpUserCmdError E5CB   1143
1231: ccpUserCmdErrorBadLoad E5D1   1163 1169
1133: ccpUserCmdFileType E525   1120
1187: ccpUserCmdFindTailStart E593   1194
1147: ccpUserCmdReadFile E549   1164
1166: ccpUserCmdSetFCBs E566   1153
1211: ccpUserCmdTailCount E5AF   1203
1201: ccpUserCmdTailMove E5A5   1209
1196: ccpUserCmdTailSetUp E59E   1190 1192
1117: ccpUserCommand  E50A   0324 0752
1427: CheckForConsoleChar E66E   0387 0849
1270: CloseFile       E5F3   0378 1021
0057: COLON           003A   0493 0635 0819 0825
0714: commandBuffer   E21B   0385 0414 0716 1186
0716: commandBufferPointer E29B   0415 0479 0523 0887 0922 0933
0687: CommandError    E1F5   0321 0627 0908 0964 0985 1051 1087 1107 1111 1137 1229 1466 1477
0702: CommandErrorExit E20B   0693 0695
0690: CommandErrorLoop E1FB   0700
0713: commandLength   E21A   0301 0365 0402 0878
0712: commandMaxLength E219   0395
0104: ComTail         0080   0105
0106: ComTailChars    0082
0105: ComTailCount    0081   0106 1199
0206: cpmRecordSize   0080   0208 0211 0213 0366 1007 1063 1156
0049: CR              000D   1380
0036: CTRL_C          0003
0037: CTRL_E          0005
0038: CTRL_H          0008
0039: CTRL_L          000C
0040: CTRL_P          0010
0041: CTRL_R          0012
0042: CTRL_S          0013
0043: CTRL_U          0015
0044: CTRL_X          0018
0045: CTRL_Z          001A
1573: currentDisk     E721   0319 0348 0381 0441 0452 0460 0499 1127 1447 1514 1517
1564: currentRecord   E71D   0994 1180 1543
0240: DataBlocks      02C7   0250
0239: DataSectors     0B1C   0240
1285: DeleteFile      E5FF   0440 0891 0989
0431: DeleteSubmitFile E0EE   0389 0393 0706
0211: DirBuffSize     0080
0858: dirCharCount    E376   0804 0837
0226: DirectoryBlockCount 0002   0251
1574: directoryEntryNumber E722   0791 1343
0213: DirectoryEntryPerRecord 0004   0254
0210: DirEntrySize    0020   0213 0251
0856: dirFileCount    E375   0783 0806
0198: DiskCommandBlock 0046
0197: DiskControlByte 0045
0200: DiskControlTable 0040
1277: DiskRead        E5F8   0360 1060 1152
0202: DiskReadCode    0001
0207: diskSectorSize  0200   0208 0229 0237
0196: DiskStatusLocation 0043
0203: DiskWriteCode   0002
0109: DMABuffer       0080   0316 0364 0797 1065 1213 1312
0052: DOLLAR          0024
0252: dpb3hdAL0       00C0
0253: dpb3hdAL1       0000
0248: dpb3hdBLM       000F
0247: dpb3hdBSH       0004
0254: dpb3hdCKS       0020
0251: dpb3hdDRM       007F   0254
0250: dpb3hdDSM       02C6
0249: dpb3hdEXM       0000
0256: dpb3hdNOH       0002
0255: dpb3hdOFF       0001
0246: dpb3hdSPT       0090
0113: END_OF_FILE     001A   1070
1459: EndCommand      E691   1113 1125 1130
1577: endOfCode       E723   1582
0034: EndOfMessage    0000
0061: EQUAL_SIGN      003D   0629 0925
0026: FALSE           0000
0101: FCB1            005C   0102 1183
0102: FCB2            006C
0268: fcbSystemFileIndex 000A   0799
0146: fCloseFile      0010   1271
0137: fConsoleIn      0001   1433
0138: fConsoleOut     0002   1064 1371 1381 1384
0149: fDeleteFile     0013   1286
0141: fGetConsoleStatus 000B   1428
0155: fGetCurrentDisk 0019   1322
0154: fGetLoginVector 0018
0157: fGetSetUserNumber 0020   1331
0142: fGetVersion     000C
0269: FILE_NAME_SIZE  0008   0510 0526 0775 0871
0270: FILE_TYPE_SIZE  0003   0514 0526 0775 0871
0602: FillWithAcc     E1A3   0521 0605
0600: FillWithSpace   E1A1   0569 0590
1522: FindFirstToken1File E6E3   0785 0912 0951
0152: fMakeFile       0016   1300
0145: fOpenFile       000F   1262
0546: FormatElement   E178   0511 0516 0560
0556: FormatElement1  E186   0552
0559: FormatElement2  E188   0554
0139: fPrintString    0009
0150: fReadSeq        0014   1278
0140: fReadString     000A   0396
0153: fRenameFile     0017   1306
0143: fResetSystem    000D   1247
0147: fSearchFirst    0011   1530
0148: fSearchNext     0012   1537
0144: fSelectDisk     000E   1253
0156: fSetDMA         001A   1316
0151: fWriteSeq       0015   1292
1473: GetNumberFromCmdLine E6A3   0982 1105
1321: GetSelectedDrive E61D   0308 0318 0815
1327: GetUser         E622   0447
0062: GREATER_THAN    003E   0311 0641
0051: HASH_TAG        0023
1246: Initialize      E5E3   0294
0648: IntrinsicFunction E1D0   0326
0651: IntrinsicFunction1 E1D5   0679
0657: IntrinsicFunction2 E1DE   0664
0672: IntrinsicFunction3 E1EE   0660 0675
0677: IntrinsicFunction4 E1F2   0668
0093: IOBYTE          0003
0622: IsItADelimiter  E1B1   0547 0563
0583: IsItDot         E195   0515
0065: LEFT_ARROW      005F   0927
0122: LengthInBytes   2000   0123 0127 0237
0123: LengthInK       0009
0060: LESS_THAN       003C   0639
0048: LF              000A   1383
0027: LO_NIBBLE_MASK  000F   0298
1299: MakeFile        E60B   0991
0711: maximumBufferSize 007F   0712 0714
0125: MemorySize      0040   0127
1236: msgBadLoad      E5DA   1232
0896: msgEraseAll     E3A9   0874
0971: msgFileExists   E41D   0967
1037: msgNoDirSpace   E486   1026
1039: msgNoDiskSpace  E499   1030
1412: msgNoFile       E666   1409
1089: msgReadErr      E4E8   1082
0238: myOffset        0001   0239 0255
0610: NextNonBlankChar E1A8   0480 0617 0924
0400: NoRead          E0D0   0388
0392: NotSubmitFile   E0BF   0346 0355 0361 0379
0222: NumberOfHeads   0002   0233 0235 0246 0256
0219: NumberOfLogicalDisks 0004
1261: OpenFile        E5EE   0354 1545
1541: OpenToken1File  E6F3   1053 1142
0568: PadTheElement   E191   0548
0474: ParseToken      E124   0471
0472: ParseToken1     E121   0320 0767 0870 0907 0934 0984 1050 1171 1460 1474
0469: ParseToken2     E11C   1175
0053: PERCENT         0025
0055: PERIOD          002E   0586 0633
0096: Pg0CurentDisk   0004   0299 0454 0461
0095: Pg0CurentUser   0004   0096
1361: PrintCharInA    E635   0310 0312 0697 0704 0818 0820 0826 0836 1075 1402
1369: PrintCharInE    E638   1356 1363
1378: PrintCrLf       E640   0307 0688 0705 0813 1056 1215 1393
1391: PrintCrLfStringNull E651   0875 0968 1027 1031 1083 1233 1410
1408: PrintNoFile     E661   0786 0893 0959
1354: PrintSpace      E631   0824 0828 0842
1396: PrintStringNull E656   0386 1404
0063: QMARK           003F   0528 0553 0703 0777
0529: QuestionMarkCount E16E   0535
0534: QuestionMarkCount1 E173   0532
0089: RAM             0000   0091 0092 0093 0095 0098 0101 0104 0109 0111
0343: ReadCommand     E065   0313 0877
0231: RecordsPerBlock 0010
0215: RecordsPerExtent 0080
0208: recordsPerSector 0004   0231 0246
1305: RenameFile      E610   0955
1509: RestoreDisk     E6D2   0963 1086 1170 1228 1456
1455: RestoreDiskAtCmdEnd E68E   0854 0894 0956 0960 0969 1035 1071 1081 1234
1502: ReturnNumericValue E6D0   1488 1491
0066: RUBOUT          007F
0446: SaveUserAndDisk E106   0394 1218
1529: SearchForFirst  E6E9   1524
1536: SearchForNext   E6EE   0851
0260: SectorMask      0003
0225: SectorsPerBlock 0004   0229 0231 0234 0240 0260
0235: SectorsPerCylinder 0024   0238 0239
0224: SectorsPerTrack 0012   0233 0235 0246
1251: SelectDisk      E5E8   0300 0351 0383 0438 0442 1129 1224 1450 1518
1565: selectedDisk    E71E   0322 0478 0505 0909 0939 1123 1172 1176 1443 1463 1475 1510
0059: SEMICOLON       003B   0637
1311: SetDefaultDMA   E615   1034 1217
1440: SetDiskForCmd   E67C   0768 0889 0911 0986 1052 1138
1315: SetDMA          E618   0317 1010 1150
0509: SetFileName     E150   0501
0459: SetPage0CurDisk E115   0398 1128 1223
0513: SetType         E155
1330: SetUser         E624   0292 1112
0050: SPACE           0020   0601 0614 0626 0667 0692 0771 1110 1119 1136 1191 1355 1462 1487
1579: Stack           E7F0   0285 0306 1222
0730: submitCR        E2BD   0358
0724: submitExtent    E2A9
0722: submitFCB       E29E   0353 0359 0377 0439
0720: submitFlag      E29D   0295 0344 0432
0726: submitFWF       E2AB   0370
0729: submitMap       E2AD
0728: submitRC        E2AC   0356 0375
0725: submitS1        E2AA
0727: submitS2        E2AB
0723: submitType      E2A6
0237: SystemSectors   0011   0238
0047: TAB             0009
1559: Token1          E6FD   0473 0655 0769 0890 0917 0950 0954 0987 1011 1020 1059 1109 1118 1134 1151 1174 1182 1442 1461 1483 1523 1544
1560: Token2          E70D   0470 0918 1178
1569: tokenStart      E71F   0481 0689
0099: TopRAM          0007
0234: TotalNumberOfBlocks 02D0
0233: TotalNumberOfSectors 0B40   0234 0239
0111: TPA             0100   0999 1146 1221
0223: TracksPerHead   0050   0233
0025: TRUE            FFFF
0562: TruncateElement E18A   0566
0064: UNDER_SCORE     005F   0631
0421: UpCase          E0E5   0407
0404: UpCaseLoop      E0D4   0409
0498: UseCurrentDisk  E143   0488
0503: UseTokensDisk   E14A   0494
0091: WarmBoot        0000
0030: WORD            0002
0171: WriteAllocated  0000
0173: WriteCleanBuffer 0002
0172: WriteDirectory  0001
1291: WriteSeq        E604   1012
1582: ZZ_MemoryLeft   00DC
