; Utilities.Z80
;------------------------------ Get The File -------------------------------;	
GetTheFile:
;   Is there a file on the command line ?

	LD		A,(FCB1 + 1)				; First char in file name
	CP		SPACE						; Is it Blank ?
	CALL	Z,askForFile				;  yes, ask the user for the file
;	CALL	CopyFileFCB1				; move the FCB

	LD		DE,FCB1						; Point at the file from CMD line
	CALL	OpenFile					; Open the file
	INC		A							; -1 +1 = 0
	RET		NZ							; File is now open
	LD		DE,FCB1						; Point at the file from CMD line
	CALL	MakeFile					; Make a new File
	INC		A							; -1 +1 = 0
	RET		NZ							; New File available

	LD		BC,msgBadMake
	CALL	printCrLfStringNull
	JP		Exit

Exit:
	LD		A,(file1Open)
	CP		TRUE						; Do we have an open file ?
	JR		NZ,Exit1					; no, skip the close
	LD		DE,FCB1						; Point at file1's FCB
	CALL	CloseFile					; Close File
Exit1:
	LD		BC,msgByeBye
	CALL	printCrLfStringNull
	RET

;---------------------------- Ask For The File -----------------------------;	
askForFile:
	XOR		A							; Set Acc to Zero
	CALL	FillCmdBuffer				; Initialize command buffer


	LD		BC,msgAskForFile
	CALL	printCrLfStringNull
	CALL	CommandPrompt

	LD		DE,commandBuffer
	LD		A,15
	LD		(DE),A						; Limit to full file name

	CALL	ReadString					; Read user's input

	CALL	Exit
	NOP
	HALT

;---------------------------- Fill Command Buffer --------------------------;
; Fills the command/readFile buffer with value in ACC.
; Registers BC,DE & HL are preserved
FillCmdBuffer:
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD		HL,commandBuffer
	LD		(HL),A
	LD		DE,commandBuffer +1
	LD		BC,BuffSize -1
	LDIR								; Clear command buffer
	POP		BC
	POP		DE
	POP		HL
	RET

;------------------------------ Command Prompt -----------------------------;
CommandPrompt:
	LD		E,STAR						; nnnn *
	CALL	UserPrompt
	RET
;------------------------------- Input Prompt ------------------------------;
InputPrompt:
	LD		E,COLON						; nnnn :
	CALL	UserPrompt
	RET
;-------------------------------- UserPrompt -------------------------------;
; E -> Char to prompt
UserPrompt:
	PUSH	DE							; Save prompt
	CALL	PrintLineNumber
	CALL	printSpace
	POP		DE							; Get prompt char
	CALL	printCharInE
	CALL	printSpace
	RET


;------------------------------ Copy File FCB1 -----------------------------;


;-------------------------- Increment Line Pointer -------------------------;
IncrementLinePointer:
		PUSH	HL							; Save Register
		LD		HL,(activeLinePointer)			; Get current position
		INC		HL							; Increment it
		LD		(activeLinePointer),HL
		POP		HL							; Restore register
		RET
		
;-------------------------- Decrement Line Pointer -------------------------;
DecrementLinePointer:
		PUSH	HL							; Save Register
		LD		HL,(activeLinePointer)			; Get current position
		LD		A,L
		ADD		A,H
		RET		Z							; Return at 0
		DEC		HL							; Decrement it
		LD		(activeLinePointer),HL
		POP		HL							; Restore register
		RET

;----------------------------- Set LinePointer -----------------------------;
; HL <- New Line number
SetLineNumber:
	LD		(activeLinePointer),HL
	RET
;---------------------------- Print Line Number ----------------------------;
PrintLineNumber:
	CALL	printCrLf
	LD		HL,(activeLinePointer)			; get current line number
	LD		IX,LineNumber
	CALL	HexToASCIIbuff				; make ASCII
	
	LD		HL,LineNumber				; Point at the buffer
	LD		B,04						; Set loop counter up
	LD		A,(HL)						; Get 1st value
	CP		ASCII_ZERO					; Leading value 0?
	JR		Z,PrintLineNumber1			; Skip if yes
	CALL	printCharInA				; print leading char

PrintLineNumber1:
	INC HL
	LD		A,(HL)
	PUSH	HL
	CALL	printCharInA
	POP		HL
	DJNZ	PrintLineNumber1
	CALL	printSpace
	RET

;------------------------------- Print Space -------------------------------;
printSpace:
	LD		E,SPACE						; Load Space
	JR		printCharInE				; Go Print it  * Save BC

;------------------------------- printCharInA ------------------------------;
; Print character
; On Entry A = Character to Send to Console
printCharInA:
	LD		E,A							; move char to E
	JR		printCharInE

;------------------------------- printCharInE ------------------------------;
; Print character
; On Entry E = Character to Send to Console
; Preserves BC								;
printCharInE:
	PUSH	BC							; Preserve BC
	CALL	ConsoleOut					; Send the char to the console
	POP		BC							; Restore BC
	RET

;-------------------------------- CR / LF ----------------------------------;
;Sent Carriage Return Line Feed to Console
printCrLf:
	LD		E,CR						; Load Carriage Return
	CALL	ConsoleOut					; Send the char to the console
	LD		E,LF						; Load Line Feed
	CALL	ConsoleOut					; Send the char to the console
	RET
;------------------------------ CR / LF Safe --------------------------------;
;Sent Carriage Return Line Feed to Console
printCrLfSafe:
	PUSH	BC							; Preserve BC
	LD		E,CR						; Load Carriage Return
	CALL	ConsoleOut					; Send the char to the console
	LD		E,LF						; Load Line Feed
	CALL	ConsoleOut					; Send the char to the console
	POP		BC							; Restore BC
	RET

;----------------- Print (CRLF then ) Null Terminated String ---------------;
;print CRLF then null terminated string at (BC)
printCrLfStringNull:
	PUSH	BC							; Save string pointer
	CALL	printCrLf					; Send CR/LF
	POP		HL							; Restore pointer & fall thru
;print null terminated string from (HL)
printStringNull:
	LD		A,(HL)						; Get the next character
	OR		A							; Is it the Null terminator ?
	RET		Z							;  exit if yes
	INC		HL							; Move string pointer
	PUSH	HL							; Save for next iteration
	LD		E,A							; Character
	CALL	ConsoleOut					; Send the char to the console
	POP		HL							; string pointer
	JR		printStringNull				; Loop for more
	
;----------------- Print (Null Terminated String ) then CRLF ---------------;
;print null terminated string from (HL)
printStringNullCrLf:
	CALL	printStringNull				; Print null terminated String
	CALL	printCrLfSafe				; Print CR/LF saving BC
	RET
;------------------------ Get Number From Command Line ---------------------;
; Get number from the command line
; Exits with A = Value
;?GetNumberFromCmdLine:
;?	CALL	ParseToken1					; Get token
;?	LD		A,(selectedDisk)			; Get currently selected disk
;?	OR		A							; Is it current default disk ?
;?	JP		NZ,CommandError				;  no, then error exit
;?; convert the byte value in Token1 to binary
;?
	LD		HL,0000
	LD		BC,0000						; Clear the registers

;	LD		IX,Token1 + 1   **********
CalculateNumber:
	LD		A,(IX + 0)					; Get Character
	INC		IX							; Adjust for next time around
	CP		SPACE						; Terminating character ?
	JR		Z,ReturnNumericValue		;  get out if yes
	SUB		ASCII_ZERO					; Make binary
	CP		0AH							; Is it a digit ?
	JR		NC,ReturnNumericValue		;  get out if no
	ADD		HL,HL						; Prior value * 2
	PUSH	HL							; Move *2
	POP		DE							;  to DE
	ADD		HL,HL						; Prior value * 4
	ADD		HL,HL						; Prior value * 8
	ADD		HL,DE						; Add * 2 gives Prior value * 10
	LD		C,A							; Get this digit
	ADD		HL,BC						; and add it
	JR		CalculateNumber

ReturnNumericValue:
	LD		A,L							; Put result in Acc
	RET

;------------------------ Get Number From Command Line ---------------------;
;----------------------------- Hex To ASCII Buffer -------------------------;
; HL  -> Dividend
; IX  -> ASCII buffer
HexToASCIIbuff:
;	LD		IX,LineNumber				; Set up buffer Pointer
			
	LD		DE,2710H					; 10,000D, 2710H 
	CALL	HexToASCIIdigit						; Get digit4
			
	LD		DE,03E8H					; 1,000D, 03E8H 
	CALL	HexToASCIIdigit						; Get digit3
			
	LD		DE,64H						; 100D, 64H 
	CALL	HexToASCIIdigit						; Get digit2
			
	LD		DE,0AH						; 10D, 0AH 
	CALL	HexToASCIIdigit						; Get digit1
			
	LD		A,L							; Get digit0
	ADD		A,ASCII_ZERO				; Make ASCII
	LD		(IX + 0),A					; Put it in Buffer

	RET									; Exit
			
;----------------------------- Hex To ASCII Buffer -------------------------;

;----------------------------- Hex To ASCII Digit --------------------------;
; HL  -> Dividend
; DE  -> Divisor
; IX  -> ASCII buffer

; HL  <- Remainder
; IX  <- ASCII buffer + 1
HexToASCIIdigit:
		CALL	Divide					; Get value
		ADD		A,ASCII_ZERO			; Make ASCII
		LD		(IX + 0),A				; Put it in Buffer
		INC		IX						; Increment buffer pointer
		PUSH	BC						; Get remainder
		POP		HL						; Put into HL for return
		RET								; Exit
;----------------------------- Hex To ASCII Digit --------------------------;

;----------------------------------- Divide --------------------------------;
; HL  -> Dividend
; DE  -> Divisor
; BC  <- Remainder
; ACC <- Result
	
Divide:
	LD		A,-1				; Initialize Acc
	
Divide1:
	PUSH	HL					; Want to save
	POP		BC					;  what will be the remainder
	INC		A					; Keep count
	AND		A					; Clear the CY flag
	SBC		HL,DE				; Poor man's Divide
	JR		NC,Divide1			;  loop if more 
	RET							;  else return
	
	
;----------------------------------- Set DMA -------------------------------;
SetDMA:
	LD		C,fSetDMA
	JP		BDOS						; Set the disk read buffer
	
;------------------------------- Read Sequential ---------------------------;
ReadSeq:
	LD		C,fReadSeq
	JP		BDOS						; Read next record

;---------------------------------- Open File ------------------------------;	
OpenFile:
	LD		C,fOpenFile
	JP		BDOS						; Open the file

;---------------------------------- Make File ------------------------------;
MakeFile:	
	LD		C,fMakeFile					; Make a new File
	JP		BDOS
	
;---------------------------------- Close File -----------------------------;
CloseFile:	
	LD		C,fCloseFile
	JP		BDOS						; Close File
	
;---------------------------------- Close File -----------------------------;
ReadString:
	LD		C,fReadString
	JP		BDOS						; Read user's input	

;---------------------------------- Console Out ----------------------------;
ConsoleOut:
	LD		C,fConsoleOut	
	JP		BDOS						; Send Char in E to Console
	
	
;------------------------------ Application Init ---------------------------;
appInit:
	LD		A,(BDOS + 2)				; Get BDOS start page
	SUB		1							; Find the page before that
	LD		H,A							; Move to H
	LD		L,0A0H
	LD		SP,HL						; Make stack 160 bytes
	LD		L,00H
	LD		(endOfBuffer),HL			; save top of buffer
	LD		HL,EndOfCode				; Find start of Buffer
	INC		H,
	LD		L,0							; Start buffer on page boundary
	LD		(startOfBuffer),HL			; Save beginning of buffer
	LD		HL,0000
	LD		(activeLinePointer),HL			; Initialize the line pointer
	LD		(readBufferPointer),HL			; Initialize the buffer pointer
	XOR		A
	LD		(lineIndex),A				; Initialize the line index

	JP		Begin						; Do the Application
	
