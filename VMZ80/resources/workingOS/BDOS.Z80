;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
 ; BDOS.Z80
 ;  in process Search For First (11H)

 ; 2019-02-04 Fixed bdosStack problem 
 ; 2019-01-10	Last rev before remaking  FInd nearest Block
 ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
 ; 2018-12-28 Started to refactor to Z80 idiom
 ; 2018-03-31 added vector for BDOS Call 5 -ListOut
 ; 2018-03-02 Refactored the CP/M Suite
 ; 2018-02-12 fixed allocate 16 bit problem
 ; 2014-01-16 extended from part of newOS (newBDOS)
 ; 2014-03-14  :  Frank Martyn
fcbExtIndexLSB	EQU		0CH			; 12 
fcbExtIndexMSB	EQU		0EH			; 14   Bit 7 = Write protected 

	$Include ./stdHeader.Z80
	$Include ./osHeader.Z80
	$Include ./diskHeader.Z80

VERSION			EQU		20H				; Version 2.0
STACK_SIZE		EQU		20H				; Make stack big enough
EOD				EQU		-1				; End of Directory

;************************ BIOS Function Constants ***************************;
bcBoot		EQU		BIOSStart+3*0		; Cold Boot function	             ;
bcWboot		EQU		BIOSStart+3*1		; Warm Boot function                 ;
bcConst		EQU		BIOSStart+3*2		; Console Status function            ;
bcConin		EQU		BIOSStart+3*3		; Console Input function             ;
bcConout	EQU		BIOSStart+3*4		; Console Output function            ;
bcList		EQU		BIOSStart+3*5		; List Output function               ;
bcPunch		EQU		BIOSStart+3*6		; Punch Output function              ;
bcReader	EQU		BIOSStart+3*7		; Reader Input function              ;
bcHome		EQU		BIOSStart+3*8		; Disk Home function                 ;
bcSeldsk	EQU		BIOSStart+3*9		; Select Disk function               ;
bcSettrk	EQU		BIOSStart+3*10		; Set Track function                 ;
bcSetsec	EQU		BIOSStart+3*11		; Set Sector function                ;
bcSetdma	EQU		BIOSStart+3*12		; Set DMA function                   ;
bcRead		EQU		BIOSStart+3*13		; Read Disk function                 ;
bcWrite		EQU		BIOSStart+3*14		; Write Disk function                ;
bcListst	EQU		BIOSStart+3*15		; List Status function               ;
bcSectran	EQU		BIOSStart+3*16		; Sector Translate                   ;
;************************ BIOS Function Constants ***************************;

;============================================================================;
;	BDOS                                                                     ;
; Calling into   :                                                           ;
;					Register  C - Contains BDOS Function Code                ;
;					Register  A - Holds the Byte argument if any             ;
;					Register DE - Holds the Word argument if any             ;
; Returning from :                                                           ;
;					Register  A - The Byte return value if any               ;
;					Register HL - The Word return value if any               ;
;                   ( Register A=L and B=H)                                  ;
;============================================================================;


	ORG	BDOSBase

;===========================BDOS Entry=======================================;
;BDOSEntry:                                                                  ;
																			 ;
																			 ;
 BdosStart:                                                                  ;
;	LD		A,C                                                              ;
; 	LD		(FunctionValue),A			; Save the function number           ;
																			 ;
; Save Calling Arguments                                                     ;
	LD		(paramDE),DE				; Save the Word Argument             ;
	LD		A,E	                                                             ;
	LD		(paramE),A					; Save the Byte argument             ;
; Save users Stack pointer                                                   ;
	LD		(usersStack),SP         	; Save the User's stack				 ;
	LD		SP,bdosStack				; We will use our own stack			 ;
	                                                                         ;
; initialize variables                                                       ;
	LD		HL,0000H                                                         ;
	LD		(exitParameterWord),HL		; Assume all is well for return      ;
	XOR		A                                                                ;
	LD		(fcbDisk),A					; Initialize to 00                   ;
	LD		(fResel),A					; Clear re selection flag            ;
	                                                                         ;
; Set up for return to caller when Function Completes                        ;
	LD		HL,ReturnToCaller                                                ;
	PUSH	HL							;Set up to ReturnToCaller            ;
	                                                                         ;
; is it a valid function number ?	                                         ;
;	LD		A,(FunctionValue)			; Get the Function Number            ;
	LD		A,C                                                              ;
	CP		functionCount				; make sure its a good number        ;
	RET		NC							; exit if not a valid function       ;
																			 ;
; Calculate the index and get vector to go to	                             ;
	LD		C,E							; Assume byte argument               ;
	LD		HL,functionTable			; Get table base                     ;
	LD		E,A							; Function number in E               ;
	LD		D,0                                                              ;
	ADD		HL,DE						; Have byte location                 ;
	ADD		HL,DE						;  but we want a Word offset         ;
	LD		E,(HL)						; Get LSB of vector                  ;
	INC		HL                                                               ;
	LD		D,(HL)						; Get MSB of vector                  ;
	EX		DE,HL						; Vector now in HL                   ;
																			 ;
; Vector to Function is in HL                                                ;
	JP		(HL) 						; Put it into the Program Counter    ;
;===========================BDOS Entry=======================================;
;===========================BDOS Exit =======================================;
;arrive here at end of processing to return to user                          ;
ReturnToCaller:                                                              ;
	LD		A,(fResel)					; get re-selection flag              ;
	OR		A							; is it set?                         ;
	JR		Z,ReturnToCaller1                                                ;
 ;re-selection  may have taken place                                         ;
	LD		HL,(paramDE)                                                     ;
	LD		(HL),0                                                           ;
	LD		A,(fcbDisk)                                                      ;
	OR		A							; Disk = 0?                          ;
	JR		Z,ReturnToCaller1			; exit if yes                  		 ;
																			 ;
	LD		(HL),A                                                           ;
	LD		A,(entryDisk)				; get back original Disk             ;
	LD		(paramE),A					; and select it                      ;
	CALL	SelectCurrent                                                    ;
																			 ;
ReturnToCaller1:                                                             ;
	LD		HL,(usersStack)                                                  ;
	LD		SP,HL						; restore callers stack              ;
	LD		HL,(exitParameterWord)                                           ;
	LD		A,L                                                              ;
	LD		B,H							; BA = exitParameterWord             ;
	RET                                                                      ;
;===========================BDOS Exit =======================================;

;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
functionTable:                                                               ;
	DW		vSystemReset				;   0 - System Reset                 ;
	DW		vConsoleIn					;   1 - Console Input                ;
	DW		vConsoleOut					;   2 - Console Output               ;
	DW		vReaderIn					;   3 - Reader Input                 ;
	DW		vPunchOut                   ;   4 - Punch Output                 ;
	DW		vListOut					;   5 - List Output                  ;
	DW		vDirectConIO				;   6 - Direct Console I/O           ;
	DW		vGetIOBYTE					;   7 - Get I/O Byte                 ;
	DW		vSetIOBYTE					;   8 - Set I/O Byte                 ;
	DW		vPrintString				;   9 - Print String                 ;
	DW		vReadString					;   A - Read Console String          ;
	DW		vGetConsoleStatus			;   B - Get Console Status           ;
diskf	EQU	($-functionTable)/2			; disk functions                     ;
	DW		vGetVersion					;   C - Return Version Number        ;
	DW		vResetSystem				;   D - Reset Disk System            ;
	DW		vSelectDisk					;   E - Select Disk                  ;
	DW		vOpenFile					;   F - Open File                    ;
	DW		vCloseFile					;  10 - Close File                   ;
	DW		vFindFirst					;  11 - Search For First             ;
	DW		vFindNext					;  12 - Search for Next              ;
	DW		vDeleteFile					;  13 - Delete File                  ;
	DW		vReadSeq					;  14 - Read Sequential              ;
	DW		vWriteSeq					;  15 - Write Sequential             ;
	DW		vMakeFile					;  16 - Make File                    ;
	DW		vRenameFile					;  17 - Rename File                  ;
	DW		vGetLoginVector				;  18 - Return Login Vector          ;
	DW		vGetCurrentDisk				;  19 - Return Current Disk          ;
	DW		vSetDMA						;  1A - Set DMA address              ;
	DW		vGetAllocAddr				;  1B - Get ADDR (ALLOC)             ;
	DW		vWriteProtectDisk			;  1C - Write Protect Disk           ;
	DW		vGetReadOnlyMap				;  1D - Get Read/Only MAP	         ;
	DW		vSetFileAttributes			;  1E - Set File Attributes ??       ;
	DW		vGetDiskParamBlock			;  1F - Get ADDR (Disk Parameters)   ;
	DW		vGetSetUserNumber			;  20 - Set/Get User Code            ;
	DW		vReadRandom					;  21 - Read Random                  ;
	DW		vWriteRandom				;  22 - Write Random                 ;
	DW		vComputeFileSize			;  23 - Compute File Size            ;
	DW		vSetRandomRecord			;  24 - Set Random Record            ;
	DW		vResetDrive					;  25 - Reset Drive                  ;
	DW		DUMMY						;  26 - Access Drive (not supported) ;
	DW		DUMMY						;  27 - Free Drive (not supported)   ;
	DW		vWriteRandom0Fill			;  28 - Write random w/Fill          ;
functionCount	EQU	($-functionTable)/2 ; Number of  functions               ;
																			 ;
DUMMY:                                                                       ;
	HALT                                                                     ;
;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;

;-------------------------- System Reset - 0 (0) ----------------------------;
;  The system reset function makes CP/M do a complete reset, exactly the     ;
; same as the warm boot function invoked when you transfer control to the    ;
; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
; to 80H, marks all disks as being Read/Write status, and transfers control  ;
; to the  CCP. The CCP then outputs its prompt to the console.               ;
;																			 ;
;			Function Code	 :	C = 00H                                      ;
;			Entry Parameters:	None                                         ;
;			Exit Parameters :	Does Not Return								 ;
;																			 ;
;-------------------------- System Reset - 0 (0) ----------------------------;
vSystemReset:
	JP		bcWboot						; do a Warm Boot
		
;****************************************************************************;
;								IOByte device I/O							 ;
;****************************************************************************;
			

;-------------------------- Read Console Byte - 1 (1) -----------------------;
;  This function reads the next byte of data from the console keyboard and   ;
; puts it into register A. If the character input is a graphic character, it ;
; will be echoed back to the console. The only control characters that are   ;
; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
; of a TAB character, the BDOS outputs as many spaces as are required to     ;
; move the cursor to the next multiple of eight columns. All of the other    ;
; control characters, including CONTROL-C, are input but are not echoed.     ;
;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
; console output should also be sent to the list device. If CONTROL-S is     ;
; found, further output will be suspended until you type another character.  ;
; CONTROL-P will enable the echoing of console output the first time it is   ;
; pressed and disable it the second time. If there is no incoming data       ;
; character, this function will wait until there is one.                     ;
;                                                                            ;
; This is a blocking function                                                ;
;																			 ;
;																			 ;
;			Function Code	:	C = 01H                                      ;
;			Entry Parameters:	None                                         ;
;			Exit Parameters :	A = Data byte from console					 ;
;																			 ;
;-------------------------- Read Console Byte - 1 (1) -----------------------;
vConsoleIn:
	CALL	ConIn						; Don't come back without input
	CALL	IsPrintableASCII			; CR,LF,TAB,BACK_SPACE or GE SPACE
	RET		C							; return nothing to echo

	PUSH	AF							; Save printable character
	LD		C,A
	CALL	TabOut						; Send to console. if TAB expand
	POP		AF							; retrieve exit value

	LD		(exitParameterByte),A
	RET					

;------------------------- Write Console Byte - 2 (2) -----------------------;
;  This function outputs the data byte in register E to the console. As with ;
; function 1, if the data byte is a TAB character, it will be expanded by    ;
; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
; checks to see if there is an incoming character, and if there is,          ;
; checks to see if it is a CONTROL-S ,in which case console output is        ;
; suspended or CONTROL-P, in which case echoing of console output to the     ;
; printer is  toggled on or off                                              ;
;																			 ;
;			Function Code	:	C = 02H                                      ;
;			Entry Parameters:	E = Data byte to be output					 ;
;			Exit Parameters :	None										 ;
;																			 ;
;------------------------- Write Console Byte - 2 (2) -----------------------;
;BDOS put parameter in C before entering this routine
vConsoleOut:
	CALL	TabOut
	RET

;--------------------------- Read Reader Byte - 3 (3) -----------------------;
;   function reads the next character from the logical "reader" device into  ;
; register A. In practice, the physical device that is accessed depends      ;
; entirely on how your BIOS is configured. In some systems, there is no      ;
; reader at all; this function will return some arbitrary value such as lAH  ;
; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
; Control is not returned to the calling program until a character has been  ;
; read.                                                                      ;
;                                                                            ;
; This is a blocking function                                                ;
;																			 ;
;			Function Code	:	C = 03H                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	A = Character Input							 ;
;																			 ;
;--------------------------- Read Reader Byte - 3 (3) -----------------------;
vReaderIn:
	CALL	bcReader
	LD		(exitParameterWord),A
	RET

;--------------------------- Write Punch Byte - 4 (4) -----------------------;
;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
; specified character from register E to the logical punch device. Again,    ;
; the actual physical device used, if any, is determined by the BIOS.        ;
; There is no set standard for this device; in some systems the punch        ;
; device is a "bit bucket," so called because it absorbs all data that you   ;
; output to it.                                                              ;
;																			 ;
;			Function Code	:	C = 04H                                      ;
;			Entry Parameters:	E = Data byte to be output					 ;
;			Exit Parameters :	None										 ;
;																			 ;
;--------------------------- Write Punch Byte - 4 (4) -----------------------;
;BDOS put parameter in C before entering this routine
 vPunchOut:
	CALL	bcPunch
	RET

;---------------------------- Write List Byte - 5 (5) -----------------------;
;  This function outputs the specified byte in register E to the logical     ;
; list device. As with the reader and the punch, the physical device used    ;
; depends entirely on the BIOS.                                              ;
;																			 ;
;			Function Code	:	C = 05H                                      ;
;			Entry Parameters:	E = Data byte to be output					 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Write List Byte - 5 (5) -----------------------;
;BDOS put parameter in C before entering this routine
 vListOut:								; func5 (05 - 05) List Output
	CALL	bcList						; direct call to BIOS
	RET

;--------------------------- Direct Console I/O - 6 (6) ---------------------;
;  This function serves double duty: it both inputs and outputs characters   ;
; from the console. However, it bypasses the normal control characters and   ;
; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
; Digital Research describes it). If the value in register E is not OFFH,    ;
; then E contains a valid ASCII character that is output to the console.     ;
;  This function works well provided you never have to send a value ofOFFH   ;
; or expect to receive a value ofOOH. If you do need to send or receive pure ;
; binary data, you cannot use this function, since these values are likely   ;
; to be part of the data stream.                                             ;
;                                                                            ;
;			Function Code	:	C = 06H                                      ;
;			Entry Parameters:	E = 0FFH for Input					  		 ;
;								E = Other than 0FFH for Output				 ;
;			Exit Parameters :	A = Input byte or status					 ;
;																			 ;
;--------------------------- Direct Console I/O - 6 (6) ---------------------;
;BDOS put parameter in C before entering this routine
 vDirectConIO:
	LD		A,C
	INC		A
	JR		Z,vDirectConIO1				; 0ffh => 00h, means input mode
; send byte to console	
	CALL	bcConout					; Send the byte to the console
	RET

;read byte/status from console	
vDirectConIO1:
	CALL	bcConst						; Check Status
	OR		A							; 00 means not data ready
	JP		Z,ReturnToCaller1			; If no data return  00 to caller
	CALL	bcConin						; Data is available, get it to A
	LD		(exitParameterByte),A		; Save it
	RET

;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
; This function places the current value of the IOBYTE in register A.        ;
;                                                                            ;
; The IOBYTE structure:                                                      ;
;								+-------+-------+-------+-------+            ;
;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
;								+-------+-------+-------+-------+            ;
;				Logical Device     List | Punch | Reader|Console             ;
;                                                                            ;
;                                                                            ;
;			Function Code	:	C = 07H                                      ;
;			Entry Parameters:	None					  		  			 ;
;			Exit Parameters :	A = Current IOBYTE value					 ;
;																			 ;
;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
 vGetIOBYTE:
	LD		A,(IOBYTE)					; Get the IOBYTE
	LD		(exitParameterWord),A		; Return it to caller
	RET	
;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
; This function sets the IOBYTE         									 ;
;                                                                            ;
; The IOBYTE structure:                                                      ;
;								+-------+-------+-------+-------+            ;
;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
;								+-------+-------+-------+-------+            ;
;				Logical Device     List | Punch | Reader|Console             ;
;                                                                            ;
;                                                                            ;
;			Function Code	:	C = 08H                                      ;
;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
;			Exit Parameters :	None                                         ;
;																			 ;
;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
;BDOS put parameter in C before entering this routine
 vSetIOBYTE:
	LD		HL,IOBYTE					; point at The IOBYTE
	LD		(HL),C						; Place new vale in it
	RET

;---------------------- Display $ terminated String - 9 (9) -----------------;
;  This function outputs a string of characters to the console device. The   ;
; address of this string is in registers DE. You must make sure that the last;
; character of the string is "$"; the BDOS uses this character as a marker   ;
; for the end of the string.                                                 ;
;  The "$" itself does not get output to the console.                        ;
;                                                                            ;
; While the BDOS is outputting the string, it expands tabs as previously     ;
; described, checks to see if there is an incoming character, and checks for ;
; CONTROL-S (XOFF, which stops the output until another character is entered);
; or CONTROL-P (which turns on or off echoing of console characters to       ;
; the printer).                                                              ;
;                                                                            ;
;			Function Code	:	C = 09H                                      ;
;			Entry Parameters:	DE = Address of the first byte of the string ;
;			Exit Parameters :	None							             ;
;																			 ;
;---------------------- Display $ terminated String - 9 (9) -----------------;
vPrintString:
	LD		HL,(paramDE)				; Get address of the string
	LD		C,L
	LD		B,H							; Put it into BC for call
	CALL	Print						; out to console
	RET

;-------------------------- Read Console String - A (10) --------------------;
;  This function reads a string of characters from the console device        ;
; and stores them in a buffer (address in DE) that you define. Full line     ;
; editing is possible: the operator can backspace, cancel the line and start ;
; over, and use all the normal control functions. What you will ultimately   ;
; see in the buffer is the final version of the character string entered,    ;
; without any of the errors or control characters used to do the line editing;
;                                                                            ;
;  The buffer that you define has a special format. The first byte in the    ;
; buffer tells the BDOS the maximum number of characters to be accepted.     ;
; The second byte is reserved for the BDOS to tell you how many characters   ;
; were actually placed in the buffer. The following bytes contain            ;
; the characters of the string. Character input will cease either when a     ;
; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
; stored in the buffer as a character-it just serves as a terminator. If     ;
; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
; the "characters input" byte to O. If you attempt to input more than the    ;
; maximum number of characters, the "characters input" count will be the     ;
; same as the maximum value allowed.                                         ;
;                                                                            ;
;			Function Code	:	C = 0AH                                      ;
;			Entry Parameters:	DE = Address string buffer					 ;
;			Exit Parameters :	String Buffer with console bytes in it       ;
;																			 ;
;-------------------------- Read Console String - A (10) --------------------;
 vReadString:
	CALL	ReadString
	RET

;------------------------- Read Console Status - B (11) ---------------------;
; This function tells you whether a console input character is waiting to be ;
;processed. Unlike the Console Input functions, which will wait until there  ;
;is input,this function simply checks and returns immediately.               ;
;                                                                            ;
;			Function Code	:	C = 0BH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	A = 00H if no incoming Data					 ;
;								A = FFH	if incoming Data					 ;
;																			 ;
;------------------------- Read Console Status - B (11) ---------------------;
vGetConsoleStatus:
	CALL	ConBreak
	LD		(exitParameterByte),A
	RET

;--------------------------- Get CP/M Version - C (12) ----------------------;
;  This function tells you which version of CP/M you are currently running.  ;
; A two-byte value is returned:                                              ;
;	H = OOH for CP/M, H = OlH for MP/M                                       ;
;	L = OOH for all releases before CP/M 2.0                                 ;
;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
;		and so on for any subsequent releases.                               ;
;                                                                            ;
; This information is of interest only if your program has some version      ;
; specific logic built into it. For example, CP/M version 1.4 does not       ;
; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
; Therefore, if your program uses Random I/O, put this check at the          ;
; beginning to ensure that it is indeed running under the appropriate        ;
; version of CP/M.                                                           ;
;                                                                            ;
;			Function Code	:	C = 0CH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL =Version Number Code						 ;
;								A = FFH	if incoming Data					 ;
;																			 ;
;--------------------------- Get CP/M Version - C (12) ----------------------;
 vGetVersion:								; func12 (12 - 0C)	 Get Version
	LD		A,VERSION
	LD		(exitParameterByte),A 			;exitParameterByte = VERSION
	RET
	
;--------------------------- Get/Set User Number - 20 (32) ------------------;
;  This subroutine either sets or gets the current user number. The current  ;
; user number determines which file directory entries are matched during all ;
; disk file operations. When you call this function, the contents of the     ;
; E register specify what action is to be taken. IfE=OFFH, then the function ;
; will return the current user number in the A register. If you set E to a   ;
; number in the range 0 to 15 (that is, a valid user number), the function   ;
; will set the current user number to this value.                            ;
;                                                                            ;
;			Function Code	:	C = 0CH                                      ;
;			Entry Parameters:	E = 0FFH to get User Number  				 ;
;								  = 0 to 15 to set User Number				 ;
;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
;								A = FFH	if incoming Data					 ;
;																			 ;
;                                                                            ;
;--------------------------- Get/Set User Number - 20 (32) ------------------;
vGetSetUserNumber:
    LD		A,(paramE)
	CP		0FFH
	JR		NZ,SetUserNumber				; interrogate user code instead
	LD		A,(currentUserNumber)
	LD		(exitParameterByte),A		; exitParameterByte=currentUserNumber
	RET

SetUserNumber:
	AND		LO_NIBBLE_MASK
	LD		(currentUserNumber),A
	RET

;****************************************************************************;
;								Character Support Routines					 ;
;****************************************************************************;


;-------------------- Return a Character from the console -------------------;
;return byte from buffer or read from the console                            ;
ConIn:                                                                       ;
	LD		HL,keyboardByte 			; is there a Byte waiting?           ;
	LD		A,(HL)                                                           ;
	LD		(HL),0                                                           ;
	OR		A                                                                ;
	RET		NZ                                                               ;
																			 ;
	JP		bcConin				 		; Go get byte from Console           ;
;-------------------- Return a Character from the console -------------------;

;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
IsPrintableASCII:                                                            ;
	CP	CR                                                                   ;
	RET	Z; carriage return?                                                  ;
	CP	LF                                                                   ;
	RET	Z; line feed?                                                        ;
	CP	TAB                                                                  ;
	RET	Z; TAB?                                                              ;
	CP	CTRL_H                                                               ;
	RET	Z; backspace?                                                        ;
	CP	SPACE						; Reset Carry if ASCII printable         ;
	RET								                                         ;
;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;

;------------------ Print character from (BC) until  $ found ----------------;
Print:                                                                       ;
	LD		A,(BC)						; Get the next character             ;
	CP		DOLLAR						; Is it the end ?                    ;
	RET	Z								;  exit if yes                       ;
	INC		BC							; Update the pointer                 ;
	PUSH	BC							; Save it                            ;
	LD		C,A							; Does Byte require                  ;
	CALL	TabOut						;  special attention - check         ;
	POP		BC							; Retrieve the pointer				 ;		
	JR		Print						; Loop back                          ;
;------------------ Print character from (BC) until  $ found ----------------;

;-- Send printable character to console. Precede with Caret if needed -------;
; character is in Reg C                                                      ;
CaretOut:                                                                    ;
	LD		A,C                                                              ;
	CALL	IsPrintableASCII                                                 ;
	JR		NC,TabOut					; Skip if Caret not needed           ;
; send preceding up arrow                                                    ;
	PUSH	AF							; Save the character                 ;
	LD		C,CARET                                                          ;
	CALL	ConsoleOut					; Send Caret to Console              ;
	POP		AF							; Get the character                  ;
	OR		40H							; Make the graphic a letter          ;
	LD		C,A							; Set up to print                    ;
; fall thru to TabbOut                                                       ;
;-- Send printable character to console. Precede with Caret if needed -------;

;------------- Send printable character to console. Expand if TAB -----------;
; character is in Reg C                                                      ;
 TabOut:                                                                     ;
	LD		A,C                                                              ;
	CP		TAB							; Is it a TAB                        ;
	JP		NZ,ConsoleOut				; Go directly to ConsoleOut if not   ;
	                                                                         ;
 ; TAB encountered                                                           ;
 TabOut0:                                                                    ;
	LD		C,SPACE						; Expand TABs with SPACEs            ;
	CALL	ConsoleOut					; Send to Console                    ;
	LD		A,(columnPosition)			; Get Column position                ;
	AND		111b						; (ColumnPosition mod 8) = 0 ?       ;
	JR		NZ,TabOut0					; Do again if not                    ;
	RET                                                                      ;
;------------- Send printable character to console. Expand if TAB -----------;

;-------------------------- Send character to console -----------------------;
; C  = Character to be output                                                ;
ConsoleOut:                                                                  ;
; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
	PUSH	BC							; Save character and Count           ;
	CALL	ConBreak					; Check for screen stop key stroke   ;
	POP		BC	                                                             ;
	PUSH	BC							; Get/save character                 ;
; Send character to Console	                                                 ;
	CALL	bcConout					; Send character to the console      ;
	POP		BC                                                               ;
	PUSH	BC							; Get/save character                 ;
; is the data to be output to print device?                                  ;
	LD		A,(printEchoFlag)                                                ;
	OR		A                                                                ;
	CALL	NZ,bcList					; Send it to printer, if so          ;
	POP		BC							; Get the character                  ;
																			 ;
	LD		A,C							; Put character to ACC               ;
	LD		HL,columnPosition			; A = char, HL = .columnPosition     ;
	INC		M							; increment the ColumnPosition       ;
																			 ;
	CP		SPACE                                                            ;
	RET		NC							; Exit if ASCII printable            ;
	                                                                         ;
	CP		LF                                                               ;
	RET		NZ							; Exit if not a Line Feed            ;
										                                     ;
	LD		(HL),0						;  else force columnPosition = 0     ;
	RET	                                                                     ;
;-------------------------- Send character to console -----------------------;

;--------------------  Check for Status and Control S or C ------------------;
;  Returns:																	 ;
;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
;			ACC = 00   No data Pending										 ;
;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
;                                                                            ;
 ConBreak:                                                                   ;
	LD		A,(keyboardByte)                                                 ;
	OR		A							; If there is a char waiting         ;
	JR		NZ,ConBreak1 				;  return with FF in ACC             ;
	                                                                         ;
	CALL	bcConst						; Get status                         ;
	CP		00H							; If 00 => No data pending	         ;
	RET		Z							; Return 00 No data pending          ;
	                                                                         ;
	CALL	bcConin						; Read the byte                      ;
	                                                                         ;
	CP		CTRL_P                                                           ;
	JR		NZ,CheckCTL_S                                                    ;
;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
	LD		HL,printEchoFlag                                                 ;
	LD		A,TRUE                                                           ;
	CP		(HL)                                                             ;
	JR		NZ,ToggleFlag1                                                   ;
	LD		A,FALSE                                                          ;
ToggleFlag1:                                                                 ;
	LD		(HL),A                                                           ;
	JR		NothingWaiting                                                   ;
;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
CheckCTL_S:		                                                             ;
	CP		CTRL_S						; If it is not Stop Screen, save     ;
	JR		NZ,ConBreak0				;   and and return 0FFH              ;
																			 ;
	CALL	bcConin						; Else Read next byte                ;
	CP		CTRL_C                                                           ;
	JP		Z,WarmBoot					; do WarmBoot if  CTRL_C             ;
 NothingWaiting:                                                             ;
	XOR		A                                                                ;
	RET									; Set ACC = 0 and return             ;
 ConBreak0:                                                                  ;
	LD		(keyboardByte),A			; save the byte                      ;
 ConBreak1:                                                                  ;
	LD		A,TRUE						; return with true set in ACC        ;
	RET                                                                      ;
;--------------------  Check for Status and Control S or C ------------------;

;------------------------  Console Output Utilities -------------------------;
showHashCRLF:                                                                ;
	LD		C,HASH_TAG                                                       ;
	CALL	ConsoleOut					; Send # to console                  ;
	CALL	showCRLF                                                         ;
showHashCRLF1:                                                               ;
	LD		A,columnPosition                                                 ;
	LD		HL,startingColumn                                                ;
	CP		A,M                                                              ;
	RET		NC                                                               ;
	LD		C,SPACE                                                          ;
	CALL	ConsoleOut                                                       ;
	JR		showHashCRLF1                                                    ;
;------------------------  Console Output Utilities -------------------------;

;------------------------  Send Carriage Return and Line Feed ---------------;
showCRLF:                                                                    ;
	LD		C,CR                                                             ;
	CALL	ConsoleOut                                                       ;
	LD		C,LF                                                             ;
  	JP		ConsoleOut					; exit via ConsoleOuts RET           ;
;------------------------  Send Carriage Return and Line Feed ---------------;

;------------------------- Read a $ terminated String -----------------------;
 ;read to paramDE address (max length, current length, buffer)               ;
ReadString:                                                                  ;
	LD		A,(columnPosition)                                               ;
	LD		(startingColumn),A			; Save start for CTRL_X and CTRL_R   ;
	LD		HL,(paramDE)				; Get the start of the String        ;
	LD		C,(HL)						; Get Max Count  					 ;
	INC		HL							; Point at actual bytes read         ;
	LD		B,0							; Initialize Current Count           ;
																			 ;
	; B = Current Count                                                      ;
	; C = Maximum characters                                                 ;
	; HL= Insertion Pointer                                                  ;
																			 ;
 ; read next character, BC, HL active                                        ;
ReadNext:                                                                    ;
	PUSH	BC							; Save Current Index and Max Count   ;
	PUSH	HL							; Save pointer                       ;
ReadNext0:                                                                   ;
	CALL	ConIn						; Get the next Character             ;
	AND		ASCII_MASK					; Mask parity bit                    ;
	POP		HL							; Restore Pointer					 ;
	POP		BC							; Restore Current Index and Max Count;
;Is It Carriage Return                                                       ;
	CP		CR                                                               ;
	JP		Z,EndRead					; End the read if yes                ;
	CP		LF                                                               ;
;Is It Linefeed                                                              ;
	JP		Z,EndRead					; End the read if yes                ;
;Is It BackSpace                                                             ;
	CP		CTRL_H															 ;
	JP		Z,BSspaceBS	                                                     ;
IsItRubout:                                                                  ;
	CP		RUBOUT						; Non destructive delete             ;
	JP		Z,ItIsRubout                                                     ;
IsPhysicalEOL:                                                               ;
	CP		CTRL_E                                                           ;
	JP		Z,ItIsPhysicalEOL	                                             ;
IsItPrintToggle:                                                             ;
	CP		CTRL_P                                                           ;
	JP		Z,ItIsPrintToggle	                                             ;
IsItDeleteTheLineX:                                                          ;
	CP		CTRL_X                                                           ;
	JP		Z,DeleteTheLine				; If CTRL_X go delete the line       ;
IsItDeleteTheLineU:                                                          ;
	CP		CTRL_U                                                           ;
	JP		Z,IgnoreTheLine				; If CTRL_U ignore the line          ;
;Retype the line                                                             ;
	CP		CTRL_R 														  	 ;
	JP		Z,RepeatLine                                                     ;

;....................... Echo input back to the Console  ....................;
; Full Duplex								                                 ;
; A = Character to display	                                                 ; 
; B = current char count                                                     ;
; C = maximum buffer length                                                  ;
; HL= buffer pointer                                                         ;
;ReadEcho                                                                    ;
	INC		B							; Increment byte count		         ;
	INC		HL							; Advance the Pointer                ;
	LD		(HL),A						; Put char in buffer                 ;
																		     ;
ReadEchoRubOut:                                                              ;
  	PUSH	BC							; Save index and length              ;
	PUSH	HL							; Save the Pointer                   ;
	LD		C,A							; Get char                           ;
	CALL	CaretOut					; Output to Console (^ if needed)    ;
	POP		HL							; Restore the Pointer                ;
	POP		BC							; Restore index and length           ;
	LD		A,(HL)						; Recall char                        ;
; check for Warm Boot                                                        ;
	CP		CTRL_C                                                           ;
	LD		A,B							; Get Line position                  ;
	JP		NZ,AreWeAtEndOfBuffer		; Skip if not CTRL_C                 ;
	CP		1							; Beginning of the Line?             ;
	JP		Z,WarmBoot					;   if yes do the Boot               ;
; Check to see if we are at the end of the buffer                            ;
AreWeAtEndOfBuffer:                                                          ;
	CP		C							; Over Max ?					     ;
	JP		C,ReadNext					;  no, Go for more				     ;
																			 ;
; At the end of read                                  					     ;
EndRead:                                                                     ;
; 	POP		HL                                                               ;
	LD		HL,(paramDE)                                                     ;
	INC		HL                                                               ;
																			 ;
	LD		(HL),B						; Actual length at Pos 0 of Buffer   ;
	LD		C,CR                                                             ;
	JP		ConsoleOut					; Send CR to the Console			 ;
;....................... Echo input back to the Console  ....................;
;.......................... Backspace SPACE BackSpace .......................;
BSspaceBS:				  													 ;
	DEC		B                                                                ;
	DEC		HL                                                               ;
	PUSH	BC                                                               ;
	PUSH	HL                                                               ;
	CALL	BackUp                                                           ;
	JP		ReadNext0                                                        ;
;.......................... Backspace SPACE BackSpace .......................;	
;.......................... It is RubOut ....................................;
ItIsRubout:                                                                  ;
; RUBOUT if possible                                                         ;
	LD		A,B							; Are we at the start of the line    ;
	OR		A                                                                ;
	JP		Z,ReadNext					; then ignore and go for next char   ;
;adjust pointers back one                                                    ;
	LD		A,(HL)                      ; ACC = current character            ;
	DEC		B							; Adjust the index			    	 ;
	DEC		HL							; Adjust the pointer                 ;
	JP		ReadEchoRubOut				; Echo back - Full Duplex            ;
;.......................... It is RubOut ....................................;
;.......................... It is PhysicalEOL ...............................;
ItIsPhysicalEOL:                                                             ;
	PUSH	BC							; Save Current Index and Max Count   ;
	PUSH	HL							; Save pointer                       ;
	CALL	showCRLF					; Make new line                      ;
	JP		ReadNext0					;   and go for next char   			 ;
;.......................... It is PhysicalEOL ...............................;
;.......................... It is PrintToggle ...............................;
ItIsPrintToggle:															 ;
	PUSH	HL							; Save pointer                       ;
; Toggle the printEcho Flag                                                  ;
	LD		HL,printEchoFlag			; Point at the flag                  ;
	LD		A,TRUE						; Load ACC with TRUE                 ;
	CP		(HL)						; Is the flag true?                  ;
	JR		NZ,IsItPrintToggle1			; Skip if not                        ;
	LD		A,FALSE						;   else. load ACC with FALSE        ;
IsItPrintToggle1:                                                            ;
	LD		(HL),A						; Set the Flags new Value	         ;
	POP		HL							; Restore pointer                    ;
	JP		ReadNext					;   and for another char             ;
;.......................... It is PrintToggle ...............................;
;.......................... RepeatLine ......................................;
RepeatLine:                                                                  ;
	PUSH	BC							; Save Current Index and Max Count   ;
	PUSH	HL							;  for exit                          ;
	CALL	showHashCRLF				; Display Hash, new Line			 ;
	                                                                         ;
	LD		HL,(paramDE)				; Get start of Buffer                ;
	INC		HL							; Skip past character count          ;
																			 ;
LL1:                                                                         ;
	INC		HL							; Point at next char to display      ;
	PUSH	BC							; Save counter, in B                 ;
	PUSH	HL							; Save buffer pointer                ;
	LD		C,M							; Get the next character             ;
	CALL	CaretOut					; Display it                         ;
	POP		HL							; Restore                            ;
	POP		BC							;  the counter and pointer           ;
	DJNZ	LL1							; loop if still more to show         ;
	POP		HL							; Restore values                     ;
	POP		BC							;  from routine entry                ;
	JP		ReadNext					; Done here !                        ;
;.......................... RepeatLine ......................................;	
;.......................... Delete The Line .................................;
DeleteTheLine:                                                               ;
	POP		HL							; Adjust Stack                       ;
                               ;                                             ;
DeleteTheLine1:                                                              ;
	LD		A,(startingColumn)                                               ;
	LD		HL,columnPosition                                                ;
	CP		M							; Start of line ?                    ;
	JP		NC,ReadString				;  If yes get out and go for more    ;
	DEC		M							; Adjust the ColumnPosition          ;
	CALL	BackUp						; Clear 1 column                     ;
	JR		DeleteTheLine1				; Loop for more                      ;
;.......................... Delete The Line .................................;
;------------------------ Back-up one screen position -----------------------;
BackUp:                                                                      ;
  	CALL	BackUp1						; Send Backspace                     ;
	LD		C,SPACE						; Overwrite with SPACE               ;
	CALL	bcConout					; Overwrite with SPACE				 ;
;does not affect column count                                                ;
BackUp1:                                                                     ;
	LD		C,CTRL_H                                                         ;
	JP		bcConout					; Send Backspace                     ;
;------------------------ Back-up one screen position -----------------------;
;.......................... Ignore The Line .................................;
IgnoreTheLine:                                                               ;
	CALL	showHashCRLF				; Display Hash, new Line			 ;
	LD		C,SPACE						; We want to add a few spaces        ;
	CALL	bcConout					;  to the console                    ;
	LD		C,SPACE                                                          ;
	CALL	bcConout                                                         ;
	JP		ReadString					; Start all over                     ;
;.......................... Ignore The Line .................................;

;------------------------- Read a $ terminated String -----------------------;

;****************************************************************************
;                           DATA AREA                                       *
;****************************************************************************

;------------------------------Non Disk Data Area ---------------------------;
usersStack:			DS	2				; entry stack pointer                ;
																			 ;
keyboardByte:		DB	00				; Saved keyboard character           ;
																			 ;
printEchoFlag:		DB	00				; Controlled by ^P                   ;
																			 ;
; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
startingColumn:		DB	0				; Starting col pos after read        ;
columnPosition:		DB	0				; Current Column position            ;
																			 ;
paramE:				DS	BYTE			; Byte Argument for BDOS Call        ;
paramDE:			DS	WORD			; Word Argument for BDOS Call	     ;
exitParameterByte:						; Byte returned Value                ;
exitParameterWord:	DS	WORD				; Word                           ;
																			 ;
																			 ;
;------------------------------------ Data Area -----------------------------;



;****************************************************************************;
;								Disk I/O									 ;
;****************************************************************************;

;---------------------------- Reset Disk System - D (13) --------------------;
;  This function requests CP/M to completely reset the disk file system.     ;
; CP/M then resets its internal tables, selects logical disk A as the        ;
; default disk, resets the DMAaddress back to 0080H (the address of the      ;
; buffer used by the BDOS to read and write to the disk), and marks all      ;
; logical disks as having Read/Write status. The BDOS will then have to log  ;
; in each logical disk as each disk is accessed. This involves reading the   ;
; entire file directory for the disk and rebuilding the allocation vectors   ;
; which keep track of which allocation blocks are free and which             ;
; are used for file storage.                                                 ;
;                                                                            ;
;			Function Code	:	C = 0DH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Reset Disk System - D (13) --------------------;
vResetSystem:
  	LD		HL,0
	LD		(readOnlyVector),HL			; Clear the vectors for 
	LD		(loggedDisks),HL			;   R/O and Logged Disks
	XOR		A							; Clear the current disk
	LD		(currentDisk),A
; note that currentUserNumber remains unchanged
	LD		HL,DMABuffer
	LD		(initDAMAddress),HL			; initDAMAddress = DMABuffer
	CALL	SetDataDMA					; to data DMA address
	JP		Select
;---------------------------- Select Disk - E (14) -------------------------;
;  This function makes the logical disk named in register E the default disk;
; All subsequent references to disk files that do not specify the disk will ;
; use this default. When you reference a disk file that does have an        ;
; explicit logical disk in its name you do not have to issue another        ;
; Select Disk function; the BDOS will take care of that for you.            ;
;                                                                           ;
;  Notice the way in which the logical disk is specified in register E.     ;
; It is not the same as the disk drive specification in the first byte of   ;
; the file control block. In the FeB, a value ofOOH is used to mean         ;
; "use the current default disk" (as specified in the last Select Disk      ;
; call or by the operator on the console). With this function, a value      ;
; of OOH in register A means that A is the selected drive, a value of       ;
; 01H means drive B, and so on to OFR for drive P, allowing                 ;
; 16 drives in the system.                                                  ;
;                                                                           ;
;			Function Code	:	C = 0EH                                     ;
;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
;			Exit Parameters :	None										;
;																			;
;---------------------------- Select Disk - E (14) -------------------------;

 vSelectDisk:
	JP	SelectCurrent

;---------------------------- Open File - F (15) ---------------------------;
;  This function opens a specified file for reading or writing. The FCB,    ;
; whose address must be in register DE, tells CP/M the user number,         ;
; the logical disk, the file name, and the file type. All other bytes of    ;
; the FCB will normally be set to O.                                        ;
;  The code returned by the BDOS in register A indicates whether the file   ;
; has been opened successfully. If A contains OFFH, then the BOOS was       ;
; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
; then the file has been opened.                                            ;
;			Function Code	:	C  = 0FH                                    ;
;			Entry Parameters:	DE = Address of File Control Block			;
;			Exit Parameters :	A  = Directory Code							;
;																			;
;---------------------------- Open File - F (15) ---------------------------;
 vOpenFile:
	CALL	InitializeExtentNumberMSB		; Clear the Extent number
	CALL	ReselectDisk						; do we need to reselect disk?
	JP		OpenFile

;---------------------------- Close File - 10 (16) -------------------------;
;  This function terminates the processing of a file to which you have      ;
; written information. Under CP/M you do not need to close a file that you  ;
; have been reading. However, if you ever intend for your program to        ;
; function correctly under MP/M (the multi-user version of CP/M) you        ;
; should close all files regardless of their use.                           ;
;  The Close File function, like Open File, returns a directory code in     ;
; the A register. Register A will contain OFFH if the BOOS could not        ;
; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
; been closed.                                                              ;
;                                                                           ;
;  When the BDOS closes a file to which data has been written, it writes    ;
; the current contents of the FCB out to the disk directory, updating       ;
; an existing directory entry by matching the disk, name, type, and         ;
; extent number in the same manner that the Open File function does.        ;
; Note that the BDOS does not transfer the last record of the file to the   ;
; disk during the close operation. It merely updates the file directory.    ;
; You must arrange to flush any partly filled record to the disk. If the    ;
; file that you have created is a standard CP/M ASCII text file, you must   ;
; arrange to fill the unused portion of the record with the standard lAH    ;
; end-of-file characters as CP/M expects.                                   ;
;                                                                           ;
;			Function Code	:	C  = 10FH                                   ;
;			Entry Parameters:	DE = Address of File Control Block			;
;			Exit Parameters :	A  = Directory Code							;
;																			;
;---------------------------- Close File - 10 (16) -------------------------;
 vCloseFile:
	CALL	ReselectDisk
	JP		CloseDirEntry
;---------------------Search for First Name Match - 11 (17) ----------------;
;  This function scans down the file directory for the first entry that     ;
; matches the file name, type, and extent in the FCB addressed by DE.       ;
; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
; more character positions. Where a "?" occurs, the BDOS will match any     ;
; character in the corresponding position in the file directory. This is    ;
; known as ambiguous file name matching.                                    ;
;  The first byte of an FCB normally contains the logical disk number code. ;
; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
; and so on up to a possible maximum of 16 for disk P. However, if this     ;
; byte contains a "?", the BDOS will search the default logical disk and    ;
; will match the file name and type regardless of the user number. This     ;
; function is normally used in conjunction with the Search Next function.   ;
; Search First, in the process of matching a file, leaves certain           ;
; variables in the BDOS set, ready for a subsequent Search Next.            ;
;  Both Search First and Search Next return a directory code in the         ;
; A register. With Search First, A = OFFH when no files match the FCB,      ;
; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
;                                                                           ;
;  To locate the particular directory entry that either the Search First    ;
; or Search Next function matched, multiply the directory code returned     ;
; in A by the length of a directory entry (32 bytes). This is easily done   ;
; by adding the A register to itself five times. Then add the DMA address   ;
; to get the actual address where the matched directory entry is stored.    ;
;  There are many occasions when you may need to write a program that will  ;
; accept an ambiguous file name and operate on all of the file names that   ;
; match it. (The DIR and ERA commands built into the CCP are examples that  ;
; use ambiguous file names.) To do this, you must use several BDOS          ;
; functions: the Set DMA Address function (code 26), this function          ;
; (Search First), and Search Next (code 18). All of this is shown in the    ;
; subroutine given in Figure 5-17.                                          ;
;                                                                           ;
;                                                                           ;
;			Function Code	:	C  = 11FH                                   ;
;			Entry Parameters:	DE = Address of File Control Block			;
;			Exit Parameters :	A  = Directory Code							;
;																			;
;---------------------Search for First Name Match - 11 (17) ----------------;
 vFindFirst:
	LD		C,0							; Length assuming '?' true
	LD		HL,(paramDE)				; Get the FCB
	LD		A,(HL)						; DIsk/User No
	CP		QMARK						; Does it contain '?' ?
	JP		Z,QMarkFind					;  if Yes, skip disk reselect
										;  and reset of EXT
										
	CALL	InitializeExtentNumberMSB	; Set Ext to 0
	CALL	ReselectDisk				; Use FCB to set currentDisk
	LD		C,nameLength				; Match name,type and extent
	
 QMarkFind:
	CALL	SearchForDirectoryRecord	; Find the directory record
	JP		CopyDirEntryToUserDMA		; Move it to the User's buffer
	
 ;-----------------------------------------------------------------

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;---------------------------- Get Active Disks - 18 (24) --------------------;
; This function returns a bit map, called the login vector, in register pair ;
; HL, indicating which logical disk drives have been selected since the last ;
; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
; The bit corresponding to the specific logical disk is set to 1 if the      ;
; disk has been selected or to 0 if the disk is not currently on-line.       ;
;  Logical disks can be selected programmatically through any file operation ;
; that sets the drive field to a nonzero value, through the Select Disk      ;
; function (code 14, OEH), or by the operator entering an "X:" command       ;
; where "X" is equal to A, B, ... , P.                                       ;
;                                                                            ;
;			Function Code	:	C = 018H                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Active disk map (login vector)			 ;
;																			 ;
;---------------------------- Get Active Disks - 18 (24) --------------------;
vGetLoginVector:
	LD		HL,(loggedDisks)
	LD		(exitParameterWord),HL
	RET
;---------------------------- Get Current Disk- 19 (25) ---------------------;
;   This function returns the current default disk set by the last Select    ;
; Disk function call (code 14, OEH) or by the operator entering the          ;
; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
;                                                                            ;
;  This function returns the current default disk in coded form.             ;
; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
; If you need to convert this to the corresponding ASCII character, simply   ;
; add 41H to register A. Use this function when you convert a file name and  ;
; type in an FCB to an ASCII string in order to display it. If the first     ;
; byte of the FCB is OOH, the current default drive is to be used.           ;
; You must therefore use this function to determine the logical disk letter  ;
; for the default drive.                                                     ;
;                                                                            ;
;			Function Code	:	C = 019H                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
;																			 ;
;---------------------------- Get Current Disk- 19 (25) ---------------------;
vGetCurrentDisk:
	LD		A,(currentDisk)
	LD		(exitParameterByte),A
	RET
;---------------------------- Set DMA Address - 1A (26) ---------------------;
;  This function sets the BDOS's direct memory access (DMA) address to a new ;
; value. The name is an historic relic dating back to the Intel Development  ;
; System on which CP/M was originally developed. This machine, by virtue of  ;
; its hardware, could read data from a diskette directly into memory or      ;
; write data to a diskette directly from memory. The name DMA address now    ;
; applies to the address of the buffer to and from which data is             ;
; transferred whenever a diskette Read, Write, or directory operation is     ;
; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
; Reset Disk operation occurs, the DMA address is reset to its default       ;
; value of 0080H.                                                            ;
;                                                                            ;
;			Function Code	:	C = 0A9H                                     ;
;			Entry Parameters:	DE = DMA Address							 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Set DMA Address - 1A (26) ---------------------;
vSetDMA:
	LD		HL,(paramDE)
	LD		(initDAMAddress),HL
	JP		SetDataDMA

	;---------------------------- Get Allocation Vector - 1B (27) ---------------;
;  This function returns the base, or starting, address of the allocation    ;
; vector for the currently selected logical disk. This information,          ;
; indicating which parts of the disk are assigned, is used by utility        ;
; programs and the BDOS itself to determine how much unused space is on the  ;
; logical disk, to locate an unused allocation block in order to extend      ;
; a file, or to relinquish an allocation block when a file is deleted.       ;
;                                                                            ;
;			Function Code	:	C = 01BH                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Address of allocation vector			 ;
;																			 ;
;---------------------------- Get Allocation Vector - 1B (27) ---------------;
vGetAllocAddr:
	LD		HL,(caAllocVector)
	LD		(exitParameterWord),HL
	RET

;---------------------------- Write Protect Disk - 1C (28) ------------------;
;  This function logically sets the currently selected disk to a Read-Only   ;
; state. Any attempts to execute a Write Sequential or Write Random function ;
; to the selected disk will be intercepted by the BDOS, and the following    ;
; message will appear on the console:                                        ;
;	BDOS Err on X: R/O                                                       ;
;	where X: is the selected disk.                                           ;
;                                                                            ;
;  Once you have requested Read-Only status for the currently selected       ;
; logical disk, this status will persist even if you proceed to select       ;
; other logical disks. In fact, it will remain in force until the next warm  ;
; boot or Reset Disk System function call.                                   ;
;  Digital Research documentation refers to this function code as Disk Write ;
; Protect. The Read-Only description is used here because it corresponds     ;
; to the error message produced if your program attempts to write on         ;
; the disk.                                                                  ;
;                                                                            ;
;			Function Code	:	C = 01CH                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Write Protect Disk - 1C (28) ------------------;
 ;;write protect current disk
vWriteProtectDisk:
	JP		SetDiskReadOnly

;---------------------------- Get Read-Only Map - 1D (29) -------------------;
;  This function returns a bit map in registers H and L showing which logical;
; disks in the system have been set to Read-Only status, either by the       ;
; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
; BDOS itself, because it detected that a diskette had been changed.         ;
;  The least significant bit of L corresponds to logical disk A, while the   ;
; most significant bit of H corresponds to disk P. The bit corresponding to  ;
; the specific logical disk is set to I if the disk has been set to          ;
; Read-Only status.                                                          ;
;                                                                            ;
;			Function Code	:	C = 01DH                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Read-Only Vector						 ;
;																			 ;
;---------------------------- Get Read-Only Map - 1D (29) -------------------;
vGetReadOnlyMap:
	LD		HL,(readOnlyVector)
	LD		(exitParameterWord),HL
	RET

;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
;  This function returns the address of the disk parameter block (DPB) for   ;
; the last selected logical disk. The DPB describes the physical             ;
; characteristics of a specific logical disk-information mainly of interest  ;
; for system utility programs.                                               ;
;                                                                            ;
;			Function Code	:	C = 1FH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
;																			 ;
;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
vGetDiskParamBlock:							; func31 (31 - 1F)
	LD		HL,(caDiskParamBlock)
	LD		(exitParameterWord),HL
	RET
 
;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
;  This function resets individual disk drives. It is a more precise version ;
; of the Reset Disk System function (code 13,ODH), in that you can set       ;
; specific logical; disks rather than all of them.                           ;
;  The bit map in DE shows which disks are to be reset. The least significant;
; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
; The bits set to I indicate the disks to be reset.                          ;
;  Note that this function returns a zero value in A in order to maintain    ;
; compatibility with MP/ M.                                                  ;
;                                                                            ;
;			Function Code	:	C = 25H                                      ;
;			Entry Parameters:	DE = Logical Drive Bit Vector					 ;
;			Exit Parameters :	A = 00H										 ;
;																			 ;
;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
;Reset Drive
 ;IN  - (DE) Drive Vector
 ;OUT - (A) 00
 vResetDrive:								; func37 (37 - 25) Reset Drive
 ; Not Yet Implemented   **************
	RET
 ;*****************************************************************

;-----------------------------------------------------------------

 ;*****************************************************************
 ;random disk read
 ;IN  - (DE) FCB address
 ;OUT - (A) 01 = Reading unwritten data
 ;	 02 = N/U
 ;	 03 = Cannot close current extent
 ;	 04 = Seek to unwriten Extent
 ;	 05 = N/U
 ;	 06 = Seek past Physical end of Disk
 vReadRandom:								; func33 (33 - 21) Read Random record
	CALL	ReselectDisk
	JP		RandomDiskRead					; to perform the disk read
 ;*****************************************************************
 ;write random record
 ;IN  - (DE) FCB address
 ;OUT - (A) 01 = Reading unwritten data
 ;	 02 = N/U
 ;	 03 = Cannot close current extent
 ;	 04 = Seek to unwriten Extent
 ;	 05 = Cannot create new Extent because of directory overflow
 ;	 06 = Seek past Physical end of Disk
 vWriteRandom:								; func34 (34 - 22) Write Random record
	CALL	ReselectDisk
	JP		RandomDiskWrite					; to perform the disk write
	;ret ;jmp goback
 ;*****************************************************************
 ;return file size (0-65536)
 ;IN  - (DE) FCB address
 vComputeFileSize:							; func35 (35 - 23) Compute File Size
	CALL	ReselectDisk
	JP		GetFileSize
 ;*****************************************************************
 ;set random record
 ;IN  - (DE) FCB address
 ;OUT - Random Record Field is set
 vSetRandomRecord:							; func36 (36 - 24) Set random Record
	JP		SetRandomRecord
;? ;*****************************************************************
;? ;Reset Drive
;? ;IN  - (DE) Drive Vector
;? ;OUT - (A) 00
;? vResetDrive:								; func37 (37 - 25) Reset Drive
;? ; Not Yet Implemented   **************
;?	RET
 ;*****************************************************************
 ;*****************************************************************
 ;Write Random With Zero Fill
 ;IN  - (DE) FCB address
 ;OUT - (A) Return Code		see Function 34
 vWriteRandom0Fill:								; func40 (40 - 28) Reset Drive
 ; Not Yet Implemented   **************
	RET
 ;*****************************************************************
 ;******************< Random I/O Stuff ****************************
 ;*****************************************************************
 ;random disk read
 RandomDiskRead:								; randiskread
	LD		C,TRUE							; marked as read operation
	CALL	RandomSeek
	CALL	Z,DiskRead						; if seek successful
	RET
 ;*****************************************************************
 ;random disk write
 RandomDiskWrite:							; randiskwrite
	LD		C,FALSE							; marked as read operation
	CALL	RandomSeek
	CALL	Z,DiskWrite						; if seek successful
	RET
 ;*****************************************************************
 ;*****************************************************************
 ;random access seek operation, C=0ffh if read mode
 ;fcb is assumed to address an active file control block
 ;(fcbS2Index has been set to 11000000b if previous bad seek)
 RandomSeek:
  	XOR		A
	LD		(seqReadFlag),A						; marked as random access operation
	PUSH	BC								; save r/w flag
	LD	HL,(paramDE)
	EX	DE,HL ; DE will hold base of fcb
	LD		HL,RANDOM_REC_FIELD
	ADD		HL,DE								; HL=.fcb(RANDOM_REC_FIELD)
	LD		A,(HL)
	AND		7FH
	PUSH	AF								; record number
	LD		A,(HL)
	RLA										; cy=lsb of extent#
	INC		HL
	LD		A,(HL)
	RLA
	AND		11111B							; A=ext#
	LD		C,A								; C holds extent number, record stacked
	LD		A,(HL)
	RRA
	RRA
	RRA
	RRA
	AND		1111B							; mod#
	LD		B,A								; B holds module#, C holds ext#
	POP		AF								; recall sought record #
											;check to insure that high byte of ran rec = 00
	INC		HL
	LD		L,(HL)								; l=high byte (must be 00)
	INC		L
	DEC		L
	LD		L,06							; zero flag, l=6
											; produce error 6, seek past physical eod
	JP	NZ,RandomSeekError
											; otherwise, high byte = 0, A = sought record
	LD		HL,NEXT_RECORD
	ADD		HL,DE								; HL = .fcb(NEXT_RECORD)
	LD		(HL),A								; sought rec# stored away
											; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
											; the r/w flag is still stacked.  compare fcb values
	LD		HL,fcbExtIndex						; extent number field
	ADD		HL,DE
	LD		A,C								; A=seek ext#
	SUB		M
	JP	NZ,RandomSeekClose					; tests for = extents
											; extents match, check mod#
	LD		HL,fcbS2Index
	ADD		HL,DE
	LD		A,B								; B=seek mod#
											; could be overflow at eof, producing module#
											; of 90H or 10H, so compare all but fwf
	SUB		M
	AND		7FH
	JP	Z,RandomSeekExit				; same?
 RandomSeekClose:
	PUSH	BC
	PUSH	DE								; save seek mod#,ext#, .fcb
	CALL	CloseDirEntry					; current extent closed
	POP		DE
	POP		BC								; recall parameters and fill
	LD		L,03							; cannot close error #3
	LD		A,(exitParameterByte)
	INC		A
	JP	Z,RandomSeekErrorBadSeek
	LD		HL,fcbExtIndex
	ADD		HL,DE
	LD		(HL),C								; fcb(fcbExtIndex)=ext#
	LD		HL,fcbS2Index
	ADD		HL,DE
	LD		(HL),B								; fcb(fcbS2Index)=mod#
	CALL	OpenFile						; is the file present?
	LD		A,(exitParameterByte)
	INC		A
	JP	NZ,RandomSeekExit					; open successful?
											; cannot open the file, read mode?
	POP		BC								; r/w flag to c (=0ffh if read)
	PUSH	BC								; everyone expects this item stacked
	LD		L,04							; seek to unwritten extent #4
	INC		C								; becomes 00 if read operation
	JP	Z,RandomSeekErrorBadSeek			; skip to error if read operation
	CALL	MakeNewFile						; write operation, make new extent
	LD		L,05							; cannot create new extent #5
	LD		A,(exitParameterByte)
	INC		A
	JP	Z,RandomSeekErrorBadSeek			; no dir space
 ; file make operation successful
 RandomSeekExit:								; seekok:
	POP		BC								; discard r/w flag
	XOR		A
	LD		(exitParameterByte),A
	RET										; with zero set

 RandomSeekErrorBadSeek:
 ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
 ; appears as overflow with file write flag set
	PUSH	HL								; save error flag
	CALL	GetExtentNumberMSB					; HL = .fcbS2Index
	LD		(HL),11000000B
	POP		HL								; and drop through
 RandomSeekError:							; seekerr:
	POP		BC								; discard r/w flag
	LD		A,L
	LD		(exitParameterByte),A					; exitParameterByte=#, nonzero
 ; SetFileWriteFlag returns non-zero accumulator for err
	JP		SetFileWriteFlag				; flag set, so subsequent close ok
	;ret
 ;
 ;*****************************************************************
 SetRandomRecord:							; setrandom
	LD	HL,(paramDE)
	LD		DE,NEXT_RECORD					; ready params for computesize
	CALL	GetRandomRecordPosition			; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
	LD		HL,RANDOM_REC_FIELD
	ADD		HL,DE								; HL = .FCB(RANDOM_REC_FIELD)
	LD		(HL),C
	INC		HL
	LD		(HL),B
	INC		HL
	LD		(HL),A								; to RANDOM_REC_FIELD
	RET
 ;*****************************************************************
 ;compute logical file size for current fcb
 GetFileSize:								; getfilesize
	LD		C,fcbExtIndex
	CALL	SearchForDirectoryRecord
 ; zero the receiving Ramdom record field
	LD	HL,(paramDE)
	LD		DE,RANDOM_REC_FIELD
	ADD		HL,DE
	PUSH	HL								; save position
	LD		(HL),D
	INC		HL
	LD		(HL),D
	INC		HL
	LD		(HL),D								; =00 00 00
 GetFileSize1:								; getsize:
	CALL	AtEndOfDirectory
	JP	Z,GetFileSizeExit
 ; current fcb addressed by dptr
	CALL	GetCurrentDirectoryRecord
	LD		DE,fcbRCIndex					; ready for compute size
	CALL	GetRandomRecordPosition
 ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
	POP		HL
	PUSH	HL								; recall, replace .fcb(Random record Field)
	LD		E,A								; save cy
	LD		A,C
	SUB		M
	INC		HL								; ls byte
	LD		A,B
	SBC		A,(HL)
	INC		HL								; middle byte
	LD		A,E
	SBC		A,(HL)								; carry if .fcb(random record field) > directory
	JP	C,GetFileSize2							; for another try
											; fcb is less or equal, fill from directory
	LD		(HL),E
	DEC		HL
	LD		(HL),B
	DEC		HL
	LD		(HL),C
 GetFileSize2:								; getnextsize:
	CALL	GetNextDirectoryRecord
	JP		GetFileSize1
 GetFileSizeExit:							; setsize:
	POP		HL								; discard .fcb(random record field)
	RET
 ;-----------------------------------------------------------------
 ;compute random record position
 GetRandomRecordPosition:				; compute$rr
	EX	DE,HL 
	ADD		HL,DE
 ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
	LD		C,(HL)
	LD		B,0							; BC = 0000 0000 ?rrr rrrr
	LD		HL,fcbExtIndex
	ADD		HL,DE
	LD		A,(HL)
	RRCA
	AND		80H							; A=e000 0000
	ADD		A,C
	LD		C,A
	LD		A,0
	ADC		A,B
	LD		B,A
 ; BC = 0000 000? errrr rrrr
	LD		A,(HL)
	RRCA
	AND		LO_NIBBLE_MASK
	ADD		A,B
	LD		B,A
										; BC = 000? eeee errrr rrrr
	LD		HL,fcbS2Index
	ADD		HL,DE
	LD		A,(HL)							; A=XXX? mmmm
	ADD		A,A
	ADD		A,A
	ADD		A,A
	ADD		A,A							; cy=? A=mmmm 0000
	PUSH	AF
	ADD		A,B
	LD		B,A
 ; cy=?, BC = mmmm eeee errr rrrr
	PUSH	AF							; possible second carry
	POP		HL							; cy = lsb of L
	LD		A,L							; cy = lsb of A
	POP		HL							; cy = lsb of L
	OR		L 							; cy/cy = lsb of A
	AND		1 							; A = 0000 000? possible carry-out
	RET
 ;-----------------------------------------------------------------

 

 ;*****************************************************************
 ;********************** Disk  I/O ********************************
 ;*****************************************************************
  ;-----------------------------------------------------------------
 ;;set file Attributes
 vSetFileAttributes:							; func30 (30 - 1E) Set File Attributes
	CALL	ReselectDisk
	CALL	SetAttributes
	JP		DirLocationToReturnLoc				; exitParameterByte=dirloc
 ;-----------------------------------------------------------------
;--------------------------- Select  Drive ---------------------------------;
; Establish the disk found in (paramE) as the current disk drive            ;
SelectCurrent:                                                              ;
	LD		A,(paramE)					; Get Disk (00H = A,01H = B ..)     ;
	LD		HL,currentDisk				; Get the current disk              ;
	CP		M							; Are the the same ?                ;
	RET		Z							; Exit if yes, nothing to do        ;
	LD		(HL),A						;  else update curretDisk and       ;
	JP		Select						;  select it                        ;
;--------------------------- Select  Drive ---------------------------------;
;--------------------------- Select Login Drive ----------------------------;
 ; select Login Drive                                                       ;
Select:                                                                     ;
 	CALL	SelectDisk					; Select the Disk                   ;
	CALL	Z,errSelect                                                     ;
	LD		HL,currentDisk													;
	LD		B,(HL)						; Get Current Disk                  ;
	LD		HL,(loggedDisks)			; Load Logged Disk MAP              ;
	CALL	IsBitSet                                                        ;
	RET		NZ							; Exit if already logged in         ;
;                                                                           ;
	LD		HL,currentDisk													;
	LD		B,(HL)						; Get Current Disk                  ;
	LD		HL,(loggedDisks)			; else log in a different disk	    ;
	CALL	SetVectorBit                                                    ;
	LD		(loggedDisks),HL			; Update the Vector                 ;
	                                                                        ;
	JP		InitDisk                                                        ;
;--------------------------- Select Login Drive ----------------------------;
;--------------------------- Select Disk ------------------------------------;
 ;*****************************************************************          ;
 ; select the disk drive given by currentDisk, and fill the base addresses   ;
 ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
SelectDisk:                                                                  ;
	LD		A,(currentDisk)				; Get current disk (0=A,1=B...)      ;
	LD		C,A							; Prepare for BIOS Call              ;
	CALL	bcSeldsk					; Select the disk                    ;
	LD		A,H							; Return Pointer to                  ;
	OR		L							;  Disk Parameter Header             ;
	RET		Z							; exit if error, with HL = 0000      ;
                                                                             ;
	LD		E,(HL)                                                           ;
	INC		HL                                                               ;
	LD		D,(HL)						; Skew Table in DE                   ;
	INC		HL							; HL = DPH + 2, Rel Pos for File     ;
	LD		(caSkewTable),DE			; Move to Current Skew Table         ;
	                                                                         ;
	LD		(caDirMaxValue),HL			; Move to Current Dir max            ;
	INC		HL                                                               ;
	INC		HL							; HL = Last Track #                  ;
	LD		(caTrack),HL				; Move to Current Track #            ;
	INC		HL                                                               ;
	INC		HL							; HL = Last Sector #                 ;
	LD		(caSector),HL				; Move to Current Sector #           ;
	INC		HL                                                               ;
	INC		HL                                                               ;
	LD		DE,caDirectoryDMA                                                ;
	LD		BC,caListSize                                                    ;
	LDIR                                                                     ;
                                                                             ;
; finish filling in address list                                             ;
	LD		HL,(caDiskParamBlock)		; Point Disk Parameter Block         ;
	LD		DE,dpbStart					; Point at BIOS DPB                  ;
	LD		BC,dpbSize                                                       ;
	LDIR								; Move DPB to current                ;
	                                                                         ;
; Determine if Byte or Word Allocation Table	                             ;
	LD		HL,(dpbDSM)					; Get max entry number               ;
	LD		A,H							; If  its 00 then < 255              ;
	LD		HL,byteAllocationFlag		; Point at the  flag				 ;
	LD		(HL),TRUE					; Assume its less than 255           ;
	OR		A							;  is the assumption confirmed ?     ;
	JR		Z,SelectDisk1				;  skip if yes                       ;
	LD		(HL),FALSE					; Fix assumption,set flag to false   ;
	                                                                         ;
; Set Sign, reset Carry and Zero to indicate success                         ;
 SelectDisk1:                                                                ;
	LD	A,TRUE                                                               ;
	OR	A								                                     ;
	RET                                                                      ;
;--------------------------- Select Disk ------------------------------------;
;--------------------------- Initialize Disk --------------------------------;
InitDisk:                                                                    ;
	LD		HL,(dpbDSM)					; Maximum allocation value           ;
	CALL	DivideHLby8					; Length of Map                      ;
	PUSH	HL							; Save Length                        ;
	PUSH	HL							; Save for end of MAP                ;
	POP		BC							; BC = dpbDSM/8                      ;
; Clear the Allocation Vector	                                             ;
	LD		HL,(caAllocVector)			; Allocation vector Start            ;
	LD		(HL),0						; Clear location                     ;
	LD		DE,(caAllocVector)                                               ;
	INC		DE							; Allocation vector Start + 1        ;
	LDIR								; Cascade 00 thru Map                ;
; Force bits at End of Map                                                   ;
	EX		DE,HL						; Put last Map byte into DE          ;
	POP		HL                                                               ;
	INC		HL                                                               ;
	CALL	MultiplyHLby8				; Blocks if all bits used            ;
	LD		BC,(dpbDSM)					; Actual block max                   ;
	INC		BC							; Now has size of the Map            ;
	XOR		A							; Clear CY                           ;
	SBC		HL,BC						; Extra unused bits                  ;
	CP		L							;  are there any                     ;
	JR		Z,Mark4Directory                                                 ;
	LD		B,L							; Number of bits to set              ;
	EX		DE,HL						; Put last Map byte into HL          ;
SetBitLoop:                                                                  ;
	SCF                                                                      ;
	RL		(HL)						; Set LSB                            ;
	DJNZ	SetBitLoop					; Loop thru the bits                 ;
	                                                                         ;
Mark4Directory:	                                                             ;
; Mark the reserved space for the directory                                  ;
	LD		HL,(dpbDABM)				; Directory block reserved bits      ;
	EX		DE,HL                                                            ;
	LD		HL,(caAllocVector)			; HL Start of Allocation Vector      ;
	LD		(HL),E                                                           ;
	INC		HL                                                               ;
	LD		(HL),D						; Put reserved blocks in Vector      ;
; end of Map                                                                 ;
; Home disk, and set current track and sector to 00                          ;
	CALL	Home                                                             ;
	LD		HL,(caDirMaxValue)                                               ;
	LD		(HL),3                                                           ;
	INC		HL                                                               ;
	LD		(HL),0						; Current Max Dir Value = 0003       ;
	CALL	SetEndDirectory				; dirEntryIndex = EOD (-1)           ;
                                                                             ;
InitDisk1:                                                                   ;
; Process the directory                                                      ;
	LD		C,TRUE						; Set flag for setting CheckSum	     ;
	CALL	ReadDirectory				; Get the directory Record           ;
	CALL	AtEndOfDirectory			; Are we Done ?                      ;
	RET		Z							;  Exit if Yes                       ;
; Not end of directory, valid entry?                                         ;
	CALL	GetCurrentDirectoryRecord	; Calculate location of the element  ;
	LD		A,emptyDir                                                       ;
	CP		M							; Is it an Empty Dir Entry           ;
	JR		Z,InitDisk1					;   Loop back if yes                 ;
; Not emptyDir, user code the same?                                          ;
	LD		A,(currentUserNumber)                                            ;
	CP		M                                                                ;
	JR		NZ,InitDisk2				; Skip if this entry not the users   ;
; Same user, check for '$' submit                                            ;
	INC		HL                                                               ;
	LD		A,(HL)                                                           ;
	SUB		DOLLAR						; Is first Char a $                  ;
	JR		NZ,InitDisk2                                                     ;
; dollar file found, mark in exitParameterByte                               ;
	DEC		A							; Set A to FFH                       ;
	LD		(exitParameterByte),A		; Return it the exit parameter       ;
 InitDisk2:                                                                  ;
; now scan the disk map for allocated blocks                                 ;
	LD		C,TRUE						; set to allocated                   ;
	CALL	ScanDiskMap                                                      ;
	CALL	SetDirectoryEntry			; Mark directory entry               ;
	JR		InitDisk1					; Loop for another entry             ;
;--------------------------- Initialize Disk --------------------------------;
;----------------------------- Open File -----------------------------------;
;search for the directory entry matching FCB at paramDE						;
 OpenFile:																	;
	LD		C,nameLength                                                   	;
	CALL	SearchForDirectoryRecord                                       	;
	CALL	AtEndOfDirectory			; Have we gone thru all the dir    	;
	RET		Z							; Exit exitParameterByte=255 if yes	;
																			;
CopyDirRecordToFCB:                                                        	;
	CALL	GetExtentAddress			; HL points to FCB's EXT           	;
	LD		A,(HL)						; Get the EXT                      	;
	PUSH	AF							; Save the FCB's EXT value         	;
	PUSH	HL							;  also save FCB's pointer         	;
	CALL	GetCurrentDirectoryRecord	; Get pointer to Dir record in HL  	;
	PUSH	HL							; Save Directory Record address    	;
																			;
	LD		DE,(paramDE)			                                       	;
	LD		BC,fcbLength                                                   	;
	LDIR								; Move dir record to FCB           	;
																			;
 ; note that entire fcb is copied, including indicators                    	;
	CALL	SetFileWriteFlag			; Set clean file flag				;
	POP		DE							; Get Directory Record address     	;
	LD		HL,fcbExtIndex				; Extent Index                     	;
	ADD		HL,DE						; Directory's EXT address          	;
	LD		C,(HL)						; Dir's EXT is in B		           	;
	LD		HL,fcbRCIndex				; Get Record Count Index           	;
	ADD		HL,DE						; Directory's RC address           	;
	LD		B,(HL)						; B holds Dir's  record count      	;
	POP		HL							; Get FCB's Extent Address         	;
	POP		AF							; Get FCB's Extent Value           	;
	LD		(HL),A						; Restore Extent Value             	;
; if user ext < dir ext then user := 128 records                           	;
; if user ext = dir ext then user := dir records                           	;
; if user ext > dir ext then user := 0 records                             	;
	LD		A,C							; Get the Dir's EXT                	;
	CP		M							; Does it match the FCB'd          	;
	LD		A,B							; Get the Dir's  record count      	;
	JP		Z,OpenSetRecordCount		; If same EXT value, use it.       	;
	LD		A,0							;   else prepare for RC = 0        	;
	JP		C,OpenSetRecordCount		; If FCB EXT > Dir EXTr            	;
	LD		A,RecordsPerExtent			;   else max record count out      	;
 OpenSetRecordCount:                                                       	;
	LD		HL,(paramDE)				; Get FCB's address                	;
	LD		DE,fcbRCIndex				; Get record count index           	;
	ADD		HL,DE						; FCB's record count               	;
	LD		(HL),A						; Set the value                    	;
	RET                                                                    	;
;----------------------------- Open File -----------------------------------;
;---------------------------- Close Directory Entry ------------------------;
 CloseDirEntry:                                                             ;
	XOR		A                                                               ;
	LD		(exitParameterByte),A		; Clear exit parameter              ;
	CALL	IsDiskWriteProtected		; Return Z set if writable          ;
	RET		NZ							; Skip close if r/o disk            ;
; check file write flag - 0 indicates written                               ;
	CALL	GetWriteFileFlagValue		; Get file's WriteFileFlag          ;
	BIT		7,A							;  Has it changed ?					;
;	AND		writeFlagMask				; Apply the RO Flag for S2          ;
	RET		NZ							; Skip close if clean file          ;
	                                                                        ;
	LD		C,nameLength                                                    ;
	CALL	SearchForDirectoryRecord	; Find the file's directory record  ;
	CALL	AtEndOfDirectory			; If EOD then there is no more      ;
	RET		Z							;  exit if at EOD                   ;
	                                                                        ;
; merge the FCB's Disk Map with the Directory record Disk Map               ;
	CALL	GetCurrentDirectoryRecord	; HL points to directory record     ;
	LD		BC,fcbDiskMapIndex			; Disk Alloc block map index        ;
	ADD		HL,BC                                                           ;
	EX		DE,HL						; DE = Directory Entry Map pointer  ;
	LD		HL,(paramDE)                                                    ;
	ADD		HL,BC						; HL = FCB Map Pointer              ;
	LD		C,(fcbLength-fcbDiskMapIndex); Size Allocation Map              ;
	                                                                        ;
MergeAllocationMaps:                                                        ;
	LD		A,(byteAllocationFlag)                                          ;
	OR		A                                                               ;
	JP		Z,MergeWordMaps				; Process Word size Block Numbers   ;
; process byte size Map	                                                    ;
	LD		A,(HL)						; FCB Block number                  ;
	OR		A							; Is it 0 ?                         ;
	LD		A,(DE)						;  anticipate yes                   ;
	JP		NZ,MergeFCBisNot0			;  Skip if no	                    ;
	LD		(HL),A						; Move Dir Entry Value to FCB		;
MergeFCBisNot0:                                                             ;
	OR		A							; Is Dir Entry Value = 0 ?          ;
	JP		NZ,MergeDirEntryNot0		; Skip if no                        ;
	LD		A,(HL)						;  else move FCB map value          ;
	LD		(DE),A						;  to Dir Entry Value 	            ;
 MergeDirEntryNot0:                                                         ;
	CP		M							; Do FCB and Dir match values       ;
	JP		NZ,CloseDirEntryError		;  If not then report error         ;
	JP		MergeMapLoop				; Go see if there is more           ;
                                                                            ;
MergeWordMaps:                                                              ;
	CALL	Merge						; If FCB map value = 0 move Dir's   ;
	EX		DE,HL                                                           ;
	CALL	Merge						; IF Dir Map value = 0 move FCB's   ;
	EX		DE,HL						; HL = FCB Map pointer, DE = Dir's  ;
	LD		A,(DE)						; Does the FCB Map value            ;
	CP		M							;  = Dir record Map pointer ?       ;
	JP		NZ,CloseDirEntryError		;  If not then report error         ;
	INC		DE                                                              ;
	INC		HL							; move on to the MSB                ;
	LD		A,(DE)                                                          ;
	CP		M							; do the check for equality         ;
	JP		NZ,CloseDirEntryError		;  If not then report error         ;
	DEC		C							; Extra count for 2 bytes           ;
MergeMapLoop:                                                               ;
	INC		DE							; Advance to the next positions     ;
	INC		HL							; in The Maps                       ;
	DEC		C							; Are we done ?                     ;
	JP	NZ,MergeAllocationMaps			;  No, do it again                  ;
                                                                            ;
; Check the EXT                                                             ;
	LD		BC,-(fcbLength-fcbExtIndex)	;Adjust to get Ext pointer          ;
	ADD		HL,BC                                                           ;
	EX		DE,HL						; HL = Directory Entry EXT pointer  ;
	ADD		HL,BC						; DE = FCB EXT Pointer              ;
	LD		A,(DE)						; FCB's extent number               ;
	CP		M							; Is it < Dir Record EXT ?          ;
	JP		C,CloseDirEntryEnd			;  we are done if yes               ;
	LD		(HL),A						; Else replace the Dir Record EXT   ;
; Update directory record count field                                       ;
	LD		BC,fcbRCIndex-fcbExtIndex	; Need to adjust to the record Count;
	ADD		HL,BC                                                           ;
	EX		DE,HL						; DE = = Directory Entry EXT pointer; 
	ADD		HL,BC						; HL = FCB EXT Pointer              ;
	LD		A,(HL)						; Copy the FCB RC to                ;
	LD		(DE),A						;  the Directory Record RC          ;
	                                                                        ;
CloseDirEntryEnd:                                                           ;
	LD		A,TRUE                                                          ;
	LD		(fcbCopiedFlag),A			;Set copied flag as true            ;
;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
	CALL	SeekDir						; Set up parameters for a Disk I/O  ;
	JP		WriteDir					; Write the directory element       ;
	RET                                                                     ;
                                                                            ;
 CloseDirEntryError:                                                        ;
	LD		HL,exitParameterByte                                            ;
	DEC		M							; Set Exit value to 0FFH            ;
	RET                                                                     ;
;---------------------------- Close Directory Entry ------------------------;

;  +++++ ;

 ;---------------
 ; set a "1" value in currentDisk position of BC
 ; return in HL
 SetCurrentDiskBit:
	PUSH	BC								; save input parameter
	LD		A,(currentDisk)
	LD		C,A								; ready parameter for shift
	LD		HL,1								; number to shift
	CALL	ShiftLeftHLbyC							; HL = mask to integrate
	POP		BC								; original mask
	LD		A,C
	OR		L
	LD		L,A
	LD		A,B
	OR		H
	LD		H,A								; HL = mask or rol(1,currentDisk)
	RET
 ;--------------

;--------------------------- Scan      Map ----------------------------------;
 ;-----------------------------------
 ; byte value from ALLOC is in register A, with shift count
 ; in register C (to place bit back into position), and
 ; target ALLOC position in registers HL, rotate and replace
 RotateAndReplace:
	RRCA
	DEC	D
	JP	NZ,RotateAndReplace					; back into position
	LD	(HL),A									; back to ALLOC
	RET
 ;-----------------------------------

 ;*****************************************************************

 ;*****************************************************************
;=========================== Disk Utilities ================================;
;--------------------------- Home The Current Disk ------------------------;
;move to home position, then offset to start of dir                        ;
Home:                                                                      ;
	CALL	bcHome						; Sets Track to 0, and checks      ;
										; if Buffer needs to be written    ;
	LD		HL,dpbOFF					; Number of tracks before directory;
	LD		C,(HL)                                                         ;
	INC		HL                                                             ;
	LD		B,(HL)                                                         ;
	CALL	bcSettrk					; Point at 1st directory position  ;
	                                                                       ;
; Set Current Track and Sector to 00                                       ;
	XOR		A							; set ACC to 00                    ;
	LD		HL,(caTrack)				                                   ;
	LD		(HL),A                                                         ;
	INC		HL                                                             ;
	LD		(HL),A                                                         ;
	LD	HL,(caSector)                                                      ;
	LD		(HL),A                                                         ;
	INC		HL                                                             ;
	LD		(HL),A                                                         ;
	RET                                                                    ;
                                                                           ;
;--------------------------- Home The Current Disk ------------------------;
;--------------------------- Set DMAs -------------------------------------;
SetDataDMA:                                                                ;
	LD		HL,initDAMAddress                                              ;
	JR		SetDMA						; Skip to complete the call        ;
;	LD		BC,initDAMAddress                                              ;
;	JP		bcSetdma					; Call BIOS to set                 ;
                                                                           ;
SetDirDMA:                                                                 ;
	LD		HL,caDirectoryDMA			; Load current directory Buffer    ;
;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
;	JP		bcSetdma					; Call BIOS to set                 ;
	                                                                       ;
SetDMA:									                              	   ;
	LD		C,(HL)                                                         ;
	INC		HL                                                             ;
	LD		B,(HL)							; parameter ready              ;
	JP		bcSetdma						; call bios to set             ;
;--------------------------- Set DMAs -------------------------------------;
;--------------------------- Read Buffer ----------------------------------;
;reads into current DMA, using current Disk,Track and Sector               ;
ReadBuffer:                                                                ;
	CALL	bcRead						; Do the read at the BIOS level    ;
	OR		A							; Check status                     ;
	JP		NZ,erPermanentNoWait		; Report if Status not OK          ;
	RET                                                                    ;
;--------------------------- Read Buffer ----------------------------------;
;--------------------------- Set Current Disk Read Only --------------------;
;set current disk to read only                                              ;
 SetDiskReadOnly:                                                           ;
	LD		HL,(readOnlyVector)			; Get the Vector                    ;
	                                                                        ;
	LD		A,(currentDisk)				; Get the current disk              ;
	LD		B,A							; Move into B                       ;
	CALL	SetVectorBit				; Set the bit	                    ;
	LD		(readOnlyVector),HL			; Update the Vector                 ;
	                                                                        ;
	LD		HL,(dpbDRM)					; Directory Max Value               ;
	EX		DE,HL                                                           ;
	LD		HL,(caDirMaxValue)			; HL = .Directory max value         ;
	LD		(HL),E                                                          ;
	INC		HL                                                              ;
	LD		(HL),D                                                          ;
	RET                                                                     ;
;--------------------------- Set disk Read Only ----------------------------;
;--------------------------- Is Disk Write Protected -----------------------;
;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
;					= reset if Write Protected		(NZ)					;
IsDiskWriteProtected:                                                       ;
	LD		HL,(readOnlyVector)			; Get Read Only Vector              ;
	LD		A,(currentDisk)				; Get current disk                  ;
	LD		B,A                                                             ;
	CALL	IsBitSet					; Check the bit                     ;
	RET									; NZ if Disk is RO                  ;
;?	LD		HL,(readOnlyVector)			; Get Read Only Vector              ;
;?	LD		A,(currentDisk)                                                 ;
;?	LD		C,A                                                             ;
;?	CALL	ShiftRightHLbyC                                                 ;
;?	LD		A,L                                                             ;
;?	AND		1BH								; 01BH                          ;
;?	RET										; non zero if nowrite           ;
;--------------------------- Is Disk Write Protected -----------------------;

;------------------------- Reselect Disk if Necessary ----------------------;
 ;check current fcb to see if reselection necessary                         ;
 ReselectDisk:                                                              ;
	LD		A,TRUE                                                          ;
	LD		(fResel),A					; Mark as possible reselect         ;
	LD		HL,(paramDE)				; Point at current FCB              ;
	LD		A,(HL)						; Load disk drive (0 = current)     ;
	AND		01FH						; Mask out user Number ??           ;
	DEC		A							; Normalized to 0..29, or 255       ;
	LD		(paramE),A					; Save drive code                   ;
	CP		30                                                              ;
	JP		NC,NoSelect					; Skip drive >= 30                  ;
											                                ;
	LD		A,(currentDisk)				; Determine the current drive       ;
	LD		(entryDisk),A				; Save it                           ;
	LD		A,(HL)                                                          ;
	LD		(fcbDisk),A					; Get calling disk                  ;
	AND		11100000B                                                       ;
	LD		(HL),A						; Preserve User Number              ;
	CALL	SelectCurrent				; Select the new disk               ;
	                                                                        ;
 NoSelect:                                                                  ;
	LD		A,(currentUserNumber)		; Get user code 0...31              ;
	LD		HL,(paramDE)				; Point at disk number              ;
	OR		M							; Combine                           ;
	LD		(HL),A						; FCB[0] = user number & disk       ;
	RET                                                                     ;
;------------------------- Reselect Disk if Necessary ----------------------;


;=========================== Disk Utilities ================================;
 
;=========================== File Utilities ================================;
;--------------------------- Set Record Variables -------------------------;
;set variables from currently FCB - Current Record, RC, EXM                ;
SetRecordVars:                                                             ;
	CALL	GetFcbRecordDetails			; DE = .RecordCount                ;
										;  and HL => .CurrentRecord        ;
	LD		A,(HL)                                                         ;
	LD		(currentFileRecord),A		; Save current record              ;
	EX		DE,HL                                                          ;
	LD		A,(HL)                                                         ;
	LD		(fcbRecordCount),A			; Save the FCBs RC                 ;
	CALL	GetExtentAddress			; HL=.FCB(fcbExtIndex)             ;
	LD		A,(dpbEXM)					; Extent mask                      ;
	AND		M							; Remove unwanted bits             ;
	LD		(extentValue),A				; Store the value                  ;
	RET                                                                    ;
;--------------------------- Set Record Variables -------------------------;
;----------------------Get File Record Count and Current Record------------;
; returns with DE pointing at RC from FCB                                  ;
;         with HL pointing at Current Record                               ;
 GetFcbRecordDetails:                                                      ;
	LD		HL,(paramDE)				; Get FCB start                    ;
	LD		DE,fcbRCIndex				; Offset to Record Count           ;
	ADD		HL,DE                                                          ;
	EX		DE,HL						; DE Points to Record Count        ;
	LD		HL,NEXT_RECORD-fcbRCIndex                                      ;
	ADD		HL,DE						; HL Points to Current Record      ;
	RET                                                                    ;
;----------------------Get File Record Count and Current Record------------;
;----------------------Get FileExtent--------------------------------------;
 ;get current extent field address to (HL)                                 ;
 GetExtentAddress:                                                         ;
	LD		HL,(paramDE)				; Get FCB                          ;
	LD		DE,fcbExtIndex				; Get EXT offset                   ;
	ADD		HL,DE						; HL=.fcb(fcbExtIndex)             ;
	RET                                                                    ;
;----------------------Get FileExtent--------------------------------------;
;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
; At Entry:	BC Contains to the Block to be modified                        ;
;			E  = TRUE if bit is to be set                                  ;
;			E  <> TRUE if bit is to be reset                               ;
; At Exit:  The target bit in the target Octet will be set/reset	       ;
 SetResetMapBit:                                                           ;
                                                                           ;
	LD		HL,0000H					; Move the block number from BC    ;
	ADD		HL,BC						;  to HL                           ;
	LD		C,E							; Move the flag to E               ;
	                                                                       ;
	LD		A,L							; LSB of the Block Number          ;
	AND		07H							; Calculate Mod(Block,8)           ;
	PUSH	AF							; Save the OctetBit                ;
	LD		B,3                                                            ;
	CALL	ShiftRightHLbyB				; Calculate Block / 8              ;
	LD		DE,(caAllocVector)			; Start Of Map                     ;
	ADD		HL,DE						; Address of targeted Octet        ;
	POP		AF                                                             ;
	LD		B,A							; Get the bit                      ;
                                                                           ;
	INC		B							; Adjust for looping               ;
	PUSH	BC							; Will need this later             ;
Left:                                                                      ;
	RL		(HL)						; Rotate the Octet                 ;
	DJNZ	Left						;  to move target bit to bit 0     ;
	POP		BC							; Restore loop limit and           ;
	SCF									;  set/reset flag                  ;
	INC		C							; was C = TRUE                     ;
	JR		Z,Right						; Skip if Set                      ;
	CCF									; Set for Reset                    ;
Right:                                                                     ;
	RR		(HL)						; Move the Octet back              ;
	DJNZ	Right						;  to its original alignment       ;
	RET                                                                    ;
;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
;--------------------- Initialize Extent Number MSB -----------------------;
 ;clear the Extent number field for user open/make (S2)                    ;
InitializeExtentNumberMSB:                                                 ;
	CALL	GetExtentNumberMSB                                             ;
	LD		(HL),0								; Set it to = 0            ;
	RET                                                                    ;
;--------------------- Initialize Extent Number MSB -----------------------;
;--------------------- Get Extent Number MSB| Write Protect ---------------;
; Get S2 value                                                             ;
;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
;			HL = Address of S2 for the FCB pointed to by paramDE           ;
GetWriteFileFlagValue:							; S2 bit 7                 ;
GetExtentNumberMSB:								; S2 bits 0-6              ;
	LD		HL,(paramDE)						; FCB address              ;
	LD		DE,fcbS2Index						; Index to value           ;
	ADD		HL,DE								; Address of value         ;
	LD		A,(HL)								; load into ACC            ;
	RET	                                                                   ;
;--------------------- Get Extent Number MSB| Write Protect ---------------;
;--------------------------- Set File Write Flag----------------------------;
;Set file write flag in FCB in (paramDE)									;
; Used to indicate the FCB is clean. No need to write on close				;
SetFileWriteFlag:                                                           ;
	CALL	GetWriteFileFlagValue		; A= Value, HL = Address of fcbS2   ;
	SET		7,(HL)						; Set the FileWriteFlag				;
	RET																		;
;?	OR		writeFlagMask				; Set the flag , bit 7 of S2        ;
;?	LD		(HL),A						; Put into FCB                      ;
;?	RET	                                                                    ;
;--------------------------- Set File Write Flag----------------------------;
;--------------------------- Reset File Write Flag--------------------------;
;Reset file write flag in FCB in (paramDE)									;
; Used to indicate the FCB is dirty. Need to write on close					;
ResetFileWriteFlag:                                                         ;
	CALL	GetWriteFileFlagValue		; A= Value, HL = Address of fcbS2   ;
	RES		7,(HL)						; Reset the FileWriteFlag			;
	RET																		;
;?	AND		0FFH-writeFlagMask			; Remove the flag bit		        ;
;?	LD		(HL),A						; Put into FCB                      ;
;?	RET	                                                                    ;
;--------------------------- Reset File Write Flag--------------------------;
;-------------------------- Compare FCB Extents ----------------------------;
; Enters:	A containing Target FCB EXT value								;
;			HL Points at Possible FCB EXT value								;
;compare extent# in A with that in C, return nonzero if they do not match	;
CompareExtents:																;
	PUSH	BC							; Save Callers Registers			;
	PUSH	AF							; Save Target FCB EXT value    		;
	LD		A,(dpbEXM)					; Load the Extent Mask         		;
	CPL									; Complement for And           		;
	LD		B,A							; Put negated Mask into B      		;
	LD		A,(HL)						; Get Possible FCBs EXT        		;
	AND		B							; Apply the Mask               		;
	LD		C,A							; Low bits removed from C      		;
	POP		AF							; Restore Target FCB EXT value 		;
	AND		B							; Apply the Mask               		;
	SUB		C							; Test if Equal ( Z Flag)      		;
	AND		maxExtValue					; Limit Size ?                 		;
	POP		BC							; Restore Callers Registers    		;
	RET                                                                		;
;-------------------------- Compare FCB Extents ----------------------------;
;---------------------Search for Directory Record --------------------------;
;        directoryFlag  ????????											;
;  Search for directory record of length C.									;
; Target is pointed to by paramDE. The whole directory is searched.			;
; If not found then dirEntryIndex is set to -1, else it points to the		;
; matched directory record													;
; Entry:	C = Search Length                                               ;
; Exit		dirEntryIndex  =	Matched directory index, if found			;
;								-1 (EOD) if there is no match				;
SearchForDirectoryRecord:                                                   ;
	LD		A,0FFH                                                          ;
	LD		(directoryFlag),A			; Initialize directory Flag         ;
	LD		HL,searchLength                                                 ;
	LD		(HL),C						; Save Search Length                ;
	LD		HL,(paramDE)				; Active FCB                        ;
	LD		(searchAddress),HL			; Start of search                   ;
	CALL	SetEndDirectory				; DirEntryIndex = -1                ;
	CALL	Home						; Reset Disk,Track, & Sector        ;
	                                                                        ;
GetNextDirectoryRecord:														;
	LD		C,FALSE                                                         ;
	CALL	ReadDirectory				; Read next Dir Record              ;
	CALL	AtEndOfDirectory                                                ;
	JP		Z,NoDirRecordsMatch				; Done if at EOD                ;
                                                                            ;
	LD		HL,(searchAddress)			; Get Current Dir Entry             ;
	EX		DE,HL						; DE=beginning of Directory Entry   ;
	LD		A,(DE)						; User Number                       ;
	CP		emptyDir					; Is Dir entry is empty             ;
	JP		Z,GetNextDirectoryRecord1	; Skip if empty                     ;
	                                                                        ;
; Check to be sure we are sill in the Directory                             ;
	PUSH	DE							; Save search address               ;
	CALL	StillInDirectory			; Still in the directorY            ;
	POP		DE							; Recall address                    ;
	JP		NC,NoDirRecordsMatch		; Get out if past directory			;
	                                                                        ;
GetNextDirectoryRecord1:													;
	CALL	GetCurrentDirectoryRecord	; Point at next directory record    ;
	LD		A,(searchLength)                                                ;
	LD		C,A							; SearchLength to c (down)          ;
	LD		B,0							; Character Index (up)              ;
	                                                                        ;
TestNextPosition:															;
	LD		A,(DE)                                                          ;
	CP		QMARK						; ? is always a char match          ;
	JP		Z,SetNextPosition				; Done with this if it is ?		;
                                                                            ;
	LD		A,B                                                             ;
	CP		fcbS1Index					; At File S1 position ?             ;
	JP		Z,SetNextPosition				; Done with this if it is ?		;
 ; not the fcbS1Index field, extent field?                                  ;
	CP		fcbExtIndex					; Past File Type position ?         ;
	LD		A,(DE)						; Get next character                ;
	JP		Z,CheckExtents				; Skip to search extent             ;
	SUB		M							; Do they match ?                   ;
	AND		07FH						; Strip MSBit                       ;
	JP		NZ,GetNextDirectoryRecord	; Skip if not matched               ;
	JP		SetNextPosition				; Matched the character             ;
;                                                                           ;
CheckExtents:																;
	CALL	CompareExtents				; Matching EXTs is work             ;
	JP		NZ,GetNextDirectoryRecord	; Get out if not matched            ;
	                                                                        ;
SetNextPosition:															;
	INC		DE							; Pointer to Looking FOR            ;
	INC		HL							; Pointer to Looking IN             ;
	INC		B							; Character Index in FCB            ;
	DEC		C							; Length of search                  ;
	JP		NZ,TestNextPosition 											;
; Match Found, entire name matches                                          ;
	LD		A,(dirEntryIndex)			; Get current Directory Index       ;
	AND		dirEntryMask				; Apply the mask                    ;
	LD		(exitParameterByte),A		; Put 0...3. Match FOund            ;
                                                                            ;
	LD		HL,directoryFlag			; Point at Directory Flag           ;
	LD		A,(HL)						; Get value                         ;
	RLA									; Set Carry if Flag = -1            ;
	RET		NC							; Return with flag still -1         ;
	                                                                        ;
	XOR		A							; Else Clear the flag               ;
	LD		(HL),A                                                          ;
	RET									;  and exit                         ;
;------                                                                     ;
 NoDirRecordsMatch:                                                         ;
	CALL	SetEndDirectory				; Set End of Directory -1           ;
	LD		A,-1						; Put Failure Code                  ;
	LD		(exitParameterByte),A		;  into return parameter            ;
	RET                                                                     ;
;---------------------Search for Directory Record --------------------------;
;---------------------------- Write Current Directory Entry ----------------;
 WriteDir:                                                                  ;
;	CALL	NewCheckSum						; initialize entry              ;
	LD		C,TRUE                                                          ;
	CALL	CheckSumUtility					; Set New CheckSum              ;
	                                                                        ;
	CALL	SetDirDMA						; Directory DMA                 ;
	LD		C,WriteDirectory				; Write type                    ;
	CALL	WriteBuffer						; Write the buffer              ;
	JP		SetDataDMA						; Reset DMA to default			;
                                                                            ;
;---------------------------- Write Current Directory Entry ----------------;
;----------------------------------- Write Buffer --------------------------;
; Write buffer and check condition. Current drive,Track, Sector and DMA     ;
; Are set up prior to calling this routine                                  ;
;                                                                           ;
; On Entry: C = 0 => normal write operation		WriteAllocated              ;
;				1 => directory write operation	WriteDirectory              ;
;				2 => start of new block			WriteCleanBuffer			;
WriteBuffer:                                                                ;
	CALL	bcWrite						; Call into BIOS                    ;
	OR		A							; Get return code                   ;
	JP		NZ,erPermanentNoWait		; Error if not 00                   ;
	RET                                                                     ;
;----------------------------------- Write Buffer --------------------------;

;=========================== File Utilities ================================;

;=========================== Directory Utilities ===========================;
;--------------------------- Set End of Directory indicator ----------------;                                     
SetEndDirectory:                                                            ;
	LD		HL,EOD						; Put -1 (0FFFFH) in index          ;                                               
	LD		(dirEntryIndex),HL                                              ;
	RET                                                                     ;
;--------------------------- Set End of Directory indicator ----------------;
;--------------------------- Are we at End Of Directory --------------------;
; Tests to see if we are at the End Of the Directory                        ;
;                                                                           ;
; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
;			 Z Flag reset if still in directory                             ;
                                                                            ;
AtEndOfDirectory:                                                           ;
	LD		HL,dirEntryIndex			; Point at LSB of Dir index         ;
	LD		A,(HL)						; Get it                            ;
	INC		HL							; Point at MSB	of Dir Index		;
	CP		M							; LSB = MSB ?                       ;
	RET		NZ							;  exit if not if different         ;
										; Same.  are they = 0ffh?           ;
	INC		A							;  if yes, A= 0, set Z flag         ;
	RET                                                                     ;
;--------------------------- Are we at End Of Directory --------------------;
;--------------------------- Get Directory Element -------------------------;
; compute the address of a directory element in Directory Buffer            ;
; Returns:  HL = Address of the specific directory Record                   ;
GetCurrentDirectoryRecord:													;
	PUSH	BC							; Save BC                           ;
	LD		HL,(caDirectoryDMA)			; Get the Directory Buffer base     ;
	LD		A,(dirBlockIndex)			; Get the index value               ;
	LD		C,A                                                             ;
	XOR		A							; Set to Zero and reset CY          ;
	LD		B,A                                                             ;
	ADC		HL,BC						; Compute the Entry Location        ;
	POP		BC							; Restore	                        ;
	RET                                                                     ;
;--------------------------- Get Directory Element -------------------------;
;--------------------------- Set Directory Entry ---------------------------;
; Will update directory if not in the directory                             ;
                                                                            ;
SetDirectoryEntry:                                                          ;
	CALL	StillInDirectory                                                ;
	RET	C								; Exit if still in the Directory  	;
																			;
; StillInDirectory will return with:                                        ;
;									DE = Directory entry number             ;
;									HL = Address of entry number + 1        ;
	INC	DE                                                                  ;
	LD	(HL),D                                                              ;
	DEC	HL                                                                  ;
	LD	(HL),E                                                              ;
	RET                                                                     ;
;--------------------------- Set Directory Entry ---------------------------;
;--------------------------- Are we sill in the Directory ------------------;
;Returns	:                                                               ;
;			CY Set   if dirEntryIndex <= Directory Max Value                ;
;			CY Reset if dirEntryIndex  > Directory Max Value                ;
;			HL = (address of Index Value) + 1                               ;
;			DE = Directory Index Value                                      ;
StillInDirectory:															;
	LD		HL,(dirEntryIndex)                                              ;
	EX		DE,HL 						; DE = directory counter            ;
	LD		HL,(caDirMaxValue)			; HL = caDirMaxValue              	;
	LD		A,E                                                             ;
	SUB		M                                                               ;
	INC		HL                                                              ;
	LD		A,D                                                             ;
	SBC		A,(HL)						; Set CY if dirEntryIndex           ;
	RET										;  <= Directory Max Value       ;
;--------------------------- Are we sill in the Directory ------------------;
;--------------------------- Scan Disk Map ---------------------------------;
; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
;                                                                           ;
; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
;           C = FALSE	reset the Map bits for each block found in FCB      ;
                                                                            ;
ScanDiskMap:                                                                ;
	PUSH	BC							; Save the Set/Reset Info           ;
	CALL	GetCurrentDirectoryRecord	; HL points at the directory record ;
	LD		DE,fcbDiskMapIndex			; DE is the index to the FCBs Map   ;
	ADD		HL,DE						; HL is now at start of the MAP     ;
	LD		C,fcbLength-fcbDiskMapIndex+1; Size of Disk Allocation Map + 1  ;
																			;
ScanDiskMap0:                                                               ;
	POP		DE							; Recall the set/reset Info         ;
	DEC		C                                                               ;
	RET		Z							; Loop once for each disk map entry ;
                                                                            ;
	PUSH	DE							; Save the Set/Reset Info           ;
	LD		A,(byteAllocationFlag)		; Is Map Byte or Word sized         ;
	OR		A                                                               ;
	JR		Z,ScanDiskMapWord			; Skip if Word Sized                ;
;  Byte Allocation scan operation                                           ;
	PUSH	BC							; Save counter                      ;
	PUSH	HL							; Save map address                  ;
	LD		C,(HL)                                                          ;
	LD		B,0							; BC=block# for Byte                ;
	JR		ScanDiskMap2                                                    ;
; Word scan operation                                                       ;
ScanDiskMapWord:                                                            ;
	DEC		C							; Adjust counter for 2 bytes        ;
	PUSH	BC							; Save counter                      ;
	LD		B,(HL)                                                          ;
	INC		HL                                                              ;
	LD		C,(HL)						; BC=block# for Word                ;
	PUSH	HL							; Save map address                  ;
	                                                                        ;
; Arrive here with BC=block#, E=0/1	                                        ;
 ScanDiskMap2:                                                              ;
	LD		A,C                                                             ;
	OR		B							; Skip if = 0000 (No Block)         ;
	CALL	NZ,SetResetMapBit			; bit set to 0/1 its in C           ;
	POP		HL                                                              ;
	INC		HL							; to next bit position              ;
	POP		BC							; recall counter                    ;
	JP		ScanDiskMap0				; for another item                  ;
                                                                            ;
;--------------------------- Scan Disk Map ---------------------------------;
;--------------------------- Get Closest Disk Block ------------------------;
; Find the closest available disk block, and mark in Map as allocated       ;
; Enter	BC	= Block number to base the search on                            ;
; Exit	HL	= 0000 if There are no available open blocks                    ;
;			= block number of available and marked block                    ;
                                                                            ;
GetClosestBlock:                                                            ;
			PUSH	BC					; save the starting Block #         ;
						                                                    ;
			LD		HL,(dpbDSM)			; Maximum allocation value          ;
			CALL	DivideHLby8			; Length of Map	                    ;
			EX		DE,HL				; put size into DE			        ;
			POP		HL					; Block number into HL              ;
			CALL	DivideHLby8			; Length of Map                     ;
			EX		DE,HL				; Size in HL, Start in DE           ;
			XOR		A					; Reset CY                          ;
			SBC		HL,DE				; Size for right                    ;
; DE = Start Index                                                          ;
; DE = Left Size                                                            ;
; HL	= Right Size                                                        ;
			PUSH	HL					; Save right size                   ;
			PUSH	DE					; Save left size & Start Index      ;
			LD		A,0FFH				; Full Octet                        ;
                                                                            ;
			LD		HL,(caAllocVector)	; Start of Map                      ;
			ADD		HL,DE				; Determine initial Octet			;
; Set up Left side                                                          ;
			POP		BC					; Left size                         ;
			INC		BC					; adjust                            ;
			PUSH	HL					; Save initial Octet                ;
			LD		DE,-1				; Flag as Left register set         ;
; HL = Initial Octet                                                        ;
; BC = Left Size                                                            ;
			EXX							; Use alternate registers           ;
			LD		DE,0000H			; Flag as Right register set        ;
			POP		HL					; Get Initial Octet                 ;
			POP		BC					; Get Right Size                    ;
			INC		BC					; adjust                            ;
LookRight:                                                                  ;
			CPI							; UnSet Bit?                        ;
			JR		NZ,FoundFreeOctet	;  Then get out of search           ;
			JP		PO,NoMoreRight		; Exhausted Map to the right        ;
			                                                                ;
			EXX							; Switch to the Left                ;
			CPD							; UnSet Bit?                        ;
			JR		NZ,FoundFreeOctet	;  Then get out of search           ;
			JP		PO,NoMoreLeft		; Exhausted Map to the right        ;
			EXX							; switch to right                   ;
			JR		LookRight			; Keep on looking                   ;
;			----------------			                                    ;
NoMoreLeft:                                                                 ;
			EXX							; Switch to Right                   ;
NoMoreLeftLoop:                                                             ;
			CPI                                                             ;
			JR		NZ,FoundFreeOctet	;  Then get out of search           ;
			JP		PO,NoFreeBlocks		; Exhausted Map to the right		;
			JR		NoMoreLeftLoop		; Keep looking                      ;
			HALT                                                            ;
NoMoreRight:                                                                ;
			EXX							; Switch to Left                    ;
NoMoreRightLoop:                                                            ;
			CPD                                                             ;
			JR		NZ,FoundFreeOctet	;  Then get out of search           ;
			JP		PO,NoFreeBlocks		; Exhausted Map to the right        ;
			JR		NoMoreRightLoop		; Keep looking                      ;
			HALT                                                            ;
NoFreeBlocks:                                                               ;
			LD		HL,0000H			; Return 0000 in HL                 ;
			RET                                                             ;
;			----------------			                                    ;
FoundFreeOctet:                                                             ;
			CP		E					; Left or Right                     ;
			JR		Z,FoundFreeOctet1	;  it was left                      ;
			DEC		HL					; Adjust for direction              ;
			JR		FoundFreeOctet2                                         ;
			                                                                ;
FoundFreeOctet1:                                                            ;
			INC		HL					; Adjust for direction              ;
FoundFreeOctet2:                                                            ;
			LD		BC,00				; need to keep track of bit         ;
FoundFreeOctet3:                                                            ;
			RLC		(HL)                                                    ;
			INC		BC                                                      ;
			JR		C,FoundFreeOctet3	; Loop if Bit 7 set                 ;
			SET		0,(HL)				; Make map bit set                  ;
			LD		B,C					; Put count in B                    ;
FoundFreeOctet4:                                                            ;
			RRC		(HL)                                                    ;
			DJNZ	FoundFreeOctet4		; Restore the Octet                 ;
			DEC		BC					; adjust for Zero based value       ;
			PUSH	BC					; Save the bit index                ;
			LD		BC,(caAllocVector)	; Get Map start                     ;
			XOR		A					; Clear CY                          ;
			SBC		HL,BC				; Get how far in the map            ;
			CALL	MultiplyHLby8			; Calculate the Octet           ;
			POP		BC					; Restore index into Octet          ;
			ADD		HL,BC				; This is the Block Number          ;
			RET                                                             ;
;--------------------------- Get Closest Disk Block ------------------------;
;---------------------------- Copy Dir Entry To User's Buffer --------------;
CopyDirEntryToUserDMA:                                                      ;
	LD		HL,(caDirectoryDMA)			; Point at Directory buffer         ;
	LD		DE,(initDAMAddress)			; Point at User's Buffer            ;
	LD		BC,cpmRecordSize			; The entire record                 ;
	LDIR								; Move it                           ;
	RET                                                                     ;
;?	LD		HL,(caDirectoryDMA)			; Get pointer to Directory buffer   ;
;?	EX		DE,HL						; put it into DE                    ;
;?	LD		HL,(initDAMAddress)			; destination is user dma address   ;
;?	LD		C,cpmRecordSize					; copy entire record            ;
;?	JP		MoveX                                                           ;
;---------------------------- Copy Dir Entry To User's Buffer --------------;

;=========================== Directory Utilities ===========================;

; GU 

;=========================== General   Utilities ===========================;

;--------------------------- Rotate HL right by value in C ----------------;
                                                                           ;
; HL = Value to be rotated Right                                           ;
;  B = Amount to shift                                                     ;
RotateRightHLbyB:                                                          ;
 		SCF								; Set carry flag, expect LSBit = 1 ;
		BIT		0,L						; is LSB set?                      ;
		JR		NZ, RotateRightHLbyB1		; Skip if LSB set              ;
		CCF								; else Clear Carry flag            ;
RotateRightHLbyB1:                                                         ;
		RR		H						; Shift thru CY                    ;
		RR		L						; ditto                            ;
		DJNZ	RotateRightHLbyB                                           ;
		RET                                                                ;
                                                                           ;
;--------------------------- Rotate HL right by value in C ----------------;
;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
; HL = Value to be shifted Right                                           ;
DivideHLby8:															   ;
		LD		B,3						; 8 = 2**3						   ;
;  B = Amount to shift                                                     ;
ShiftRightHLbyB:                                                           ;
		XOR		A						; else Clear Carry flag            ;
		RR		H						; Shift thru CY                    ;
		RR		L						; ditto                            ;
		DJNZ	ShiftRightHLbyB                                            ;
		RET                                                                ;
;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
; HL = Value to be shifted Left                                            ;
MultiplyHLby8:															   ;
		LD		B,3						; 8 = 2**3						   ;
;  B = Amount to shift                                                     ;
ShiftLeftHLbyB:                                                            ;
		XOR		A						; else Clear Carry flag            ;
		RL		L						; Shift thru CY                    ;
		RL		H						; ditto                            ;
		DJNZ	ShiftLeftHLbyB                                             ;
		RET                                                                ;
;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
;----------------------------- Merge ---------------------------------------;
; Merge Map Block Numbers between FCB and directory record                  ;
; HL has pointer to map for either dir record or FCB,                       ;
; DE has the other pointer. If HL is pointing to a non empty block, then    ;
; it just returns, Else it copies the block number to where DE is pointing  ;
                                                                            ;
 Merge:                                                                     ;
	LD		A,(HL)						; Get the first byte                ;
	INC		HL                                                              ;
	OR		M							; OR it with the second byte        ;
	DEC		HL							; Restore HL to start               ;
	RET		NZ							; Exit if both are 0s               ;
; HL points to a non Zero value	                                            ;
	LD		A,(DE)						; Get the first byte                ;
	LD		(HL),A						; Move it                           ;
	INC		DE                                                              ;
	INC		HL							; Increment both pointers           ;
	LD		A,(DE)						; Get the second byte               ;
	LD		(HL),A						; Move it                           ;
	DEC		DE                                                              ;
	DEC		HL							; Restore HL & DE to start          ;
	RET                                                                     ;
;----------------------------- Merge ---------------------------------------;


;=========================== General   Utilities ===========================;

;--------------------------- Read Directory Record -------------------------;
; read a directory entry into the directory buffer                          ;
ReadDirRecord:                                                              ;
	CALL	SetDirDMA					; System Assigned Buffer            ;
	CALL	ReadBuffer					; Go to BIOS for the read           ;
	JP		SetDataDMA					; Restore DMA                       ;
;--------------------------- Read Directory Record -------------------------;

;--------------------------- Read Directory --------------------------------;
; Read next directory entry                                                 ;
; Enter :                                                                   ;
;		C =  TRUE initializing and setting CheckSum                         ;
;		  <> TRUE Checking existing CheckSum                                ;
 ReadDirectory:                                                             ;
	LD		DE,(dpbDRM)					; Number of Dir Entries-1           ;
	LD		HL,(dirEntryIndex)			; Prior Directory Index             ;
	INC		HL							; Increment the Index               ;
	LD		(dirEntryIndex),HL			; Save current directory index      ;
	XOR		A							; Clear the CY flag                 ;
	SBC		HL,DE						; Are we at end Of the directory    ;
	JR		NZ,ReadDirectory0			;  No the process                   ;
	CALL	SetEndDirectory				;  else we are done                 ;
	RET                                                                     ;
                                                                            ;
; Calculate the entry index Position in Buffer                              ;
ReadDirectory0:                                                             ;
	LD		A,(dirEntryIndex)			; Get the index                     ;
	AND		dirEntryMask				; Determine Entry number            ;
	LD		B,fcbShift					; Shift value for Record Size       ;
ReadDirectory1:                                                             ;
	ADD		A,A                                                             ;
	DJNZ	ReadDirectory1		                                            ;
	LD		(dirBlockIndex),A			; Now save the Index into to buffer ;
	OR		A							; Is this the 1st entry?            ;
	RET		NZ							;  return if not.                   ;
	                                                                        ;
	PUSH	BC							; Save init Flag (CheckSum)         ;
	CALL	SeekDir						; Set up for Directory Read         ;
	CALL	ReadDirRecord				; Read the directory record         ;
	POP		BC							; Recall initialization flag        ;
	JP		CheckSumUtility				; Checksum the directory            ;
;--------------------------- Read Directory --------------------------------;
;--------------------------- Seek Directory --------------------------------;
 ;seek the record containing the current directory entry					;
SeekDir:                                                                    ;
	LD		HL,(dirEntryIndex)			; Directory Entry Index             ;
	LD		B,dirEntryShift				; 4 entries per record              ;
	CALL	ShiftRightHLbyB                                                 ;
	LD		(absoluteCPMRecord),HL                                          ;
	LD		(dirRecord),HL				; Save                              ;
	JP		Seek                                                            ;
;--------------------------- Seek Directory --------------------------------;
;--------------------------- Seek ------------------------------------------;
Seek:								                                        ;
	LD		BC,0FFFFH					; Initialize the track counter      ;
	LD		HL,(absoluteCPMRecord)		; Get the record in question        ;
	LD		DE,(dpbSPT)					; Get Sectors Per track             ;
																			;
Seek0:                                                                      ;
	INC		BC							; Divide the record                 ;
	XOR		A							;  by the sectors per track         ;
	SBC		HL,DE                                                           ;
	JR		NC,Seek0					;  to get the gross track number    ;
	                                                                        ;
	                                                                        ;
	ADD		HL,DE						; Gets the sector in the track      ;
	PUSH	HL							; Save Index Sector                 ;
	                                                                        ;
	LD		IX,(caTrack)                                                    ;
	LD		(IX + 0),C                                                      ;
	LD		(IX + 1),B					; Save the Gross Track              ;
	                                                                        ;
	EX		DE,HL						; Take the index from the record    ;
	LD		HL,(absoluteCPMRecord)                                          ;
	XOR		A                                                               ;
	SBC		HL,DE						;  and you get the Block start      ;
	                                                                        ;
	LD		IX,(caSector)                                                   ;
	LD		(IX + 0),L                                                      ;
	LD		(IX + 1),H					; Save the Block Start              ;
	                                                                        ;
	LD		HL,(dpbOFF)					; Get directory Offset (tracks)		;
	ADD		HL,BC						;  to add to the gross Track        ;
	PUSH	HL							;  which yields the net or          ;
	POP		BC							;  actual track for the record      ;
	CALL	bcSettrk					; Set the net (actual) track        ;
	                                                                        ;
	POP		BC							; Get the sector within the track   ;
	JP		bcSetsec					;  and set it for the seek          ;
                                                                            ;
;--------------------------- Seek ------------------------------------------;
;--------------------------- Check Sum Utility -----------------------------;
; At entry                                                                  ;
;			C  = TRUE	-  Set the Checksum values in Vector                ;
;			C <> TRUE	-  Validate Checksum value in Vector                ;
                                                                            ;
CheckSumUtility:                                                            ;
	LD		HL,(dpbCKS)                                                     ;
	LD		DE,(dirRecord)                                                  ;
	XOR		A                                                               ;
	SBC		HL,DE							; Skip if past the Directory    ;
	RET		C								;  Entries                      ;
                                                                            ;
	PUSH	BC								; Save New/Validate Flag        ;
	                                                                        ;
; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
ComputeCheckSum:                                                            ;
	LD		B,cpmRecordSize                                                 ;
	LD		HL,(caDirectoryDMA)                                             ;
	XOR                                                                     ;
ComputeCheckSum1:                                                           ;
	ADD		A,(HL)                                                          ;
	INC		HL                                                              ;
	DJNZ	ComputeCheckSum1                                                ;
; Checksum is in ACC	                                                    ;
                                                                            ;
	LD		HL,(caCheckSum)				; Address of check sum vector       ;
	LD		DE,(dirRecord)				; Index to this record              ;
	ADD		HL,DE						; Address of this record in vector  ;
	POP		BC							; Retrieve New/Validate Flag        ;
	INC		C                                                               ;
	JP		Z,SetNewCheckSum			; Set the Value if Flag was TRUE    ;
	                                                                        ;
	CP		M							; Else we are checking the value    ;
	RET		Z							; Exit if OK                        ;
; possible checksum error, are we beyond the end of the disk?               ;
	CALL	StillInDirectory                                                ;
	RET		NC							; OK, if not in the directory       ;
	CALL	SetDiskReadOnly				;  else the checksums don't match   ;
	RET									;  Set disk RO before returning     ;
                                                                            ;
 ;initializing the checksum                                                 ;
 SetNewCheckSum:                                                            ;
	LD		(HL),A                                                          ;
	RET                                                                     ;
;--------------------------- Check Sum Utility -----------------------------;


;---------------------
 ;update variables from I/O in  fcb
 UpdateRecordVars:
	CALL	GetFcbRecordDetails					; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
	LD		A,(seqReadFlag)
	LD		C,A								; =1 if sequential i/o
	LD		A,(currentFileRecord)							; get NEXT_RECORD
	ADD		A,C
	LD		(HL),A								; fcb(NEXT_RECORD)=current File Record+seqReadFlag
	EX	DE,HL 
	LD		A,(fcbRecordCount)
	LD		(HL),A								; fcb(fcbRCIndex)=fcbRecordCount
	RET
 ;---------------------
 ;set file Attributes for current fcb
 SetAttributes:
	LD		C,fcbExtIndex
	CALL	SearchForDirectoryRecord				; through file type
 SetAttributes1:
	CALL	AtEndOfDirectory
	RET	Z; exit at end of dir
	LD		C,0
	LD		E,fcbExtIndex					;copy name
	CALL	CopyDir
	CALL	GetNextDirectoryRecord
	JP		SetAttributes1
 ;
 ;*****************************************************************

 ;*****************************************************************
 ;********************** File  Routines ***************************
 ;*****************************************************************
  ;search for next occurrence of a file name
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vFindNext:									; func18: (18 - 12) Search for next
	LD	HL,(searchAddress)
	LD	(paramDE),HL
	CALL	ReselectDisk
	CALL	GetNextDirectoryRecord
	JP		CopyDirEntryToUserDMA				; copy directory entry to user
 ;-----------------------------------------------------------------
 ;search for next occurrence of a file name
 ; OUT - (A)	Directory Code
 ;delete a file
 vDeleteFile:								; func18: (19 - 13) Delete File
	CALL	ReselectDisk
	CALL	DeleteFile
	JP		DirLocationToReturnLoc
 ;-----------------------------------------------------------------
 ;read sequential
 ;IN  - (DE) FCB address
 ;OUT - (A) 00 = success and data available. else no read and no data
 vReadSeq:									; func20: (20 - 14) read sequential
	CALL	ReselectDisk
	CALL	ReadSeq
	RET
 ;-----------------------------------------------------------------
 ;write sequential
 ;IN  - (DE) FCB address
 ;OUT - (A) 00 = success and data available. else no read and no data
 vWriteSeq:									; func21 (21 - 15) write sequention
	CALL	ReselectDisk
	CALL	DiskWriteSeq
	RET
 ;-----------------------------------------------------------------
 ; Make file
 ; In - (DE)	FCB Address
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vMakeFile:									; func22 (22 - 16) Make file
	CALL	InitializeExtentNumberMSB					; set S2 to Zero
	CALL	ReselectDisk
	JP		MakeNewFile
 ;-----------------------------------------------------------------
 ; Rename file
 ; In - (DE)	FCB Address
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vRenameFile:								; func23 (23 - 17) Rename File
	CALL	ReselectDisk
	CALL	Rename
	JP		DirLocationToReturnLoc
 ;-----------------------------------------------------------------
 ;-----------------------------------------------------------------
 ;*****************************************************************
 ;-----------------------------------------------------------------
 ;check current directory element for read/only status
 CheckRODirectory:
	CALL	GetCurrentDirectoryRecord			; address of element
 ;	JMP	CheckROFile
 ;------------
 ;check current buff(dptr) or fcb(0) for r/o status
 CheckROFile:
	LD		DE,fcbROfileIndex
	ADD		HL,DE								; offset to ro bit
	LD		A,(HL)
	RLA
	RET	NC; return if not set
	JP		errReadOnlyFile					; exit to read only disk message
 ;-----------------------------------------------------------------
 ;check for write protected disk
 CheckWrite:
	CALL	IsDiskWriteProtected
	RET		Z					; OK to write
	JP		errReadOnlyDisk					; read only disk error
 ;-----------------------------------------------------------------
 ;-----------------------------------------------------------------
 ;sequential disk read operation
 ReadSeq:
	LD		A,1
	LD		(seqReadFlag),A						; set flag for seqential read
 ;---
 ; read the disk
 ; read the next record from the current fcb
 DiskRead:
	LD		A,TRUE
	LD		(readModeFlag),A					; read mode flag = true (OpenNextExt)

	CALL	SetRecordVars					; sets current File Record, fcbRecordCount and EXM
	LD		A,(currentFileRecord)
	LD		HL,fcbRecordCount
	CP		M								; current File Record-fcbRecordCount
											; skip if  current File Record < fcbRecordCount
	JP	C,RecordOK
 ; not enough records in the extent
	CP		RecordsPerExtent				; current File Record = 128?   *** Records in an Extent
	JP	NZ,DiskEOF							; skip if current File Record<>128
	CALL	OpenNextExt						; go to next extent if so
	XOR		A
	LD		(currentFileRecord),A						; current File Record=00
 ; now check for open ok
	LD		A,(exitParameterByte)
	OR		A
	JP	NZ,DiskEOF
	; stop at eof
 ; arrive with fcb addressing a record to read
 RecordOK:									; recordok:
	CALL	GetBlockNumber					; save it in Absolute CPM Record
	CALL	IsAllocated						; Absolute CPM Record=0000?
	JP	Z,DiskEOF							; get out if not allocated already

	CALL	SetActualRecordAdd				; Absolute CPM Record now a record value
	CALL	Seek							; to proper track,sector
	CALL	ReadBuffer						; to dma address
	CALL	UpdateRecordVars				; update variables from I/O in  fcb
	RET
 DiskEOF:									; diskeof:
	JP		SetLowReturnTo1					; exitParameterByte = 1
	;ret
 ;-----------------------------------------------------------------
 ;sequential disk write
 DiskWriteSeq:
	LD		A,1
	LD		(seqReadFlag),A
 ;--------
 ;disk write
 DiskWrite:
	LD		A,FALSE
	LD		(readModeFlag),A
											; write record to currently selected file
	CALL	CheckWrite						; in case write protected
	LD	HL,(paramDE)							; HL = .fcb(0)
	CALL	CheckROFile						; may be a read-only file
	CALL	SetRecordVars					; set local Record parameters
	LD		A,(currentFileRecord)
	CP		highestRecordNumber + 1			; Still in the same extent?
	JP	C,DiskWrite1						; skip if in the same Extent
	CALL	SetLowReturnTo1
	RET										; Exit ???????????

 ; can write the next record, so continue
 DiskWrite1:
	CALL	GetBlockNumber					; sets up actual block number
	CALL	IsAllocated
	LD		C,WriteAllocated				; assume a normal write operation for WriteBuffer
	JP	NZ,DiskWrite3
 ; not allocated -
 ; the argument to getblock is the starting position for the disk search
 ; and should be the last allocated block for this file,
 ; or the value 0 if no space has been allocated

	CALL	GetDiskMapIndex					; return with Disk Map index in Acc
	LD		(diskMapIndex),A					; save for later
	LD		BC,0000h						; may use block zero
	OR		A
	JP	Z,FirstBlock						; skip if no previous block
 ; previous block exists
	LD		C,A
	DEC		BC								; previous block # in BC
	CALL	GetDiskMapValue					; previous block # to HL
	LD		B,H
	LD		C,L								; BC=prev block#
 ; BC = 0000, or previous block #
 FirstBlock:
;	CALL	GetClosestBlockXX					; block # to HL
	CALL	GetClosestBlock
 ; arrive here with block# or zero
	LD		A,L
	OR		H
	JP	NZ,BlockOK
 ; cannot find a block to allocate
	LD		A,2
	LD		(exitParameterByte),A
	RET										; exitParameterByte=2

 BlockOK:
	LD	(absoluteCPMRecord),HL					; allocated block number is in HL
	EX	DE,HL ; block number to DE
	LD	HL,(paramDE)
	LD		BC,fcbDiskMapIndex
	ADD		HL,BC								; HL=.fcb(fcbDiskMapIndex)
	LD		A,(byteAllocationFlag)
	OR		A								; set flags for byteAllocationFlag byte dm
	LD		A,(diskMapIndex)					; recall dm index
	JP	Z,Allocate16Bit					; skip if allocating word
 ; else allocate using a byte value
	CALL	AddAtoHL
	LD		(HL),E								; byteAllocationFlag byte alloc
	JP		DiskWrite2						; to continue

 Allocate16Bit:								; allocate a word value

	LD		C,A
	LD		B,0								; double(diskMapIndex)
	ADD		HL,BC
	ADD		HL,BC								; HL=.fcb(diskMapIndex*2)
	LD		(HL),D
	INC		HL
	LD		(HL),E								; double wd
 ; disk write to previously unallocated block
 DiskWrite2:
	LD		C,WriteCleanBuffer				; marked as unallocated write
	CALL	ResetFileWriteFlag
 ; continue the write operation of no allocation error
 ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block

 DiskWrite3:
	LD		A,(exitParameterByte)
	OR		A
	RET	NZ; stop if non zero returned value

	PUSH	BC								; save write flag ( in C see above)
	CALL	SetActualRecordAdd				; Absolute CPM Record set to actual record number
	CALL	Seek							; to proper file position
	POP		BC								; get write flag
	PUSH	BC								; restore/save write flag (C=2 if new block)
	CALL	WriteBuffer						; written to disk
	POP		BC								; C = 2 if a new block was allocated, 0 if not
											; increment record count if fcbRecordCount<=current File Record
	LD		A,(currentFileRecord)
	LD		HL,fcbRecordCount
	CP		M 								; current File Record-fcbRecordCount
	JP	C,DiskWrite4
 ; fcbRecordCount <= current File Record
	LD		(HL),A
	INC		M								; fcbRecordCount = current File Record+1
	LD		C,2								; mark as record count incremented
 DiskWrite4:
 ; A has current File Record, C=2 if new block or new record#
	DEC		C
	DEC		C
	JP	NZ,DiskWrite5
	PUSH	AF								; save current File Record value
	CALL	GetExtentNumberMSB					; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
 ; reset the file write flag to mark as written fcb
	AND		7FH								; not writeFlagMask
	LD		(HL),A								; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
	POP		AF								; restore current File Record
 DiskWrite5:
 ; check for end of extent, if found attempt to open next extent in preparation for next write
	CP		highestRecordNumber				; current File Record=highestRecordNumber?
	JP	NZ,DiskWrite7						; skip if not
 ; may be random access write, if so we are done
	LD		A,(seqReadFlag)
	OR		A
	JP	Z,DiskWrite7						; skip next extent open op
 ; update current fcb before going to next extent
	CALL	UpdateRecordVars				;update variables from I/O in  fcb
	CALL	OpenNextExt						; readModeFlag=false
 ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
	LD		HL,exitParameterByte
	LD		A,(HL)
	OR		A
	JP	NZ,DiskWrite6						; no space
 ; space available, set current File Record=255
	DEC		A
	LD		(currentFileRecord),A						; goes to 00 next time
 DiskWrite6:
	LD		(HL),0								; exitParameterByte = 00 for returned value
 DiskWrite7:
	JP		UpdateRecordVars				; update variables from I/O in  fcb
	;ret
 ;-----------------------------------------------------------------
 ;close the current extent  and open the next one if possible.
 ;readModeFlag is true if in read mode
 OpenNextExt:					; open$reel
	XOR		A
	LD		(fcbCopiedFlag),A					; set true if actually copied
	CALL	CloseDirEntry					; close current extent
 ; exitParameterByte remains at enddir if we cannot open the next ext
	CALL	AtEndOfDirectory
	RET	Z; return if end
	LD	HL,(paramDE)							; increment extent number
	LD		BC,fcbExtIndex
	ADD		HL,BC								; HL=.fcb(fcbExtIndex)
	LD		A,(HL)
	INC		A
	AND		maxExtValue
	LD		(HL),A								; fcb(fcbExtIndex)=++1
	JP	Z,OpenNextModule					; move to next module if zero
											; may be in the same extent group
	LD		B,A
	LD		A,(dpbEXM)
	AND		B
 ; if result is zero, then not in the same group
	LD		HL,fcbCopiedFlag				; true if the fcb was copied to directory
	AND		M 								; produces a 00 in accumulator if not written
	JP	Z,OpenNextExt1					; go to next physical extent
											; result is non zero, so we must be in same logical ext
	JP		OpenNextExt2					; to copy fcb information
 ; extent number overflow, go to next module

 OpenNextModule:
	LD		BC,fcbS2Index-fcbExtIndex	;RATS
	ADD		HL,BC								; HL=.fcb(fcbS2Index)
	INC		M								; fcb(fcbS2Index)=++1
											; module number incremented, check for overflow
	LD		A,(HL)
	AND		moduleMask						; mask high order bits
	JP	Z,OpenNextExtError				; cannot overflow to zero
 ; otherwise, ok to continue with new module

 OpenNextExt1:
	LD		C,nameLength
	CALL	SearchForDirectoryRecord				; next extent found?
	CALL	AtEndOfDirectory
	JP	NZ,OpenNextExt2
 ; end of file encountered
	LD		A,(readModeFlag)
	INC		A								; 0ffh becomes 00 if read
	JP	Z,OpenNextExtError				; sets exitParameterByte = 1
 ; try to extend the current file
	CALL	MakeNewFile
 ; cannot be end of directory
	CALL	AtEndOfDirectory
	JP	Z,OpenNextExtError				; with exitParameterByte = 1
	JP		OpenNextExt3

 ; not end of file, open
 OpenNextExt2:
	CALL	CopyDirRecordToFCB
 OpenNextExt3:
	CALL	SetRecordVars					; Set Record parameters
	XOR		A
	LD		(exitParameterByte),A					; exitParameterByte = 0
	RET										; with exitParameterByte = 0

 ; cannot move to next extent of this file
 OpenNextExtError:
	CALL	SetLowReturnTo1					; exitParameterByte = 1
	JP		SetFileWriteFlag				; ensure that it will not be closed
 ;-----------------------------------------------------------------
 ;rename the file described by the first half of the currently addressed FCB.
 ;the new name is contained in the last half of the FCB. The file name and type
 ;are changed, but the reel number is ignored.  the user number is identical
 Rename:
	CALL	CheckWrite						; may be write protected
 ; search up to the extent field
	LD		C,fcbExtIndex					; extent number field index
	CALL	SearchForDirectoryRecord
 ; copy position 0
	LD	HL,(paramDE)
	LD		A,(HL)								; HL=.fcb(0), A=fcb(0)
	LD		DE,fcbDiskMapIndex
	ADD		HL,DE								; HL=.fcb(fcbDiskMapIndex)
	LD		(HL),A								; fcb(fcbDiskMapIndex)=fcb(0)
 ; assume the same disk drive for new named file
 Rename1:
	CALL	AtEndOfDirectory
	RET	Z; stop at end of dir
 ; not end of directory, rename next element
	CALL	CheckRODirectory				; may be read-only file
	LD		C,fcbDiskMapIndex
	LD		E,fcbExtIndex
	CALL	CopyDir
 ; element renamed, move to next
	CALL	GetNextDirectoryRecord
	JP		Rename1
 ;-----------------------------------------------------------------
 ;create a new file by creating a directory entry then opening the file
 MakeNewFile:
	CALL	CheckWrite						; may be write protected
	LD	HL,(paramDE)
	PUSH	HL								; save fcb address, look for e5
	LD		HL,emptyFCB
	LD	(paramDE),HL							; paramDE = .empty
	LD		C,1
	CALL	SearchForDirectoryRecord				; length 1 match on empty entry
	CALL	AtEndOfDirectory					; zero flag set if no space
	POP		HL								; recall paramDE address
	LD	(paramDE),HL							; in case we return here
	RET	Z; return with error condition 255 if not found
	EX	DE,HL ; DE = paramDE address
 ; clear the remainder of the fcb
	LD		HL,nameLength
	ADD		HL,DE								; HL=.fcb(nameLength)
	LD		C,fcbLength-nameLength			; number of bytes to fill
	XOR		A								; clear accumulator to 00 for fill
 MakeNewFile1:
	LD		(HL),A
	INC		HL
	DEC		C
	JP	NZ,MakeNewFile1
	LD		HL,fcbS1Index
	ADD		HL,DE								; HL = .fcb(fcbS1Index)
	LD		(HL),A								; fcb(fcbS1Index) = 0
	CALL	SetDirectoryEntry				; may have extended the directory
 ; now copy entry to the directory
	CALL	CopyFCB
 ; and set the file write flag to "1"
	JP		SetFileWriteFlag
 ;-----------------------------------------------------------------
 ;delete the currently addressed file
 DeleteFile:
	CALL	CheckWrite						; write protected ?
	LD		C,fcbExtIndex					; extent number field
	CALL	SearchForDirectoryRecord				; search through file type
 DeleteFile1:
						; loop while directory matches
	CALL	AtEndOfDirectory
	RET	Z; exit if end
 ; set each non zero disk map entry to 0 in the allocation vector
	CALL	CheckRODirectory				; ro disk error if found
	CALL	GetCurrentDirectoryRecord			; HL=.buff(dptr)
	LD		(HL),emptyDir
	LD		C,FALSE
	CALL	ScanDiskMap						; alloc elts set to 0
	CALL	WriteDir						; write the directory
	CALL	GetNextDirectoryRecord			; to next element
	JP		DeleteFile1						; for another record
 ;-----------------------------------------------------------------

 ;-----------------------------------------------------------------
;? ;enter from CloseDirEntry to seek and copy current element
;? SeekCopy:
;?	CALL	SeekDir							; to the directory element
;?	JP		WriteDir						; write the directory element
;?	;ret
;? ;-----------------------------------------------------------------
 ;-----------------------------------------------------------------
 ;-----------------------------------------------------------------

 
 ;-----------------------------------------------------------------
 ;compute disk block number from current fcb
 GetBlockNumber:
	CALL	GetDiskMapIndex					; 0...15 in register A
	LD		C,A
	LD		B,0
	CALL	GetDiskMapValue					; return value in HL
	LD	(absoluteCPMRecord),HL					; save for later
	RET
 ;-----------------------------------------------------------------
 ;is  block allocated
 IsAllocated:
	LD	HL,(absoluteCPMRecord)
	LD		A,L
	OR		H
	RET
 ;-----------------------------------------------------------------
 ;compute actual record address
 ; result = absolute CPMRecord * ( 2**BSH)
 SetActualRecordAdd:
	LD		A,(dpbBSH)							; Block Shift  to reg A
	LD	HL,(absoluteCPMRecord)

 SetActualRecordAdd1:
	ADD		HL,HL
	DEC		A								; shl(absolute CPMRecord,dpbBSH)
	JP	NZ,SetActualRecordAdd1
 ; HL has Record number for start of the block;
	LD		A,(dpbBLM)							; get block mask
	LD		C,A								; to get current File Record mod Block
	LD		A,(currentFileRecord)						; get index into block
	AND		C								; masked value in A
	OR		L
	LD		L,A								; to HL
	LD	(absoluteCPMRecord),HL					; Absolute CPM Record=HL or (current File Record and dpbBLM)
 ; *** Absolute CPM Record now has current record number - Starting record number + index into block
	RET
 ;-----------------------------------------------------------------
 ;---------------------
 ;copy directory location to exitParameterByte
 DirLocationToReturnLoc:
	LD		A,(directoryFlag)
	LD		(exitParameterByte),A
	RET
 ;---------------------


 ;---------------------
 ;set exitParameterByte to 1
 SetLowReturnTo1:
	LD		A,1
	LD		(exitParameterByte),A
	RET
 ;---------------------
 ;---------------------
 ;copy the whole file control block
 CopyFCB:
	LD		C,0
	LD		E,fcbLength						; start at 0, to fcblen-1
	JP		CopyDir
 ;---------------------
 ;copy fcb information starting at C for E bytes into the currently addressed directory entry
 CopyDir:
	PUSH	DE								; save length for later
	LD		B,0								; double index to BC
	LD	HL,(paramDE)							; HL = source for data
	ADD		HL,BC
	EX	DE,HL ; DE=.fcb(C), source for copy
	CALL	GetCurrentDirectoryRecord			; HL=.buff(dptr), destination
	POP		BC								; DE=source, HL=dest, C=length
	CALL	MoveX							; data moved
 ;enter from close to seek and copy current element
 SeekAndCopy:								; seek$copy:
	CALL	SeekDir							; seek$dir ;to the directory element
	JP	WriteDir							; write the directory element
 ;---------------------
 ;Return the  disk map Index for current File Record in the ACC
 ;  account for multiple extents in 1 physical Directory entry
 GetDiskMapIndex:							; dm$position
	LD		HL,dpbBSH						; get block shift value
	LD		C,(HL)								; shift count to C
	LD		A,(currentFileRecord)						; current virtual record to A
 GetDiskMapIndex1:
	OR		A								; reset the carry flag
	RRA
	DEC		C
	JP	NZ,GetDiskMapIndex1
											; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
											; A has the relative position in the block.
	LD		B,A								; save it for later addition
	LD		A,8
	SUB		M								; 8-dpbBSH to accumulator
	LD		C,A								; extent shift count in register c
	LD		A,(extentValue)						; extent value ani extmsk
 GetDiskMapIndex2:							; dmpos1:
											; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
											; shift is 4,3,2,1,0
	DEC		C
	JP	Z,GetDiskMapIndex3
	OR		A								; clear the carry flag
	RLA
	JP		GetDiskMapIndex2

 ; The ACC has the Block Number for this record
 GetDiskMapIndex3:
											; arrive here with A = shl(ext and extmsk,7-dpbBSH)
	ADD	A,B 									; add the previous shr(current File Record,dpbBSH) value
											; A is one of the following values, depending upon alloc
											; bks dpbBSH
											; 1k   3     v/8 + extentValue * 16
											; 2k   4     v/16+ extentValue * 8
											; 4k   5     v/32+ extentValue * 4
											; 8k   6     v/64+ extentValue * 2
											; 16k  7     v/128+extentValue * 1
	RET 									; with disk map position in A
 ;---------------------
 ; Enter with Disk Map Index in BG
 ; Return disk map value  in HL
 GetDiskMapValue:
	LD	HL,(paramDE)							; base address of file control block
	LD		DE,fcbDiskMapIndex				; offset to the disk map
	ADD		HL,DE								; HL =.diskmap
	ADD		HL,BC								; index by a  byte value
	LD		A,(byteAllocationFlag)							;  byte map entry?
	OR		A
	JP	Z,GetDiskMap16Bit 				; get disk map  byte
	LD		L,(HL)
	LD		H,0
	RET										; with HL=00bb
 GetDiskMap16Bit:							; getdmd:
	ADD		HL,BC								; HL=.fcb(dm+i*2)
											; double precision value returned
	LD		D,(HL)
	INC		HL
	LD		E,(HL)
	EX	DE,HL 
	RET
 ;---------------------
 ;---------------------
 ;*****************************************************************
 ;************************ Utilities ******************************
 ;*****************************************************************
 AddAtoHL:
	ADD		A,L
	LD		L,A
	RET	NC
	INC		H
	RET
 ;----------
 DEminusHL2HL:
	LD		A,E
	SUB		L
	LD		L,A
	LD		A,D
	SBC		A,H
	LD		H,A
	RET
 ;-------------
 ShiftRightHLbyC:
	INC		C
 ShiftRightHLbyC0:
	DEC		C
	RET	Z
	LD		A,H
	OR		A
	RRA
	LD		H,A
	LD		A,L
	RRA
	LD		L,A
	JP		ShiftRightHLbyC0
 ;-------
 ShiftLeftHLbyC:
	INC		C
 ShiftLeftHLbyC0:
	DEC		C
	RET	Z; exit when done
	ADD		HL,HL
	JP		ShiftLeftHLbyC0
 ;*****************************************************************
 ;move data length of length C from source DE to HL
 MoveX:
	INC		C
 MoveX0:
	DEC		C
	RET	Z
	LD	A,(DE)
	LD		(HL),A
	INC		DE
	INC		HL
	JP		MoveX0

 ;********** Console OUT Routines*******************??????
 
;---------------------------------- Is Bit Set ------------------------------;
; Enter HL  contains the bit map                                             ;
;       B   Has the bit number (0...F)                                       ;
; Return ZFlag = 1 if bit is reset (0)                                       ;
;              = 0 if bit is set (1)                                         ;
IsBitSet:																	 ;
		INC		B                                                            ;
IsBitSetLoop:                                                                ;
 		SCF								; Set carry flag, expect LSBit = 1   ;
		BIT		0,L						; is LSB set?                        ;
		JR		NZ, IsBitSet1				; Skip if LSB set                ;
		CCF								; else Clear Carry flag              ;
IsBitSet1:                                                                   ;
		RR		H						; Shift thru CY                      ;
		RR		L						; ditto                              ;
		DJNZ	IsBitSetLoop                                                 ;
		BIT		7,H						; Bit moved from L LSBit to H MSBit	 ;
		RET                                                                  ;
;---------------------------------- Is Bit Set ------------------------------;

;============================ Set/Reset Vector Bit ==========================;		
;---------------------------------- Set Vector Bit -------------------------;;		
; Enter  HL  contains the bit map vector                                    ;;
;        B   Has the bit number (0...F)                                     ;;
; Return HL  Contains the modified bit map vector                           ;;
SetVectorBit:                                                               ;;
		PUSH	BC						; Save the Bit Number               ;;
		CALL	IsBitSet				; Put the bit in the LSBit          ;;
                                                                            ;;
		POP		BC						; Get the bit position              ;;
		SET		7,H                                                         ;;
		JR		ReAlignVector				;                                    ;
;---------------------------------- Set Vector Bit -------------------------;;
;---------------------------------- Reset Vector Bit -----------------------;;		
; Enter  HL  contains the bit map vector                                    ;;
;        B   Has the bit number (0...F)                                     ;;
; Return HL  Contains the modified bit map vector                           ;;
ResetVectorBit:                                                             ;;
		PUSH	BC						; Save the Bit Number               ;;
		CALL	IsBitSet				; Put the bit in the LSBit          ;;
                                                                            ;;
		POP		BC						; Get the bit position              ;;
		RES		7,H                                                         ;;
; Fall thru to ReAlignVector                                                 ;
;---------------------------------- Reset Vector Bit -----------------------;;		
;---------------------------------- Set VectorBit --------------------------;;
; Adjusts the HL register to its Original Alignment after IsBitSet           ;
		                                                                     ;
ReAlignVector:                                                                  ;
		INC		B                                                            ;
ReAlignMapLoop:                                                              ;
 		SCF								; Set carry flag, expect LSBit = 1   ;
		BIT		7,H						; is LSB set?                        ;
		JR		NZ, ReAlignMap1				; Skip if LSB set                ;
		CCF								; else Clear Carry flag              ;
ReAlignMap1:                                                                 ;
		RL		L						; Shift thru CY                      ;
		RL		H						; ditto                              ;
		DJNZ	ReAlignMapLoop                                               ;
		RET                                                                  ;
;============================ Set/Reset Vector Bit ==========================;		
 ;************Error message World*************************
 errSelect:
	LD		HL,evSelection
	JP		GoToError
 errReadOnlyDisk:
	LD		HL,evReadOnlyDisk
	JP		GoToError
 errReadOnlyFile:
	LD		HL,evReadOnlyFile
	JP		GoToError
 errPermanent:
	LD		HL,evPermanent
	JP		GoToError
 ;************Error message handler **********************
 GoToError:
 ;HL = .errorhandler, call subroutine
	LD		E,(HL)
	INC		HL
	LD		D,(HL)								; address of routine in DE
	EX	DE,HL 
	JP(HL) 									; vector to subroutine
 ;************ Error Vectors *****************************
 evPermanent: 	DW	erPermanent				; pererr permanent error subroutine
 evSelection:	DW	erSelection				; selerr select error subroutine
 evReadOnlyDisk:	DW	erReadOnlyDisk			; roderr ro disk error subroutine
 evReadOnlyFile:	DW	erReadOnlyFile			; roferr ro file error subroutine
 ;************Error Routines ******************************
 erPermanentNoWait:
	LD		HL,emPermanent
	JP		GoToError
 erPermanent:
	LD		HL,emPermanent
	CALL	displayAndWait					; to report the error
	CP 	CTRL_C
	JP	Z,WarmBoot						; reboot if response is CTRL_C
	RET										; and ignore the error
 ;
 erSelection:
	LD		HL,emSelection
	JP		waitB4boot						; wait console before boot
 ;
 erReadOnlyDisk:
	LD		HL,emReadOnlyDisk
	JP		waitB4boot						; wait console before boot
 ;
 erReadOnlyFile:
	LD		HL,emReadOnlyFile				; drop through to wait for console
 ;
 ; wait for response before boot
 waitB4boot:
	CALL	displayAndWait
	JP		WarmBoot

 ;report error to console, message address in HL
 displayAndWait:
	PUSH	HL								; save message pointer
	CALL	showCRLF						; stack mssg address, new line
	LD		A,(currentDisk)
	ADD	A,ASCII_A
	LD		(emDisk),A							; Problem disk name
	LD		BC,emDisk0
	CALL	Print							; the error message
	POP		BC
	CALL	Print							; error mssage tail
	JP		ConIn							; to get the input character
	;ret
 ;**************Error Messages*******************************
 emDisk0:			DB		'Bdos Err On '
 emDisk:				DB		' : $'
 emPermanent:		DB		'Bad Sector$'
 emSelection:		DB		'Select$'
 emReadOnlyFile:		DB		'File '
 emReadOnlyDisk:		DB		'R/O$'
 ;*****************************************************************

 ;********* file control block (fcb) constants ********************
 fcbLength			EQU		20H	;32				; fcblen file control block size
 fcbROfileIndex		EQU		09H				; high order of first type char
 fcbHiddenfileIndex	EQU		0AH	;10				; invisible file in dir command
 fcbExtIndex		EQU		0CH	;12				; extent number field index
 fcbS1Index			EQU		0DH	;13				; S1 index
 fcbS2Index			EQU		0EH	;14				; S2 data module number index
 fcbRCIndex			EQU		0FH	;15				; record count field index
 fcbDiskMapIndex	EQU		10H	;16				; dskmap disk map field
 
 fcbCurrentRecord	EQU		21H	;33

 highestRecordNumber	EQU		RecordsPerExtent - 1; last record# in extent

 dirEntriesPerRecord	EQU		cpmRecordSize/fcbLength; directory elts / record
 dirEntryShift		EQU		2				; log2(dirEntriesPerRecord)
 dirEntryMask		EQU		dirEntriesPerRecord-1
 fcbShift			EQU		5				; log2(fcbLength)
 ;



 maxExtValue			EQU		31				; largest extent number
 moduleMask			EQU		15				; limits module number value
 writeFlagMask		EQU		80h				; file write flag is high order fcbS2Index
 nameLength			EQU		15				; namlen name length

 emptyDir			EQU		0E5H			; empty empty directory entry
 NEXT_RECORD			EQU		fcbLength		; nxtrec
 RANDOM_REC_FIELD	EQU		NEXT_RECORD + 1	;ranrec random record field (2 bytes)
 ;
 ;	reserved file indicators
 ;	equ	11				; reserved
 ;*****************************************************************
 ;*****************************************************************

 ;***common values shared between bdosi and bdos******************
 currentUserNumber:	DB	0					; usrcode current user number
; paramDE:			DS	2					; ParamsDE information address
; exitParameterByte:
; exitParameterWord:	DS	2					; address value to return
 currentDisk:		DB	-1					; curdsk current disk number
; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)

 ;********************* Local Variables ***************************
 ;     ************************
 ;     *** Initialized Data ***

 emptyFCB:			DB	emptyDir			; efcb 0E5 = available dir entry
 readOnlyVector:		DW	0					; rodsk read only disk vector
 loggedDisks:		DW	0					; dlog	 logged-in disks
 initDAMAddress:		DW	DMABuffer			; dmaad tbuff initial dma address

 ;     *** Current Disk attributes ****
 ; These are set upon disk select
 ; data must be adjacent, do not insert variables
 ; address of translate vector, not used
 ; ca - currentAddress

 caDirMaxValue:		DW	0000H				; cdrmaxa pointer to cur dir max value
 caTrack:			DW	0000H				; curtrka current track address
 caSector:			DW	0000H				; current Sector
 caListSizeStart:
 caDirectoryDMA:		DW	0000H				; buffa pointer to directory dma address
 caDiskParamBlock:	DW	0000H				; dpbaddr current disk parameter block address
 caCheckSum:			DW	0000H				; checka current checksum vector address
 caAllocVector:		DW	0000H				; alloca current allocation vector address
 caListSizeEnd:
 caListSize			EQU	caListSizeEnd - caListSizeStart

 ;     ***** Disk Parameter Block *******
 ; data must be adjacent, do not insert variables
 ; dpb - Disk Parameter Block
 dpbStart:
 dpbSPT:				DW	0000H				; sectpt sectors per track
 dpbBSH:				DB	0000H				; blkshf block shift factor
 dpbBLM:				DB	00H					; blkmsk block mask
 dpbEXM:				DB	00H					; extmsk extent mask
 dpbDSM:				DW	0000H				; Maximum allocation number
 dpbDRM:				DW	0000H				; dirmax largest directory number
 dpbDABM:			DW	0000H				; dirblk reserved allocation bits for directory
 dpbCKS:				DW	0000H				; chksiz size of checksum vector
 dpbOFF:				DW	0000H				; offset offset tracks at beginning
 dpbEnd:
 dpbSize				EQU	dpbEnd - dpbStart
 ;

 ;     ************************

 caSkewTable:		DW	0000H				; tranv address of translate vector
 fcbCopiedFlag:		DB	00H					; fcb$copied set true if CopyFCB called
 readModeFlag:		DB	00H					; rmf read mode flag for OpenNextExt
 directoryFlag:		DB	00H					; dirloc directory flag in rename, etc.
 seqReadFlag:		DB	00H					; seqio  1 if sequential i/o
 diskMapIndex:		DB	00H					; dminx  local for DiskWrite
 searchLength:		DB	00H					; searchl search length
 searchAddress:		DW	0000H				; searcha search address
 ;tinfo:	ds	word							; temp for info in "make"
 byteAllocationFlag:	DB	00H					; set true if single byte allocation map
 fResel:				DB	00H					; resel reselection flag
 entryDisk:			DB	00H					; olddsk disk on entry to bdos
 fcbDisk:			DB	00H					; fcbdsk disk named in fcb
 fcbRecordCount:	DB	00H				; record count from current FCB
 extentValue:		DB	00H					; extent number and dpbEXM from current fcb
 currentFileRecord:			DW	0000H				; Current File Record - fcbCurrentRecord
 absoluteCPMRecord:	DW	0000H			; Raw record ( 4 records / Sector)( 4 Sectors per block)
 ;
 ;	local variables for directory access
 dirBlockIndex:		DB	00H					; directory block Index 0,1,2,3
 dirEntryIndex:		DW	00H					; directory entry Index  0,1,...,dpbDRM
 dirRecord:			DW	00H					; drec:	ds	word	;directory record 0,1,...,dpbDRM/4

 ;********************** data areas ******************************


;---------------------------------- Stack Area--------------------------------;
stackBottom:		DS	STACK_SIZE * 2	; stack size                      ;
bdosStack:
                                                                    ;
;---------------------------------- Stack Area--------------------------------;
 ;	end of Basic I/O System
 ;-----------------------------------------------------------------;
 *****************************************************************

 ;
Z_HighestLocation:
Z_MemoryLeft			EQU    (BIOSStart-1) - Z_HighestLocation


