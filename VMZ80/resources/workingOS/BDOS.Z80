;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
 ; BDOS.Z80
 
 
 ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
 ; 2018-12-28 Started to refactor to Z80 idiom
 ; 2018-03-31 added vector for BDOS Call 5 -ListOut
 ; 2018-03-02 Refactored the CP/M Suite
 ; 2018-02-12 fixed allocate 16 bit problem
 ; 2014-01-16 extended from part of newOS (newBDOS)
 ; 2014-03-14  :  Frank Martyn


	$Include ./stdHeader.Z80
	$Include ./osHeader.Z80
	$Include ./diskHeader.Z80

VERSION			EQU		20H				; Version 2.0
STACK_SIZE		EQU		20H				; Make stack big enough
EOD				EQU		-1				; End of Directory

;************************ BIOS Function Constants ***************************;
bcBoot		EQU		BIOSStart+3*0		; Cold Boot function	             ;
bcWboot		EQU		BIOSStart+3*1		; Warm Boot function                 ;
bcConst		EQU		BIOSStart+3*2		; Console Status function            ;
bcConin		EQU		BIOSStart+3*3		; Console Input function             ;
bcConout	EQU		BIOSStart+3*4		; Console Output function            ;
bcList		EQU		BIOSStart+3*5		; List Output function               ;
bcPunch		EQU		BIOSStart+3*6		; Punch Output function              ;
bcReader	EQU		BIOSStart+3*7		; Reader Input function              ;
bcHome		EQU		BIOSStart+3*8		; Disk Home function                 ;
bcSeldsk	EQU		BIOSStart+3*9		; Select Disk function               ;
bcSettrk	EQU		BIOSStart+3*10		; Set Track function                 ;
bcSetsec	EQU		BIOSStart+3*11		; Set Sector function                ;
bcSetdma	EQU		BIOSStart+3*12		; Set DMA function                   ;
bcRead		EQU		BIOSStart+3*13		; Read Disk function                 ;
bcWrite		EQU		BIOSStart+3*14		; Write Disk function                ;
bcListst	EQU		BIOSStart+3*15		; List Status function               ;
bcSectran	EQU		BIOSStart+3*16		; Sector Translate                   ;
;************************ BIOS Function Constants ***************************;

;============================================================================;
;	BDOS                                                                     ;
; Calling into   :                                                           ;
;					Register  C - Contains BDOS Function Code                ;
;					Register  A - Holds the Byte argument if any             ;
;					Register DE - Holds the Word argument if any             ;
; Returning from :                                                           ;
;					Register  A - The Byte return value if any               ;
;					Register HL - The Word return value if any               ;
;                   ( Register A=L and B=H)                                  ;
;============================================================================;


	ORG	BDOSBase

;===========================BDOS Entry=======================================;
;BDOSEntry:                                                                  ;
																			 ;
																			 ;
 BdosStart:                                                                  ;
;	LD		A,C                                                              ;
; 	LD		(FunctionValue),A			; Save the function number           ;
																			 ;
; Save Calling Arguments                                                     ;
	LD		(paramDE),DE				; Save the Word Argument             ;
	LD		A,E	                                                             ;
	LD		(paramE),A					; Save the Byte argument             ;
; Save users Stack pointer                                                   ;
	LD		(usersStack),SP				; We will use our own stack          ;
	                                                                         ;
; initialize variables                                                       ;
	LD		HL,0000H                                                         ;
	LD		(exitParameterWord),HL		; Assume all is well for return      ;
	XOR		A                                                                ;
	LD		(fcbDisk),A					; Initialize to 00                   ;
	LD		(fResel),A					; Clear re selection flag            ;
	                                                                         ;
; Set up for return to caller when Function Completes                        ;
	LD		HL,ReturnToCaller                                                ;
	PUSH	HL							;Set up to ReturnToCaller            ;
	                                                                         ;
; is it a valid function number ?	                                         ;
;	LD		A,(FunctionValue)			; Get the Function Number            ;
	LD		A,C                                                              ;
	CP		functionCount				; make sure its a good number        ;
	RET		NC							; exit if not a valid function       ;
																			 ;
; Calculate the index and get vector to go to	                             ;
	LD		C,E							; Assume byte argument               ;
	LD		HL,functionTable			; Get table base                     ;
	LD		E,A							; Function number in E               ;
	LD		D,0                                                              ;
	ADD		HL,DE						; Have byte location                 ;
	ADD		HL,DE						;  but we want a Word offset         ;
	LD		E,(HL)						; Get LSB of vector                  ;
	INC		HL                                                               ;
	LD		D,(HL)						; Get MSB of vector                  ;
	EX		DE,HL						; Vector now in HL                   ;
																			 ;
; Vector to Function is in HL                                                ;
	JP		(HL) 						; Put it into the Program Counter    ;
;===========================BDOS Entry=======================================;
;===========================BDOS Exit =======================================;
;arrive here at end of processing to return to user                          ;
ReturnToCaller:                                                              ;
	LD		A,(fResel)					; get re-selection flag              ;
	OR		A							; is it set?                         ;
	JR		Z,ReturnToCaller1                                                ;
 ;re-selection  may have taken place                                         ;
	LD		HL,(paramDE)                                                     ;
	LD		(HL),0                                                           ;
	LD		A,(fcbDisk)                                                      ;
	OR		A							; Disk = 0?                          ;
	JR		Z,ReturnToCaller1			; exit if yes                  		 ;
																			 ;
	LD		(HL),A                                                           ;
	LD		A,(entryDisk)				; get back original Disk             ;
	LD		(paramE),A					; and select it                      ;
	CALL	SelectCurrent                                                    ;
																			 ;
ReturnToCaller1:                                                             ;
	LD		HL,(usersStack)                                                  ;
	LD		SP,HL						; restore callers stack              ;
	LD		HL,(exitParameterWord)                                           ;
	LD		A,L                                                              ;
	LD		B,H							; BA = exitParameterWord             ;
	RET                                                                      ;
;===========================BDOS Exit =======================================;

;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
functionTable:                                                               ;
	DW		vSystemReset				;   0 - System Reset                 ;
	DW		vConsoleIn					;   1 - Console Input                ;
	DW		vConsoleOut					;   2 - Console Output               ;
	DW		vReaderIn					;   3 - Reader Input                 ;
	DW		vPunchOut                   ;   4 - Punch Output                 ;
	DW		vListOut					;   5 - List Output                  ;
	DW		vDirectConIO				;   6 - Direct Console I/O           ;
	DW		vGetIOBYTE					;   7 - Get I/O Byte                 ;
	DW		vSetIOBYTE					;   8 - Set I/O Byte                 ;
	DW		vPrintString				;   9 - Print String                 ;
	DW		vReadString					;   A - Read Console String          ;
	DW		vGetConsoleStatus			;   B - Get Console Status           ;
diskf	EQU	($-functionTable)/2			; disk functions                     ;
	DW		vGetVersion					;   C - Return Version Number        ;
	DW		vResetSystem				;   D - Reset Disk System            ;
	DW		vSelectDisk					;   E - Select Disk                  ;
	DW		vOpenFile					;   F - Open File                    ;
	DW		vCloseFile					;  10 - Close File                   ;
	DW		vFindFirst					;  11 - Search For First             ;
	DW		vFindNext					;  12 - Search for Next              ;
	DW		vDeleteFile					;  13 - Delete File                  ;
	DW		vReadSeq					;  14 - Read Sequential              ;
	DW		vWriteSeq					;  15 - Write Sequential             ;
	DW		vMakeFile					;  16 - Make File                    ;
	DW		vRenameFile					;  17 - Rename File                  ;
	DW		vGetLoginVector				;  18 - Return Login Vector          ;
	DW		vGetCurrentDisk				;  19 - Return Current Disk          ;
	DW		vSetDMA						;  1A - Set DMA address              ;
	DW		vGetAllocAddr				;  1B - Get ADDR (ALLOC)             ;
	DW		vWriteProtectDisk			;  1C - Write Protect Disk           ;
	DW		vGetReadOnlyMap				;  1D - Get Read/Only MAP	         ;
	DW		vSetFileAttributes			;  1E - Set File Attributes ??       ;
	DW		vGetDiskParamBlock			;  1F - Get ADDR (Disk Parameters)   ;
	DW		vGetSetUserNumber			;  20 - Set/Get User Code            ;
	DW		vReadRandom					;  21 - Read Random                  ;
	DW		vWriteRandom				;  22 - Write Random                 ;
	DW		vComputeFileSize			;  23 - Compute File Size            ;
	DW		vSetRandomRecord			;  24 - Set Random Record            ;
	DW		vResetDrive					;  25 - Reset Drive                  ;
	DW		DUMMY						;  26 - Access Drive (not supported) ;
	DW		DUMMY						;  27 - Free Drive (not supported)   ;
	DW		vWriteRandom0Fill			;  28 - Write random w/Fill          ;
functionCount	EQU	($-functionTable)/2 ; Number of  functions               ;
																			 ;
DUMMY:                                                                       ;
	HALT                                                                     ;
;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;

;-------------------------- System Reset - 0 (0) ----------------------------;
;  The system reset function makes CP/M do a complete reset, exactly the     ;
; same as the warm boot function invoked when you transfer control to the    ;
; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
; to 80H, marks all disks as being Read/Write status, and transfers control  ;
; to the  CCP. The CCP then outputs its prompt to the console.               ;
;																			 ;
;			Function Code	 :	C = 00H                                      ;
;			Entry Parameters:	None                                         ;
;			Exit Parameters :	Does Not Return								 ;
;																			 ;
;-------------------------- System Reset - 0 (0) ----------------------------;
vSystemReset:
	JP		bcWboot						; do a Warm Boot
		
;****************************************************************************;
;								IOByte device I/O							 ;
;****************************************************************************;
			

;-------------------------- Read Console Byte - 1 (1) -----------------------;
;  This function reads the next byte of data from the console keyboard and   ;
; puts it into register A. If the character input is a graphic character, it ;
; will be echoed back to the console. The only control characters that are   ;
; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
; of a TAB character, the BDOS outputs as many spaces as are required to     ;
; move the cursor to the next multiple of eight columns. All of the other    ;
; control characters, including CONTROL-C, are input but are not echoed.     ;
;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
; console output should also be sent to the list device. If CONTROL-S is     ;
; found, further output will be suspended until you type another character.  ;
; CONTROL-P will enable the echoing of console output the first time it is   ;
; pressed and disable it the second time. If there is no incoming data       ;
; character, this function will wait until there is one.                     ;
;                                                                            ;
; This is a blocking function                                                ;
;																			 ;
;																			 ;
;			Function Code	:	C = 01H                                      ;
;			Entry Parameters:	None                                         ;
;			Exit Parameters :	A = Data byte from console					 ;
;																			 ;
;-------------------------- Read Console Byte - 1 (1) -----------------------;
vConsoleIn:
	CALL	ConIn						; Don't come back without input
	CALL	IsPrintableASCII			; CR,LF,TAB,BACK_SPACE or GE SPACE
	RET		C							; return nothing to echo

	PUSH	AF							; Save printable character
	LD		C,A
	CALL	TabOut						; Send to console. if TAB expand
	POP		AF							; retrieve exit value

	LD		(exitParameterByte),A
	RET					

;------------------------- Write Console Byte - 2 (2) -----------------------;
;  This function outputs the data byte in register E to the console. As with ;
; function 1, if the data byte is a TAB character, it will be expanded by    ;
; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
; checks to see if there is an incoming character, and if there is,          ;
; checks to see if it is a CONTROL-S ,in which case console output is        ;
; suspended or CONTROL-P, in which case echoing of console output to the     ;
; printer is  toggled on or off                                              ;
;																			 ;
;			Function Code	:	C = 02H                                      ;
;			Entry Parameters:	E = Data byte to be output					 ;
;			Exit Parameters :	None										 ;
;																			 ;
;------------------------- Write Console Byte - 2 (2) -----------------------;
;BDOS put parameter in C before entering this routine
vConsoleOut:
	CALL	TabOut
	RET

;--------------------------- Read Reader Byte - 3 (3) -----------------------;
;   function reads the next character from the logical "reader" device into  ;
; register A. In practice, the physical device that is accessed depends      ;
; entirely on how your BIOS is configured. In some systems, there is no      ;
; reader at all; this function will return some arbitrary value such as lAH  ;
; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
; Control is not returned to the calling program until a character has been  ;
; read.                                                                      ;
;                                                                            ;
; This is a blocking function                                                ;
;																			 ;
;			Function Code	:	C = 03H                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	A = Character Input							 ;
;																			 ;
;--------------------------- Read Reader Byte - 3 (3) -----------------------;
vReaderIn:
	CALL	bcReader
	LD		(exitParameterWord),A
	RET

;--------------------------- Write Punch Byte - 4 (4) -----------------------;
;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
; specified character from register E to the logical punch device. Again,    ;
; the actual physical device used, if any, is determined by the BIOS.        ;
; There is no set standard for this device; in some systems the punch        ;
; device is a "bit bucket," so called because it absorbs all data that you   ;
; output to it.                                                              ;
;																			 ;
;			Function Code	:	C = 04H                                      ;
;			Entry Parameters:	E = Data byte to be output					 ;
;			Exit Parameters :	None										 ;
;																			 ;
;--------------------------- Write Punch Byte - 4 (4) -----------------------;
;BDOS put parameter in C before entering this routine
 vPunchOut:
	CALL	bcPunch
	RET

;---------------------------- Write List Byte - 5 (5) -----------------------;
;  This function outputs the specified byte in register E to the logical     ;
; list device. As with the reader and the punch, the physical device used    ;
; depends entirely on the BIOS.                                              ;
;																			 ;
;			Function Code	:	C = 05H                                      ;
;			Entry Parameters:	E = Data byte to be output					 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Write List Byte - 5 (5) -----------------------;
;BDOS put parameter in C before entering this routine
 vListOut:								; func5 (05 - 05) List Output
	CALL	bcList						; direct call to BIOS
	RET

;--------------------------- Direct Console I/O - 6 (6) ---------------------;
;  This function serves double duty: it both inputs and outputs characters   ;
; from the console. However, it bypasses the normal control characters and   ;
; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
; Digital Research describes it). If the value in register E is not OFFH,    ;
; then E contains a valid ASCII character that is output to the console.     ;
;  This function works well provided you never have to send a value ofOFFH   ;
; or expect to receive a value ofOOH. If you do need to send or receive pure ;
; binary data, you cannot use this function, since these values are likely   ;
; to be part of the data stream.                                             ;
;                                                                            ;
;			Function Code	:	C = 06H                                      ;
;			Entry Parameters:	E = 0FFH for Input					  		 ;
;								E = Other than 0FFH for Output				 ;
;			Exit Parameters :	A = Input byte or status					 ;
;																			 ;
;--------------------------- Direct Console I/O - 6 (6) ---------------------;
;BDOS put parameter in C before entering this routine
 vDirectConIO:
	LD		A,C
	INC		A
	JR		Z,vDirectConIO1				; 0ffh => 00h, means input mode
; send byte to console	
	CALL	bcConout					; Send the byte to the console
	RET

;read byte/status from console	
vDirectConIO1:
	CALL	bcConst						; Check Status
	OR		A							; 00 means not data ready
	JP		Z,ReturnToCaller1			; If no data return  00 to caller
	CALL	bcConin						; Data is available, get it to A
	LD		(exitParameterByte),A		; Save it
	RET

;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
; This function places the current value of the IOBYTE in register A.        ;
;                                                                            ;
; The IOBYTE structure:                                                      ;
;								+-------+-------+-------+-------+            ;
;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
;								+-------+-------+-------+-------+            ;
;				Logical Device     List | Punch | Reader|Console             ;
;                                                                            ;
;                                                                            ;
;			Function Code	:	C = 07H                                      ;
;			Entry Parameters:	None					  		  			 ;
;			Exit Parameters :	A = Current IOBYTE value					 ;
;																			 ;
;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
 vGetIOBYTE:
	LD		A,(IOBYTE)					; Get the IOBYTE
	LD		(exitParameterWord),A		; Return it to caller
	RET	
;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
; This function sets the IOBYTE         									 ;
;                                                                            ;
; The IOBYTE structure:                                                      ;
;								+-------+-------+-------+-------+            ;
;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
;								+-------+-------+-------+-------+            ;
;				Logical Device     List | Punch | Reader|Console             ;
;                                                                            ;
;                                                                            ;
;			Function Code	:	C = 08H                                      ;
;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
;			Exit Parameters :	None                                         ;
;																			 ;
;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
;BDOS put parameter in C before entering this routine
 vSetIOBYTE:
	LD		HL,IOBYTE					; point at The IOBYTE
	LD		(HL),C						; Place new vale in it
	RET

;---------------------- Display $ terminated String - 9 (9) -----------------;
;  This function outputs a string of characters to the console device. The   ;
; address of this string is in registers DE. You must make sure that the last;
; character of the string is "$"; the BDOS uses this character as a marker   ;
; for the end of the string.                                                 ;
;  The "$" itself does not get output to the console.                        ;
;                                                                            ;
; While the BDOS is outputting the string, it expands tabs as previously     ;
; described, checks to see if there is an incoming character, and checks for ;
; CONTROL-S (XOFF, which stops the output until another character is entered);
; or CONTROL-P (which turns on or off echoing of console characters to       ;
; the printer).                                                              ;
;                                                                            ;
;			Function Code	:	C = 09H                                      ;
;			Entry Parameters:	DE = Address of the first byte of the string ;
;			Exit Parameters :	None							             ;
;																			 ;
;---------------------- Display $ terminated String - 9 (9) -----------------;
vPrintString:
	LD		HL,(paramDE)				; Get address of the string
	LD		C,L
	LD		B,H							; Put it into BC for call
	CALL	Print						; out to console
	RET

;-------------------------- Read Console String - A (10) --------------------;
;  This function reads a string of characters from the console device        ;
; and stores them in a buffer (address in DE) that you define. Full line     ;
; editing is possible: the operator can backspace, cancel the line and start ;
; over, and use all the normal control functions. What you will ultimately   ;
; see in the buffer is the final version of the character string entered,    ;
; without any of the errors or control characters used to do the line editing;
;                                                                            ;
;  The buffer that you define has a special format. The first byte in the    ;
; buffer tells the BDOS the maximum number of characters to be accepted.     ;
; The second byte is reserved for the BDOS to tell you how many characters   ;
; were actually placed in the buffer. The following bytes contain            ;
; the characters of the string. Character input will cease either when a     ;
; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
; stored in the buffer as a character-it just serves as a terminator. If     ;
; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
; the "characters input" byte to O. If you attempt to input more than the    ;
; maximum number of characters, the "characters input" count will be the     ;
; same as the maximum value allowed.                                         ;
;                                                                            ;
;			Function Code	:	C = 0AH                                      ;
;			Entry Parameters:	DE = Address string buffer					 ;
;			Exit Parameters :	String Buffer with console bytes in it       ;
;																			 ;
;-------------------------- Read Console String - A (10) --------------------;
 vReadString:
	CALL	ReadString
	RET

;------------------------- Read Console Status - B (11) ---------------------;
; This function tells you whether a console input character is waiting to be ;
;processed. Unlike the Console Input functions, which will wait until there  ;
;is input,this function simply checks and returns immediately.               ;
;                                                                            ;
;			Function Code	:	C = 0BH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	A = 00H if no incoming Data					 ;
;								A = FFH	if incoming Data					 ;
;																			 ;
;------------------------- Read Console Status - B (11) ---------------------;
vGetConsoleStatus:
	CALL	ConBreak
	LD		(exitParameterByte),A
	RET

;--------------------------- Get CP/M Version - C (12) ----------------------;
;  This function tells you which version of CP/M you are currently running.  ;
; A two-byte value is returned:                                              ;
;	H = OOH for CP/M, H = OlH for MP/M                                       ;
;	L = OOH for all releases before CP/M 2.0                                 ;
;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
;		and so on for any subsequent releases.                               ;
;                                                                            ;
; This information is of interest only if your program has some version      ;
; specific logic built into it. For example, CP/M version 1.4 does not       ;
; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
; Therefore, if your program uses Random I/O, put this check at the          ;
; beginning to ensure that it is indeed running under the appropriate        ;
; version of CP/M.                                                           ;
;                                                                            ;
;			Function Code	:	C = 0CH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL =Version Number Code						 ;
;								A = FFH	if incoming Data					 ;
;																			 ;
;--------------------------- Get CP/M Version - C (12) ----------------------;
 vGetVersion:								; func12 (12 - 0C)	 Get Version
	LD		A,VERSION
	LD		(exitParameterByte),A 			;exitParameterByte = VERSION
	RET
	
;--------------------------- Get/Set User Number - 20 (32) ------------------;
;  This subroutine either sets or gets the current user number. The current  ;
; user number determines which file directory entries are matched during all ;
; disk file operations. When you call this function, the contents of the     ;
; E register specify what action is to be taken. IfE=OFFH, then the function ;
; will return the current user number in the A register. If you set E to a   ;
; number in the range 0 to 15 (that is, a valid user number), the function   ;
; will set the current user number to this value.                            ;
;                                                                            ;
;			Function Code	:	C = 0CH                                      ;
;			Entry Parameters:	E = 0FFH to get User Number  				 ;
;								  = 0 to 15 to set User Number				 ;
;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
;								A = FFH	if incoming Data					 ;
;																			 ;
;                                                                            ;
;--------------------------- Get/Set User Number - 20 (32) ------------------;
vGetSetUserNumber:
    LD		A,(paramE)
	CP		0FFH
	JR		NZ,SetUserNumber				; interrogate user code instead
	LD		A,(currentUserNumber)
	LD		(exitParameterByte),A		; exitParameterByte=currentUserNumber
	RET

SetUserNumber:
	AND		LO_NIBBLE_MASK
	LD		(currentUserNumber),A
	RET

;****************************************************************************;
;								Character Support Routines					 ;
;****************************************************************************;


;-------------------- Return a Character from the console -------------------;
;return byte from buffer or read from the console                            ;
ConIn:                                                                       ;
	LD		HL,keyboardByte 			; is there a Byte waiting?           ;
	LD		A,(HL)                                                           ;
	LD		(HL),0                                                           ;
	OR		A                                                                ;
	RET		NZ                                                               ;
																		 ;
	JP		bcConin				 		; Go get byte from Console           ;
;-------------------- Return a Character from the console -------------------;

;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
IsPrintableASCII:                                                            ;
	CP	CR                                                                   ;
	RET	Z; carriage return?                                                  ;
	CP	LF                                                                   ;
	RET	Z; line feed?                                                        ;
	CP	TAB                                                                  ;
	RET	Z; TAB?                                                              ;
	CP	CTRL_H                                                               ;
	RET	Z; backspace?                                                        ;
	CP	SPACE						; Reset Carry if ASCII printable         ;
	RET								                                         ;
;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;

;------------------ Print character from (BC) until  $ found ----------------;
Print:                                                                       ;
	LD		A,(BC)						; Get the next character             ;
	CP		DOLLAR						; Is it the end ?                    ;
	RET	Z								;  exit if yes                       ;
	INC		BC							; Update the pointer                 ;
	PUSH	BC							; Save it                            ;
	LD		C,A							; Does Byte require                  ;
	CALL	TabOut						;  special attention - check         ;
	POP		BC							; Retrieve the pointer				 ;		
	JR		Print						; Loop back                          ;
;------------------ Print character from (BC) until  $ found ----------------;

;-- Send printable character to console. Precede with Caret if needed -------;
; character is in Reg C                                                      ;
CaretOut:                                                                    ;
	LD		A,C                                                              ;
	CALL	IsPrintableASCII                                                 ;
	JR		NC,TabOut					; Skip if Caret not needed           ;
; send preceding up arrow                                                    ;
	PUSH	AF							; Save the character                 ;
	LD		C,CARET                                                          ;
	CALL	ConsoleOut					; Send Caret to Console              ;
	POP		AF							; Get the character                  ;
	OR		40H							; Make the graphic a letter          ;
	LD		C,A							; Set up to print                    ;
; fall thru to TabbOut                                                       ;
;-- Send printable character to console. Precede with Caret if needed -------;

;------------- Send printable character to console. Expand if TAB -----------;
; character is in Reg C                                                      ;
 TabOut:                                                                     ;
	LD		A,C                                                              ;
	CP		TAB							; Is it a TAB                        ;
	JP		NZ,ConsoleOut				; Go directly to ConsoleOut if not   ;
	                                                                         ;
 ; TAB encountered                                                           ;
 TabOut0:                                                                    ;
	LD		C,SPACE						; Expand TABs with SPACEs            ;
	CALL	ConsoleOut					; Send to Console                    ;
	LD		A,(columnPosition)			; Get Column position                ;
	AND		111b						; (ColumnPosition mod 8) = 0 ?       ;
	JR		NZ,TabOut0					; Do again if not                    ;
	RET                                                                      ;
;------------- Send printable character to console. Expand if TAB -----------;

;-------------------------- Send character to console -----------------------;
; C  = Character to be output                                                ;
ConsoleOut:                                                                  ;
; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
	PUSH	BC							; Save character and Count           ;
	CALL	ConBreak					; Check for screen stop key stroke   ;
	POP		BC	                                                             ;
	PUSH	BC							; Get/save character                 ;
; Send character to Console	                                                 ;
	CALL	bcConout					; Send character to the console      ;
	POP		BC                                                               ;
	PUSH	BC							; Get/save character                 ;
; is the data to be output to print device?                                  ;
	LD		A,(printEchoFlag)                                                ;
	OR		A                                                                ;
	CALL	NZ,bcList					; Send it to printer, if so          ;
	POP		BC							; Get the character                  ;
																			 ;
	LD		A,C							; Put character to ACC               ;
	LD		HL,columnPosition			; A = char, HL = .columnPosition     ;
	INC		M							; increment the ColumnPosition       ;
																			 ;
	CP		SPACE                                                            ;
	RET		NC							; Exit if ASCII printable            ;
	                                                                         ;
	CP		LF                                                               ;
	RET		NZ							; Exit if not a Line Feed            ;
										                                     ;
	LD		(HL),0						;  else force columnPosition = 0     ;
	RET	                                                                     ;
;-------------------------- Send character to console -----------------------;

;--------------------  Check for Status and Control S or C ------------------;
;  Returns:																	 ;
;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
;			ACC = 00   No data Pending										 ;
;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
;                                                                            ;
 ConBreak:                                                                   ;
	LD		A,(keyboardByte)                                                 ;
	OR		A							; If there is a char waiting         ;
	JR		NZ,ConBreak1 				;  return with FF in ACC             ;
	                                                                         ;
	CALL	bcConst						; Get status                         ;
	CP		00H							; If 00 => No data pending	         ;
	RET		Z							; Return 00 No data pending          ;
	                                                                         ;
	CALL	bcConin						; Read the byte                      ;
	                                                                         ;
	CP		CTRL_P                                                           ;
	JR		NZ,CheckCTL_S                                                    ;
;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
	LD		HL,printEchoFlag                                                 ;
	LD		A,TRUE                                                           ;
	CP		(HL)                                                             ;
	JR		NZ,ToggleFlag1                                                   ;
	LD		A,FALSE                                                          ;
ToggleFlag1:                                                                 ;
	LD		(HL),A                                                           ;
	JR		NothingWaiting                                                   ;
;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
CheckCTL_S:		                                                             ;
	CP		CTRL_S						; If it is not Stop Screen, save     ;
	JR		NZ,ConBreak0				;   and and return 0FFH              ;
																			 ;
	CALL	bcConin						; Else Read next byte                ;
	CP		CTRL_C                                                           ;
	JP		Z,WarmBoot					; do WarmBoot if  CTRL_C             ;
 NothingWaiting:                                                             ;
	XOR		A                                                                ;
	RET									; Set ACC = 0 and return             ;
 ConBreak0:                                                                  ;
	LD		(keyboardByte),A			; save the byte                      ;
 ConBreak1:                                                                  ;
	LD		A,TRUE						; return with true set in ACC        ;
	RET                                                                      ;
;--------------------  Check for Status and Control S or C ------------------;

;------------------------  Console Output Utilities -------------------------;
showHashCRLF:                                                                ;
	LD		C,HASH_TAG                                                       ;
	CALL	ConsoleOut					; Send # to console                  ;
	CALL	showCRLF                                                         ;
showHashCRLF1:                                                               ;
	LD		A,columnPosition                                                 ;
	LD		HL,startingColumn                                                ;
	CP		A,M                                                              ;
	RET		NC                                                               ;
	LD		C,SPACE                                                          ;
	CALL	ConsoleOut                                                       ;
	JR		showHashCRLF1                                                    ;
;------------------------  Console Output Utilities -------------------------;

;------------------------  Send Carriage Return and Line Feed ---------------;
showCRLF:                                                                    ;
	LD		C,CR                                                             ;
	CALL	ConsoleOut                                                       ;
	LD		C,LF                                                             ;
  	JP		ConsoleOut					; exit via ConsoleOuts RET           ;
;------------------------  Send Carriage Return and Line Feed ---------------;

;------------------------- Read a $ terminated String -----------------------;
 ;read to paramDE address (max length, current length, buffer)               ;
ReadString:                                                                  ;
	LD		A,(columnPosition)                                               ;
	LD		(startingColumn),A			; Save start for CTRL_X and CTRL_R   ;
	LD		HL,(paramDE)				; Get the start of the String        ;
	LD		C,(HL)						; Get Max Count  					 ;
	INC		HL							; Point at actual bytes read         ;
	LD		B,0							; Initialize Current Count           ;
																			 ;
	; B = Current Count                                                      ;
	; C = Maximum characters                                                 ;
	; HL= Insertion Pointer                                                  ;
																			 ;
 ; read next character, BC, HL active                                        ;
ReadNext:                                                                    ;
	PUSH	BC							; Save Current Index and Max Count   ;
	PUSH	HL							; Save pointer                       ;
ReadNext0:                                                                   ;
	CALL	ConIn						; Get the next Character             ;
	AND		ASCII_MASK					; Mask parity bit                    ;
	POP		HL							; Restore Pointer					 ;
	POP		BC							; Restore Current Index and Max Count;
;Is It Carriage Return                                                       ;
	CP		CR                                                               ;
	JP		Z,EndRead					; End the read if yes                ;
	CP		LF                                                               ;
;Is It Linefeed                                                              ;
	JP		Z,EndRead					; End the read if yes                ;
;Is It BackSpace                                                             ;
	CP		CTRL_H															 ;
	JP		Z,BSspaceBS	                                                     ;
IsItRubout:                                                                  ;
	CP		RUBOUT						; Non destructive delete             ;
	JP		Z,ItIsRubout                                                     ;
IsPhysicalEOL:                                                               ;
	CP		CTRL_E                                                           ;
	JP		Z,ItIsPhysicalEOL	                                             ;
IsItPrintToggle:                                                             ;
	CP		CTRL_P                                                           ;
	JP		Z,ItIsPrintToggle	                                             ;
IsItDeleteTheLineX:                                                          ;
	CP		CTRL_X                                                           ;
	JP		Z,DeleteTheLine				; If CTRL_X go delete the line       ;
IsItDeleteTheLineU:                                                          ;
	CP		CTRL_U                                                           ;
	JP		Z,IgnoreTheLine				; If CTRL_U ignore the line          ;
;Retype the line                                                             ;
	CP		CTRL_R 														  	 ;
	JP		Z,RepeatLine                                                     ;

;....................... Echo input back to the Console  ....................;
; Full Duplex								                                 ;
; A = Character to display	                                                 ; 
; B = current char count                                                     ;
; C = maximum buffer length                                                  ;
; HL= buffer pointer                                                         ;
;ReadEcho                                                                    ;
	INC		B							; Increment byte count		         ;
	INC		HL							; Advance the Pointer                ;
	LD		(HL),A						; Put char in buffer                 ;
																		     ;
ReadEchoRubOut:                                                              ;
  	PUSH	BC							; Save index and length              ;
	PUSH	HL							; Save the Pointer                   ;
	LD		C,A							; Get char                           ;
	CALL	CaretOut					; Output to Console (^ if needed)    ;
	POP		HL							; Restore the Pointer                ;
	POP		BC							; Restore index and length           ;
	LD		A,(HL)						; Recall char                        ;
; check for Warm Boot                                                        ;
	CP		CTRL_C                                                           ;
	LD		A,B							; Get Line position                  ;
	JP		NZ,AreWeAtEndOfBuffer		; Skip if not CTRL_C                 ;
	CP		1							; Beginning of the Line?             ;
	JP		Z,WarmBoot					;   if yes do the Boot               ;
; Check to see if we are at the end of the buffer                            ;
AreWeAtEndOfBuffer:                                                          ;
	CP		C							; Over Max ?					     ;
	JP		C,ReadNext					;  no, Go for more				     ;
																			 ;
; At the end of read                                  					     ;
EndRead:                                                                     ;
; 	POP		HL                                                               ;
	LD		HL,(paramDE)                                                     ;
	INC		HL                                                               ;
																			 ;
	LD		(HL),B						; Actual length at Pos 0 of Buffer   ;
	LD		C,CR                                                             ;
	JP		ConsoleOut					; Send CR to the Console			 ;
;....................... Echo input back to the Console  ....................;
;.......................... Backspace SPACE BackSpace .......................;
BSspaceBS:				  													 ;
	DEC		B                                                                ;
	DEC		HL                                                               ;
	PUSH	BC                                                               ;
	PUSH	HL                                                               ;
	CALL	BackUp                                                           ;
	JP		ReadNext0                                                        ;
;.......................... Backspace SPACE BackSpace .......................;	
;.......................... It is RubOut ....................................;
ItIsRubout:                                                                  ;
; RUBOUT if possible                                                         ;
	LD		A,B							; Are we at the start of the line    ;
	OR		A                                                                ;
	JP		Z,ReadNext					; then ignore and go for next char   ;
;adjust pointers back one                                                    ;
	LD		A,(HL)                      ; ACC = current character            ;
	DEC		B							; Adjust the index			    	 ;
	DEC		HL							; Adjust the pointer                 ;
	JP		ReadEchoRubOut				; Echo back - Full Duplex            ;
;.......................... It is RubOut ....................................;
;.......................... It is PhysicalEOL ...............................;
ItIsPhysicalEOL:                                                             ;
	PUSH	BC							; Save Current Index and Max Count   ;
	PUSH	HL							; Save pointer                       ;
	CALL	showCRLF					; Make new line                      ;
	JP		ReadNext0					;   and go for next char   			 ;
;.......................... It is PhysicalEOL ...............................;
;.......................... It is PrintToggle ...............................;
ItIsPrintToggle:
	PUSH	HL							; Save pointer                       ;
; Toggle the printEcho Flag                                                  ;
	LD		HL,printEchoFlag			; Point at the flag                  ;
	LD		A,TRUE						; Load ACC with TRUE                 ;
	CP		(HL)						; Is the flag true?                  ;
	JR		NZ,IsItPrintToggle1			; Skip if not                        ;
	LD		A,FALSE						;   else. load ACC with FALSE        ;
IsItPrintToggle1:                                                            ;
	LD		(HL),A						; Set the Flags new Value	         ;
	POP		HL							; Restore pointer                    ;
	JP		ReadNext					;   and for another char             ;
;.......................... It is PrintToggle ...............................;
;.......................... RepeatLine ......................................;
RepeatLine:                                                                  ;
	PUSH	BC							; Save Current Index and Max Count   ;
	PUSH	HL							;  for exit                          ;
	CALL	showHashCRLF				; Display Hash, new Line			 ;
	                                                                         ;
	LD		HL,(paramDE)				; Get start of Buffer                ;
	INC		HL							; Skip past character count          ;
																			 ;
LL1:                                                                         ;
	INC		HL							; Point at next char to display      ;
	PUSH	BC							; Save counter, in B                 ;
	PUSH	HL							; Save buffer pointer                ;
	LD		C,M							; Get the next character             ;
	CALL	CaretOut					; Display it                         ;
	POP		HL							; Restore                            ;
	POP		BC							;  the counter and pointer           ;
	DJNZ	LL1							; loop if still more to show         ;
	POP		HL							; Restore values                     ;
	POP		BC							;  from routine entry                ;
	JP		ReadNext					; Done here !                        ;
;.......................... RepeatLine ......................................;	
;.......................... Delete The Line .................................;
DeleteTheLine:                                                               ;
	POP		HL							; Adjust Stack                       ;
                               ;                                             ;
DeleteTheLine1:                                                              ;
	LD		A,(startingColumn)                                               ;
	LD		HL,columnPosition                                                ;
	CP		M							; Start of line ?                    ;
	JP		NC,ReadString				;  If yes get out and go for more    ;
	DEC		M							; Adjust the ColumnPosition          ;
	CALL	BackUp						; Clear 1 column                     ;
	JR		DeleteTheLine1				; Loop for more                      ;
;.......................... Delete The Line .................................;
;------------------------ Back-up one screen position -----------------------;
BackUp:                                                                      ;
  	CALL	BackUp1						; Send Backspace                     ;
	LD		C,SPACE						; Overwrite with SPACE               ;
	CALL	bcConout					; Overwrite with SPACE				 ;
;does not affect column count                                                ;
BackUp1:                                                                     ;
	LD		C,CTRL_H                                                         ;
	JP		bcConout					; Send Backspace                     ;
;------------------------ Back-up one screen position -----------------------;
;.......................... Ignore The Line .................................;
IgnoreTheLine:                                                               ;
	CALL	showHashCRLF				; Display Hash, new Line			 ;
	LD		C,SPACE						; We want to add a few spaces        ;
	CALL	bcConout					;  to the console                    ;
	LD		C,SPACE                                                          ;
	CALL	bcConout                                                         ;
	JP		ReadString					; Start all over                     ;
;.......................... Ignore The Line .................................;

;------------------------- Read a $ terminated String -----------------------;

;****************************************************************************
;                           DATA AREA                                       *
;****************************************************************************

;------------------------------Non Disk Data Area ---------------------------;
usersStack:			DS	2				; entry stack pointer                ;
																			 ;
keyboardByte:		DB	00				; Saved keyboard character           ;
																			 ;
printEchoFlag:		DB	00				; Controlled by ^P                   ;
																			 ;
; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
startingColumn:		DB	0				; Starting col pos after read        ;
columnPosition:		DB	0				; Current Column position            ;
																			 ;
paramE:				DS	BYTE			; Byte Argument for BDOS Call        ;
paramDE:			DS	WORD			; Word Argument for BDOS Call	     ;
exitParameterByte:						; Byte returned Value                ;
exitParameterWord:	DS	WORD				; Word                           ;
																			 ;
																			 ;
;------------------------------------ Data Area -----------------------------;



;****************************************************************************;
;								Disk I/O									 ;
;****************************************************************************;

;---------------------------- Reset Disk System - D (13) --------------------;
;  This function requests CP/M to completely reset the disk file system.     ;
; CP/M then resets its internal tables, selects logical disk A as the        ;
; default disk, resets the DMAaddress back to 0080H (the address of the      ;
; buffer used by the BDOS to read and write to the disk), and marks all      ;
; logical disks as having Read/Write status. The BDOS will then have to log  ;
; in each logical disk as each disk is accessed. This involves reading the   ;
; entire file directory for the disk and rebuilding the allocation vectors   ;
; which keep track of which allocation blocks are free and which             ;
; are used for file storage.                                                 ;
;                                                                            ;
;			Function Code	:	C = 0DH                                      ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Reset Disk System - D (13) --------------------;
vResetSystem:
  	LD		HL,0
	LD		(readOnlyVector),HL			; Clear the vectors for 
	LD		(loggedDisks),HL			;   R/O and Logged Disks
	XOR		A							; Clear the current disk
	LD		(currentDisk),A
; note that currentUserNumber remains unchanged
	LD		HL,DMABuffer
	LD		(initDAMAddress),HL			; initDAMAddress = DMABuffer
	CALL	SetDataDMA					; to data dma address
	JP		Select
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;---------------------------- Get Active Disks - 18 (24) --------------------;
; This function returns a bit map, called the login vector, in register pair ;
; HL, indicating which logical disk drives have been selected since the last ;
; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
; The bit corresponding to the specific logical disk is set to 1 if the      ;
; disk has been selected or to 0 if the disk is not currently on-line.       ;
;  Logical disks can be selected programmatically through any file operation ;
; that sets the drive field to a nonzero value, through the Select Disk      ;
; function (code 14, OEH), or by the operator entering an "X:" command       ;
; where "X" is equal to A, B, ... , P.                                       ;
;                                                                            ;
;			Function Code	:	C = 018H                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Active disk map (login vector)			 ;
;																			 ;
;---------------------------- Get Active Disks - 18 (24) --------------------;
vGetLoginVector:
	LD		HL,(loggedDisks)
	LD		(exitParameterWord),HL
	RET
;---------------------------- Get Current Disk- 19 (25) ---------------------;
;   This function returns the current default disk set by the last Select    ;
; Disk function call (code 14, OEH) or by the operator entering the          ;
; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
;                                                                            ;
;  This function returns the current default disk in coded form.             ;
; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
; If you need to convert this to the corresponding ASCII character, simply   ;
; add 41H to register A. Use this function when you convert a file name and  ;
; type in an FCB to an ASCII string in order to display it. If the first     ;
; byte of the FCB is OOH, the current default drive is to be used.           ;
; You must therefore use this function to determine the logical disk letter  ;
; for the default drive.                                                     ;
;                                                                            ;
;			Function Code	:	C = 019H                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
;																			 ;
;---------------------------- Get Current Disk- 19 (25) ---------------------;
vGetCurrentDisk:
	LD		A,(currentDisk)
	LD		(exitParameterByte),A
	RET
;---------------------------- Set DMA Address - 1A (26) ---------------------;
;  This function sets the BDOS's direct memory access (DMA) address to a new ;
; value. The name is an historic relic dating back to the Intel Development  ;
; System on which CP/M was originally developed. This machine, by virtue of  ;
; its hardware, could read data from a diskette directly into memory or      ;
; write data to a diskette directly from memory. The name DMA address now    ;
; applies to the address of the buffer to and from which data is             ;
; transferred whenever a diskette Read, Write, or directory operation is     ;
; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
; Reset Disk operation occurs, the DMA address is reset to its default       ;
; value of 0080H.                                                            ;
;                                                                            ;
;			Function Code	:	C = 0A9H                                     ;
;			Entry Parameters:	DE = DMA Address							 ;
;			Exit Parameters :	None										 ;
;																			 ;
;---------------------------- Set DMA Address - 1A (26) ---------------------;
vSetDMA:
	LD		HL,(paramDE)
	LD		(initDAMAddress),HL
	JP		SetDataDMA
;---------------------------- Get Allocation Vector - 1B (27) ---------------;
;  This function returns the base, or starting, address of the allocation    ;
; vector for the currently selected logical disk. This information,          ;
; indicating which parts of the disk are assigned, is used by utility        ;
; programs and the BDOS itself to determine how much unused space is on the  ;
; logical disk, to locate an unused allocation block in order to extend      ;
; a file, or to relinquish an allocation block when a file is deleted.       ;
;                                                                            ;
;			Function Code	:	C = 01BH                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Address of allocation vector			 ;
;																			 ;
;---------------------------- Get Allocation Vector - 1B (27) ---------------;
vGetAllocAddr:
	LD		HL,(caAllocVector)
	LD		(exitParameterWord),HL
	RET
;---------------------------- Get Read-Only Map - 1D (29) -------------------;
;  This function returns a bit map in registers H and L showing which logical;
; disks in the system have been set to Read-Only status, either by the       ;
; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
; BDOS itself, because it detected that a diskette had been changed.         ;
;  The least significant bit of L corresponds to logical disk A, while the   ;
; most significant bit of H corresponds to disk P. The bit corresponding to  ;
; the specific logical disk is set to I if the disk has been set to          ;
; Read-Only status.                                                          ;
;                                                                            ;
;			Function Code	:	C = 0DBH                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Read-Only Map							 ;
;																			 ;
;---------------------------- Get Read-Only Map - 1D (29) -------------------;
vGetReadOnlyMap:
	LD		HL,(readOnlyVector)
	LD		(exitParameterWord),HL
	RET
;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
;  This function returns the address of the disk parameter block (DPB) for   ;
; the last selected logical disk. The DPB describes the physical             ;
; characteristics of a specific logical disk-information mainly of interest  ;
; for system utility programs.                                               ;
;                                                                            ;
;			Function Code	:	C = 1FH                                     ;
;			Entry Parameters:	None										 ;
;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
;																			 ;
;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
vGetDiskParamBlock:							; func31 (31 - 1F)
	LD		HL,(caDiskParamBlock)
	LD		(exitParameterWord),HL
	RET
 
;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
;  This function resets individual disk drives. It is a more precise version ;
; of the Reset Disk System function (code 13,ODH), in that you can set       ;
; specific logical; disks rather than all of them.                           ;
;  The bit map in DE shows which disks are to be reset. The least significant;
; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
; The bits set to I indicate the disks to be reset.                          ;
;  Note that this function returns a zero value in A in order to maintain    ;
; compatibility with MP/ M.                                                  ;
;                                                                            ;
;			Function Code	:	C = 25H                                      ;
;			Entry Parameters:	DE = Logical Drive Bit Map					 ;
;			Exit Parameters :	A = 00H										 ;
;																			 ;
;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
;Reset Drive
 ;IN  - (DE) Drive Vector
 ;OUT - (A) 00
 vResetDrive:								; func37 (37 - 25) Reset Drive
 ; Not Yet Implemented   **************
	RET
 ;*****************************************************************

;-----------------------------------------------------------------
 ;select disk in (E) paramDE
 ; IN - (E) disk number -- 0=A  1=B ...15=P
 vSelectDisk:								; func14 (14 - 0E)	Select Current Disk
	JP	SelectCurrent
	;ret ;jmp goba


 ;*****************************************************************
 ;random disk read
 ;IN  - (DE) FCB address
 ;OUT - (A) 01 = Reading unwritten data
 ;	 02 = N/U
 ;	 03 = Cannot close current extent
 ;	 04 = Seek to unwriten Extent
 ;	 05 = N/U
 ;	 06 = Seek past Physical end of Disk
 vReadRandom:								; func33 (33 - 21) Read Random record
	CALL	Reselect
	JP		RandomDiskRead					; to perform the disk read
 ;*****************************************************************
 ;write random record
 ;IN  - (DE) FCB address
 ;OUT - (A) 01 = Reading unwritten data
 ;	 02 = N/U
 ;	 03 = Cannot close current extent
 ;	 04 = Seek to unwriten Extent
 ;	 05 = Cannot create new Extent because of directory overflow
 ;	 06 = Seek past Physical end of Disk
 vWriteRandom:								; func34 (34 - 22) Write Random record
	CALL	Reselect
	JP		RandomDiskWrite					; to perform the disk write
	;ret ;jmp goback
 ;*****************************************************************
 ;return file size (0-65536)
 ;IN  - (DE) FCB address
 vComputeFileSize:							; func35 (35 - 23) Compute File Size
	CALL	Reselect
	JP		GetFileSize
 ;*****************************************************************
 ;set random record
 ;IN  - (DE) FCB address
 ;OUT - Random Record Field is set
 vSetRandomRecord:							; func36 (36 - 24) Set random Record
	JP		SetRandomRecord
;? ;*****************************************************************
;? ;Reset Drive
;? ;IN  - (DE) Drive Vector
;? ;OUT - (A) 00
;? vResetDrive:								; func37 (37 - 25) Reset Drive
;? ; Not Yet Implemented   **************
;?	RET
 ;*****************************************************************
 ;*****************************************************************
 ;Write Random With Zero Fill
 ;IN  - (DE) FCB address
 ;OUT - (A) Return Code		see Function 34
 vWriteRandom0Fill:								; func40 (40 - 28) Reset Drive
 ; Not Yet Implemented   **************
	RET
 ;*****************************************************************
 ;******************< Random I/O Stuff ****************************
 ;*****************************************************************
 ;random disk read
 RandomDiskRead:								; randiskread
	LD		C,TRUE							; marked as read operation
	CALL	RandomSeek
	CALL	Z,DiskRead						; if seek successful
	RET
 ;*****************************************************************
 ;random disk write
 RandomDiskWrite:							; randiskwrite
	LD		C,FALSE							; marked as read operation
	CALL	RandomSeek
	CALL	Z,DiskWrite						; if seek successful
	RET
 ;*****************************************************************
 ;*****************************************************************
 ;random access seek operation, C=0ffh if read mode
 ;fcb is assumed to address an active file control block
 ;(fcbS2Index has been set to 11000000b if previous bad seek)
 RandomSeek:
  	XOR		A
	LD		(seqReadFlag),A						; marked as random access operation
	PUSH	BC								; save r/w flag
	LD	HL,(paramDE)
	EX	DE,HL ; DE will hold base of fcb
	LD		HL,RANDOM_REC_FIELD
	ADD		HL,DE								; HL=.fcb(RANDOM_REC_FIELD)
	LD		A,(HL)
	AND		7FH
	PUSH	AF								; record number
	LD		A,(HL)
	RLA										; cy=lsb of extent#
	INC		HL
	LD		A,(HL)
	RLA
	AND		11111B							; A=ext#
	LD		C,A								; C holds extent number, record stacked
	LD		A,(HL)
	RRA
	RRA
	RRA
	RRA
	AND		1111B							; mod#
	LD		B,A								; B holds module#, C holds ext#
	POP		AF								; recall sought record #
											;check to insure that high byte of ran rec = 00
	INC		HL
	LD		L,(HL)								; l=high byte (must be 00)
	INC		L
	DEC		L
	LD		L,06							; zero flag, l=6
											; produce error 6, seek past physical eod
	JP	NZ,RandomSeekError
											; otherwise, high byte = 0, A = sought record
	LD		HL,NEXT_RECORD
	ADD		HL,DE								; HL = .fcb(NEXT_RECORD)
	LD		(HL),A								; sought rec# stored away
											; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
											; the r/w flag is still stacked.  compare fcb values
	LD		HL,fcbExtIndex						; extent number field
	ADD		HL,DE
	LD		A,C								; A=seek ext#
	SUB		M
	JP	NZ,RandomSeekClose					; tests for = extents
											; extents match, check mod#
	LD		HL,fcbS2Index
	ADD		HL,DE
	LD		A,B								; B=seek mod#
											; could be overflow at eof, producing module#
											; of 90H or 10H, so compare all but fwf
	SUB		M
	AND		7FH
	JP	Z,RandomSeekExit				; same?
 RandomSeekClose:
	PUSH	BC
	PUSH	DE								; save seek mod#,ext#, .fcb
	CALL	CloseDirEntry					; current extent closed
	POP		DE
	POP		BC								; recall parameters and fill
	LD		L,03							; cannot close error #3
	LD		A,(exitParameterByte)
	INC		A
	JP	Z,RandomSeekErrorBadSeek
	LD		HL,fcbExtIndex
	ADD		HL,DE
	LD		(HL),C								; fcb(fcbExtIndex)=ext#
	LD		HL,fcbS2Index
	ADD		HL,DE
	LD		(HL),B								; fcb(fcbS2Index)=mod#
	CALL	OpenFile						; is the file present?
	LD		A,(exitParameterByte)
	INC		A
	JP	NZ,RandomSeekExit					; open successful?
											; cannot open the file, read mode?
	POP		BC								; r/w flag to c (=0ffh if read)
	PUSH	BC								; everyone expects this item stacked
	LD		L,04							; seek to unwritten extent #4
	INC		C								; becomes 00 if read operation
	JP	Z,RandomSeekErrorBadSeek			; skip to error if read operation
	CALL	MakeNewFile						; write operation, make new extent
	LD		L,05							; cannot create new extent #5
	LD		A,(exitParameterByte)
	INC		A
	JP	Z,RandomSeekErrorBadSeek			; no dir space
 ; file make operation successful
 RandomSeekExit:								; seekok:
	POP		BC								; discard r/w flag
	XOR		A
	LD		(exitParameterByte),A
	RET										; with zero set

 RandomSeekErrorBadSeek:
 ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
 ; appears as overflow with file write flag set
	PUSH	HL								; save error flag
	CALL	GetModuleNum					; HL = .fcbS2Index
	LD		(HL),11000000B
	POP		HL								; and drop through
 RandomSeekError:							; seekerr:
	POP		BC								; discard r/w flag
	LD		A,L
	LD		(exitParameterByte),A					; exitParameterByte=#, nonzero
 ; SetFileWriteFlag returns non-zero accumulator for err
	JP		SetFileWriteFlag				; flag set, so subsequent close ok
	;ret
 ;
 ;*****************************************************************
 SetRandomRecord:							; setrandom
	LD	HL,(paramDE)
	LD		DE,NEXT_RECORD					; ready params for computesize
	CALL	GetRandomRecordPosition			; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
	LD		HL,RANDOM_REC_FIELD
	ADD		HL,DE								; HL = .FCB(RANDOM_REC_FIELD)
	LD		(HL),C
	INC		HL
	LD		(HL),B
	INC		HL
	LD		(HL),A								; to RANDOM_REC_FIELD
	RET
 ;*****************************************************************
 ;compute logical file size for current fcb
 GetFileSize:								; getfilesize
	LD		C,fcbExtIndex
	CALL	Search4DirElement
 ; zero the receiving Ramdom record field
	LD	HL,(paramDE)
	LD		DE,RANDOM_REC_FIELD
	ADD		HL,DE
	PUSH	HL								; save position
	LD		(HL),D
	INC		HL
	LD		(HL),D
	INC		HL
	LD		(HL),D								; =00 00 00
 GetFileSize1:								; getsize:
	CALL	EndOfDirectory
	JP	Z,GetFileSizeExit
 ; current fcb addressed by dptr
	CALL	GetDirElementAddress
	LD		DE,fcbRCIndex					; ready for compute size
	CALL	GetRandomRecordPosition
 ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
	POP		HL
	PUSH	HL								; recall, replace .fcb(Random record Field)
	LD		E,A								; save cy
	LD		A,C
	SUB		M
	INC		HL								; ls byte
	LD		A,B
	SBC		A,(HL)
	INC		HL								; middle byte
	LD		A,E
	SBC		A,(HL)								; carry if .fcb(random record field) > directory
	JP	C,GetFileSize2							; for another try
											; fcb is less or equal, fill from directory
	LD		(HL),E
	DEC		HL
	LD		(HL),B
	DEC		HL
	LD		(HL),C
 GetFileSize2:								; getnextsize:
	CALL	Search4NextDirElement
	JP		GetFileSize1
 GetFileSizeExit:							; setsize:
	POP		HL								; discard .fcb(random record field)
	RET
 ;-----------------------------------------------------------------
 ;compute random record position
 GetRandomRecordPosition:				; compute$rr
	EX	DE,HL 
	ADD		HL,DE
 ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
	LD		C,(HL)
	LD		B,0							; BC = 0000 0000 ?rrr rrrr
	LD		HL,fcbExtIndex
	ADD		HL,DE
	LD		A,(HL)
	RRCA
	AND		80H							; A=e000 0000
	ADD		A,C
	LD		C,A
	LD		A,0
	ADC		A,B
	LD		B,A
 ; BC = 0000 000? errrr rrrr
	LD		A,(HL)
	RRCA
	AND		LO_NIBBLE_MASK
	ADD		A,B
	LD		B,A
										; BC = 000? eeee errrr rrrr
	LD		HL,fcbS2Index
	ADD		HL,DE
	LD		A,(HL)							; A=XXX? mmmm
	ADD		A,A
	ADD		A,A
	ADD		A,A
	ADD		A,A							; cy=? A=mmmm 0000
	PUSH	AF
	ADD		A,B
	LD		B,A
 ; cy=?, BC = mmmm eeee errr rrrr
	PUSH	AF							; possible second carry
	POP		HL							; cy = lsb of L
	LD		A,L							; cy = lsb of A
	POP		HL							; cy = lsb of L
	OR		L 							; cy/cy = lsb of A
	AND		1 							; A = 0000 000? possible carry-out
	RET
 ;-----------------------------------------------------------------

 

 ;*****************************************************************
 ;********************** Disk  I/O ********************************
 ;*****************************************************************
  ;-----------------------------------------------------------------
 ;;write protect current disk
 vWriteProtectDisk:							; func28 (28 - 1C) Write protect disk
	JP	SetDiskReadOnly
 ;-----------------------------------------------------------------
 ;;set file Attributes
 vSetFileAttributes:							; func30 (30 - 1E) Set File Attributes
	CALL	Reselect
	CALL	SetAttributes
	JP	DirLocationToReturnLoc				; exitParameterByte=dirloc
 ;-----------------------------------------------------------------

 SelectCurrent:								; curselect
	LD	A,(paramE)
	LD	HL,currentDisk
	CP	M
	RET	Z; exit if parame = Current disk
	LD	(HL),A
	JP	Select
 ;*****************************************************************
;--------------------------- Select Login Drive -----------------------------;
 ; select Login Drive                                                        ;
Select:                                                                      ;
 	CALL	SelectDisk					; Select the Disk                    ;
	CALL	Z,errSelect                                                      ;
	LD		HL,currentDisk													 ;
	LD		B,(HL)						; Get Current Disk                   ;
	LD		HL,(loggedDisks)			; Load Logged Disk MAP               ;
	CALL	IsBitSet                                                         ;
	RET		NZ							; Exit if already logged in          ;
;                                                                            ;
	LD		HL,currentDisk													 ;
	LD		B,(HL)						; Get Current Disk                   ;
	LD		HL,(loggedDisks)			; else log in a different disk	     ;
	CALL	SetMapBit                                                        ;
	LD		(loggedDisks),HL			; Update the Map                     ;
	                                                                         ;
	JP		InitDisk                                                         ;
;--------------------------- Select Login Drive -----------------------------;

;--------------------------- Select Disk ------------------------------------;
 ;*****************************************************************          ;
 ; select the disk drive given by currentDisk, and fill the base addresses   ;
 ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
SelectDisk:                                                                  ;
	LD		A,(currentDisk)				; Get current disk (0=A,1=B...)      ;
	LD		C,A							; Prepare for BIOS Call              ;
	CALL	bcSeldsk					; Select the disk                    ;
	LD		A,H							; Return Pointer to                  ;
	OR		L							;  Disk Parameter Header             ;
	RET		Z							; exit if error, with HL = 0000      ;
                                                                             ;
	LD		E,(HL)                                                           ;
	INC		HL                                                               ;
	LD		D,(HL)						; Skew Table in DE                   ;
	INC		HL							; HL = DPH + 2, Rel Pos for File     ;
	LD		(caSkewTable),DE			; Move to Current Skew Table         ;
	                                                                         ;
	LD		(caDirMaxValue),HL			; Move to Current Dir max            ;
	INC		HL                                                               ;
	INC		HL							; HL = Last Track #                  ;
	LD		(caTrack),HL				; Move to Current Track #            ;
	INC		HL                                                               ;
	INC		HL							; HL = Last Sector #                 ;
	LD		(caSector),HL				; Move to Current Sector #           ;
	INC		HL                                                               ;
	INC		HL                                                               ;
	LD		DE,caDirectoryDMA                                                ;
	LD		BC,caListSize                                                    ;
	LDIR                                                                     ;
                                                                             ;
; finish filling in address list                                             ;
	LD		HL,(caDiskParamBlock)		; Point Disk Parameter Block         ;
	LD		DE,dpbStart					; Point at BIOS DPB                  ;
	LD		BC,dpbSize                                                       ;
	LDIR								; Move DPB to current                ;
	                                                                         ;
; Determine if Byte or Word Allocation Table	                             ;
	LD		HL,(dpbDSM)					; Get max entry number               ;
	LD		A,H							; If  its 00 then < 255              ;
	LD		HL,byteAllocationFlag		; Point at the  flag				 ;
	LD		(HL),TRUE					; Assume its less than 255           ;
	OR		A							;  is the assumption confirmed ?     ;
	JR		Z,SelectDisk1				;  skip if yes                       ;
	LD		(HL),FALSE					; Fix assumption,set flag to false   ;
	                                                                         ;
; Set Sign, reset Carry and Zero to indicate success                         ;
 SelectDisk1:                                                                ;
	LD	A,TRUE                                                               ;
	OR	A								                                     ;
	RET                                                                      ;
;--------------------------- Select Disk ------------------------------------;
;--------------------------- Initialize Disk --------------------------------;
InitDisk:
	LD		HL,(dpbDSM)					; Maximum allocation value
	LD		B,3							; We want dpbDSM/8
InitDiskLoop1:
	XOR		A							; Rest the CY flag
	RR		H
	RR		L							; Shift right
	DJNZ	InitDiskLoop1				; Loop till divide by 8
	PUSH	HL
	POP		BC							; BC = dpbDSM/8+1
; Clear the Allocation Vector	
	LD		HL,(caAllocVector)			; Allocation vector Start
	LD		(HL),0						; Clear location
	LD		DE,(caAllocVector)
	INC		DE							; Allocation vector Start + 1
	LDIR								; Cascade 00 thru Allocation Vector
; Mark the reserved space for the directory
	LD		HL,(dpbDABM)				; Directory block reserved bits
	EX		DE,HL 
	LD		HL,(caAllocVector)			; HL Start of Allocation Vector
	LD		(HL),E
	INC		HL
	LD		(HL),D						; Put reserved blocks in Vector	
; home disk, and set current track and sector to 00
	CALL	Home
	LD		HL,(caDirMaxValue)
	LD		(HL),3
	INC		HL
	LD		(HL),0						; Current Max Dir Value = 0003
	CALL	SetEndDirectory				; dirEntryIndex = EOD (-1)

 InitDisk1:
; Process the directory for 
	LD		C,TRUE						; Set flag for setting CheckSum	
	CALL	ReadDirectory
	CALL	EndOfDirectory
	RET		Z							; Exit at end of directory
; not end of directory, valid entry?
	CALL	GetDirElementAddress		; Calculate the location of the element
	LD		A,emptyDir
	CP		M
	JP	Z,InitDisk1						; go get another item
 ; not emptyDir, user code the same?
	LD		A,(currentUserNumber)
	CP		M
	JP	NZ,InitDisk2
 ; same user code, check for '$' submit
	INC		HL
	LD		A,(HL)								; first character
	SUB		DOLLAR							; dollar file?
	JP	NZ,InitDisk2
 ; dollar file found, mark in exitParameterByte
	DEC		A
	LD		(exitParameterByte),A					; exitParameterByte = 255
 InitDisk2:
 ; now scan the disk map for allocated blocks
	LD		C,1								; set to allocated
	CALL	ScanDiskMap
	CALL	SetDirectoryEntry				; set DirMaxVAlue to dirEntryIndex
	JP		InitDisk1						; for another entry
;--------------------------- Initialize Disk --------------------------------;
 ;---------------
 ; set a "1" value in currentDisk position of BC
 ; return in HL
 SetCurrentDiskBit:
	PUSH	BC								; save input parameter
	LD		A,(currentDisk)
	LD		C,A								; ready parameter for shift
	LD		HL,1								; number to shift
	CALL	ShiftLeftHLbyC							; HL = mask to integrate
	POP		BC								; original mask
	LD		A,C
	OR		L
	LD		L,A
	LD		A,B
	OR		H
	LD		H,A								; HL = mask or rol(1,currentDisk)
	RET
 ;--------------
;--------------------------- Set disk Read Only ----------------------------;
 ;set current disk to read only
 SetDiskReadOnly:
	LD		HL,readOnlyVector			; Get the Vector
	
;	LD		B,(currentDisk)				; Get the current disk
;	CALL	SetMapBit					; Set the bit
	LD		C,(HL)
	INC		HL
	LD		B,(HL)
	CALL	SetCurrentDiskBit				; sets bit to 1
	LD		(readOnlyVector),HL			; Update the Vector

	
	
	LD	HL,(dpbDRM)						; Directory Max Value
	EX	DE,HL ; DE = directory max
	LD	HL,(caDirMaxValue)					; HL = .Directory max value
	LD		(HL),E
	INC		HL
	LD		(HL),D								; cdrmax = dpbDRM

;	LD		IX(dpbDRM)
	RET
 ;--------------------------- Set disk Read Only ----------------------------;

 ;
 ;-------------Scan the disk map for unallocated entry-----------------------------------
 ; scan the disk map addressed by dptr for non-zero entries.  The allocation
 ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
 ScanDiskMap:
	PUSH	BC								; save the set/reset bit
	CALL	GetDirElementAddress			; HL = buffa + dptr
  ; HL addresses the beginning of the directory entry
	LD		DE,fcbDiskMapIndex
	ADD		HL,DE								; hl now addresses the disk map
	LD		C,fcbLength-fcbDiskMapIndex+1	; size of Disk Allocation Map + 1

 ScanDiskMap0:								; loop once for each disk map entry
	POP		DE								; recall the set/reset bit
	DEC		C
	RET	Z

	PUSH	DE								; save the set/reset bit
	LD		A,(byteAllocationFlag)							; byteAllocationFlag byte entry flag
	OR		A
	JP	Z,ScanDiskMap1					; skip if two byte value
 ;  Byte Allocation scan operation
	PUSH	BC								; save counter
	PUSH	HL								; save map address
	LD		C,(HL)
	LD		B,0								; BC=block#
	JP		ScanDiskMap2
 ; two byte scan operation
 ScanDiskMap1:
	DEC		C								; adjust counter for double byte
	PUSH	BC								; save counter
 ;	MOV		C,M
	LD		B,(HL)
	INC		HL
 ;	MOV		B,M								; BC=block#
	LD		C,(HL)								; BC=block#
	PUSH	HL								; save map address
 ScanDiskMap2:								; arrive here with BC=block#, E=0/1
	LD		A,C
	OR		B								; skip if = 0000
	CALL	NZ,SetAllocBit						; bit set to 0/1 its in C
	POP		HL
	INC		HL								; to next bit position
	POP		BC								; recall counter
	JP		ScanDiskMap0					; for another item
 ;
 ;-----------------------------------
 ;given allocation vector position BC, return with byte
 ;containing BC shifted so that the least significant
 ;bit is in the low order accumulator position.  HL is
 ;the address of the byte for possible replacement in
 ;memory upon return, and D contains the number of shifts
 ;required to place the returned value back into position

 GetAllocBit:								; getallocbit
	LD		A,C
	AND		111b
	INC		A
	LD		E,A
	LD		D,A
 ; d and e both contain the number of bit positions to shift
	LD		A,C
	RRCA
	RRCA
	RRCA
	AND		11111b
	LD		C,A								; C shr 3 to C
	LD		A,B
	ADD		A,A
	ADD		A,A
	ADD		A,A
	ADD		A,A
	ADD		A,A								; B shl 5
	OR		C
	LD		C,A								; bbbccccc to C
	LD		A,B
	RRCA
	RRCA
	RRCA
	AND		11111b
	LD		B,A								; BC shr 3 to BC
	LD	HL,(caAllocVector)					; base address of allocation vector
	ADD		HL,BC
	LD		A,(HL)								; byte to A, hl = .alloc(BC shr 3)
	 ;now move the bit to the low order position of A
 GetAllocBitl:
	RLCA
	DEC		E
	JP	NZ,GetAllocBitl
	RET

 ;-----------------------------------
 ; BC is the bit position of ALLOC to set or reset.  The
 ; value of the bit is in register E.
 SetAllocBit:
	PUSH	DE
	CALL	GetAllocBit						; shifted val A, count in D
	AND		11111110b						; mask low bit to zero (may be set)
	POP		BC
	OR		C								; low bit of C is masked into A
	JP		RotateAndReplace				; to rotate back into proper position
	;ret
 ;-----------------------------------
 ; byte value from ALLOC is in register A, with shift count
 ; in register C (to place bit back into position), and
 ; target ALLOC position in registers HL, rotate and replace
 RotateAndReplace:
	RRCA
	DEC	D
	JP	NZ,RotateAndReplace					; back into position
	LD	(HL),A									; back to ALLOC
	RET
 ;-----------------------------------
;--------------------------- Home The Current Disk -------------------------;
;move to home position, then offset to start of dir                         ;
Home:                                                                       ;
	CALL	bcHome						; Sets Track to 0, and checks       ;
										; if Buffer needs to be written     ;
	LD		HL,dpbOFF					; Number of tracks before directory ;
	LD		C,(HL)                                                          ;
	INC		HL                                                              ;
	LD		B,(HL)                                                          ;
	CALL	bcSettrk					; Point at 1st directory position   ;
	                                                                        ;
; Set Current Track and Sector to 00                                        ;
	XOR		A							; set ACC to 00                     ;
	LD		HL,(caTrack)				                                    ;
	LD		(HL),A                                                          ;
	INC		HL                                                              ;
	LD		(HL),A                                                          ;
	LD	HL,(caSector)                                                       ;
	LD		(HL),A                                                          ;
	INC		HL                                                              ;
	LD		(HL),A                                                          ;
	RET                                                                     ;
                                                                            ;
;--------------------------- Home The Current Disk -------------------------;

 ;*****************************************************************

 ;*****************************************************************
;=========================== Disk Utilities ================================;
;--------------------------- Set DMAs -------------------------------------;
SetDataDMA:                                                                ;
	LD		HL,initDAMAddress                                              ;
	JR		SetDMA						; Skip to complete the call        ;
;	LD		BC,initDAMAddress                                              ;
;	JP		bcSetdma					; Call BIOS to set                 ;
                                                                           ;
SetDirDMA:                                                                 ;
	LD		HL,caDirectoryDMA			; Load current directory Buffer    ;
;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
;	JP		bcSetdma					; Call BIOS to set                 ;
	                                                                       ;
SetDMA:									                              	   ;
	LD		C,(HL)                                                         ;
	INC		HL                                                             ;
	LD		B,(HL)							; parameter ready              ;
	JP		bcSetdma						; call bios to set             ;
;--------------------------- Set DMAs -------------------------------------;
;--------------------------- Read Buffer ----------------------------------;
;reads into current DMA, using current Disk,Track and Sector               ;
ReadBuffer:                                                                ;
	CALL	bcRead						; Do the read at the BIOS level    ;
	OR		A							; Check status                     ;
	JP		NZ,erPermanentNoWait		; Report if Status not OK          ;
	RET                                                                    ;
;--------------------------- Read Buffer ----------------------------------;


;=========================== Disk Utilities ================================;
 
;=========================== File Utilities ================================;
;--------------------------- Set Record Variables -------------------------;
;set variables from currently FCB - Current Record, RC, EXM                ;
SetRecordVars:                                                             ;
	CALL	GetFcbRecordDetails			; DE = .RecordCount                ;
										;  and HL => .CurrentRecord        ;
	LD		A,(HL)                                                         ;
	LD		(currentFileRecord),A		; Save current record              ;
	EX		DE,HL                                                          ;
	LD		A,(HL)                                                         ;
	LD		(fcbRecordCount),A			; Save the FCBs RC                 ;
	CALL	GetExtentAddress			; HL=.FCB(fcbExtIndex)             ;
	LD		A,(dpbEXM)					; Extent mask                      ;
	AND		M							; Remove unwanted bits             ;
	LD		(extentValue),A				; Store the value                  ;
	RET                                                                    ;
;--------------------------- Set Record Variables -------------------------;

;----------------------Get File Record Count and Current Record------------;
; returns with DE pointing at RC from FCB                                  ;
;         with HL pointing at Current Record                               ;
 GetFcbRecordDetails:                                                      ;
	LD		HL,(paramDE)				; Get FCB start                    ;
	LD		DE,fcbRCIndex				; Offset to Record Count           ;
	ADD		HL,DE                                                          ;
	EX		DE,HL						; DE Points to Record Count        ;
	LD		HL,NEXT_RECORD-fcbRCIndex                                      ;
	ADD		HL,DE						; HL Points to Current Record      ;
	RET                                                                    ;
;----------------------Get File Record Count and Current Record------------;
;----------------------Get FileExtent--------------------------------------;
 ;get current extent field address to (HL)                                 ;
 GetExtentAddress:                                                         ;
	LD		HL,(paramDE)				; Get FCB                          ;
	LD		DE,fcbExtIndex				; Get EXT offset                   ;
	ADD		HL,DE						; HL=.fcb(fcbExtIndex)             ;
	RET                                                                    ;
;----------------------Get FileExtent--------------------------------------;

;=========================== File Utilities ================================;

;=========================== Directory Utilities ===========================;
;--------------------------- Set End of Directory indicator ----------------;                                     
SetEndDirectory:                                                            ;
	LD		HL,EOD						; Put -1 (0FFFFH) in index          ;                                               
	LD		(dirEntryIndex),HL                                              ;
	RET                                                                     ;
;--------------------------- Set End of Directory indicator ----------------;
;--------------------------- Get Directory Element -------------------------;
; compute the address of a directory element in Directory Buffer            ;
GetDirElementAddress:                                                       ;
	LD		HL,(caDirectoryDMA)			; Get the Directory Buffer base     ;
	LD		A,(dirBlockIndex)			; Get the index value               ;
	LD		C,A                                                             ;
	XOR		A							; Set to Zero and reset CY          ;
	LD		B,A                                                             ;
	ADC		HL,BC						; Compute the Entry Location        ;
	RET                                                                     ;
;--------------------------- Get Directory Element -------------------------;
;--------------------------- Set Directory Entry ---------------------------;
; Will update directory if not in the directory                             ;
                                                                            ;
SetDirectoryEntry:                                                          ;
	CALL	StillInDirectory                                                ;
	RET	C								; Exit if still in the Directory  	;
																			;
; StillInDirectory will return with:                                        ;
;									DE = Directory entry number             ;
;									HL = Address of entry number + 1        ;
	INC	DE                                                                  ;
	LD	(HL),D                                                              ;
	DEC	HL                                                                  ;
	LD	(HL),E                                                              ;
	RET                                                                     ;
;--------------------------- Set Directory Entry ---------------------------;

;--------------------------- Are we sill in the Directory ------------------;
;Returns	:                                                               ;
;			CY Set   if dirEntryIndex <= Directory Max Value                ;
;			CY Reset if dirEntryIndex  > Directory Max Value                ;
;			HL = (address of Index Value) + 1                               ;
;			DE = Directory Index Value                                      ;
StillInDirectory:                                                           ;
	LD		HL,(dirEntryIndex)                                              ;
	EX		DE,HL 						; DE = directory counter            ;
	LD		HL,(caDirMaxValue)			; HL = caDirMaxValue              	;
	LD		A,E                                                             ;
	SUB		M                                                               ;
	INC		HL                                                              ;
	LD		A,D                                                             ;
	SBC		A,(HL)						; Set CY if dirEntryIndex           ;
	RET										;  <= Directory Max Value       ;
;--------------------------- Are we sill in the Directory ------------------;
                                                                            
;=========================== Directory Utilities ===========================;

;=========================== General   Utilities ===========================;
;--------------------------- Shift HL right by value in C -----------------;
                                                                           ;
; HL = Value to be shifted Right                                           ;
;  B = Amount to shift                                                     ;
ShiftRightHLbyB:                                                           ;
 		SCF								; Set carry flag, expect LSBit = 1 ;
		BIT		0,L						; is LSB set?                      ;
		JR		NZ, ShiftRightHLbyB1		; Skip if LSB set              ;
		CCF								; else Clear Carry flag            ;
ShiftRightHLbyB1:                                                          ;
		RR		H						; Shift thru CY                    ;
		RR		L						; ditto                            ;
		DJNZ	ShiftRightHLbyB                                            ;
		RET                                                                ;
                                                                           ;
;--------------------------- Shift HL right by value in C -----------------;
;=========================== General   Utilities ===========================;

 ;---------------
;---------------
 ;---------------
 ; return zero flag if at end of directory
 ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
 EndOfDirectory:
	LD		HL,dirEntryIndex
	LD		A,(HL)								; may be 0ffh
	INC		HL
	CP		M								; low(dirEntryIndex) = high(dirEntryIndex)?
	RET	NZ; non zero returned if different
											; high and low the same, = 0ffh?
	INC		A								; 0ffh becomes 00 if so
	RET
 ;---------------
;--------------------------- Read Directory Record -------------------------;
; read a directory entry into the directory buffer                          ;
ReadDirRecord:                                                              ;
	CALL	SetDirDMA					; System Assigned Buffer            ;
	CALL	ReadBuffer					; Go to BIOS for the read           ;
	JP		SetDataDMA					; Restore DMA                       ;
;--------------------------- Read Directory Record -------------------------;

;--------------------------- Read Directory --------------------------------;
; Read next directory entry, with C=true if initializing and setting CheckSum
 ReadDirectory:
	LD		DE,(dpbDRM)					; Number of Dir Entries-1
	LD		HL,(dirEntryIndex)			; Prior Directory Index
	INC		HL							; Increment the Index
	LD		(dirEntryIndex),HL			; Save current directory index
	XOR		A							; Clear the CY flag
	SBC		HL,DE						; Are we at end Of the directory
	JR		NZ,ReadDirectory0			;  No the process
	CALL	SetEndDirectory				;  else we are done
	RET

; Calculate the entry index Position in Buffer
ReadDirectory0:
	LD		A,(dirEntryIndex)			; Get the index
	AND		dirEntryMask				; Determine Entry number in the buffer 
	LD		B,fcbShift					; Shift value results in Record Size
ReadDirectory1:
	ADD		A,A
	DJNZ	ReadDirectory1		
	LD		(dirBlockIndex),A			; Now save the Index into to buffer
	OR		A							; Is this the 1st entry?
	RET		NZ							;  return if not. 
	
	PUSH	BC							; Save init Flag (CheckSum)
	CALL	SeekDir						; Set up for Directory Read
	CALL	ReadDirRecord				; Read the directory record
	POP		BC							; Recall initialization flag
	JP		CheckSumUtility				; checksum the directory elt
 ;---------
;--------------------------- Read Directory ---------------------------------;
;--------------------------- Seek Directory --------------------------------;
 ;seek the record containing the current dir entry                          ;
SeekDir:                                                                    ;
	LD		HL,(dirEntryIndex)			; Directory Entry Index             ;
	LD		B,dirEntryShift				; 4 entries per record              ;
	CALL	ShiftRightHLbyB                                                 ;
	LD		(absoluteCPMRecord),HL                                          ;
	LD		(dirRecord),HL				; Save                              ;
	JP		Seek                                                            ;
;--------------------------- Seek Directory --------------------------------;
;--------------------------- Seek ------------------------------------------;
Seek:						; seek                                          ;
	LD		BC,0FFFFH					; Initialize the track counter      ;
	LD		HL,(absoluteCPMRecord)		; Get the record in question        ;
	LD		DE,(dpbSPT)					; Get Sectors Per track             ;
																			;
Seek0:                                                                      ;
	INC		BC							; Divide the record                 ;
	XOR		A							;  by the sectors per track         ;
	SBC		HL,DE                                                           ;
	JR		NC,Seek0					;  to get the gross track number    ;
	                                                                        ;
	                                                                        ;
	ADD		HL,DE						; Gets the sector in the track      ;
	PUSH	HL							; Save Index Sector                 ;
	                                                                        ;
	LD		IX,(caTrack)                                                    ;
	LD		(IX + 0),C                                                      ;
	LD		(IX + 1),B					; Save the Gross Track              ;
	                                                                        ;
	EX		DE,HL						; Take the index from the record    ;
	LD		HL,(absoluteCPMRecord)                                          ;
	XOR		A                                                               ;
	SBC		HL,DE						;  and you get the Block start      ;
	                                                                        ;
	LD		IX,(caSector)                                                   ;
	LD		(IX + 0),L                                                      ;
	LD		(IX + 1),H					; Save the Block Start              ;
	                                                                        ;
	LD		HL,(dpbOFF)					; Get directory Offset (tracks)		;
	ADD		HL,BC						;  to add to the gross Track        ;
	PUSH	HL							;  which yields the net or          ;
	POP		BC							;  actual track for the record      ;
	CALL	bcSettrk					; Set the net (actual) track        ;
	                                                                        ;
	POP		BC							; Get the sector within the track   ;
	JP		bcSetsec					;  and set it for the seek          ;
                                                                            ;
;--------------------------- Seek ------------------------------------------;
;--------------------------- Check Sum Utility -----------------------------;
; At entry
;			C  = TRUE	-  Set the Checksum values in Vector
;			C <> TRUE	-  Validate Checksum value in Vector

;/ NewCheckSum:
;/	LD		C,TRUE
;/
CheckSumUtility:
	LD		HL,(dpbCKS)
	LD		DE,(dirRecord)
	XOR		A
	SBC		HL,DE							; Skip if past the Directory 
	RET		C								;  Entry

	PUSH	BC								; Save New/Validate Flag
	
; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)
ComputeCheckSum:
	LD		B,cpmRecordSize
	LD		HL,(caDirectoryDMA)
	XOR
ComputeCheckSum1:
	ADD		A,(HL)
	INC		HL
	DJNZ	ComputeCheckSum1
; Checksum is in ACC	

	LD		HL,(caCheckSum)				; Address of check sum vector
	LD		DE,(dirRecord)				; Index to this record
	ADD		HL,DE						; Address of this record in vector
	POP		BC							; Retrieve New/Validate Flag
	INC		C
	JP		Z,SetNewCheckSum			; Set the Value if Flag was TRUE
	
	CP		M							; Else we are checking the value
	RET		Z							; Exit if OK
; possible checksum error, are we beyond the end of the disk?
	CALL	StillInDirectory
	RET		NC							; OK, if not in the directory
	CALL	SetDiskReadOnly				;  else the checksums don't match
	RET									;  Set disk RO before returning

 ;initializing the checksum
 SetNewCheckSum:
	LD		(HL),A
	RET
 ;------------------
;/ ;compute checksum for current directory buffer
;/ ComputeCheckSum:
;/	LD		C,cpmRecordSize					; size of directory buffer
;/	LD	HL,(caDirectoryDMA)					; current directory buffer
;/	XOR		A								; clear checksum value
;/ ComputeCheckSum0:
;/	ADD		A,(HL)
;/	INC		HL
;/	DEC		C								; cs=cs+buff(cpmRecordSize-C)
;/	JP	NZ,ComputeCheckSum0
;/	RET										; with checksum in A
 ;*****************************************************************
;--------------------------- Check Sum Utility -----------------------------;


;---------------------
 ;update variables from I/O in  fcb
 UpdateRecordVars:
	CALL	GetFcbRecordDetails					; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
	LD		A,(seqReadFlag)
	LD		C,A								; =1 if sequential i/o
	LD		A,(currentFileRecord)							; get NEXT_RECORD
	ADD		A,C
	LD		(HL),A								; fcb(NEXT_RECORD)=current File Record+seqReadFlag
	EX	DE,HL 
	LD		A,(fcbRecordCount)
	LD		(HL),A								; fcb(fcbRCIndex)=fcbRecordCount
	RET
 ;---------------------
 ;set file Attributes for current fcb
 SetAttributes:
	LD		C,fcbExtIndex
	CALL	Search4DirElement				; through file type
 SetAttributes1:
	CALL	EndOfDirectory
	RET	Z; exit at end of dir
	LD		C,0
	LD		E,fcbExtIndex					;copy name
	CALL	CopyDir
	CALL	Search4NextDirElement
	JP		SetAttributes1
 ;
 ;*****************************************************************

 ;*****************************************************************
 ;********************** File  Routines ***************************
 ;*****************************************************************
 ;open file
 ; IN  - (DE)	FCB Address
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vOpenFile:					;
	CALL	ClearModuleNum					; clear the module number
	CALL	Reselect						; do we need to reselect disk?
	JP		OpenFile
	;ret ;jmp goback
 ;-----------------------------------------------------------------
 ;close file
 vCloseFile:									; func16: (16 - 10) Close File
	CALL	Reselect
	JP		CloseDirEntry
 ;-----------------------------------------------------------------
 ;search for first occurrence of a file
 ; In - (DE)	FCB Address
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vFindFirst:									; func17: (17 - 11) Search for first
	LD		C,0								; length assuming '?' true
	LD	HL,(paramDE)
	LD		A,(HL)
	CP		QMARK							; no reselect if ?
	JP	Z,QMarkSelect						; skip reselect if so

	CALL	ClearModuleNum					; module number zeroed
	CALL	Reselect
	LD		C,nameLength
 QMarkSelect:								; qselect:
	CALL	Search4DirElement
	JP		CopyDirEntryToUser				; copy directory entry to user
 ;-----------------------------------------------------------------
 ;search for next occurrence of a file name
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vFindNext:									; func18: (18 - 12) Search for next
	LD	HL,(searchAddress)
	LD	(paramDE),HL
	CALL	Reselect
	CALL	Search4NextDirElement
	JP		CopyDirEntryToUser				; copy directory entry to user
 ;-----------------------------------------------------------------
 ;search for next occurrence of a file name
 ; OUT - (A)	Directory Code
 ;delete a file
 vDeleteFile:								; func18: (19 - 13) Delete File
	CALL	Reselect
	CALL	DeleteFile
	JP		DirLocationToReturnLoc
 ;-----------------------------------------------------------------
 ;read sequential
 ;IN  - (DE) FCB address
 ;OUT - (A) 00 = success and data available. else no read and no data
 vReadSeq:									; func20: (20 - 14) read sequential
	CALL	Reselect
	CALL	ReadSeq
	RET
 ;-----------------------------------------------------------------
 ;write sequential
 ;IN  - (DE) FCB address
 ;OUT - (A) 00 = success and data available. else no read and no data
 vWriteSeq:									; func21 (21 - 15) write sequention
	CALL	Reselect
	CALL	DiskWriteSeq
	RET
 ;-----------------------------------------------------------------
 ; Make file
 ; In - (DE)	FCB Address
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vMakeFile:									; func22 (22 - 16) Make file
	CALL	ClearModuleNum					; set S2 to Zero
	CALL	Reselect
	JP		MakeNewFile
 ;-----------------------------------------------------------------
 ; Rename file
 ; In - (DE)	FCB Address
 ; OUT - (A)	Directory Code
 ;	0-3 = success ; 0FFH = File Not Found
 vRenameFile:								; func23 (23 - 17) Rename File
	CALL	Reselect
	CALL	Rename
	JP		DirLocationToReturnLoc
 ;-----------------------------------------------------------------
 ;-----------------------------------------------------------------
 ;*****************************************************************
 ;-----------------------------------------------------------------
 ;check current directory element for read/only status
 CheckRODirectory:
	CALL	GetDirElementAddress			; address of element
 ;	JMP	CheckROFile
 ;------------
 ;check current buff(dptr) or fcb(0) for r/o status
 CheckROFile:
	LD		DE,fcbROfileIndex
	ADD		HL,DE								; offset to ro bit
	LD		A,(HL)
	RLA
	RET	NC; return if not set
	JP		errReadOnlyFile					; exit to read only disk message
 ;-----------------------------------------------------------------
 ;check for write protected disk
 CheckWrite:
	CALL	DoNotWrite
	RET	Z; ok to write if not rodsk
	JP		errReadOnlyDisk					; read only disk error
 ;-----------------------------------------------------------------
 ;return true if dir checksum difference occurred
 DoNotWrite:
	LD	HL,(readOnlyVector)
	LD		A,(currentDisk)
	LD		C,A
	CALL	ShiftRightHLbyC
	LD		A,L
	AND		1BH								; 01BH
	RET										; non zero if nowrite
 ;-----------------------------------------------------------------
 ;sequential disk read operation
 ReadSeq:
	LD		A,1
	LD		(seqReadFlag),A						; set flag for seqential read
 ;---
 ; read the disk
 ; read the next record from the current fcb
 DiskRead:
	LD		A,TRUE
	LD		(readModeFlag),A					; read mode flag = true (OpenNextExt)

	CALL	SetRecordVars					; sets current File Record, fcbRecordCount and EXM
	LD		A,(currentFileRecord)
	LD		HL,fcbRecordCount
	CP		M								; current File Record-fcbRecordCount
											; skip if  current File Record < fcbRecordCount
	JP	C,RecordOK
 ; not enough records in the extent
	CP		RecordsPerExtent				; current File Record = 128?   *** Records in an Extent
	JP	NZ,DiskEOF							; skip if current File Record<>128
	CALL	OpenNextExt						; go to next extent if so
	XOR		A
	LD		(currentFileRecord),A						; current File Record=00
 ; now check for open ok
	LD		A,(exitParameterByte)
	OR		A
	JP	NZ,DiskEOF
	; stop at eof
 ; arrive with fcb addressing a record to read
 RecordOK:									; recordok:
	CALL	GetBlockNumber					; save it in Absolute CPM Record
	CALL	IsAllocated						; Absolute CPM Record=0000?
	JP	Z,DiskEOF							; get out if not allocated already

	CALL	SetActualRecordAdd				; Absolute CPM Record now a record value
	CALL	Seek							; to proper track,sector
	CALL	ReadBuffer						; to dma address
	CALL	UpdateRecordVars				; update variables from I/O in  fcb
	RET
 DiskEOF:									; diskeof:
	JP		SetLowReturnTo1					; exitParameterByte = 1
	;ret
 ;-----------------------------------------------------------------
 ;sequential disk write
 DiskWriteSeq:
	LD		A,1
	LD		(seqReadFlag),A
 ;--------
 ;disk write
 DiskWrite:
	LD		A,FALSE
	LD		(readModeFlag),A
											; write record to currently selected file
	CALL	CheckWrite						; in case write protected
	LD	HL,(paramDE)							; HL = .fcb(0)
	CALL	CheckROFile						; may be a read-only file
	CALL	SetRecordVars					; set local Record parameters
	LD		A,(currentFileRecord)
	CP		highestRecordNumber + 1			; Still in the same extent?
	JP	C,DiskWrite1						; skip if in the same Extent
	CALL	SetLowReturnTo1
	RET										; Exit ???????????

 ; can write the next record, so continue
 DiskWrite1:
	CALL	GetBlockNumber					; sets up actual block number
	CALL	IsAllocated
	LD		C,WriteAllocated				; assume a normal write operation for WriteBuffer
	JP	NZ,DiskWrite3
 ; not allocated -
 ; the argument to getblock is the starting position for the disk search
 ; and should be the last allocated block for this file,
 ; or the value 0 if no space has been allocated

	CALL	GetDiskMapIndex					; return with Disk Map index in Acc
	LD		(diskMapIndex),A					; save for later
	LD		BC,0000h						; may use block zero
	OR		A
	JP	Z,FirstBlock						; skip if no previous block
 ; previous block exists
	LD		C,A
	DEC		BC								; previous block # in BC
	CALL	GetDiskMapValue					; previous block # to HL
	LD		B,H
	LD		C,L								; BC=prev block#
 ; BC = 0000, or previous block #
 FirstBlock:
	CALL	GetClosestBlock					; block # to HL
 ; arrive here with block# or zero
	LD		A,L
	OR		H
	JP	NZ,BlockOK
 ; cannot find a block to allocate
	LD		A,2
	LD		(exitParameterByte),A
	RET										; exitParameterByte=2

 BlockOK:
	LD	(absoluteCPMRecord),HL					; allocated block number is in HL
	EX	DE,HL ; block number to DE
	LD	HL,(paramDE)
	LD		BC,fcbDiskMapIndex
	ADD		HL,BC								; HL=.fcb(fcbDiskMapIndex)
	LD		A,(byteAllocationFlag)
	OR		A								; set flags for byteAllocationFlag byte dm
	LD		A,(diskMapIndex)					; recall dm index
	JP	Z,Allocate16Bit					; skip if allocating word
 ; else allocate using a byte value
	CALL	AddAtoHL
	LD		(HL),E								; byteAllocationFlag byte alloc
	JP		DiskWrite2						; to continue

 Allocate16Bit:								; allocate a word value

	LD		C,A
	LD		B,0								; double(diskMapIndex)
	ADD		HL,BC
	ADD		HL,BC								; HL=.fcb(diskMapIndex*2)
	LD		(HL),D
	INC		HL
	LD		(HL),E								; double wd
 ; disk write to previously unallocated block
 DiskWrite2:
	LD		C,WriteCleanBuffer				; marked as unallocated write

 ; continue the write operation of no allocation error
 ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block

 DiskWrite3:
	LD		A,(exitParameterByte)
	OR		A
	RET	NZ; stop if non zero returned value

	PUSH	BC								; save write flag ( in C see above)
	CALL	SetActualRecordAdd				; Absolute CPM Record set to actual record number
	CALL	Seek							; to proper file position
	POP		BC								; get write flag
	PUSH	BC								; restore/save write flag (C=2 if new block)
	CALL	WriteBuffer						; written to disk
	POP		BC								; C = 2 if a new block was allocated, 0 if not
											; increment record count if fcbRecordCount<=current File Record
	LD		A,(currentFileRecord)
	LD		HL,fcbRecordCount
	CP		M 								; current File Record-fcbRecordCount
	JP	C,DiskWrite4
 ; fcbRecordCount <= current File Record
	LD		(HL),A
	INC		M								; fcbRecordCount = current File Record+1
	LD		C,2								; mark as record count incremented
 DiskWrite4:
 ; A has current File Record, C=2 if new block or new record#
	DEC		C
	DEC		C
	JP	NZ,DiskWrite5
	PUSH	AF								; save current File Record value
	CALL	GetModuleNum					; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
 ; reset the file write flag to mark as written fcb
	AND		7FH								; not writeFlagMask
	LD		(HL),A								; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
	POP		AF								; restore current File Record
 DiskWrite5:
 ; check for end of extent, if found attempt to open next extent in preparation for next write
	CP		highestRecordNumber				; current File Record=highestRecordNumber?
	JP	NZ,DiskWrite7						; skip if not
 ; may be random access write, if so we are done
	LD		A,(seqReadFlag)
	OR		A
	JP	Z,DiskWrite7						; skip next extent open op
 ; update current fcb before going to next extent
	CALL	UpdateRecordVars				;update variables from I/O in  fcb
	CALL	OpenNextExt						; readModeFlag=false
 ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
	LD		HL,exitParameterByte
	LD		A,(HL)
	OR		A
	JP	NZ,DiskWrite6						; no space
 ; space available, set current File Record=255
	DEC		A
	LD		(currentFileRecord),A						; goes to 00 next time
 DiskWrite6:
	LD		(HL),0								; exitParameterByte = 00 for returned value
 DiskWrite7:
	JP		UpdateRecordVars				; update variables from I/O in  fcb
	;ret
 ;-----------------------------------------------------------------
 ;close the current extent  and open the next one if possible.
 ;readModeFlag is true if in read mode
 OpenNextExt:					; open$reel
	XOR		A
	LD		(fcbCopiedFlag),A					; set true if actually copied
	CALL	CloseDirEntry					; close current extent
 ; exitParameterByte remains at enddir if we cannot open the next ext
	CALL	EndOfDirectory
	RET	Z; return if end
	LD	HL,(paramDE)							; increment extent number
	LD		BC,fcbExtIndex
	ADD		HL,BC								; HL=.fcb(fcbExtIndex)
	LD		A,(HL)
	INC		A
	AND		maxExtValue
	LD		(HL),A								; fcb(fcbExtIndex)=++1
	JP	Z,OpenNextModule					; move to next module if zero
											; may be in the same extent group
	LD		B,A
	LD		A,(dpbEXM)
	AND		B
 ; if result is zero, then not in the same group
	LD		HL,fcbCopiedFlag				; true if the fcb was copied to directory
	AND		M 								; produces a 00 in accumulator if not written
	JP	Z,OpenNextExt1					; go to next physical extent
											; result is non zero, so we must be in same logical ext
	JP		OpenNextExt2					; to copy fcb information
 ; extent number overflow, go to next module

 OpenNextModule:
	LD		BC,fcbS2Index-fcbExtIndex	;RATS
	ADD		HL,BC								; HL=.fcb(fcbS2Index)
	INC		M								; fcb(fcbS2Index)=++1
											; module number incremented, check for overflow
	LD		A,(HL)
	AND		moduleMask						; mask high order bits
	JP	Z,OpenNextExtError				; cannot overflow to zero
 ; otherwise, ok to continue with new module

 OpenNextExt1:
	LD		C,nameLength
	CALL	Search4DirElement				; next extent found?
	CALL	EndOfDirectory
	JP	NZ,OpenNextExt2
 ; end of file encountered
	LD		A,(readModeFlag)
	INC		A								; 0ffh becomes 00 if read
	JP	Z,OpenNextExtError				; sets exitParameterByte = 1
 ; try to extend the current file
	CALL	MakeNewFile
 ; cannot be end of directory
	CALL	EndOfDirectory
	JP	Z,OpenNextExtError				; with exitParameterByte = 1
	JP		OpenNextExt3

 ; not end of file, open
 OpenNextExt2:
	CALL	OpenFileCopyFCB
 OpenNextExt3:
	CALL	SetRecordVars					; Set Record parameters
	XOR		A
	LD		(exitParameterByte),A					; exitParameterByte = 0
	RET										; with exitParameterByte = 0

 ; cannot move to next extent of this file
 OpenNextExtError:
	CALL	SetLowReturnTo1					; exitParameterByte = 1
	JP		SetFileWriteFlag				; ensure that it will not be closed
 ;-----------------------------------------------------------------
 ;rename the file described by the first half of the currently addressed FCB.
 ;the new name is contained in the last half of the FCB. The file name and type
 ;are changed, but the reel number is ignored.  the user number is identical
 Rename:
	CALL	CheckWrite						; may be write protected
 ; search up to the extent field
	LD		C,fcbExtIndex					; extent number field index
	CALL	Search4DirElement
 ; copy position 0
	LD	HL,(paramDE)
	LD		A,(HL)								; HL=.fcb(0), A=fcb(0)
	LD		DE,fcbDiskMapIndex
	ADD		HL,DE								; HL=.fcb(fcbDiskMapIndex)
	LD		(HL),A								; fcb(fcbDiskMapIndex)=fcb(0)
 ; assume the same disk drive for new named file
 Rename1:
	CALL	EndOfDirectory
	RET	Z; stop at end of dir
 ; not end of directory, rename next element
	CALL	CheckRODirectory				; may be read-only file
	LD		C,fcbDiskMapIndex
	LD		E,fcbExtIndex
	CALL	CopyDir
 ; element renamed, move to next
	CALL	Search4NextDirElement
	JP		Rename1
 ;-----------------------------------------------------------------
 ;create a new file by creating a directory entry then opening the file
 MakeNewFile:
	CALL	CheckWrite						; may be write protected
	LD	HL,(paramDE)
	PUSH	HL								; save fcb address, look for e5
	LD		HL,emptyFCB
	LD	(paramDE),HL							; paramDE = .empty
	LD		C,1
	CALL	Search4DirElement				; length 1 match on empty entry
	CALL	EndOfDirectory					; zero flag set if no space
	POP		HL								; recall paramDE address
	LD	(paramDE),HL							; in case we return here
	RET	Z; return with error condition 255 if not found
	EX	DE,HL ; DE = paramDE address
 ; clear the remainder of the fcb
	LD		HL,nameLength
	ADD		HL,DE								; HL=.fcb(nameLength)
	LD		C,fcbLength-nameLength			; number of bytes to fill
	XOR		A								; clear accumulator to 00 for fill
 MakeNewFile1:
	LD		(HL),A
	INC		HL
	DEC		C
	JP	NZ,MakeNewFile1
	LD		HL,fcbS1Index
	ADD		HL,DE								; HL = .fcb(fcbS1Index)
	LD		(HL),A								; fcb(fcbS1Index) = 0
	CALL	SetDirectoryEntry				; may have extended the directory
 ; now copy entry to the directory
	CALL	CopyFCB
 ; and set the file write flag to "1"
	JP		SetFileWriteFlag
 ;-----------------------------------------------------------------
 ;delete the currently addressed file
 DeleteFile:
	CALL	CheckWrite						; write protected ?
	LD		C,fcbExtIndex					; extent number field
	CALL	Search4DirElement				; search through file type
 DeleteFile1:
						; loop while directory matches
	CALL	EndOfDirectory
	RET	Z; exit if end
 ; set each non zero disk map entry to 0 in the allocation vector
	CALL	CheckRODirectory				; ro disk error if found
	CALL	GetDirElementAddress			; HL=.buff(dptr)
	LD		(HL),emptyDir
	LD		C,0
	CALL	ScanDiskMap						; alloc elts set to 0
	CALL	WriteDir						; write the directory
	CALL	Search4NextDirElement			; to next element
	JP		DeleteFile1						; for another record
 ;-----------------------------------------------------------------
 ;locate the directory element and re-write it
 CloseDirEntry:
	XOR		A
	LD		(exitParameterByte),A
	CALL	DoNotWrite						; return TRUE (0) if checksum change
	RET	NZ; skip close if r/o disk
 ; check file write flag - 0 indicates written
	CALL	GetModuleNum					; fcb(fcbS2Index) in A
	AND		writeFlagMask
	RET	NZ; return if bit remains set
	LD		C,nameLength
	CALL	Search4DirElement				; locate file
	CALL	EndOfDirectory
	RET	Z; return if not found
 ; merge the disk map at paramDE with that at buff(dptr)
	LD		BC,fcbDiskMapIndex
	CALL	GetDirElementAddress
	ADD		HL,BC
	EX	DE,HL ; DE is .buff(dptr+16)
	LD	HL,(paramDE)
	ADD		HL,BC								; DE=.buff(dptr+16), HL=.fcb(16)
	LD		C,(fcbLength-fcbDiskMapIndex)	; length of  byte Allocation Map
 CloseDirEntry1:
	LD		A,(byteAllocationFlag)
	OR		A
	JP	Z,CloseDirEntry4					; skip to double
 ; this is a  byte map
 ; if fcb(i) = 0 then fcb(i) = buff(i)
 ; if buff(i) = 0 then buff(i) = fcb(i)
 ; if fcb(i) <> buff(i) then error
	LD		A,(HL)
	OR		A
	LD	A,(DE)
	JP	NZ,CloseDirEntry2
 ; fcb(i) = 0
	LD		(HL),A								; fcb(i) = buff(i)
 CloseDirEntry2:
	OR		A
	JP	NZ,CloseDirEntry3
 ; buff(i) = 0
	LD		A,(HL)
	LD	(DE),AE								; buff(i)=fcb(i)
 CloseDirEntry3:
	CP		M
	JP	NZ,CloseDirEntryError				; fcb(i) = buff(i)?
	JP		CloseDirEntry5					; if merge ok

 ; this is a double byte merge operation
 CloseDirEntry4:
	CALL	Merge							; buff = fcb if buff 0000
	EX	DE,HL 
	CALL	Merge
	EX	DE,HL ; fcb = buff if fcb 0000
 ; they should be identical at this point
	LD	A,(DE)
	CP		M
	JP	NZ,CloseDirEntryError				; low same?
	INC		DE
	INC		HL								; to high byte
	LD	A,(DE)
	CP		M
	JP	NZ,CloseDirEntryError				; high same?
 ;	merge operation ok for this pair
	DEC			C							; extra count for double byte
 CloseDirEntry5:
	INC		DE
	INC		HL								; to next byte position
	DEC		C
	JP	NZ,CloseDirEntry1					; for more
 ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
	LD		BC,-(fcbLength-fcbExtIndex)	;RATS
	ADD		HL,BC
	EX	DE,HL 
	ADD		HL,BC
											; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
	LD	A,(DE)								; current user extent number
 ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
	CP		M
	JP	C,CloseDirEntryEnd
 ; fcb extent number >= dir extent number
	LD		(HL),A								; buff(ext) = fcb(ext)
 ; update directory record count field
	LD		BC,fcbRCIndex-fcbExtIndex	;RATS
	ADD		HL,BC
	EX	DE,HL 
	ADD		HL,BC
 ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
	LD		A,(HL)
	LD	(DE),AE								; buff(fcbRCIndex)=fcb(fcbRCIndex)
 CloseDirEntryEnd:
	LD		A,TRUE
	LD		(fcbCopiedFlag),A					; mark as copied
	CALL	SeekCopy						; ok to "WriteDir" here - 1.4 compat
	RET

 ; elements did not merge correctly
 CloseDirEntryError:
	LD		HL,exitParameterByte
	DEC		M								; =255 non zero flag set
	RET
 ;-----------------------------------------------------------------
 ;enter from CloseDirEntry to seek and copy current element
 SeekCopy:
	CALL	SeekDir							; to the directory element
	JP		WriteDir						; write the directory element
	;ret
 ;-----------------------------------------------------------------
 ;write the current directory entry, set checksum
 WriteDir:
;	CALL	NewCheckSum						; initialize entry
	LD		C,TRUE
	CALL	CheckSumUtility
	
	CALL	SetDirDMA						; directory dma
	LD		C,1								; indicates a write directory operation
	CALL	WriteBuffer						; write the buffer
	JP		SetDataDMA						; to data dma address
	;ret
 ;-----------------------------------------------------------------
 ;write buffer and check condition
 ;write type (wrtype) is in register C
 ;wrtype = 0 => normal write operation		WriteAllocated
 ;wrtype = 1 => directory write operation	WriteDirectory
 ;wrtype = 2 => start of new block			WriteCleanBuffer
 WriteBuffer:
	CALL	bcWrite							; current drive, track, sector, dma
	OR		A
	JP	NZ,erPermanentNoWait				; error if not 00
	RET
 ;-----------------------------------------------------------------

 ;HL = .fcb1(i), DE = .fcb2(i),
 ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
 Merge:
	LD		A,(HL)
	INC		HL
	OR		M
	DEC		HL
	RET	NZ; return if = 0000
	LD	A,(DE)
	LD		(HL),A
	INC		DE
	INC		HL								; low byte copied
	LD	A,(DE)
	LD		(HL),A
	DEC		DE
	DEC		HL								; back to input form
	RET
 ;-----------------------------------------------------------------
 ;compute closest disk block number from current block
 ;given allocation vector position BC, find the zero bit closest to this position
 ;by searching left and right.
 ;if found, set the bit to one and return the bit position in hl.
 ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
 GetClosestBlock:
	LD		D,B
	LD		E,C								; copy of starting position to de
 TestLeft:
	LD		A,C
	OR		B
	JP	Z,TestRight						; skip if left=0000
 ; left not at position zero, bit zero?
	DEC		BC
	PUSH	DE
	PUSH	BC								; left,right pushed
	CALL	GetAllocBit
	RRA
	JP	NC,ReturnBlockNumber				; return block number if zero
 ; bit is one, so try the right
	POP		BC
	POP		DE								; left, right restored
 TestRight:
	LD	HL,(dpbDSM)							; value of maximum allocation#
	LD		A,E
	SUB		L
	LD		A,D
	SBC		A,H								; right=dpbDSM?
	JP	NC,ReturnBlockZero					; return block 0000 if so
	INC		DE
	PUSH	BC
	PUSH	DE								; left, right pushed
	LD		B,D
	LD		C,E								; ready right for call
	CALL	GetAllocBit
	RRA
	JP	NC,ReturnBlockNumber				; return block number if zero
	POP		DE
	POP		BC								; restore left and right pointers
	JP		TestLeft						; for another attempt
 ReturnBlockNumber:
	RLA
	INC		A								; bit back into position and set to 1
											; 	D contains the number of shifts required to reposition
	CALL	RotateAndReplace				; move bit back to position and store
	POP		HL
	POP		DE								; HL returned value, DE discarded
	RET

 ; cannot find an available bit, return 0000
 ReturnBlockZero:
	LD		HL,0000H
	RET
 ;-----------------------------------------------------------------
 ;compute disk block number from current fcb
 GetBlockNumber:
	CALL	GetDiskMapIndex					; 0...15 in register A
	LD		C,A
	LD		B,0
	CALL	GetDiskMapValue					; return value in HL
	LD	(absoluteCPMRecord),HL					; save for later
	RET
 ;-----------------------------------------------------------------
 ;is  block allocated
 IsAllocated:
	LD	HL,(absoluteCPMRecord)
	LD		A,L
	OR		H
	RET
 ;-----------------------------------------------------------------
 ;compute actual record address
 ; result = absoluteCPMRecord * ( 2**BSH)
 SetActualRecordAdd:
	LD		A,(dpbBSH)							; Block Shift  to reg A
	LD	HL,(absoluteCPMRecord)

 SetActualRecordAdd1:
	ADD		HL,HL
	DEC		A								; shl(absoluteCPMRecord,dpbBSH)
	JP	NZ,SetActualRecordAdd1
 ; HL has Record number for start of the block;
	LD		A,(dpbBLM)							; get block mask
	LD		C,A								; to get current File Record mod Block
	LD		A,(currentFileRecord)						; get index into block
	AND		C								; masked value in A
	OR		L
	LD		L,A								; to HL
	LD	(absoluteCPMRecord),HL					; Absolute CPM Record=HL or (current File Record and dpbBLM)
 ; *** Absolute CPM Record now has current record number - Starting record number + index into block
	RET
 ;-----------------------------------------------------------------
 ;---------------------
 ;copy directory location to exitParameterByte
 DirLocationToReturnLoc:
	LD		A,(directoryFlag)
	LD		(exitParameterByte),A
	RET
 ;---------------------
 ;clear the module number field for user open/make (S2)
 ClearModuleNum:
	CALL	GetModuleNum
	LD		(HL),0								; fcb(fcbS2Index)=0
	RET
 ;---------------------
 ;get data module number (high order bit is fwf -file write flag)
 GetModuleNum:
	LD	HL,(paramDE)
	LD		DE,fcbS2Index
	ADD		HL,DE								; HL=.fcb(fcbS2Index)
	LD		A,(HL)
	RET										; A=fcb(fcbS2Index)
 ;---------------------
 ;check current fcb to see if reselection necessary
 Reselect:
	LD		A,TRUE
	LD		(fResel),A							;mark possible reselect
	LD	HL,(paramDE)
	LD		A,(HL)								; drive select code
	AND		00011111B						; non zero is auto drive select
	DEC		A								; drive code normalized to 0..30, or 255
	LD		(paramE),A							; save drive code
	CP		30
	JP	NC,NoSelect
											; auto select function, save currentDisk
	LD		A,(currentDisk)
	LD		(entryDisk),A						; entryDisk=currentDisk
	LD		A,(HL)
	LD		(fcbDisk),A							; save drive code
	AND		11100000B
	LD		(HL),A								; preserve hi bits
	CALL	SelectCurrent
 NoSelect:									; noselect:

	LD		A,(currentUserNumber)				; set user code 0...31
	LD	HL,(paramDE)
	OR		M
	LD		(HL),A
	RET
 ;---------------------
 ;search for the directory entry, copy to fcb
 OpenFile:
	LD		C,nameLength
	CALL	Search4DirElement
	CALL	EndOfDirectory
	RET	Z; return with exitParameterByte=255 if end

 ; not end of directory, copy fcb information
 OpenFileCopyFCB:
	CALL	GetExtentAddress				; HL=.fcb(fcbExtIndex)
	LD		A,(HL)
	PUSH	AF
	PUSH	HL								; save extent#
	CALL	GetDirElementAddress
	EX	DE,HL ; DE = .buff(dptr)
	LD	HL,(paramDE)							; HL=.fcb(0)
	LD		C,NEXT_RECORD					; length of move operation
	PUSH	DE								; save .buff(dptr)
	CALL	Move							; from .buff(dptr) to .fcb(0)
 ; note that entire fcb is copied, including indicators
	CALL	SetFileWriteFlag				; sets file write flag
	POP		DE
	LD		HL,fcbExtIndex
	ADD		HL,DE								; HL=.buff(dptr+fcbExtIndex)
	LD		C,(HL)								; C = directory extent number
	LD		HL,fcbRCIndex					; point at the record Count field
	ADD		HL,DE								; HL=.buff(dptr+fcbRCIndex)
	LD		B,(HL)								; B holds directory record count
	POP		HL
	POP		AF
	LD		(HL),A								; restore extent number
 ; HL = .user extent#, B = dir rec cnt, C = dir extent#
 ; if user ext < dir ext then user := 128 records
 ; if user ext = dir ext then user := dir records
 ; if user ext > dir ext then user := 0 records
	LD		A,C
	CP		M
	LD		A,B								; ready dir fcbRCIndex
	JP	Z,OpenRecordCount					; if same, user gets dir fcbRCIndex
	LD		A,0
	JP	C,OpenRecordCount					; user is larger
	LD		A,RecordsPerExtent				; directory is larger >>>RecordsPerExtent
 OpenRecordCount:							;Acc has record count to fill
	LD	HL,(paramDE)
	LD		DE,fcbRCIndex
	ADD		HL,DE
	LD		(HL),A
	RET

 ;---------------------
 ;search for directory element of length C at info
 Search4DirElement:
	LD		A,0FFH
	LD		(directoryFlag),A					; changed if actually found
	LD		HL,searchLength
	LD		(HL),C								; searchLength = C
	LD	HL,(paramDE)
	LD	(searchAddress),HL					; searchAddress = paramDE
	CALL	SetEndDirectory					; dirEntryIndex = enddir
	CALL	Home							; to start at the beginning
	JP		Search4NextDirElement
 ;---------------------
 ;search for the next directory element, assuming a previous
 ;call on search which sets searchAddress and searchLength
 Search4NextDirElement:
	LD		C,FALSE
	CALL	ReadDirectory					; read next dir element
	CALL	EndOfDirectory
	JP	Z,SearchDone						; skip to end if so
 ; not end of directory, scan for match
	LD	HL,(searchAddress)
	EX	DE,HL ; DE=beginning of user fcb
	LD	A,(DE)								; first character
	CP		emptyDir						; keep scanning if Dir entry is empty
	JP	Z,Search4NextDirElement1
 ; not emptyDir, may be end of logical directory
	PUSH	DE								; save search address
	CALL	StillInDirectory				; past logical end?
	POP		DE								; recall address
	JP	NC,SearchDone						; artificial stop
 Search4NextDirElement1:
	CALL	GetDirElementAddress			; HL = buffa+dptr
	LD		A,(searchLength)
	LD		C,A								; length of search to c
	LD		B,0								; bcounts up, c counts down
 Search4NextLoop:
	LD		A,C
	OR		A
	JP	Z,EndDirElementSearch
	LD	A,(DE)
	CP		QMARK
	JP	Z,Search4NextOK					; ? matches all
 ; scan next character if not fcbS1Index
	LD		A,B
	CP		fcbS1Index
	JP	Z,Search4NextOK
 ; not the fcbS1Index field, extent field?
	CP		fcbExtIndex						; may be extent field
	LD	A,(DE)								; fcb character
	JP	Z,Search4Ext						; skip to search extent
	SUB		M
	AND		07FH							; mask-out flags/extent modulus
	JP	NZ,Search4NextDirElement			; skip if not matched
	JP		Search4NextOK					;matched character

 ; A has fcb character attempt an extent # match
 Search4Ext:
	PUSH	BC								; save counters
	LD		C,(HL)								; directory character to c
	CALL	CompareExtents					; compare user/dir char
	POP		BC								; recall counters
	JP	NZ,Search4NextDirElement			; skip if no match

 ; current character matches
 Search4NextOK:
	INC		DE
	INC		HL
	INC		B
	DEC		C
	JP		Search4NextLoop

 ; entire name matches, return dir position
 EndDirElementSearch:
	LD		A,(dirEntryIndex)
	AND		dirEntryMask
	LD		(exitParameterByte),A
 ; exitParameterByte = low(dirEntryIndex) and 11b
	LD		HL,directoryFlag
	LD		A,(HL)
	RLA
	RET	NC; directoryFlag=0ffh?
 ; yes, change it to 0 to mark as found
	XOR		A
	LD		(HL),A								; directoryFlag=0
	RET

 ; end of directory, or empty name
 SearchDone:
	CALL	SetEndDirectory					; may be artifical end
	LD		A,0FFH
	LD		(exitParameterByte),A
	RET
 ;---------------------
 ;Set file write flag
 SetFileWriteFlag:
	CALL	GetModuleNum					; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
	OR		writeFlagMask					; set fwf (file write flag) to "1"
	LD		(HL),A								; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
	RET										; also returns non zero in accumulator
 ;---------------------
 ;set exitParameterByte to 1
 SetLowReturnTo1:
	LD		A,1
	LD		(exitParameterByte),A
	RET
 ;---------------------
 ;compare extent# in A with that in C, return nonzero if they do not match
 CompareExtents:
	PUSH	BC								; save C's original value
	PUSH	AF
	LD		A,(dpbEXM)
	CPL
	LD		B,A
											; B has negated form of extent mask
	LD		A,C
	AND		B
	LD		C,A								; low bits removed from C
	POP		AF
	AND		B								; low bits removed from A
	SUB		C
	AND		maxExtValue						; set flags
	POP		BC								; restore original values
	RET
 ;---------------------
 ;copy the directory entry to the user buffer
 CopyDirEntryToUser:
	LD	HL,(caDirectoryDMA)
	EX	DE,HL ; source is directory buffer
	LD	HL,(initDAMAddress)					; destination is user dma address
	LD		C,cpmRecordSize					; copy entire record
	JP		Move
 ;---------------------
 ;copy the whole file control block
 CopyFCB:
	LD		C,0
	LD		E,fcbLength						; start at 0, to fcblen-1
	JP		CopyDir
 ;---------------------
 ;copy fcb information starting at C for E bytes into the currently addressed directory entry
 CopyDir:
	PUSH	DE								; save length for later
	LD		B,0								; double index to BC
	LD	HL,(paramDE)							; HL = source for data
	ADD		HL,BC
	EX	DE,HL ; DE=.fcb(C), source for copy
	CALL	GetDirElementAddress			; HL=.buff(dptr), destination
	POP		BC								; DE=source, HL=dest, C=length
	CALL	Move							; data moved
 ;enter from close to seek and copy current element
 SeekAndCopy:								; seek$copy:
	CALL	SeekDir							; seek$dir ;to the directory element
	JP	WriteDir							; write the directory element
 ;---------------------
 ;Return the  disk map Index for current File Record in the ACC
 ;  account for multiple extents in 1 physical Directory entry
 GetDiskMapIndex:							; dm$position
	LD		HL,dpbBSH						; get block shift value
	LD		C,(HL)								; shift count to C
	LD		A,(currentFileRecord)						; current virtual record to A
 GetDiskMapIndex1:
	OR		A								; reset the carry flag
	RRA
	DEC		C
	JP	NZ,GetDiskMapIndex1
											; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
											; A has the relative position in the block.
	LD		B,A								; save it for later addition
	LD		A,8
	SUB		M								; 8-dpbBSH to accumulator
	LD		C,A								; extent shift count in register c
	LD		A,(extentValue)						; extent value ani extmsk
 GetDiskMapIndex2:							; dmpos1:
											; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
											; shift is 4,3,2,1,0
	DEC		C
	JP	Z,GetDiskMapIndex3
	OR		A								; clear the carry flag
	RLA
	JP		GetDiskMapIndex2

 ; The ACC has the Block Number for this record
 GetDiskMapIndex3:
											; arrive here with A = shl(ext and extmsk,7-dpbBSH)
	ADD	A,B 									; add the previous shr(current File Record,dpbBSH) value
											; A is one of the following values, depending upon alloc
											; bks dpbBSH
											; 1k   3     v/8 + extentValue * 16
											; 2k   4     v/16+ extentValue * 8
											; 4k   5     v/32+ extentValue * 4
											; 8k   6     v/64+ extentValue * 2
											; 16k  7     v/128+extentValue * 1
	RET 									; with disk map position in A
 ;---------------------
 ; Enter with Disk Map Index in BG
 ; Return disk map value  in HL
 GetDiskMapValue:
	LD	HL,(paramDE)							; base address of file control block
	LD		DE,fcbDiskMapIndex				; offset to the disk map
	ADD		HL,DE								; HL =.diskmap
	ADD		HL,BC								; index by a  byte value
	LD		A,(byteAllocationFlag)							;  byte map entry?
	OR		A
	JP	Z,GetDiskMap16Bit 				; get disk map  byte
	LD		L,(HL)
	LD		H,0
	RET										; with HL=00bb
 GetDiskMap16Bit:							; getdmd:
	ADD		HL,BC								; HL=.fcb(dm+i*2)
											; double precision value returned
	LD		D,(HL)
	INC		HL
	LD		E,(HL)
	EX	DE,HL 
	RET
 ;---------------------
 ;---------------------
 ;*****************************************************************
 ;************************ Utilities ******************************
 ;*****************************************************************
 AddAtoHL:
	ADD		A,L
	LD		L,A
	RET	NC
	INC		H
	RET
 ;----------
 DEminusHL2HL:
	LD		A,E
	SUB		L
	LD		L,A
	LD		A,D
	SBC		A,H
	LD		H,A
	RET
 ;-------------
 ShiftRightHLbyC:
	INC		C
 ShiftRightHLbyC0:
	DEC		C
	RET	Z
	LD		A,H
	OR		A
	RRA
	LD		H,A
	LD		A,L
	RRA
	LD		L,A
	JP		ShiftRightHLbyC0
 ;-------
 ShiftLeftHLbyC:
	INC		C
 ShiftLeftHLbyC0:
	DEC		C
	RET	Z; exit when done
	ADD		HL,HL
	JP		ShiftLeftHLbyC0
 ;*****************************************************************
 ;move data length of length C from source DE to HL
 Move:
	INC		C
 Move0:
	DEC		C
	RET	Z
	LD	A,(DE)
	LD		(HL),A
	INC		DE
	INC		HL
	JP		Move0

 ;********** Console OUT Routines*******************??????
 
;---------------------------------- Is Bit Set ------------------------------;
; Enter HL  contains the bit map                                             ;
;       B   Has the bit number (0...F)                                       ;
; Return ZFlag = 1 if bit is reset (0)                                       ;
;              = 0 if bit is set (1)                                         ;
IsBitSet:																	 ;
		INC		B                                                            ;
IsBitSetLoop:                                                                ;
 		SCF								; Set carry flag, expect LSBit = 1   ;
		BIT		0,L						; is LSB set?                        ;
		JR		NZ, IsBitSet1				; Skip if LSB set                ;
		CCF								; else Clear Carry flag              ;
IsBitSet1:                                                                   ;
		RR		H						; Shift thru CY                      ;
		RR		L						; ditto                              ;
		DJNZ	IsBitSetLoop                                                 ;
		BIT		7,H						; Bit moved from L LSBit to H MSBit	 ;
		RET                                                                  ;
;---------------------------------- Is Bit Set ------------------------------;

;============================ Set/Reset Map Bit =============================;		
;---------------------------------- Set Map Bit ----------------------------;;		
; Enter  HL  contains the bit map                                           ;;
;        B   Has the bit number (0...F)                                     ;;
; Return HL  Contains the modified bit map                                  ;;
SetMapBit:                                                                  ;;
		PUSH	BC						; Save the Bit Number               ;;
		CALL	IsBitSet				; Put the bit in the LSBit          ;;
                                                                            ;;
		POP		BC						; Get the bit position              ;;
		SET		7,H                                                         ;;
		JR		ReAlignMap				;                                    ;
;---------------------------------- Set Map Bit ----------------------------;;
;---------------------------------- Reset Map Bit --------------------------;;		
; Enter  HL  contains the bit map                                           ;;
;        B   Has the bit number (0...F)                                     ;;
; Return HL  Contains the modified bit map                                  ;;
ResetMapBit:                                                                  ;;
		PUSH	BC						; Save the Bit Number               ;;
		CALL	IsBitSet				; Put the bit in the LSBit          ;;
                                                                            ;;
		POP		BC						; Get the bit position              ;;
		RES		7,H                                                         ;;
; Fall thru to ReAlignMap                                                    ;
;---------------------------------- Reset Map Bit --------------------------;;		
;---------------------------------- Set Map Bit ----------------------------;;
; Adjusts the HL register to its Original Alignment after IsBitSet           ;
		                                                                     ;
ReAlignMap:                                                                  ;
		INC		B                                                            ;
ReAlignMapLoop:                                                              ;
 		SCF								; Set carry flag, expect LSBit = 1   ;
		BIT		7,H						; is LSB set?                        ;
		JR		NZ, ReAlignMap1				; Skip if LSB set                ;
		CCF								; else Clear Carry flag              ;
ReAlignMap1:                                                                 ;
		RL		L						; Shift thru CY                      ;
		RL		H						; ditto                              ;
		DJNZ	ReAlignMapLoop                                               ;
		RET                                                                  ;
;============================ Set/Reset Map Bit =============================;		


;? ;********************************************************
;? ;return version number
;? vGetVersion:								; func12 (12 - 0C)	 Get Verson
;?	LD		A,VERSION
;?	LD		(exitParameterByte),A 				;exitParameterByte = VERSION (high = 00)
;?	RET
 ;************Error message World*************************
 errSelect:
	LD		HL,evSelection
	JP		GoToError
 errReadOnlyDisk:
	LD		HL,evReadOnlyDisk
	JP		GoToError
 errReadOnlyFile:
	LD		HL,evReadOnlyFile
	JP		GoToError
 errPermanent:
	LD		HL,evPermanent
	JP		GoToError
 ;************Error message handler **********************
 GoToError:
 ;HL = .errorhandler, call subroutine
	LD		E,(HL)
	INC		HL
	LD		D,(HL)								; address of routine in DE
	EX	DE,HL 
	JP(HL) 									; vector to subroutine
 ;************ Error Vectors *****************************
 evPermanent: 	DW	erPermanent				; pererr permanent error subroutine
 evSelection:	DW	erSelection				; selerr select error subroutine
 evReadOnlyDisk:	DW	erReadOnlyDisk			; roderr ro disk error subroutine
 evReadOnlyFile:	DW	erReadOnlyFile			; roferr ro file error subroutine
 ;************Error Routines ******************************
 erPermanentNoWait:
	LD		HL,emPermanent
	JP		GoToError
 erPermanent:
	LD		HL,emPermanent
	CALL	displayAndWait					; to report the error
	CP 	CTRL_C
	JP	Z,WarmBoot						; reboot if response is CTRL_C
	RET										; and ignore the error
 ;
 erSelection:
	LD		HL,emSelection
	JP		waitB4boot						; wait console before boot
 ;
 erReadOnlyDisk:
	LD		HL,emReadOnlyDisk
	JP		waitB4boot						; wait console before boot
 ;
 erReadOnlyFile:
	LD		HL,emReadOnlyFile				; drop through to wait for console
 ;
 ; wait for response before boot
 waitB4boot:
	CALL	displayAndWait
	JP		WarmBoot

 ;report error to console, message address in HL
 displayAndWait:
	PUSH	HL								; save message pointer
	CALL	showCRLF						; stack mssg address, new line
	LD		A,(currentDisk)
	ADD	A,ASCII_A
	LD		(emDisk),A							; Problem disk name
	LD		BC,emDisk0
	CALL	Print							; the error message
	POP		BC
	CALL	Print							; error mssage tail
	JP		ConIn							; to get the input character
	;ret
 ;**************Error Messages*******************************
 emDisk0:			DB		'Bdos Err On '
 emDisk:				DB		' : $'
 emPermanent:		DB		'Bad Sector$'
 emSelection:		DB		'Select$'
 emReadOnlyFile:		DB		'File '
 emReadOnlyDisk:		DB		'R/O$'
 ;*****************************************************************

 ;********* file control block (fcb) constants ********************
 fcbLength			EQU		20H	;32				; fcblen file control block size
 fcbROfileIndex		EQU		09H				; high order of first type char
 fcbHiddenfileIndex	EQU		0AH	;10				; invisible file in dir command
 fcbExtIndex		EQU		0CH	;12				; extent number field index
 fcbS1Index			EQU		0DH	;13				; S1 index
 fcbS2Index			EQU		0EH	;14				; S2 data module number index
 fcbRCIndex			EQU		0FH	;15				; record count field index
 fcbDiskMapIndex	EQU		10H	;16				; dskmap disk map field
 
 fcbCurrentRecord	EQU		21H	;33

 highestRecordNumber	EQU		RecordsPerExtent - 1; last record# in extent

 dirEntriesPerRecord	EQU		cpmRecordSize/fcbLength; directory elts / record
 dirEntryShift		EQU		2				; log2(dirEntriesPerRecord)
 dirEntryMask		EQU		dirEntriesPerRecord-1
 fcbShift			EQU		5				; log2(fcbLength)
 ;



 maxExtValue			EQU		31				; largest extent number
 moduleMask			EQU		15				; limits module number value
 writeFlagMask		EQU		80h				; file write flag is high order fcbS2Index
 nameLength			EQU		15				; namlen name length

 emptyDir			EQU		0E5H			; empty empty directory entry
 NEXT_RECORD			EQU		fcbLength		; nxtrec
 RANDOM_REC_FIELD	EQU		NEXT_RECORD + 1	;ranrec random record field (2 bytes)
 ;
 ;	reserved file indicators
 ;	equ	11				; reserved
 ;*****************************************************************
 ;*****************************************************************

 ;***common values shared between bdosi and bdos******************
 currentUserNumber:	DB	0					; usrcode current user number
; paramDE:			DS	2					; ParamsDE information address
; exitParameterByte:
; exitParameterWord:	DS	2					; address value to return
 currentDisk:		DB	-1					; curdsk current disk number
; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)

 ;********************* Local Variables ***************************
 ;     ************************
 ;     *** Initialized Data ***

 emptyFCB:			DB	emptyDir			; efcb 0E5 = available dir entry
 readOnlyVector:		DW	0					; rodsk read only disk vector
 loggedDisks:		DW	0					; dlog	 logged-in disks
 initDAMAddress:		DW	DMABuffer			; dmaad tbuff initial dma address

 ;     *** Current Disk attributes ****
 ; These are set upon disk select
 ; data must be adjacent, do not insert variables
 ; address of translate vector, not used
 ; ca - currentAddress

 caDirMaxValue:		DW	0000H				; cdrmaxa pointer to cur dir max value
 caTrack:			DW	0000H				; curtrka current track address
 caSector:			DW	0000H				; current Sector
 caListSizeStart:
 caDirectoryDMA:		DW	0000H				; buffa pointer to directory dma address
 caDiskParamBlock:	DW	0000H				; dpbaddr current disk parameter block address
 caCheckSum:			DW	0000H				; checka current checksum vector address
 caAllocVector:		DW	0000H				; alloca current allocation vector address
 caListSizeEnd:
 caListSize			EQU	caListSizeEnd - caListSizeStart

 ;     ***** Disk Parameter Block *******
 ; data must be adjacent, do not insert variables
 ; dpb - Disk Parameter Block
 dpbStart:
 dpbSPT:				DW	0000H				; sectpt sectors per track
 dpbBSH:				DB	0000H				; blkshf block shift factor
 dpbBLM:				DB	00H					; blkmsk block mask
 dpbEXM:				DB	00H					; extmsk extent mask
 dpbDSM:				DW	0000H				; Maximum allocation number
 dpbDRM:				DW	0000H				; dirmax largest directory number
 dpbDABM:			DW	0000H				; dirblk reserved allocation bits for directory
 dpbCKS:				DW	0000H				; chksiz size of checksum vector
 dpbOFF:				DW	0000H				; offset offset tracks at beginning
 dpbEnd:
 dpbSize				EQU	dpbEnd - dpbStart
 ;

 ;     ************************

 caSkewTable:		DW	0000H				; tranv address of translate vector
 fcbCopiedFlag:		DB	00H					; fcb$copied set true if CopyFCB called
 readModeFlag:		DB	00H					; rmf read mode flag for OpenNextExt
 directoryFlag:		DB	00H					; dirloc directory flag in rename, etc.
 seqReadFlag:		DB	00H					; seqio  1 if sequential i/o
 diskMapIndex:		DB	00H					; dminx  local for DiskWrite
 searchLength:		DB	00H					; searchl search length
 searchAddress:		DW	0000H				; searcha search address
 ;tinfo:	ds	word							; temp for info in "make"
 byteAllocationFlag:	DB	00H					; set true if single byte allocation map
 fResel:				DB	00H					; resel reselection flag
 entryDisk:			DB	00H					; olddsk disk on entry to bdos
 fcbDisk:			DB	00H					; fcbdsk disk named in fcb
 fcbRecordCount:	DB	00H				; record count from current FCB
 extentValue:		DB	00H					; extent number and dpbEXM from current fcb
 currentFileRecord:			DW	0000H				; Current File Record - fcbCurrentRecord
 absoluteCPMRecord:	DW	0000H			; Raw record ( 4 records / Sector)( 4 Sectors per block)
 ;
 ;	local variables for directory access
 dirBlockIndex:		DB	00H					; directory block Index 0,1,2,3
 dirEntryIndex:		DW	00H					; directory entry Index  0,1,...,dpbDRM
 dirRecord:			DW	00H					; drec:	ds	word	;directory record 0,1,...,dpbDRM/4

 ;********************** data areas ******************************


;---------------------------------- Stack Area--------------------------------;
stackBottom:		DS	STACK_SIZE * 2	; stack size                      ;
bdosStack:
                                                                    ;
;---------------------------------- Stack Area--------------------------------;
 ;	end of Basic I/O System
 ;-----------------------------------------------------------------;
 *****************************************************************

 ;
Z_HighestLocation:
Z_MemoryLeft			EQU    (BIOSStart-1) - Z_HighestLocation


