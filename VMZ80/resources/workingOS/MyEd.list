0001: 0100         ; MyEd.Z80
0002: 0100         ;  Reading the open file
0003: 0100
0004: 0100             TPA        EQU    0100H
0005: 0100
0006: 0100                        ORG    TPA
0007: 0100
0008: 0100
0009: 0100             Start:
0010: 0100 C3 96 01               JP     appInit              ; Initialize application
0011: 0103             Begin:
0012: 0103 CD 10 01               CALL   GetTheFile           ; open/create the file
0013: 0106 3E FF                  LD     A,TRUE
0014: 0108 32 7F 02               LD     (file1Open),A        ; Set open flag
0015: 010B
0016: 010B
0017: 010B C3 35 01               JP     Exit
0018: 010E
0019: 010E             END:
0020: 010E 00                     NOP
0021: 010F 76                     HALT
0022: 0110
0023: 0110             LoadtheFile:
0024: 0110
0025: 0110             GetTheFile:
0026: 0110         ;   Is there a file on the command line ?
0027: 0110
0028: 0110 3A 5D 00               LD     A,(FCB1+1)           ; First char in file name
0029: 0113 FE 20                  CP     SPACE                ; Is it Blank ?
0030: 0115 CC 4B 01               CALL   Z,askForFile         ;  yes, ask the user for the file
0031: 0118
0032: 0118
0033: 0118 11 5C 00               LD     DE,FCB1              ; Point at the file from CMD line
0034: 011B 0E 0F                  LD     C,fOpenFile          ; Open the file
0035: 011D CD 05 00               CALL   BDOS
0036: 0120 3C                     INC    A                    ; -1 +1 = 0
0037: 0121 C0                     RET    NZ                   ; File is now open
0038: 0122 11 5C 00               LD     DE,FCB1              ; Point at the file from CMD line
0039: 0125 0E 16                  LD     C,fMakeFile          ; Make a new File
0040: 0127 CD 05 00               CALL   BDOS
0041: 012A 3C                     INC    A                    ; -1 +1 = 0
0042: 012B C0                     RET    NZ                   ; New File available
0043: 012C
0044: 012C 01 C5 02               LD     BC,msgBadMake
0045: 012F CD 0D 02               CALL   printCrLfStringNull
0046: 0132 C3 35 01               JP     Exit
0047: 0135
0048: 0135             Exit:
0049: 0135 3A 7F 02               LD     A,(file1Open)
0050: 0138 FE FF                  CP     TRUE                 ; Do we have an open file ?
0051: 013A 20 08                  JR     NZ,Exit1             ; no, skip the close
0052: 013C 11 5C 00               LD     DE,FCB1              ; Point at file1's FCB
0053: 013F 0E 10                  LD     C,fCloseFile         ; CLose File
0054: 0141 CD 05 00               CALL   BDOS
0055: 0144             Exit1:
0056: 0144 01 D9 02               LD     BC,msgByeBye
0057: 0147 CD 0D 02               CALL   printCrLfStringNull
0058: 014A C9                     RET
0059: 014B         ;-------
0060: 014B
0061: 014B             askForFile:
0062: 014B AF                     XOR    A                    ; Set Acc to Zero
0063: 014C CD 68 01               CALL   FillCmdBuffer        ; Initialize command buffer
0064: 014F
0065: 014F
0066: 014F 01 A6 02               LD     BC,msgAskForFile
0067: 0152 CD 0D 02               CALL   printCrLfStringNull
0068: 0155 CD 7B 01               CALL   CommandPrompt
0069: 0158
0070: 0158 11 80 02               LD     DE,CommandBuffer
0071: 015B 3E 0F                  LD     A,15
0072: 015D 12                     LD     (DE),A               ; Limit to full file name
0073: 015E
0074: 015E         ;	INC		DE
0075: 015E         ;	INC		DE							; Point at start of input
0076: 015E 0E 0A                  LD     C,fReadString
0077: 0160 CD 05 00               CALL   BDOS                 ; read user's input
0078: 0163
0079: 0163 CD 35 01               CALL   Exit
0080: 0166 00                     NOP
0081: 0167 76                     HALT
0082: 0168
0083: 0168         ;---------------------------- Fill Command Buffer --------------------------;
0084: 0168         ; Fills the command buffer with value in ACC.
0085: 0168         ; Registers BC,DE & HL are preserved
0086: 0168             FillCmdBuffer:
0087: 0168 E5                     PUSH   HL
0088: 0169 D5                     PUSH   DE
0089: 016A C5                     PUSH   BC
0090: 016B 21 80 02               LD     HL,CommandBuffer
0091: 016E 77                     LD     (HL),A
0092: 016F 11 81 02               LD     DE,CommandBuffer+1
0093: 0172 01 1F 00               LD     BC,CmdBuffSize-1
0094: 0175 ED B0                  LDIR                        ; Clear command buffer
0095: 0177 C1                     POP    BC
0096: 0178 D1                     POP    DE
0097: 0179 E1                     POP    HL
0098: 017A C9                     RET
0099: 017B
0100: 017B
0101: 017B         ;------------------------------ Command Prompt -----------------------------;
0102: 017B             CommandPrompt:
0103: 017B 1E 2A                  LD     E,STAR               ; nnnn *
0104: 017D CD 87 01               CALL   UserPrompt
0105: 0180 C9                     RET
0106: 0181         ;------------------------------- Input Prompt ------------------------------;
0107: 0181             InputPrompt:
0108: 0181 1E 3A                  LD     E,COLON              ; nnnn :
0109: 0183 CD 87 01               CALL   UserPrompt
0110: 0186 C9                     RET
0111: 0187         ;-------------------------------- UserPrompt -------------------------------;
0112: 0187         ; E -> Char to prompt
0113: 0187             UserPrompt:
0114: 0187 D5                     PUSH   DE                   ; Save prompt
0115: 0188 CD BA 01               CALL   PrintLineNumber
0116: 018B CD DE 01               CALL   printSpace
0117: 018E D1                     POP    DE                   ; Get prompt char
0118: 018F CD E5 01               CALL   printCharInE
0119: 0192 CD DE 01               CALL   printSpace
0120: 0195 C9                     RET
0121: 0196
0122: 0196
0123: 0196
0124: 0196         ;--------------------------------- Utilities -------------------------------;
0125: 0196             appInit:
0126: 0196 3A 07 00               LD     A,(BDOS+2)           ; Get BDOS start page
0127: 0199 D6 01                  SUB    1                    ; Find the page before that
0128: 019B 67                     LD     H,A                  ; Move to H
0129: 019C 2E A0                  LD     L,0A0H
0130: 019E F9                     LD     SP,HL                ; Make stack 160 bytes
0131: 019F 2E 00                  LD     L,00H
0132: 01A1 22 7D 02               LD     (endOfBuffer),HL     ; save top of buffer
0133: 01A4 21 E7 02               LD     HL,EndOfCode         ; Find start of Buffer
0134: 01A7 24                     INC    H
0135: 01A8 2E 00                  LD     L,0                  ; Start buffer on page boundary
0136: 01AA 22 7B 02               LD     (startOfBuffer),HL   ; Save beginning of buffer
0137: 01AD 21 00 00               LD     HL,0000
0138: 01B0 22 78 02               LD     (linePointer),HL     ; Initialize the pointer
0139: 01B3 AF                     XOR    A
0140: 01B4 32 7A 02               LD     (lineIndex),A        ; Initialize the index
0141: 01B7
0142: 01B7 C3 03 01               JP     Begin                ; Do the Application
0143: 01BA
0144: 01BA
0145: 01BA                        Include ./Utilities.Z80
0146: 01BA         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0147: 01BA         ; Utilities.Z80
0148: 01BA         ;---------------------------- Print Line Number ----------------------------;
0149: 01BA             PrintLineNumber:
0150: 01BA CD ED 01               CALL   printCrLf
0151: 01BD 2A 78 02               LD     HL,(linePointer)     ; get current line number
0152: 01C0 DD 21 A0 02               LD     IX,LineNumber
0153: 01C4 CD 41 02               CALL   HexToASCIIbuff       ; make ASCII
0154: 01C7
0155: 01C7 21 A0 02               LD     HL,LineNumber        ; Point at the buffer
0156: 01CA 06 04                  LD     B,04                 ; Set loop counter up
0157: 01CC 7E                     LD     A,(HL)               ; Get 1st value
0158: 01CD FE 30                  CP     ASCII_ZERO           ; Leading value 0?
0159: 01CF 28 03                  JR     Z,PrintLineNumber1   ; Skip if yes
0160: 01D1 CD E2 01               CALL   printCharInA         ; print leading char
0161: 01D4
0162: 01D4             PrintLineNumber1:
0163: 01D4 23                     INC    HL
0164: 01D5 7E                     LD     A,(HL)
0165: 01D6 E5                     PUSH   HL
0166: 01D7 CD E2 01               CALL   printCharInA
0167: 01DA E1                     POP    HL
0168: 01DB 10 F7                  DJNZ   PrintLineNumber1
0169: 01DD C9                     RET
0170: 01DE
0171: 01DE         ;------------------------------- Print Space -------------------------------;
0172: 01DE             printSpace:
0173: 01DE 1E 20                  LD     E,SPACE              ; Load Space
0174: 01E0 18 03                  JR     printCharInE         ; Go Print it  * Save BC
0175: 01E2
0176: 01E2         ;------------------------------- printCharInA ------------------------------;
0177: 01E2         ; Print character
0178: 01E2         ; On Entry A = Character to Send to Console
0179: 01E2             printCharInA:
0180: 01E2 5F                     LD     E,A                  ; move char to E
0181: 01E3 18 00                  JR     printCharInE
0182: 01E5
0183: 01E5         ;------------------------------- printCharInE ------------------------------;
0184: 01E5         ; Print character
0185: 01E5         ; On Entry E = Character to Send to Console
0186: 01E5         ; Preserves BC								;
0187: 01E5             printCharInE:
0188: 01E5 C5                     PUSH   BC                   ; Preserve BC
0189: 01E6 0E 02                  LD     C,fConsoleOut        ; Load Function Number
0190: 01E8 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0191: 01EB C1                     POP    BC                   ; Restore BC
0192: 01EC C9                     RET
0193: 01ED         ;------------------------------- printCharInE ------------------------------;
0194: 01ED
0195: 01ED         ;-------------------------------- CR / LF ----------------------------------;
0196: 01ED         ;Sent Carriage Return Line Feed to Console
0197: 01ED             printCrLf:
0198: 01ED 1E 0D                  LD     E,CR                 ; Load Carriage Return
0199: 01EF 0E 02                  LD     C,fConsoleOut        ; Load Function Number
0200: 01F1 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0201: 01F4 1E 0A                  LD     E,LF                 ; Load Line Feed
0202: 01F6 0E 02                  LD     C,fConsoleOut        ; Load Function Number
0203: 01F8 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0204: 01FB C9                     RET
0205: 01FC         ;-------------------------------- CR / LF ----------------------------------;
0206: 01FC         ;-------------------------------- CR / LF ----------------------------------;
0207: 01FC         ;Sent Carriage Return Line Feed to Console
0208: 01FC             printCrLfSafe:
0209: 01FC C5                     PUSH   BC                   ; Preserve BC
0210: 01FD 1E 0D                  LD     E,CR                 ; Load Carriage Return
0211: 01FF 0E 02                  LD     C,fConsoleOut        ; Load Function Number
0212: 0201 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0213: 0204 1E 0A                  LD     E,LF                 ; Load Line Feed
0214: 0206 0E 02                  LD     C,fConsoleOut        ; Load Function Number
0215: 0208 CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0216: 020B C1                     POP    BC                   ; Restore BC
0217: 020C C9                     RET
0218: 020D         ;-------------------------------- CR / LF ----------------------------------;
0219: 020D         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
0220: 020D         ;print CRLF then null terminated string at (BC)
0221: 020D             printCrLfStringNull:
0222: 020D C5                     PUSH   BC                   ; Save string pointer
0223: 020E CD ED 01               CALL   printCrLf            ; Send CR/LF
0224: 0211 E1                     POP    HL                   ; Restore pointer & fall thru
0225: 0212         ;print null terminated string from (HL)
0226: 0212             printStringNull:
0227: 0212 7E                     LD     A,(HL)               ; Get the next character
0228: 0213 B7                     OR     A                    ; Is it the Null terminator ?
0229: 0214 C8                     RET    Z                    ;  exit if yes
0230: 0215 23                     INC    HL                   ; Move string pointer
0231: 0216 E5                     PUSH   HL                   ; Save for next iteration
0232: 0217 5F                     LD     E,A                  ; Character
0233: 0218 0E 02                  LD     C,fConsoleOut        ; Load Function Number
0234: 021A CD 05 00               CALL   BDOS                 ;  and let BDOS do its work
0235: 021D E1                     POP    HL                   ; string pointer
0236: 021E 18 F2                  JR     printStringNull      ; Loop for more
0237: 0220         ;----------------- Print (CRLF then ) Null Terminated String ---------------;
0238: 0220         ;------------------------ Get Number From Command Line ---------------------;
0239: 0220         ; Get number from the command line
0240: 0220         ; Exits with A = Value
0241: 0220         ;?GetNumberFromCmdLine:
0242: 0220         ;?	CALL	ParseToken1					; Get token
0243: 0220         ;?	LD		A,(selectedDisk)			; Get currently selected disk
0244: 0220         ;?	OR		A							; Is it current default disk ?
0245: 0220         ;?	JP		NZ,CommandError				;  no, then error exit
0246: 0220         ;?; convert the byte value in Token1 to binary
0247: 0220         ;?
0248: 0220 21 00 00               LD     HL,0000
0249: 0223 01 00 00               LD     BC,0000              ; Clear the registers
0250: 0226
0251: 0226         ;	LD		IX,Token1 + 1   **********
0252: 0226             CalculateNumber:
0253: 0226 DD 7E 00               LD     A,(IX+0)             ; Get Character
0254: 0229 DD 23                  INC    IX                   ; Adjust for next time around
0255: 022B FE 20                  CP     SPACE                ; Terminating character ?
0256: 022D 28 10                  JR     Z,ReturnNumericValue ;  get out if yes
0257: 022F D6 30                  SUB    ASCII_ZERO           ; Make binary
0258: 0231 FE 0A                  CP     0AH                  ; Is it a digit ?
0259: 0233 30 0A                  JR     NC,ReturnNumericValue ;  get out if no
0260: 0235 29                     ADD    HL,HL                ; Prior value * 2
0261: 0236 E5                     PUSH   HL                   ; Move *2
0262: 0237 D1                     POP    DE                   ;  to DE
0263: 0238 29                     ADD    HL,HL                ; Prior value * 4
0264: 0239 29                     ADD    HL,HL                ; Prior value * 8
0265: 023A 19                     ADD    HL,DE                ; Add * 2 gives Prior value * 10
0266: 023B 4F                     LD     C,A                  ; Get this digit
0267: 023C 09                     ADD    HL,BC                ; and add it
0268: 023D 18 E7                  JR     CalculateNumber
0269: 023F
0270: 023F             ReturnNumericValue:
0271: 023F 7D                     LD     A,L                  ; Put result in Acc
0272: 0240 C9                     RET
0273: 0241
0274: 0241         ;------------------------ Get Number From Command Line ---------------------;
0275: 0241         ;----------------------------- Hex To ASCII Buffer -------------------------;
0276: 0241         ; HL  -> Dividend
0277: 0241         ; IX  -> ASCII buffer
0278: 0241             HexToASCIIbuff:
0279: 0241         ;	LD		IX,LineNumber				; Set up buffer Pointer
0280: 0241
0281: 0241 11 10 27               LD     DE,2710H             ; 10,000D, 2710H
0282: 0244 CD 60 02               CALL   HexToASCIIdigit      ; Get digit4
0283: 0247
0284: 0247 11 E8 03               LD     DE,03E8H             ; 1,000D, 03E8H
0285: 024A CD 60 02               CALL   HexToASCIIdigit      ; Get digit3
0286: 024D
0287: 024D 11 64 00               LD     DE,64H               ; 100D, 64H
0288: 0250 CD 60 02               CALL   HexToASCIIdigit      ; Get digit2
0289: 0253
0290: 0253 11 0A 00               LD     DE,0AH               ; 10D, 0AH
0291: 0256 CD 60 02               CALL   HexToASCIIdigit      ; Get digit1
0292: 0259
0293: 0259 7D                     LD     A,L                  ; Get digit0
0294: 025A C6 30                  ADD    A,ASCII_ZERO         ; Make ASCII
0295: 025C DD 77 00               LD     (IX+0),A             ; Put it in Buffer
0296: 025F
0297: 025F C9                     RET                         ; Exit
0298: 0260
0299: 0260         ;----------------------------- Hex To ASCII Buffer -------------------------;
0300: 0260
0301: 0260         ;----------------------------- Hex To ASCII Digit --------------------------;
0302: 0260         ; HL  -> Dividend
0303: 0260         ; DE  -> Divisor
0304: 0260         ; IX  -> ASCII buffer
0305: 0260
0306: 0260         ; HL  <- Remainder
0307: 0260         ; IX  <- ASCII buffer + 1
0308: 0260             HexToASCIIdigit:
0309: 0260 CD 6D 02               CALL   Divide               ; Get value
0310: 0263 C6 30                  ADD    A,ASCII_ZERO         ; Make ASCII
0311: 0265 DD 77 00               LD     (IX+0),A             ; Put it in Buffer
0312: 0268 DD 23                  INC    IX                   ; Increment buffer pointer
0313: 026A C5                     PUSH   BC                   ; Get remainder
0314: 026B E1                     POP    HL                   ; Put into HL for return
0315: 026C C9                     RET                         ; Exit
0316: 026D         ;----------------------------- Hex To ASCII Digit --------------------------;
0317: 026D
0318: 026D         ;----------------------------------- Divide --------------------------------;
0319: 026D         ; HL  -> Dividend
0320: 026D         ; DE  -> Divisor
0321: 026D         ; BC  <- Remainder
0322: 026D         ; ACC <- Result
0323: 026D
0324: 026D             Divide:
0325: 026D 3E FF                  LD     A,-1                 ; Initialize Acc
0326: 026F
0327: 026F             Divide1:
0328: 026F E5                     PUSH   HL                   ; Want to save
0329: 0270 C1                     POP    BC                   ;  what will be the remainder
0330: 0271 3C                     INC    A                    ; Keep count
0331: 0272 A7                     AND    A                    ; Clear the CY flag
0332: 0273 ED 52                  SBC    HL,DE                ; Poor man's divide
0333: 0275 30 F8                  JR     NC,Divide1           ;  loop if more
0334: 0277 C9                     RET                         ;  else return
0335: 0278         ;----------------------------------- Divide --------------------------------;
0336: 0278         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0337: 0278
0338: 0278                        Include ./MyEdVars.Z80
0339: 0278         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0340: 0278         ; MyEdVars.z80
0341: 0278
0342: 0278         ;-------------------------------- Variables --------------------------------;
0343: 0278             linePointer:
0344: 0278 00 00                  DW     00000H               ; Current Line Number
0345: 027A             lineIndex:
0346: 027A 00                     DB     00                   ; Current index in current line
0347: 027B             startOfBuffer:
0348: 027B 00 00                  DW     0000H
0349: 027D             endOfBuffer:
0350: 027D 00 00                  DW     0000H
0351: 027F             file1Open:
0352: 027F 00                     DB     FALSE
0353: 0280
0354: 0280         ;---------------------------------- Buffers --------------------------------;
0355: 0280             CmdBuffSize EQU    020H
0356: 0280             CommandBuffer:
0357: 0280                        DS     CmdBuffSize
0358: 02A0             LineNumber:
0359: 02A0 20 20 20 20 20 20                DB     SPACE,SPACE,SPACE,SPACE,SPACE,SPACE
0360: 02A6
0361: 02A6         ;--------------------------------- Messages --------------------------------;
0362: 02A6             msgAskForFile:
0363: 02A6 0D 0A 50 6C 65 61 73 65 20 65 6E 74 65 72 20 61 20 66 69 6C 65 20 6E 61 6D 65 3A 20 0D 0A 00                DB     CR,LF,'Please enter a file name: ',CR,LF,0
0364: 02C5             msgBadMake:
0365: 02C5 55 6E 61 62 6C 65 20 74 6F 20 6D 61 6B 65 20 66 69 6C 65 00                DB     'Unable to make file',0
0366: 02D9             msgByeBye:
0367: 02D9 45 6E 64 20 6F 66 20 4D 59 45 44 0D 0A 00                DB     'End of MYED',CR,LF,0
0368: 02E7             EndOfCode:
0369: 02E7         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0370: 02E7
0371: 02E7             EndOfCode:
0372: 02E7
0373: 02E7                        Include ./hdrA.z80
0374: 02E7         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0375: 02E7         ;hdrA.Z80
0376: 02E7
0377: 02E7         ; Header file for use with A.Z80
0378: 02E7
0379: 02E7             BDOS       EQU    00005H
0380: 02E7             fConsoleOut EQU    02H
0381: 02E7             fPrintString EQU    09H
0382: 02E7             fReadString EQU    0AH
0383: 02E7             fOpenFile  EQU    0FH
0384: 02E7             fCloseFile EQU    10H
0385: 02E7             fFindFirst EQU    11H
0386: 02E7             fFindNext  EQU    12H
0387: 02E7             fReadSeq   EQU    14H
0388: 02E7             fMakeFile  EQU    16H
0389: 02E7             fRenameFile EQU    17H
0390: 02E7             fSetDMA    EQU    1AH
0391: 02E7
0392: 02E7             defaultBuffer EQU    080H
0393: 02E7
0394: 02E7             FCB1       EQU    05CH                 ; File Control Block #1
0395: 02E7
0396: 02E7             EOM        EQU    '$'
0397: 02E7
0398: 02E7             LF         EQU    0AH                  ; Line Feed
0399: 02E7             CR         EQU    0DH                  ; Carriage Return
0400: 02E7             TRUE       EQU    -1
0401: 02E7             FALSE      EQU    00H
0402: 02E7             SPACE      EQU    020H
0403: 02E7
0404: 02E7             STAR       EQU    '*'
0405: 02E7             COLON      EQU    3AH                  ; Colon
0406: 02E7             ASCII_ZERO EQU    030H
0407: 02E7         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
           ************************   Xref   ************************
0000: $               02E7
0125: appInit         0196   0010
0406: ASCII_ZERO      0030   0158 0257 0294 0310
0061: askForFile      014B   0030
0379: BDOS            0005   0035 0040 0054 0077 0126 0190 0200 0203 0212 0215 0234
0011: Begin           0103   0142
0252: CalculateNumber 0226   0268
0355: CmdBuffSize     0020   0093 0357
0405: COLON           003A   0108
0356: CommandBuffer   0280   0070 0090 0092
0102: CommandPrompt   017B   0068
0399: CR              000D   0198 0210 0363 0367
0392: defaultBuffer   0080
0324: Divide          026D   0309
0327: Divide1         026F   0333
0019: END             010E
0349: endOfBuffer     027D   0132
0368: EndOfCode       02E7   0133
0396: EOM             0024
0048: Exit            0135   0017 0046 0079
0055: Exit1           0144   0051
0401: FALSE           0000   0352
0394: FCB1            005C   0028 0033 0038 0052
0384: fCloseFile      0010   0053
0380: fConsoleOut     0002   0189 0199 0202 0211 0214 0233
0385: fFindFirst      0011
0386: fFindNext       0012
0351: file1Open       027F   0014 0049
0086: FillCmdBuffer   0168   0063
0388: fMakeFile       0016   0039
0383: fOpenFile       000F   0034
0381: fPrintString    0009
0387: fReadSeq        0014
0382: fReadString     000A   0076
0389: fRenameFile     0017
0390: fSetDMA         001A
0025: GetTheFile      0110   0012
0278: HexToASCIIbuff  0241   0153
0308: HexToASCIIdigit 0260   0282 0285 0288 0291
0107: InputPrompt     0181
0398: LF              000A   0201 0213 0363 0367
0345: lineIndex       027A   0140
0358: LineNumber      02A0   0152 0155
0343: linePointer     0278   0138 0151
0023: LoadtheFile     0110
0362: msgAskForFile   02A6   0066
0364: msgBadMake      02C5   0044
0366: msgByeBye       02D9   0056
0179: printCharInA    01E2   0160 0166
0187: printCharInE    01E5   0118 0174 0181
0197: printCrLf       01ED   0150 0223
0208: printCrLfSafe   01FC
0221: printCrLfStringNull 020D   0045 0057 0067
0149: PrintLineNumber 01BA   0115
0162: PrintLineNumber1 01D4   0159 0168
0172: printSpace      01DE   0116 0119
0226: printStringNull 0212   0236
0270: ReturnNumericValue 023F   0256 0259
0402: SPACE           0020   0029 0173 0255 0359
0404: STAR            002A   0103
0009: Start           0100
0347: startOfBuffer   027B   0136
0004: TPA             0100   0006
0400: TRUE            FFFF   0013 0050
0113: UserPrompt      0187   0104 0109
