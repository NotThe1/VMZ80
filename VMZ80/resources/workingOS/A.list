0001: 0100         ; A.Z80
0002: 0100         ;
0003: 0100         ;	2018-11-30
0004: 0100         ; 1
0005: 0100
0006: 0100         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0007: 0100         ; by Andy Johnson-Laird
0008: 0100         ;
0009: 0100         ; Published by
0010: 0100         ; Osborne/McGraw-Hill
0011: 0100         ; 2600 Tenth Street
0012: 0100         ; Berkeley, California 94710
0013: 0100         ; U.S.A.
0014: 0100
0015: 0100             IN_OPCODE  EQU    0DBH                 ; opcode for read
0016: 0100             OUT_OPCODE EQU    0D3H                 ; opcode for Write
0017: 0100         ;?END_OF_FILE	EQU		01AH;		; End Of File code
0018: 0100             ASCII_MASK EQU    07FH                 ; bits 0-6
0019: 0100         ;?DUMMY_VALUE	EQU		00H			; place holder for Dummy Status mask
0020: 0100             MINUS_ONE  EQU    0FFH                 ; byte size -1
0021: 0100         ;?
0022: 0100             StackTop   EQU    0100H
0023: 0100         ;?
0024: 0100         ;?
0025: 0100                        ORG    0100H
0026: 0100             Start:
0027: 0100 31 00 01               LD     SP,StackTop
0028: 0103         ;	CALL ConStatus
0029: 0103         ;	CALL	ConIn
0030: 0103         ;	LD		C,045H
0031: 0103         ;	CALL	CONOut
0032: 0103 CD 3E 01               CALL   LISTST
0033: 0106 76                     HALT
0034: 0107 18 F7                  JR     Start
0035: 0109
0036: 0109 00          IOBYTE:    DB     00000000B            ; LST: device 0
0037: 010A         ;---------------------------------------------------------------------------
0038: 010A         ;				BIOS Character I/O devices
0039: 010A         ;
0040: 010A         ;				BIOS JMP vector		Function
0041: 010A         ;					--				--------
0042: 010A         ;		ConStatus:	02			 	Console Status
0043: 010A         ;		ConIn:		03				Console In
0044: 010A         ;		CONOut:		04				Console Out
0045: 010A         ;					05				List Out
0046: 010A         ;					06				Punch Out
0047: 010A         ;					07				Reader In
0048: 010A         ;		ListST		0F				List Status
0049: 010A
0050: 010A
0051: 010A         ;---------------------------------------------------------------------------
0052: 010A         ;	Console Status:		BIOS 02
0053: 010A         ;  CONST simply returns an indicator showing whether there is an incoming
0054: 010A         ; character from the console device. The convention is that A = OFFH if a character
0055: 010A         ; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
0056: 010A         ; to reflect the contents of the A register - it is the contents that are important.
0057: 010A         ; CONST is called by the CCP whenever the CCP is in the middle of an
0058: 010A         ; operation that can be interrupted by pressing a keyboard character.
0059: 010A         ;
0060: 010A         ; The BDOS will call CONST if a program makes a Read Console Status
0061: 010A         ; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
0062: 010A         ; routine, CONIN
0063: 010A
0064: 010A             ConStatus:
0065: 010A 3A 09 01               LD     A,(IOBYTE)
0066: 010D DD 21 D1 01               LD     IX,CON_Vector
0067: 0111 CD 8A 01               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0068: 0114 CD 57 01               CALL   GetInStatus
0069: 0117 B7                     OR     A
0070: 0118 C8                     RET    Z                    ; 00 => No data pending
0071: 0119 3E FF                  LD     A,0FFH
0072: 011B C9                     RET                         ; OFFH => Data in Buffer
0073: 011C         ;---------------------------------------------------------------------
0074: 011C         ;	Console In:		BIOS 03
0075: 011C         ;  CONIN reads the next character from the console to the A register and sets the
0076: 011C         ; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
0077: 011C         ; until it detects A = OFFH. Only then will it input the data character and mask off
0078: 011C         ; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
0079: 011C         ; Read Console Byte function (B$CONIN, code 1).
0080: 011C
0081: 011C         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0082: 011C
0083: 011C             ConIn:
0084: 011C CD 0A 01               CALL   ConStatus
0085: 011F 28 FB                  JR     Z,ConIn              ; loop until there is some
0086: 0121         ; Call to ConStatus Sets up IX with Physical Table
0087: 0121 DD 6E 06               LD     L,(IX+DataReadIndex)
0088: 0124 DD 66 07               LD     H,(IX+(DataReadIndex+1))
0089: 0127 E9                     JP     (HL)
0090: 0128         ;---------------------------------------------------------------------------
0091: 0128         ;	Console Out:		BIOS 04
0092: 0128         ;  CONOUT outputs the character (in ASCII) in register C to the console. The
0093: 0128         ; most significant (parity) bit of the character will always be O.
0094: 0128         ; CONOUT must first check that the console device is ready to receive more
0095: 0128         ; data, delaying if necessary until it is, and only then sending the character to the
0096: 0128         ; device. CONOUT is called by the CCP and by the BDOS when a program executes a
0097: 0128         ; Write Console Byte function (B$CONOUT, code 2).
0098: 0128
0099: 0128             CONOut:
0100: 0128 3A 09 01               LD     A,(IOBYTE)
0101: 012B DD 21 D1 01               LD     IX,CON_Vector
0102: 012F CD 8A 01               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0103: 0132             CONOutStat:
0104: 0132 CD 52 01               CALL   GetOutStatus
0105: 0135 28 FB                  JR     Z,CONOutStat         ; wait until ready
0106: 0137 DD 6E 08               LD     L,(IX+DataWriteIndex)
0107: 013A DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0108: 013D E9                     JP     (HL)
0109: 013E
0110: 013E
0111: 013E         ;---------------------------------------------------------------------------
0112: 013E         ;	List Status:  BIOS 0F
0113: 013E
0114: 013E         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0115: 013E         ; This function returns the current status of the list device, using the IOBYTE if
0116: 013E         ; necessary to select the correct physical device. It sets the A register to OFFH if the
0117: 013E         ; list device can accept another character for output or to OOH if it is not ready.
0118: 013E         ; Digital Research's documentation states that this function is used by the
0119: 013E         ; DESPOOL utility program (which allows you to print a file "simultaneously" with
0120: 013E         ; other operations) to improve console response during its operation, and that it is
0121: 013E         ; acceptable for the routine always to return OOH if you choose not to implement it
0122: 013E         ; fully.
0123: 013E         ; Unfortunately, this statement is wrong. Many other programs use the LISTST
0124: 013E         ; function to "poll" the list device to make sure it is ready, and if it fails to come
0125: 013E         ; ready after a predetermined time, to output a message to the console indicating
0126: 013E         ; that the printer is not ready. If you ever make a call to the BDOS list output
0127: 013E         ; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0128: 013E         ; not ready, then CP/M will wait forever-and your program will have lost control
0129: 013E         ; so it cannot even detect that the problem has occurred. If LISTST always returns a
0130: 013E         ; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
0131: 013E         ; out of the LISTST function, but it also causes a stream of false "Printer
0132: 013E         ; not Ready" error messages to appear on the console.
0133: 013E         ;
0134: 013E             LISTST:
0135: 013E         ;?GetLSTStatus:
0136: 013E 3A 09 01               LD     A,(IOBYTE)           ; Get Physical device
0137: 0141 07                     RLCA
0138: 0142 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0139: 0143
0140: 0143 DD 21 E9 01               LD     IX,LST_Vector
0141: 0147 CD 8A 01               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0142: 014A CD 52 01               CALL   GetOutStatus
0143: 014D
0144: 014D B7                     OR     A
0145: 014E C8                     RET    Z                    ; 00 => Device Ready
0146: 014F 3E FF                  LD     A,0FFH
0147: 0151 C9                     RET                         ; OFFH => Device No Ready
0148: 0152
0149: 0152         ;---------------------------------------------------------------------------
0150: 0152
0151: 0152         ;---------------------------------------------------------------------
0152: 0152             GetOutStatus:
0153: 0152         ; vector to CON Devices
0154: 0152 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0155: 0155 18 03                  JR     GetStatus
0156: 0157             GetInStatus:
0157: 0157 DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0158: 015A             GetStatus:
0159: 015A DD 6E 04               LD     L,(IX+StatusReadIndex)
0160: 015D DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0161: 0160 E9                     JP     (HL)                 ; jump to the stats read routine
0162: 0161
0163: 0161         ;---------------------------------------------------------------------
0164: 0161
0165: 0161             DataRead:
0166: 0161 DD 7E 01               LD     A,(IX+DataPortIndex)
0167: 0164 32 68 01               LD     (AddressDataIn),A    ; modify code with the Data port
0168: 0167 DB                     DB     IN_OPCODE
0169: 0168             AddressDataIn:
0170: 0168 00                     DB     00                   ; perform the read
0171: 0169 C9                     RET
0172: 016A
0173: 016A             DataReadASCII:
0174: 016A CD 61 01               CALL   DataRead
0175: 016D E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0176: 016F C9                     RET                         ; AND		ASCII_MASK
0177: 0170
0178: 0170         ; Enter DataWrite the value to be output in C
0179: 0170             DataWrite:
0180: 0170 DD 7E 01               LD     A,(IX+DataPortIndex)
0181: 0173 32 78 01               LD     (AddressDataOut),A   ; modify code with the Data port
0182: 0176 79                     LD     A,C                  ; get value into ACC
0183: 0177 D3                     DB     OUT_OPCODE
0184: 0178             AddressDataOut:
0185: 0178 00                     DB     00                   ; perform the write
0186: 0179 C9                     RET
0187: 017A
0188: 017A
0189: 017A         ; Enter Status Read with Target mask in D
0190: 017A             StatusRead:
0191: 017A DD 7E 00               LD     A,(IX+StatusPortIndex)
0192: 017D 32 81 01               LD     (AddressStatus),A    ; modify code with the status port
0193: 0180 DB                     DB     IN_OPCODE
0194: 0181             AddressStatus:
0195: 0181 00                     DB     00
0196: 0182 A2                     AND    D                    ; Check return vale with the mask
0197: 0183 C9                     RET
0198: 0184
0199: 0184             DUMMYRead:                      ;        Routine stub
0200: 0184 C9                     RET
0201: 0185             DUMMYWrite:                      ;        Routine stub
0202: 0185 C9                     RET
0203: 0186             DUMMYCheck:                      ;        Routine stub
0204: 0186 3E FF                  LD     A,MINUS_ONE          ; Always return 0FFH
0205: 0188 B7                     OR     A                    ; Set flags
0206: 0189 C9                     RET
0207: 018A
0208: 018A         ;=============================================================================
0209: 018A             SetDeviceVector:
0210: 018A E6 03                  AND    03H                  ; Get bits 0 & 1;
0211: 018C 87                     ADD    A,A                  ; Double for word size index
0212: 018D 16 00                  LD     D,00H
0213: 018F 5F                     LD     E,A                  ; load byte index int DE
0214: 0190 DD 19                  ADD    IX,DE                ; add to the value vector base
0215: 0192
0216: 0192 DD 5E 00               LD     E,(IX+0)
0217: 0195 DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0218: 0198 DD 21 00 00               LD     IX,0000H
0219: 019C DD 19                  ADD    IX,DE                ; Move it to IX
0220: 019E C9                     RET
0221: 019F
0222: 019F
0223: 019F         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0224: 019F
0225: 019F             TTY_StatusPort EQU    0EDH
0226: 019F             TTY_DataPort EQU    0ECH
0227: 019F             TTY_OutputMask EQU    80H                  ; Status Mask
0228: 019F             TTY_InputMask EQU    7FH                  ; Status Mask
0229: 019F
0230: 019F             CRT_StatusPort EQU    02H
0231: 019F             CRT_DataPort EQU    01H
0232: 019F             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0233: 019F             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0234: 019F
0235: 019F             COM_StatusPort EQU    0EDH
0236: 019F             COM_DataPort EQU    0ECH
0237: 019F             COM_OutputMask EQU    01H                  ; Status Mask
0238: 019F             COM_InputMask EQU    02H                  ; Status Mask
0239: 019F
0240: 019F             LPT_StatusPort EQU    011H
0241: 019F             LPT_DataPort EQU    010H
0242: 019F             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0243: 019F             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0244: 019F
0245: 019F             DUMMY_StatusPort EQU    011H
0246: 019F             DUMMY_DataPort EQU    010H
0247: 019F             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0248: 019F             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0249: 019F
0250: 019F         ; Device Table Control Block
0251: 019F             StatusPortIndex EQU    0
0252: 019F             DataPortIndex EQU    1
0253: 019F             OutputMaskIndex EQU    2
0254: 019F             InputMaskIndex EQU    3
0255: 019F             StatusReadIndex EQU    4
0256: 019F             DataReadIndex EQU    6
0257: 019F             DataWriteIndex EQU    8
0258: 019F
0259: 019F
0260: 019F             TTY_Table:
0261: 019F ED                     DB     TTY_StatusPort
0262: 01A0 EC                     DB     TTY_DataPort
0263: 01A1 80                     DB     TTY_OutputMask
0264: 01A2 7F                     DB     TTY_InputMask
0265: 01A3 7A 01                  DW     StatusRead
0266: 01A5 6A 01                  DW     DataReadASCII
0267: 01A7 70 01                  DW     DataWrite
0268: 01A9
0269: 01A9             CRT_Table:
0270: 01A9 02                     DB     CRT_StatusPort
0271: 01AA 01                     DB     CRT_DataPort
0272: 01AB 80                     DB     CRT_OutputMask
0273: 01AC 7F                     DB     CRT_InputMask
0274: 01AD 7A 01                  DW     StatusRead
0275: 01AF 61 01                  DW     DataRead
0276: 01B1 70 01                  DW     DataWrite
0277: 01B3             COM_Table:
0278: 01B3 ED                     DB     COM_StatusPort
0279: 01B4 EC                     DB     COM_DataPort
0280: 01B5 01                     DB     COM_OutputMask
0281: 01B6 02                     DB     COM_InputMask
0282: 01B7 7A 01                  DW     StatusRead
0283: 01B9 61 01                  DW     DataRead
0284: 01BB 70 01                  DW     DataWrite
0285: 01BD             LPT_Table:
0286: 01BD 11                     DB     LPT_StatusPort
0287: 01BE 10                     DB     LPT_DataPort
0288: 01BF FF                     DB     LPT_OutputMask
0289: 01C0 7F                     DB     LPT_InputMask
0290: 01C1 7A 01                  DW     StatusRead
0291: 01C3 61 01                  DW     DataRead
0292: 01C5 70 01                  DW     DataWrite
0293: 01C7             DUMMY_Table:
0294: 01C7 11                     DB     DUMMY_StatusPort
0295: 01C8 10                     DB     DUMMY_DataPort
0296: 01C9 FF                     DB     DUMMY_OutputMask
0297: 01CA 7F                     DB     DUMMY_InputMask
0298: 01CB 86 01                  DW     DUMMYCheck
0299: 01CD 84 01                  DW     DUMMYRead
0300: 01CF 85 01                  DW     DUMMYWrite
0301: 01D1
0302: 01D1
0303: 01D1
0304: 01D1         ;---------------------------------------------------------------------------
0305: 01D1             CON_Vector:
0306: 01D1 9F 01                  DW     TTY_Table
0307: 01D3 A9 01                  DW     CRT_Table
0308: 01D5 B3 01                  DW     COM_Table
0309: 01D7 C7 01                  DW     DUMMY_Table
0310: 01D9             RDR_Vector:
0311: 01D9 9F 01                  DW     TTY_Table
0312: 01DB A9 01                  DW     CRT_Table
0313: 01DD C7 01                  DW     DUMMY_Table
0314: 01DF C7 01                  DW     DUMMY_Table
0315: 01E1             PUN_Vector:
0316: 01E1 9F 01                  DW     TTY_Table
0317: 01E3 C7 01                  DW     DUMMY_Table
0318: 01E5 B3 01                  DW     COM_Table
0319: 01E7 A9 01                  DW     CRT_Table
0320: 01E9             LST_Vector:
0321: 01E9 9F 01                  DW     TTY_Table
0322: 01EB A9 01                  DW     CRT_Table
0323: 01ED BD 01                  DW     LPT_Table
0324: 01EF C7 01                  DW     DUMMY_Table
0325: 01F1
0326: 01F1
0327: 01F1
0328: 01F1         ;? ;---------------------------------------------------------------------------
0329: 01F1         ;? ;	List Status:  BIOS 0F
0330: 01F1         ;?
0331: 01F1         ;?  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0332: 01F1         ;?; This function returns the current status of the list device, using the IOBYTE if
0333: 01F1         ;?; necessary to select the correct physical device. It sets the A register to OFFH if the
0334: 01F1         ;?; list device can accept another character for output or to OOH if it is not ready.
0335: 01F1         ;?; Digital Research's documentation states that this function is used by the
0336: 01F1         ;?; DESPOOL utility program (which allows you to print a file "simultaneously" with
0337: 01F1         ;?; other operations) to improve console response during its operation, and that it is
0338: 01F1         ;?; acceptable for the routine always to return OOH if you choose not to implement it
0339: 01F1         ;?; fully.
0340: 01F1         ;?; Unfortunately, this statement is wrong. Many other programs use the LISTST
0341: 01F1         ;?; function to "poll" the list device to make sure it is ready, and if it fails to come
0342: 01F1         ;?; ready after a predetermined time, to output a message to the console indicating
0343: 01F1         ;?; that the printer is not ready. If you ever make a call to the BDOS list output
0344: 01F1         ;?; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0345: 01F1         ;?; not ready, then CP/M will wait forever-and your program will have lost control
0346: 01F1         ;?; so it cannot even detect that the problem has occurred. If LISTST always returns a
0347: 01F1         ;?; OOH, then the printer will always appear not to be ready. Not only does this makenonsense
0348: 01F1         ;?; out of the LISTST function, but it also causes a stream offalse "Printer
0349: 01F1         ;?; not Ready" error messages to appear on the console.
0350: 01F1         ;?;
0351: 01F1         ;? LISTST:
0352: 01F1         ;?GetLSTStatus:
0353: 01F1         ;?	LD		A,(IOBYTE)				; Get Physical device
0354: 01F1         ;?	RLCA
0355: 01F1         ;?	RLCA							; Move bits 6 & 7 to bits 0 & 1
0356: 01F1         ;?	LD		IX,LSTStatOutVector		; vector to I/O routines
0357: 01F1         ;?	LD		IY,LSTStatPort			; vector to I/O values
0358: 01F1         ;?	CALL	SetIndexesIO			; set up IX & IY
0359: 01F1         ;?	LD		L,(IX+0)
0360: 01F1         ;?	LD		H,(IX+1)				; HL Points to the routine
0361: 01F1         ;?	JP		(HL)
0362: 01F1         ;?
0363: 01F1         ;?
0364: 01F1         ;?;=============================================================================
0365: 01F1         ;?SetIndexesIO:
0366: 01F1         ;?	AND	03H					; Get bits 0 & 1;
0367: 01F1         ;?	LD	D,00H
0368: 01F1         ;?	LD	E,A					; load byte index int DE
0369: 01F1         ;?	ADD	IY,DE				; add to the value vector base
0370: 01F1         ;?
0371: 01F1         ;?	ADD	A,A					; Double for word size index
0372: 01F1         ;?;	LD	D,00H
0373: 01F1         ;?	LD	E,A					; load word index int DE
0374: 01F1         ;?	ADD	IX,DE				; add to the Routine vector base
0375: 01F1         ;?	RET
0376: 01F1         ;?
0377: 01F1         ;?;----------------------------------------------------------------
0378: 01F1         ;?
0379: 01F1         ;?
0380: 01F1         ;?;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0381: 01F1         ;?TTYOutStatus:
0382: 01F1         ;?CRTOutStatus:
0383: 01F1         ;?COMOutStatus:
0384: 01F1         ;?	LD		D,(IY + (ConStatOutMask-ConStatPort))
0385: 01F1         ;?	JR		ConInOutStatus
0386: 01F1         ;?TTYInStatus:
0387: 01F1         ;?CRTInStatus:
0388: 01F1         ;?COMInStatus:
0389: 01F1         ;?	LD		D,(IY + (ConStatInMask-ConStatPort))
0390: 01F1         ;?ConInOutStatus:
0391: 01F1         ;?	LD		A,(IY + (ConStatPort - ConStatPort))	; Status Port
0392: 01F1         ;?	LD		(InputStatusPort),A
0393: 01F1         ;?	DB		IN_OPCODE
0394: 01F1         ;?InputStatusPort:
0395: 01F1         ;?	DB		00					; Modified code location
0396: 01F1         ;?	AND		D
0397: 01F1         ;?	RET							; 00 => No data pending
0398: 01F1         ;?	HALT
0399: 01F1         ;?
0400: 01F1         ;?TTYInData:
0401: 01F1         ;?CRTInData0:
0402: 01F1         ;?COMInData:
0403: 01F1         ;?	LD		A,(IY + ConDataPort-ConStatPort)
0404: 01F1         ;?	LD		(InputDataPort),A
0405: 01F1         ;?	DB		IN_OPCODE
0406: 01F1         ;?InputDataPort:		DB	00		; Modified code location
0407: 01F1         ;?	RET
0408: 01F1         ;?
0409: 01F1         ;?CRTInData:
0410: 01F1         ;?	CALL	CRTInData0
0411: 01F1         ;?	AND		ASCII_MASK			; strip off bit 7
0412: 01F1         ;?	RET
0413: 01F1         ;?
0414: 01F1         ;?TTYOutData:
0415: 01F1         ;?CRTOutData:
0416: 01F1         ;?COMOutData:
0417: 01F1         ;?	LD		A,(IY + ConDataPort-ConStatPort)
0418: 01F1         ;?	LD		(OutputDataPort),A
0419: 01F1         ;?	LD		A,C					; Get Byte from C to output
0420: 01F1         ;?	DB		OUT_OPCODE
0421: 01F1         ;?OutputDataPort:		DB	00		; Modified code location
0422: 01F1         ;?	RET
0423: 01F1         ;?;......................................................
0424: 01F1         ;?LPTOutStatus:
0425: 01F1         ;?	LD		D,(IY+(LSTStatOutMask-LSTStatPort))
0426: 01F1         ;?	LD		A,(IY + (LSTStatPort-LSTStatPort))	; Status port
0427: 01F1         ;?	LD		(InputStatusPort1),A
0428: 01F1         ;?	DB		IN_OPCODE
0429: 01F1         ;?InputStatusPort1:
0430: 01F1         ;?	DB		00					; Modified code location
0431: 01F1         ;?	AND		D
0432: 01F1         ;?	RET							; 00 => No data pending
0433: 01F1         ;?	HALT
0434: 01F1         ;?
0435: 01F1         ;?;........................................................
0436: 01F1         ;?DummyStatus:
0437: 01F1         ;?	LD	A,0FFH
0438: 01F1         ;?	OR	A						; Reset the Z Flag
0439: 01F1         ;?	RET							; Dummy always returns FFH
0440: 01F1         ;?DummyInput:
0441: 01F1         ;?	LD	A,END_OF_FILE;			; Always returns End Of File
0442: 01F1         ;?DummyOutput:
0443: 01F1         ;?	RET
0444: 01F1         ;?
0445: 01F1         ;?;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0446: 01F1         ;?
0447: 01F1
0448: 01F1
0449: 01F1         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
           ************************   Xref   ************************
0000: $               01EF
0169: AddressDataIn   0168   0167
0184: AddressDataOut  0178   0181
0194: AddressStatus   0181   0192
0018: ASCII_MASK      007F   0175
0236: COM_DataPort    00EC   0279
0238: COM_InputMask   0002   0281
0237: COM_OutputMask  0001   0280
0235: COM_StatusPort  00ED   0278
0277: COM_Table       01B3   0308 0318
0305: CON_Vector      01D1   0066 0101
0083: ConIn           011C   0085
0099: CONOut          0128
0103: CONOutStat      0132   0105
0064: ConStatus       010A   0084
0231: CRT_DataPort    0001   0271
0233: CRT_InputMask   007F   0273
0232: CRT_OutputMask  0080   0272
0230: CRT_StatusPort  0002   0270
0269: CRT_Table       01A9   0307 0312 0319 0322
0252: DataPortIndex   0001   0166 0180
0165: DataRead        0161   0174 0275 0283 0291
0173: DataReadASCII   016A   0266
0256: DataReadIndex   0006   0087 0088
0179: DataWrite       0170   0267 0276 0284 0292
0257: DataWriteIndex  0008   0106 0107
0246: DUMMY_DataPort  0010   0295
0248: DUMMY_InputMask 007F   0297
0247: DUMMY_OutputMask 00FF   0296
0245: DUMMY_StatusPort 0011   0294
0293: DUMMY_Table     01C7   0309 0313 0314 0317 0324
0203: DUMMYCheck      0186   0298
0199: DUMMYRead       0184   0299
0201: DUMMYWrite      0185   0300
0156: GetInStatus     0157   0068
0152: GetOutStatus    0152   0104 0142
0158: GetStatus       015A   0155
0015: IN_OPCODE       00DB   0168 0193
0254: InputMaskIndex  0003   0157
0036: IOBYTE          0109   0065 0100 0136
0134: LISTST          013E   0032
0241: LPT_DataPort    0010   0287
0243: LPT_InputMask   007F   0289
0242: LPT_OutputMask  00FF   0288
0240: LPT_StatusPort  0011   0286
0285: LPT_Table       01BD   0323
0320: LST_Vector      01E9   0140
0020: MINUS_ONE       00FF   0204
0016: OUT_OPCODE      00D3   0183
0253: OutputMaskIndex 0002   0154
0315: PUN_Vector      01E1
0310: RDR_Vector      01D9
0209: SetDeviceVector 018A   0067 0102 0141
0022: StackTop        0100   0027
0026: Start           0100   0034
0251: StatusPortIndex 0000   0191
0190: StatusRead      017A   0265 0274 0282 0290
0255: StatusReadIndex 0004   0159 0160
0226: TTY_DataPort    00EC   0262
0228: TTY_InputMask   007F   0264
0227: TTY_OutputMask  0080   0263
0225: TTY_StatusPort  00ED   0261
0260: TTY_Table       019F   0306 0311 0316 0321
