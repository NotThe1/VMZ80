0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800
0006: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0007: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0008: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0009: E800         ; 2018-03-02 Refactored the CP/M Suite
0010: E800         ; 2018-02-12 fixed allocate 16 bit problem
0011: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0012: E800         ; 2014-03-14  :  Frank Martyn
0013: E800
0014: E800
0015: E800                        Include ./stdHeader.Z80
0016: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0017: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0018: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0019: E800         ; stdHeader.asm
0020: E800         ; standard equates
0021: E800
0022: E800         ; 2017-03-02 Refactored the CP/M Suite
0023: E800
0024: E800
0025: E800             TRUE       EQU    -1                   ; not false
0026: E800             FALSE      EQU    0000H
0027: E800             ON         EQU    -1
0028: E800             OFF        EQU    0000H
0029: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0030: E800
0031: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0032: E800             WORD       EQU    2                    ; number of bytes for "word" type
0033: E800
0034: E800
0035: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0036: E800             ZERO       EQU    00H                  ; Zero
0037: E800             EndOfMessage EQU    00H
0038: E800
0039: E800             CTRL_C     EQU    03H                  ; ETX
0040: E800             CTRL_E     EQU    05H                  ; physical eol
0041: E800             CTRL_H     EQU    08H                  ; backspace
0042: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0043: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0044: E800             CTRL_P     EQU    10H                  ; prnt toggle
0045: E800             CTRL_R     EQU    12H                  ; repeat line
0046: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0047: E800             CTRL_U     EQU    15H                  ; line delete
0048: E800             CTRL_X     EQU    18H                  ; =ctl-u
0049: E800             CTRL_Z     EQU    1AH                  ; end of file
0050: E800
0051: E800             NULL       EQU    00H                  ; Null
0052: E800             SOH        EQU    01H                  ; Start of Heading
0053: E800             BELL       EQU    07H                  ; Bell
0054: E800             TAB        EQU    09H                  ; Tab
0055: E800             LF         EQU    0AH                  ; Line Feed
0056: E800             CR         EQU    0DH                  ; Carriage Return
0057: E800             SPACE      EQU    20H                  ; Space
0058: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0059: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0060: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0061: E800             PERCENT    EQU    25H                  ; Percent Sign
0062: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0063: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0064: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0065: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0066: E800             COMMA      EQU    2CH                  ; Comma
0067: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0068: E800             PERIOD     EQU    2EH                  ; Period
0069: E800             SLASH      EQU    2FH                  ; /
0070: E800             ASCII_ZERO EQU    30H                  ; zero
0071: E800             COLON      EQU    3AH                  ; Colon
0072: E800
0073: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0074: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0075: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0076: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0077: E800             QMARK      EQU    3FH                  ; Question Mark
0078: E800             UNDER_SCORE EQU    5FH                  ; under score _
0079: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0080: E800             RUBOUT     EQU    7FH                  ; Delete Key
0081: E800
0082: E800
0083: E800             ASCII_A    EQU    'A'
0084: E800             ASCII_C    EQU    'C'
0085: E800             ASCII_K    EQU    'K'
0086: E800             ASCII_N    EQU    'N'
0087: E800             ASCII_Q    EQU    'Q'
0088: E800             ASCII_R    EQU    'R'
0089: E800             ASCII_W    EQU    'W'
0090: E800             ASCII_Y    EQU    'Y'
0091: E800             CARET      EQU    '^'
0092: E800             ASCII_LO_A EQU    'a'
0093: E800             ASCII_LO_K EQU    'k'
0094: E800             ASCII_LO_P EQU    'p'
0095: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0096: E800
0097: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0098: E800                        Include ./osHeader.Z80
0099: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0100: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0101: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0102: E800         ; osHeader.Z80
0103: E800
0104: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0105: E800         ; 2017-03-02 Refactored the CP/M Suite
0106: E800
0107: E800         ; Contains the Equates used by the CP/M system
0108: E800
0109: E800         ;------------------------Page Zero Constants ---------------------------------
0110: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0111: E800
0112: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0113: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0114: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0115: E800
0116: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0117: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0118: E800
0119: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0120: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0121: E800
0122: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0123: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0124: E800
0125: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0126: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0127: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0128: E800         ;-----------------------------------------------------------------------
0129: E800
0130: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0131: E800         ;-----------------------------------------------------------------------
0132: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0133: E800         ;-----------------------------------------------------------------------
0134: E800             END_OF_FILE EQU    1AH                  ; end of file
0135: E800         ;-----------------------------------------------------------------------
0136: E800
0137: E800         ;--------------- CP/M Constants -----------------------------------------
0138: E800
0139: E800             CCPLength  EQU    0800H                ; Constant
0140: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0141: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0142: E800
0143: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0144: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0145: E800
0146: E800             MemorySize EQU    64
0147: E800
0148: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0149: E800
0150: E800             BDOSBase   EQU    CCPEntry + CCPLength
0151: E800             BDOSEntry  EQU    BDOSBase
0152: E800
0153: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0154: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0155: E800         ;-----------------------------------------------------------------------
0156: E800
0157: E800         ;------------------- BDOS System Call Equates --------------------------
0158: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0159: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0160: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0161: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0162: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0163: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0164: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0165: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0166: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0167: E800             fCloseFile EQU    10H                  ; closef - Close File
0168: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0169: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0170: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0171: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0172: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0173: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0174: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0175: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0176: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0177: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0178: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0179: E800         ;-----------------------------------------------------------------------
0180: E800
0181: E800
0182: E800
0183: E800
0184: E800
0185: E800         ;*******************************************************************************
0186: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0187: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0188: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0189: E800         ; sector write) or to an allocation block that has already been allocated to a
0190: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0191: E800         ;*******************************************************************************
0192: E800             WriteAllocated EQU    00H
0193: E800             WriteDirectory EQU    01H
0194: E800             WriteCleanBuffer EQU    02H
0195: E800
0196: E800
0197: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0198: E800                        Include ./diskHeader.Z80
0199: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0200: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0201: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0202: E800         ; diskHeader.asm
0203: E800
0204: E800         ; 2017-03-02 Refactored the CP/M Suite
0205: E800
0206: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0207: E800
0208: E800         ; Contains the Equates used by the CP/M system to handle disks
0209: E800
0210: E800
0211: E800         ;*******************************************************************************
0212: E800         ;
0213: E800         ;     Disk related values
0214: E800         ;
0215: E800         ;
0216: E800         ;*******************************************************************************
0217: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0218: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0219: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0220: E800         ; for boot
0221: E800             DiskControlTable EQU    0040H
0222: E800
0223: E800             DiskReadCode EQU    01H                  ; Code for Read
0224: E800             DiskWriteCode EQU    02H                  ; Code for Write
0225: E800
0226: E800
0227: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0228: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0229: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0230: E800
0231: E800             DirEntrySize EQU    20H                  ; (32)
0232: E800             DirBuffSize EQU    cpmRecordSize
0233: E800
0234: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0235: E800
0236: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0237: E800
0238: E800
0239: E800         ;-------------------------------------------------------------------------------------
0240: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0241: E800
0242: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0243: E800             NumberOfHeads EQU    02H                  ; number of heads
0244: E800             TracksPerHead EQU    50H                  ; 80
0245: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0246: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0247: E800             DirectoryBlockCount EQU    02H                  ;
0248: E800         ;-----------------------------------------------------------------------
0249: E800
0250: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0251: E800
0252: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0253: E800
0254: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0255: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0256: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0257: E800
0258: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0259: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0260: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0261: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0262: E800
0263: E800         ;-----------------------------------------------------------------------
0264: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0265: E800         ;-----------------------------------------------------------------------
0266: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0267: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0268: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0269: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0270: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0271: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0272: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0273: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0274: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0275: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0276: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0277: E800             dpb3hdNOH  EQU    NumberOfHeads
0278: E800
0279: E800         ;*******************************************************************************
0280: E800
0281: E800             SectorMask EQU    SectorsPerBlock - 1
0282: E800
0283: E800         ;***************************************************************************
0284: E800
0285: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0286: E800
0287: E800             VERSION    EQU    20H                  ; Version 2.0
0288: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0289: E800             EOD        EQU    -1                   ; End of Directory
0290: E800
0291: E800         ;************************ BIOS Function Constants ***************************;
0292: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0293: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0294: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0295: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0296: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0297: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0298: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0299: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0300: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0301: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0302: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0303: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0304: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0305: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0306: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0307: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0308: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0309: E800         ;************************ BIOS Function Constants ***************************;
0310: E800
0311: E800         ;============================================================================;
0312: E800         ;	BDOS                                                                     ;
0313: E800         ; Calling into   :                                                           ;
0314: E800         ;					Register  C - Contains BDOS Function Code                ;
0315: E800         ;					Register  A - Holds the Byte argument if any             ;
0316: E800         ;					Register DE - Holds the Word argument if any             ;
0317: E800         ; Returning from :                                                           ;
0318: E800         ;					Register  A - The Byte return value if any               ;
0319: E800         ;					Register HL - The Word return value if any               ;
0320: E800         ;                   ( Register A=L and B=H)                                  ;
0321: E800         ;============================================================================;
0322: E800
0323: E800
0324: E800                        ORG    BDOSBase
0325: E800
0326: E800         ;===========================BDOS Entry=======================================;
0327: E800         ;BDOSEntry:                                                                  ;
0328: E800         ;
0329: E800         ;
0330: E800             BdosStart:                      ;
0331: E800         ;	LD		A,C                                                              ;
0332: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0333: E800         ;
0334: E800         ; Save Calling Arguments                                                     ;
0335: E800 ED 53 C0 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0336: E804 7B                     LD     A,E                  ;
0337: E805 32 BF EA               LD     (paramE),A           ; Save the Byte argument             ;
0338: E808         ; Save users Stack pointer                                                   ;
0339: E808 ED 73 B9 EA               LD     (usersStack),SP      ; We will use our own stack          ;
0340: E80C         ;
0341: E80C         ; initialize variables                                                       ;
0342: E80C 21 00 00               LD     HL,0000H             ;
0343: E80F 22 C2 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0344: E812 AF                     XOR    A                    ;
0345: E813 32 69 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0346: E816 32 67 F5               LD     (fResel),A           ; Clear re selection flag            ;
0347: E819         ;
0348: E819         ; Set up for return to caller when Function Completes                        ;
0349: E819 21 2F E8               LD     HL,ReturnToCaller    ;
0350: E81C E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0351: E81D         ;
0352: E81D         ; is it a valid function number ?	                                         ;
0353: E81D         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0354: E81D 79                     LD     A,C                  ;
0355: E81E FE 28                  CP     functionCount        ; make sure its a good number        ;
0356: E820 D0                     RET    NC                   ; exit if not a valid function       ;
0357: E821         ;
0358: E821         ; Calculate the index and get vector to go to	                             ;
0359: E821 4B                     LD     C,E                  ; Assume byte argument               ;
0360: E822 21 54 E8               LD     HL,functionTable     ; Get table base                     ;
0361: E825 5F                     LD     E,A                  ; Function number in E               ;
0362: E826 16 00                  LD     D,0                  ;
0363: E828 19                     ADD    HL,DE                ; Have byte location                 ;
0364: E829 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0365: E82A 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0366: E82B 23                     INC    HL                   ;
0367: E82C 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0368: E82D EB                     EX     DE,HL                ; Vector now in HL                   ;
0369: E82E         ;
0370: E82E         ; Vector to Function is in HL                                                ;
0371: E82E E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0372: E82F         ;===========================BDOS Entry=======================================;
0373: E82F         ;===========================BDOS Exit =======================================;
0374: E82F         ;arrive here at end of processing to return to user                          ;
0375: E82F             ReturnToCaller:                      ;
0376: E82F 3A 67 F5               LD     A,(fResel)           ; get re-selection flag              ;
0377: E832 B7                     OR     A                    ; is it set?                         ;
0378: E833 28 15                  JR     Z,ReturnToCaller1    ;
0379: E835         ;re-selection  may have taken place                                         ;
0380: E835 2A C0 EA               LD     HL,(paramDE)         ;
0381: E838 36 00                  LD     (HL),0               ;
0382: E83A 3A 69 F5               LD     A,(fcbDisk)          ;
0383: E83D B7                     OR     A                    ; Disk = 0?                          ;
0384: E83E 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0385: E840         ;
0386: E840 77                     LD     (HL),A               ;
0387: E841 3A 68 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0388: E844 32 BF EA               LD     (paramE),A           ; and select it                      ;
0389: E847 CD 4F EC               CALL   SelectCurrent        ;
0390: E84A         ;
0391: E84A             ReturnToCaller1:                      ;
0392: E84A 2A B9 EA               LD     HL,(usersStack)      ;
0393: E84D F9                     LD     SP,HL                ; restore callers stack              ;
0394: E84E 2A C2 EA               LD     HL,(exitParameterWord) ;
0395: E851 7D                     LD     A,L                  ;
0396: E852 44                     LD     B,H                  ; BA = exitParameterWord             ;
0397: E853 C9                     RET                         ;
0398: E854         ;===========================BDOS Exit =======================================;
0399: E854
0400: E854         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0401: E854             functionTable:                      ;
0402: E854 A7 E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0403: E856 AA E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0404: E858 BB E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0405: E85A BF E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0406: E85C C6 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0407: E85E CA E8                  DW     vListOut             ;   5 - List Output                  ;
0408: E860 CE E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0409: E862 E4 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0410: E864 EB E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0411: E866 F0 E8                  DW     vPrintString         ;   9 - Print String                 ;
0412: E868 F9 E8                  DW     vReadString          ;   A - Read Console String          ;
0413: E86A FD E8                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0414: E86C             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0415: E86C 04 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0416: E86E C4 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0417: E870 0A EB                  DW     vSelectDisk          ;   E - Select Disk                  ;
0418: E872 34 EF                  DW     vOpenFile            ;   F - Open File                    ;
0419: E874 3D EF                  DW     vCloseFile           ;  10 - Close File                   ;
0420: E876 43 EF                  DW     vFindFirst           ;  11 - Search For First             ;
0421: E878 5C EF                  DW     vFindNext            ;  12 - Search for Next              ;
0422: E87A 6B EF                  DW     vDeleteFile          ;  13 - Delete File                  ;
0423: E87C 74 EF                  DW     vReadSeq             ;  14 - Read Sequential              ;
0424: E87E 7B EF                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0425: E880 82 EF                  DW     vMakeFile            ;  16 - Make File                    ;
0426: E882 8B EF                  DW     vRenameFile          ;  17 - Rename File                  ;
0427: E884 DD EA                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0428: E886 E4 EA                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0429: E888 EB EA                  DW     vSetDMA              ;  1A - Set DMA address              ;
0430: E88A F4 EA                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0431: E88C 43 EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0432: E88E FB EA                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0433: E890 46 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0434: E892 02 EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0435: E894 0A E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0436: E896 0D EB                  DW     vReadRandom          ;  21 - Read Random                  ;
0437: E898 13 EB                  DW     vWriteRandom         ;  22 - Write Random                 ;
0438: E89A 19 EB                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0439: E89C 1F EB                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0440: E89E 09 EB                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0441: E8A0 A6 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0442: E8A2 A6 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0443: E8A4 23 EB                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0444: E8A6             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0445: E8A6         ;
0446: E8A6             DUMMY:                          ;
0447: E8A6 76                     HALT                        ;
0448: E8A7         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0449: E8A7
0450: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0451: E8A7         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0452: E8A7         ; same as the warm boot function invoked when you transfer control to the    ;
0453: E8A7         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0454: E8A7         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0455: E8A7         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0456: E8A7         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0457: E8A7         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0458: E8A7         ;																			 ;
0459: E8A7         ;			Function Code	 :	C = 00H                                      ;
0460: E8A7         ;			Entry Parameters:	None                                         ;
0461: E8A7         ;			Exit Parameters :	Does Not Return								 ;
0462: E8A7         ;																			 ;
0463: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0464: E8A7             vSystemReset:
0465: E8A7 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0466: E8AA
0467: E8AA         ;****************************************************************************;
0468: E8AA         ;								IOByte device I/O							 ;
0469: E8AA         ;****************************************************************************;
0470: E8AA
0471: E8AA
0472: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0473: E8AA         ;  This function reads the next byte of data from the console keyboard and   ;
0474: E8AA         ; puts it into register A. If the character input is a graphic character, it ;
0475: E8AA         ; will be echoed back to the console. The only control characters that are   ;
0476: E8AA         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0477: E8AA         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0478: E8AA         ; move the cursor to the next multiple of eight columns. All of the other    ;
0479: E8AA         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0480: E8AA         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0481: E8AA         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0482: E8AA         ; console output should also be sent to the list device. If CONTROL-S is     ;
0483: E8AA         ; found, further output will be suspended until you type another character.  ;
0484: E8AA         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0485: E8AA         ; pressed and disable it the second time. If there is no incoming data       ;
0486: E8AA         ; character, this function will wait until there is one.                     ;
0487: E8AA         ;                                                                            ;
0488: E8AA         ; This is a blocking function                                                ;
0489: E8AA         ;																			 ;
0490: E8AA         ;																			 ;
0491: E8AA         ;			Function Code	:	C = 01H                                      ;
0492: E8AA         ;			Entry Parameters:	None                                         ;
0493: E8AA         ;			Exit Parameters :	A = Data byte from console					 ;
0494: E8AA         ;																			 ;
0495: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0496: E8AA             vConsoleIn:
0497: E8AA CD 1E E9               CALL   ConIn                ; Don't come back without input
0498: E8AD CD 29 E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0499: E8B0 D8                     RET    C                    ; return nothing to echo
0500: E8B1
0501: E8B1 F5                     PUSH   AF                   ; Save printable character
0502: E8B2 4F                     LD     C,A
0503: E8B3 CD 55 E9               CALL   TabOut               ; Send to console. if TAB expand
0504: E8B6 F1                     POP    AF                   ; retrieve exit value
0505: E8B7
0506: E8B7 32 C2 EA               LD     (exitParameterByte),A
0507: E8BA C9                     RET
0508: E8BB
0509: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0510: E8BB         ;  This function outputs the data byte in register E to the console. As with ;
0511: E8BB         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0512: E8BB         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0513: E8BB         ; checks to see if there is an incoming character, and if there is,          ;
0514: E8BB         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0515: E8BB         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0516: E8BB         ; printer is  toggled on or off                                              ;
0517: E8BB         ;																			 ;
0518: E8BB         ;			Function Code	:	C = 02H                                      ;
0519: E8BB         ;			Entry Parameters:	E = Data byte to be output					 ;
0520: E8BB         ;			Exit Parameters :	None										 ;
0521: E8BB         ;																			 ;
0522: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0523: E8BB         ;BDOS put parameter in C before entering this routine
0524: E8BB             vConsoleOut:
0525: E8BB CD 55 E9               CALL   TabOut
0526: E8BE C9                     RET
0527: E8BF
0528: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0529: E8BF         ;   function reads the next character from the logical "reader" device into  ;
0530: E8BF         ; register A. In practice, the physical device that is accessed depends      ;
0531: E8BF         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0532: E8BF         ; reader at all; this function will return some arbitrary value such as lAH  ;
0533: E8BF         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0534: E8BF         ; Control is not returned to the calling program until a character has been  ;
0535: E8BF         ; read.                                                                      ;
0536: E8BF         ;                                                                            ;
0537: E8BF         ; This is a blocking function                                                ;
0538: E8BF         ;																			 ;
0539: E8BF         ;			Function Code	:	C = 03H                                      ;
0540: E8BF         ;			Entry Parameters:	None										 ;
0541: E8BF         ;			Exit Parameters :	A = Character Input							 ;
0542: E8BF         ;																			 ;
0543: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0544: E8BF             vReaderIn:
0545: E8BF CD 15 F6               CALL   bcReader
0546: E8C2 32 C2 EA               LD     (exitParameterWord),A
0547: E8C5 C9                     RET
0548: E8C6
0549: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0550: E8C6         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0551: E8C6         ; specified character from register E to the logical punch device. Again,    ;
0552: E8C6         ; the actual physical device used, if any, is determined by the BIOS.        ;
0553: E8C6         ; There is no set standard for this device; in some systems the punch        ;
0554: E8C6         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0555: E8C6         ; output to it.                                                              ;
0556: E8C6         ;																			 ;
0557: E8C6         ;			Function Code	:	C = 04H                                      ;
0558: E8C6         ;			Entry Parameters:	E = Data byte to be output					 ;
0559: E8C6         ;			Exit Parameters :	None										 ;
0560: E8C6         ;																			 ;
0561: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0562: E8C6         ;BDOS put parameter in C before entering this routine
0563: E8C6             vPunchOut:
0564: E8C6 CD 12 F6               CALL   bcPunch
0565: E8C9 C9                     RET
0566: E8CA
0567: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0568: E8CA         ;  This function outputs the specified byte in register E to the logical     ;
0569: E8CA         ; list device. As with the reader and the punch, the physical device used    ;
0570: E8CA         ; depends entirely on the BIOS.                                              ;
0571: E8CA         ;																			 ;
0572: E8CA         ;			Function Code	:	C = 05H                                      ;
0573: E8CA         ;			Entry Parameters:	E = Data byte to be output					 ;
0574: E8CA         ;			Exit Parameters :	None										 ;
0575: E8CA         ;																			 ;
0576: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0577: E8CA         ;BDOS put parameter in C before entering this routine
0578: E8CA             vListOut:                       ; func5 (05 - 05) List Output
0579: E8CA CD 0F F6               CALL   bcList               ; direct call to BIOS
0580: E8CD C9                     RET
0581: E8CE
0582: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0583: E8CE         ;  This function serves double duty: it both inputs and outputs characters   ;
0584: E8CE         ; from the console. However, it bypasses the normal control characters and   ;
0585: E8CE         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0586: E8CE         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0587: E8CE         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0588: E8CE         ; then E contains a valid ASCII character that is output to the console.     ;
0589: E8CE         ;  This function works well provided you never have to send a value ofOFFH   ;
0590: E8CE         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0591: E8CE         ; binary data, you cannot use this function, since these values are likely   ;
0592: E8CE         ; to be part of the data stream.                                             ;
0593: E8CE         ;                                                                            ;
0594: E8CE         ;			Function Code	:	C = 06H                                      ;
0595: E8CE         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0596: E8CE         ;								E = Other than 0FFH for Output				 ;
0597: E8CE         ;			Exit Parameters :	A = Input byte or status					 ;
0598: E8CE         ;																			 ;
0599: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0600: E8CE         ;BDOS put parameter in C before entering this routine
0601: E8CE             vDirectConIO:
0602: E8CE 79                     LD     A,C
0603: E8CF 3C                     INC    A
0604: E8D0 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0605: E8D2         ; send byte to console
0606: E8D2 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0607: E8D5 C9                     RET
0608: E8D6
0609: E8D6         ;read byte/status from console
0610: E8D6             vDirectConIO1:
0611: E8D6 CD 06 F6               CALL   bcConst              ; Check Status
0612: E8D9 B7                     OR     A                    ; 00 means not data ready
0613: E8DA CA 4A E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0614: E8DD CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0615: E8E0 32 C2 EA               LD     (exitParameterByte),A ; Save it
0616: E8E3 C9                     RET
0617: E8E4
0618: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0619: E8E4         ; This function places the current value of the IOBYTE in register A.        ;
0620: E8E4         ;                                                                            ;
0621: E8E4         ; The IOBYTE structure:                                                      ;
0622: E8E4         ;								+-------+-------+-------+-------+            ;
0623: E8E4         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0624: E8E4         ;								+-------+-------+-------+-------+            ;
0625: E8E4         ;				Logical Device     List | Punch | Reader|Console             ;
0626: E8E4         ;                                                                            ;
0627: E8E4         ;                                                                            ;
0628: E8E4         ;			Function Code	:	C = 07H                                      ;
0629: E8E4         ;			Entry Parameters:	None					  		  			 ;
0630: E8E4         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0631: E8E4         ;																			 ;
0632: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0633: E8E4             vGetIOBYTE:
0634: E8E4 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0635: E8E7 32 C2 EA               LD     (exitParameterWord),A ; Return it to caller
0636: E8EA C9                     RET
0637: E8EB         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0638: E8EB         ; This function sets the IOBYTE         									 ;
0639: E8EB         ;                                                                            ;
0640: E8EB         ; The IOBYTE structure:                                                      ;
0641: E8EB         ;								+-------+-------+-------+-------+            ;
0642: E8EB         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0643: E8EB         ;								+-------+-------+-------+-------+            ;
0644: E8EB         ;				Logical Device     List | Punch | Reader|Console             ;
0645: E8EB         ;                                                                            ;
0646: E8EB         ;                                                                            ;
0647: E8EB         ;			Function Code	:	C = 08H                                      ;
0648: E8EB         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0649: E8EB         ;			Exit Parameters :	None                                         ;
0650: E8EB         ;																			 ;
0651: E8EB         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0652: E8EB         ;BDOS put parameter in C before entering this routine
0653: E8EB             vSetIOBYTE:
0654: E8EB 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0655: E8EE 71                     LD     (HL),C               ; Place new vale in it
0656: E8EF C9                     RET
0657: E8F0
0658: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0659: E8F0         ;  This function outputs a string of characters to the console device. The   ;
0660: E8F0         ; address of this string is in registers DE. You must make sure that the last;
0661: E8F0         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0662: E8F0         ; for the end of the string.                                                 ;
0663: E8F0         ;  The "$" itself does not get output to the console.                        ;
0664: E8F0         ;                                                                            ;
0665: E8F0         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0666: E8F0         ; described, checks to see if there is an incoming character, and checks for ;
0667: E8F0         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0668: E8F0         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0669: E8F0         ; the printer).                                                              ;
0670: E8F0         ;                                                                            ;
0671: E8F0         ;			Function Code	:	C = 09H                                      ;
0672: E8F0         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0673: E8F0         ;			Exit Parameters :	None							             ;
0674: E8F0         ;																			 ;
0675: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0676: E8F0             vPrintString:
0677: E8F0 2A C0 EA               LD     HL,(paramDE)         ; Get address of the string
0678: E8F3 4D                     LD     C,L
0679: E8F4 44                     LD     B,H                  ; Put it into BC for call
0680: E8F5 CD 38 E9               CALL   Print                ; out to console
0681: E8F8 C9                     RET
0682: E8F9
0683: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0684: E8F9         ;  This function reads a string of characters from the console device        ;
0685: E8F9         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0686: E8F9         ; editing is possible: the operator can backspace, cancel the line and start ;
0687: E8F9         ; over, and use all the normal control functions. What you will ultimately   ;
0688: E8F9         ; see in the buffer is the final version of the character string entered,    ;
0689: E8F9         ; without any of the errors or control characters used to do the line editing;
0690: E8F9         ;                                                                            ;
0691: E8F9         ;  The buffer that you define has a special format. The first byte in the    ;
0692: E8F9         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0693: E8F9         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0694: E8F9         ; were actually placed in the buffer. The following bytes contain            ;
0695: E8F9         ; the characters of the string. Character input will cease either when a     ;
0696: E8F9         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0697: E8F9         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0698: E8F9         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0699: E8F9         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0700: E8F9         ; the "characters input" byte to O. If you attempt to input more than the    ;
0701: E8F9         ; maximum number of characters, the "characters input" count will be the     ;
0702: E8F9         ; same as the maximum value allowed.                                         ;
0703: E8F9         ;                                                                            ;
0704: E8F9         ;			Function Code	:	C = 0AH                                      ;
0705: E8F9         ;			Entry Parameters:	DE = Address string buffer					 ;
0706: E8F9         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0707: E8F9         ;																			 ;
0708: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0709: E8F9             vReadString:
0710: E8F9 CD DD E9               CALL   ReadString
0711: E8FC C9                     RET
0712: E8FD
0713: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0714: E8FD         ; This function tells you whether a console input character is waiting to be ;
0715: E8FD         ;processed. Unlike the Console Input functions, which will wait until there  ;
0716: E8FD         ;is input,this function simply checks and returns immediately.               ;
0717: E8FD         ;                                                                            ;
0718: E8FD         ;			Function Code	:	C = 0BH                                      ;
0719: E8FD         ;			Entry Parameters:	None										 ;
0720: E8FD         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0721: E8FD         ;								A = FFH	if incoming Data					 ;
0722: E8FD         ;																			 ;
0723: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0724: E8FD             vGetConsoleStatus:
0725: E8FD CD 89 E9               CALL   ConBreak
0726: E900 32 C2 EA               LD     (exitParameterByte),A
0727: E903 C9                     RET
0728: E904
0729: E904         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0730: E904         ;  This function tells you which version of CP/M you are currently running.  ;
0731: E904         ; A two-byte value is returned:                                              ;
0732: E904         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0733: E904         ;	L = OOH for all releases before CP/M 2.0                                 ;
0734: E904         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0735: E904         ;		and so on for any subsequent releases.                               ;
0736: E904         ;                                                                            ;
0737: E904         ; This information is of interest only if your program has some version      ;
0738: E904         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0739: E904         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0740: E904         ; Therefore, if your program uses Random I/O, put this check at the          ;
0741: E904         ; beginning to ensure that it is indeed running under the appropriate        ;
0742: E904         ; version of CP/M.                                                           ;
0743: E904         ;                                                                            ;
0744: E904         ;			Function Code	:	C = 0CH                                      ;
0745: E904         ;			Entry Parameters:	None										 ;
0746: E904         ;			Exit Parameters :	HL =Version Number Code						 ;
0747: E904         ;								A = FFH	if incoming Data					 ;
0748: E904         ;																			 ;
0749: E904         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0750: E904             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0751: E904 3E 20                  LD     A,VERSION
0752: E906 32 C2 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0753: E909 C9                     RET
0754: E90A
0755: E90A         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0756: E90A         ;  This subroutine either sets or gets the current user number. The current  ;
0757: E90A         ; user number determines which file directory entries are matched during all ;
0758: E90A         ; disk file operations. When you call this function, the contents of the     ;
0759: E90A         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0760: E90A         ; will return the current user number in the A register. If you set E to a   ;
0761: E90A         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0762: E90A         ; will set the current user number to this value.                            ;
0763: E90A         ;                                                                            ;
0764: E90A         ;			Function Code	:	C = 0CH                                      ;
0765: E90A         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0766: E90A         ;								  = 0 to 15 to set User Number				 ;
0767: E90A         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0768: E90A         ;								A = FFH	if incoming Data					 ;
0769: E90A         ;																			 ;
0770: E90A         ;                                                                            ;
0771: E90A         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0772: E90A             vGetSetUserNumber:
0773: E90A 3A BF EA               LD     A,(paramE)
0774: E90D FE FF                  CP     0FFH
0775: E90F 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0776: E911 3A 36 F5               LD     A,(currentUserNumber)
0777: E914 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0778: E917 C9                     RET
0779: E918
0780: E918             SetUserNumber:
0781: E918 E6 0F                  AND    LO_NIBBLE_MASK
0782: E91A 32 36 F5               LD     (currentUserNumber),A
0783: E91D C9                     RET
0784: E91E
0785: E91E         ;****************************************************************************;
0786: E91E         ;								Character Support Routines					 ;
0787: E91E         ;****************************************************************************;
0788: E91E
0789: E91E
0790: E91E         ;-------------------- Return a Character from the console -------------------;
0791: E91E         ;return byte from buffer or read from the console                            ;
0792: E91E             ConIn:                          ;
0793: E91E 21 BB EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0794: E921 7E                     LD     A,(HL)               ;
0795: E922 36 00                  LD     (HL),0               ;
0796: E924 B7                     OR     A                    ;
0797: E925 C0                     RET    NZ                   ;
0798: E926         ;
0799: E926 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0800: E929         ;-------------------- Return a Character from the console -------------------;
0801: E929
0802: E929         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0803: E929         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0804: E929             IsPrintableASCII:                      ;
0805: E929 FE 0D                  CP     CR                   ;
0806: E92B C8                     RET    Z                    ; carriage return?                                                  ;
0807: E92C FE 0A                  CP     LF                   ;
0808: E92E C8                     RET    Z                    ; line feed?                                                        ;
0809: E92F FE 09                  CP     TAB                  ;
0810: E931 C8                     RET    Z                    ; TAB?                                                              ;
0811: E932 FE 08                  CP     CTRL_H               ;
0812: E934 C8                     RET    Z                    ; backspace?                                                        ;
0813: E935 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0814: E937 C9                     RET                         ;
0815: E938         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0816: E938
0817: E938         ;------------------ Print character from (BC) until  $ found ----------------;
0818: E938             Print:                          ;
0819: E938 0A                     LD     A,(BC)               ; Get the next character             ;
0820: E939 FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0821: E93B C8                     RET    Z                    ;  exit if yes                       ;
0822: E93C 03                     INC    BC                   ; Update the pointer                 ;
0823: E93D C5                     PUSH   BC                   ; Save it                            ;
0824: E93E 4F                     LD     C,A                  ; Does Byte require                  ;
0825: E93F CD 55 E9               CALL   TabOut               ;  special attention - check         ;
0826: E942 C1                     POP    BC                   ; Retrieve the pointer				 ;
0827: E943 18 F3                  JR     Print                ; Loop back                          ;
0828: E945         ;------------------ Print character from (BC) until  $ found ----------------;
0829: E945
0830: E945         ;-- Send printable character to console. Precede with Caret if needed -------;
0831: E945         ; character is in Reg C                                                      ;
0832: E945             CaretOut:                       ;
0833: E945 79                     LD     A,C                  ;
0834: E946 CD 29 E9               CALL   IsPrintableASCII     ;
0835: E949 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0836: E94B         ; send preceding up arrow                                                    ;
0837: E94B F5                     PUSH   AF                   ; Save the character                 ;
0838: E94C 0E 5E                  LD     C,CARET              ;
0839: E94E CD 68 E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0840: E951 F1                     POP    AF                   ; Get the character                  ;
0841: E952 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0842: E954 4F                     LD     C,A                  ; Set up to print                    ;
0843: E955         ; fall thru to TabbOut                                                       ;
0844: E955         ;-- Send printable character to console. Precede with Caret if needed -------;
0845: E955
0846: E955         ;------------- Send printable character to console. Expand if TAB -----------;
0847: E955         ; character is in Reg C                                                      ;
0848: E955             TabOut:                         ;
0849: E955 79                     LD     A,C                  ;
0850: E956 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0851: E958 C2 68 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0852: E95B         ;
0853: E95B         ; TAB encountered                                                           ;
0854: E95B             TabOut0:                        ;
0855: E95B 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0856: E95D CD 68 E9               CALL   ConsoleOut           ; Send to Console                    ;
0857: E960 3A BE EA               LD     A,(columnPosition)   ; Get Column position                ;
0858: E963 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0859: E965 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0860: E967 C9                     RET                         ;
0861: E968         ;------------- Send printable character to console. Expand if TAB -----------;
0862: E968
0863: E968         ;-------------------------- Send character to console -----------------------;
0864: E968         ; C  = Character to be output                                                ;
0865: E968             ConsoleOut:                      ;
0866: E968         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0867: E968 C5                     PUSH   BC                   ; Save character and Count           ;
0868: E969 CD 89 E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0869: E96C C1                     POP    BC                   ;
0870: E96D C5                     PUSH   BC                   ; Get/save character                 ;
0871: E96E         ; Send character to Console	                                                 ;
0872: E96E CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0873: E971 C1                     POP    BC                   ;
0874: E972 C5                     PUSH   BC                   ; Get/save character                 ;
0875: E973         ; is the data to be output to print device?                                  ;
0876: E973 3A BC EA               LD     A,(printEchoFlag)    ;
0877: E976 B7                     OR     A                    ;
0878: E977 C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0879: E97A C1                     POP    BC                   ; Get the character                  ;
0880: E97B         ;
0881: E97B 79                     LD     A,C                  ; Put character to ACC               ;
0882: E97C 21 BE EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0883: E97F 34                     INC    M                    ; increment the ColumnPosition       ;
0884: E980         ;
0885: E980 FE 20                  CP     SPACE                ;
0886: E982 D0                     RET    NC                   ; Exit if ASCII printable            ;
0887: E983         ;
0888: E983 FE 0A                  CP     LF                   ;
0889: E985 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0890: E986         ;
0891: E986 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0892: E988 C9                     RET                         ;
0893: E989         ;-------------------------- Send character to console -----------------------;
0894: E989
0895: E989         ;--------------------  Check for Status and Control S or C ------------------;
0896: E989         ;  Returns:																	 ;
0897: E989         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0898: E989         ;			ACC = 00   No data Pending										 ;
0899: E989         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0900: E989         ;                                                                            ;
0901: E989             ConBreak:                       ;
0902: E989 3A BB EA               LD     A,(keyboardByte)     ;
0903: E98C B7                     OR     A                    ; If there is a char waiting         ;
0904: E98D 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0905: E98F         ;
0906: E98F CD 06 F6               CALL   bcConst              ; Get status                         ;
0907: E992 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0908: E994 C8                     RET    Z                    ; Return 00 No data pending          ;
0909: E995         ;
0910: E995 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0911: E998         ;
0912: E998 FE 10                  CP     CTRL_P               ;
0913: E99A 20 0D                  JR     NZ,CheckCTL_S        ;
0914: E99C         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0915: E99C 21 BC EA               LD     HL,printEchoFlag     ;
0916: E99F 3E FF                  LD     A,TRUE               ;
0917: E9A1 BE                     CP     (HL)                 ;
0918: E9A2 20 02                  JR     NZ,ToggleFlag1       ;
0919: E9A4 3E 00                  LD     A,FALSE              ;
0920: E9A6             ToggleFlag1:                      ;
0921: E9A6 77                     LD     (HL),A               ;
0922: E9A7 18 0C                  JR     NothingWaiting       ;
0923: E9A9         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0924: E9A9             CheckCTL_S:                      ;
0925: E9A9 FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0926: E9AB 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0927: E9AD         ;
0928: E9AD CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0929: E9B0 FE 03                  CP     CTRL_C               ;
0930: E9B2 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0931: E9B5             NothingWaiting:                      ;
0932: E9B5 AF                     XOR    A                    ;
0933: E9B6 C9                     RET                         ; Set ACC = 0 and return             ;
0934: E9B7             ConBreak0:                      ;
0935: E9B7 32 BB EA               LD     (keyboardByte),A     ; save the byte                      ;
0936: E9BA             ConBreak1:                      ;
0937: E9BA 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0938: E9BC C9                     RET                         ;
0939: E9BD         ;--------------------  Check for Status and Control S or C ------------------;
0940: E9BD
0941: E9BD         ;------------------------  Console Output Utilities -------------------------;
0942: E9BD             showHashCRLF:                      ;
0943: E9BD 0E 23                  LD     C,HASH_TAG           ;
0944: E9BF CD 68 E9               CALL   ConsoleOut           ; Send # to console                  ;
0945: E9C2 CD D3 E9               CALL   showCRLF             ;
0946: E9C5             showHashCRLF1:                      ;
0947: E9C5 3E BE                  LD     A,columnPosition     ;
0948: E9C7 21 BD EA               LD     HL,startingColumn    ;
0949: E9CA BF                     CP     A,M                  ;
0950: E9CB D0                     RET    NC                   ;
0951: E9CC 0E 20                  LD     C,SPACE              ;
0952: E9CE CD 68 E9               CALL   ConsoleOut           ;
0953: E9D1 18 F2                  JR     showHashCRLF1        ;
0954: E9D3         ;------------------------  Console Output Utilities -------------------------;
0955: E9D3
0956: E9D3         ;------------------------  Send Carriage Return and Line Feed ---------------;
0957: E9D3             showCRLF:                       ;
0958: E9D3 0E 0D                  LD     C,CR                 ;
0959: E9D5 CD 68 E9               CALL   ConsoleOut           ;
0960: E9D8 0E 0A                  LD     C,LF                 ;
0961: E9DA C3 68 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0962: E9DD         ;------------------------  Send Carriage Return and Line Feed ---------------;
0963: E9DD
0964: E9DD         ;------------------------- Read a $ terminated String -----------------------;
0965: E9DD         ;read to paramDE address (max length, current length, buffer)               ;
0966: E9DD             ReadString:                      ;
0967: E9DD 3A BE EA               LD     A,(columnPosition)   ;
0968: E9E0 32 BD EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0969: E9E3 2A C0 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0970: E9E6 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0971: E9E7 23                     INC    HL                   ; Point at actual bytes read         ;
0972: E9E8 06 00                  LD     B,0                  ; Initialize Current Count           ;
0973: E9EA         ;
0974: E9EA         ; B = Current Count                                                      ;
0975: E9EA         ; C = Maximum characters                                                 ;
0976: E9EA         ; HL= Insertion Pointer                                                  ;
0977: E9EA         ;
0978: E9EA         ; read next character, BC, HL active                                        ;
0979: E9EA             ReadNext:                       ;
0980: E9EA C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0981: E9EB E5                     PUSH   HL                   ; Save pointer                       ;
0982: E9EC             ReadNext0:                      ;
0983: E9EC CD 1E E9               CALL   ConIn                ; Get the next Character             ;
0984: E9EF E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0985: E9F1 E1                     POP    HL                   ; Restore Pointer					 ;
0986: E9F2 C1                     POP    BC                   ; Restore Current Index and Max Count;
0987: E9F3         ;Is It Carriage Return                                                       ;
0988: E9F3 FE 0D                  CP     CR                   ;
0989: E9F5 CA 3B EA               JP     Z,EndRead            ; End the read if yes                ;
0990: E9F8 FE 0A                  CP     LF                   ;
0991: E9FA         ;Is It Linefeed                                                              ;
0992: E9FA CA 3B EA               JP     Z,EndRead            ; End the read if yes                ;
0993: E9FD         ;Is It BackSpace                                                             ;
0994: E9FD FE 08                  CP     CTRL_H               ;
0995: E9FF CA 45 EA               JP     Z,BSspaceBS          ;
0996: EA02             IsItRubout:                      ;
0997: EA02 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
0998: EA04 CA 4F EA               JP     Z,ItIsRubout         ;
0999: EA07             IsPhysicalEOL:                      ;
1000: EA07 FE 05                  CP     CTRL_E               ;
1001: EA09 CA 5A EA               JP     Z,ItIsPhysicalEOL    ;
1002: EA0C             IsItPrintToggle:                      ;
1003: EA0C FE 10                  CP     CTRL_P               ;
1004: EA0E CA 62 EA               JP     Z,ItIsPrintToggle    ;
1005: EA11             IsItDeleteTheLineX:                      ;
1006: EA11 FE 18                  CP     CTRL_X               ;
1007: EA13 CA 8B EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1008: EA16             IsItDeleteTheLineU:                      ;
1009: EA16 FE 15                  CP     CTRL_U               ;
1010: EA18 CA A9 EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1011: EA1B         ;Retype the line                                                             ;
1012: EA1B FE 12                  CP     CTRL_R               ;
1013: EA1D CA 72 EA               JP     Z,RepeatLine         ;
1014: EA20
1015: EA20         ;....................... Echo input back to the Console  ....................;
1016: EA20         ; Full Duplex								                                 ;
1017: EA20         ; A = Character to display	                                                 ;
1018: EA20         ; B = current char count                                                     ;
1019: EA20         ; C = maximum buffer length                                                  ;
1020: EA20         ; HL= buffer pointer                                                         ;
1021: EA20         ;ReadEcho                                                                    ;
1022: EA20 04                     INC    B                    ; Increment byte count		         ;
1023: EA21 23                     INC    HL                   ; Advance the Pointer                ;
1024: EA22 77                     LD     (HL),A               ; Put char in buffer                 ;
1025: EA23         ;
1026: EA23             ReadEchoRubOut:                      ;
1027: EA23 C5                     PUSH   BC                   ; Save index and length              ;
1028: EA24 E5                     PUSH   HL                   ; Save the Pointer                   ;
1029: EA25 4F                     LD     C,A                  ; Get char                           ;
1030: EA26 CD 45 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1031: EA29 E1                     POP    HL                   ; Restore the Pointer                ;
1032: EA2A C1                     POP    BC                   ; Restore index and length           ;
1033: EA2B 7E                     LD     A,(HL)               ; Recall char                        ;
1034: EA2C         ; check for Warm Boot                                                        ;
1035: EA2C FE 03                  CP     CTRL_C               ;
1036: EA2E 78                     LD     A,B                  ; Get Line position                  ;
1037: EA2F C2 37 EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1038: EA32 FE 01                  CP     1                    ; Beginning of the Line?             ;
1039: EA34 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1040: EA37         ; Check to see if we are at the end of the buffer                            ;
1041: EA37             AreWeAtEndOfBuffer:                      ;
1042: EA37 B9                     CP     C                    ; Over Max ?					     ;
1043: EA38 DA EA E9               JP     C,ReadNext           ;  no, Go for more				     ;
1044: EA3B         ;
1045: EA3B         ; At the end of read                                  					     ;
1046: EA3B             EndRead:                        ;
1047: EA3B         ; 	POP		HL                                                               ;
1048: EA3B 2A C0 EA               LD     HL,(paramDE)         ;
1049: EA3E 23                     INC    HL                   ;
1050: EA3F         ;
1051: EA3F 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1052: EA40 0E 0D                  LD     C,CR                 ;
1053: EA42 C3 68 E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1054: EA45         ;....................... Echo input back to the Console  ....................;
1055: EA45         ;.......................... Backspace SPACE BackSpace .......................;
1056: EA45             BSspaceBS:                      ;
1057: EA45 05                     DEC    B                    ;
1058: EA46 2B                     DEC    HL                   ;
1059: EA47 C5                     PUSH   BC                   ;
1060: EA48 E5                     PUSH   HL                   ;
1061: EA49 CD 9C EA               CALL   BackUp               ;
1062: EA4C C3 EC E9               JP     ReadNext0            ;
1063: EA4F         ;.......................... Backspace SPACE BackSpace .......................;
1064: EA4F         ;.......................... It is RubOut ....................................;
1065: EA4F             ItIsRubout:                      ;
1066: EA4F         ; RUBOUT if possible                                                         ;
1067: EA4F 78                     LD     A,B                  ; Are we at the start of the line    ;
1068: EA50 B7                     OR     A                    ;
1069: EA51 CA EA E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1070: EA54         ;adjust pointers back one                                                    ;
1071: EA54 7E                     LD     A,(HL)               ; ACC = current character            ;
1072: EA55 05                     DEC    B                    ; Adjust the index			    	 ;
1073: EA56 2B                     DEC    HL                   ; Adjust the pointer                 ;
1074: EA57 C3 23 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1075: EA5A         ;.......................... It is RubOut ....................................;
1076: EA5A         ;.......................... It is PhysicalEOL ...............................;
1077: EA5A             ItIsPhysicalEOL:                      ;
1078: EA5A C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1079: EA5B E5                     PUSH   HL                   ; Save pointer                       ;
1080: EA5C CD D3 E9               CALL   showCRLF             ; Make new line                      ;
1081: EA5F C3 EC E9               JP     ReadNext0            ;   and go for next char   			 ;
1082: EA62         ;.......................... It is PhysicalEOL ...............................;
1083: EA62         ;.......................... It is PrintToggle ...............................;
1084: EA62             ItIsPrintToggle:
1085: EA62 E5                     PUSH   HL                   ; Save pointer                       ;
1086: EA63         ; Toggle the printEcho Flag                                                  ;
1087: EA63 21 BC EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1088: EA66 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1089: EA68 BE                     CP     (HL)                 ; Is the flag true?                  ;
1090: EA69 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1091: EA6B 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1092: EA6D             IsItPrintToggle1:                      ;
1093: EA6D 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1094: EA6E E1                     POP    HL                   ; Restore pointer                    ;
1095: EA6F C3 EA E9               JP     ReadNext             ;   and for another char             ;
1096: EA72         ;.......................... It is PrintToggle ...............................;
1097: EA72         ;.......................... RepeatLine ......................................;
1098: EA72             RepeatLine:                      ;
1099: EA72 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1100: EA73 E5                     PUSH   HL                   ;  for exit                          ;
1101: EA74 CD BD E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1102: EA77         ;
1103: EA77 2A C0 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1104: EA7A 23                     INC    HL                   ; Skip past character count          ;
1105: EA7B         ;
1106: EA7B             LL1:                            ;
1107: EA7B 23                     INC    HL                   ; Point at next char to display      ;
1108: EA7C C5                     PUSH   BC                   ; Save counter, in B                 ;
1109: EA7D E5                     PUSH   HL                   ; Save buffer pointer                ;
1110: EA7E 4E                     LD     C,M                  ; Get the next character             ;
1111: EA7F CD 45 E9               CALL   CaretOut             ; Display it                         ;
1112: EA82 E1                     POP    HL                   ; Restore                            ;
1113: EA83 C1                     POP    BC                   ;  the counter and pointer           ;
1114: EA84 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1115: EA86 E1                     POP    HL                   ; Restore values                     ;
1116: EA87 C1                     POP    BC                   ;  from routine entry                ;
1117: EA88 C3 EA E9               JP     ReadNext             ; Done here !                        ;
1118: EA8B         ;.......................... RepeatLine ......................................;
1119: EA8B         ;.......................... Delete The Line .................................;
1120: EA8B             DeleteTheLine:                      ;
1121: EA8B E1                     POP    HL                   ; Adjust Stack                       ;
1122: EA8C         ;                                             ;
1123: EA8C             DeleteTheLine1:                      ;
1124: EA8C 3A BD EA               LD     A,(startingColumn)   ;
1125: EA8F 21 BE EA               LD     HL,columnPosition    ;
1126: EA92 BE                     CP     M                    ; Start of line ?                    ;
1127: EA93 D2 DD E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1128: EA96 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1129: EA97 CD 9C EA               CALL   BackUp               ; Clear 1 column                     ;
1130: EA9A 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1131: EA9C         ;.......................... Delete The Line .................................;
1132: EA9C         ;------------------------ Back-up one screen position -----------------------;
1133: EA9C             BackUp:                         ;
1134: EA9C CD A4 EA               CALL   BackUp1              ; Send Backspace                     ;
1135: EA9F 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1136: EAA1 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1137: EAA4         ;does not affect column count                                                ;
1138: EAA4             BackUp1:                        ;
1139: EAA4 0E 08                  LD     C,CTRL_H             ;
1140: EAA6 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1141: EAA9         ;------------------------ Back-up one screen position -----------------------;
1142: EAA9         ;.......................... Ignore The Line .................................;
1143: EAA9             IgnoreTheLine:                      ;
1144: EAA9 CD BD E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1145: EAAC 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1146: EAAE CD 0C F6               CALL   bcConout             ;  to the console                    ;
1147: EAB1 0E 20                  LD     C,SPACE              ;
1148: EAB3 CD 0C F6               CALL   bcConout             ;
1149: EAB6 C3 DD E9               JP     ReadString           ; Start all over                     ;
1150: EAB9         ;.......................... Ignore The Line .................................;
1151: EAB9
1152: EAB9         ;------------------------- Read a $ terminated String -----------------------;
1153: EAB9
1154: EAB9         ;****************************************************************************
1155: EAB9         ;                           DATA AREA                                       *
1156: EAB9         ;****************************************************************************
1157: EAB9
1158: EAB9         ;------------------------------Non Disk Data Area ---------------------------;
1159: EAB9             usersStack: DS     2                    ; entry stack pointer                ;
1160: EABB         ;
1161: EABB 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1162: EABC         ;
1163: EABC 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1164: EABD         ;
1165: EABD         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1166: EABD 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1167: EABE 00          columnPosition: DB     0                    ; Current Column position            ;
1168: EABF         ;
1169: EABF             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1170: EAC0             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1171: EAC2             exitParameterByte:                      ; Byte returned Value                ;
1172: EAC2             exitParameterWord: DS     WORD                 ; Word                           ;
1173: EAC4         ;
1174: EAC4         ;
1175: EAC4         ;------------------------------------ Data Area -----------------------------;
1176: EAC4
1177: EAC4
1178: EAC4
1179: EAC4         ;****************************************************************************;
1180: EAC4         ;								Disk I/O									 ;
1181: EAC4         ;****************************************************************************;
1182: EAC4
1183: EAC4         ;---------------------------- Reset Disk System - D (13) --------------------;
1184: EAC4         ;  This function requests CP/M to completely reset the disk file system.     ;
1185: EAC4         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1186: EAC4         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1187: EAC4         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1188: EAC4         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1189: EAC4         ; in each logical disk as each disk is accessed. This involves reading the   ;
1190: EAC4         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1191: EAC4         ; which keep track of which allocation blocks are free and which             ;
1192: EAC4         ; are used for file storage.                                                 ;
1193: EAC4         ;                                                                            ;
1194: EAC4         ;			Function Code	:	C = 0DH                                      ;
1195: EAC4         ;			Entry Parameters:	None										 ;
1196: EAC4         ;			Exit Parameters :	None										 ;
1197: EAC4         ;																			 ;
1198: EAC4         ;---------------------------- Reset Disk System - D (13) --------------------;
1199: EAC4             vResetSystem:
1200: EAC4 21 00 00               LD     HL,0
1201: EAC7 22 39 F5               LD     (ReadOnlyVector),HL  ; Clear the vectors for
1202: EACA 22 3B F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1203: EACD AF                     XOR    A                    ; Clear the current disk
1204: EACE 32 37 F5               LD     (currentDisk),A
1205: EAD1         ; note that currentUserNumber remains unchanged
1206: EAD1 21 80 00               LD     HL,DMABuffer
1207: EAD4 22 3D F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = DMABuffer
1208: EAD7 CD CE ED               CALL   SetDataDMA           ; to data dma address
1209: EADA C3 5B EC               JP     Select
1210: EADD         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1211: EADD         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1212: EADD         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1213: EADD         ; This function returns a bit map, called the login vector, in register pair ;
1214: EADD         ; HL, indicating which logical disk drives have been selected since the last ;
1215: EADD         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1216: EADD         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1217: EADD         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1218: EADD         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1219: EADD         ;  Logical disks can be selected programmatically through any file operation ;
1220: EADD         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1221: EADD         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1222: EADD         ; where "X" is equal to A, B, ... , P.                                       ;
1223: EADD         ;                                                                            ;
1224: EADD         ;			Function Code	:	C = 018H                                     ;
1225: EADD         ;			Entry Parameters:	None										 ;
1226: EADD         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1227: EADD         ;																			 ;
1228: EADD         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1229: EADD             vGetLoginVector:
1230: EADD 2A 3B F5               LD     HL,(loggedDisks)
1231: EAE0 22 C2 EA               LD     (exitParameterWord),HL
1232: EAE3 C9                     RET
1233: EAE4         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1234: EAE4         ;   This function returns the current default disk set by the last Select    ;
1235: EAE4         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1236: EAE4         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1237: EAE4         ;                                                                            ;
1238: EAE4         ;  This function returns the current default disk in coded form.             ;
1239: EAE4         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1240: EAE4         ; If you need to convert this to the corresponding ASCII character, simply   ;
1241: EAE4         ; add 41H to register A. Use this function when you convert a file name and  ;
1242: EAE4         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1243: EAE4         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1244: EAE4         ; You must therefore use this function to determine the logical disk letter  ;
1245: EAE4         ; for the default drive.                                                     ;
1246: EAE4         ;                                                                            ;
1247: EAE4         ;			Function Code	:	C = 019H                                     ;
1248: EAE4         ;			Entry Parameters:	None										 ;
1249: EAE4         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1250: EAE4         ;																			 ;
1251: EAE4         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1252: EAE4             vGetCurrentDisk:
1253: EAE4 3A 37 F5               LD     A,(currentDisk)
1254: EAE7 32 C2 EA               LD     (exitParameterByte),A
1255: EAEA C9                     RET
1256: EAEB         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1257: EAEB         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1258: EAEB         ; value. The name is an historic relic dating back to the Intel Development  ;
1259: EAEB         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1260: EAEB         ; its hardware, could read data from a diskette directly into memory or      ;
1261: EAEB         ; write data to a diskette directly from memory. The name DMA address now    ;
1262: EAEB         ; applies to the address of the buffer to and from which data is             ;
1263: EAEB         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1264: EAEB         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1265: EAEB         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1266: EAEB         ; value of 0080H.                                                            ;
1267: EAEB         ;                                                                            ;
1268: EAEB         ;			Function Code	:	C = 0A9H                                     ;
1269: EAEB         ;			Entry Parameters:	DE = DMA Address							 ;
1270: EAEB         ;			Exit Parameters :	None										 ;
1271: EAEB         ;																			 ;
1272: EAEB         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1273: EAEB             vSetDMA:
1274: EAEB 2A C0 EA               LD     HL,(paramDE)
1275: EAEE 22 3D F5               LD     (InitDAMAddress),HL
1276: EAF1 C3 CE ED               JP     SetDataDMA
1277: EAF4         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1278: EAF4         ;  This function returns the base, or starting, address of the allocation    ;
1279: EAF4         ; vector for the currently selected logical disk. This information,          ;
1280: EAF4         ; indicating which parts of the disk are assigned, is used by utility        ;
1281: EAF4         ; programs and the BDOS itself to determine how much unused space is on the  ;
1282: EAF4         ; logical disk, to locate an unused allocation block in order to extend      ;
1283: EAF4         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1284: EAF4         ;                                                                            ;
1285: EAF4         ;			Function Code	:	C = 01BH                                     ;
1286: EAF4         ;			Entry Parameters:	None										 ;
1287: EAF4         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1288: EAF4         ;																			 ;
1289: EAF4         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1290: EAF4             vGetAllocAddr:
1291: EAF4 2A 4B F5               LD     HL,(caAllocVector)
1292: EAF7 22 C2 EA               LD     (exitParameterWord),HL
1293: EAFA C9                     RET
1294: EAFB         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1295: EAFB         ;  This function returns a bit map in registers H and L showing which logical;
1296: EAFB         ; disks in the system have been set to Read-Only status, either by the       ;
1297: EAFB         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1298: EAFB         ; BDOS itself, because it detected that a diskette had been changed.         ;
1299: EAFB         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1300: EAFB         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1301: EAFB         ; the specific logical disk is set to I if the disk has been set to          ;
1302: EAFB         ; Read-Only status.                                                          ;
1303: EAFB         ;                                                                            ;
1304: EAFB         ;			Function Code	:	C = 0DBH                                     ;
1305: EAFB         ;			Entry Parameters:	None										 ;
1306: EAFB         ;			Exit Parameters :	HL = Read-Only Map							 ;
1307: EAFB         ;																			 ;
1308: EAFB         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1309: EAFB             vGetReadOnlyMap:
1310: EAFB 2A 39 F5               LD     HL,(ReadOnlyVector)
1311: EAFE 22 C2 EA               LD     (exitParameterWord),HL
1312: EB01 C9                     RET
1313: EB02         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1314: EB02         ;  This function returns the address of the disk parameter block (DPB) for   ;
1315: EB02         ; the last selected logical disk. The DPB describes the physical             ;
1316: EB02         ; characteristics of a specific logical disk-information mainly of interest  ;
1317: EB02         ; for system utility programs.                                               ;
1318: EB02         ;                                                                            ;
1319: EB02         ;			Function Code	:	C = 1FH                                     ;
1320: EB02         ;			Entry Parameters:	None										 ;
1321: EB02         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1322: EB02         ;																			 ;
1323: EB02         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1324: EB02             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1325: EB02 2A 47 F5               LD     HL,(caDiskParamBlock)
1326: EB05 22 C2 EA               LD     (exitParameterWord),HL
1327: EB08 C9                     RET
1328: EB09
1329: EB09         ;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
1330: EB09         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1331: EB09         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1332: EB09         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1333: EB09
1334: EB09         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1335: EB09         ;  This function resets individual disk drives. It is a more precise version ;
1336: EB09         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1337: EB09         ; specific logical; disks rather than all of them.                           ;
1338: EB09         ;  The bit map in DE shows which disks are to be reset. The least significant;
1339: EB09         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1340: EB09         ; The bits set to I indicate the disks to be reset.                          ;
1341: EB09         ;  Note that this function returns a zero value in A in order to maintain    ;
1342: EB09         ; compatibility with MP/ M.                                                  ;
1343: EB09         ;                                                                            ;
1344: EB09         ;			Function Code	:	C = 25H                                      ;
1345: EB09         ;			Entry Parameters:	DE = Logical Drive Bit Map					 ;
1346: EB09         ;			Exit Parameters :	A = 00H										 ;
1347: EB09         ;																			 ;
1348: EB09         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1349: EB09         ;Reset Drive
1350: EB09         ;IN  - (DE) Drive Vector
1351: EB09         ;OUT - (A) 00
1352: EB09             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1353: EB09         ; Not Yet Implemented   **************
1354: EB09 C9                     RET
1355: EB0A         ;*****************************************************************
1356: EB0A
1357: EB0A         ;-----------------------------------------------------------------
1358: EB0A         ;select disk in (E) paramDE
1359: EB0A         ; IN - (E) disk number -- 0=A  1=B ...15=P
1360: EB0A             vSelectDisk:                      ; func14 (14 - 0E)	Select Current Disk
1361: EB0A C3 4F EC               JP     SelectCurrent
1362: EB0D         ;ret ;jmp goba
1363: EB0D
1364: EB0D
1365: EB0D         ;*****************************************************************
1366: EB0D         ;random disk read
1367: EB0D         ;IN  - (DE) FCB address
1368: EB0D         ;OUT - (A) 01 = Reading unwritten data
1369: EB0D         ;	 02 = N/U
1370: EB0D         ;	 03 = Cannot close current extent
1371: EB0D         ;	 04 = Seek to unwriten Extent
1372: EB0D         ;	 05 = N/U
1373: EB0D         ;	 06 = Seek past Physical end of Disk
1374: EB0D             vReadRandom:                      ; func33 (33 - 21) Read Random record
1375: EB0D CD C9 F2               CALL   Reselect
1376: EB10 C3 24 EB               JP     RandomDiskRead       ; to perform the disk read
1377: EB13         ;*****************************************************************
1378: EB13         ;write random record
1379: EB13         ;IN  - (DE) FCB address
1380: EB13         ;OUT - (A) 01 = Reading unwritten data
1381: EB13         ;	 02 = N/U
1382: EB13         ;	 03 = Cannot close current extent
1383: EB13         ;	 04 = Seek to unwriten Extent
1384: EB13         ;	 05 = Cannot create new Extent because of directory overflow
1385: EB13         ;	 06 = Seek past Physical end of Disk
1386: EB13             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1387: EB13 CD C9 F2               CALL   Reselect
1388: EB16 C3 2D EB               JP     RandomDiskWrite      ; to perform the disk write
1389: EB19         ;ret ;jmp goback
1390: EB19         ;*****************************************************************
1391: EB19         ;return file size (0-65536)
1392: EB19         ;IN  - (DE) FCB address
1393: EB19             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1394: EB19 CD C9 F2               CALL   Reselect
1395: EB1C C3 DA EB               JP     GetFileSize
1396: EB1F         ;*****************************************************************
1397: EB1F         ;set random record
1398: EB1F         ;IN  - (DE) FCB address
1399: EB1F         ;OUT - Random Record Field is set
1400: EB1F             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1401: EB1F C3 C7 EB               JP     SetRandomRecord
1402: EB22         ;*****************************************************************
1403: EB22         ;Reset Drive
1404: EB22         ;IN  - (DE) Drive Vector
1405: EB22         ;OUT - (A) 00
1406: EB22             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1407: EB22         ; Not Yet Implemented   **************
1408: EB22 C9                     RET
1409: EB23         ;*****************************************************************
1410: EB23         ;*****************************************************************
1411: EB23         ;Write Random With Zero Fill
1412: EB23         ;IN  - (DE) FCB address
1413: EB23         ;OUT - (A) Return Code		see Function 34
1414: EB23             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1415: EB23         ; Not Yet Implemented   **************
1416: EB23 C9                     RET
1417: EB24         ;*****************************************************************
1418: EB24         ;******************< Random I/O Stuff ****************************
1419: EB24         ;*****************************************************************
1420: EB24         ;random disk read
1421: EB24             RandomDiskRead:                      ; randiskread
1422: EB24 0E FF                  LD     C,TRUE               ; marked as read operation
1423: EB26 CD 36 EB               CALL   RandomSeek
1424: EB29 CC BB EF               CALL   Z,DiskRead           ; if seek successful
1425: EB2C C9                     RET
1426: EB2D         ;*****************************************************************
1427: EB2D         ;random disk write
1428: EB2D             RandomDiskWrite:                      ; randiskwrite
1429: EB2D 0E 00                  LD     C,FALSE              ; marked as read operation
1430: EB2F CD 36 EB               CALL   RandomSeek
1431: EB32 CC FE EF               CALL   Z,DiskWrite          ; if seek successful
1432: EB35 C9                     RET
1433: EB36         ;*****************************************************************
1434: EB36         ;*****************************************************************
1435: EB36         ;random access seek operation, C=0ffh if read mode
1436: EB36         ;fcb is assumed to address an active file control block
1437: EB36         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1438: EB36             RandomSeek:
1439: EB36 AF                     XOR    A
1440: EB37 32 61 F5               LD     (seqReadFlag),A      ; marked as random access operation
1441: EB3A C5                     PUSH   BC                   ; save r/w flag
1442: EB3B 2A C0 EA               LD     HL,(paramDE)
1443: EB3E EB                     EX     DE,HL                ; DE will hold base of fcb
1444: EB3F 21 21 00               LD     HL,RANDOM_REC_FIELD
1445: EB42 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1446: EB43 7E                     LD     A,(HL)
1447: EB44 E6 7F                  AND    7FH
1448: EB46 F5                     PUSH   AF                   ; record number
1449: EB47 7E                     LD     A,(HL)
1450: EB48 17                     RLA                         ; cy=lsb of extent#
1451: EB49 23                     INC    HL
1452: EB4A 7E                     LD     A,(HL)
1453: EB4B 17                     RLA
1454: EB4C E6 1F                  AND    11111B               ; A=ext#
1455: EB4E 4F                     LD     C,A                  ; C holds extent number, record stacked
1456: EB4F 7E                     LD     A,(HL)
1457: EB50 1F                     RRA
1458: EB51 1F                     RRA
1459: EB52 1F                     RRA
1460: EB53 1F                     RRA
1461: EB54 E6 0F                  AND    1111B                ; mod#
1462: EB56 47                     LD     B,A                  ; B holds module#, C holds ext#
1463: EB57 F1                     POP    AF                   ; recall sought record #
1464: EB58         ;check to insure that high byte of ran rec = 00
1465: EB58 23                     INC    HL
1466: EB59 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1467: EB5A 2C                     INC    L
1468: EB5B 2D                     DEC    L
1469: EB5C 2E 06                  LD     L,06                 ; zero flag, l=6
1470: EB5E         ; produce error 6, seek past physical eod
1471: EB5E C2 BF EB               JP     NZ,RandomSeekError
1472: EB61         ; otherwise, high byte = 0, A = sought record
1473: EB61 21 20 00               LD     HL,NEXT_RECORD
1474: EB64 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1475: EB65 77                     LD     (HL),A               ; sought rec# stored away
1476: EB66         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1477: EB66         ; the r/w flag is still stacked.  compare fcb values
1478: EB66 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1479: EB69 19                     ADD    HL,DE
1480: EB6A 79                     LD     A,C                  ; A=seek ext#
1481: EB6B 96                     SUB    M
1482: EB6C C2 7A EB               JP     NZ,RandomSeekClose   ; tests for = extents
1483: EB6F         ; extents match, check mod#
1484: EB6F 21 0E 00               LD     HL,fcbS2Index
1485: EB72 19                     ADD    HL,DE
1486: EB73 78                     LD     A,B                  ; B=seek mod#
1487: EB74         ; could be overflow at eof, producing module#
1488: EB74         ; of 90H or 10H, so compare all but fwf
1489: EB74 96                     SUB    M
1490: EB75 E6 7F                  AND    7FH
1491: EB77 CA B2 EB               JP     Z,RandomSeekExit     ; same?
1492: EB7A             RandomSeekClose:
1493: EB7A C5                     PUSH   BC
1494: EB7B D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1495: EB7C CD 9E F1               CALL   CloseDirEntry        ; current extent closed
1496: EB7F D1                     POP    DE
1497: EB80 C1                     POP    BC                   ; recall parameters and fill
1498: EB81 2E 03                  LD     L,03                 ; cannot close error #3
1499: EB83 3A C2 EA               LD     A,(exitParameterByte)
1500: EB86 3C                     INC    A
1501: EB87 CA B8 EB               JP     Z,RandomSeekErrorBadSeek
1502: EB8A 21 0C 00               LD     HL,fcbExtIndex
1503: EB8D 19                     ADD    HL,DE
1504: EB8E 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1505: EB8F 21 0E 00               LD     HL,fcbS2Index
1506: EB92 19                     ADD    HL,DE
1507: EB93 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1508: EB94 CD F6 F2               CALL   OpenFile             ; is the file present?
1509: EB97 3A C2 EA               LD     A,(exitParameterByte)
1510: EB9A 3C                     INC    A
1511: EB9B C2 B2 EB               JP     NZ,RandomSeekExit    ; open successful?
1512: EB9E         ; cannot open the file, read mode?
1513: EB9E C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1514: EB9F C5                     PUSH   BC                   ; everyone expects this item stacked
1515: EBA0 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1516: EBA2 0C                     INC    C                    ; becomes 00 if read operation
1517: EBA3 CA B8 EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1518: EBA6 CD 46 F1               CALL   MakeNewFile          ; write operation, make new extent
1519: EBA9 2E 05                  LD     L,05                 ; cannot create new extent #5
1520: EBAB 3A C2 EA               LD     A,(exitParameterByte)
1521: EBAE 3C                     INC    A
1522: EBAF CA B8 EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1523: EBB2         ; file make operation successful
1524: EBB2             RandomSeekExit:                      ; seekok:
1525: EBB2 C1                     POP    BC                   ; discard r/w flag
1526: EBB3 AF                     XOR    A
1527: EBB4 32 C2 EA               LD     (exitParameterByte),A
1528: EBB7 C9                     RET                         ; with zero set
1529: EBB8
1530: EBB8             RandomSeekErrorBadSeek:
1531: EBB8         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1532: EBB8         ; appears as overflow with file write flag set
1533: EBB8 E5                     PUSH   HL                   ; save error flag
1534: EBB9 CD C0 F2               CALL   GetModuleNum         ; HL = .fcbS2Index
1535: EBBC 36 C0                  LD     (HL),11000000B
1536: EBBE E1                     POP    HL                   ; and drop through
1537: EBBF             RandomSeekError:                      ; seekerr:
1538: EBBF C1                     POP    BC                   ; discard r/w flag
1539: EBC0 7D                     LD     A,L
1540: EBC1 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1541: EBC4         ; SetFileWriteFlag returns non-zero accumulator for err
1542: EBC4 C3 C9 F3               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1543: EBC7         ;ret
1544: EBC7         ;
1545: EBC7         ;*****************************************************************
1546: EBC7             SetRandomRecord:                      ; setrandom
1547: EBC7 2A C0 EA               LD     HL,(paramDE)
1548: EBCA 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1549: EBCD CD 16 EC               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1550: EBD0 21 21 00               LD     HL,RANDOM_REC_FIELD
1551: EBD3 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1552: EBD4 71                     LD     (HL),C
1553: EBD5 23                     INC    HL
1554: EBD6 70                     LD     (HL),B
1555: EBD7 23                     INC    HL
1556: EBD8 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1557: EBD9 C9                     RET
1558: EBDA         ;*****************************************************************
1559: EBDA         ;compute logical file size for current fcb
1560: EBDA             GetFileSize:                      ; getfilesize
1561: EBDA 0E 0C                  LD     C,fcbExtIndex
1562: EBDC CD 39 F3               CALL   Search4DirElement
1563: EBDF         ; zero the receiving Ramdom record field
1564: EBDF 2A C0 EA               LD     HL,(paramDE)
1565: EBE2 11 21 00               LD     DE,RANDOM_REC_FIELD
1566: EBE5 19                     ADD    HL,DE
1567: EBE6 E5                     PUSH   HL                   ; save position
1568: EBE7 72                     LD     (HL),D
1569: EBE8 23                     INC    HL
1570: EBE9 72                     LD     (HL),D
1571: EBEA 23                     INC    HL
1572: EBEB 72                     LD     (HL),D               ; =00 00 00
1573: EBEC             GetFileSize1:                      ; getsize:
1574: EBEC CD DD ED               CALL   EndOfDirectory
1575: EBEF CA 14 EC               JP     Z,GetFileSizeExit
1576: EBF2         ; current fcb addressed by dptr
1577: EBF2 CD C9 EE               CALL   GetDirElementAddress
1578: EBF5 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1579: EBF8 CD 16 EC               CALL   GetRandomRecordPosition
1580: EBFB         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1581: EBFB E1                     POP    HL
1582: EBFC E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1583: EBFD 5F                     LD     E,A                  ; save cy
1584: EBFE 79                     LD     A,C
1585: EBFF 96                     SUB    M
1586: EC00 23                     INC    HL                   ; ls byte
1587: EC01 78                     LD     A,B
1588: EC02 9E                     SBC    A,(HL)
1589: EC03 23                     INC    HL                   ; middle byte
1590: EC04 7B                     LD     A,E
1591: EC05 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1592: EC06 DA 0E EC               JP     C,GetFileSize2       ; for another try
1593: EC09         ; fcb is less or equal, fill from directory
1594: EC09 73                     LD     (HL),E
1595: EC0A 2B                     DEC    HL
1596: EC0B 70                     LD     (HL),B
1597: EC0C 2B                     DEC    HL
1598: EC0D 71                     LD     (HL),C
1599: EC0E             GetFileSize2:                      ; getnextsize:
1600: EC0E CD 51 F3               CALL   Search4NextDirElement
1601: EC11 C3 EC EB               JP     GetFileSize1
1602: EC14             GetFileSizeExit:                      ; setsize:
1603: EC14 E1                     POP    HL                   ; discard .fcb(random record field)
1604: EC15 C9                     RET
1605: EC16         ;-----------------------------------------------------------------
1606: EC16         ;compute random record position
1607: EC16             GetRandomRecordPosition:                      ; compute$rr
1608: EC16 EB                     EX     DE,HL
1609: EC17 19                     ADD    HL,DE
1610: EC18         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1611: EC18 4E                     LD     C,(HL)
1612: EC19 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1613: EC1B 21 0C 00               LD     HL,fcbExtIndex
1614: EC1E 19                     ADD    HL,DE
1615: EC1F 7E                     LD     A,(HL)
1616: EC20 0F                     RRCA
1617: EC21 E6 80                  AND    80H                  ; A=e000 0000
1618: EC23 81                     ADD    A,C
1619: EC24 4F                     LD     C,A
1620: EC25 3E 00                  LD     A,0
1621: EC27 88                     ADC    A,B
1622: EC28 47                     LD     B,A
1623: EC29         ; BC = 0000 000? errrr rrrr
1624: EC29 7E                     LD     A,(HL)
1625: EC2A 0F                     RRCA
1626: EC2B E6 0F                  AND    LO_NIBBLE_MASK
1627: EC2D 80                     ADD    A,B
1628: EC2E 47                     LD     B,A
1629: EC2F         ; BC = 000? eeee errrr rrrr
1630: EC2F 21 0E 00               LD     HL,fcbS2Index
1631: EC32 19                     ADD    HL,DE
1632: EC33 7E                     LD     A,(HL)               ; A=XXX? mmmm
1633: EC34 87                     ADD    A,A
1634: EC35 87                     ADD    A,A
1635: EC36 87                     ADD    A,A
1636: EC37 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1637: EC38 F5                     PUSH   AF
1638: EC39 80                     ADD    A,B
1639: EC3A 47                     LD     B,A
1640: EC3B         ; cy=?, BC = mmmm eeee errr rrrr
1641: EC3B F5                     PUSH   AF                   ; possible second carry
1642: EC3C E1                     POP    HL                   ; cy = lsb of L
1643: EC3D 7D                     LD     A,L                  ; cy = lsb of A
1644: EC3E E1                     POP    HL                   ; cy = lsb of L
1645: EC3F B5                     OR     L                    ; cy/cy = lsb of A
1646: EC40 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1647: EC42 C9                     RET
1648: EC43         ;-----------------------------------------------------------------
1649: EC43
1650: EC43
1651: EC43
1652: EC43         ;*****************************************************************
1653: EC43         ;********************** Disk  I/O ********************************
1654: EC43         ;*****************************************************************
1655: EC43         ;-----------------------------------------------------------------
1656: EC43         ;;write protect current disk
1657: EC43             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1658: EC43 C3 D1 EC               JP     SetDiskReadOnly
1659: EC46         ;-----------------------------------------------------------------
1660: EC46         ;;set file Attributes
1661: EC46             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1662: EC46 CD C9 F2               CALL   Reselect
1663: EC49 CD 1E EF               CALL   SetAttributes
1664: EC4C C3 B3 F2               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1665: EC4F         ;-----------------------------------------------------------------
1666: EC4F
1667: EC4F             SelectCurrent:                      ; curselect
1668: EC4F 3A BF EA               LD     A,(paramE)
1669: EC52 21 37 F5               LD     HL,currentDisk
1670: EC55 BE                     CP     M
1671: EC56 C8                     RET    Z                    ; exit if parame = Current disk
1672: EC57 77                     LD     (HL),A
1673: EC58 C3 5B EC               JP     Select
1674: EC5B         ;*****************************************************************
1675: EC5B         ;--------------------------- Select Login Drive -----------------------------;
1676: EC5B         ; select Login Drive
1677: EC5B             Select:
1678: EC5B CD 78 EC               CALL   SelectDisk           ; Select the Disk
1679: EC5E CC A6 F4               CALL   Z,errSelect
1680: EC61 2A 3B F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP
1681: EC64 06 37                  LD     B,(currentDisk)      ; Get Current Disk
1682: EC66 CD 72 F4               CALL   IsBitSet
1683: EC69 C0                     RET    NZ                   ; Exit if already logged in
1684: EC6A         ;
1685: EC6A
1686: EC6A
1687: EC6A         ;	LD		HL,(loggedDisks)			; Point at Logged in Disks
1688: EC6A         ;	LD		A,(currentDisk)				; Get Current Disk
1689: EC6A         ;	LD		C,A
1690: EC6A         ;	CALL	ShiftRightHLbyC				; see if we already have drive logged in
1691: EC6A         ;	PUSH	HL							; save result
1692: EC6A         ;;	EX		DE,HL						 ; send to seldsk
1693: EC6A         ;	CALL	SelectDisk
1694: EC6A         ;	POP		HL								; get back logged disk vector
1695: EC6A         ;	CALL	Z,errSelect
1696: EC6A         ;	LD		A,L								; get logged disks
1697: EC6A         ;	RRA
1698: EC6A         ;	RET	C; exit if the disk already logged in
1699: EC6A
1700: EC6A 2A 3B F5               LD     HL,(loggedDisks)     ; else log in a different disk
1701: EC6D
1702: EC6D 06 37                  LD     B,(currentDisk)      ; Get Current Disk
1703: EC6F CD 82 F4               CALL   SetMapBit
1704: EC72         ;?	LD		C,L
1705: EC72         ;?	LD		B,H								; BC has logged disk
1706: EC72         ;?	CALL	SetCurrentDiskBit
1707: EC72 22 3B F5               LD     (loggedDisks),HL     ; save result
1708: EC75 C3 E8 EC               JP     InitDisk
1709: EC78         ;--------------------------- Select Login Drive -----------------------------;
1710: EC78
1711: EC78         ;--------------------------- Select Disk ------------------------------------;
1712: EC78         ;*****************************************************************          ;
1713: EC78         ; select the disk drive given by currentDisk, and fill the base addresses   ;
1714: EC78         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
1715: EC78             SelectDisk:                      ;
1716: EC78 3A 37 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
1717: EC7B 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
1718: EC7C CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
1719: EC7F 7C                     LD     A,H                  ; Return Pointer to                  ;
1720: EC80 B5                     OR     L                    ;  Disk Parameter Header             ;
1721: EC81 C8                     RET    Z                    ; exit if error, with HL = 0000      ;
1722: EC82         ;
1723: EC82 5E                     LD     E,(HL)               ;
1724: EC83 23                     INC    HL                   ;
1725: EC84 56                     LD     D,(HL)               ; Skew Table in DE                   ;
1726: EC85 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
1727: EC86 ED 53 5C F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
1728: EC8A         ;
1729: EC8A 22 3F F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
1730: EC8D 23                     INC    HL                   ;
1731: EC8E 23                     INC    HL                   ; HL = Last Track #                  ;
1732: EC8F 22 41 F5               LD     (caTrack),HL         ; Move to Current Track #            ;
1733: EC92 23                     INC    HL                   ;
1734: EC93 23                     INC    HL                   ; HL = Last Sector #                 ;
1735: EC94 22 43 F5               LD     (caSector),HL        ; Move to Current Sector #           ;
1736: EC97 23                     INC    HL                   ;
1737: EC98 23                     INC    HL                   ;
1738: EC99 11 45 F5               LD     DE,caDirectoryDMA    ;
1739: EC9C 01 08 00               LD     BC,caListSize        ;
1740: EC9F ED B0                  LDIR                        ;
1741: ECA1         ;
1742: ECA1         ; finish filling in address list                                             ;
1743: ECA1 2A 47 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
1744: ECA4 11 4D F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
1745: ECA7 01 0F 00               LD     BC,dpbSize           ;
1746: ECAA ED B0                  LDIR                        ; Move DPB to current                ;
1747: ECAC         ;
1748: ECAC         ; Determine if Byte or Word Allocation Table	                             ;
1749: ECAC 2A 52 F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
1750: ECAF 7C                     LD     A,H                  ; If  its 00 then < 255              ;
1751: ECB0 21 66 F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
1752: ECB3 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
1753: ECB5 B7                     OR     A                    ;  is the assumption confirmed ?     ;
1754: ECB6 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
1755: ECB8 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
1756: ECBA         ;
1757: ECBA         ; Set Sign, reset Carry and Zero to indicate success                         ;
1758: ECBA             SelectDisk1:                      ;
1759: ECBA 3E FF                  LD     A,TRUE               ;
1760: ECBC B7                     OR     A                    ;
1761: ECBD C9                     RET                         ;
1762: ECBE         ;--------------------------- Select Disk ------------------------------------;
1763: ECBE
1764: ECBE         ;---------------
1765: ECBE         ; set a "1" value in currentDisk position of BC
1766: ECBE         ; return in HL
1767: ECBE             SetCurrentDiskBit:
1768: ECBE C5                     PUSH   BC                   ; save input parameter
1769: ECBF 3A 37 F5               LD     A,(currentDisk)
1770: ECC2 4F                     LD     C,A                  ; ready parameter for shift
1771: ECC3 21 01 00               LD     HL,1                 ; number to shift
1772: ECC6 CD 61 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1773: ECC9 C1                     POP    BC                   ; original mask
1774: ECCA 79                     LD     A,C
1775: ECCB B5                     OR     L
1776: ECCC 6F                     LD     L,A
1777: ECCD 78                     LD     A,B
1778: ECCE B4                     OR     H
1779: ECCF 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1780: ECD0 C9                     RET
1781: ECD1         ;--------------
1782: ECD1         ;set current disk to read only
1783: ECD1             SetDiskReadOnly:
1784: ECD1 21 39 F5               LD     HL,ReadOnlyVector
1785: ECD4 4E                     LD     C,(HL)
1786: ECD5 23                     INC    HL
1787: ECD6 46                     LD     B,(HL)
1788: ECD7 CD BE EC               CALL   SetCurrentDiskBit    ; sets bit to 1
1789: ECDA 22 39 F5               LD     (ReadOnlyVector),HL
1790: ECDD         ; high water mark in directory goes to max
1791: ECDD 2A 54 F5               LD     HL,(dpbDRM)          ; directory max
1792: ECE0 EB                     EX     DE,HL                ; DE = directory max
1793: ECE1 2A 3F F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value
1794: ECE4 73                     LD     (HL),E
1795: ECE5 23                     INC    HL
1796: ECE6 72                     LD     (HL),D               ; cdrmax = dpbDRM
1797: ECE7 C9                     RET
1798: ECE8         ;----------------------- initialize the current disk
1799: ECE8         ;
1800: ECE8         ;exitParameterByte = false ;set to true if $ file exists
1801: ECE8         ; compute the length of the allocation vector - 2
1802: ECE8
1803: ECE8             InitDisk:
1804: ECE8 2A 52 F5               LD     HL,(dpbDSM)          ; get max allocation value
1805: ECEB 0E 03                  LD     C,3                  ; we want dpbDSM/8
1806: ECED         ; number of bytes in alloc vector is (dpbDSM/8)+1
1807: ECED CD 54 F4               CALL   ShiftRightHLbyC
1808: ECF0 23                     INC    HL                   ; HL = dpbDSM/8+1
1809: ECF1 44                     LD     B,H
1810: ECF2 4D                     LD     C,L                  ; BC has size of AllocationVector
1811: ECF3 2A 4B F5               LD     HL,(caAllocVector)   ; base of allocation vector
1812: ECF6         ;fill the allocation vector with zeros
1813: ECF6             InitDisk0:
1814: ECF6 36 00                  LD     (HL),0
1815: ECF8 23                     INC    HL                   ; alloc(i)=0
1816: ECF9 0B                     DEC    BC                   ; count length down
1817: ECFA 78                     LD     A,B
1818: ECFB B1                     OR     C
1819: ECFC C2 F6 EC               JP     NZ,InitDisk0
1820: ECFF         ; set the reserved space for the directory
1821: ECFF 2A 56 F5               LD     HL,(dpbDABM)         ; get the directory block reserved bits
1822: ED02 EB                     EX     DE,HL
1823: ED03 2A 4B F5               LD     HL,(caAllocVector)   ; HL=.alloc()
1824: ED06 73                     LD     (HL),E
1825: ED07 23                     INC    HL
1826: ED08 72                     LD     (HL),D               ; sets reserved directory blks
1827: ED09         ; allocation vector initialized, home disk
1828: ED09 CD AD ED               CALL   Home
1829: ED0C         ; caDirMaxValue = 3 (scans at least one directory record)
1830: ED0C 2A 3F F5               LD     HL,(caDirMaxValue)
1831: ED0F 36 03                  LD     (HL),3
1832: ED11 23                     INC    HL
1833: ED12 36 00                  LD     (HL),0               ; caDirMaxValue = 0003
1834: ED14
1835: ED14 CD C7 ED               CALL   SetEndDirectory      ; dirEntryIndex = EOD
1836: ED17         ; read directory entries and check for allocated storage
1837: ED17             InitDisk1:
1838: ED17 0E FF                  LD     C,TRUE
1839: ED19 CD EF ED               CALL   ReadDirectory
1840: ED1C CD DD ED               CALL   EndOfDirectory
1841: ED1F C8                     RET    Z                    ; return if end of directory
1842: ED20         ; not end of directory, valid entry?
1843: ED20 CD C9 EE               CALL   GetDirElementAddress ; HL = caDirectoryDMA + dirBlockIndex
1844: ED23 3E E5                  LD     A,emptyDir
1845: ED25 BE                     CP     M
1846: ED26 CA 17 ED               JP     Z,InitDisk1          ; go get another item
1847: ED29         ; not emptyDir, user code the same?
1848: ED29 3A 36 F5               LD     A,(currentUserNumber)
1849: ED2C BE                     CP     M
1850: ED2D C2 3B ED               JP     NZ,InitDisk2
1851: ED30         ; same user code, check for '$' submit
1852: ED30 23                     INC    HL
1853: ED31 7E                     LD     A,(HL)               ; first character
1854: ED32 D6 24                  SUB    DOLLAR               ; dollar file?
1855: ED34 C2 3B ED               JP     NZ,InitDisk2
1856: ED37         ; dollar file found, mark in exitParameterByte
1857: ED37 3D                     DEC    A
1858: ED38 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte = 255
1859: ED3B             InitDisk2:
1860: ED3B         ; now scan the disk map for allocated blocks
1861: ED3B 0E 01                  LD     C,1                  ; set to allocated
1862: ED3D CD 46 ED               CALL   ScanDiskMap
1863: ED40 CD D2 EE               CALL   SetDirectoryEntry    ; set DirMaxVAlue to dirEntryIndex
1864: ED43 C3 17 ED               JP     InitDisk1            ; for another entry
1865: ED46         ;
1866: ED46         ;-------------Scan the disk map for unallocated entry-----------------------------------
1867: ED46         ; scan the disk map addressed by dptr for non-zero entries.  The allocation
1868: ED46         ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
1869: ED46             ScanDiskMap:
1870: ED46 CD C9 EE               CALL   GetDirElementAddress ; HL = buffa + dptr
1871: ED49         ; HL addresses the beginning of the directory entry
1872: ED49 11 10 00               LD     DE,fcbDiskMapIndex
1873: ED4C 19                     ADD    HL,DE                ; hl now addresses the disk map
1874: ED4D C5                     PUSH   BC                   ; save the set/reset bit
1875: ED4E 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; size of Disk Allocation Map + 1
1876: ED50
1877: ED50             ScanDiskMap0:                      ; loop once for each disk map entry
1878: ED50 D1                     POP    DE                   ; recall the set/reset bit
1879: ED51 0D                     DEC    C
1880: ED52 C8                     RET    Z
1881: ED53
1882: ED53 D5                     PUSH   DE                   ; save the set/reset bit
1883: ED54 3A 66 F5               LD     A,(byteAllocationFlag) ; byteAllocationFlag byte entry flag
1884: ED57 B7                     OR     A
1885: ED58 CA 63 ED               JP     Z,ScanDiskMap1       ; skip if two byte value
1886: ED5B         ;  Byte Allocation scan operation
1887: ED5B C5                     PUSH   BC                   ; save counter
1888: ED5C E5                     PUSH   HL                   ; save map address
1889: ED5D 4E                     LD     C,(HL)
1890: ED5E 06 00                  LD     B,0                  ; BC=block#
1891: ED60 C3 69 ED               JP     ScanDiskMap2
1892: ED63         ; two byte scan operation
1893: ED63             ScanDiskMap1:
1894: ED63 0D                     DEC    C                    ; adjust counter for double byte
1895: ED64 C5                     PUSH   BC                   ; save counter
1896: ED65         ;	MOV		C,M
1897: ED65 46                     LD     B,(HL)
1898: ED66 23                     INC    HL
1899: ED67         ;	MOV		B,M								; BC=block#
1900: ED67 4E                     LD     C,(HL)               ; BC=block#
1901: ED68 E5                     PUSH   HL                   ; save map address
1902: ED69             ScanDiskMap2:                      ; arrive here with BC=block#, E=0/1
1903: ED69 79                     LD     A,C
1904: ED6A B0                     OR     B                    ; skip if = 0000
1905: ED6B C4 9B ED               CALL   NZ,SetAllocBit       ; bit set to 0/1 its in C
1906: ED6E E1                     POP    HL
1907: ED6F 23                     INC    HL                   ; to next bit position
1908: ED70 C1                     POP    BC                   ; recall counter
1909: ED71 C3 50 ED               JP     ScanDiskMap0         ; for another item
1910: ED74         ;
1911: ED74         ;-----------------------------------
1912: ED74         ;given allocation vector position BC, return with byte
1913: ED74         ;containing BC shifted so that the least significant
1914: ED74         ;bit is in the low order accumulator position.  HL is
1915: ED74         ;the address of the byte for possible replacement in
1916: ED74         ;memory upon return, and D contains the number of shifts
1917: ED74         ;required to place the returned value back into position
1918: ED74
1919: ED74             GetAllocBit:                      ; getallocbit
1920: ED74 79                     LD     A,C
1921: ED75 E6 07                  AND    111b
1922: ED77 3C                     INC    A
1923: ED78 5F                     LD     E,A
1924: ED79 57                     LD     D,A
1925: ED7A         ; d and e both contain the number of bit positions to shift
1926: ED7A 79                     LD     A,C
1927: ED7B 0F                     RRCA
1928: ED7C 0F                     RRCA
1929: ED7D 0F                     RRCA
1930: ED7E E6 1F                  AND    11111b
1931: ED80 4F                     LD     C,A                  ; C shr 3 to C
1932: ED81 78                     LD     A,B
1933: ED82 87                     ADD    A,A
1934: ED83 87                     ADD    A,A
1935: ED84 87                     ADD    A,A
1936: ED85 87                     ADD    A,A
1937: ED86 87                     ADD    A,A                  ; B shl 5
1938: ED87 B1                     OR     C
1939: ED88 4F                     LD     C,A                  ; bbbccccc to C
1940: ED89 78                     LD     A,B
1941: ED8A 0F                     RRCA
1942: ED8B 0F                     RRCA
1943: ED8C 0F                     RRCA
1944: ED8D E6 1F                  AND    11111b
1945: ED8F 47                     LD     B,A                  ; BC shr 3 to BC
1946: ED90 2A 4B F5               LD     HL,(caAllocVector)   ; base address of allocation vector
1947: ED93 09                     ADD    HL,BC
1948: ED94 7E                     LD     A,(HL)               ; byte to A, hl = .alloc(BC shr 3)
1949: ED95         ;now move the bit to the low order position of A
1950: ED95             GetAllocBitl:
1951: ED95 07                     RLCA
1952: ED96 1D                     DEC    E
1953: ED97 C2 95 ED               JP     NZ,GetAllocBitl
1954: ED9A C9                     RET
1955: ED9B
1956: ED9B         ;-----------------------------------
1957: ED9B         ; BC is the bit position of ALLOC to set or reset.  The
1958: ED9B         ; value of the bit is in register E.
1959: ED9B             SetAllocBit:
1960: ED9B D5                     PUSH   DE
1961: ED9C CD 74 ED               CALL   GetAllocBit          ; shifted val A, count in D
1962: ED9F E6 FE                  AND    11111110b            ; mask low bit to zero (may be set)
1963: EDA1 C1                     POP    BC
1964: EDA2 B1                     OR     C                    ; low bit of C is masked into A
1965: EDA3 C3 A6 ED               JP     RotateAndReplace     ; to rotate back into proper position
1966: EDA6         ;ret
1967: EDA6         ;-----------------------------------
1968: EDA6         ; byte value from ALLOC is in register A, with shift count
1969: EDA6         ; in register C (to place bit back into position), and
1970: EDA6         ; target ALLOC position in registers HL, rotate and replace
1971: EDA6             RotateAndReplace:
1972: EDA6 0F                     RRCA
1973: EDA7 15                     DEC    D
1974: EDA8 C2 A6 ED               JP     NZ,RotateAndReplace  ; back into position
1975: EDAB 77                     LD     (HL),A               ; back to ALLOC
1976: EDAC C9                     RET
1977: EDAD         ;-----------------------------------
1978: EDAD
1979: EDAD         ;move to home position, then offset to start of dir
1980: EDAD             Home:
1981: EDAD CD 18 F6               CALL   bcHome               ; move to track 00, sector 00 reference
1982: EDB0 21 5A F5               LD     HL,dpbOFF            ; get track ofset at begining
1983: EDB3 4E                     LD     C,(HL)
1984: EDB4 23                     INC    HL
1985: EDB5 46                     LD     B,(HL)
1986: EDB6 CD 1E F6               CALL   bcSettrk             ; select first directory position
1987: EDB9
1988: EDB9 AF                     XOR    A                    ; constant zero to accumulator
1989: EDBA 2A 41 F5               LD     HL,(caTrack)
1990: EDBD 77                     LD     (HL),A
1991: EDBE 23                     INC    HL
1992: EDBF 77                     LD     (HL),A               ; curtrk=0000
1993: EDC0 2A 43 F5               LD     HL,(caSector)
1994: EDC3 77                     LD     (HL),A
1995: EDC4 23                     INC    HL
1996: EDC5 77                     LD     (HL),A               ; currec=0000
1997: EDC6 C9                     RET
1998: EDC7
1999: EDC7
2000: EDC7         ;*****************************************************************
2001: EDC7
2002: EDC7         ;*****************************************************************
2003: EDC7         ;*****************************************************************
2004: EDC7         ; set directory counter to end  -1
2005: EDC7             SetEndDirectory:
2006: EDC7 21 FF FF               LD     HL,EOD
2007: EDCA 22 71 F5               LD     (dirEntryIndex),HL
2008: EDCD C9                     RET
2009: EDCE         ;---------------
2010: EDCE             SetDataDMA:                      ; setdata
2011: EDCE 21 3D F5               LD     HL,InitDAMAddress
2012: EDD1 C3 D7 ED               JP     SetDMA               ; to complete the call
2013: EDD4         ;---------------
2014: EDD4             SetDirDMA:                      ; setdir
2015: EDD4 21 45 F5               LD     HL,caDirectoryDMA
2016: EDD7
2017: EDD7             SetDMA:
2018: EDD7 4E                     LD     C,(HL)
2019: EDD8 23                     INC    HL
2020: EDD9 46                     LD     B,(HL)               ; parameter ready
2021: EDDA C3 24 F6               JP     bcSetdma             ; call bios to set
2022: EDDD         ;---------------
2023: EDDD         ;---------------
2024: EDDD         ; return zero flag if at end of directory
2025: EDDD         ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
2026: EDDD             EndOfDirectory:
2027: EDDD 21 71 F5               LD     HL,dirEntryIndex
2028: EDE0 7E                     LD     A,(HL)               ; may be 0ffh
2029: EDE1 23                     INC    HL
2030: EDE2 BE                     CP     M                    ; low(dirEntryIndex) = high(dirEntryIndex)?
2031: EDE3 C0                     RET    NZ                   ; non zero returned if different
2032: EDE4         ; high and low the same, = 0ffh?
2033: EDE4 3C                     INC    A                    ; 0ffh becomes 00 if so
2034: EDE5 C9                     RET
2035: EDE6         ;---------------
2036: EDE6         ; read a directory entry into the directory buffer
2037: EDE6             ReadDirRecord:
2038: EDE6 CD D4 ED               CALL   SetDirDMA            ; directory dma
2039: EDE9 CD 37 F2               CALL   ReadBuffer           ; directory record loaded
2040: EDEC C3 CE ED               JP     SetDataDMA           ; to data dma address
2041: EDEF         ;ret
2042: EDEF         ;---------------
2043: EDEF         ; read next directory entry, with C=true if initializing
2044: EDEF             ReadDirectory:
2045: EDEF 2A 54 F5               LD     HL,(dpbDRM)
2046: EDF2 EB                     EX     DE,HL                ; determine number of directory entries
2047: EDF3 2A 71 F5               LD     HL,(dirEntryIndex)   ; index into directory
2048: EDF6 23                     INC    HL
2049: EDF7 22 71 F5               LD     (dirEntryIndex),HL   ; initialize directory index
2050: EDFA         ; continue while dpbDRM >= dirEntryIndex (dpbDRM-dirEntryIndex no cy)
2051: EDFA CD 4D F4               CALL   DEminusHL2HL         ; DE-HL - processed all entries ?
2052: EDFD D2 04 EE               JP     NC,ReadDirectory0    ; no - do it again
2053: EE00         ; yes, set dirEntryIndex to end of directory
2054: EE00 CD C7 ED               CALL   SetEndDirectory
2055: EE03 C9                     RET
2056: EE04
2057: EE04         ; not at end of directory, seek next element, initialization flag is in C
2058: EE04             ReadDirectory0:
2059: EE04 3A 71 F5               LD     A,(dirEntryIndex)
2060: EE07 E6 03                  AND    dirEntryMask         ; low(dirEntryIndex) and dirEntryMask
2061: EE09 06 05                  LD     B,fcbShift           ; to multiply by fcb size to get the correct index in dir record
2062: EE0B             ReadDirectory1:
2063: EE0B 87                     ADD    A,A
2064: EE0C 05                     DEC    B
2065: EE0D C2 0B EE               JP     NZ,ReadDirectory1
2066: EE10         ; A = (low(dirEntryIndex) and dirEntryMask) shl fcbShift
2067: EE10 32 70 F5               LD     (dirBlockIndex),A    ; ready for next dir operation
2068: EE13 B7                     OR     A
2069: EE14 C0                     RET    NZ                   ; return if not a new record (Directory Block)
2070: EE15 C5                     PUSH   BC                   ; save initialization flag C
2071: EE16 CD 20 EE               CALL   SeekDir              ; seek$dir seek proper record
2072: EE19 CD E6 ED               CALL   ReadDirRecord        ; read the directory record
2073: EE1C C1                     POP    BC                   ; recall initialization flag
2074: EE1D C3 94 EE               JP     CalculateCheckSum    ; checksum the directory elt
2075: EE20         ;---------
2076: EE20         ;seek the record containing the current dir entry
2077: EE20             SeekDir:
2078: EE20 2A 71 F5               LD     HL,(dirEntryIndex)   ; directory counter to HL
2079: EE23 0E 02                  LD     C,dirEntryShift      ; 4 entries per record
2080: EE25 CD 54 F4               CALL   ShiftRightHLbyC      ; value to HL
2081: EE28 22 6E F5               LD     (currentBlock),HL
2082: EE2B 22 73 F5               LD     (dirRecord),HL       ; ready for seek
2083: EE2E C3 31 EE               JP     Seek
2084: EE31         ;---------------------------
2085: EE31             Seek:                           ; seek
2086: EE31         ;seek the track given by currentBlock (actual record number)
2087: EE31
2088: EE31 21 6E F5               LD     HL,currentBlock      ; contains the cpm record number
2089: EE34 4E                     LD     C,(HL)               ; Actual Record Number Low
2090: EE35 23                     INC    HL
2091: EE36 46                     LD     B,(HL)               ; Actual Record Number High
2092: EE37 2A 43 F5               LD     HL,(caSector)        ; Current Sector
2093: EE3A 5E                     LD     E,(HL)               ; Current Sector Number Low
2094: EE3B 23                     INC    HL
2095: EE3C 56                     LD     D,(HL)               ; Current Sector Number High
2096: EE3D 2A 41 F5               LD     HL,(caTrack)         ; Current track
2097: EE40 7E                     LD     A,(HL)               ; Current track Number Low - temp
2098: EE41 23                     INC    HL
2099: EE42 66                     LD     H,(HL)               ; Current track Number High
2100: EE43 6F                     LD     L,A                  ; Current track Number Low
2101: EE44         ;(BC) - cpmRecord Number
2102: EE44         ;(DE) - Current Sector
2103: EE44         ;(HL) - Current Track
2104: EE44
2105: EE44         ;loop while currentBlock < currec   ?????
2106: EE44             Seek0:
2107: EE44 79                     LD     A,C                  ;   Current Sector
2108: EE45 93                     SUB    E                    ;
2109: EE46 78                     LD     A,B                  ; - cpmRecord Number
2110: EE47 9A                     SBC    A,D                  ;
2111: EE48 D2 5A EE               JP     NC,Seek1             ; skip if cpmRecord Number >= Current Sector
2112: EE4B
2113: EE4B E5                     PUSH   HL
2114: EE4C 2A 4D F5               LD     HL,(dpbSPT)
2115: EE4F 7B                     LD     A,E
2116: EE50 95                     SUB    L
2117: EE51 5F                     LD     E,A
2118: EE52 7A                     LD     A,D
2119: EE53 9C                     SBC    A,H
2120: EE54 57                     LD     D,A
2121: EE55 E1                     POP    HL
2122: EE56 2B                     DEC    HL
2123: EE57 C3 44 EE               JP     Seek0
2124: EE5A
2125: EE5A             Seek1:
2126: EE5A
2127: EE5A E5                     PUSH   HL                   ; Save Current Track
2128: EE5B 2A 4D F5               LD     HL,(dpbSPT)          ; records per track
2129: EE5E 19                     ADD    HL,DE                ; HL = Current Sector + sectorsPerClynder
2130: EE5F 79                     LD     A,C                  ;     cpmRecord Number
2131: EE60 95                     SUB    L                    ;
2132: EE61 78                     LD     A,B                  ;  - HL (above)
2133: EE62 9C                     SBC    A,H                  ;
2134: EE63 DA 6C EE               JP     C,Seek2              ; skip if cpmRecord Number > HL (above)
2135: EE66
2136: EE66 EB                     EX     DE,HL
2137: EE67
2138: EE67 E1                     POP    HL
2139: EE68 23                     INC    HL
2140: EE69 C3 5A EE               JP     Seek1
2141: EE6C
2142: EE6C             Seek2:
2143: EE6C E1                     POP    HL                   ; retreive Current Track
2144: EE6D C5                     PUSH   BC                   ; save  cpmRecord Number
2145: EE6E D5                     PUSH   DE                   ; save  Current Sector
2146: EE6F E5                     PUSH   HL                   ; save CurrentTrack
2147: EE70         ; stack contains CurrentTrack , Current Sector, cpmRecord Number
2148: EE70 EB                     EX     DE,HL                ; DE => CurrentTrack, HL => Current Sector
2149: EE71 2A 5A F5               LD     HL,(dpbOFF)          ; Block Zero starting Track
2150: EE74 19                     ADD    HL,DE                ; HL =  actual physical Track number
2151: EE75 44                     LD     B,H
2152: EE76 4D                     LD     C,L                  ; BC has physical Track number
2153: EE77 CD 1E F6               CALL   bcSettrk             ; track set up
2154: EE7A         ; note that BC - curtrk is difference to move in bios
2155: EE7A D1                     POP    DE                   ; recall CurrentTrack
2156: EE7B 2A 41 F5               LD     HL,(caTrack)         ; point at current Track
2157: EE7E 73                     LD     (HL),E
2158: EE7F 23                     INC    HL
2159: EE80 72                     LD     (HL),D               ; current Track updated
2160: EE81         ; now compute sector as currentBlock-currec
2161: EE81 D1                     POP    DE                   ; recall Current Sector
2162: EE82 2A 43 F5               LD     HL,(caSector)        ; point at current Sector
2163: EE85 73                     LD     (HL),E
2164: EE86 23                     INC    HL
2165: EE87 72                     LD     (HL),D               ; current sector updated / DE has currentSector
2166: EE88 C1                     POP    BC                   ; recall cpmRecord Number
2167: EE89 79                     LD     A,C                  ; cpmRecord Number
2168: EE8A 93                     SUB    E
2169: EE8B 4F                     LD     C,A                  ; - currentSector
2170: EE8C 78                     LD     A,B
2171: EE8D 9A                     SBC    A,D
2172: EE8E 47                     LD     B,A                  ; back into BC
2173: EE8F C3 21 F6               JP     bcSetsec             ; sector selected
2174: EE92         ;ret
2175: EE92         ;************* CheckSum *******************************
2176: EE92         ; compute current checksum record
2177: EE92         ; if C = TRUE , update the allocation vector
2178: EE92         ;
2179: EE92         ; or check for = if not dirRecord < dpbCKS ????
2180: EE92
2181: EE92             NewCheckSum:
2182: EE92 0E FF                  LD     C,TRUE
2183: EE94
2184: EE94             CalculateCheckSum:
2185: EE94 2A 73 F5               LD     HL,(dirRecord)
2186: EE97 EB                     EX     DE,HL
2187: EE98 2A 58 F5               LD     HL,(dpbCKS)          ; size of checksum vector
2188: EE9B CD 4D F4               CALL   DEminusHL2HL         ; DE-HL
2189: EE9E D0                     RET    NC                   ; skip checksum if past checksum vector size
2190: EE9F C5                     PUSH   BC                   ; save init flag
2191: EEA0 CD BC EE               CALL   ComputeCheckSum      ; check sum value to A
2192: EEA3 2A 49 F5               LD     HL,(caCheckSum)      ; address of check sum vector
2193: EEA6 EB                     EX     DE,HL
2194: EEA7 2A 73 F5               LD     HL,(dirRecord)       ; value of dirRecord
2195: EEAA 19                     ADD    HL,DE                ; HL = .check(dirRecord)
2196: EEAB C1                     POP    BC                   ; recall true=0ffh or false=00 to C
2197: EEAC 0C                     INC    C                    ; 0ffh produces zero flag
2198: EEAD CA BA EE               JP     Z,SetNewCheckSum
2199: EEB0         ; not initializing, compare
2200: EEB0 BE                     CP     M                    ; compute$cs=check(dirRecord)?
2201: EEB1 C8                     RET    Z                    ; no message if ok
2202: EEB2         ; possible checksum error, are we beyond the end of the disk?
2203: EEB2 CD DB EE               CALL   StillInDirectory
2204: EEB5 D0                     RET    NC                   ; no message if so
2205: EEB6 CD D1 EC               CALL   SetDiskReadOnly      ; read/only disk set
2206: EEB9 C9                     RET
2207: EEBA
2208: EEBA         ;initializing the checksum
2209: EEBA             SetNewCheckSum:
2210: EEBA 77                     LD     (HL),A
2211: EEBB C9                     RET
2212: EEBC         ;------------------
2213: EEBC         ;compute checksum for current directory buffer
2214: EEBC             ComputeCheckSum:
2215: EEBC 0E 80                  LD     C,cpmRecordSize      ; size of directory buffer
2216: EEBE 2A 45 F5               LD     HL,(caDirectoryDMA)  ; current directory buffer
2217: EEC1 AF                     XOR    A                    ; clear checksum value
2218: EEC2             ComputeCheckSum0:
2219: EEC2 86                     ADD    A,(HL)
2220: EEC3 23                     INC    HL
2221: EEC4 0D                     DEC    C                    ; cs=cs+buff(cpmRecordSize-C)
2222: EEC5 C2 C2 EE               JP     NZ,ComputeCheckSum0
2223: EEC8 C9                     RET                         ; with checksum in A
2224: EEC9         ;*****************************************************************
2225: EEC9         ; compute the address of a directory element at positon dirBlockIndex in the buffer
2226: EEC9             GetDirElementAddress:
2227: EEC9 2A 45 F5               LD     HL,(caDirectoryDMA)
2228: EECC 3A 70 F5               LD     A,(dirBlockIndex)
2229: EECF C3 48 F4               JP     AddAtoHL
2230: EED2         ;---------------------
2231: EED2         ;if not still in directory set max value
2232: EED2             SetDirectoryEntry:
2233: EED2 CD DB EE               CALL   StillInDirectory
2234: EED5 D8                     RET    C
2235: EED6         ; return if yes,otherwise, HL = DirMaxValue+1, DE = directoryCount
2236: EED6
2237: EED6 13                     INC    DE
2238: EED7 72                     LD     (HL),D
2239: EED8 2B                     DEC    HL
2240: EED9 73                     LD     (HL),E
2241: EEDA C9                     RET
2242: EEDB         ; return CY if entry is still in Directory
2243: EEDB             StillInDirectory:
2244: EEDB 2A 71 F5               LD     HL,(dirEntryIndex)
2245: EEDE EB                     EX     DE,HL                ; DE = directory counter
2246: EEDF 2A 3F F5               LD     HL,(caDirMaxValue)   ; HL=caDirMaxValue
2247: EEE2 7B                     LD     A,E
2248: EEE3 96                     SUB    M                    ; low(dirEntryIndex) - low(cdrmax)
2249: EEE4 23                     INC    HL                   ; HL = .cdrmax+1
2250: EEE5 7A                     LD     A,D
2251: EEE6 9E                     SBC    A,(HL)               ; hi(dirEntryIndex) - hig(cdrmax)
2252: EEE7         ;condition dirEntryIndex - cdrmax  produces cy if cdrmax>dirEntryIndex
2253: EEE7 C9                     RET
2254: EEE8         ;---------------------
2255: EEE8         ;compute fcbRCIndex and NEXT_RECORD addresses for get/setfcb
2256: EEE8         ; returns with DE pointing at RC from FCB
2257: EEE8         ;         with HL pointing at Next Record
2258: EEE8             GetFcbAddress:                      ; getfcba
2259: EEE8 2A C0 EA               LD     HL,(paramDE)
2260: EEEB 11 0F 00               LD     DE,fcbRCIndex
2261: EEEE 19                     ADD    HL,DE
2262: EEEF EB                     EX     DE,HL                ; DE=.fcb(fcbRCIndex)
2263: EEF0 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;RATS
2264: EEF3 19                     ADD    HL,DE                ; HL=.fcb(NEXT_RECORD)
2265: EEF4 C9                     RET
2266: EEF5         ;---------------------
2267: EEF5         ;set variables from currently fcb - NEXT_RECORD, RC, EXM
2268: EEF5             SetRecordVars:
2269: EEF5 CD E8 EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2270: EEF8 7E                     LD     A,(HL)
2271: EEF9 32 6C F5               LD     (cpmRecord),A        ; cpmRecord=fcb(NEXT_RECORD)
2272: EEFC EB                     EX     DE,HL
2273: EEFD 7E                     LD     A,(HL)
2274: EEFE 32 6A F5               LD     (fcbRecordCount),A   ; fcbRecordCount=fcb(fcbRCIndex)
2275: EF01 CD C1 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2276: EF04 3A 51 F5               LD     A,(dpbEXM)           ; extent mask to a
2277: EF07 A6                     AND    M                    ; fcb(fcbExtIndex) and dpbEXM
2278: EF08 32 6B F5               LD     (extentValue),A      ; save extent number
2279: EF0B C9                     RET
2280: EF0C         ;---------------------
2281: EF0C         ;update variables from I/O in  fcb
2282: EF0C             UpdateRecordVars:
2283: EF0C CD E8 EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2284: EF0F 3A 61 F5               LD     A,(seqReadFlag)
2285: EF12 4F                     LD     C,A                  ; =1 if sequential i/o
2286: EF13 3A 6C F5               LD     A,(cpmRecord)        ; get NEXT_RECORD
2287: EF16 81                     ADD    A,C
2288: EF17 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=cpmRecord+seqReadFlag
2289: EF18 EB                     EX     DE,HL
2290: EF19 3A 6A F5               LD     A,(fcbRecordCount)
2291: EF1C 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2292: EF1D C9                     RET
2293: EF1E         ;---------------------
2294: EF1E         ;set file Attributes for current fcb
2295: EF1E             SetAttributes:
2296: EF1E 0E 0C                  LD     C,fcbExtIndex
2297: EF20 CD 39 F3               CALL   Search4DirElement    ; through file type
2298: EF23             SetAttributes1:
2299: EF23 CD DD ED               CALL   EndOfDirectory
2300: EF26 C8                     RET    Z                    ; exit at end of dir
2301: EF27 0E 00                  LD     C,0
2302: EF29 1E 0C                  LD     E,fcbExtIndex        ;copy name
2303: EF2B CD FA F3               CALL   CopyDir
2304: EF2E CD 51 F3               CALL   Search4NextDirElement
2305: EF31 C3 23 EF               JP     SetAttributes1
2306: EF34         ;
2307: EF34         ;*****************************************************************
2308: EF34
2309: EF34         ;*****************************************************************
2310: EF34         ;********************** File  Routines ***************************
2311: EF34         ;*****************************************************************
2312: EF34         ;open file
2313: EF34         ; IN  - (DE)	FCB Address
2314: EF34         ; OUT - (A)	Directory Code
2315: EF34         ;	0-3 = success ; 0FFH = File Not Found
2316: EF34             vOpenFile:                      ;
2317: EF34 CD BA F2               CALL   ClearModuleNum       ; clear the module number
2318: EF37 CD C9 F2               CALL   Reselect             ; do we need to reselect disk?
2319: EF3A C3 F6 F2               JP     OpenFile
2320: EF3D         ;ret ;jmp goback
2321: EF3D         ;-----------------------------------------------------------------
2322: EF3D         ;close file
2323: EF3D             vCloseFile:                      ; func16: (16 - 10) Close File
2324: EF3D CD C9 F2               CALL   Reselect
2325: EF40 C3 9E F1               JP     CloseDirEntry
2326: EF43         ;-----------------------------------------------------------------
2327: EF43         ;search for first occurrence of a file
2328: EF43         ; In - (DE)	FCB Address
2329: EF43         ; OUT - (A)	Directory Code
2330: EF43         ;	0-3 = success ; 0FFH = File Not Found
2331: EF43             vFindFirst:                      ; func17: (17 - 11) Search for first
2332: EF43 0E 00                  LD     C,0                  ; length assuming '?' true
2333: EF45 2A C0 EA               LD     HL,(paramDE)
2334: EF48 7E                     LD     A,(HL)
2335: EF49 FE 3F                  CP     QMARK                ; no reselect if ?
2336: EF4B CA 56 EF               JP     Z,QMarkSelect        ; skip reselect if so
2337: EF4E
2338: EF4E CD BA F2               CALL   ClearModuleNum       ; module number zeroed
2339: EF51 CD C9 F2               CALL   Reselect
2340: EF54 0E 0F                  LD     C,nameLength
2341: EF56             QMarkSelect:                      ; qselect:
2342: EF56 CD 39 F3               CALL   Search4DirElement
2343: EF59 C3 E7 F3               JP     CopyDirEntryToUser   ; copy directory entry to user
2344: EF5C         ;-----------------------------------------------------------------
2345: EF5C         ;search for next occurrence of a file name
2346: EF5C         ; OUT - (A)	Directory Code
2347: EF5C         ;	0-3 = success ; 0FFH = File Not Found
2348: EF5C             vFindNext:                      ; func18: (18 - 12) Search for next
2349: EF5C 2A 64 F5               LD     HL,(searchAddress)
2350: EF5F 22 C0 EA               LD     (paramDE),HL
2351: EF62 CD C9 F2               CALL   Reselect
2352: EF65 CD 51 F3               CALL   Search4NextDirElement
2353: EF68 C3 E7 F3               JP     CopyDirEntryToUser   ; copy directory entry to user
2354: EF6B         ;-----------------------------------------------------------------
2355: EF6B         ;search for next occurrence of a file name
2356: EF6B         ; OUT - (A)	Directory Code
2357: EF6B         ;delete a file
2358: EF6B             vDeleteFile:                      ; func18: (19 - 13) Delete File
2359: EF6B CD C9 F2               CALL   Reselect
2360: EF6E CD 7C F1               CALL   DeleteFile
2361: EF71 C3 B3 F2               JP     DirLocationToReturnLoc
2362: EF74         ;-----------------------------------------------------------------
2363: EF74         ;read sequential
2364: EF74         ;IN  - (DE) FCB address
2365: EF74         ;OUT - (A) 00 = success and data available. else no read and no data
2366: EF74             vReadSeq:                       ; func20: (20 - 14) read sequential
2367: EF74 CD C9 F2               CALL   Reselect
2368: EF77 CD B6 EF               CALL   ReadSeq
2369: EF7A C9                     RET
2370: EF7B         ;-----------------------------------------------------------------
2371: EF7B         ;write sequential
2372: EF7B         ;IN  - (DE) FCB address
2373: EF7B         ;OUT - (A) 00 = success and data available. else no read and no data
2374: EF7B             vWriteSeq:                      ; func21 (21 - 15) write sequention
2375: EF7B CD C9 F2               CALL   Reselect
2376: EF7E CD F9 EF               CALL   DiskWriteSeq
2377: EF81 C9                     RET
2378: EF82         ;-----------------------------------------------------------------
2379: EF82         ; Make file
2380: EF82         ; In - (DE)	FCB Address
2381: EF82         ; OUT - (A)	Directory Code
2382: EF82         ;	0-3 = success ; 0FFH = File Not Found
2383: EF82             vMakeFile:                      ; func22 (22 - 16) Make file
2384: EF82 CD BA F2               CALL   ClearModuleNum       ; set S2 to Zero
2385: EF85 CD C9 F2               CALL   Reselect
2386: EF88 C3 46 F1               JP     MakeNewFile
2387: EF8B         ;-----------------------------------------------------------------
2388: EF8B         ; Rename file
2389: EF8B         ; In - (DE)	FCB Address
2390: EF8B         ; OUT - (A)	Directory Code
2391: EF8B         ;	0-3 = success ; 0FFH = File Not Found
2392: EF8B             vRenameFile:                      ; func23 (23 - 17) Rename File
2393: EF8B CD C9 F2               CALL   Reselect
2394: EF8E CD 21 F1               CALL   Rename
2395: EF91 C3 B3 F2               JP     DirLocationToReturnLoc
2396: EF94         ;-----------------------------------------------------------------
2397: EF94         ;-----------------------------------------------------------------
2398: EF94         ;*****************************************************************
2399: EF94         ;-----------------------------------------------------------------
2400: EF94         ;check current directory element for read/only status
2401: EF94             CheckRODirectory:
2402: EF94 CD C9 EE               CALL   GetDirElementAddress ; address of element
2403: EF97         ;	JMP	CheckROFile
2404: EF97         ;------------
2405: EF97         ;check current buff(dptr) or fcb(0) for r/o status
2406: EF97             CheckROFile:
2407: EF97 11 09 00               LD     DE,fcbROfileIndex
2408: EF9A 19                     ADD    HL,DE                ; offset to ro bit
2409: EF9B 7E                     LD     A,(HL)
2410: EF9C 17                     RLA
2411: EF9D D0                     RET    NC                   ; return if not set
2412: EF9E C3 B2 F4               JP     errReadOnlyFile      ; exit to read only disk message
2413: EFA1         ;-----------------------------------------------------------------
2414: EFA1         ;check for write protected disk
2415: EFA1             CheckWrite:
2416: EFA1 CD A8 EF               CALL   DoNotWrite
2417: EFA4 C8                     RET    Z                    ; ok to write if not rodsk
2418: EFA5 C3 AC F4               JP     errReadOnlyDisk      ; read only disk error
2419: EFA8         ;-----------------------------------------------------------------
2420: EFA8         ;return true if dir checksum difference occurred
2421: EFA8             DoNotWrite:
2422: EFA8 2A 39 F5               LD     HL,(ReadOnlyVector)
2423: EFAB 3A 37 F5               LD     A,(currentDisk)
2424: EFAE 4F                     LD     C,A
2425: EFAF CD 54 F4               CALL   ShiftRightHLbyC
2426: EFB2 7D                     LD     A,L
2427: EFB3 E6 1B                  AND    1BH                  ; 01BH
2428: EFB5 C9                     RET                         ; non zero if nowrite
2429: EFB6         ;-----------------------------------------------------------------
2430: EFB6         ;sequential disk read operation
2431: EFB6             ReadSeq:
2432: EFB6 3E 01                  LD     A,1
2433: EFB8 32 61 F5               LD     (seqReadFlag),A      ; set flag for seqential read
2434: EFBB         ;---
2435: EFBB         ; read the disk
2436: EFBB         ; read the next record from the current fcb
2437: EFBB             DiskRead:
2438: EFBB 3E FF                  LD     A,TRUE
2439: EFBD 32 5F F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
2440: EFC0
2441: EFC0 CD F5 EE               CALL   SetRecordVars        ; sets cpmRecord, fcbRecordCount and EXM
2442: EFC3 3A 6C F5               LD     A,(cpmRecord)
2443: EFC6 21 6A F5               LD     HL,fcbRecordCount
2444: EFC9 BE                     CP     M                    ; cpmRecord-fcbRecordCount
2445: EFCA         ; skip if  cpmRecord < fcbRecordCount
2446: EFCA DA E0 EF               JP     C,RecordOK
2447: EFCD         ; not enough records in the extent
2448: EFCD FE 80                  CP     RecordsPerExtent     ; cpmRecord = 128?   *** Records in an Extent
2449: EFCF C2 F6 EF               JP     NZ,DiskEOF           ; skip if cpmRecord<>128
2450: EFD2 CD BE F0               CALL   OpenNextExt          ; go to next extent if so
2451: EFD5 AF                     XOR    A
2452: EFD6 32 6C F5               LD     (cpmRecord),A        ; cpmRecord=00
2453: EFD9         ; now check for open ok
2454: EFD9 3A C2 EA               LD     A,(exitParameterByte)
2455: EFDC B7                     OR     A
2456: EFDD C2 F6 EF               JP     NZ,DiskEOF
2457: EFE0         ; stop at eof
2458: EFE0         ; arrive with fcb addressing a record to read
2459: EFE0             RecordOK:                       ; recordok:
2460: EFE0 CD 87 F2               CALL   GetBlockNumber       ; save it in currentBlock
2461: EFE3 CD 94 F2               CALL   IsAllocated          ; currentBlock=0000?
2462: EFE6 CA F6 EF               JP     Z,DiskEOF            ; get out if not allocated already
2463: EFE9
2464: EFE9 CD 9A F2               CALL   SetActualRecordAdd   ; currentBlock now a record value
2465: EFEC CD 31 EE               CALL   Seek                 ; to proper track,sector
2466: EFEF CD 37 F2               CALL   ReadBuffer           ; to dma address
2467: EFF2 CD 0C EF               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
2468: EFF5 C9                     RET
2469: EFF6             DiskEOF:                        ; diskeof:
2470: EFF6 C3 D0 F3               JP     SetLowReturnTo1      ; exitParameterByte = 1
2471: EFF9         ;ret
2472: EFF9         ;-----------------------------------------------------------------
2473: EFF9         ;sequential disk write
2474: EFF9             DiskWriteSeq:
2475: EFF9 3E 01                  LD     A,1
2476: EFFB 32 61 F5               LD     (seqReadFlag),A
2477: EFFE         ;--------
2478: EFFE         ;disk write
2479: EFFE             DiskWrite:
2480: EFFE 3E 00                  LD     A,FALSE
2481: F000 32 5F F5               LD     (readModeFlag),A
2482: F003         ; write record to currently selected file
2483: F003 CD A1 EF               CALL   CheckWrite           ; in case write protected
2484: F006 2A C0 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
2485: F009 CD 97 EF               CALL   CheckROFile          ; may be a read-only file
2486: F00C CD F5 EE               CALL   SetRecordVars        ; set local Record parameters
2487: F00F 3A 6C F5               LD     A,(cpmRecord)
2488: F012 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
2489: F014 DA 1B F0               JP     C,DiskWrite1         ; skip if in the same Extent
2490: F017 CD D0 F3               CALL   SetLowReturnTo1
2491: F01A C9                     RET                         ; Exit ???????????
2492: F01B
2493: F01B         ; can write the next record, so continue
2494: F01B             DiskWrite1:
2495: F01B CD 87 F2               CALL   GetBlockNumber       ; sets up actual block number
2496: F01E CD 94 F2               CALL   IsAllocated
2497: F021 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
2498: F023 C2 6E F0               JP     NZ,DiskWrite3
2499: F026         ; not allocated -
2500: F026         ; the argument to getblock is the starting position for the disk search
2501: F026         ; and should be the last allocated block for this file,
2502: F026         ; or the value 0 if no space has been allocated
2503: F026
2504: F026 CD 0F F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
2505: F029 32 62 F5               LD     (diskMapIndex),A     ; save for later
2506: F02C 01 00 00               LD     BC,0000h             ; may use block zero
2507: F02F B7                     OR     A
2508: F030 CA 3A F0               JP     Z,FirstBlock         ; skip if no previous block
2509: F033         ; previous block exists
2510: F033 4F                     LD     C,A
2511: F034 0B                     DEC    BC                   ; previous block # in BC
2512: F035 CD 2F F4               CALL   GetDiskMapValue      ; previous block # to HL
2513: F038 44                     LD     B,H
2514: F039 4D                     LD     C,L                  ; BC=prev block#
2515: F03A         ; BC = 0000, or previous block #
2516: F03A             FirstBlock:
2517: F03A CD 4D F2               CALL   GetClosestBlock      ; block # to HL
2518: F03D         ; arrive here with block# or zero
2519: F03D 7D                     LD     A,L
2520: F03E B4                     OR     H
2521: F03F C2 48 F0               JP     NZ,BlockOK
2522: F042         ; cannot find a block to allocate
2523: F042 3E 02                  LD     A,2
2524: F044 32 C2 EA               LD     (exitParameterByte),A
2525: F047 C9                     RET                         ; exitParameterByte=2
2526: F048
2527: F048             BlockOK:
2528: F048 22 6E F5               LD     (currentBlock),HL    ; allocated block number is in HL
2529: F04B EB                     EX     DE,HL                ; block number to DE
2530: F04C 2A C0 EA               LD     HL,(paramDE)
2531: F04F 01 10 00               LD     BC,fcbDiskMapIndex
2532: F052 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
2533: F053 3A 66 F5               LD     A,(byteAllocationFlag)
2534: F056 B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
2535: F057 3A 62 F5               LD     A,(diskMapIndex)     ; recall dm index
2536: F05A CA 64 F0               JP     Z,Allocate16Bit      ; skip if allocating word
2537: F05D         ; else allocate using a byte value
2538: F05D CD 48 F4               CALL   AddAtoHL
2539: F060 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
2540: F061 C3 6C F0               JP     DiskWrite2           ; to continue
2541: F064
2542: F064             Allocate16Bit:                      ; allocate a word value
2543: F064
2544: F064 4F                     LD     C,A
2545: F065 06 00                  LD     B,0                  ; double(diskMapIndex)
2546: F067 09                     ADD    HL,BC
2547: F068 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
2548: F069 72                     LD     (HL),D
2549: F06A 23                     INC    HL
2550: F06B 73                     LD     (HL),E               ; double wd
2551: F06C         ; disk write to previously unallocated block
2552: F06C             DiskWrite2:
2553: F06C 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
2554: F06E
2555: F06E         ; continue the write operation of no allocation error
2556: F06E         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
2557: F06E
2558: F06E             DiskWrite3:
2559: F06E 3A C2 EA               LD     A,(exitParameterByte)
2560: F071 B7                     OR     A
2561: F072 C0                     RET    NZ                   ; stop if non zero returned value
2562: F073
2563: F073 C5                     PUSH   BC                   ; save write flag ( in C see above)
2564: F074 CD 9A F2               CALL   SetActualRecordAdd   ; currentBlock set to actual record number
2565: F077 CD 31 EE               CALL   Seek                 ; to proper file position
2566: F07A C1                     POP    BC                   ; get write flag
2567: F07B C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
2568: F07C CD 2F F2               CALL   WriteBuffer          ; written to disk
2569: F07F C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
2570: F080         ; increment record count if fcbRecordCount<=cpmRecord
2571: F080 3A 6C F5               LD     A,(cpmRecord)
2572: F083 21 6A F5               LD     HL,fcbRecordCount
2573: F086 BE                     CP     M                    ; cpmRecord-fcbRecordCount
2574: F087 DA 8E F0               JP     C,DiskWrite4
2575: F08A         ; fcbRecordCount <= cpmRecord
2576: F08A 77                     LD     (HL),A
2577: F08B 34                     INC    M                    ; fcbRecordCount = cpmRecord+1
2578: F08C 0E 02                  LD     C,2                  ; mark as record count incremented
2579: F08E             DiskWrite4:
2580: F08E         ; A has cpmRecord, C=2 if new block or new record#
2581: F08E 0D                     DEC    C
2582: F08F 0D                     DEC    C
2583: F090 C2 9B F0               JP     NZ,DiskWrite5
2584: F093 F5                     PUSH   AF                   ; save cpmRecord value
2585: F094 CD C0 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2586: F097         ; reset the file write flag to mark as written fcb
2587: F097 E6 7F                  AND    7FH                  ; not writeFlagMask
2588: F099 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2589: F09A F1                     POP    AF                   ; restore cpmRecord
2590: F09B             DiskWrite5:
2591: F09B         ; check for end of extent, if found attempt to open next extent in preparation for next write
2592: F09B FE 7F                  CP     highestRecordNumber  ; cpmRecord=highestRecordNumber?
2593: F09D C2 BB F0               JP     NZ,DiskWrite7        ; skip if not
2594: F0A0         ; may be random access write, if so we are done
2595: F0A0 3A 61 F5               LD     A,(seqReadFlag)
2596: F0A3 B7                     OR     A
2597: F0A4 CA BB F0               JP     Z,DiskWrite7         ; skip next extent open op
2598: F0A7         ; update current fcb before going to next extent
2599: F0A7 CD 0C EF               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2600: F0AA CD BE F0               CALL   OpenNextExt          ; readModeFlag=false
2601: F0AD         ; cpmRecord remains at highestRecordNumber causing eof if no more directory space is available
2602: F0AD 21 C2 EA               LD     HL,exitParameterByte
2603: F0B0 7E                     LD     A,(HL)
2604: F0B1 B7                     OR     A
2605: F0B2 C2 B9 F0               JP     NZ,DiskWrite6        ; no space
2606: F0B5         ; space available, set cpmRecord=255
2607: F0B5 3D                     DEC    A
2608: F0B6 32 6C F5               LD     (cpmRecord),A        ; goes to 00 next time
2609: F0B9             DiskWrite6:
2610: F0B9 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
2611: F0BB             DiskWrite7:
2612: F0BB C3 0C EF               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2613: F0BE         ;ret
2614: F0BE         ;-----------------------------------------------------------------
2615: F0BE         ;close the current extent  and open the next one if possible.
2616: F0BE         ;readModeFlag is true if in read mode
2617: F0BE             OpenNextExt:                      ; open$reel
2618: F0BE AF                     XOR    A
2619: F0BF 32 5E F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
2620: F0C2 CD 9E F1               CALL   CloseDirEntry        ; close current extent
2621: F0C5         ; exitParameterByte remains at enddir if we cannot open the next ext
2622: F0C5 CD DD ED               CALL   EndOfDirectory
2623: F0C8 C8                     RET    Z                    ; return if end
2624: F0C9 2A C0 EA               LD     HL,(paramDE)         ; increment extent number
2625: F0CC 01 0C 00               LD     BC,fcbExtIndex
2626: F0CF 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
2627: F0D0 7E                     LD     A,(HL)
2628: F0D1 3C                     INC    A
2629: F0D2 E6 1F                  AND    maxExtValue
2630: F0D4 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
2631: F0D5 CA E7 F0               JP     Z,OpenNextModule     ; move to next module if zero
2632: F0D8         ; may be in the same extent group
2633: F0D8 47                     LD     B,A
2634: F0D9 3A 51 F5               LD     A,(dpbEXM)
2635: F0DC A0                     AND    B
2636: F0DD         ; if result is zero, then not in the same group
2637: F0DD 21 5E F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
2638: F0E0 A6                     AND    M                    ; produces a 00 in accumulator if not written
2639: F0E1 CA F2 F0               JP     Z,OpenNextExt1       ; go to next physical extent
2640: F0E4         ; result is non zero, so we must be in same logical ext
2641: F0E4 C3 10 F1               JP     OpenNextExt2         ; to copy fcb information
2642: F0E7         ; extent number overflow, go to next module
2643: F0E7
2644: F0E7             OpenNextModule:
2645: F0E7 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
2646: F0EA 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
2647: F0EB 34                     INC    M                    ; fcb(fcbS2Index)=++1
2648: F0EC         ; module number incremented, check for overflow
2649: F0EC 7E                     LD     A,(HL)
2650: F0ED E6 0F                  AND    moduleMask           ; mask high order bits
2651: F0EF CA 1B F1               JP     Z,OpenNextExtError   ; cannot overflow to zero
2652: F0F2         ; otherwise, ok to continue with new module
2653: F0F2
2654: F0F2             OpenNextExt1:
2655: F0F2 0E 0F                  LD     C,nameLength
2656: F0F4 CD 39 F3               CALL   Search4DirElement    ; next extent found?
2657: F0F7 CD DD ED               CALL   EndOfDirectory
2658: F0FA C2 10 F1               JP     NZ,OpenNextExt2
2659: F0FD         ; end of file encountered
2660: F0FD 3A 5F F5               LD     A,(readModeFlag)
2661: F100 3C                     INC    A                    ; 0ffh becomes 00 if read
2662: F101 CA 1B F1               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
2663: F104         ; try to extend the current file
2664: F104 CD 46 F1               CALL   MakeNewFile
2665: F107         ; cannot be end of directory
2666: F107 CD DD ED               CALL   EndOfDirectory
2667: F10A CA 1B F1               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
2668: F10D C3 13 F1               JP     OpenNextExt3
2669: F110
2670: F110         ; not end of file, open
2671: F110             OpenNextExt2:
2672: F110 CD FF F2               CALL   OpenFileCopyFCB
2673: F113             OpenNextExt3:
2674: F113 CD F5 EE               CALL   SetRecordVars        ; Set Record parameters
2675: F116 AF                     XOR    A
2676: F117 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
2677: F11A C9                     RET                         ; with exitParameterByte = 0
2678: F11B
2679: F11B         ; cannot move to next extent of this file
2680: F11B             OpenNextExtError:
2681: F11B CD D0 F3               CALL   SetLowReturnTo1      ; exitParameterByte = 1
2682: F11E C3 C9 F3               JP     SetFileWriteFlag     ; ensure that it will not be closed
2683: F121         ;-----------------------------------------------------------------
2684: F121         ;rename the file described by the first half of the currently addressed FCB.
2685: F121         ;the new name is contained in the last half of the FCB. The file name and type
2686: F121         ;are changed, but the reel number is ignored.  the user number is identical
2687: F121             Rename:
2688: F121 CD A1 EF               CALL   CheckWrite           ; may be write protected
2689: F124         ; search up to the extent field
2690: F124 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
2691: F126 CD 39 F3               CALL   Search4DirElement
2692: F129         ; copy position 0
2693: F129 2A C0 EA               LD     HL,(paramDE)
2694: F12C 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
2695: F12D 11 10 00               LD     DE,fcbDiskMapIndex
2696: F130 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
2697: F131 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
2698: F132         ; assume the same disk drive for new named file
2699: F132             Rename1:
2700: F132 CD DD ED               CALL   EndOfDirectory
2701: F135 C8                     RET    Z                    ; stop at end of dir
2702: F136         ; not end of directory, rename next element
2703: F136 CD 94 EF               CALL   CheckRODirectory     ; may be read-only file
2704: F139 0E 10                  LD     C,fcbDiskMapIndex
2705: F13B 1E 0C                  LD     E,fcbExtIndex
2706: F13D CD FA F3               CALL   CopyDir
2707: F140         ; element renamed, move to next
2708: F140 CD 51 F3               CALL   Search4NextDirElement
2709: F143 C3 32 F1               JP     Rename1
2710: F146         ;-----------------------------------------------------------------
2711: F146         ;create a new file by creating a directory entry then opening the file
2712: F146             MakeNewFile:
2713: F146 CD A1 EF               CALL   CheckWrite           ; may be write protected
2714: F149 2A C0 EA               LD     HL,(paramDE)
2715: F14C E5                     PUSH   HL                   ; save fcb address, look for e5
2716: F14D 21 38 F5               LD     HL,emptyFCB
2717: F150 22 C0 EA               LD     (paramDE),HL         ; paramDE = .empty
2718: F153 0E 01                  LD     C,1
2719: F155 CD 39 F3               CALL   Search4DirElement    ; length 1 match on empty entry
2720: F158 CD DD ED               CALL   EndOfDirectory       ; zero flag set if no space
2721: F15B E1                     POP    HL                   ; recall paramDE address
2722: F15C 22 C0 EA               LD     (paramDE),HL         ; in case we return here
2723: F15F C8                     RET    Z                    ; return with error condition 255 if not found
2724: F160 EB                     EX     DE,HL                ; DE = paramDE address
2725: F161         ; clear the remainder of the fcb
2726: F161 21 0F 00               LD     HL,nameLength
2727: F164 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
2728: F165 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
2729: F167 AF                     XOR    A                    ; clear accumulator to 00 for fill
2730: F168             MakeNewFile1:
2731: F168 77                     LD     (HL),A
2732: F169 23                     INC    HL
2733: F16A 0D                     DEC    C
2734: F16B C2 68 F1               JP     NZ,MakeNewFile1
2735: F16E 21 0D 00               LD     HL,fcbS1Index
2736: F171 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
2737: F172 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
2738: F173 CD D2 EE               CALL   SetDirectoryEntry    ; may have extended the directory
2739: F176         ; now copy entry to the directory
2740: F176 CD F3 F3               CALL   CopyFCB
2741: F179         ; and set the file write flag to "1"
2742: F179 C3 C9 F3               JP     SetFileWriteFlag
2743: F17C         ;-----------------------------------------------------------------
2744: F17C         ;delete the currently addressed file
2745: F17C             DeleteFile:
2746: F17C CD A1 EF               CALL   CheckWrite           ; write protected ?
2747: F17F 0E 0C                  LD     C,fcbExtIndex        ; extent number field
2748: F181 CD 39 F3               CALL   Search4DirElement    ; search through file type
2749: F184             DeleteFile1:
2750: F184         ; loop while directory matches
2751: F184 CD DD ED               CALL   EndOfDirectory
2752: F187 C8                     RET    Z                    ; exit if end
2753: F188         ; set each non zero disk map entry to 0 in the allocation vector
2754: F188 CD 94 EF               CALL   CheckRODirectory     ; ro disk error if found
2755: F18B CD C9 EE               CALL   GetDirElementAddress ; HL=.buff(dptr)
2756: F18E 36 E5                  LD     (HL),emptyDir
2757: F190 0E 00                  LD     C,0
2758: F192 CD 46 ED               CALL   ScanDiskMap          ; alloc elts set to 0
2759: F195 CD 21 F2               CALL   WriteDir             ; write the directory
2760: F198 CD 51 F3               CALL   Search4NextDirElement ; to next element
2761: F19B C3 84 F1               JP     DeleteFile1          ; for another record
2762: F19E         ;-----------------------------------------------------------------
2763: F19E         ;locate the directory element and re-write it
2764: F19E             CloseDirEntry:
2765: F19E AF                     XOR    A
2766: F19F 32 C2 EA               LD     (exitParameterByte),A
2767: F1A2 CD A8 EF               CALL   DoNotWrite           ; return TRUE (0) if checksum change
2768: F1A5 C0                     RET    NZ                   ; skip close if r/o disk
2769: F1A6         ; check file write flag - 0 indicates written
2770: F1A6 CD C0 F2               CALL   GetModuleNum         ; fcb(fcbS2Index) in A
2771: F1A9 E6 80                  AND    writeFlagMask
2772: F1AB C0                     RET    NZ                   ; return if bit remains set
2773: F1AC 0E 0F                  LD     C,nameLength
2774: F1AE CD 39 F3               CALL   Search4DirElement    ; locate file
2775: F1B1 CD DD ED               CALL   EndOfDirectory
2776: F1B4 C8                     RET    Z                    ; return if not found
2777: F1B5         ; merge the disk map at paramDE with that at buff(dptr)
2778: F1B5 01 10 00               LD     BC,fcbDiskMapIndex
2779: F1B8 CD C9 EE               CALL   GetDirElementAddress
2780: F1BB 09                     ADD    HL,BC
2781: F1BC EB                     EX     DE,HL                ; DE is .buff(dptr+16)
2782: F1BD 2A C0 EA               LD     HL,(paramDE)
2783: F1C0 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
2784: F1C1 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of  byte Allocation Map
2785: F1C3             CloseDirEntry1:
2786: F1C3 3A 66 F5               LD     A,(byteAllocationFlag)
2787: F1C6 B7                     OR     A
2788: F1C7 CA DE F1               JP     Z,CloseDirEntry4     ; skip to double
2789: F1CA         ; this is a  byte map
2790: F1CA         ; if fcb(i) = 0 then fcb(i) = buff(i)
2791: F1CA         ; if buff(i) = 0 then buff(i) = fcb(i)
2792: F1CA         ; if fcb(i) <> buff(i) then error
2793: F1CA 7E                     LD     A,(HL)
2794: F1CB B7                     OR     A
2795: F1CC 1A                     LD     A,(DE)
2796: F1CD C2 D1 F1               JP     NZ,CloseDirEntry2
2797: F1D0         ; fcb(i) = 0
2798: F1D0 77                     LD     (HL),A               ; fcb(i) = buff(i)
2799: F1D1             CloseDirEntry2:
2800: F1D1 B7                     OR     A
2801: F1D2 C2 D7 F1               JP     NZ,CloseDirEntry3
2802: F1D5         ; buff(i) = 0
2803: F1D5 7E                     LD     A,(HL)
2804: F1D6 12                     LD     (DE),AE              ; buff(i)=fcb(i)
2805: F1D7             CloseDirEntry3:
2806: F1D7 BE                     CP     M
2807: F1D8 C2 16 F2               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
2808: F1DB C3 F3 F1               JP     CloseDirEntry5       ; if merge ok
2809: F1DE
2810: F1DE         ; this is a double byte merge operation
2811: F1DE             CloseDirEntry4:
2812: F1DE CD 3F F2               CALL   Merge                ; buff = fcb if buff 0000
2813: F1E1 EB                     EX     DE,HL
2814: F1E2 CD 3F F2               CALL   Merge
2815: F1E5 EB                     EX     DE,HL                ; fcb = buff if fcb 0000
2816: F1E6         ; they should be identical at this point
2817: F1E6 1A                     LD     A,(DE)
2818: F1E7 BE                     CP     M
2819: F1E8 C2 16 F2               JP     NZ,CloseDirEntryError ; low same?
2820: F1EB 13                     INC    DE
2821: F1EC 23                     INC    HL                   ; to high byte
2822: F1ED 1A                     LD     A,(DE)
2823: F1EE BE                     CP     M
2824: F1EF C2 16 F2               JP     NZ,CloseDirEntryError ; high same?
2825: F1F2         ;	merge operation ok for this pair
2826: F1F2 0D                     DEC    C                    ; extra count for double byte
2827: F1F3             CloseDirEntry5:
2828: F1F3 13                     INC    DE
2829: F1F4 23                     INC    HL                   ; to next byte position
2830: F1F5 0D                     DEC    C
2831: F1F6 C2 C3 F1               JP     NZ,CloseDirEntry1    ; for more
2832: F1F9         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
2833: F1F9 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
2834: F1FC 09                     ADD    HL,BC
2835: F1FD EB                     EX     DE,HL
2836: F1FE 09                     ADD    HL,BC
2837: F1FF         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
2838: F1FF 1A                     LD     A,(DE)               ; current user extent number
2839: F200         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
2840: F200 BE                     CP     M
2841: F201 DA 0D F2               JP     C,CloseDirEntryEnd
2842: F204         ; fcb extent number >= dir extent number
2843: F204 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
2844: F205         ; update directory record count field
2845: F205 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
2846: F208 09                     ADD    HL,BC
2847: F209 EB                     EX     DE,HL
2848: F20A 09                     ADD    HL,BC
2849: F20B         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
2850: F20B 7E                     LD     A,(HL)
2851: F20C 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
2852: F20D             CloseDirEntryEnd:
2853: F20D 3E FF                  LD     A,TRUE
2854: F20F 32 5E F5               LD     (fcbCopiedFlag),A    ; mark as copied
2855: F212 CD 1B F2               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
2856: F215 C9                     RET
2857: F216
2858: F216         ; elements did not merge correctly
2859: F216             CloseDirEntryError:
2860: F216 21 C2 EA               LD     HL,exitParameterByte
2861: F219 35                     DEC    M                    ; =255 non zero flag set
2862: F21A C9                     RET
2863: F21B         ;-----------------------------------------------------------------
2864: F21B         ;enter from CloseDirEntry to seek and copy current element
2865: F21B             SeekCopy:
2866: F21B CD 20 EE               CALL   SeekDir              ; to the directory element
2867: F21E C3 21 F2               JP     WriteDir             ; write the directory element
2868: F221         ;ret
2869: F221         ;-----------------------------------------------------------------
2870: F221         ;write the current directory entry, set checksum
2871: F221             WriteDir:
2872: F221 CD 92 EE               CALL   NewCheckSum          ; initialize entry
2873: F224 CD D4 ED               CALL   SetDirDMA            ; directory dma
2874: F227 0E 01                  LD     C,1                  ; indicates a write directory operation
2875: F229 CD 2F F2               CALL   WriteBuffer          ; write the buffer
2876: F22C C3 CE ED               JP     SetDataDMA           ; to data dma address
2877: F22F         ;ret
2878: F22F         ;-----------------------------------------------------------------
2879: F22F         ;write buffer and check condition
2880: F22F         ;write type (wrtype) is in register C
2881: F22F         ;wrtype = 0 => normal write operation		WriteAllocated
2882: F22F         ;wrtype = 1 => directory write operation	WriteDirectory
2883: F22F         ;wrtype = 2 => start of new block			WriteCleanBuffer
2884: F22F             WriteBuffer:
2885: F22F CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
2886: F232 B7                     OR     A
2887: F233 C2 CB F4               JP     NZ,erPermanentNoWait ; error if not 00
2888: F236 C9                     RET
2889: F237         ;-----------------------------------------------------------------
2890: F237         ;read buffer and check condition
2891: F237             ReadBuffer:
2892: F237 CD 27 F6               CALL   bcRead               ; current drive, track, sector, dma
2893: F23A B7                     OR     A
2894: F23B C2 CB F4               JP     NZ,erPermanentNoWait
2895: F23E C9                     RET
2896: F23F         ;-----------------------------------------------------------------
2897: F23F         ;HL = .fcb1(i), DE = .fcb2(i),
2898: F23F         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
2899: F23F             Merge:
2900: F23F 7E                     LD     A,(HL)
2901: F240 23                     INC    HL
2902: F241 B6                     OR     M
2903: F242 2B                     DEC    HL
2904: F243 C0                     RET    NZ                   ; return if = 0000
2905: F244 1A                     LD     A,(DE)
2906: F245 77                     LD     (HL),A
2907: F246 13                     INC    DE
2908: F247 23                     INC    HL                   ; low byte copied
2909: F248 1A                     LD     A,(DE)
2910: F249 77                     LD     (HL),A
2911: F24A 1B                     DEC    DE
2912: F24B 2B                     DEC    HL                   ; back to input form
2913: F24C C9                     RET
2914: F24D         ;-----------------------------------------------------------------
2915: F24D         ;compute closest disk block number from current block
2916: F24D         ;given allocation vector position BC, find the zero bit closest to this position
2917: F24D         ;by searching left and right.
2918: F24D         ;if found, set the bit to one and return the bit position in hl.
2919: F24D         ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
2920: F24D             GetClosestBlock:
2921: F24D 50                     LD     D,B
2922: F24E 59                     LD     E,C                  ; copy of starting position to de
2923: F24F             TestLeft:
2924: F24F 79                     LD     A,C
2925: F250 B0                     OR     B
2926: F251 CA 60 F2               JP     Z,TestRight          ; skip if left=0000
2927: F254         ; left not at position zero, bit zero?
2928: F254 0B                     DEC    BC
2929: F255 D5                     PUSH   DE
2930: F256 C5                     PUSH   BC                   ; left,right pushed
2931: F257 CD 74 ED               CALL   GetAllocBit
2932: F25A 1F                     RRA
2933: F25B D2 7B F2               JP     NC,ReturnBlockNumber ; return block number if zero
2934: F25E         ; bit is one, so try the right
2935: F25E C1                     POP    BC
2936: F25F D1                     POP    DE                   ; left, right restored
2937: F260             TestRight:
2938: F260 2A 52 F5               LD     HL,(dpbDSM)          ; value of maximum allocation#
2939: F263 7B                     LD     A,E
2940: F264 95                     SUB    L
2941: F265 7A                     LD     A,D
2942: F266 9C                     SBC    A,H                  ; right=dpbDSM?
2943: F267 D2 83 F2               JP     NC,ReturnBlockZero   ; return block 0000 if so
2944: F26A 13                     INC    DE
2945: F26B C5                     PUSH   BC
2946: F26C D5                     PUSH   DE                   ; left, right pushed
2947: F26D 42                     LD     B,D
2948: F26E 4B                     LD     C,E                  ; ready right for call
2949: F26F CD 74 ED               CALL   GetAllocBit
2950: F272 1F                     RRA
2951: F273 D2 7B F2               JP     NC,ReturnBlockNumber ; return block number if zero
2952: F276 D1                     POP    DE
2953: F277 C1                     POP    BC                   ; restore left and right pointers
2954: F278 C3 4F F2               JP     TestLeft             ; for another attempt
2955: F27B             ReturnBlockNumber:
2956: F27B 17                     RLA
2957: F27C 3C                     INC    A                    ; bit back into position and set to 1
2958: F27D         ; 	D contains the number of shifts required to reposition
2959: F27D CD A6 ED               CALL   RotateAndReplace     ; move bit back to position and store
2960: F280 E1                     POP    HL
2961: F281 D1                     POP    DE                   ; HL returned value, DE discarded
2962: F282 C9                     RET
2963: F283
2964: F283         ; cannot find an available bit, return 0000
2965: F283             ReturnBlockZero:
2966: F283 21 00 00               LD     HL,0000H
2967: F286 C9                     RET
2968: F287         ;-----------------------------------------------------------------
2969: F287         ;compute disk block number from current fcb
2970: F287             GetBlockNumber:
2971: F287 CD 0F F4               CALL   GetDiskMapIndex      ; 0...15 in register A
2972: F28A 4F                     LD     C,A
2973: F28B 06 00                  LD     B,0
2974: F28D CD 2F F4               CALL   GetDiskMapValue      ; return value in HL
2975: F290 22 6E F5               LD     (currentBlock),HL    ; save for later
2976: F293 C9                     RET
2977: F294         ;-----------------------------------------------------------------
2978: F294         ;is  block allocated
2979: F294             IsAllocated:
2980: F294 2A 6E F5               LD     HL,(currentBlock)
2981: F297 7D                     LD     A,L
2982: F298 B4                     OR     H
2983: F299 C9                     RET
2984: F29A         ;-----------------------------------------------------------------
2985: F29A         ;compute actual record address
2986: F29A         ; result = currentBlock * ( 2**BSH)
2987: F29A             SetActualRecordAdd:
2988: F29A 3A 4F F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
2989: F29D 2A 6E F5               LD     HL,(currentBlock)
2990: F2A0
2991: F2A0             SetActualRecordAdd1:
2992: F2A0 29                     ADD    HL,HL
2993: F2A1 3D                     DEC    A                    ; shl(currentBlock,dpbBSH)
2994: F2A2 C2 A0 F2               JP     NZ,SetActualRecordAdd1
2995: F2A5         ; HL has Record number for start of the block;
2996: F2A5 3A 50 F5               LD     A,(dpbBLM)           ; get block mask
2997: F2A8 4F                     LD     C,A                  ; to get cpmRecord mod Block
2998: F2A9 3A 6C F5               LD     A,(cpmRecord)        ; get index into block
2999: F2AC A1                     AND    C                    ; masked value in A
3000: F2AD B5                     OR     L
3001: F2AE 6F                     LD     L,A                  ; to HL
3002: F2AF 22 6E F5               LD     (currentBlock),HL    ; currentBlock=HL or (cpmRecord and dpbBLM)
3003: F2B2         ; *** currentBlock now has current record number - Starting record number + index into block
3004: F2B2 C9                     RET
3005: F2B3         ;-----------------------------------------------------------------
3006: F2B3         ;---------------------
3007: F2B3         ;copy directory location to exitParameterByte
3008: F2B3             DirLocationToReturnLoc:
3009: F2B3 3A 60 F5               LD     A,(directoryFlag)
3010: F2B6 32 C2 EA               LD     (exitParameterByte),A
3011: F2B9 C9                     RET
3012: F2BA         ;---------------------
3013: F2BA         ;clear the module number field for user open/make (S2)
3014: F2BA             ClearModuleNum:
3015: F2BA CD C0 F2               CALL   GetModuleNum
3016: F2BD 36 00                  LD     (HL),0               ; fcb(fcbS2Index)=0
3017: F2BF C9                     RET
3018: F2C0         ;---------------------
3019: F2C0         ;get data module number (high order bit is fwf -file write flag)
3020: F2C0             GetModuleNum:
3021: F2C0 2A C0 EA               LD     HL,(paramDE)
3022: F2C3 11 0E 00               LD     DE,fcbS2Index
3023: F2C6 19                     ADD    HL,DE                ; HL=.fcb(fcbS2Index)
3024: F2C7 7E                     LD     A,(HL)
3025: F2C8 C9                     RET                         ; A=fcb(fcbS2Index)
3026: F2C9         ;---------------------
3027: F2C9         ;check current fcb to see if reselection necessary
3028: F2C9             Reselect:
3029: F2C9 3E FF                  LD     A,TRUE
3030: F2CB 32 67 F5               LD     (fResel),A           ;mark possible reselect
3031: F2CE 2A C0 EA               LD     HL,(paramDE)
3032: F2D1 7E                     LD     A,(HL)               ; drive select code
3033: F2D2 E6 1F                  AND    00011111B            ; non zero is auto drive select
3034: F2D4 3D                     DEC    A                    ; drive code normalized to 0..30, or 255
3035: F2D5 32 BF EA               LD     (paramE),A           ; save drive code
3036: F2D8 FE 1E                  CP     30
3037: F2DA D2 ED F2               JP     NC,NoSelect
3038: F2DD         ; auto select function, save currentDisk
3039: F2DD 3A 37 F5               LD     A,(currentDisk)
3040: F2E0 32 68 F5               LD     (entryDisk),A        ; entryDisk=currentDisk
3041: F2E3 7E                     LD     A,(HL)
3042: F2E4 32 69 F5               LD     (fcbDisk),A          ; save drive code
3043: F2E7 E6 E0                  AND    11100000B
3044: F2E9 77                     LD     (HL),A               ; preserve hi bits
3045: F2EA CD 4F EC               CALL   SelectCurrent
3046: F2ED             NoSelect:                       ; noselect:
3047: F2ED
3048: F2ED 3A 36 F5               LD     A,(currentUserNumber) ; set user code 0...31
3049: F2F0 2A C0 EA               LD     HL,(paramDE)
3050: F2F3 B6                     OR     M
3051: F2F4 77                     LD     (HL),A
3052: F2F5 C9                     RET
3053: F2F6         ;---------------------
3054: F2F6         ;search for the directory entry, copy to fcb
3055: F2F6             OpenFile:
3056: F2F6 0E 0F                  LD     C,nameLength
3057: F2F8 CD 39 F3               CALL   Search4DirElement
3058: F2FB CD DD ED               CALL   EndOfDirectory
3059: F2FE C8                     RET    Z                    ; return with exitParameterByte=255 if end
3060: F2FF
3061: F2FF         ; not end of directory, copy fcb information
3062: F2FF             OpenFileCopyFCB:
3063: F2FF CD C1 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
3064: F302 7E                     LD     A,(HL)
3065: F303 F5                     PUSH   AF
3066: F304 E5                     PUSH   HL                   ; save extent#
3067: F305 CD C9 EE               CALL   GetDirElementAddress
3068: F308 EB                     EX     DE,HL                ; DE = .buff(dptr)
3069: F309 2A C0 EA               LD     HL,(paramDE)         ; HL=.fcb(0)
3070: F30C 0E 20                  LD     C,NEXT_RECORD        ; length of move operation
3071: F30E D5                     PUSH   DE                   ; save .buff(dptr)
3072: F30F CD 68 F4               CALL   Move                 ; from .buff(dptr) to .fcb(0)
3073: F312         ; note that entire fcb is copied, including indicators
3074: F312 CD C9 F3               CALL   SetFileWriteFlag     ; sets file write flag
3075: F315 D1                     POP    DE
3076: F316 21 0C 00               LD     HL,fcbExtIndex
3077: F319 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbExtIndex)
3078: F31A 4E                     LD     C,(HL)               ; C = directory extent number
3079: F31B 21 0F 00               LD     HL,fcbRCIndex        ; point at the record Count field
3080: F31E 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbRCIndex)
3081: F31F 46                     LD     B,(HL)               ; B holds directory record count
3082: F320 E1                     POP    HL
3083: F321 F1                     POP    AF
3084: F322 77                     LD     (HL),A               ; restore extent number
3085: F323         ; HL = .user extent#, B = dir rec cnt, C = dir extent#
3086: F323         ; if user ext < dir ext then user := 128 records
3087: F323         ; if user ext = dir ext then user := dir records
3088: F323         ; if user ext > dir ext then user := 0 records
3089: F323 79                     LD     A,C
3090: F324 BE                     CP     M
3091: F325 78                     LD     A,B                  ; ready dir fcbRCIndex
3092: F326 CA 30 F3               JP     Z,OpenRecordCount    ; if same, user gets dir fcbRCIndex
3093: F329 3E 00                  LD     A,0
3094: F32B DA 30 F3               JP     C,OpenRecordCount    ; user is larger
3095: F32E 3E 80                  LD     A,RecordsPerExtent   ; directory is larger >>>RecordsPerExtent
3096: F330             OpenRecordCount:                      ;Acc has record count to fill
3097: F330 2A C0 EA               LD     HL,(paramDE)
3098: F333 11 0F 00               LD     DE,fcbRCIndex
3099: F336 19                     ADD    HL,DE
3100: F337 77                     LD     (HL),A
3101: F338 C9                     RET
3102: F339
3103: F339         ;---------------------
3104: F339         ;search for directory element of length C at info
3105: F339             Search4DirElement:
3106: F339 3E FF                  LD     A,0FFH
3107: F33B 32 60 F5               LD     (directoryFlag),A    ; changed if actually found
3108: F33E 21 63 F5               LD     HL,searchLength
3109: F341 71                     LD     (HL),C               ; searchLength = C
3110: F342 2A C0 EA               LD     HL,(paramDE)
3111: F345 22 64 F5               LD     (searchAddress),HL   ; searchAddress = paramDE
3112: F348 CD C7 ED               CALL   SetEndDirectory      ; dirEntryIndex = enddir
3113: F34B CD AD ED               CALL   Home                 ; to start at the beginning
3114: F34E C3 51 F3               JP     Search4NextDirElement
3115: F351         ;---------------------
3116: F351         ;search for the next directory element, assuming a previous
3117: F351         ;call on search which sets searchAddress and searchLength
3118: F351             Search4NextDirElement:
3119: F351 0E 00                  LD     C,FALSE
3120: F353 CD EF ED               CALL   ReadDirectory        ; read next dir element
3121: F356 CD DD ED               CALL   EndOfDirectory
3122: F359 CA B8 F3               JP     Z,SearchDone         ; skip to end if so
3123: F35C         ; not end of directory, scan for match
3124: F35C 2A 64 F5               LD     HL,(searchAddress)
3125: F35F EB                     EX     DE,HL                ; DE=beginning of user fcb
3126: F360 1A                     LD     A,(DE)               ; first character
3127: F361 FE E5                  CP     emptyDir             ; keep scanning if Dir entry is empty
3128: F363 CA 6E F3               JP     Z,Search4NextDirElement1
3129: F366         ; not emptyDir, may be end of logical directory
3130: F366 D5                     PUSH   DE                   ; save search address
3131: F367 CD DB EE               CALL   StillInDirectory     ; past logical end?
3132: F36A D1                     POP    DE                   ; recall address
3133: F36B D2 B8 F3               JP     NC,SearchDone        ; artificial stop
3134: F36E             Search4NextDirElement1:
3135: F36E CD C9 EE               CALL   GetDirElementAddress ; HL = buffa+dptr
3136: F371 3A 63 F5               LD     A,(searchLength)
3137: F374 4F                     LD     C,A                  ; length of search to c
3138: F375 06 00                  LD     B,0                  ; bcounts up, c counts down
3139: F377             Search4NextLoop:
3140: F377 79                     LD     A,C
3141: F378 B7                     OR     A
3142: F379 CA A7 F3               JP     Z,EndDirElementSearch
3143: F37C 1A                     LD     A,(DE)
3144: F37D FE 3F                  CP     QMARK
3145: F37F CA A0 F3               JP     Z,Search4NextOK      ; ? matches all
3146: F382         ; scan next character if not fcbS1Index
3147: F382 78                     LD     A,B
3148: F383 FE 0D                  CP     fcbS1Index
3149: F385 CA A0 F3               JP     Z,Search4NextOK
3150: F388         ; not the fcbS1Index field, extent field?
3151: F388 FE 0C                  CP     fcbExtIndex          ; may be extent field
3152: F38A 1A                     LD     A,(DE)               ; fcb character
3153: F38B CA 97 F3               JP     Z,Search4Ext         ; skip to search extent
3154: F38E 96                     SUB    M
3155: F38F E6 7F                  AND    07FH                 ; mask-out flags/extent modulus
3156: F391 C2 51 F3               JP     NZ,Search4NextDirElement ; skip if not matched
3157: F394 C3 A0 F3               JP     Search4NextOK        ;matched character
3158: F397
3159: F397         ; A has fcb character attempt an extent # match
3160: F397             Search4Ext:
3161: F397 C5                     PUSH   BC                   ; save counters
3162: F398 4E                     LD     C,(HL)               ; directory character to c
3163: F399 CD D6 F3               CALL   CompareExtents       ; compare user/dir char
3164: F39C C1                     POP    BC                   ; recall counters
3165: F39D C2 51 F3               JP     NZ,Search4NextDirElement ; skip if no match
3166: F3A0
3167: F3A0         ; current character matches
3168: F3A0             Search4NextOK:
3169: F3A0 13                     INC    DE
3170: F3A1 23                     INC    HL
3171: F3A2 04                     INC    B
3172: F3A3 0D                     DEC    C
3173: F3A4 C3 77 F3               JP     Search4NextLoop
3174: F3A7
3175: F3A7         ; entire name matches, return dir position
3176: F3A7             EndDirElementSearch:
3177: F3A7 3A 71 F5               LD     A,(dirEntryIndex)
3178: F3AA E6 03                  AND    dirEntryMask
3179: F3AC 32 C2 EA               LD     (exitParameterByte),A
3180: F3AF         ; exitParameterByte = low(dirEntryIndex) and 11b
3181: F3AF 21 60 F5               LD     HL,directoryFlag
3182: F3B2 7E                     LD     A,(HL)
3183: F3B3 17                     RLA
3184: F3B4 D0                     RET    NC                   ; directoryFlag=0ffh?
3185: F3B5         ; yes, change it to 0 to mark as found
3186: F3B5 AF                     XOR    A
3187: F3B6 77                     LD     (HL),A               ; directoryFlag=0
3188: F3B7 C9                     RET
3189: F3B8
3190: F3B8         ; end of directory, or empty name
3191: F3B8             SearchDone:
3192: F3B8 CD C7 ED               CALL   SetEndDirectory      ; may be artifical end
3193: F3BB 3E FF                  LD     A,0FFH
3194: F3BD 32 C2 EA               LD     (exitParameterByte),A
3195: F3C0 C9                     RET
3196: F3C1         ;---------------------
3197: F3C1         ;get current extent field address to (HL)
3198: F3C1             GetExtentAddress:
3199: F3C1 2A C0 EA               LD     HL,(paramDE)
3200: F3C4 11 0C 00               LD     DE,fcbExtIndex
3201: F3C7 19                     ADD    HL,DE                ;HL=.fcb(fcbExtIndex)
3202: F3C8 C9                     RET
3203: F3C9         ;---------------------
3204: F3C9         ;Set file write flag
3205: F3C9             SetFileWriteFlag:
3206: F3C9 CD C0 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3207: F3CC F6 80                  OR     writeFlagMask        ; set fwf (file write flag) to "1"
3208: F3CE 77                     LD     (HL),A               ; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
3209: F3CF C9                     RET                         ; also returns non zero in accumulator
3210: F3D0         ;---------------------
3211: F3D0         ;set exitParameterByte to 1
3212: F3D0             SetLowReturnTo1:
3213: F3D0 3E 01                  LD     A,1
3214: F3D2 32 C2 EA               LD     (exitParameterByte),A
3215: F3D5 C9                     RET
3216: F3D6         ;---------------------
3217: F3D6         ;compare extent# in A with that in C, return nonzero if they do not match
3218: F3D6             CompareExtents:
3219: F3D6 C5                     PUSH   BC                   ; save C's original value
3220: F3D7 F5                     PUSH   AF
3221: F3D8 3A 51 F5               LD     A,(dpbEXM)
3222: F3DB 2F                     CPL
3223: F3DC 47                     LD     B,A
3224: F3DD         ; B has negated form of extent mask
3225: F3DD 79                     LD     A,C
3226: F3DE A0                     AND    B
3227: F3DF 4F                     LD     C,A                  ; low bits removed from C
3228: F3E0 F1                     POP    AF
3229: F3E1 A0                     AND    B                    ; low bits removed from A
3230: F3E2 91                     SUB    C
3231: F3E3 E6 1F                  AND    maxExtValue          ; set flags
3232: F3E5 C1                     POP    BC                   ; restore original values
3233: F3E6 C9                     RET
3234: F3E7         ;---------------------
3235: F3E7         ;copy the directory entry to the user buffer
3236: F3E7             CopyDirEntryToUser:
3237: F3E7 2A 45 F5               LD     HL,(caDirectoryDMA)
3238: F3EA EB                     EX     DE,HL                ; source is directory buffer
3239: F3EB 2A 3D F5               LD     HL,(InitDAMAddress)  ; destination is user dma address
3240: F3EE 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3241: F3F0 C3 68 F4               JP     Move
3242: F3F3         ;---------------------
3243: F3F3         ;copy the whole file control block
3244: F3F3             CopyFCB:
3245: F3F3 0E 00                  LD     C,0
3246: F3F5 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3247: F3F7 C3 FA F3               JP     CopyDir
3248: F3FA         ;---------------------
3249: F3FA         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3250: F3FA             CopyDir:
3251: F3FA D5                     PUSH   DE                   ; save length for later
3252: F3FB 06 00                  LD     B,0                  ; double index to BC
3253: F3FD 2A C0 EA               LD     HL,(paramDE)         ; HL = source for data
3254: F400 09                     ADD    HL,BC
3255: F401 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3256: F402 CD C9 EE               CALL   GetDirElementAddress ; HL=.buff(dptr), destination
3257: F405 C1                     POP    BC                   ; DE=source, HL=dest, C=length
3258: F406 CD 68 F4               CALL   Move                 ; data moved
3259: F409         ;enter from close to seek and copy current element
3260: F409             SeekAndCopy:                      ; seek$copy:
3261: F409 CD 20 EE               CALL   SeekDir              ; seek$dir ;to the directory element
3262: F40C C3 21 F2               JP     WriteDir             ; write the directory element
3263: F40F         ;---------------------
3264: F40F         ;Return the  disk map Index for cpmRecord in the ACC
3265: F40F         ;  account for multiple extents in 1 physical Directory entry
3266: F40F             GetDiskMapIndex:                      ; dm$position
3267: F40F 21 4F F5               LD     HL,dpbBSH            ; get block shift value
3268: F412 4E                     LD     C,(HL)               ; shift count to C
3269: F413 3A 6C F5               LD     A,(cpmRecord)        ; current virtual record to A
3270: F416             GetDiskMapIndex1:
3271: F416 B7                     OR     A                    ; reset the carry flag
3272: F417 1F                     RRA
3273: F418 0D                     DEC    C
3274: F419 C2 16 F4               JP     NZ,GetDiskMapIndex1
3275: F41C         ; A = shr(cpmRecord,dpbBSH) = cpmRecord/2**(sect/block)
3276: F41C         ; A has the relative position in the block.
3277: F41C 47                     LD     B,A                  ; save it for later addition
3278: F41D 3E 08                  LD     A,8
3279: F41F 96                     SUB    M                    ; 8-dpbBSH to accumulator
3280: F420 4F                     LD     C,A                  ; extent shift count in register c
3281: F421 3A 6B F5               LD     A,(extentValue)      ; extent value ani extmsk
3282: F424             GetDiskMapIndex2:                      ; dmpos1:
3283: F424         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3284: F424         ; shift is 4,3,2,1,0
3285: F424 0D                     DEC    C
3286: F425 CA 2D F4               JP     Z,GetDiskMapIndex3
3287: F428 B7                     OR     A                    ; clear the carry flag
3288: F429 17                     RLA
3289: F42A C3 24 F4               JP     GetDiskMapIndex2
3290: F42D
3291: F42D         ; The ACC has the Block Number for this record
3292: F42D             GetDiskMapIndex3:
3293: F42D         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3294: F42D 80                     ADD    A,B                  ; add the previous shr(cpmRecord,dpbBSH) value
3295: F42E         ; A is one of the following values, depending upon alloc
3296: F42E         ; bks dpbBSH
3297: F42E         ; 1k   3     v/8 + extentValue * 16
3298: F42E         ; 2k   4     v/16+ extentValue * 8
3299: F42E         ; 4k   5     v/32+ extentValue * 4
3300: F42E         ; 8k   6     v/64+ extentValue * 2
3301: F42E         ; 16k  7     v/128+extentValue * 1
3302: F42E C9                     RET                         ; with disk map position in A
3303: F42F         ;---------------------
3304: F42F         ; Enter with Disk Map Index in BG
3305: F42F         ; Return disk map value  in HL
3306: F42F             GetDiskMapValue:
3307: F42F 2A C0 EA               LD     HL,(paramDE)         ; base address of file control block
3308: F432 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3309: F435 19                     ADD    HL,DE                ; HL =.diskmap
3310: F436 09                     ADD    HL,BC                ; index by a  byte value
3311: F437 3A 66 F5               LD     A,(byteAllocationFlag) ;  byte map entry?
3312: F43A B7                     OR     A
3313: F43B CA 42 F4               JP     Z,GetDiskMap16Bit    ; get disk map  byte
3314: F43E 6E                     LD     L,(HL)
3315: F43F 26 00                  LD     H,0
3316: F441 C9                     RET                         ; with HL=00bb
3317: F442             GetDiskMap16Bit:                      ; getdmd:
3318: F442 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3319: F443         ; double precision value returned
3320: F443 56                     LD     D,(HL)
3321: F444 23                     INC    HL
3322: F445 5E                     LD     E,(HL)
3323: F446 EB                     EX     DE,HL
3324: F447 C9                     RET
3325: F448         ;---------------------
3326: F448         ;---------------------
3327: F448         ;*****************************************************************
3328: F448         ;************************ Utilities ******************************
3329: F448         ;*****************************************************************
3330: F448             AddAtoHL:
3331: F448 85                     ADD    A,L
3332: F449 6F                     LD     L,A
3333: F44A D0                     RET    NC
3334: F44B 24                     INC    H
3335: F44C C9                     RET
3336: F44D         ;----------
3337: F44D             DEminusHL2HL:
3338: F44D 7B                     LD     A,E
3339: F44E 95                     SUB    L
3340: F44F 6F                     LD     L,A
3341: F450 7A                     LD     A,D
3342: F451 9C                     SBC    A,H
3343: F452 67                     LD     H,A
3344: F453 C9                     RET
3345: F454         ;-------------
3346: F454             ShiftRightHLbyC:
3347: F454 0C                     INC    C
3348: F455             ShiftRightHLbyC0:
3349: F455 0D                     DEC    C
3350: F456 C8                     RET    Z
3351: F457 7C                     LD     A,H
3352: F458 B7                     OR     A
3353: F459 1F                     RRA
3354: F45A 67                     LD     H,A
3355: F45B 7D                     LD     A,L
3356: F45C 1F                     RRA
3357: F45D 6F                     LD     L,A
3358: F45E C3 55 F4               JP     ShiftRightHLbyC0
3359: F461         ;-------
3360: F461             ShiftLeftHLbyC:
3361: F461 0C                     INC    C
3362: F462             ShiftLeftHLbyC0:
3363: F462 0D                     DEC    C
3364: F463 C8                     RET    Z                    ; exit when done
3365: F464 29                     ADD    HL,HL
3366: F465 C3 62 F4               JP     ShiftLeftHLbyC0
3367: F468         ;*****************************************************************
3368: F468         ;move data length of length C from source DE to HL
3369: F468             Move:
3370: F468 0C                     INC    C
3371: F469             Move0:
3372: F469 0D                     DEC    C
3373: F46A C8                     RET    Z
3374: F46B 1A                     LD     A,(DE)
3375: F46C 77                     LD     (HL),A
3376: F46D 13                     INC    DE
3377: F46E 23                     INC    HL
3378: F46F C3 69 F4               JP     Move0
3379: F472
3380: F472         ;********** Console OUT Routines*******************??????
3381: F472
3382: F472         ;---------------------------------- Is Bit Set ------------------------------;
3383: F472         ; Enter HL  contains the bit map                                             ;
3384: F472         ;       B   Has the bit number (0...F)                                       ;
3385: F472         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3386: F472         ;              = 0 if bit is set (1)                                         ;
3387: F472             IsBitSet:                       ;
3388: F472 04                     INC    B                    ;
3389: F473             IsBitSetLoop:                      ;
3390: F473 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3391: F474 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3392: F476 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3393: F478 3F                     CCF                         ; else Clear Carry flag              ;
3394: F479             IsBitSet1:                      ;
3395: F479 CB 1C                  RR     H                    ; Shift thru CY                      ;
3396: F47B CB 1D                  RR     L                    ; ditto                              ;
3397: F47D 10 F4                  DJNZ   IsBitSetLoop         ;
3398: F47F CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3399: F481 C9                     RET                         ;
3400: F482         ;---------------------------------- Is Bit Set ------------------------------;
3401: F482
3402: F482         ;============================ Set/Reset Map Bit =============================;
3403: F482         ;---------------------------------- Set Map Bit ----------------------------;;
3404: F482         ; Enter  HL  contains the bit map                                           ;;
3405: F482         ;        B   Has the bit number (0...F)                                     ;;
3406: F482         ; Return HL  Contains the modified bit map                                  ;;
3407: F482             SetMapBit:                      ;;
3408: F482 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3409: F483 CD 72 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3410: F486         ;;
3411: F486 C1                     POP    BC                   ; Get the bit position              ;;
3412: F487 CB FC                  SET    7,H                  ;;
3413: F489 18 07                  JR     ReAlignMap           ;                                    ;
3414: F48B         ;---------------------------------- Set Map Bit ----------------------------;;
3415: F48B         ;---------------------------------- Reset Map Bit --------------------------;;
3416: F48B         ; Enter  HL  contains the bit map                                           ;;
3417: F48B         ;        B   Has the bit number (0...F)                                     ;;
3418: F48B         ; Return HL  Contains the modified bit map                                  ;;
3419: F48B             SetMapBit:                      ;;
3420: F48B C5                     PUSH   BC                   ; Save the Bit Number               ;;
3421: F48C CD 72 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3422: F48F         ;;
3423: F48F C1                     POP    BC                   ; Get the bit position              ;;
3424: F490 CB BC                  RES    7,H                  ;;
3425: F492         ; Fall thru to ReAlignMap                                                    ;
3426: F492         ;---------------------------------- Reset Map Bit --------------------------;;
3427: F492         ;---------------------------------- Set Map Bit ----------------------------;;
3428: F492         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3429: F492         ;
3430: F492             ReAlignMap:                      ;
3431: F492 04                     INC    B                    ;
3432: F493             ReAlignMapLoop:                      ;
3433: F493 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3434: F494 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3435: F496 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3436: F498 3F                     CCF                         ; else Clear Carry flag              ;
3437: F499             ReAlignMap1:                      ;
3438: F499 CB 15                  RL     L                    ; Shift thru CY                      ;
3439: F49B CB 14                  RL     H                    ; ditto                              ;
3440: F49D 10 F4                  DJNZ   ReAlignMapLoop       ;
3441: F49F C9                     RET                         ;
3442: F4A0         ;============================ Set/Reset Map Bit =============================;
3443: F4A0
3444: F4A0
3445: F4A0         ;********************************************************
3446: F4A0         ;return version number
3447: F4A0             vGetVersion:                      ; func12 (12 - 0C)	 Get Verson
3448: F4A0 3E 20                  LD     A,VERSION
3449: F4A2 32 C2 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION (high = 00)
3450: F4A5 C9                     RET
3451: F4A6         ;************Error message World*************************
3452: F4A6             errSelect:
3453: F4A6 21 C5 F4               LD     HL,evSelection
3454: F4A9 C3 BE F4               JP     GoToError
3455: F4AC             errReadOnlyDisk:
3456: F4AC 21 C7 F4               LD     HL,evReadOnlyDisk
3457: F4AF C3 BE F4               JP     GoToError
3458: F4B2             errReadOnlyFile:
3459: F4B2 21 C9 F4               LD     HL,evReadOnlyFile
3460: F4B5 C3 BE F4               JP     GoToError
3461: F4B8             errPermanent:
3462: F4B8 21 C3 F4               LD     HL,evPermanent
3463: F4BB C3 BE F4               JP     GoToError
3464: F4BE         ;************Error message handler **********************
3465: F4BE             GoToError:
3466: F4BE         ;HL = .errorhandler, call subroutine
3467: F4BE 5E                     LD     E,(HL)
3468: F4BF 23                     INC    HL
3469: F4C0 56                     LD     D,(HL)               ; address of routine in DE
3470: F4C1 EB                     EX     DE,HL
3471: F4C2 E9                     JP     (HL)                 ; vector to subroutine
3472: F4C3         ;************ Error Vectors *****************************
3473: F4C3 D1 F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3474: F4C5 DD F4       evSelection: DW     erSelection          ; selerr select error subroutine
3475: F4C7 E3 F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3476: F4C9 E9 F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3477: F4CB         ;************Error Routines ******************************
3478: F4CB             erPermanentNoWait:
3479: F4CB 21 1B F5               LD     HL,emPermanent
3480: F4CE C3 BE F4               JP     GoToError
3481: F4D1             erPermanent:
3482: F4D1 21 1B F5               LD     HL,emPermanent
3483: F4D4 CD F2 F4               CALL   displayAndWait       ; to report the error
3484: F4D7 FE 03                  CP     CTRL_C
3485: F4D9 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3486: F4DC C9                     RET                         ; and ignore the error
3487: F4DD         ;
3488: F4DD             erSelection:
3489: F4DD 21 26 F5               LD     HL,emSelection
3490: F4E0 C3 EC F4               JP     waitB4boot           ; wait console before boot
3491: F4E3         ;
3492: F4E3             erReadOnlyDisk:
3493: F4E3 21 32 F5               LD     HL,emReadOnlyDisk
3494: F4E6 C3 EC F4               JP     waitB4boot           ; wait console before boot
3495: F4E9         ;
3496: F4E9             erReadOnlyFile:
3497: F4E9 21 2D F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3498: F4EC         ;
3499: F4EC         ; wait for response before boot
3500: F4EC             waitB4boot:
3501: F4EC CD F2 F4               CALL   displayAndWait
3502: F4EF C3 00 00               JP     WarmBoot
3503: F4F2
3504: F4F2         ;report error to console, message address in HL
3505: F4F2             displayAndWait:
3506: F4F2 E5                     PUSH   HL                   ; save message pointer
3507: F4F3 CD D3 E9               CALL   showCRLF             ; stack mssg address, new line
3508: F4F6 3A 37 F5               LD     A,(currentDisk)
3509: F4F9 C6 41                  ADD    A,ASCII_A
3510: F4FB 32 17 F5               LD     (emDisk),A           ; Problem disk name
3511: F4FE 01 0B F5               LD     BC,emDisk0
3512: F501 CD 38 E9               CALL   Print                ; the error message
3513: F504 C1                     POP    BC
3514: F505 CD 38 E9               CALL   Print                ; error mssage tail
3515: F508 C3 1E E9               JP     ConIn                ; to get the input character
3516: F50B         ;ret
3517: F50B         ;**************Error Messages*******************************
3518: F50B 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3519: F517 20 3A 20 24     emDisk:    DB     ' : $'
3520: F51B 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3521: F526 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3522: F52D 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3523: F532 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3524: F536         ;*****************************************************************
3525: F536
3526: F536         ;********* file control block (fcb) constants ********************
3527: F536             fcbLength  EQU    32                   ; fcblen file control block size
3528: F536             fcbROfileIndex EQU    9                    ; high order of first type char
3529: F536             fcbHiddenfileIndex EQU    10                   ; invisible file in dir command
3530: F536             fcbExtIndex EQU    12                   ; extent number field index
3531: F536             fcbS1Index EQU    13                   ; S1 index
3532: F536             fcbS2Index EQU    14                   ; S2 data module number index
3533: F536             fcbRCIndex EQU    15                   ; record count field index
3534: F536             fcbDiskMapIndex EQU    16                   ; dskmap disk map field
3535: F536
3536: F536             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3537: F536
3538: F536             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3539: F536             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3540: F536             dirEntryMask EQU    dirEntriesPerRecord-1
3541: F536             fcbShift   EQU    5                    ; log2(fcbLength)
3542: F536         ;
3543: F536
3544: F536
3545: F536
3546: F536             maxExtValue EQU    31                   ; largest extent number
3547: F536             moduleMask EQU    15                   ; limits module number value
3548: F536             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3549: F536             nameLength EQU    15                   ; namlen name length
3550: F536
3551: F536             emptyDir   EQU    0E5H                 ; empty empty directory entry
3552: F536             NEXT_RECORD EQU    fcbLength            ; nxtrec
3553: F536             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3554: F536         ;
3555: F536         ;	reserved file indicators
3556: F536         ;	equ	11				; reserved
3557: F536         ;*****************************************************************
3558: F536         ;*****************************************************************
3559: F536
3560: F536         ;***common values shared between bdosi and bdos******************
3561: F536 00          currentUserNumber: DB     0                    ; usrcode current user number
3562: F537         ; paramDE:			DS	2					; ParamsDE information address
3563: F537         ; exitParameterByte:
3564: F537         ; exitParameterWord:	DS	2					; address value to return
3565: F537 FF          currentDisk: DB     -1                   ; curdsk current disk number
3566: F538         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3567: F538
3568: F538         ;********************* Local Variables ***************************
3569: F538         ;     ************************
3570: F538         ;     *** Initialized Data ***
3571: F538
3572: F538 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3573: F539 00 00       ReadOnlyVector: DW     0                    ; rodsk read only disk vector
3574: F53B 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3575: F53D 80 00       InitDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3576: F53F
3577: F53F         ;     *** Current Disk attributes ****
3578: F53F         ; These are set upon disk select
3579: F53F         ; data must be adjacent, do not insert variables
3580: F53F         ; address of translate vector, not used
3581: F53F         ; ca - currentAddress
3582: F53F
3583: F53F 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3584: F541 00 00       caTrack:   DW     0000H                ; curtrka current track address
3585: F543 00 00       caSector:  DW     0000H                ; current Sector
3586: F545             caListSizeStart:
3587: F545 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3588: F547 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3589: F549 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3590: F54B 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3591: F54D             caListSizeEnd:
3592: F54D             caListSize EQU    caListSizeEnd - caListSizeStart
3593: F54D
3594: F54D         ;     ***** Disk Parameter Block *******
3595: F54D         ; data must be adjacent, do not insert variables
3596: F54D         ; dpb - Disk Parameter Block
3597: F54D             dpbStart:
3598: F54D 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3599: F54F 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3600: F550 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3601: F551 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3602: F552 00 00       dpbDSM:    DW     0000H                ; maxall maximum allocation number
3603: F554 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3604: F556 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3605: F558 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3606: F55A 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3607: F55C             dpbEnd:
3608: F55C             dpbSize    EQU    dpbEnd - dpbStart
3609: F55C         ;
3610: F55C
3611: F55C         ;     ************************
3612: F55C
3613: F55C 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3614: F55E 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3615: F55F 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3616: F560 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3617: F561 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3618: F562 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3619: F563 00          searchLength: DB     00H                  ; searchl search length
3620: F564 00 00       searchAddress: DW     0000H                ; searcha search address
3621: F566         ;tinfo:	ds	word							; temp for info in "make"
3622: F566 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3623: F567 00          fResel:    DB     00H                  ; resel reselection flag
3624: F568 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3625: F569 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3626: F56A 00          fcbRecordCount: DB     00H                  ; record count from current fcb
3627: F56B 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3628: F56C 00 00       cpmRecord: DW     0000H                ; current virtual record - NEXT_RECORD
3629: F56E 00 00       currentBlock: DW     0000H                ; arecord current actual record
3630: F570         ;
3631: F570         ;	local variables for directory access
3632: F570 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3633: F571 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3634: F573 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3635: F575
3636: F575         ;********************** data areas ******************************
3637: F575
3638: F575
3639: F575         ;---------------------------------- Stack Area--------------------------------;
3640: F575             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3641: F5B5             bdosStack:
3642: F5B5         ;
3643: F5B5         ;---------------------------------- Stack Area--------------------------------;
3644: F5B5         ;	end of Basic I/O System
3645: F5B5         ;-----------------------------------------------------------------;
3646: F5B5
3647: F5B5
3648: F5B5         ;
3649: F5B5             Z_HighestLocation:
3650: F5B5             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3651: F5B5
3652: F5B5
           ************************   Xref   ************************
0000: $               F5B5   0414 0444
3330: AddAtoHL        F448   2229 2538
2542: Allocate16Bit   F064   2536
1041: AreWeAtEndOfBuffer EA37   1037
0083: ASCII_A         0041   3509
0084: ASCII_C         0043
0085: ASCII_K         004B
0092: ASCII_LO_A      0061
0093: ASCII_LO_K      006B
0094: ASCII_LO_P      0070
0035: ASCII_MASK      007F   0984
0086: ASCII_N         004E
0087: ASCII_Q         0051
0088: ASCII_R         0052
0089: ASCII_W         0057
0090: ASCII_Y         0059
0070: ASCII_ZERO      0030
0064: ASTERISK        002A
1133: BackUp          EA9C   1061 1129
1138: BackUp1         EAA4   1134
0292: bcBoot          F600
0295: bcConin         F609   0614 0799 0910 0928
0296: bcConout        F60C   0606 0872 1136 1140 1146 1148
0294: bcConst         F606   0611 0906
0300: bcHome          F618   1981
0297: bcList          F60F   0579 0878
0307: bcListst        F62D
0298: bcPunch         F612   0564
0305: bcRead          F627   2892
0299: bcReader        F615   0545
0308: bcSectran       F630
0301: bcSeldsk        F61B   1718
0304: bcSetdma        F624   2021
0303: bcSetsec        F621   2173
0302: bcSettrk        F61E   1986 2153
0293: bcWboot         F603   0465
0306: bcWrite         F62A   2885
0150: BDOSBase        E800   0151 0153 0324
0119: BDOSE           0005   0120
0151: BDOSEntry       E800
0140: BDOSLength      0E00   0143 0153 0154
3641: bdosStack       F5B5
0330: BdosStart       E800
0053: BELL            0007
0153: BIOSBase        F600
0141: BIOSLength      0A00   0143
0113: BIOSPAGE        0002
0154: BIOSStart       F600   0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 3650
2527: BlockOK         F048   2521
0250: BlockSize       0800   0272
1056: BSspaceBS       EA45   0995
0031: BYTE            0001   1169
3622: byteAllocationFlag F566   1751 1883 2533 2786 3311
3590: caAllocVector   F54B   1291 1811 1823 1946
3589: caCheckSum      F549   2192
3587: caDirectoryDMA  F545   1738 2015 2216 2227 3237
3583: caDirMaxValue   F53F   1729 1793 1830 2246
3588: caDiskParamBlock F547   1325 1743
2184: CalculateCheckSum EE94   2074
3592: caListSize      0008   1739
3591: caListSizeEnd   F54D   3592
3586: caListSizeStart F545   3592
0091: CARET           005E   0838
0832: CaretOut        E945   1030 1111
3585: caSector        F543   1735 1993 2092 2162
3613: caSkewTable     F55C   1727
3584: caTrack         F541   1732 1989 2096 2156
0148: CCPEntry        E000   0150 0154
0139: CCPLength       0800   0143 0150 0154
0924: CheckCTL_S      E9A9   0913
2401: CheckRODirectory EF94   2703 2754
2406: CheckROFile     EF97   2485
2415: CheckWrite      EFA1   2483 2688 2713 2746
3014: ClearModuleNum  F2BA   2317 2338 2384
2764: CloseDirEntry   F19E   1495 2325 2620
2785: CloseDirEntry1  F1C3   2831
2799: CloseDirEntry2  F1D1   2796
2805: CloseDirEntry3  F1D7   2801
2811: CloseDirEntry4  F1DE   2788
2827: CloseDirEntry5  F1F3   2808
2852: CloseDirEntryEnd F20D   2841
2859: CloseDirEntryError F216   2807 2819 2824
0071: COLON           003A
1167: columnPosition  EABE   0857 0882 0947 0967 1125
0066: COMMA           002C
3218: CompareExtents  F3D6   3163
2214: ComputeCheckSum EEBC   2191
2218: ComputeCheckSum0 EEC2   2222
0125: ComTail         0080   0126
0127: ComTailChars    0082
0126: ComTailCount    0081   0127
0901: ConBreak        E989   0725 0868
0934: ConBreak0       E9B7   0926
0936: ConBreak1       E9BA   0904
0792: ConIn           E91E   0497 0983 3515
0865: ConsoleOut      E968   0839 0851 0856 0944 0952 0959 0961 1053
3250: CopyDir         F3FA   2303 2706 3247
3236: CopyDirEntryToUser F3E7   2343 2353
3244: CopyFCB         F3F3   2740
3628: cpmRecord       F56C   2271 2286 2442 2452 2487 2571 2608 2998 3269
0227: cpmRecordSize   0080   0229 0232 0234 2215 3240 3538
0056: CR              000D   0805 0958 0988 1052
0039: CTRL_C          0003   0929 1035 3484
0040: CTRL_E          0005   1000
0041: CTRL_H          0008   0811 0994 1139
0042: CTRL_K          000B
0043: CTRL_L          000C
0044: CTRL_P          0010   0912 1003
0045: CTRL_R          0012   1012
0046: CTRL_S          0013   0925
0047: CTRL_U          0015   1009
0048: CTRL_X          0018   1006
0049: CTRL_Z          001A
3629: currentBlock    F56E   2081 2088 2528 2975 2980 2989 3002
3565: currentDisk     F537   1204 1253 1669 1681 1702 1716 1769 2423 3039 3508
3561: currentUserNumber F536   0776 0782 1848 3048
0067: DASH            002D
0261: DataBlocks      02C7   0271
0260: DataSectors     0B1C   0261
2745: DeleteFile      F17C   2360
2749: DeleteFile1     F184   2761
1120: DeleteTheLine   EA8B   1007
1123: DeleteTheLine1  EA8C   1130
3337: DEminusHL2HL    F44D   2051 2188
3632: dirBlockIndex   F570   2067 2228
0232: DirBuffSize     0080
0247: DirectoryBlockCount 0002   0272
0234: DirectoryEntryPerRecord 0004   0275
3616: directoryFlag   F560   3009 3107 3181
3538: dirEntriesPerRecord 0004   3540
3633: dirEntryIndex   F571   2007 2027 2047 2049 2059 2078 2244 3177
3540: dirEntryMask    0003   2060 3178
3539: dirEntryShift   0002   2079
0231: DirEntrySize    0020   0234 0272
3008: DirLocationToReturnLoc F2B3   1664 2361 2395
3634: dirRecord       F573   2082 2185 2194
0219: DiskCommandBlock 0046
0218: DiskControlByte 0045
0221: DiskControlTable 0040
2469: DiskEOF         EFF6   2449 2456 2462
0414: diskf           000B
3618: diskMapIndex    F562   2505 2535
2437: DiskRead        EFBB   1424
0223: DiskReadCode    0001
0228: diskSectorSize  0200   0229 0250 0258
0217: DiskStatusLocation 0043
2479: DiskWrite       EFFE   1431
2494: DiskWrite1      F01B   2489
2552: DiskWrite2      F06C   2540
2558: DiskWrite3      F06E   2498
2579: DiskWrite4      F08E   2574
2590: DiskWrite5      F09B   2583
2609: DiskWrite6      F0B9   2605
2611: DiskWrite7      F0BB   2593 2597
0224: DiskWriteCode   0002
2474: DiskWriteSeq    EFF9   2376
3505: displayAndWait  F4F2   3483 3501
0130: DMABuffer       0080   1206 3575
0060: DOLLAR          0024   0820 1854
2421: DoNotWrite      EFA8   2416 2767
0273: dpb3hdAL0       00C0
0274: dpb3hdAL1       0000
0269: dpb3hdBLM       000F
0268: dpb3hdBSH       0004
0275: dpb3hdCKS       0020
0272: dpb3hdDRM       007F   0275
0271: dpb3hdDSM       02C6
0270: dpb3hdEXM       0000
0277: dpb3hdNOH       0002
0276: dpb3hdOFF       0001
0267: dpb3hdSPT       0090
3600: dpbBLM          F550   2996
3599: dpbBSH          F54F   2988 3267
3605: dpbCKS          F558   2187
3604: dpbDABM         F556   1821
3603: dpbDRM          F554   1791 2045
3602: dpbDSM          F552   1749 1804 2938
3607: dpbEnd          F55C   3608
3601: dpbEXM          F551   2276 2634 3221
3606: dpbOFF          F55A   1982 2149
3608: dpbSize         000F   1745
3598: dpbSPT          F54D   2114 2128
3597: dpbStart        F54D   1744 3608
0446: DUMMY           E8A6   0441 0442
3519: emDisk          F517   3510
3518: emDisk0         F50B   3511
3520: emPermanent     F51B   3479 3482
3551: emptyDir        00E5   1844 2756 3127 3572
3572: emptyFCB        F538   2716
3523: emReadOnlyDisk  F532   3493
3522: emReadOnlyFile  F52D   3497
3521: emSelection     F526   3489
0134: END_OF_FILE     001A
3176: EndDirElementSearch F3A7   3142
2026: EndOfDirectory  EDDD   1574 1840 2299 2622 2657 2666 2700 2720 2751 2775 3058 3121
0037: EndOfMessage    0000
1046: EndRead         EA3B   0989 0992
3624: entryDisk       F568   0387 3040
0289: EOD             FFFF   2006
0075: EQUAL_SIGN      003D
3481: erPermanent     F4D1   3473
3478: erPermanentNoWait F4CB   2887 2894
3492: erReadOnlyDisk  F4E3   3475
3496: erReadOnlyFile  F4E9   3476
3461: errPermanent    F4B8
3455: errReadOnlyDisk F4AC   2418
3458: errReadOnlyFile F4B2   2412
3452: errSelect       F4A6   1679
3488: erSelection     F4DD   3474
3473: evPermanent     F4C3   3462
3475: evReadOnlyDisk  F4C7   3456
3476: evReadOnlyFile  F4C9   3459
3474: evSelection     F4C5   3453
0058: EXCLAIM_POINT   0021
1171: exitParameterByte EAC2   0506 0615 0726 0752 0777 1254 1499 1509 1520 1527 1540 1858 2454 2524 2559 2602 2676 2766 2860 3010 3179 3194 3214 3449
1172: exitParameterWord EAC2   0343 0394 0546 0635 1231 1292 1311 1326
3627: extentValue     F56B   2278 3281
0026: FALSE           0000   0919 1091 1429 1755 2480 3119
0122: FCB1            005C   0123
0123: FCB2            006C
3614: fcbCopiedFlag   F55E   2619 2637 2854
3625: fcbDisk         F569   0345 0382 3042
3534: fcbDiskMapIndex 0010   1872 1875 2531 2695 2704 2778 2784 3308
3530: fcbExtIndex     000C   1478 1502 1561 1613 2296 2302 2625 2645 2690 2705 2747 2833 2845 3076 3151 3200
3529: fcbHiddenfileIndex 000A
3527: fcbLength       0020   1875 2728 2784 2833 3246 3538 3552
3533: fcbRCIndex      000F   1578 2260 2263 2845 3079 3098
3626: fcbRecordCount  F56A   2274 2290 2443 2572
3528: fcbROfileIndex  0009   2407
3531: fcbS1Index      000D   2735 3148
3532: fcbS2Index      000E   1484 1505 1630 2645 3022
3541: fcbShift        0005   2061
0167: fCloseFile      0010
0158: fConsoleIn      0001
0159: fConsoleOut     0002
0170: fDeleteFile     0013
0162: fGetConsoleStatus 000B
0176: fGetCurrentDisk 0019
0175: fGetLoginVector 0018
0178: fGetSetUserNumber 0020
0163: fGetVersion     000C
2516: FirstBlock      F03A   2508
0173: fMakeFile       0016
0166: fOpenFile       000F
0160: fPrintString    0009
0171: fReadSeq        0014
0161: fReadString     000A
0174: fRenameFile     0017
3623: fResel          F567   0346 0376 3030
0164: fResetSystem    000D
0168: fSearchFirst    0011
0169: fSearchNext     0012
0165: fSelectDisk     000E
0177: fSetDMA         001A
0444: functionCount   0028   0355
0401: functionTable   E854   0360 0414 0444
0172: fWriteSeq       0015
1919: GetAllocBit     ED74   1961 2931 2949
1950: GetAllocBitl    ED95   1953
2970: GetBlockNumber  F287   2460 2495
2920: GetClosestBlock F24D   2517
2226: GetDirElementAddress EEC9   1577 1843 1870 2402 2755 2779 3067 3135 3256
3317: GetDiskMap16Bit F442   3313
3266: GetDiskMapIndex F40F   2504 2971
3270: GetDiskMapIndex1 F416   3274
3282: GetDiskMapIndex2 F424   3289
3292: GetDiskMapIndex3 F42D   3286
3306: GetDiskMapValue F42F   2512 2974
3198: GetExtentAddress F3C1   2275 3063
2258: GetFcbAddress   EEE8   2269 2283
1560: GetFileSize     EBDA   1395
1573: GetFileSize1    EBEC   1601
1599: GetFileSize2    EC0E   1592
1602: GetFileSizeExit EC14   1575
3020: GetModuleNum    F2C0   1534 2585 2770 3015 3206
1607: GetRandomRecordPosition EC16   1549 1579
3465: GoToError       F4BE   3454 3457 3460 3463 3480
0076: GREATER_THAN    003E
0059: HASH_TAG        0023   0943
3536: highestRecordNumber 007F   2488 2592
1980: Home            EDAD   1828 3113
1143: IgnoreTheLine   EAA9   1010
3575: InitDAMAddress  F53D   1207 1275 2011 3239
1803: InitDisk        ECE8   1708
1813: InitDisk0       ECF6   1819
1837: InitDisk1       ED17   1846 1864
1859: InitDisk2       ED3B   1850 1855
0114: IOBYTE          0003   0634 0654
2979: IsAllocated     F294   2461 2496
3387: IsBitSet        F472   1682 3409 3421
3394: IsBitSet1       F479   3392
3389: IsBitSetLoop    F473   3397
1008: IsItDeleteTheLineU EA16
1005: IsItDeleteTheLineX EA11
1002: IsItPrintToggle EA0C
1092: IsItPrintToggle1 EA6D   1090
0996: IsItRubout      EA02
0999: IsPhysicalEOL   EA07
0804: IsPrintableASCII E929   0498 0834
1077: ItIsPhysicalEOL EA5A   1001
1084: ItIsPrintToggle EA62   1004
1065: ItIsRubout      EA4F   0998
1161: keyboardByte    EABB   0793 0902 0935
0062: L_PAREN         0028
0079: LEFT_ARROW      005F
0095: LEFT_CURLY      007B
0143: LengthInBytes   2000   0144 0148 0258
0144: LengthInK       0009
0074: LESS_THAN       003C
0055: LF              000A   0807 0888 0960 0990
1106: LL1             EA7B   1114
0029: LO_NIBBLE_MASK  000F   0781 1626
3574: loggedDisks     F53B   1202 1230 1680 1700 1707
2712: MakeNewFile     F146   1518 2386 2664
2730: MakeNewFile1    F168   2734
3546: maxExtValue     001F   2629 3231
0146: MemorySize      0040   0148
2899: Merge           F23F   2812 2814
3547: moduleMask      000F   2650
3369: Move            F468   3072 3241 3258
3371: Move0           F469   3378
0259: myOffset        0001   0260 0276
3549: nameLength      000F   2340 2655 2726 2728 2773 3056
2181: NewCheckSum     EE92   2872
3552: NEXT_RECORD     0020   1473 1548 2263 3070 3553
3046: NoSelect        F2ED   3037
0931: NothingWaiting  E9B5   0922
0051: NULL            0000
0243: NumberOfHeads   0002   0254 0256 0267 0277
0240: NumberOfLogicalDisks 0004
0028: OFF             0000
0027: ON              FFFF
3055: OpenFile        F2F6   1508 2319
3062: OpenFileCopyFCB F2FF   2672
2617: OpenNextExt     F0BE   2450 2600
2654: OpenNextExt1    F0F2   2639
2671: OpenNextExt2    F110   2641 2658
2673: OpenNextExt3    F113   2668
2680: OpenNextExtError F11B   2651 2662 2667
2644: OpenNextModule  F0E7   2631
3096: OpenRecordCount F330   3092 3094
1170: paramDE         EAC0   0335 0380 0677 0969 1048 1103 1274 1442 1547 1564 2259 2333 2350 2484 2530 2624 2693 2714 2717 2722 2782 3021 3031 3049 3069 3097 3110 3199 3253 3307
1169: paramE          EABF   0337 0388 0773 1668 3035
0061: PERCENT         0025
0068: PERIOD          002E
0117: Pg0CurentDisk   0004
0116: Pg0CurentUser   0004   0117
0065: PLUS_SIGN       002B
0818: Print           E938   0680 0827 3512 3514
1163: printEchoFlag   EABC   0876 0915 1087
0077: QMARK           003F   2335 3144
2341: QMarkSelect     EF56   2336
0063: R_PAREN         0029
0110: RAM             0000   0112 0113 0114 0116 0119 0122 0125 0130 0132
3553: RANDOM_REC_FIELD 0021   1444 1550 1565
1421: RandomDiskRead  EB24   1376
1428: RandomDiskWrite EB2D   1388
1438: RandomSeek      EB36   1423 1430
1492: RandomSeekClose EB7A   1482
1537: RandomSeekError EBBF   1471
1530: RandomSeekErrorBadSeek EBB8   1501 1517 1522
1524: RandomSeekExit  EBB2   1491 1511
2891: ReadBuffer      F237   2039 2466
2044: ReadDirectory   EDEF   1839 3120
2058: ReadDirectory0  EE04   2052
2062: ReadDirectory1  EE0B   2065
2037: ReadDirRecord   EDE6   2072
1026: ReadEchoRubOut  EA23   1074
3615: readModeFlag    F55F   2439 2481 2660
0979: ReadNext        E9EA   1043 1069 1095 1117
0982: ReadNext0       E9EC   1062 1081
3573: ReadOnlyVector  F539   1201 1310 1784 1789 2422
2431: ReadSeq         EFB6   2368
0966: ReadString      E9DD   0710 1127 1149
3430: ReAlignMap      F492   3413
3437: ReAlignMap1     F499   3435
3432: ReAlignMapLoop  F493   3440
2459: RecordOK        EFE0   2446
0252: RecordsPerBlock 0010
0236: RecordsPerExtent 0080   2448 3095 3536
0229: recordsPerSector 0004   0252 0267
2687: Rename          F121   2394
2699: Rename1         F132   2709
1098: RepeatLine      EA72   1013
3028: Reselect        F2C9   1375 1387 1394 1662 2318 2324 2339 2351 2359 2367 2375 2385 2393
2955: ReturnBlockNumber F27B   2933 2951
2965: ReturnBlockZero F283   2943
0375: ReturnToCaller  E82F   0349
0391: ReturnToCaller1 E84A   0378 0384 0613
1971: RotateAndReplace EDA6   1965 1974 2959
0080: RUBOUT          007F   0997
1869: ScanDiskMap     ED46   1862 2758
1877: ScanDiskMap0    ED50   1909
1893: ScanDiskMap1    ED63   1885
1902: ScanDiskMap2    ED69   1891
3105: Search4DirElement F339   1562 2297 2342 2656 2691 2719 2748 2774 3057
3160: Search4Ext      F397   3153
3118: Search4NextDirElement F351   1600 2304 2352 2708 2760 3114 3156 3165
3134: Search4NextDirElement1 F36E   3128
3139: Search4NextLoop F377   3173
3168: Search4NextOK   F3A0   3145 3149 3157
3620: searchAddress   F564   2349 3111 3124
3191: SearchDone      F3B8   3122 3133
3619: searchLength    F563   3108 3136
0281: SectorMask      0003
0246: SectorsPerBlock 0004   0250 0252 0255 0261 0281
0256: SectorsPerCylinder 0024   0259 0260
0245: SectorsPerTrack 0012   0254 0256 0267
2085: Seek            EE31   2083 2465 2565
2106: Seek0           EE44   2123
2125: Seek1           EE5A   2111 2140
2142: Seek2           EE6C   2134
3260: SeekAndCopy     F409
2865: SeekCopy        F21B   2855
2077: SeekDir         EE20   2071 2866 3261
1677: Select          EC5B   1209 1673
1667: SelectCurrent   EC4F   0389 1361 3045
1715: SelectDisk      EC78   1678
1758: SelectDisk1     ECBA   1754
0073: SEMICOLON       003B
3617: seqReadFlag     F561   1440 2284 2433 2476 2595
2987: SetActualRecordAdd F29A   2464 2564
2991: SetActualRecordAdd1 F2A0   2994
1959: SetAllocBit     ED9B   1905
2295: SetAttributes   EF1E   1663
2298: SetAttributes1  EF23   2305
1767: SetCurrentDiskBit ECBE   1788
2010: SetDataDMA      EDCE   1208 1276 2040 2876
2014: SetDirDMA       EDD4   2038 2873
2232: SetDirectoryEntry EED2   1863 2738
1783: SetDiskReadOnly ECD1   1658 2205
2017: SetDMA          EDD7   2012
2005: SetEndDirectory EDC7   1835 2054 3112 3192
3205: SetFileWriteFlag F3C9   1542 2682 2742 3074
3212: SetLowReturnTo1 F3D0   2470 2490 2681
3407: SetMapBit       F482   1703
2209: SetNewCheckSum  EEBA   2198
1546: SetRandomRecord EBC7   1401
2268: SetRecordVars   EEF5   2441 2486 2674
0780: SetUserNumber   E918   0775
3360: ShiftLeftHLbyC  F461   1772
3362: ShiftLeftHLbyC0 F462   3366
3346: ShiftRightHLbyC F454   1807 2080 2425
3348: ShiftRightHLbyC0 F455   3358
0957: showCRLF        E9D3   0945 1080 3507
0942: showHashCRLF    E9BD   1101 1144
0946: showHashCRLF1   E9C5   0953
0069: SLASH           002F
0052: SOH             0001
0057: SPACE           0020   0813 0855 0885 0951 1135 1145 1147
0288: STACK_SIZE      0020   3640
3640: stackBottom     F575
1166: startingColumn  EABD   0948 0968 1124
2243: StillInDirectory EEDB   2203 2233 3131
0258: SystemSectors   0011   0259
0054: TAB             0009   0809 0850
0848: TabOut          E955   0503 0525 0825 0835
0854: TabOut0         E95B   0859
2923: TestLeft        F24F   2954
2937: TestRight       F260   2926
0920: ToggleFlag1     E9A6   0918
0120: TopRAM          0007
0255: TotalNumberOfBlocks 02D0
0254: TotalNumberOfSectors 0B40   0255 0260
0132: TPA             0100
0244: TracksPerHead   0050   0254
0025: TRUE            FFFF   0916 0937 1088 1422 1752 1759 1838 2182 2438 2853 3029
0078: UNDER_SCORE     005F
2282: UpdateRecordVars EF0C   2467 2599 2612
1159: usersStack      EAB9   0339 0392
2323: vCloseFile      EF3D   0419
1393: vComputeFileSize EB19   0438
0496: vConsoleIn      E8AA   0403
0524: vConsoleOut     E8BB   0404
2358: vDeleteFile     EF6B   0422
0601: vDirectConIO    E8CE   0408
0610: vDirectConIO1   E8D6   0604
0287: VERSION         0020   0751 3448
2331: vFindFirst      EF43   0420
2348: vFindNext       EF5C   0421
1290: vGetAllocAddr   EAF4   0430
0724: vGetConsoleStatus E8FD   0413
1252: vGetCurrentDisk EAE4   0428
1324: vGetDiskParamBlock EB02   0434
0633: vGetIOBYTE      E8E4   0409
1229: vGetLoginVector EADD   0427
1309: vGetReadOnlyMap EAFB   0432
0772: vGetSetUserNumber E90A   0435
0750: vGetVersion     E904   0415
0578: vListOut        E8CA   0407
2383: vMakeFile       EF82   0425
2316: vOpenFile       EF34   0418
0676: vPrintString    E8F0   0411
0563: vPunchOut       E8C6   0406
0544: vReaderIn       E8BF   0405
1374: vReadRandom     EB0D   0436
2366: vReadSeq        EF74   0423
0709: vReadString     E8F9   0412
2392: vRenameFile     EF8B   0426
1352: vResetDrive     EB09   0440
1199: vResetSystem    EAC4   0416
1360: vSelectDisk     EB0A   0417
1273: vSetDMA         EAEB   0429
1661: vSetFileAttributes EC46   0433
0653: vSetIOBYTE      E8EB   0410
1400: vSetRandomRecord EB1F   0439
0464: vSystemReset    E8A7   0402
1657: vWriteProtectDisk EC43   0431
1386: vWriteRandom    EB13   0437
1414: vWriteRandom0Fill EB23   0443
2374: vWriteSeq       EF7B   0424
3500: waitB4boot      F4EC   3490 3494
0112: WarmBoot        0000   0930 1039 3485 3502
0032: WORD            0002   1170 1172
0192: WriteAllocated  0000   2497
2884: WriteBuffer     F22F   2568 2875
0194: WriteCleanBuffer 0002   2553
2871: WriteDir        F221   2759 2867 3262
0193: WriteDirectory  0001
3548: writeFlagMask   0080   2771 3207
3649: Z_HighestLocation F5B5   3650
3650: Z_MemoryLeft    004A
0036: ZERO            0000
