0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process vReadSeq - 14 (20)
0005: E800
0006: E800         ; 2019-02-04 Fixed bdosStack problem
0007: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0008: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0009: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0010: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0011: E800         ; 2018-03-02 Refactored the CP/M Suite
0012: E800         ; 2018-02-12 fixed allocate 16 bit problem
0013: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0014: E800         ; 2014-03-14  :  Frank Martyn
0015: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0016: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.asm
0023: E800         ; standard equates
0024: E800
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; not false
0029: E800             FALSE      EQU    0000H
0030: E800             ON         EQU    -1
0031: E800             OFF        EQU    0000H
0032: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0033: E800
0034: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0035: E800             WORD       EQU    2                    ; number of bytes for "word" type
0036: E800
0037: E800
0038: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0039: E800             ZERO       EQU    00H                  ; Zero
0040: E800             EndOfMessage EQU    00H
0041: E800
0042: E800             CTRL_C     EQU    03H                  ; ETX
0043: E800             CTRL_E     EQU    05H                  ; physical eol
0044: E800             CTRL_H     EQU    08H                  ; backspace
0045: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0046: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0047: E800             CTRL_P     EQU    10H                  ; prnt toggle
0048: E800             CTRL_R     EQU    12H                  ; repeat line
0049: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0050: E800             CTRL_U     EQU    15H                  ; line delete
0051: E800             CTRL_X     EQU    18H                  ; =ctl-u
0052: E800             CTRL_Z     EQU    1AH                  ; end of file
0053: E800
0054: E800             NULL       EQU    00H                  ; Null
0055: E800             SOH        EQU    01H                  ; Start of Heading
0056: E800             BELL       EQU    07H                  ; Bell
0057: E800             TAB        EQU    09H                  ; Tab
0058: E800             LF         EQU    0AH                  ; Line Feed
0059: E800             CR         EQU    0DH                  ; Carriage Return
0060: E800             SPACE      EQU    20H                  ; Space
0061: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0062: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0064: E800             PERCENT    EQU    25H                  ; Percent Sign
0065: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0066: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0067: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0068: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0069: E800             COMMA      EQU    2CH                  ; Comma
0070: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0071: E800             PERIOD     EQU    2EH                  ; Period
0072: E800             SLASH      EQU    2FH                  ; /
0073: E800             ASCII_ZERO EQU    30H                  ; zero
0074: E800             COLON      EQU    3AH                  ; Colon
0075: E800
0076: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0077: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0078: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0079: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0080: E800             QMARK      EQU    3FH                  ; Question Mark
0081: E800             UNDER_SCORE EQU    5FH                  ; under score _
0082: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0083: E800             RUBOUT     EQU    7FH                  ; Delete Key
0084: E800
0085: E800
0086: E800             ASCII_A    EQU    'A'
0087: E800             ASCII_C    EQU    'C'
0088: E800             ASCII_K    EQU    'K'
0089: E800             ASCII_N    EQU    'N'
0090: E800             ASCII_Q    EQU    'Q'
0091: E800             ASCII_R    EQU    'R'
0092: E800             ASCII_W    EQU    'W'
0093: E800             ASCII_Y    EQU    'Y'
0094: E800             CARET      EQU    '^'
0095: E800             ASCII_LO_A EQU    'a'
0096: E800             ASCII_LO_K EQU    'k'
0097: E800             ASCII_LO_P EQU    'p'
0098: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0099: E800
0100: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E800                        Include ./osHeader.Z80
0102: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0103: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0104: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0105: E800         ; osHeader.Z80
0106: E800
0107: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0108: E800         ; 2017-03-02 Refactored the CP/M Suite
0109: E800
0110: E800         ; Contains the Equates used by the CP/M system
0111: E800
0112: E800         ;------------------------Page Zero Constants ---------------------------------
0113: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0114: E800
0115: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0116: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0117: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0118: E800
0119: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0120: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0121: E800
0122: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0123: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0124: E800
0125: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0126: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0127: E800
0128: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0129: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0130: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0131: E800         ;-----------------------------------------------------------------------
0132: E800
0133: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0134: E800         ;-----------------------------------------------------------------------
0135: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0136: E800         ;-----------------------------------------------------------------------
0137: E800             END_OF_FILE EQU    1AH                  ; end of file
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;--------------- CP/M Constants -----------------------------------------
0141: E800
0142: E800             CCPLength  EQU    0800H                ; Constant
0143: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0144: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0145: E800
0146: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0147: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0148: E800
0149: E800             MemorySize EQU    64
0150: E800
0151: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0152: E800
0153: E800             BDOSBase   EQU    CCPEntry + CCPLength
0154: E800             BDOSEntry  EQU    BDOSBase
0155: E800
0156: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0157: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0158: E800         ;-----------------------------------------------------------------------
0159: E800
0160: E800         ;------------------- BDOS System Call Equates --------------------------
0161: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0162: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0163: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0164: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0165: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0166: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0167: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0168: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0169: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0170: E800             fCloseFile EQU    10H                  ; closef - Close File
0171: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0172: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0173: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0174: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0175: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0176: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0177: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0178: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0179: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0180: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0181: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0182: E800         ;-----------------------------------------------------------------------
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800
0188: E800         ;*******************************************************************************
0189: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0190: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0191: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0192: E800         ; sector write) or to an allocation block that has already been allocated to a
0193: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0194: E800         ;*******************************************************************************
0195: E800             WriteAllocated EQU    00H
0196: E800             WriteDirectory EQU    01H
0197: E800             WriteCleanBuffer EQU    02H
0198: E800
0199: E800
0200: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E800                        Include ./diskHeader.Z80
0202: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0203: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0204: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0205: E800         ; diskHeader.asm
0206: E800
0207: E800         ; 2017-03-02 Refactored the CP/M Suite
0208: E800
0209: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0210: E800
0211: E800         ; Contains the Equates used by the CP/M system to handle disks
0212: E800
0213: E800
0214: E800         ;*******************************************************************************
0215: E800         ;
0216: E800         ;     Disk related values
0217: E800         ;
0218: E800         ;
0219: E800         ;*******************************************************************************
0220: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0221: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0222: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0223: E800         ; for boot
0224: E800             DiskControlTable EQU    0040H
0225: E800
0226: E800             DiskReadCode EQU    01H                  ; Code for Read
0227: E800             DiskWriteCode EQU    02H                  ; Code for Write
0228: E800
0229: E800
0230: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0231: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0232: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0233: E800
0234: E800             DirEntrySize EQU    20H                  ; (32)
0235: E800             DirBuffSize EQU    cpmRecordSize
0236: E800
0237: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0238: E800
0239: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0240: E800
0241: E800
0242: E800         ;-------------------------------------------------------------------------------------
0243: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0244: E800
0245: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0246: E800             NumberOfHeads EQU    02H                  ; number of heads
0247: E800             TracksPerHead EQU    50H                  ; 80
0248: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0249: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0250: E800             DirectoryBlockCount EQU    02H                  ;
0251: E800         ;-----------------------------------------------------------------------
0252: E800
0253: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0254: E800
0255: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0256: E800
0257: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0258: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0259: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0260: E800
0261: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0262: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0263: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0264: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0265: E800
0266: E800         ;-----------------------------------------------------------------------
0267: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0268: E800         ;-----------------------------------------------------------------------
0269: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0270: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0271: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0272: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0273: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0274: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0275: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0276: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0277: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0278: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0279: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0280: E800             dpb3hdNOH  EQU    NumberOfHeads
0281: E800
0282: E800         ;*******************************************************************************
0283: E800
0284: E800             SectorMask EQU    SectorsPerBlock - 1
0285: E800
0286: E800         ;***************************************************************************
0287: E800
0288: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0289: E800
0290: E800             VERSION    EQU    20H                  ; Version 2.0
0291: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0292: E800             EOD        EQU    -1                   ; End of Directory
0293: E800
0294: E800         ;************************ BIOS Function Constants ***************************;
0295: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0296: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0297: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0298: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0299: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0300: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0301: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0302: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0303: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0304: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0305: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0306: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0307: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0308: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0309: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0310: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0311: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0312: E800         ;************************ BIOS Function Constants ***************************;
0313: E800
0314: E800         ;============================================================================;
0315: E800         ;	BDOS                                                                     ;
0316: E800         ; Calling into   :                                                           ;
0317: E800         ;					Register  C - Contains BDOS Function Code                ;
0318: E800         ;					Register  A - Holds the Byte argument if any             ;
0319: E800         ;					Register DE - Holds the Word argument if any             ;
0320: E800         ; Returning from :                                                           ;
0321: E800         ;					Register  A - The Byte return value if any               ;
0322: E800         ;					Register HL - The Word return value if any               ;
0323: E800         ;                   ( Register A=L and B=H)                                  ;
0324: E800         ;============================================================================;
0325: E800
0326: E800
0327: E800                        ORG    BDOSBase
0328: E800
0329: E800         ;===========================BDOS Entry=======================================;
0330: E800         ;BDOSEntry:                                                                  ;
0331: E800         ;
0332: E800         ;
0333: E800             BdosStart:                      ;
0334: E800         ;	LD		A,C                                                              ;
0335: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0336: E800         ;
0337: E800         ; Save Calling Arguments                                                     ;
0338: E800 ED 53 C3 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0339: E804 7B                     LD     A,E                  ;
0340: E805 32 C2 EA               LD     (paramE),A           ; Save the Byte argument             ;
0341: E808         ; Save users Stack pointer                                                   ;
0342: E808 ED 73 BC EA               LD     (usersStack),SP      ; Save the User's stack				 ;
0343: E80C 31 B4 F5               LD     SP,bdosStack         ; We will use our own stack			 ;
0344: E80F         ;
0345: E80F         ; initialize variables                                                       ;
0346: E80F 21 00 00               LD     HL,0000H             ;
0347: E812 22 C5 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0348: E815 AF                     XOR    A                    ;
0349: E816 32 68 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0350: E819 32 66 F5               LD     (fResel),A           ; Clear re selection flag            ;
0351: E81C         ;
0352: E81C         ; Set up for return to caller when Function Completes                        ;
0353: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0354: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0355: E820         ;
0356: E820         ; is it a valid function number ?	                                         ;
0357: E820         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0358: E820 79                     LD     A,C                  ;
0359: E821 FE 28                  CP     functionCount        ; make sure its a good number        ;
0360: E823 D0                     RET    NC                   ; exit if not a valid function       ;
0361: E824         ;
0362: E824         ; Calculate the index and get vector to go to	                             ;
0363: E824 4B                     LD     C,E                  ; Assume byte argument               ;
0364: E825 21 57 E8               LD     HL,functionTable     ; Get table base                     ;
0365: E828 5F                     LD     E,A                  ; Function number in E               ;
0366: E829 16 00                  LD     D,0                  ;
0367: E82B 19                     ADD    HL,DE                ; Have byte location                 ;
0368: E82C 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0369: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0370: E82E 23                     INC    HL                   ;
0371: E82F 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0372: E830 EB                     EX     DE,HL                ; Vector now in HL                   ;
0373: E831         ;
0374: E831         ; Vector to Function is in HL                                                ;
0375: E831 E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0376: E832         ;===========================BDOS Entry=======================================;
0377: E832         ;===========================BDOS Exit =======================================;
0378: E832         ;arrive here at end of processing to return to user                          ;
0379: E832             ReturnToCaller:                      ;
0380: E832 3A 66 F5               LD     A,(fResel)           ; get re-selection flag              ;
0381: E835 B7                     OR     A                    ; is it set?                         ;
0382: E836 28 15                  JR     Z,ReturnToCaller1    ;
0383: E838         ;re-selection  may have taken place                                         ;
0384: E838 2A C3 EA               LD     HL,(paramDE)         ;
0385: E83B 36 00                  LD     (HL),0               ;
0386: E83D 3A 68 F5               LD     A,(fcbDisk)          ;
0387: E840 B7                     OR     A                    ; Disk = 0?                          ;
0388: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0389: E843         ;
0390: E843 77                     LD     (HL),A               ;
0391: E844 3A 67 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0392: E847 32 C2 EA               LD     (paramE),A           ; and select it                      ;
0393: E84A CD 36 ED               CALL   SelectCurrent        ;
0394: E84D         ;
0395: E84D             ReturnToCaller1:                      ;
0396: E84D 2A BC EA               LD     HL,(usersStack)      ;
0397: E850 F9                     LD     SP,HL                ; restore callers stack              ;
0398: E851 2A C5 EA               LD     HL,(exitParameterWord) ;
0399: E854 7D                     LD     A,L                  ;
0400: E855 44                     LD     B,H                  ; BA = exitParameterWord             ;
0401: E856 C9                     RET                         ;
0402: E857         ;===========================BDOS Exit =======================================;
0403: E857
0404: E857         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0405: E857             functionTable:                      ;
0406: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0407: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0408: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0409: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0410: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0411: E861 CD E8                  DW     vListOut             ;   5 - List Output                  ;
0412: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0413: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0414: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0415: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                 ;
0416: E86B FC E8                  DW     vReadString          ;   A - Read Console String          ;
0417: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0418: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0419: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0420: E871 C7 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0421: E873 E0 EA                  DW     vSelectDisk          ;   E - Select Disk                  ;
0422: E875 E3 EA                  DW     vOpenFile            ;   F - Open File                    ;
0423: E877 EC EA                  DW     vCloseFile           ;  10 - Close File                   ;
0424: E879 F2 EA                  DW     vFindFirst           ;  11 - Search For First             ;
0425: E87B 0B EB                  DW     vFindNext            ;  12 - Search for Next              ;
0426: E87D 1A EB                  DW     vDeleteFile          ;  13 - Delete File                  ;
0427: E87F 41 EB                  DW     vReadSeq             ;  14 - Read Sequential              ;
0428: E881 25 F3                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0429: E883 87 EB                  DW     vMakeFile            ;  16 - Make File                    ;
0430: E885 90 EB                  DW     vRenameFile          ;  17 - Rename File                  ;
0431: E887 BA EB                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0432: E889 C1 EB                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0433: E88B C8 EB                  DW     vSetDMA              ;  1A - Set DMA address              ;
0434: E88D D1 EB                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0435: E88F D8 EB                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0436: E891 DB EB                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0437: E893 E2 EB                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0438: E895 FD EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0439: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0440: E899 59 EC                  DW     vReadRandom          ;  21 - Read Random                  ;
0441: E89B 5F EC                  DW     vWriteRandom         ;  22 - Write Random                 ;
0442: E89D 04 EC                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0443: E89F 43 EC                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0444: E8A1 56 EC                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0445: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0446: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0447: E8A7 65 EC                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0448: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0449: E8A9         ;
0450: E8A9             DUMMY:                          ;
0451: E8A9 76                     HALT                        ;
0452: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0453: E8AA
0454: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0455: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0456: E8AA         ; same as the warm boot function invoked when you transfer control to the    ;
0457: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0458: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0459: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0460: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0461: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0462: E8AA         ;																			 ;
0463: E8AA         ;			Function Code	 :	C = 00H                                      ;
0464: E8AA         ;			Entry Parameters:	None                                         ;
0465: E8AA         ;			Exit Parameters :	Does Not Return								 ;
0466: E8AA         ;																			 ;
0467: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0468: E8AA             vSystemReset:
0469: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0470: E8AD
0471: E8AD         ;****************************************************************************;
0472: E8AD         ;								IOByte device I/O							 ;
0473: E8AD         ;****************************************************************************;
0474: E8AD
0475: E8AD
0476: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0477: E8AD         ;  This function reads the next byte of data from the console keyboard and   ;
0478: E8AD         ; puts it into register A. If the character input is a graphic character, it ;
0479: E8AD         ; will be echoed back to the console. The only control characters that are   ;
0480: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0481: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0482: E8AD         ; move the cursor to the next multiple of eight columns. All of the other    ;
0483: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0484: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0485: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0486: E8AD         ; console output should also be sent to the list device. If CONTROL-S is     ;
0487: E8AD         ; found, further output will be suspended until you type another character.  ;
0488: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0489: E8AD         ; pressed and disable it the second time. If there is no incoming data       ;
0490: E8AD         ; character, this function will wait until there is one.                     ;
0491: E8AD         ;                                                                            ;
0492: E8AD         ; This is a blocking function                                                ;
0493: E8AD         ;																			 ;
0494: E8AD         ;																			 ;
0495: E8AD         ;			Function Code	:	C = 01H                                      ;
0496: E8AD         ;			Entry Parameters:	None                                         ;
0497: E8AD         ;			Exit Parameters :	A = Data byte from console					 ;
0498: E8AD         ;																			 ;
0499: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0500: E8AD             vConsoleIn:
0501: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0502: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0503: E8B3 D8                     RET    C                    ; return nothing to echo
0504: E8B4
0505: E8B4 F5                     PUSH   AF                   ; Save printable character
0506: E8B5 4F                     LD     C,A
0507: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0508: E8B9 F1                     POP    AF                   ; retrieve exit value
0509: E8BA
0510: E8BA 32 C5 EA               LD     (exitParameterByte),A
0511: E8BD C9                     RET
0512: E8BE
0513: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0514: E8BE         ;  This function outputs the data byte in register E to the console. As with ;
0515: E8BE         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0516: E8BE         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0517: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0518: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0519: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0520: E8BE         ; printer is  toggled on or off                                              ;
0521: E8BE         ;																			 ;
0522: E8BE         ;			Function Code	:	C = 02H                                      ;
0523: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0524: E8BE         ;			Exit Parameters :	None										 ;
0525: E8BE         ;																			 ;
0526: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0527: E8BE         ;BDOS put parameter in C before entering this routine
0528: E8BE             vConsoleOut:
0529: E8BE CD 58 E9               CALL   TabOut
0530: E8C1 C9                     RET
0531: E8C2
0532: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0533: E8C2         ;   function reads the next character from the logical "reader" device into  ;
0534: E8C2         ; register A. In practice, the physical device that is accessed depends      ;
0535: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0536: E8C2         ; reader at all; this function will return some arbitrary value such as lAH  ;
0537: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0538: E8C2         ; Control is not returned to the calling program until a character has been  ;
0539: E8C2         ; read.                                                                      ;
0540: E8C2         ;                                                                            ;
0541: E8C2         ; This is a blocking function                                                ;
0542: E8C2         ;																			 ;
0543: E8C2         ;			Function Code	:	C = 03H                                      ;
0544: E8C2         ;			Entry Parameters:	None										 ;
0545: E8C2         ;			Exit Parameters :	A = Character Input							 ;
0546: E8C2         ;																			 ;
0547: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0548: E8C2             vReaderIn:
0549: E8C2 CD 15 F6               CALL   bcReader
0550: E8C5 32 C5 EA               LD     (exitParameterWord),A
0551: E8C8 C9                     RET
0552: E8C9
0553: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0554: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0555: E8C9         ; specified character from register E to the logical punch device. Again,    ;
0556: E8C9         ; the actual physical device used, if any, is determined by the BIOS.        ;
0557: E8C9         ; There is no set standard for this device; in some systems the punch        ;
0558: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0559: E8C9         ; output to it.                                                              ;
0560: E8C9         ;																			 ;
0561: E8C9         ;			Function Code	:	C = 04H                                      ;
0562: E8C9         ;			Entry Parameters:	E = Data byte to be output					 ;
0563: E8C9         ;			Exit Parameters :	None										 ;
0564: E8C9         ;																			 ;
0565: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0566: E8C9         ;BDOS put parameter in C before entering this routine
0567: E8C9             vPunchOut:
0568: E8C9 CD 12 F6               CALL   bcPunch
0569: E8CC C9                     RET
0570: E8CD
0571: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0572: E8CD         ;  This function outputs the specified byte in register E to the logical     ;
0573: E8CD         ; list device. As with the reader and the punch, the physical device used    ;
0574: E8CD         ; depends entirely on the BIOS.                                              ;
0575: E8CD         ;																			 ;
0576: E8CD         ;			Function Code	:	C = 05H                                      ;
0577: E8CD         ;			Entry Parameters:	E = Data byte to be output					 ;
0578: E8CD         ;			Exit Parameters :	None										 ;
0579: E8CD         ;																			 ;
0580: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0581: E8CD         ;BDOS put parameter in C before entering this routine
0582: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0583: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0584: E8D0 C9                     RET
0585: E8D1
0586: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0587: E8D1         ;  This function serves double duty: it both inputs and outputs characters   ;
0588: E8D1         ; from the console. However, it bypasses the normal control characters and   ;
0589: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0590: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0591: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0592: E8D1         ; then E contains a valid ASCII character that is output to the console.     ;
0593: E8D1         ;  This function works well provided you never have to send a value ofOFFH   ;
0594: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0595: E8D1         ; binary data, you cannot use this function, since these values are likely   ;
0596: E8D1         ; to be part of the data stream.                                             ;
0597: E8D1         ;                                                                            ;
0598: E8D1         ;			Function Code	:	C = 06H                                      ;
0599: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0600: E8D1         ;								E = Other than 0FFH for Output				 ;
0601: E8D1         ;			Exit Parameters :	A = Input byte or status					 ;
0602: E8D1         ;																			 ;
0603: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0604: E8D1         ;BDOS put parameter in C before entering this routine
0605: E8D1             vDirectConIO:
0606: E8D1 79                     LD     A,C
0607: E8D2 3C                     INC    A
0608: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0609: E8D5         ; send byte to console
0610: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0611: E8D8 C9                     RET
0612: E8D9
0613: E8D9         ;read byte/status from console
0614: E8D9             vDirectConIO1:
0615: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0616: E8DC B7                     OR     A                    ; 00 means not data ready
0617: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0618: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0619: E8E3 32 C5 EA               LD     (exitParameterByte),A ; Save it
0620: E8E6 C9                     RET
0621: E8E7
0622: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0623: E8E7         ; This function places the current value of the IOBYTE in register A.        ;
0624: E8E7         ;                                                                            ;
0625: E8E7         ; The IOBYTE structure:                                                      ;
0626: E8E7         ;								+-------+-------+-------+-------+            ;
0627: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0628: E8E7         ;								+-------+-------+-------+-------+            ;
0629: E8E7         ;				Logical Device     List | Punch | Reader|Console             ;
0630: E8E7         ;                                                                            ;
0631: E8E7         ;                                                                            ;
0632: E8E7         ;			Function Code	:	C = 07H                                      ;
0633: E8E7         ;			Entry Parameters:	None					  		  			 ;
0634: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0635: E8E7         ;																			 ;
0636: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0637: E8E7             vGetIOBYTE:
0638: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0639: E8EA 32 C5 EA               LD     (exitParameterWord),A ; Return it to caller
0640: E8ED C9                     RET
0641: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0642: E8EE         ; This function sets the IOBYTE         									 ;
0643: E8EE         ;                                                                            ;
0644: E8EE         ; The IOBYTE structure:                                                      ;
0645: E8EE         ;								+-------+-------+-------+-------+            ;
0646: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0647: E8EE         ;								+-------+-------+-------+-------+            ;
0648: E8EE         ;				Logical Device     List | Punch | Reader|Console             ;
0649: E8EE         ;                                                                            ;
0650: E8EE         ;                                                                            ;
0651: E8EE         ;			Function Code	:	C = 08H                                      ;
0652: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0653: E8EE         ;			Exit Parameters :	None                                         ;
0654: E8EE         ;																			 ;
0655: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0656: E8EE         ;BDOS put parameter in C before entering this routine
0657: E8EE             vSetIOBYTE:
0658: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0659: E8F1 71                     LD     (HL),C               ; Place new vale in it
0660: E8F2 C9                     RET
0661: E8F3
0662: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0663: E8F3         ;  This function outputs a string of characters to the console device. The   ;
0664: E8F3         ; address of this string is in registers DE. You must make sure that the last;
0665: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0666: E8F3         ; for the end of the string.                                                 ;
0667: E8F3         ;  The "$" itself does not get output to the console.                        ;
0668: E8F3         ;                                                                            ;
0669: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0670: E8F3         ; described, checks to see if there is an incoming character, and checks for ;
0671: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0672: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0673: E8F3         ; the printer).                                                              ;
0674: E8F3         ;                                                                            ;
0675: E8F3         ;			Function Code	:	C = 09H                                      ;
0676: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0677: E8F3         ;			Exit Parameters :	None							             ;
0678: E8F3         ;																			 ;
0679: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0680: E8F3             vPrintString:
0681: E8F3 2A C3 EA               LD     HL,(paramDE)         ; Get address of the string
0682: E8F6 4D                     LD     C,L
0683: E8F7 44                     LD     B,H                  ; Put it into BC for call
0684: E8F8 CD 3B E9               CALL   Print                ; out to console
0685: E8FB C9                     RET
0686: E8FC
0687: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0688: E8FC         ;  This function reads a string of characters from the console device        ;
0689: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0690: E8FC         ; editing is possible: the operator can backspace, cancel the line and start ;
0691: E8FC         ; over, and use all the normal control functions. What you will ultimately   ;
0692: E8FC         ; see in the buffer is the final version of the character string entered,    ;
0693: E8FC         ; without any of the errors or control characters used to do the line editing;
0694: E8FC         ;                                                                            ;
0695: E8FC         ;  The buffer that you define has a special format. The first byte in the    ;
0696: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0697: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0698: E8FC         ; were actually placed in the buffer. The following bytes contain            ;
0699: E8FC         ; the characters of the string. Character input will cease either when a     ;
0700: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0701: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0702: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0703: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0704: E8FC         ; the "characters input" byte to O. If you attempt to input more than the    ;
0705: E8FC         ; maximum number of characters, the "characters input" count will be the     ;
0706: E8FC         ; same as the maximum value allowed.                                         ;
0707: E8FC         ;                                                                            ;
0708: E8FC         ;			Function Code	:	C = 0AH                                      ;
0709: E8FC         ;			Entry Parameters:	DE = Address string buffer					 ;
0710: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0711: E8FC         ;																			 ;
0712: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0713: E8FC             vReadString:
0714: E8FC CD E0 E9               CALL   ReadString
0715: E8FF C9                     RET
0716: E900
0717: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0718: E900         ; This function tells you whether a console input character is waiting to be ;
0719: E900         ;processed. Unlike the Console Input functions, which will wait until there  ;
0720: E900         ;is input,this function simply checks and returns immediately.               ;
0721: E900         ;                                                                            ;
0722: E900         ;			Function Code	:	C = 0BH                                      ;
0723: E900         ;			Entry Parameters:	None										 ;
0724: E900         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0725: E900         ;								A = FFH	if incoming Data					 ;
0726: E900         ;																			 ;
0727: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0728: E900             vGetConsoleStatus:
0729: E900 CD 8C E9               CALL   ConBreak
0730: E903 32 C5 EA               LD     (exitParameterByte),A
0731: E906 C9                     RET
0732: E907
0733: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0734: E907         ;  This function tells you which version of CP/M you are currently running.  ;
0735: E907         ; A two-byte value is returned:                                              ;
0736: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0737: E907         ;	L = OOH for all releases before CP/M 2.0                                 ;
0738: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0739: E907         ;		and so on for any subsequent releases.                               ;
0740: E907         ;                                                                            ;
0741: E907         ; This information is of interest only if your program has some version      ;
0742: E907         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0743: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0744: E907         ; Therefore, if your program uses Random I/O, put this check at the          ;
0745: E907         ; beginning to ensure that it is indeed running under the appropriate        ;
0746: E907         ; version of CP/M.                                                           ;
0747: E907         ;                                                                            ;
0748: E907         ;			Function Code	:	C = 0CH                                      ;
0749: E907         ;			Entry Parameters:	None										 ;
0750: E907         ;			Exit Parameters :	HL =Version Number Code						 ;
0751: E907         ;								A = FFH	if incoming Data					 ;
0752: E907         ;																			 ;
0753: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0754: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0755: E907 3E 20                  LD     A,VERSION
0756: E909 32 C5 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0757: E90C C9                     RET
0758: E90D
0759: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0760: E90D         ;  This subroutine either sets or gets the current user number. The current  ;
0761: E90D         ; user number determines which file directory entries are matched during all ;
0762: E90D         ; disk file operations. When you call this function, the contents of the     ;
0763: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0764: E90D         ; will return the current user number in the A register. If you set E to a   ;
0765: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0766: E90D         ; will set the current user number to this value.                            ;
0767: E90D         ;                                                                            ;
0768: E90D         ;			Function Code	:	C = 0CH                                      ;
0769: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0770: E90D         ;								  = 0 to 15 to set User Number				 ;
0771: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0772: E90D         ;								A = FFH	if incoming Data					 ;
0773: E90D         ;																			 ;
0774: E90D         ;                                                                            ;
0775: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0776: E90D             vGetSetUserNumber:
0777: E90D 3A C2 EA               LD     A,(paramE)
0778: E910 FE FF                  CP     0FFH
0779: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0780: E914 3A 35 F5               LD     A,(currentUserNumber)
0781: E917 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0782: E91A C9                     RET
0783: E91B
0784: E91B             SetUserNumber:
0785: E91B E6 0F                  AND    LO_NIBBLE_MASK
0786: E91D 32 35 F5               LD     (currentUserNumber),A
0787: E920 C9                     RET
0788: E921
0789: E921         ;****************************************************************************;
0790: E921         ;								Character Support Routines					 ;
0791: E921         ;****************************************************************************;
0792: E921
0793: E921
0794: E921         ;-------------------- Return a Character from the console -------------------;
0795: E921         ;return byte from buffer or read from the console                            ;
0796: E921             ConIn:                          ;
0797: E921 21 BE EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0798: E924 7E                     LD     A,(HL)               ;
0799: E925 36 00                  LD     (HL),0               ;
0800: E927 B7                     OR     A                    ;
0801: E928 C0                     RET    NZ                   ;
0802: E929         ;
0803: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0804: E92C         ;-------------------- Return a Character from the console -------------------;
0805: E92C
0806: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0807: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0808: E92C             IsPrintableASCII:                      ;
0809: E92C FE 0D                  CP     CR                   ;
0810: E92E C8                     RET    Z                    ; carriage return?                                                  ;
0811: E92F FE 0A                  CP     LF                   ;
0812: E931 C8                     RET    Z                    ; line feed?                                                        ;
0813: E932 FE 09                  CP     TAB                  ;
0814: E934 C8                     RET    Z                    ; TAB?                                                              ;
0815: E935 FE 08                  CP     CTRL_H               ;
0816: E937 C8                     RET    Z                    ; backspace?                                                        ;
0817: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0818: E93A C9                     RET                         ;
0819: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0820: E93B
0821: E93B         ;------------------ Print character from (BC) until  $ found ----------------;
0822: E93B             Print:                          ;
0823: E93B 0A                     LD     A,(BC)               ; Get the next character             ;
0824: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0825: E93E C8                     RET    Z                    ;  exit if yes                       ;
0826: E93F 03                     INC    BC                   ; Update the pointer                 ;
0827: E940 C5                     PUSH   BC                   ; Save it                            ;
0828: E941 4F                     LD     C,A                  ; Does Byte require                  ;
0829: E942 CD 58 E9               CALL   TabOut               ;  special attention - check         ;
0830: E945 C1                     POP    BC                   ; Retrieve the pointer				 ;
0831: E946 18 F3                  JR     Print                ; Loop back                          ;
0832: E948         ;------------------ Print character from (BC) until  $ found ----------------;
0833: E948
0834: E948         ;-- Send printable character to console. Precede with Caret if needed -------;
0835: E948         ; character is in Reg C                                                      ;
0836: E948             CaretOut:                       ;
0837: E948 79                     LD     A,C                  ;
0838: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0839: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0840: E94E         ; send preceding up arrow                                                    ;
0841: E94E F5                     PUSH   AF                   ; Save the character                 ;
0842: E94F 0E 5E                  LD     C,CARET              ;
0843: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0844: E954 F1                     POP    AF                   ; Get the character                  ;
0845: E955 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0846: E957 4F                     LD     C,A                  ; Set up to print                    ;
0847: E958         ; fall thru to TabbOut                                                       ;
0848: E958         ;-- Send printable character to console. Precede with Caret if needed -------;
0849: E958
0850: E958         ;------------- Send printable character to console. Expand if TAB -----------;
0851: E958         ; character is in Reg C                                                      ;
0852: E958             TabOut:                         ;
0853: E958 79                     LD     A,C                  ;
0854: E959 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0855: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0856: E95E         ;
0857: E95E         ; TAB encountered                                                           ;
0858: E95E             TabOut0:                        ;
0859: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0860: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                    ;
0861: E963 3A C1 EA               LD     A,(columnPosition)   ; Get Column position                ;
0862: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0863: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0864: E96A C9                     RET                         ;
0865: E96B         ;------------- Send printable character to console. Expand if TAB -----------;
0866: E96B
0867: E96B         ;-------------------------- Send character to console -----------------------;
0868: E96B         ; C  = Character to be output                                                ;
0869: E96B             ConsoleOut:                      ;
0870: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0871: E96B C5                     PUSH   BC                   ; Save character and Count           ;
0872: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0873: E96F C1                     POP    BC                   ;
0874: E970 C5                     PUSH   BC                   ; Get/save character                 ;
0875: E971         ; Send character to Console	                                                 ;
0876: E971 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0877: E974 C1                     POP    BC                   ;
0878: E975 C5                     PUSH   BC                   ; Get/save character                 ;
0879: E976         ; is the data to be output to print device?                                  ;
0880: E976 3A BF EA               LD     A,(printEchoFlag)    ;
0881: E979 B7                     OR     A                    ;
0882: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0883: E97D C1                     POP    BC                   ; Get the character                  ;
0884: E97E         ;
0885: E97E 79                     LD     A,C                  ; Put character to ACC               ;
0886: E97F 21 C1 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0887: E982 34                     INC    M                    ; increment the ColumnPosition       ;
0888: E983         ;
0889: E983 FE 20                  CP     SPACE                ;
0890: E985 D0                     RET    NC                   ; Exit if ASCII printable            ;
0891: E986         ;
0892: E986 FE 0A                  CP     LF                   ;
0893: E988 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0894: E989         ;
0895: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0896: E98B C9                     RET                         ;
0897: E98C         ;-------------------------- Send character to console -----------------------;
0898: E98C
0899: E98C         ;--------------------  Check for Status and Control S or C ------------------;
0900: E98C         ;  Returns:																	 ;
0901: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0902: E98C         ;			ACC = 00   No data Pending										 ;
0903: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0904: E98C         ;                                                                            ;
0905: E98C             ConBreak:                       ;
0906: E98C 3A BE EA               LD     A,(keyboardByte)     ;
0907: E98F B7                     OR     A                    ; If there is a char waiting         ;
0908: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0909: E992         ;
0910: E992 CD 06 F6               CALL   bcConst              ; Get status                         ;
0911: E995 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0912: E997 C8                     RET    Z                    ; Return 00 No data pending          ;
0913: E998         ;
0914: E998 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0915: E99B         ;
0916: E99B FE 10                  CP     CTRL_P               ;
0917: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0918: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0919: E99F 21 BF EA               LD     HL,printEchoFlag     ;
0920: E9A2 3E FF                  LD     A,TRUE               ;
0921: E9A4 BE                     CP     (HL)                 ;
0922: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0923: E9A7 3E 00                  LD     A,FALSE              ;
0924: E9A9             ToggleFlag1:                      ;
0925: E9A9 77                     LD     (HL),A               ;
0926: E9AA 18 0C                  JR     NothingWaiting       ;
0927: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0928: E9AC             CheckCTL_S:                      ;
0929: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0930: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0931: E9B0         ;
0932: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0933: E9B3 FE 03                  CP     CTRL_C               ;
0934: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0935: E9B8             NothingWaiting:                      ;
0936: E9B8 AF                     XOR    A                    ;
0937: E9B9 C9                     RET                         ; Set ACC = 0 and return             ;
0938: E9BA             ConBreak0:                      ;
0939: E9BA 32 BE EA               LD     (keyboardByte),A     ; save the byte                      ;
0940: E9BD             ConBreak1:                      ;
0941: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0942: E9BF C9                     RET                         ;
0943: E9C0         ;--------------------  Check for Status and Control S or C ------------------;
0944: E9C0
0945: E9C0         ;------------------------  Console Output Utilities -------------------------;
0946: E9C0             showHashCRLF:                      ;
0947: E9C0 0E 23                  LD     C,HASH_TAG           ;
0948: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                  ;
0949: E9C5 CD D6 E9               CALL   showCRLF             ;
0950: E9C8             showHashCRLF1:                      ;
0951: E9C8 3E C1                  LD     A,columnPosition     ;
0952: E9CA 21 C0 EA               LD     HL,startingColumn    ;
0953: E9CD BF                     CP     A,M                  ;
0954: E9CE D0                     RET    NC                   ;
0955: E9CF 0E 20                  LD     C,SPACE              ;
0956: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0957: E9D4 18 F2                  JR     showHashCRLF1        ;
0958: E9D6         ;------------------------  Console Output Utilities -------------------------;
0959: E9D6
0960: E9D6         ;------------------------  Send Carriage Return and Line Feed ---------------;
0961: E9D6             showCRLF:                       ;
0962: E9D6 0E 0D                  LD     C,CR                 ;
0963: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0964: E9DB 0E 0A                  LD     C,LF                 ;
0965: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0966: E9E0         ;------------------------  Send Carriage Return and Line Feed ---------------;
0967: E9E0
0968: E9E0         ;------------------------- Read a $ terminated String -----------------------;
0969: E9E0         ;read to paramDE address (max length, current length, buffer)               ;
0970: E9E0             ReadString:                      ;
0971: E9E0 3A C1 EA               LD     A,(columnPosition)   ;
0972: E9E3 32 C0 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0973: E9E6 2A C3 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0974: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0975: E9EA 23                     INC    HL                   ; Point at actual bytes read         ;
0976: E9EB 06 00                  LD     B,0                  ; Initialize Current Count           ;
0977: E9ED         ;
0978: E9ED         ; B = Current Count                                                      ;
0979: E9ED         ; C = Maximum characters                                                 ;
0980: E9ED         ; HL= Insertion Pointer                                                  ;
0981: E9ED         ;
0982: E9ED         ; read next character, BC, HL active                                        ;
0983: E9ED             ReadNext:                       ;
0984: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0985: E9EE E5                     PUSH   HL                   ; Save pointer                       ;
0986: E9EF             ReadNext0:                      ;
0987: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character             ;
0988: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0989: E9F4 E1                     POP    HL                   ; Restore Pointer					 ;
0990: E9F5 C1                     POP    BC                   ; Restore Current Index and Max Count;
0991: E9F6         ;Is It Carriage Return                                                       ;
0992: E9F6 FE 0D                  CP     CR                   ;
0993: E9F8 CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0994: E9FB FE 0A                  CP     LF                   ;
0995: E9FD         ;Is It Linefeed                                                              ;
0996: E9FD CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0997: EA00         ;Is It BackSpace                                                             ;
0998: EA00 FE 08                  CP     CTRL_H               ;
0999: EA02 CA 48 EA               JP     Z,BSspaceBS          ;
1000: EA05             IsItRubout:                      ;
1001: EA05 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
1002: EA07 CA 52 EA               JP     Z,ItIsRubout         ;
1003: EA0A             IsPhysicalEOL:                      ;
1004: EA0A FE 05                  CP     CTRL_E               ;
1005: EA0C CA 5D EA               JP     Z,ItIsPhysicalEOL    ;
1006: EA0F             IsItPrintToggle:                      ;
1007: EA0F FE 10                  CP     CTRL_P               ;
1008: EA11 CA 65 EA               JP     Z,ItIsPrintToggle    ;
1009: EA14             IsItDeleteTheLineX:                      ;
1010: EA14 FE 18                  CP     CTRL_X               ;
1011: EA16 CA 8E EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1012: EA19             IsItDeleteTheLineU:                      ;
1013: EA19 FE 15                  CP     CTRL_U               ;
1014: EA1B CA AC EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1015: EA1E         ;Retype the line                                                             ;
1016: EA1E FE 12                  CP     CTRL_R               ;
1017: EA20 CA 75 EA               JP     Z,RepeatLine         ;
1018: EA23
1019: EA23         ;....................... Echo input back to the Console  ....................;
1020: EA23         ; Full Duplex								                                 ;
1021: EA23         ; A = Character to display	                                                 ;
1022: EA23         ; B = current char count                                                     ;
1023: EA23         ; C = maximum buffer length                                                  ;
1024: EA23         ; HL= buffer pointer                                                         ;
1025: EA23         ;ReadEcho                                                                    ;
1026: EA23 04                     INC    B                    ; Increment byte count		         ;
1027: EA24 23                     INC    HL                   ; Advance the Pointer                ;
1028: EA25 77                     LD     (HL),A               ; Put char in buffer                 ;
1029: EA26         ;
1030: EA26             ReadEchoRubOut:                      ;
1031: EA26 C5                     PUSH   BC                   ; Save index and length              ;
1032: EA27 E5                     PUSH   HL                   ; Save the Pointer                   ;
1033: EA28 4F                     LD     C,A                  ; Get char                           ;
1034: EA29 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1035: EA2C E1                     POP    HL                   ; Restore the Pointer                ;
1036: EA2D C1                     POP    BC                   ; Restore index and length           ;
1037: EA2E 7E                     LD     A,(HL)               ; Recall char                        ;
1038: EA2F         ; check for Warm Boot                                                        ;
1039: EA2F FE 03                  CP     CTRL_C               ;
1040: EA31 78                     LD     A,B                  ; Get Line position                  ;
1041: EA32 C2 3A EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1042: EA35 FE 01                  CP     1                    ; Beginning of the Line?             ;
1043: EA37 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1044: EA3A         ; Check to see if we are at the end of the buffer                            ;
1045: EA3A             AreWeAtEndOfBuffer:                      ;
1046: EA3A B9                     CP     C                    ; Over Max ?					     ;
1047: EA3B DA ED E9               JP     C,ReadNext           ;  no, Go for more				     ;
1048: EA3E         ;
1049: EA3E         ; At the end of read                                  					     ;
1050: EA3E             EndRead:                        ;
1051: EA3E         ; 	POP		HL                                                               ;
1052: EA3E 2A C3 EA               LD     HL,(paramDE)         ;
1053: EA41 23                     INC    HL                   ;
1054: EA42         ;
1055: EA42 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1056: EA43 0E 0D                  LD     C,CR                 ;
1057: EA45 C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1058: EA48         ;....................... Echo input back to the Console  ....................;
1059: EA48         ;.......................... Backspace SPACE BackSpace .......................;
1060: EA48             BSspaceBS:                      ;
1061: EA48 05                     DEC    B                    ;
1062: EA49 2B                     DEC    HL                   ;
1063: EA4A C5                     PUSH   BC                   ;
1064: EA4B E5                     PUSH   HL                   ;
1065: EA4C CD 9F EA               CALL   BackUp               ;
1066: EA4F C3 EF E9               JP     ReadNext0            ;
1067: EA52         ;.......................... Backspace SPACE BackSpace .......................;
1068: EA52         ;.......................... It is RubOut ....................................;
1069: EA52             ItIsRubout:                      ;
1070: EA52         ; RUBOUT if possible                                                         ;
1071: EA52 78                     LD     A,B                  ; Are we at the start of the line    ;
1072: EA53 B7                     OR     A                    ;
1073: EA54 CA ED E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1074: EA57         ;adjust pointers back one                                                    ;
1075: EA57 7E                     LD     A,(HL)               ; ACC = current character            ;
1076: EA58 05                     DEC    B                    ; Adjust the index			    	 ;
1077: EA59 2B                     DEC    HL                   ; Adjust the pointer                 ;
1078: EA5A C3 26 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1079: EA5D         ;.......................... It is RubOut ....................................;
1080: EA5D         ;.......................... It is PhysicalEOL ...............................;
1081: EA5D             ItIsPhysicalEOL:                      ;
1082: EA5D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1083: EA5E E5                     PUSH   HL                   ; Save pointer                       ;
1084: EA5F CD D6 E9               CALL   showCRLF             ; Make new line                      ;
1085: EA62 C3 EF E9               JP     ReadNext0            ;   and go for next char   			 ;
1086: EA65         ;.......................... It is PhysicalEOL ...............................;
1087: EA65         ;.......................... It is PrintToggle ...............................;
1088: EA65             ItIsPrintToggle:                      ;
1089: EA65 E5                     PUSH   HL                   ; Save pointer                       ;
1090: EA66         ; Toggle the printEcho Flag                                                  ;
1091: EA66 21 BF EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1092: EA69 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1093: EA6B BE                     CP     (HL)                 ; Is the flag true?                  ;
1094: EA6C 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1095: EA6E 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1096: EA70             IsItPrintToggle1:                      ;
1097: EA70 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1098: EA71 E1                     POP    HL                   ; Restore pointer                    ;
1099: EA72 C3 ED E9               JP     ReadNext             ;   and for another char             ;
1100: EA75         ;.......................... It is PrintToggle ...............................;
1101: EA75         ;.......................... RepeatLine ......................................;
1102: EA75             RepeatLine:                      ;
1103: EA75 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1104: EA76 E5                     PUSH   HL                   ;  for exit                          ;
1105: EA77 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1106: EA7A         ;
1107: EA7A 2A C3 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1108: EA7D 23                     INC    HL                   ; Skip past character count          ;
1109: EA7E         ;
1110: EA7E             LL1:                            ;
1111: EA7E 23                     INC    HL                   ; Point at next char to display      ;
1112: EA7F C5                     PUSH   BC                   ; Save counter, in B                 ;
1113: EA80 E5                     PUSH   HL                   ; Save buffer pointer                ;
1114: EA81 4E                     LD     C,M                  ; Get the next character             ;
1115: EA82 CD 48 E9               CALL   CaretOut             ; Display it                         ;
1116: EA85 E1                     POP    HL                   ; Restore                            ;
1117: EA86 C1                     POP    BC                   ;  the counter and pointer           ;
1118: EA87 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1119: EA89 E1                     POP    HL                   ; Restore values                     ;
1120: EA8A C1                     POP    BC                   ;  from routine entry                ;
1121: EA8B C3 ED E9               JP     ReadNext             ; Done here !                        ;
1122: EA8E         ;.......................... RepeatLine ......................................;
1123: EA8E         ;.......................... Delete The Line .................................;
1124: EA8E             DeleteTheLine:                      ;
1125: EA8E E1                     POP    HL                   ; Adjust Stack                       ;
1126: EA8F         ;                                             ;
1127: EA8F             DeleteTheLine1:                      ;
1128: EA8F 3A C0 EA               LD     A,(startingColumn)   ;
1129: EA92 21 C1 EA               LD     HL,columnPosition    ;
1130: EA95 BE                     CP     M                    ; Start of line ?                    ;
1131: EA96 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1132: EA99 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1133: EA9A CD 9F EA               CALL   BackUp               ; Clear 1 column                     ;
1134: EA9D 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1135: EA9F         ;.......................... Delete The Line .................................;
1136: EA9F         ;------------------------ Back-up one screen position -----------------------;
1137: EA9F             BackUp:                         ;
1138: EA9F CD A7 EA               CALL   BackUp1              ; Send Backspace                     ;
1139: EAA2 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1140: EAA4 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1141: EAA7         ;does not affect column count                                                ;
1142: EAA7             BackUp1:                        ;
1143: EAA7 0E 08                  LD     C,CTRL_H             ;
1144: EAA9 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1145: EAAC         ;------------------------ Back-up one screen position -----------------------;
1146: EAAC         ;.......................... Ignore The Line .................................;
1147: EAAC             IgnoreTheLine:                      ;
1148: EAAC CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1149: EAAF 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1150: EAB1 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1151: EAB4 0E 20                  LD     C,SPACE              ;
1152: EAB6 CD 0C F6               CALL   bcConout             ;
1153: EAB9 C3 E0 E9               JP     ReadString           ; Start all over                     ;
1154: EABC         ;.......................... Ignore The Line .................................;
1155: EABC
1156: EABC         ;------------------------- Read a $ terminated String -----------------------;
1157: EABC
1158: EABC         ;****************************************************************************
1159: EABC         ;                           DATA AREA                                       *
1160: EABC         ;****************************************************************************
1161: EABC
1162: EABC         ;------------------------------Non Disk Data Area ---------------------------;
1163: EABC             usersStack: DS     2                    ; entry stack pointer                ;
1164: EABE         ;
1165: EABE 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1166: EABF         ;
1167: EABF 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1168: EAC0         ;
1169: EAC0         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1170: EAC0 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1171: EAC1 00          columnPosition: DB     0                    ; Current Column position            ;
1172: EAC2         ;
1173: EAC2             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1174: EAC3             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1175: EAC5             exitParameterByte:                      ; Byte returned Value                ;
1176: EAC5             exitParameterWord: DS     WORD                 ; Word                           ;
1177: EAC7         ;
1178: EAC7         ;
1179: EAC7         ;------------------------------------ Data Area -----------------------------;
1180: EAC7
1181: EAC7
1182: EAC7
1183: EAC7         ;****************************************************************************;
1184: EAC7         ;								Disk I/O									 ;
1185: EAC7         ;****************************************************************************;
1186: EAC7
1187: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1188: EAC7         ;  This function requests CP/M to completely reset the disk file system.     ;
1189: EAC7         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1190: EAC7         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1191: EAC7         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1192: EAC7         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1193: EAC7         ; in each logical disk as each disk is accessed. This involves reading the   ;
1194: EAC7         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1195: EAC7         ; which keep track of which allocation blocks are free and which             ;
1196: EAC7         ; are used for file storage.                                                 ;
1197: EAC7         ;                                                                            ;
1198: EAC7         ;			Function Code	:	C = 0DH                                      ;
1199: EAC7         ;			Entry Parameters:	None										 ;
1200: EAC7         ;			Exit Parameters :	None										 ;
1201: EAC7         ;																			 ;
1202: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1203: EAC7             vResetSystem:
1204: EAC7 21 00 00               LD     HL,0
1205: EACA 22 38 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1206: EACD 22 3A F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1207: EAD0 AF                     XOR    A                    ; Clear the current disk
1208: EAD1 32 36 F5               LD     (currentDisk),A
1209: EAD4         ; note that currentUserNumber remains unchanged
1210: EAD4 21 80 00               LD     HL,DMABuffer
1211: EAD7 22 3C F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1212: EADA CD 4A EF               CALL   SetDataDMA           ; to data DMA address
1213: EADD C3 42 ED               JP     Select
1214: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1215: EAE0         ;  This function makes the logical disk named in register E the default disk;
1216: EAE0         ; All subsequent references to disk files that do not specify the disk will ;
1217: EAE0         ; use this default. When you reference a disk file that does have an        ;
1218: EAE0         ; explicit logical disk in its name you do not have to issue another        ;
1219: EAE0         ; Select Disk function; the BDOS will take care of that for you.            ;
1220: EAE0         ;                                                                           ;
1221: EAE0         ;  Notice the way in which the logical disk is specified in register E.     ;
1222: EAE0         ; It is not the same as the disk drive specification in the first byte of   ;
1223: EAE0         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1224: EAE0         ; "use the current default disk" (as specified in the last Select Disk      ;
1225: EAE0         ; call or by the operator on the console). With this function, a value      ;
1226: EAE0         ; of OOH in register A means that A is the selected drive, a value of       ;
1227: EAE0         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1228: EAE0         ; 16 drives in the system.                                                  ;
1229: EAE0         ;                                                                           ;
1230: EAE0         ;			Function Code	:	C = 0EH                                     ;
1231: EAE0         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1232: EAE0         ;			Exit Parameters :	None										;
1233: EAE0         ;																			;
1234: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1235: EAE0
1236: EAE0             vSelectDisk:
1237: EAE0 C3 36 ED               JP     SelectCurrent
1238: EAE3
1239: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1240: EAE3         ;  This function opens a specified file for reading or writing. The FCB,    ;
1241: EAE3         ; whose address must be in register DE, tells CP/M the user number,         ;
1242: EAE3         ; the logical disk, the file name, and the file type. All other bytes of    ;
1243: EAE3         ; the FCB will normally be set to O.                                        ;
1244: EAE3         ;  The code returned by the BDOS in register A indicates whether the file   ;
1245: EAE3         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1246: EAE3         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1247: EAE3         ; then the file has been opened.                                            ;
1248: EAE3         ;			Function Code	:	C  = 0FH                                    ;
1249: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1250: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1251: EAE3         ;																			;
1252: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1253: EAE3             vOpenFile:
1254: EAE3 CD 02 F0               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1255: EAE6 CD 83 EF               CALL   ReselectDisk         ; do we need to reselect disk?
1256: EAE9 C3 19 EE               JP     OpenFile
1257: EAEC
1258: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1259: EAEC         ;  This function terminates the processing of a file to which you have      ;
1260: EAEC         ; written information. Under CP/M you do not need to close a file that you  ;
1261: EAEC         ; have been reading. However, if you ever intend for your program to        ;
1262: EAEC         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1263: EAEC         ; should close all files regardless of their use.                           ;
1264: EAEC         ;  The Close File function, like Open File, returns a directory code in     ;
1265: EAEC         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1266: EAEC         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1267: EAEC         ; been closed.                                                              ;
1268: EAEC         ;                                                                           ;
1269: EAEC         ;  When the BDOS closes a file to which data has been written, it writes    ;
1270: EAEC         ; the current contents of the FCB out to the disk directory, updating       ;
1271: EAEC         ; an existing directory entry by matching the disk, name, type, and         ;
1272: EAEC         ; extent number in the same manner that the Open File function does.        ;
1273: EAEC         ; Note that the BDOS does not transfer the last record of the file to the   ;
1274: EAEC         ; disk during the close operation. It merely updates the file directory.    ;
1275: EAEC         ; You must arrange to flush any partly filled record to the disk. If the    ;
1276: EAEC         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1277: EAEC         ; arrange to fill the unused portion of the record with the standard lAH    ;
1278: EAEC         ; end-of-file characters as CP/M expects.                                   ;
1279: EAEC         ;                                                                           ;
1280: EAEC         ;			Function Code	:	C  = 10H                                    ;
1281: EAEC         ;			Entry Parameters:	DE = Address of File Control Block			;
1282: EAEC         ;			Exit Parameters :	A  = Directory Code							;
1283: EAEC         ;																			;
1284: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1285: EAEC             vCloseFile:
1286: EAEC CD 83 EF               CALL   ReselectDisk
1287: EAEF C3 5C EE               JP     CloseDirEntry
1288: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1289: EAF2         ;  This function scans down the file directory for the first entry that     ;
1290: EAF2         ; matches the file name, type, and extent in the FCB addressed by DE.       ;
1291: EAF2         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
1292: EAF2         ; more character positions. Where a "?" occurs, the BDOS will match any     ;
1293: EAF2         ; character in the corresponding position in the file directory. This is    ;
1294: EAF2         ; known as ambiguous file name matching.                                    ;
1295: EAF2         ;  The first byte of an FCB normally contains the logical disk number code. ;
1296: EAF2         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
1297: EAF2         ; and so on up to a possible maximum of 16 for disk P. However, if this     ;
1298: EAF2         ; byte contains a "?", the BDOS will search the default logical disk and    ;
1299: EAF2         ; will match the file name and type regardless of the user number. This     ;
1300: EAF2         ; function is normally used in conjunction with the Search Next function.   ;
1301: EAF2         ; Search First, in the process of matching a file, leaves certain           ;
1302: EAF2         ; variables in the BDOS set, ready for a subsequent Search Next.            ;
1303: EAF2         ;  Both Search First and Search Next return a directory code in the         ;
1304: EAF2         ; A register. With Search First, A = OFFH when no files match the FCB,      ;
1305: EAF2         ; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
1306: EAF2         ;                                                                           ;
1307: EAF2         ;  To locate the particular directory entry that either the Search First    ;
1308: EAF2         ; or Search Next function matched, multiply the directory code returned     ;
1309: EAF2         ; in A by the length of a directory entry (32 bytes). This is easily done   ;
1310: EAF2         ; by adding the A register to itself five times. Then add the DMA address   ;
1311: EAF2         ; to get the actual address where the matched directory entry is stored.    ;
1312: EAF2         ;  There are many occasions when you may need to write a program that will  ;
1313: EAF2         ; accept an ambiguous file name and operate on all of the file names that   ;
1314: EAF2         ; match it. (The DIR and ERA commands built into the CCP are examples that  ;
1315: EAF2         ; use ambiguous file names.) To do this, you must use several BDOS          ;
1316: EAF2         ; functions: the Set DMA Address function (code 26), this function          ;
1317: EAF2         ; (Search First), and Search Next (code 18). All of this is shown in the    ;
1318: EAF2         ; subroutine given in Figure 5-17.                                          ;
1319: EAF2         ;                                                                           ;
1320: EAF2         ;                                                                           ;
1321: EAF2         ;			Function Code	:	C  = 11H                                    ;
1322: EAF2         ;			Entry Parameters:	DE = Address of File Control Block			;
1323: EAF2         ;			Exit Parameters :	A  = Directory Code							;
1324: EAF2         ;																			;
1325: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1326: EAF2             vFindFirst:
1327: EAF2 0E 00                  LD     C,0                  ; Length assuming '?' true
1328: EAF4 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB
1329: EAF7 7E                     LD     A,(HL)               ; DIsk/User No
1330: EAF8 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1331: EAFA CA 05 EB               JP     Z,QMarkFind          ;  if Yes, skip disk reselect
1332: EAFD         ;  and reset of EXT
1333: EAFD
1334: EAFD CD 02 F0               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1335: EB00 CD 83 EF               CALL   ReselectDisk         ; Use FCB to set currentDisk
1336: EB03 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1337: EB05
1338: EB05             QMarkFind:
1339: EB05 CD 2E F0               CALL   SearchForDirectoryRecord ; Find the directory record
1340: EB08 C3 AB F1               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1341: EB0B
1342: EB0B         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1343: EB0B         ;	This function searches down the file directory for the next file name,  ;
1344: EB0B         ; type, and extent that match the FCB specified in a previous Search First  ;
1345: EB0B         ; function call. Search First and Search Next are the only BDOS functions   ;
1346: EB0B         ; that must be used together. As you can see, the Search Next function      ;
1347: EB0B         ; does not require an FCB address as an input parameter-all the necessary   ;
1348: EB0B         ; information will have been left in the BDOS on the Search First call.     ;
1349: EB0B         ; Like Search First, Search Next returns a directory code in the A register,;
1350: EB0B         ; in this case, if A = OFFH, it means that there are no more files that     ;
1351: EB0B         ; match the file control block. If A is not OFFH, it will be a value of     ;
1352: EB0B         ; 0, 1, 2, or 3, indicating the relative directory entry number.            ;
1353: EB0B         ;                                                                           ;
1354: EB0B         ;  There are two ways of using the Search First/ Next calls. Consider a     ;
1355: EB0B         ; simple file copying program that takes as input an ambiguous file name.   ;
1356: EB0B         ; You could scan the file directory, matching all of the possible file      ;
1357: EB0B         ; names, possibly displaying them on the console, and storing the names of  ;
1358: EB0B         ; the files to be copied in a table inside your program. This would have    ;
1359: EB0B         ; the advantage of enabling you to present the file names to the operator   ;
1360: EB0B         ; before any copying occurred. You could even arrange for the operator to   ;
1361: EB0B         ; select which files to copy on a file-by-file basis. One disadvantage      ;
1362: EB0B         ; would be that you could not accurately predict how many files might be    ;
1363: EB0B         ; selected. On some hard disk systems you might have to accommodate several ;
1364: EB0B         ; thousand file names.                                                      ;
1365: EB0B         ;  The alternative way of handling the problem would be to match one file   ;
1366: EB0B         ; name, copy it, then match the next file name, copy it, and so on. If you  ;
1367: EB0B         ; gave the operator the choice of selecting which files to copy, this person;
1368: EB0B         ; would have to wait at the terminal as each file was being copied, but the ;
1369: EB0B         ; program would not need to have large table areas set aside to hold file   ;
1370: EB0B         ; names. This solution to the problem is slightly more complicated, as you  ;
1371: EB0B         ; can see from the logic in Figure 5-17.                                    ;
1372: EB0B         ;  The subroutine in Figure 5-17, Get Next File (GNF), contains all of the  ;
1373: EB0B         ; necessary logic to search down a directory for both alternatives described;
1374: EB0B         ; It does require that you indicate on entry whether it should search for   ;
1375: EB0B         ; the first or next file match, by setting A to zero or some nonzero value  ;
1376: EB0B         ; respectively.                                                             ;
1377: EB0B         ;  You can see from Figure 5-17 that whenever the subroutine is called to   ;
1378: EB0B         ; get the next file, you must execute a Search First function to re-find    ;
1379: EB0B         ; the  previous file. Only then can a Search Next be issued. As with all    ;
1380: EB0B         ; functions that return a directory code in A, if this value is not OFFH, it;
1381: EB0B         ; will be the relative directory entry number in the directory record       ;
1382: EB0B         ; currently in memory. This directory record will have been read into memory;
1383: EB0B         ; at whatever address was specified at the last Set DMA Address function    ;
1384: EB0B         ; call. Notwithstanding its odd name, the DMA Address is simply the address ;
1385: EB0B         ; into which any record input from disk will be placed. If the Set DMA      ;
1386: EB0B         ; Address function has not been used to change the value, then the CP/M     ;
1387: EB0B         ; default DMA address, location 0080H, will be used to hold the directory   ;
1388: EB0B         ; record.                                                                   ;
1389: EB0B         ;  The actual code for locating the address of the particular directory     ;
1390: EB0B         ;  entry matched by the Search First/ Next functions is shown in Figure 5-17;
1391: EB0B         ;  near the label GNFC. The method involves multiplying the directory code  ;
1392: EB0B         ;  by 32 and then adding this product to the current DMA address.	        ;
1393: EB0B         ;                                                                           ;
1394: EB0B         ;                                                                           ;
1395: EB0B         ;			Function Code	:	C  = 12H                                    ;
1396: EB0B         ;			Entry Parameters:	None , Assume previous Search First Call	;
1397: EB0B         ;			Exit Parameters :	A  = Directory Code							;
1398: EB0B         ;																			;
1399: EB0B         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1400: EB0B             vFindNext:
1401: EB0B 2A 63 F5               LD     HL,(searchAddress)   ; Get Current Dir Entry
1402: EB0E 22 C3 EA               LD     (paramDE),HL         ; Get the user's FCB
1403: EB11 CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1404: EB14 CD 43 F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1405: EB17 C3 AB F1               JP     CopyDirEntryToUserDMA ; Copy directory entry to user
1406: EB1A
1407: EB1A         ;--------------------------------Delete File - 13 (19) ---------------------;
1408: EB1A         ; This function logically deletes from the file directory files that match  ;
1409: EB1A         ; the FCB addressed by DE. It does so by replacing the first byte of each   ;
1410: EB1A         ; relevant directory entry (remember, a single file can have several        ;
1411: EB1A         ; entries, one for each extent) by the value OE5H. This flags the directory ;
1412: EB1A         ; entry as being available for use.                                         ;
1413: EB1A         ;                                                                           ;
1414: EB1A         ;  Like the previous two functions, Search First and Search Next, this      ;
1415: EB1A         ; function can take an ambiguous file name and type as part of the          ;
1416: EB1A         ; File Control Block, but unlike those functions, the logical disk select   ;
1417: EB1A         ; code cannot be a"?". This function returns a directory code in A in the   ;
1418: EB1A         ; same way as the previous file operations.                                 ;
1419: EB1A         ;                                                                           ;
1420: EB1A         ;                                                                           ;
1421: EB1A         ;			Function Code	:	C  = 13H                                   ;
1422: EB1A         ;			Entry Parameters:	DE = Address of File Control Block			;
1423: EB1A         ;			Exit Parameters :	A  = Directory Code							;
1424: EB1A         ;																			;
1425: EB1A         ;--------------------------------Delete File - 13 (19) ---------------------;
1426: EB1A             vDeleteFile:
1427: EB1A CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1428: EB1D CD BF F1               CALL   CheckWrite           ; Terminate with error if Disk R/O
1429: EB20 0E 0C                  LD     C,fcbExtIndex        ; Load the extent number field
1430: EB22 CD 2E F0               CALL   SearchForDirectoryRecord ; Look for directory entry
1431: EB25
1432: EB25             DeleteFileLoop:
1433: EB25 CD DC F0               CALL   AtEndOfDirectory     ; Have we worked thru all entries
1434: EB28 CA B8 F1               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1435: EB2B
1436: EB2B         ; set each non zero disk map entry to 0 in the allocation vector
1437: EB2B CD C6 F1               CALL   CheckRODirectory     ; Terminate with error if File R/O
1438: EB2E CD E5 F0               CALL   GetCurrentDirectoryRecord ; Point to Directory Entry
1439: EB31 36 E5                  LD     (HL),emptyDir        ; Mark as Empty
1440: EB33 0E 00                  LD     C,FALSE              ; Set flag for remove
1441: EB35 CD 09 F1               CALL   ScanDiskMap          ; Reclaim Bisk Blocks, set to 0
1442: EB38 CD AB F0               CALL   WriteDir             ; Update the directory
1443: EB3B CD 43 F0               CALL   GetNextDirectoryRecord ; Look for more
1444: EB3E C3 25 EB               JP     DeleteFileLoop       ; Loop
1445: EB41
1446: EB41         ;----------------------------Read Sequential - 14 (20) ---------------------;
1447: EB41         ;  This function reads the next record (l28-byte sector) from the designated;
1448: EB41         ; file into memory at the address set by the last Set DMA function call     ;
1449: EB41         ; (code 26, lAH). The record read is specified by the FCB's sequential      ;
1450: EB41         ; record field. This field is incremented by 1 so that a subsequent call    ;
1451: EB41         ; to Read Sequential will get the next record from the file. If the end of  ;
1452: EB41         ; the current extent is reached, then the BDOS will automatically open the  ;
1453: EB41         ; next extent and reset the sequential record field to 0, ready for the     ;
1454: EB41         ; next Read function call.                                                  ;
1455: EB41         ;  The file specified in the FCB must have been readied for input by        ;
1456: EB41         ; issuing an Open File (code 15, OFH) or a Create File (code 22, 16H)       ;
1457: EB41         ; BDOS call. The value OOH is returned in A to indicate a successful Read   ;
1458: EB41         ; Sequential operation, while a nonzero value shows that the Read could     ;
1459: EB41         ; not be completed because there was no data in the next record, as at the  ;
1460: EB41         ; end of file.                                                              ;
1461: EB41         ;                                                                           ;
1462: EB41         ;  Although it is not immediately obvious, you can change the sequential    ;
1463: EB41         ; record number, FCB$SEQREC, and within a given extent, read a record at    ;
1464: EB41         ; random. If you want to access any given record within a file, you must    ;
1465: EB41         ; compute which extent that record would be in and set the extent field in  ;
1466: EB41         ; the file control block (FCB$EXTENT) before you open the file. Thus,       ;
1467: EB41         ; although the function name implies sequential access, in practice you can ;
1468: EB41         ; use it to perform a simple type of random access. If you need to do true  ;
1469: EB41         ; random access, look ahead to the Random Read function (code 33), which    ;
1470: EB41         ; takes care of opening the correct extent automatically.                   ;
1471: EB41         ;  When you read data from a CP/M text file, the normal convention is to    ;
1472: EB41         ; fill the last record of the file with lAH characters (CONTROL-Z).         ;
1473: EB41         ; Therefore, two possible conditions can indicate end-of-file: either       ;
1474: EB41         ; encountering a IAH, or receiving a return code from the BDOS function     ;
1475: EB41         ; (in the A register) of OFFH. However, if the file that you are reading    ;
1476: EB41         ; is not an ASCII text file, then a IAH character has no special meaning,   ;
1477: EB41         ; it is just a normal data byte in the body of the file.	                ;
1478: EB41         ;                                                                           ;
1479: EB41         ;			Function Code	:	C  = 14H                                    ;
1480: EB41         ;			Entry Parameters:	DE = Address of File Control Block			;
1481: EB41         ;			Exit Parameters :	A  = 0  => Success							;
1482: EB41         ;								  <> 0  => No data read, Probably EOF		;
1483: EB41         ;																			;
1484: EB41         ;----------------------------Read Sequential - 14 (20) ---------------------;
1485: EB41         ;read sequential
1486: EB41         ;IN  - (DE) FCB address
1487: EB41         ;OUT - (A) 00 = success and data available. else no read and no data
1488: EB41             vReadSeq:
1489: EB41 CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1490: EB44         ;	CALL	ReadSeq
1491: EB44
1492: EB44         ;----------
1493: EB44
1494: EB44         ;sequential disk read operation
1495: EB44             ReadSeq:
1496: EB44 3E 01                  LD     A,1
1497: EB46 32 60 F5               LD     (seqDiskIOFlag),A    ; Set flag for sequential read
1498: EB49         ;---
1499: EB49             DiskRead:
1500: EB49 3E FF                  LD     A,TRUE
1501: EB4B 32 5E F5               LD     (readModeFlag),A     ; Set Read mode flag
1502: EB4E
1503: EB4E CD B0 EF               CALL   SetRecordVars        ; Set variables for current FCB
1504: EB51 3A 6B F5               LD     A,(currentFileRecord)
1505: EB54 21 69 F5               LD     HL,fcbRecordCount
1506: EB57 BE                     CP     M                    ; is File Record < fcbRecordCount
1507: EB58 DA 6E EB               JP     C,RecordOK           ; skip if  yes
1508: EB5B         ; not enough records in the extent
1509: EB5B FE 80                  CP     RecordsPerExtent     ; Is record count the Max ?
1510: EB5D C2 84 EB               JP     NZ,DiskEOF           ;  No, Exit with EOF
1511: EB60
1512: EB60 CD F4 F3               CALL   OpenNextExt          ; Need to open the next extent
1513: EB63 AF                     XOR    A
1514: EB64 32 6B F5               LD     (currentFileRecord),A ; Reset the record count
1515: EB67 3A C5 EA               LD     A,(exitParameterByte) ; Was it a good Open
1516: EB6A B7                     OR     A
1517: EB6B C2 84 EB               JP     NZ,DiskEOF           ;  exit if No
1518: EB6E
1519: EB6E             RecordOK:
1520: EB6E CD EE F1               CALL   GetBlockNumber       ; Put it in absoluteCPMRecord
1521: EB71 CD 20 F2               CALL   WasBlockAllocated    ; Was it a good Allocation ?
1522: EB74 CA 84 EB               JP     Z,DiskEOF            ; get out if not allocated
1523: EB77
1524: EB77 CD 26 F2               CALL   SetActualRecordAdd   ; Absolute CPM Record
1525: EB7A CD BB F2               CALL   Seek                 ; Go to proper track,sector
1526: EB7D CD 58 EF               CALL   ReadBuffer           ; Read into DMA address
1527: EB80 CD C3 F0               CALL   UpdateRecordVariables ; update Record info
1528: EB83 C9                     RET
1529: EB84
1530: EB84             DiskEOF:
1531: EB84 C3 6D F2               JP     SetExitParamTo1      ; exitParameterByte = 1
1532: EB87         ;ret
1533: EB87
1534: EB87         ;----------
1535: EB87         ;	RET
1536: EB87
1537: EB87         ;--------------------------------- Make File - 16 (22) ---------------------;
1538: EB87         ;  This function creates a new file of the specified name and type. You must;
1539: EB87         ; first ensure that no file of the same name and type already exists on the ;
1540: EB87         ; same logical disk, either by trying to open the file (if this succeeds,   ;
1541: EB87         ; the file already exists) or by unconditionally erasing the file.          ;
1542: EB87         ;  In addition to creating the file and its associated file directory entry,;
1543: EB87         ; this function also effectively opens the file so that it is ready for     ;
1544: EB87         ; records to be written to it.                                              ;
1545: EB87         ;  This function returns a normal directory code if the file creation has   ;
1546: EB87         ; completed successfully or a value of OFFH if there is insufficient        ;
1547: EB87         ; disk or directory space.                                                  ;
1548: EB87         ;  Note that this function cannot accept an ambiguous file name in the FCB. ;
1549: EB87         ;                                                                           ;
1550: EB87         ;                                                                           ;
1551: EB87         ;			Function Code	:	C  = 16H                                    ;
1552: EB87         ;			Entry Parameters:	DE = Address of File Control Block			;
1553: EB87         ;			Exit Parameters :	A  = Directory Code							;
1554: EB87         ;																			;
1555: EB87         ;---------------------------- Make File - 16 (22) --------------------------;
1556: EB87             vMakeFile:
1557: EB87 CD 02 F0               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1558: EB8A CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1559: EB8D C3 DC EE               JP     MakeNewFile          ; Go Make it
1560: EB90
1561: EB90         ;-------------------------- Rename File - 17 (23) --------------------------;
1562: EB90         ;  This function renames an existing file name and type to a new name and   ;
1563: EB90         ; type. It is unusual in that it uses a single FCB to store both the old    ;
1564: EB90         ; file name and type (in the first 16 bytes) and the new file name and type ;
1565: EB90         ; (in the second 16 bytes).                                                 ;
1566: EB90         ;  This function returns a normal directory code if the file rename was     ;
1567: EB90         ; completed successfully or a value of OFFH if the old file name could not  ;
1568: EB90         ; be found.                                                                 ;
1569: EB90         ;                                                                           ;
1570: EB90         ;  The Rename File function only checks that the old file name and type     ;
1571: EB90         ; exist; it makes no check to ensure that the new name and type combination ;
1572: EB90         ; does not already exist. Therefore, you should try to open the new file    ;
1573: EB90         ; name and type. If you succeed, do not attempt the rename operation.       ;
1574: EB90         ; CP/M will create more than one file of the same name and type, and you    ;
1575: EB90         ; stand to lose the information in both files as you attempt to sort out    ;
1576: EB90         ; the problem.                                                              ;
1577: EB90         ;  Never use ambiguous file names in a rename operation; it produces strange;
1578: EB90         ; effects and may result in files being irreparably damaged. This function  ;
1579: EB90         ; will change all occurrences of the old file name to the new name.         ;
1580: EB90         ;                                                                           ;
1581: EB90         ;                                                                           ;
1582: EB90         ;			Function Code	:	C  = 17H                                   ;
1583: EB90         ;			Entry Parameters:	DE = Address of File Control Block			;
1584: EB90         ;			Exit Parameters :	A  = Directory Code							;
1585: EB90         ;																			;
1586: EB90         ;-------------------------- Rename File - 17 (23) --------------------------;
1587: EB90             vRenameFile:
1588: EB90 CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1589: EB93 CD BF F1               CALL   CheckWrite           ; Terminate with error if Disk R/O
1590: EB96 0E 0C                  LD     C,fcbExtIndex        ; Match user#, Name & Type only
1591: EB98 CD 2E F0               CALL   SearchForDirectoryRecord
1592: EB9B
1593: EB9B         ; Move the old use number to the new entry (2nd half of FCB)
1594: EB9B 2A C3 EA               LD     HL,(paramDE)         ; FCB pointer
1595: EB9E 7E                     LD     A,(HL)               ; First byte of Dir entry
1596: EB9F 11 10 00               LD     DE,fcbDiskMapIndex   ; Use second half of FCB
1597: EBA2 19                     ADD    HL,DE                ; Point at the second half of FCB
1598: EBA3 77                     LD     (HL),A               ; Put into new name user position
1599: EBA4
1600: EBA4             RenameLoop:
1601: EBA4 CD DC F0               CALL   AtEndOfDirectory     ; If have we checked the whole dir
1602: EBA7 CA B8 F1               JP     Z,DirLocationToReturnLoc ;  return directory Index to caller
1603: EBAA         ; process this match
1604: EBAA CD C6 F1               CALL   CheckRODirectory     ; Terminate with error if File R/O
1605: EBAD 0E 10                  LD     C,fcbDiskMapIndex    ; Set starting position
1606: EBAF 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1607: EBB1 CD D7 F1               CALL   CopyDir              ; copy from FCB to dir entry
1608: EBB4         ; element renamed, look for more
1609: EBB4 CD 43 F0               CALL   GetNextDirectoryRecord ; Look for more dir entries
1610: EBB7 C3 A4 EB               JP     RenameLoop           ; Loop
1611: EBBA
1612: EBBA         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1613: EBBA         ; This function returns a bit map, called the login vector, in register pair ;
1614: EBBA         ; HL, indicating which logical disk drives have been selected since the last ;
1615: EBBA         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1616: EBBA         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1617: EBBA         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1618: EBBA         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1619: EBBA         ;  Logical disks can be selected programmatically through any file operation ;
1620: EBBA         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1621: EBBA         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1622: EBBA         ; where "X" is equal to A, B, ... , P.                                       ;
1623: EBBA         ;                                                                            ;
1624: EBBA         ;			Function Code	:	C = 018H                                     ;
1625: EBBA         ;			Entry Parameters:	None										 ;
1626: EBBA         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1627: EBBA         ;																			 ;
1628: EBBA         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1629: EBBA             vGetLoginVector:
1630: EBBA 2A 3A F5               LD     HL,(loggedDisks)
1631: EBBD 22 C5 EA               LD     (exitParameterWord),HL
1632: EBC0 C9                     RET
1633: EBC1
1634: EBC1         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1635: EBC1         ;   This function returns the current default disk set by the last Select    ;
1636: EBC1         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1637: EBC1         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1638: EBC1         ;                                                                            ;
1639: EBC1         ;  This function returns the current default disk in coded form.             ;
1640: EBC1         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1641: EBC1         ; If you need to convert this to the corresponding ASCII character, simply   ;
1642: EBC1         ; add 41H to register A. Use this function when you convert a file name and  ;
1643: EBC1         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1644: EBC1         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1645: EBC1         ; You must therefore use this function to determine the logical disk letter  ;
1646: EBC1         ; for the default drive.                                                     ;
1647: EBC1         ;                                                                            ;
1648: EBC1         ;			Function Code	:	C = 019H                                     ;
1649: EBC1         ;			Entry Parameters:	None										 ;
1650: EBC1         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1651: EBC1         ;																			 ;
1652: EBC1         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1653: EBC1             vGetCurrentDisk:
1654: EBC1 3A 36 F5               LD     A,(currentDisk)
1655: EBC4 32 C5 EA               LD     (exitParameterByte),A
1656: EBC7 C9                     RET
1657: EBC8
1658: EBC8         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1659: EBC8         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1660: EBC8         ; value. The name is an historic relic dating back to the Intel Development  ;
1661: EBC8         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1662: EBC8         ; its hardware, could read data from a diskette directly into memory or      ;
1663: EBC8         ; write data to a diskette directly from memory. The name DMA address now    ;
1664: EBC8         ; applies to the address of the buffer to and from which data is             ;
1665: EBC8         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1666: EBC8         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1667: EBC8         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1668: EBC8         ; value of 0080H.                                                            ;
1669: EBC8         ;                                                                            ;
1670: EBC8         ;			Function Code	:	C = 0A9H                                     ;
1671: EBC8         ;			Entry Parameters:	DE = DMA Address							 ;
1672: EBC8         ;			Exit Parameters :	None										 ;
1673: EBC8         ;																			 ;
1674: EBC8         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1675: EBC8             vSetDMA:
1676: EBC8 2A C3 EA               LD     HL,(paramDE)
1677: EBCB 22 3C F5               LD     (initDAMAddress),HL
1678: EBCE C3 4A EF               JP     SetDataDMA
1679: EBD1
1680: EBD1         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1681: EBD1         ;  This function returns the base, or starting, address of the allocation    ;
1682: EBD1         ; vector for the currently selected logical disk. This information,          ;
1683: EBD1         ; indicating which parts of the disk are assigned, is used by utility        ;
1684: EBD1         ; programs and the BDOS itself to determine how much unused space is on the  ;
1685: EBD1         ; logical disk, to locate an unused allocation block in order to extend      ;
1686: EBD1         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1687: EBD1         ;                                                                            ;
1688: EBD1         ;			Function Code	:	C = 01BH                                     ;
1689: EBD1         ;			Entry Parameters:	None										 ;
1690: EBD1         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1691: EBD1         ;																			 ;
1692: EBD1         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1693: EBD1             vGetAllocAddr:
1694: EBD1 2A 4A F5               LD     HL,(caAllocVector)
1695: EBD4 22 C5 EA               LD     (exitParameterWord),HL
1696: EBD7 C9                     RET
1697: EBD8
1698: EBD8         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1699: EBD8         ;  This function logically sets the currently selected disk to a Read-Only   ;
1700: EBD8         ; state. Any attempts to execute a Write Sequential or Write Random function ;
1701: EBD8         ; to the selected disk will be intercepted by the BDOS, and the following    ;
1702: EBD8         ; message will appear on the console:                                        ;
1703: EBD8         ;	BDOS Err on X: R/O                                                       ;
1704: EBD8         ;	where X: is the selected disk.                                           ;
1705: EBD8         ;                                                                            ;
1706: EBD8         ;  Once you have requested Read-Only status for the currently selected       ;
1707: EBD8         ; logical disk, this status will persist even if you proceed to select       ;
1708: EBD8         ; other logical disks. In fact, it will remain in force until the next warm  ;
1709: EBD8         ; boot or Reset Disk System function call.                                   ;
1710: EBD8         ;  Digital Research documentation refers to this function code as Disk Write ;
1711: EBD8         ; Protect. The Read-Only description is used here because it corresponds     ;
1712: EBD8         ; to the error message produced if your program attempts to write on         ;
1713: EBD8         ; the disk.                                                                  ;
1714: EBD8         ;                                                                            ;
1715: EBD8         ;			Function Code	:	C = 01CH                                     ;
1716: EBD8         ;			Entry Parameters:	None										 ;
1717: EBD8         ;			Exit Parameters :	None										 ;
1718: EBD8         ;																			 ;
1719: EBD8         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1720: EBD8         ;;write protect current disk
1721: EBD8             vWriteProtectDisk:
1722: EBD8 C3 60 EF               JP     SetDiskReadOnly
1723: EBDB
1724: EBDB         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1725: EBDB         ;  This function returns a bit map in registers H and L showing which logical;
1726: EBDB         ; disks in the system have been set to Read-Only status, either by the       ;
1727: EBDB         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1728: EBDB         ; BDOS itself, because it detected that a diskette had been changed.         ;
1729: EBDB         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1730: EBDB         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1731: EBDB         ; the specific logical disk is set to I if the disk has been set to          ;
1732: EBDB         ; Read-Only status.                                                          ;
1733: EBDB         ;                                                                            ;
1734: EBDB         ;			Function Code	:	C = 01DH                                     ;
1735: EBDB         ;			Entry Parameters:	None										 ;
1736: EBDB         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1737: EBDB         ;																			 ;
1738: EBDB         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1739: EBDB             vGetReadOnlyMap:
1740: EBDB 2A 38 F5               LD     HL,(readOnlyVector)
1741: EBDE 22 C5 EA               LD     (exitParameterWord),HL
1742: EBE1 C9                     RET
1743: EBE2
1744: EBE2         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1745: EBE2         ;  This function sets the bits that describe attributes of a file in the    ;
1746: EBE2         ; relevant directory entries for the specified file. Each file can be       ;
1747: EBE2         ; assigned up to 11 file attributes. Of these 11, two have predefined       ;
1748: EBE2         ; meanings, four others are available for you to use, and the remaining     ;
1749: EBE2         ; five are reserved for future use by CP/M.                                 ;
1750: EBE2         ;  Each attribute consists of a single bit. The most significant bit of     ;
1751: EBE2         ; each byte of the file name and type is used to store the attributes.      ;
1752: EBE2         ; The file attributes are known by a code consisting of the letter "f"      ;
1753: EBE2         ; (for file name) or "t" (for file type), followed by the number of the     ;
1754: EBE2         ; character position and a single quotation mark. For example, the Read-Only;
1755: EBE2         ; attribute is tl'.                                                         ;
1756: EBE2         ;	The significance of the attributes is as follows:                       ;
1757: EBE2         ;			fl' to f4' Available for you to use                             ;
1758: EBE2         ;			f5' to fS' Reserved for future CP/M use                         ;
1759: EBE2         ;			tl' Read-Only File attribute                                    ;
1760: EBE2         ;			t2' System File attribute                                       ;
1761: EBE2         ;			t3' Reserved for future CP/M use                                ;
1762: EBE2         ;			                                                                ;
1763: EBE2         ;  Attributes are set by presenting this function with an FCB in which the  ;
1764: EBE2         ; unambiguous file name has been preset with the most significant bits      ;
1765: EBE2         ; set appropriately. This function then searches the directory for a match  ;
1766: EBE2         ; and changes the matched entries to contain the attributes which have been ;
1767: EBE2         ; set in the FCB.                                                           ;
1768: EBE2         ;  The BDOS will intercept any attempt to write on a file that has the      ;
1769: EBE2         ; Read-Only attribute set. The DIR command in the CCP does not display any  ;
1770: EBE2         ; file with System status.                                                  ;
1771: EBE2         ;                                                                           ;
1772: EBE2         ;  You can use the four attributes available to you to set up a file        ;
1773: EBE2         ; security system, or perhaps to flag certain files that must be backed up  ;
1774: EBE2         ; to other disks. The Search First and Search Next functions allow you to   ;
1775: EBE2         ; view the complete file directory entry, so your programs can test the     ;
1776: EBE2         ; attributes easily.                                                        ;
1777: EBE2         ;                                                                           ;
1778: EBE2         ;                                                                           ;
1779: EBE2         ;			Function Code	:	C  = 1EH                                    ;
1780: EBE2         ;			Entry Parameters:	DE = Address of File Control Block			;
1781: EBE2         ;			Exit Parameters :	A  = Directory Code							;
1782: EBE2         ;																			;
1783: EBE2         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1784: EBE2             vSetFileAttributes:
1785: EBE2 CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1786: EBE5 0E 0C                  LD     C,fcbExtIndex        ; Size of search/match
1787: EBE7 CD 2E F0               CALL   SearchForDirectoryRecord ; Find a match
1788: EBEA
1789: EBEA             SetAttributesLoop:
1790: EBEA CD DC F0               CALL   AtEndOfDirectory     ; Any more dir entries ?
1791: EBED CA B8 F1               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller							;  exit if yes
1792: EBF0         ; Directory entry found
1793: EBF0 0E 00                  LD     C,0                  ; Set starting position
1794: EBF2 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1795: EBF4 CD D7 F1               CALL   CopyDir              ; copy from FCB to dir entry
1796: EBF7 CD 43 F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1797: EBFA C3 EA EB               JP     SetAttributesLoop    ; Loop
1798: EBFD
1799: EBFD         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1800: EBFD         ;  This function returns the address of the disk parameter block (DPB) for   ;
1801: EBFD         ; the last selected logical disk. The DPB describes the physical             ;
1802: EBFD         ; characteristics of a specific logical disk-information mainly of interest  ;
1803: EBFD         ; for system utility programs.                                               ;
1804: EBFD         ;                                                                            ;
1805: EBFD         ;			Function Code	:	C = 1FH                                      ;
1806: EBFD         ;			Entry Parameters:	None										 ;
1807: EBFD         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1808: EBFD         ;																			 ;
1809: EBFD         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1810: EBFD             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1811: EBFD 2A 46 F5               LD     HL,(caDiskParamBlock)
1812: EC00 22 C5 EA               LD     (exitParameterWord),HL
1813: EC03 C9                     RET
1814: EC04
1815: EC04         ;------------------------- Get File Size - 23 (35) -------------------------;
1816: EC04         ;  This function returns the virtual size of the specified file. It does so ;
1817: EC04         ; by setting the random record number (bytes 33-35) in the specified FCB to ;
1818: EC04         ; the maximum 128-byte record number in the file. The virtual file size is  ;
1819: EC04         ; calculated from the record address of the record following the end of the ;
1820: EC04         ; file. Bytes 33 and 34 form a 16-bit value that contains the record number,;
1821: EC04         ; with overflow indicated in byte 35. If byte 35 is 01, this means that the ;
1822: EC04         ; file has the maximum record count of 65,536.                              ;
1823: EC04         ;  If the function cannot find the file specified by the FCB, it returns    ;
1824: EC04         ; with the random record field set to O.                                    ;
1825: EC04         ;  You can use this function when you want to add data to the end of an     ;
1826: EC04         ; existing file. By calling this function first, the random record bytes    ;
1827: EC04         ; will be set to the end of file. Subsequent Write Random calls will write  ;
1828: EC04         ; out records to this preset address.                                       ;
1829: EC04         ;                                                                           ;
1830: EC04         ;  Do not confuse the virtual file size with the actual file size. In a     ;
1831: EC04         ; random file, if you write just a single CP/M record to record number      ;
1832: EC04         ; 1000 and then call this function, it will return with the random record   ;
1833: EC04         ; number field set in the FCB to 1000, even though only a single record     ;
1834: EC04         ; exists in the file. For sequential files, this function returns the       ;
1835: EC04         ; number of records in the file. In this case, the virtual and actual file  ;
1836: EC04         ; sizes coincide.                                                           ;
1837: EC04         ;                                                                           ;
1838: EC04         ;                                                                           ;
1839: EC04         ;			Function Code	:	C  = 23H                                    ;
1840: EC04         ;			Entry Parameters:	DE = Address of File Control Block			;
1841: EC04         ;			Exit Parameters :	Random record field set in FCB				;
1842: EC04         ;																			;
1843: EC04         ;------------------------- Get File Size - 23 (35) -------------------------;
1844: EC04             vComputeFileSize:
1845: EC04 CD 83 EF               CALL   ReselectDisk         ; Reselect if needed
1846: EC07         ;	JP		GetFileSize
1847: EC07
1848: EC07         ;compute logical file size for current fcb
1849: EC07         ; GetFileSize:
1850: EC07 0E 0C                  LD     C,fcbExtIndex        ; Set search/match length
1851: EC09 CD 2E F0               CALL   SearchForDirectoryRecord ; Set directoryIndex
1852: EC0C         ; zero the receiving FCB Random Record field
1853: EC0C 2A C3 EA               LD     HL,(paramDE)         ; Point at FCB
1854: EC0F 11 21 00               LD     DE,recordRandom      ; Random Record index
1855: EC12 19                     ADD    HL,DE                ; Point at Random Record
1856: EC13 E5                     PUSH   HL                   ; Random Record LSB pointer
1857: EC14 72                     LD     (HL),D               ; Set Random Record LSB = 0
1858: EC15 23                     INC    HL                   ; Random Record MSB pointer
1859: EC16 72                     LD     (HL),D               ; Set Random Record MSB = 0
1860: EC17 23                     INC    HL                   ; Random Record overflow pointer
1861: EC18 72                     LD     (HL),D               ; Set Random Record overflow = 0
1862: EC19
1863: EC19             GetFileSize1:
1864: EC19 CD DC F0               CALL   AtEndOfDirectory     ; Any more dir entries ?
1865: EC1C CA 41 EC               JP     Z,GetFileSizeExit    ;  exit if no
1866: EC1F
1867: EC1F CD E5 F0               CALL   GetCurrentDirectoryRecord ; HL points at Directory entry
1868: EC22 11 0F 00               LD     DE,fcbRCIndex        ; FCB Record Count index
1869: EC25 CD 09 ED               CALL   GetRandomRecordPosition
1870: EC28         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1871: EC28 E1                     POP    HL
1872: EC29 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1873: EC2A 5F                     LD     E,A                  ; save cy
1874: EC2B 79                     LD     A,C
1875: EC2C 96                     SUB    M
1876: EC2D 23                     INC    HL                   ; ls byte
1877: EC2E 78                     LD     A,B
1878: EC2F 9E                     SBC    A,(HL)
1879: EC30 23                     INC    HL                   ; middle byte
1880: EC31 7B                     LD     A,E
1881: EC32 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1882: EC33 DA 3B EC               JP     C,GetFileSize2       ; for another try
1883: EC36         ; fcb is less or equal, fill from directory
1884: EC36 73                     LD     (HL),E
1885: EC37 2B                     DEC    HL
1886: EC38 70                     LD     (HL),B
1887: EC39 2B                     DEC    HL
1888: EC3A 71                     LD     (HL),C
1889: EC3B             GetFileSize2:                      ; getnextsize:
1890: EC3B CD 43 F0               CALL   GetNextDirectoryRecord
1891: EC3E C3 19 EC               JP     GetFileSize1
1892: EC41             GetFileSizeExit:                      ; setsize:
1893: EC41 E1                     POP    HL                   ; discard .fcb(random record field)
1894: EC42 C9                     RET
1895: EC43
1896: EC43         ;------------------ Set Random Record Number - 24 (36) ---------------------;
1897: EC43         ;  This function sets the random record number in the FCB to the correct    ;
1898: EC43         ; value for the last record read or written sequentially to the file.       ;
1899: EC43         ;                                                                           ;
1900: EC43         ;  This function provides you with a convenient way to build an index file  ;
1901: EC43         ;  so that you can randomly access a sequential file. Open the sequential   ;
1902: EC43         ;  file, and as you read each record, extract the appropriate key field from;
1903: EC43         ;  the data record. Make the BDOS Set Random Record request and create a new;
1904: EC43         ; data record with just the key field and the random record number. Write   ;
1905: EC43         ; the new data record out to the index file.                                ;
1906: EC43         ;  Once you have done this for each record in the file, your index file     ;
1907: EC43         ; provides a convenient method, given a search key value, of finding the    ;
1908: EC43         ; appropriate CP/M record in which the data lies.                           ;
1909: EC43         ;  You can also use this function as a means offinding out where you are    ;
1910: EC43         ; currently positioned in a sequential file-either to relate a CP/M record  ;
1911: EC43         ; number to the position, or simply as a place-marker to allow a            ;
1912: EC43         ; repositioning to the same place later.                                    ;
1913: EC43         ;                                                                           ;
1914: EC43         ;                                                                           ;
1915: EC43         ;			Function Code	:	C  = 24H                                    ;
1916: EC43         ;			Entry Parameters:	DE = Address of File Control Block			;
1917: EC43         ;			Exit Parameters :	Random record field set in FCB				;
1918: EC43         ;																			;
1919: EC43         ;------------------ Set Random Record Number - 24 (36) ---------------------;
1920: EC43             vSetRandomRecord:
1921: EC43         ;	JP		SetRandomRecord
1922: EC43         ; SetRandomRecord:
1923: EC43 2A C3 EA               LD     HL,(paramDE)         ; FCB
1924: EC46 11 20 00               LD     DE,recordSeq         ; Sequential record pointer
1925: EC49 CD 09 ED               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1926: EC4C 21 21 00               LD     HL,recordRandom
1927: EC4F 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1928: EC50 71                     LD     (HL),C
1929: EC51 23                     INC    HL
1930: EC52 70                     LD     (HL),B
1931: EC53 23                     INC    HL
1932: EC54 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1933: EC55 C9                     RET
1934: EC56
1935: EC56         ;*****************************************************************
1936: EC56
1937: EC56         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1938: EC56         ;  This function resets individual disk drives. It is a more precise version ;
1939: EC56         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1940: EC56         ; specific logical; disks rather than all of them.                           ;
1941: EC56         ;  The bit map in DE shows which disks are to be reset. The least significant;
1942: EC56         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1943: EC56         ; The bits set to 1 indicate the disks to be reset.                          ;
1944: EC56         ;  Note that this function returns a zero value in A in order to maintain    ;
1945: EC56         ; compatibility with MP/ M.                                                  ;
1946: EC56         ;                                                  ;                         ;
1947: EC56         ;  Use this function when only specific diskettes need to be changed.        ;
1948: EC56         ; Changing a diskette without requesting CP/M to log it in will cause the    ;
1949: EC56         ; BDOS to assume that an error has occurred and to set the new diskette to   ;
1950: EC56         ; Read-Only status as a protective measure                                   ;
1951: EC56         ;                                                                            ;
1952: EC56         ;			Function Code	:	C = 25H                                      ;
1953: EC56         ;			Entry Parameters:	DE = Logical Drive Bit Vector				 ;
1954: EC56         ;			Exit Parameters :	A = 00H										 ;
1955: EC56         ;																			 ;
1956: EC56         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1957: EC56         ;  **************  Not Yet Implemented   **************
1958: EC56             vResetDrive:
1959: EC56 3E FF                  LD     A,-1                 ; Error return
1960: EC58 C9                     RET
1961: EC59
1962: EC59
1963: EC59
1964: EC59         ;-----------------------------------------------------------------
1965: EC59
1966: EC59         ;*****************************************************************
1967: EC59         ;random disk read
1968: EC59         ;IN  - (DE) FCB address
1969: EC59         ;OUT - (A) 01 = Reading unwritten data
1970: EC59         ;	 02 = N/U
1971: EC59         ;	 03 = Cannot close current extent
1972: EC59         ;	 04 = Seek to unwriten Extent
1973: EC59         ;	 05 = N/U
1974: EC59         ;	 06 = Seek past Physical end of Disk
1975: EC59             vReadRandom:                      ; func33 (33 - 21) Read Random record
1976: EC59 CD 83 EF               CALL   ReselectDisk
1977: EC5C C3 66 EC               JP     RandomDiskRead       ; to perform the disk read
1978: EC5F         ;*****************************************************************
1979: EC5F         ;write random record
1980: EC5F         ;IN  - (DE) FCB address
1981: EC5F         ;OUT - (A) 01 = Reading unwritten data
1982: EC5F         ;	 02 = N/U
1983: EC5F         ;	 03 = Cannot close current extent
1984: EC5F         ;	 04 = Seek to unwriten Extent
1985: EC5F         ;	 05 = Cannot create new Extent because of directory overflow
1986: EC5F         ;	 06 = Seek past Physical end of Disk
1987: EC5F             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1988: EC5F CD 83 EF               CALL   ReselectDisk
1989: EC62 C3 6F EC               JP     RandomDiskWrite      ; to perform the disk write
1990: EC65         ;ret ;jmp goback
1991: EC65         ;? ;*****************************************************************
1992: EC65         ;? ;Reset Drive
1993: EC65         ;? ;IN  - (DE) Drive Vector
1994: EC65         ;? ;OUT - (A) 00
1995: EC65         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
1996: EC65         ;? ; Not Yet Implemented   **************
1997: EC65         ;?	RET
1998: EC65         ;*****************************************************************
1999: EC65         ;*****************************************************************
2000: EC65         ;Write Random With Zero Fill
2001: EC65         ;IN  - (DE) FCB address
2002: EC65         ;OUT - (A) Return Code		see Function 34
2003: EC65             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
2004: EC65         ; Not Yet Implemented   **************
2005: EC65 C9                     RET
2006: EC66         ;*****************************************************************
2007: EC66         ;******************< Random I/O Stuff ****************************
2008: EC66         ;*****************************************************************
2009: EC66         ;random disk read
2010: EC66             RandomDiskRead:                      ; randiskread
2011: EC66 0E FF                  LD     C,TRUE               ; marked as read operation
2012: EC68 CD 78 EC               CALL   RandomSeek
2013: EC6B CC 49 EB               CALL   Z,DiskRead           ; if seek successful
2014: EC6E C9                     RET
2015: EC6F         ;*****************************************************************
2016: EC6F         ;random disk write
2017: EC6F             RandomDiskWrite:                      ; randiskwrite
2018: EC6F 0E 00                  LD     C,FALSE              ; marked as read operation
2019: EC71 CD 78 EC               CALL   RandomSeek
2020: EC74 CC 31 F3               CALL   Z,DiskWrite          ; if seek successful
2021: EC77 C9                     RET
2022: EC78         ;*****************************************************************
2023: EC78         ;*****************************************************************
2024: EC78         ;random access seek operation, C=0ffh if read mode
2025: EC78         ;fcb is assumed to address an active file control block
2026: EC78         ;(fcbS2Index has been set to 11000000b if previous bad seek)
2027: EC78             RandomSeek:
2028: EC78 AF                     XOR    A
2029: EC79 32 60 F5               LD     (seqDiskIOFlag),A    ; marked as random access operation
2030: EC7C C5                     PUSH   BC                   ; save r/w flag
2031: EC7D 2A C3 EA               LD     HL,(paramDE)
2032: EC80 EB                     EX     DE,HL                ; DE will hold base of fcb
2033: EC81 21 21 00               LD     HL,recordRandom
2034: EC84 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
2035: EC85 7E                     LD     A,(HL)
2036: EC86 E6 7F                  AND    7FH
2037: EC88 F5                     PUSH   AF                   ; record number
2038: EC89 7E                     LD     A,(HL)
2039: EC8A 17                     RLA                         ; cy=lsb of extent#
2040: EC8B 23                     INC    HL
2041: EC8C 7E                     LD     A,(HL)
2042: EC8D 17                     RLA
2043: EC8E E6 1F                  AND    11111B               ; A=ext#
2044: EC90 4F                     LD     C,A                  ; C holds extent number, record stacked
2045: EC91 7E                     LD     A,(HL)
2046: EC92 1F                     RRA
2047: EC93 1F                     RRA
2048: EC94 1F                     RRA
2049: EC95 1F                     RRA
2050: EC96 E6 0F                  AND    1111B                ; mod#
2051: EC98 47                     LD     B,A                  ; B holds module#, C holds ext#
2052: EC99 F1                     POP    AF                   ; recall sought record #
2053: EC9A         ;check to insure that high byte of ran rec = 00
2054: EC9A 23                     INC    HL
2055: EC9B 6E                     LD     L,(HL)               ; l=high byte (must be 00)
2056: EC9C 2C                     INC    L
2057: EC9D 2D                     DEC    L
2058: EC9E 2E 06                  LD     L,06                 ; zero flag, l=6
2059: ECA0         ; produce error 6, seek past physical eod
2060: ECA0 C2 01 ED               JP     NZ,RandomSeekError
2061: ECA3         ; otherwise, high byte = 0, A = sought record
2062: ECA3 21 20 00               LD     HL,recordSeq
2063: ECA6 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
2064: ECA7 77                     LD     (HL),A               ; sought rec# stored away
2065: ECA8         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
2066: ECA8         ; the r/w flag is still stacked.  compare fcb values
2067: ECA8 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
2068: ECAB 19                     ADD    HL,DE
2069: ECAC 79                     LD     A,C                  ; A=seek ext#
2070: ECAD 96                     SUB    M
2071: ECAE C2 BC EC               JP     NZ,RandomSeekClose   ; tests for = extents
2072: ECB1         ; extents match, check mod#
2073: ECB1 21 0E 00               LD     HL,fcbS2Index
2074: ECB4 19                     ADD    HL,DE
2075: ECB5 78                     LD     A,B                  ; B=seek mod#
2076: ECB6         ; could be overflow at eof, producing module#
2077: ECB6         ; of 90H or 10H, so compare all but fwf
2078: ECB6 96                     SUB    M
2079: ECB7 E6 7F                  AND    7FH
2080: ECB9 CA F4 EC               JP     Z,RandomSeekExit     ; same?
2081: ECBC             RandomSeekClose:
2082: ECBC C5                     PUSH   BC
2083: ECBD D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
2084: ECBE CD 5C EE               CALL   CloseDirEntry        ; current extent closed
2085: ECC1 D1                     POP    DE
2086: ECC2 C1                     POP    BC                   ; recall parameters and fill
2087: ECC3 2E 03                  LD     L,03                 ; cannot close error #3
2088: ECC5 3A C5 EA               LD     A,(exitParameterByte)
2089: ECC8 3C                     INC    A
2090: ECC9 CA FA EC               JP     Z,RandomSeekErrorBadSeek
2091: ECCC 21 0C 00               LD     HL,fcbExtIndex
2092: ECCF 19                     ADD    HL,DE
2093: ECD0 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
2094: ECD1 21 0E 00               LD     HL,fcbS2Index
2095: ECD4 19                     ADD    HL,DE
2096: ECD5 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
2097: ECD6 CD 19 EE               CALL   OpenFile             ; is the file present?
2098: ECD9 3A C5 EA               LD     A,(exitParameterByte)
2099: ECDC 3C                     INC    A
2100: ECDD C2 F4 EC               JP     NZ,RandomSeekExit    ; open successful?
2101: ECE0         ; cannot open the file, read mode?
2102: ECE0 C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
2103: ECE1 C5                     PUSH   BC                   ; everyone expects this item stacked
2104: ECE2 2E 04                  LD     L,04                 ; seek to unwritten extent #4
2105: ECE4 0C                     INC    C                    ; becomes 00 if read operation
2106: ECE5 CA FA EC               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
2107: ECE8 CD DC EE               CALL   MakeNewFile          ; write operation, make new extent
2108: ECEB 2E 05                  LD     L,05                 ; cannot create new extent #5
2109: ECED 3A C5 EA               LD     A,(exitParameterByte)
2110: ECF0 3C                     INC    A
2111: ECF1 CA FA EC               JP     Z,RandomSeekErrorBadSeek ; no dir space
2112: ECF4         ; file make operation successful
2113: ECF4             RandomSeekExit:                      ; seekok:
2114: ECF4 C1                     POP    BC                   ; discard r/w flag
2115: ECF5 AF                     XOR    A
2116: ECF6 32 C5 EA               LD     (exitParameterByte),A
2117: ECF9 C9                     RET                         ; with zero set
2118: ECFA
2119: ECFA             RandomSeekErrorBadSeek:
2120: ECFA         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
2121: ECFA         ; appears as overflow with file write flag set
2122: ECFA E5                     PUSH   HL                   ; save error flag
2123: ECFB CD 08 F0               CALL   GetExtentNumberMSB   ; HL = .fcbS2Index
2124: ECFE 36 C0                  LD     (HL),11000000B
2125: ED00 E1                     POP    HL                   ; and drop through
2126: ED01             RandomSeekError:                      ; seekerr:
2127: ED01 C1                     POP    BC                   ; discard r/w flag
2128: ED02 7D                     LD     A,L
2129: ED03 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
2130: ED06         ; SetFileWriteFlag returns non-zero accumulator for err
2131: ED06 C3 11 F0               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
2132: ED09         ;ret
2133: ED09         ;
2134: ED09         ;*****************************************************************
2135: ED09         ;*****************************************************************
2136: ED09         ;--------------------------- Get Random Record Position --------------------;
2137: ED09         ; on Entry :
2138: ED09         ;			HL = pointer to directory entry
2139: ED09         ;			DE = fcbRCIndex/seqRecord index
2140: ED09             GetRandomRecordPosition:
2141: ED09 EB                     EX     DE,HL                ; DE = pointer to directory entry
2142: ED0A 19                     ADD    HL,DE
2143: ED0B         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
2144: ED0B 4E                     LD     C,(HL)               ; C = record count
2145: ED0C 06 00                  LD     B,0                  ; Make count a word value
2146: ED0E
2147: ED0E 21 0C 00               LD     HL,fcbExtIndex       ; FCB Extent index
2148: ED11 19                     ADD    HL,DE
2149: ED12 7E                     LD     A,(HL)               ; ACC has Extent value
2150: ED13 0F                     RRCA
2151: ED14 E6 80                  AND    80H                  ; A=e000 0000
2152: ED16 81                     ADD    A,C
2153: ED17 4F                     LD     C,A
2154: ED18 3E 00                  LD     A,0
2155: ED1A 88                     ADC    A,B
2156: ED1B 47                     LD     B,A
2157: ED1C         ; BC = 0000 000? errrr rrrr
2158: ED1C 7E                     LD     A,(HL)
2159: ED1D 0F                     RRCA
2160: ED1E E6 0F                  AND    LO_NIBBLE_MASK
2161: ED20 80                     ADD    A,B
2162: ED21 47                     LD     B,A
2163: ED22         ; BC = 000? eeee errrr rrrr
2164: ED22 21 0E 00               LD     HL,fcbS2Index
2165: ED25 19                     ADD    HL,DE
2166: ED26 7E                     LD     A,(HL)               ; A=XXX? mmmm
2167: ED27 87                     ADD    A,A
2168: ED28 87                     ADD    A,A
2169: ED29 87                     ADD    A,A
2170: ED2A 87                     ADD    A,A                  ; cy=? A=mmmm 0000
2171: ED2B F5                     PUSH   AF
2172: ED2C 80                     ADD    A,B
2173: ED2D 47                     LD     B,A
2174: ED2E         ; cy=?, BC = mmmm eeee errr rrrr
2175: ED2E F5                     PUSH   AF                   ; possible second carry
2176: ED2F E1                     POP    HL                   ; cy = lsb of L
2177: ED30 7D                     LD     A,L                  ; cy = lsb of A
2178: ED31 E1                     POP    HL                   ; cy = lsb of L
2179: ED32 B5                     OR     L                    ; cy/cy = lsb of A
2180: ED33 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
2181: ED35 C9                     RET
2182: ED36         ;--------------------------- Get Random Record Position --------------------;
2183: ED36
2184: ED36
2185: ED36
2186: ED36         ;*****************************************************************
2187: ED36         ;********************** Disk  I/O ********************************
2188: ED36         ;*****************************************************************
2189: ED36         ;-----------------------------------------------------------------
2190: ED36         ;-----------------------------------------------------------------
2191: ED36         ;--------------------------- Select  Drive ---------------------------------;
2192: ED36         ; Establish the disk found in (paramE) as the current disk drive            ;
2193: ED36             SelectCurrent:                      ;
2194: ED36 3A C2 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
2195: ED39 21 36 F5               LD     HL,currentDisk       ; Get the current disk              ;
2196: ED3C BE                     CP     M                    ; Are the the same ?                ;
2197: ED3D C8                     RET    Z                    ; Exit if yes, nothing to do        ;
2198: ED3E 77                     LD     (HL),A               ;  else update curretDisk and       ;
2199: ED3F C3 42 ED               JP     Select               ;  select it                        ;
2200: ED42         ;--------------------------- Select  Drive ---------------------------------;
2201: ED42         ;--------------------------- Select Login Drive ----------------------------;
2202: ED42         ; select Login Drive                                                       ;
2203: ED42             Select:                         ;
2204: ED42 CD 63 ED               CALL   SelectDisk           ; Select the Disk                   ;
2205: ED45 CC A5 F4               CALL   Z,errSelect          ;
2206: ED48 21 36 F5               LD     HL,currentDisk       ;
2207: ED4B 46                     LD     B,(HL)               ; Get Current Disk                  ;
2208: ED4C 2A 3A F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
2209: ED4F CD 77 F4               CALL   IsBitSet             ;
2210: ED52 C0                     RET    NZ                   ; Exit if already logged in         ;
2211: ED53         ;                                                                           ;
2212: ED53 21 36 F5               LD     HL,currentDisk       ;
2213: ED56 46                     LD     B,(HL)               ; Get Current Disk                  ;
2214: ED57 2A 3A F5               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
2215: ED5A CD 87 F4               CALL   SetVectorBit         ;
2216: ED5D 22 3A F5               LD     (loggedDisks),HL     ; Update the Vector                 ;
2217: ED60         ;
2218: ED60 C3 A9 ED               JP     InitDisk             ;
2219: ED63         ;--------------------------- Select Login Drive ----------------------------;
2220: ED63         ;--------------------------- Select Disk ------------------------------------;
2221: ED63         ;*****************************************************************          ;
2222: ED63         ; select the disk drive given by currentDisk, and fill the base addresses   ;
2223: ED63         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
2224: ED63             SelectDisk:                      ;
2225: ED63 3A 36 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
2226: ED66 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
2227: ED67 CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
2228: ED6A 7C                     LD     A,H                  ; Return Pointer to                  ;
2229: ED6B B5                     OR     L                    ;  Disk Parameter Header             ;
2230: ED6C C8                     RET    Z                    ; exit if error, with HL = 0000      ;
2231: ED6D         ;
2232: ED6D 5E                     LD     E,(HL)               ;
2233: ED6E 23                     INC    HL                   ;
2234: ED6F 56                     LD     D,(HL)               ; Skew Table in DE                   ;
2235: ED70 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
2236: ED71 ED 53 5B F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
2237: ED75         ;
2238: ED75 22 3E F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
2239: ED78 23                     INC    HL                   ;
2240: ED79 23                     INC    HL                   ; HL = Last Track #                  ;
2241: ED7A 22 40 F5               LD     (caTrack),HL         ; Move to Current Track #            ;
2242: ED7D 23                     INC    HL                   ;
2243: ED7E 23                     INC    HL                   ; HL = Last Sector #                 ;
2244: ED7F 22 42 F5               LD     (caSector),HL        ; Move to Current Sector #           ;
2245: ED82 23                     INC    HL                   ;
2246: ED83 23                     INC    HL                   ;
2247: ED84 11 44 F5               LD     DE,caDirectoryDMA    ;
2248: ED87 01 08 00               LD     BC,caListSize        ;
2249: ED8A ED B0                  LDIR                        ;
2250: ED8C         ;
2251: ED8C         ; finish filling in address list                                             ;
2252: ED8C 2A 46 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
2253: ED8F 11 4C F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
2254: ED92 01 0F 00               LD     BC,dpbSize           ;
2255: ED95 ED B0                  LDIR                        ; Move DPB to current                ;
2256: ED97         ;
2257: ED97         ; Determine if Byte or Word Allocation Table	                             ;
2258: ED97 2A 51 F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
2259: ED9A 7C                     LD     A,H                  ; If  its 00 then < 255              ;
2260: ED9B 21 65 F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
2261: ED9E 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
2262: EDA0 B7                     OR     A                    ;  is the assumption confirmed ?     ;
2263: EDA1 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
2264: EDA3 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
2265: EDA5         ;
2266: EDA5         ; Set Sign, reset Carry and Zero to indicate success                         ;
2267: EDA5             SelectDisk1:                      ;
2268: EDA5 3E FF                  LD     A,TRUE               ;
2269: EDA7 B7                     OR     A                    ;
2270: EDA8 C9                     RET                         ;
2271: EDA9         ;--------------------------- Select Disk ------------------------------------;
2272: EDA9         ;--------------------------- Initialize Disk --------------------------------;
2273: EDA9             InitDisk:                       ;
2274: EDA9 2A 51 F5               LD     HL,(dpbDSM)          ; Maximum allocation value           ;
2275: EDAC CD 4B F2               CALL   DivideHLby8          ; Length of Map                      ;
2276: EDAF E5                     PUSH   HL                   ; Save Length                        ;
2277: EDB0 E5                     PUSH   HL                   ; Save for end of MAP                ;
2278: EDB1 C1                     POP    BC                   ; BC = dpbDSM/8                      ;
2279: EDB2         ; Clear the Allocation Vector	                                             ;
2280: EDB2 2A 4A F5               LD     HL,(caAllocVector)   ; Allocation vector Start            ;
2281: EDB5 36 00                  LD     (HL),0               ; Clear location                     ;
2282: EDB7 ED 5B 4A F5               LD     DE,(caAllocVector)   ;
2283: EDBB 13                     INC    DE                   ; Allocation vector Start + 1        ;
2284: EDBC ED B0                  LDIR                        ; Cascade 00 thru Map                ;
2285: EDBE         ; Force bits at End of Map                                                   ;
2286: EDBE EB                     EX     DE,HL                ; Put last Map byte into DE          ;
2287: EDBF E1                     POP    HL                   ;
2288: EDC0 23                     INC    HL                   ;
2289: EDC1 CD 55 F2               CALL   MultiplyHLby8        ; Blocks if all bits used            ;
2290: EDC4 ED 4B 51 F5               LD     BC,(dpbDSM)          ; Actual block max                   ;
2291: EDC8 03                     INC    BC                   ; Now has size of the Map            ;
2292: EDC9 AF                     XOR    A                    ; Clear CY                           ;
2293: EDCA ED 42                  SBC    HL,BC                ; Extra unused bits                  ;
2294: EDCC BD                     CP     L                    ;  are there any                     ;
2295: EDCD 28 07                  JR     Z,Mark4Directory     ;
2296: EDCF 45                     LD     B,L                  ; Number of bits to set              ;
2297: EDD0 EB                     EX     DE,HL                ; Put last Map byte into HL          ;
2298: EDD1             SetBitLoop:                      ;
2299: EDD1 37                     SCF                         ;
2300: EDD2 CB 16                  RL     (HL)                 ; Set LSB                            ;
2301: EDD4 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                 ;
2302: EDD6         ;
2303: EDD6             Mark4Directory:                      ;
2304: EDD6         ; Mark the reserved space for the directory                                  ;
2305: EDD6 2A 55 F5               LD     HL,(dpbDABM)         ; Directory block reserved bits      ;
2306: EDD9 EB                     EX     DE,HL                ;
2307: EDDA 2A 4A F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector      ;
2308: EDDD 73                     LD     (HL),E               ;
2309: EDDE 23                     INC    HL                   ;
2310: EDDF 72                     LD     (HL),D               ; Put reserved blocks in Vector      ;
2311: EDE0         ; end of Map                                                                 ;
2312: EDE0         ; Home disk, and set current track and sector to 00                          ;
2313: EDE0 CD 30 EF               CALL   Home                 ;
2314: EDE3 2A 3E F5               LD     HL,(caDirMaxValue)   ;
2315: EDE6 36 03                  LD     (HL),3               ;
2316: EDE8 23                     INC    HL                   ;
2317: EDE9 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003       ;
2318: EDEB CD D5 F0               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)           ;
2319: EDEE         ;
2320: EDEE             InitDisk1:                      ;
2321: EDEE         ; Process the directory                                                      ;
2322: EDEE 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	     ;
2323: EDF0 CD 7C F2               CALL   ReadDirectory        ; Get the directory Record           ;
2324: EDF3 CD DC F0               CALL   AtEndOfDirectory     ; Are we Done ?                      ;
2325: EDF6 C8                     RET    Z                    ;  Exit if Yes                       ;
2326: EDF7         ; Not end of directory, valid entry?                                         ;
2327: EDF7 CD E5 F0               CALL   GetCurrentDirectoryRecord ; Calculate location of the element  ;
2328: EDFA 3E E5                  LD     A,emptyDir           ;
2329: EDFC BE                     CP     M                    ; Is it an Empty Dir Entry           ;
2330: EDFD 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                 ;
2331: EDFF         ; Not emptyDir, user code the same?                                          ;
2332: EDFF 3A 35 F5               LD     A,(currentUserNumber) ;
2333: EE02 BE                     CP     M                    ;
2334: EE03 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users   ;
2335: EE05         ; Same user, check for '$' submit                                            ;
2336: EE05 23                     INC    HL                   ;
2337: EE06 7E                     LD     A,(HL)               ;
2338: EE07 D6 24                  SUB    DOLLAR               ; Is first Char a $                  ;
2339: EE09 20 04                  JR     NZ,InitDisk2         ;
2340: EE0B         ; dollar file found, mark in exitParameterByte                               ;
2341: EE0B 3D                     DEC    A                    ; Set A to FFH                       ;
2342: EE0C 32 C5 EA               LD     (exitParameterByte),A ; Return it the exit parameter       ;
2343: EE0F             InitDisk2:                      ;
2344: EE0F         ; now scan the disk map for allocated blocks                                 ;
2345: EE0F 0E FF                  LD     C,TRUE               ; set to allocated                   ;
2346: EE11 CD 09 F1               CALL   ScanDiskMap          ;
2347: EE14 CD F3 F0               CALL   SetDirectoryEntry    ; Mark directory entry               ;
2348: EE17 18 D5                  JR     InitDisk1            ; Loop for another entry             ;
2349: EE19         ;--------------------------- Initialize Disk --------------------------------;
2350: EE19         ;----------------------------- Open File -----------------------------------;
2351: EE19         ;search for the directory entry matching FCB at paramDE						;
2352: EE19             OpenFile:                       ;
2353: EE19 0E 0F                  LD     C,nameLength         ;
2354: EE1B CD 2E F0               CALL   SearchForDirectoryRecord ;
2355: EE1E CD DC F0               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
2356: EE21 C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
2357: EE22         ;
2358: EE22             CopyDirRecordToFCB:                      ;
2359: EE22 CD D4 EF               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
2360: EE25 7E                     LD     A,(HL)               ; Get the EXT                      	;
2361: EE26 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
2362: EE27 E5                     PUSH   HL                   ;  also save FCB's pointer         	;
2363: EE28 CD E5 F0               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
2364: EE2B E5                     PUSH   HL                   ; Save Directory Record address    	;
2365: EE2C         ;
2366: EE2C ED 5B C3 EA               LD     DE,(paramDE)         ;
2367: EE30 01 20 00               LD     BC,fcbLength         ;
2368: EE33 ED B0                  LDIR                        ; Move dir record to FCB           	;
2369: EE35         ;
2370: EE35         ; note that entire fcb is copied, including indicators                    	;
2371: EE35 CD 11 F0               CALL   SetFileWriteFlag     ; Set clean file flag				;
2372: EE38 D1                     POP    DE                   ; Get Directory Record address     	;
2373: EE39 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
2374: EE3C 19                     ADD    HL,DE                ; Directory's EXT address          	;
2375: EE3D 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
2376: EE3E 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
2377: EE41 19                     ADD    HL,DE                ; Directory's RC address           	;
2378: EE42 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
2379: EE43 E1                     POP    HL                   ; Get FCB's Extent Address         	;
2380: EE44 F1                     POP    AF                   ; Get FCB's Extent Value           	;
2381: EE45 77                     LD     (HL),A               ; Restore Extent Value             	;
2382: EE46         ; if user ext < dir ext then user := 128 records                           	;
2383: EE46         ; if user ext = dir ext then user := dir records                           	;
2384: EE46         ; if user ext > dir ext then user := 0 records                             	;
2385: EE46 79                     LD     A,C                  ; Get the Dir's EXT                	;
2386: EE47 BE                     CP     M                    ; Does it match the FCB'd          	;
2387: EE48 78                     LD     A,B                  ; Get the Dir's  record count      	;
2388: EE49 CA 53 EE               JP     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
2389: EE4C 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
2390: EE4E DA 53 EE               JP     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
2391: EE51 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
2392: EE53             OpenSetRecordCount:                      ;
2393: EE53 2A C3 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
2394: EE56 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
2395: EE59 19                     ADD    HL,DE                ; FCB's record count               	;
2396: EE5A 77                     LD     (HL),A               ; Set the value                    	;
2397: EE5B C9                     RET                         ;
2398: EE5C         ;----------------------------- Open File -----------------------------------;
2399: EE5C         ;---------------------------- Close Directory Entry ------------------------;
2400: EE5C             CloseDirEntry:                      ;
2401: EE5C AF                     XOR    A                    ;
2402: EE5D 32 C5 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
2403: EE60 CD 78 EF               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
2404: EE63 C0                     RET    NZ                   ; Skip close if r/o disk            ;
2405: EE64         ; check file write flag - 0 indicates written                               ;
2406: EE64 CD 08 F0               CALL   GetWriteFileFlagValue ; Get file's WriteFileFlag          ;
2407: EE67 CB 7F                  BIT    7,A                  ;  Has it changed ?					;
2408: EE69         ;	AND		writeFlagMask				; Apply the RO Flag for S2          ;
2409: EE69 C0                     RET    NZ                   ; Skip close if clean file          ;
2410: EE6A         ;
2411: EE6A 0E 0F                  LD     C,nameLength         ;
2412: EE6C CD 2E F0               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
2413: EE6F CD DC F0               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
2414: EE72 C8                     RET    Z                    ;  exit if at EOD                   ;
2415: EE73         ;
2416: EE73         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
2417: EE73 CD E5 F0               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
2418: EE76 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
2419: EE79 09                     ADD    HL,BC                ;
2420: EE7A EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
2421: EE7B 2A C3 EA               LD     HL,(paramDE)         ;
2422: EE7E 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
2423: EE7F 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
2424: EE81         ;
2425: EE81             MergeAllocationMaps:                      ;
2426: EE81 3A 65 F5               LD     A,(byteAllocationFlag) ;
2427: EE84 B7                     OR     A                    ;
2428: EE85 CA 9C EE               JP     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2429: EE88         ; process byte size Map	                                                    ;
2430: EE88 7E                     LD     A,(HL)               ; FCB Block number                  ;
2431: EE89 B7                     OR     A                    ; Is it 0 ?                         ;
2432: EE8A 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2433: EE8B C2 8F EE               JP     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2434: EE8E 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2435: EE8F             MergeFCBisNot0:                      ;
2436: EE8F B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2437: EE90 C2 95 EE               JP     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2438: EE93 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2439: EE94 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2440: EE95             MergeDirEntryNot0:                      ;
2441: EE95 BE                     CP     M                    ; Do FCB and Dir match values       ;
2442: EE96 C2 D7 EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2443: EE99 C3 B1 EE               JP     MergeMapLoop         ; Go see if there is more           ;
2444: EE9C         ;
2445: EE9C             MergeWordMaps:                      ;
2446: EE9C CD 5F F2               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2447: EE9F EB                     EX     DE,HL                ;
2448: EEA0 CD 5F F2               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2449: EEA3 EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2450: EEA4 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2451: EEA5 BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2452: EEA6 C2 D7 EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2453: EEA9 13                     INC    DE                   ;
2454: EEAA 23                     INC    HL                   ; move on to the MSB                ;
2455: EEAB 1A                     LD     A,(DE)               ;
2456: EEAC BE                     CP     M                    ; do the check for equality         ;
2457: EEAD C2 D7 EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2458: EEB0 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2459: EEB1             MergeMapLoop:                      ;
2460: EEB1 13                     INC    DE                   ; Advance to the next positions     ;
2461: EEB2 23                     INC    HL                   ; in The Maps                       ;
2462: EEB3 0D                     DEC    C                    ; Are we done ?                     ;
2463: EEB4 C2 81 EE               JP     NZ,MergeAllocationMaps ;  No, do it again                  ;
2464: EEB7         ;
2465: EEB7         ; Check the EXT                                                             ;
2466: EEB7 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2467: EEBA 09                     ADD    HL,BC                ;
2468: EEBB EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2469: EEBC 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2470: EEBD 1A                     LD     A,(DE)               ; FCB's extent number               ;
2471: EEBE BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2472: EEBF DA CB EE               JP     C,CloseDirEntryEnd   ;  we are done if yes               ;
2473: EEC2 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2474: EEC3         ; Update directory record count field                                       ;
2475: EEC3 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2476: EEC6 09                     ADD    HL,BC                ;
2477: EEC7 EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2478: EEC8 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2479: EEC9 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2480: EECA 12                     LD     (DE),A               ;  the Directory Record RC          ;
2481: EECB         ;
2482: EECB             CloseDirEntryEnd:                      ;
2483: EECB 3E FF                  LD     A,TRUE               ;
2484: EECD 32 5D F5               LD     (fcbCopiedFlag),A    ;Set copied flag as true            ;
2485: EED0         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2486: EED0 CD AA F2               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2487: EED3 C3 AB F0               JP     WriteDir             ; Write the directory element       ;
2488: EED6 C9                     RET                         ;
2489: EED7         ;
2490: EED7             CloseDirEntryError:                      ;
2491: EED7 21 C5 EA               LD     HL,exitParameterByte ;
2492: EEDA 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2493: EEDB C9                     RET                         ;
2494: EEDC         ;---------------------------- Close Directory Entry ------------------------;
2495: EEDC         ;----------------------------------- Make new File -------------------------;
2496: EEDC         ;create a new file by creating a directory entry then opening the file      ;
2497: EEDC             MakeNewFile:                      ;
2498: EEDC CD BF F1               CALL   CheckWrite           ; Terminate with error if Disk R/O  ;
2499: EEDF 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB                       ;
2500: EEE2 E5                     PUSH   HL                   ; FCB                               ;
2501: EEE3 21 37 F5               LD     HL,emptyFCB          ;
2502: EEE6 22 C3 EA               LD     (paramDE),HL         ; Find the first empty dir record   ;
2503: EEE9 0E 01                  LD     C,1                  ;
2504: EEEB CD 2E F0               CALL   SearchForDirectoryRecord ; 0F5H in first position            ;
2505: EEEE CD DC F0               CALL   AtEndOfDirectory     ; Check if at end of directory      ;
2506: EEF1 E1                     POP    HL                   ; Recall the FCB pointer            ;
2507: EEF2 22 C3 EA               LD     (paramDE),HL         ;  in case we return here           ;
2508: EEF5 C8                     RET    Z                    ; Exit with No Dir space error      ;
2509: EEF6         ; fill Allocation Map with Zeros	                                        ;
2510: EEF6 11 0F 00               LD     DE,nameLength        ;
2511: EEF9 19                     ADD    HL,DE                ; Start of fill                     ;
2512: EEFA 36 00                  LD     (HL),00              ; Prime the values                  ;
2513: EEFC E5                     PUSH   HL                   ;
2514: EEFD D1                     POP    DE                   ; Copy to DE                        ;
2515: EEFE 13                     INC    DE                   ; adjust the to pointer             ;
2516: EEFF 01 10 00               LD     BC,fcbLength-nameLength-1 ; number of bytes to fill           ;
2517: EF02 ED B0                  LDIR                        ;
2518: EF04         ;
2519: EF04 2A C3 EA               LD     HL,(paramDE)         ; get FCB                           ;
2520: EF07 11 0D 00               LD     DE,fcbS1Index        ; Get the S1 index                  ;
2521: EF0A 19                     ADD    HL,DE                ; Point to S1                       ;
2522: EF0B 36 00                  LD     (HL),0               ; Set to 0                          ;
2523: EF0D CD F3 F0               CALL   SetDirectoryEntry    ; Update directory entry            ;
2524: EF10 CD D3 F1               CALL   CopyFCB              ; Update dir entry to Disk          ;
2525: EF13         ; and set the file write flag to "1"                                        ;
2526: EF13 C3 11 F0               JP     SetFileWriteFlag     ; Set the clean entry flag          ;
2527: EF16         ;----------------------------------- Make new File -------------------------;
2528: EF16
2529: EF16         ; DIO
2530: EF16
2531: EF16         ;---------------
2532: EF16         ; set a "1" value in currentDisk position of BC
2533: EF16         ; return in HL
2534: EF16             SetCurrentDiskBit:
2535: EF16 C5                     PUSH   BC                   ; save input parameter
2536: EF17 3A 36 F5               LD     A,(currentDisk)
2537: EF1A 4F                     LD     C,A                  ; ready parameter for shift
2538: EF1B 21 01 00               LD     HL,1                 ; number to shift
2539: EF1E CD 70 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
2540: EF21 C1                     POP    BC                   ; original mask
2541: EF22 79                     LD     A,C
2542: EF23 B5                     OR     L
2543: EF24 6F                     LD     L,A
2544: EF25 78                     LD     A,B
2545: EF26 B4                     OR     H
2546: EF27 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
2547: EF28 C9                     RET
2548: EF29         ;--------------
2549: EF29
2550: EF29         ;--------------------------- Scan      Map ----------------------------------;
2551: EF29         ;-----------------------------------
2552: EF29         ; byte value from ALLOC is in register A, with shift count
2553: EF29         ; in register C (to place bit back into position), and
2554: EF29         ; target ALLOC position in registers HL, rotate and replace
2555: EF29             RotateAndReplace:
2556: EF29 0F                     RRCA
2557: EF2A 15                     DEC    D
2558: EF2B C2 29 EF               JP     NZ,RotateAndReplace  ; back into position
2559: EF2E 77                     LD     (HL),A               ; back to ALLOC
2560: EF2F C9                     RET
2561: EF30         ;-----------------------------------
2562: EF30
2563: EF30         ;*****************************************************************
2564: EF30
2565: EF30         ;*****************************************************************
2566: EF30         ;=========================== Disk Utilities ================================;
2567: EF30         ;--------------------------- Home The Current Disk ------------------------;
2568: EF30         ;move to home position, then offset to start of dir                        ;
2569: EF30             Home:                           ;
2570: EF30 CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks      ;
2571: EF33         ; if Buffer needs to be written    ;
2572: EF33 21 59 F5               LD     HL,dpbOFF            ; Number of tracks before directory;
2573: EF36 4E                     LD     C,(HL)               ;
2574: EF37 23                     INC    HL                   ;
2575: EF38 46                     LD     B,(HL)               ;
2576: EF39 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position  ;
2577: EF3C         ;
2578: EF3C         ; Set Current Track and Sector to 00                                       ;
2579: EF3C AF                     XOR    A                    ; set ACC to 00                    ;
2580: EF3D 2A 40 F5               LD     HL,(caTrack)         ;
2581: EF40 77                     LD     (HL),A               ;
2582: EF41 23                     INC    HL                   ;
2583: EF42 77                     LD     (HL),A               ;
2584: EF43 2A 42 F5               LD     HL,(caSector)        ;
2585: EF46 77                     LD     (HL),A               ;
2586: EF47 23                     INC    HL                   ;
2587: EF48 77                     LD     (HL),A               ;
2588: EF49 C9                     RET                         ;
2589: EF4A         ;
2590: EF4A         ;--------------------------- Home The Current Disk ------------------------;
2591: EF4A         ;--------------------------- Set DMAs -------------------------------------;
2592: EF4A             SetDataDMA:                      ;
2593: EF4A 21 3C F5               LD     HL,initDAMAddress    ;
2594: EF4D 18 03                  JR     SetDMA               ; Skip to complete the call        ;
2595: EF4F         ;	LD		BC,initDAMAddress                                              ;
2596: EF4F         ;	JP		bcSetdma					; Call BIOS to set                 ;
2597: EF4F         ;
2598: EF4F             SetDirDMA:                      ;
2599: EF4F 21 44 F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
2600: EF52         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
2601: EF52         ;	JP		bcSetdma					; Call BIOS to set                 ;
2602: EF52         ;
2603: EF52             SetDMA:                         ;
2604: EF52 4E                     LD     C,(HL)               ;
2605: EF53 23                     INC    HL                   ;
2606: EF54 46                     LD     B,(HL)               ; parameter ready              ;
2607: EF55 C3 24 F6               JP     bcSetdma             ; call bios to set             ;
2608: EF58         ;--------------------------- Set DMAs -------------------------------------;
2609: EF58         ;--------------------------- Read Buffer ----------------------------------;
2610: EF58         ;reads into current DMA, using current Disk,Track and Sector               ;
2611: EF58             ReadBuffer:                      ;
2612: EF58 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
2613: EF5B B7                     OR     A                    ; Check status                     ;
2614: EF5C C2 CA F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2615: EF5F C9                     RET                         ;
2616: EF60         ;--------------------------- Read Buffer ----------------------------------;
2617: EF60         ;--------------------------- Set Current Disk Read Only --------------------;
2618: EF60         ;set current disk to read only                                              ;
2619: EF60             SetDiskReadOnly:                      ;
2620: EF60 2A 38 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2621: EF63         ;
2622: EF63 3A 36 F5               LD     A,(currentDisk)      ; Get the current disk              ;
2623: EF66 47                     LD     B,A                  ; Move into B                       ;
2624: EF67 CD 87 F4               CALL   SetVectorBit         ; Set the bit	                    ;
2625: EF6A 22 38 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2626: EF6D         ;
2627: EF6D 2A 53 F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2628: EF70 EB                     EX     DE,HL                ;
2629: EF71 2A 3E F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2630: EF74 73                     LD     (HL),E               ;
2631: EF75 23                     INC    HL                   ;
2632: EF76 72                     LD     (HL),D               ;
2633: EF77 C9                     RET                         ;
2634: EF78         ;--------------------------- Set disk Read Only ----------------------------;
2635: EF78         ;--------------------------- Is Disk Write Protected -----------------------;
2636: EF78         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2637: EF78         ;					= reset if Write Protected		(NZ)					;
2638: EF78             IsDiskWriteProtected:                      ;
2639: EF78 2A 38 F5               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2640: EF7B 3A 36 F5               LD     A,(currentDisk)      ; Get current disk                  ;
2641: EF7E 47                     LD     B,A                  ;
2642: EF7F CD 77 F4               CALL   IsBitSet             ; Check the bit                     ;
2643: EF82 C9                     RET                         ; NZ if Disk is RO                  ;
2644: EF83         ;--------------------------- Is Disk Write Protected -----------------------;
2645: EF83
2646: EF83         ;------------------------- Reselect Disk if Necessary ----------------------;
2647: EF83         ;check current fcb to see if reselection necessary                         ;
2648: EF83             ReselectDisk:                      ;
2649: EF83 3E FF                  LD     A,TRUE               ;
2650: EF85 32 66 F5               LD     (fResel),A           ; Mark as possible reselect         ;
2651: EF88 2A C3 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2652: EF8B 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2653: EF8C E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2654: EF8E 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2655: EF8F 32 C2 EA               LD     (paramE),A           ; Save drive code                   ;
2656: EF92 FE 1E                  CP     30                   ;
2657: EF94 D2 A7 EF               JP     NC,NoSelect          ; Skip drive >= 30                  ;
2658: EF97         ;
2659: EF97 3A 36 F5               LD     A,(currentDisk)      ; Determine the current drive       ;
2660: EF9A 32 67 F5               LD     (entryDisk),A        ; Save it                           ;
2661: EF9D 7E                     LD     A,(HL)               ;
2662: EF9E 32 68 F5               LD     (fcbDisk),A          ; Get calling disk                  ;
2663: EFA1 E6 E0                  AND    11100000B            ;
2664: EFA3 77                     LD     (HL),A               ; Preserve User Number              ;
2665: EFA4 CD 36 ED               CALL   SelectCurrent        ; Select the new disk               ;
2666: EFA7         ;
2667: EFA7             NoSelect:                       ;
2668: EFA7 3A 35 F5               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2669: EFAA 2A C3 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2670: EFAD B6                     OR     M                    ; Combine                           ;
2671: EFAE 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2672: EFAF C9                     RET                         ;
2673: EFB0         ;------------------------- Reselect Disk if Necessary ----------------------;
2674: EFB0
2675: EFB0
2676: EFB0         ;=========================== Disk Utilities ================================;
2677: EFB0
2678: EFB0         ;=========================== File Utilities ================================;
2679: EFB0         ;--------------------------- Set Record Variables -------------------------;
2680: EFB0         ;set variables from currently FCB - Current Record, RC, EXM                ;
2681: EFB0             SetRecordVars:                      ;
2682: EFB0 CD C7 EF               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2683: EFB3         ;  and HL => .CurrentRecord        ;
2684: EFB3 7E                     LD     A,(HL)               ;
2685: EFB4 32 6B F5               LD     (currentFileRecord),A ; Save current record              ;
2686: EFB7 EB                     EX     DE,HL                ;
2687: EFB8 7E                     LD     A,(HL)               ;
2688: EFB9 32 69 F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2689: EFBC CD D4 EF               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2690: EFBF 3A 50 F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2691: EFC2 A6                     AND    M                    ; Remove unwanted bits             ;
2692: EFC3 32 6A F5               LD     (extentValue),A      ; Store the value                  ;
2693: EFC6 C9                     RET                         ;
2694: EFC7         ;--------------------------- Set Record Variables -------------------------;
2695: EFC7         ;----------------------Get File Record Count and Current Record------------;
2696: EFC7         ; returns with DE pointing at RC from FCB                                  ;
2697: EFC7         ;         with HL pointing at Current Record                               ;
2698: EFC7             GetFcbRecordDetails:                      ;
2699: EFC7 2A C3 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2700: EFCA 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2701: EFCD 19                     ADD    HL,DE                ;
2702: EFCE EB                     EX     DE,HL                ; DE Points to Record Count        ;
2703: EFCF 21 11 00               LD     HL,recordSeq-fcbRCIndex ;
2704: EFD2 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2705: EFD3 C9                     RET                         ;
2706: EFD4         ;----------------------Get File Record Count and Current Record------------;
2707: EFD4         ;----------------------Get FileExtent--------------------------------------;
2708: EFD4         ;get current extent field address to (HL)                                 ;
2709: EFD4             GetExtentAddress:                      ;
2710: EFD4 2A C3 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2711: EFD7 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2712: EFDA 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2713: EFDB C9                     RET                         ;
2714: EFDC         ;----------------------Get FileExtent--------------------------------------;
2715: EFDC         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2716: EFDC         ; At Entry:	BC Contains to the Block to be modified                        ;
2717: EFDC         ;			E  = TRUE if bit is to be set                                  ;
2718: EFDC         ;			E  <> TRUE if bit is to be reset                               ;
2719: EFDC         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2720: EFDC             SetResetMapBit:                      ;
2721: EFDC         ;
2722: EFDC 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2723: EFDF 09                     ADD    HL,BC                ;  to HL                           ;
2724: EFE0 4B                     LD     C,E                  ; Move the flag to E               ;
2725: EFE1         ;
2726: EFE1 7D                     LD     A,L                  ; LSB of the Block Number          ;
2727: EFE2 E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2728: EFE4 F5                     PUSH   AF                   ; Save the OctetBit                ;
2729: EFE5 06 03                  LD     B,3                  ;
2730: EFE7 CD 4D F2               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2731: EFEA ED 5B 4A F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2732: EFEE 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2733: EFEF F1                     POP    AF                   ;
2734: EFF0 47                     LD     B,A                  ; Get the bit                      ;
2735: EFF1         ;
2736: EFF1 04                     INC    B                    ; Adjust for looping               ;
2737: EFF2 C5                     PUSH   BC                   ; Will need this later             ;
2738: EFF3             Left:                           ;
2739: EFF3 CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2740: EFF5 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2741: EFF7 C1                     POP    BC                   ; Restore loop limit and           ;
2742: EFF8 37                     SCF                         ;  set/reset flag                  ;
2743: EFF9 0C                     INC    C                    ; was C = TRUE                     ;
2744: EFFA 28 01                  JR     Z,Right              ; Skip if Set                      ;
2745: EFFC 3F                     CCF                         ; Set for Reset                    ;
2746: EFFD             Right:                          ;
2747: EFFD CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2748: EFFF 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2749: F001 C9                     RET                         ;
2750: F002         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2751: F002         ;--------------------- Initialize Extent Number MSB -----------------------;
2752: F002         ;clear the Extent number field for user open/make (S2)                    ;
2753: F002             InitializeExtentNumberMSB:                      ;
2754: F002 CD 08 F0               CALL   GetExtentNumberMSB   ;
2755: F005 36 00                  LD     (HL),0               ; Set it to = 0            ;
2756: F007 C9                     RET                         ;
2757: F008         ;--------------------- Initialize Extent Number MSB -----------------------;
2758: F008         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2759: F008         ; Get S2 value                                                             ;
2760: F008         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
2761: F008         ;			HL = Address of S2 for the FCB pointed to by paramDE           ;
2762: F008             GetWriteFileFlagValue:                      ; S2 bit 7                 ;
2763: F008             GetExtentNumberMSB:                      ; S2 bits 0-6              ;
2764: F008 2A C3 EA               LD     HL,(paramDE)         ; FCB address              ;
2765: F00B 11 0E 00               LD     DE,fcbS2Index        ; Index to value           ;
2766: F00E 19                     ADD    HL,DE                ; Address of value         ;
2767: F00F 7E                     LD     A,(HL)               ; load into ACC            ;
2768: F010 C9                     RET                         ;
2769: F011         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2770: F011         ;--------------------------- Set File Write Flag----------------------------;
2771: F011         ;Set file write flag in FCB in (paramDE)									;
2772: F011         ; Used to indicate the FCB is clean. No need to write on close				;
2773: F011             SetFileWriteFlag:                      ;
2774: F011 CD 08 F0               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2775: F014 CB FE                  SET    7,(HL)               ; Set the FileWriteFlag				;
2776: F016 C9                     RET                         ;
2777: F017         ;?	OR		writeFlagMask				; Set the flag , bit 7 of S2        ;
2778: F017         ;?	LD		(HL),A						; Put into FCB                      ;
2779: F017         ;?	RET	                                                                    ;
2780: F017         ;--------------------------- Set File Write Flag----------------------------;
2781: F017         ;--------------------------- Reset File Write Flag--------------------------;
2782: F017         ;Reset file write flag in FCB in (paramDE)									;
2783: F017         ; Used to indicate the FCB is dirty. Need to write on close					;
2784: F017             ResetFileWriteFlag:                      ;
2785: F017 CD 08 F0               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2786: F01A CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag			;
2787: F01C C9                     RET                         ;
2788: F01D         ;?	AND		0FFH-writeFlagMask			; Remove the flag bit		        ;
2789: F01D         ;?	LD		(HL),A						; Put into FCB                      ;
2790: F01D         ;?	RET	                                                                    ;
2791: F01D         ;--------------------------- Reset File Write Flag--------------------------;
2792: F01D         ;-------------------------- Compare FCB Extents ----------------------------;
2793: F01D         ; Enters:	A containing Target FCB EXT value								;
2794: F01D         ;			HL Points at Possible FCB EXT value								;
2795: F01D         ;compare extent# in A with that in C, return nonzero if they do not match	;
2796: F01D             CompareExtents:                      ;
2797: F01D C5                     PUSH   BC                   ; Save Callers Registers			;
2798: F01E F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2799: F01F 3A 50 F5               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2800: F022 2F                     CPL                         ; Complement for And           		;
2801: F023 47                     LD     B,A                  ; Put negated Mask into B      		;
2802: F024 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2803: F025 A0                     AND    B                    ; Apply the Mask               		;
2804: F026 4F                     LD     C,A                  ; Low bits removed from C      		;
2805: F027 F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2806: F028 A0                     AND    B                    ; Apply the Mask               		;
2807: F029 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2808: F02A E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2809: F02C C1                     POP    BC                   ; Restore Callers Registers    		;
2810: F02D C9                     RET                         ;
2811: F02E         ;-------------------------- Compare FCB Extents ----------------------------;
2812: F02E         ;---------------------Search for Directory Record --------------------------;
2813: F02E         ;  Search for directory record of length C.									;
2814: F02E         ; Target is pointed to by paramDE. The whole directory is searched.			;
2815: F02E         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2816: F02E         ; matched directory record													;
2817: F02E         ; Entry:	C = Search Length                                               ;
2818: F02E         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2819: F02E         ;								-1 (EOD) if there is no match				;
2820: F02E             SearchForDirectoryRecord:                      ;
2821: F02E 3E FF                  LD     A,0FFH               ;
2822: F030 32 5F F5               LD     (directoryIndex),A   ; Initialize directory Index        ;
2823: F033 21 62 F5               LD     HL,searchLength      ;
2824: F036 71                     LD     (HL),C               ; Save Search Length                ;
2825: F037 2A C3 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2826: F03A 22 63 F5               LD     (searchAddress),HL   ; Start of search                   ;
2827: F03D CD D5 F0               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2828: F040 CD 30 EF               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2829: F043         ;
2830: F043             GetNextDirectoryRecord:                      ;
2831: F043 0E 00                  LD     C,FALSE              ;
2832: F045 CD 7C F2               CALL   ReadDirectory        ; Read next Dir Record              ;
2833: F048 CD DC F0               CALL   AtEndOfDirectory     ;
2834: F04B CA A2 F0               JP     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2835: F04E         ;
2836: F04E 2A 63 F5               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2837: F051 EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2838: F052 1A                     LD     A,(DE)               ; User Number                       ;
2839: F053 FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2840: F055 CA 60 F0               JP     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2841: F058         ;
2842: F058         ; Check to be sure we are sill in the Directory                             ;
2843: F058 D5                     PUSH   DE                   ; Save search address               ;
2844: F059 CD FC F0               CALL   StillInDirectory     ; Still in the directorY            ;
2845: F05C D1                     POP    DE                   ; Recall address                    ;
2846: F05D D2 A2 F0               JP     NC,NoDirRecordsMatch ; Get out if past directory			;
2847: F060         ;
2848: F060             GetNextDirectoryRecord1:                      ;
2849: F060 CD E5 F0               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2850: F063 3A 62 F5               LD     A,(searchLength)     ;
2851: F066 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2852: F067 06 00                  LD     B,0                  ; Character Index (up)              ;
2853: F069         ;
2854: F069             TestNextPosition:                      ;
2855: F069 1A                     LD     A,(DE)               ;
2856: F06A FE 3F                  CP     QMARK                ; ? is always a char match          ;
2857: F06C CA 8A F0               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2858: F06F         ;
2859: F06F 78                     LD     A,B                  ;
2860: F070 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2861: F072 CA 8A F0               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2862: F075         ; not the fcbS1Index field, extent field?                                  ;
2863: F075 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2864: F077 1A                     LD     A,(DE)               ; Get next character                ;
2865: F078 CA 84 F0               JP     Z,CheckExtents       ; Skip to search extent             ;
2866: F07B 96                     SUB    M                    ; Do they match ?                   ;
2867: F07C E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2868: F07E C2 43 F0               JP     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2869: F081 C3 8A F0               JP     SetNextPosition      ; Matched the character             ;
2870: F084         ;                                                                           ;
2871: F084             CheckExtents:                      ;
2872: F084 CD 1D F0               CALL   CompareExtents       ; Matching EXTs is work             ;
2873: F087 C2 43 F0               JP     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2874: F08A         ;
2875: F08A             SetNextPosition:                      ;
2876: F08A 13                     INC    DE                   ; Pointer to Looking FOR            ;
2877: F08B 23                     INC    HL                   ; Pointer to Looking IN             ;
2878: F08C 04                     INC    B                    ; Character Index in FCB            ;
2879: F08D 0D                     DEC    C                    ; Length of search                  ;
2880: F08E C2 69 F0               JP     NZ,TestNextPosition  ;
2881: F091         ; Match Found, entire name matches                                          ;
2882: F091 3A 70 F5               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2883: F094 E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2884: F096 32 C5 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2885: F099         ;
2886: F099 21 5F F5               LD     HL,directoryIndex    ; Point at Directory Flag           ;
2887: F09C 7E                     LD     A,(HL)               ; Get value                         ;
2888: F09D 17                     RLA                         ; Set Carry if Flag = -1            ;
2889: F09E D0                     RET    NC                   ; Return with flag still -1         ;
2890: F09F         ;
2891: F09F AF                     XOR    A                    ; Else Clear the flag               ;
2892: F0A0 77                     LD     (HL),A               ;
2893: F0A1 C9                     RET                         ;  and exit                         ;
2894: F0A2         ;------                                                                     ;
2895: F0A2             NoDirRecordsMatch:                      ;
2896: F0A2 CD D5 F0               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2897: F0A5 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2898: F0A7 32 C5 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2899: F0AA C9                     RET                         ;
2900: F0AB         ;---------------------Search for Directory Record --------------------------;
2901: F0AB         ;---------------------------- Write Current Directory Entry ----------------;
2902: F0AB             WriteDir:                       ;
2903: F0AB         ;	CALL	NewCheckSum						; initialize entry              ;
2904: F0AB 0E FF                  LD     C,TRUE               ;
2905: F0AD CD F5 F2               CALL   CheckSumUtility      ; Set New CheckSum              ;
2906: F0B0         ;
2907: F0B0 CD 4F EF               CALL   SetDirDMA            ; Directory DMA                 ;
2908: F0B3 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
2909: F0B5 CD BB F0               CALL   WriteBuffer          ; Write the buffer              ;
2910: F0B8 C3 4A EF               JP     SetDataDMA           ; Reset DMA to default			;
2911: F0BB         ;
2912: F0BB         ;---------------------------- Write Current Directory Entry ----------------;
2913: F0BB         ;----------------------------------- Write Buffer --------------------------;
2914: F0BB         ; Write buffer and check condition. Current drive,Track, Sector and DMA     ;
2915: F0BB         ; Are set up prior to calling this routine                                  ;
2916: F0BB         ;                                                                           ;
2917: F0BB         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
2918: F0BB         ;				1 => directory write operation	WriteDirectory              ;
2919: F0BB         ;				2 => start of new block			WriteCleanBuffer			;
2920: F0BB             WriteBuffer:                      ;
2921: F0BB CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
2922: F0BE B7                     OR     A                    ; Get return code                   ;
2923: F0BF C2 CA F4               JP     NZ,erPermanentNoWait ; Error if not 00                   ;
2924: F0C2 C9                     RET                         ;
2925: F0C3         ;----------------------------------- Write Buffer --------------------------;
2926: F0C3         ;---------------------------- Update Record Vars ---------------------------;
2927: F0C3         ;update variables from I/O in  FCB                                          ;
2928: F0C3             UpdateRecordVariables:                      ;
2929: F0C3 CD C7 EF               CALL   GetFcbRecordDetails  ; DE => FCB RC, HL => CurrentRecord ;
2930: F0C6 3A 60 F5               LD     A,(seqDiskIOFlag)    ; If Seq IO it is set to 1			;
2931: F0C9 4F                     LD     C,A                  ;  and move it to C                 ;
2932: F0CA 3A 6B F5               LD     A,(currentFileRecord) ; Get NEXT_RECORD                   ;
2933: F0CD 81                     ADD    A,C                  ; Update record count               ;
2934: F0CE 77                     LD     (HL),A               ;  for CurrentRecord                ;
2935: F0CF EB                     EX     DE,HL                ;
2936: F0D0 3A 69 F5               LD     A,(fcbRecordCount)   ;
2937: F0D3 77                     LD     (HL),A               ;  and FCB RC                       ;
2938: F0D4 C9                     RET                         ;
2939: F0D5         ;---------------------------- Update Record Vars ---------------------------;
2940: F0D5
2941: F0D5         ; FU
2942: F0D5         ;=========================== File Utilities ================================;
2943: F0D5
2944: F0D5         ;=========================== Directory Utilities ===========================;
2945: F0D5         ;--------------------------- Set End of Directory indicator ----------------;
2946: F0D5             SetEndDirectory:                      ;
2947: F0D5 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
2948: F0D8 22 70 F5               LD     (dirEntryIndex),HL   ;
2949: F0DB C9                     RET                         ;
2950: F0DC         ;--------------------------- Set End of Directory indicator ----------------;
2951: F0DC         ;--------------------------- Are we at End Of Directory --------------------;
2952: F0DC         ; Tests to see if we are at the End Of the Directory                        ;
2953: F0DC         ;                                                                           ;
2954: F0DC         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
2955: F0DC         ;			 Z Flag reset if still in directory                             ;
2956: F0DC         ;
2957: F0DC             AtEndOfDirectory:                      ;
2958: F0DC 21 70 F5               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
2959: F0DF 7E                     LD     A,(HL)               ; Get it                            ;
2960: F0E0 23                     INC    HL                   ; Point at MSB	of Dir Index		;
2961: F0E1 BE                     CP     M                    ; LSB = MSB ?                       ;
2962: F0E2 C0                     RET    NZ                   ;  exit if not if different         ;
2963: F0E3         ; Same.  are they = 0ffh?           ;
2964: F0E3 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
2965: F0E4 C9                     RET                         ;
2966: F0E5         ;--------------------------- Are we at End Of Directory --------------------;
2967: F0E5         ;--------------------------- Get Directory Element -------------------------;
2968: F0E5         ; compute the address of a directory element in Directory Buffer            ;
2969: F0E5         ; Returns:  HL = Address of the specific directory Entry                    ;
2970: F0E5             GetCurrentDirectoryRecord:                      ;
2971: F0E5 C5                     PUSH   BC                   ; Save BC                           ;
2972: F0E6 2A 44 F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
2973: F0E9 3A 6F F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
2974: F0EC 4F                     LD     C,A                  ;
2975: F0ED AF                     XOR    A                    ; Set to Zero and reset CY          ;
2976: F0EE 47                     LD     B,A                  ;
2977: F0EF ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
2978: F0F1 C1                     POP    BC                   ; Restore	                        ;
2979: F0F2 C9                     RET                         ;
2980: F0F3         ;--------------------------- Get Directory Element -------------------------;
2981: F0F3         ;--------------------------- Set Directory Entry ---------------------------;
2982: F0F3         ; Will update directory if not in the directory                             ;
2983: F0F3         ;
2984: F0F3             SetDirectoryEntry:                      ;
2985: F0F3 CD FC F0               CALL   StillInDirectory     ;
2986: F0F6 D8                     RET    C                    ; Exit if still in the Directory  	;
2987: F0F7         ;
2988: F0F7         ; StillInDirectory will return with:                                        ;
2989: F0F7         ;									DE = Directory entry number             ;
2990: F0F7         ;									HL = Address of entry number + 1        ;
2991: F0F7 13                     INC    DE                   ;
2992: F0F8 72                     LD     (HL),D               ;
2993: F0F9 2B                     DEC    HL                   ;
2994: F0FA 73                     LD     (HL),E               ;
2995: F0FB C9                     RET                         ;
2996: F0FC         ;--------------------------- Set Directory Entry ---------------------------;
2997: F0FC         ;--------------------------- Are we sill in the Directory ------------------;
2998: F0FC         ;Returns	:                                                               ;
2999: F0FC         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
3000: F0FC         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
3001: F0FC         ;			HL = (address of Index Value) + 1                               ;
3002: F0FC         ;			DE = Directory Index Value                                      ;
3003: F0FC             StillInDirectory:                      ;
3004: F0FC 2A 70 F5               LD     HL,(dirEntryIndex)   ;
3005: F0FF EB                     EX     DE,HL                ; DE = directory counter            ;
3006: F100 2A 3E F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
3007: F103 7B                     LD     A,E                  ;
3008: F104 96                     SUB    M                    ;
3009: F105 23                     INC    HL                   ;
3010: F106 7A                     LD     A,D                  ;
3011: F107 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
3012: F108 C9                     RET                         ;  <= Directory Max Value       ;
3013: F109         ;--------------------------- Are we sill in the Directory ------------------;
3014: F109         ;--------------------------- Scan Disk Map ---------------------------------;
3015: F109         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
3016: F109         ;                                                                           ;
3017: F109         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
3018: F109         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
3019: F109         ;
3020: F109             ScanDiskMap:                      ;
3021: F109 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
3022: F10A CD E5 F0               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
3023: F10D 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
3024: F110 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
3025: F111 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
3026: F113         ;
3027: F113             ScanDiskMap0:                      ;
3028: F113 D1                     POP    DE                   ; Recall the set/reset Info         ;
3029: F114 0D                     DEC    C                    ;
3030: F115 C8                     RET    Z                    ; Loop once for each disk map entry ;
3031: F116         ;
3032: F116 D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
3033: F117 3A 65 F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
3034: F11A B7                     OR     A                    ;
3035: F11B 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
3036: F11D         ;  Byte Allocation scan operation                                           ;
3037: F11D C5                     PUSH   BC                   ; Save counter                      ;
3038: F11E E5                     PUSH   HL                   ; Save map address                  ;
3039: F11F 4E                     LD     C,(HL)               ;
3040: F120 06 00                  LD     B,0                  ; BC=block# for Byte                ;
3041: F122 18 06                  JR     ScanDiskMap2         ;
3042: F124         ; Word scan operation                                                       ;
3043: F124             ScanDiskMapWord:                      ;
3044: F124 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
3045: F125 C5                     PUSH   BC                   ; Save counter                      ;
3046: F126 46                     LD     B,(HL)               ;
3047: F127 23                     INC    HL                   ;
3048: F128 4E                     LD     C,(HL)               ; BC=block# for Word                ;
3049: F129 E5                     PUSH   HL                   ; Save map address                  ;
3050: F12A         ;
3051: F12A         ; Arrive here with BC=block#, E=0/1	                                        ;
3052: F12A             ScanDiskMap2:                      ;
3053: F12A 79                     LD     A,C                  ;
3054: F12B B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
3055: F12C C4 DC EF               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
3056: F12F E1                     POP    HL                   ;
3057: F130 23                     INC    HL                   ; to next bit position              ;
3058: F131 C1                     POP    BC                   ; recall counter                    ;
3059: F132 C3 13 F1               JP     ScanDiskMap0         ; for another item                  ;
3060: F135         ;
3061: F135         ;--------------------------- Scan Disk Map ---------------------------------;
3062: F135         ;--------------------------- Get Closest Disk Block ------------------------;
3063: F135         ; Find the closest available disk block, and mark in Map as allocated       ;
3064: F135         ; Enter	BC	= Block number to base the search on                            ;
3065: F135         ; Exit	HL	= 0000 if There are no available open blocks                    ;
3066: F135         ;			= block number of available and marked block                    ;
3067: F135         ;
3068: F135             GetClosestBlock:                      ;
3069: F135 C5                     PUSH   BC                   ; save the starting Block #         ;
3070: F136         ;
3071: F136 2A 51 F5               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
3072: F139 CD 4B F2               CALL   DivideHLby8          ; Length of Map	                    ;
3073: F13C EB                     EX     DE,HL                ; put size into DE			        ;
3074: F13D E1                     POP    HL                   ; Block number into HL              ;
3075: F13E CD 4B F2               CALL   DivideHLby8          ; Length of Map                     ;
3076: F141 EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
3077: F142 AF                     XOR    A                    ; Reset CY                          ;
3078: F143 ED 52                  SBC    HL,DE                ; Size for right                    ;
3079: F145         ; DE = Start Index                                                          ;
3080: F145         ; DE = Left Size                                                            ;
3081: F145         ; HL	= Right Size                                                        ;
3082: F145 E5                     PUSH   HL                   ; Save right size                   ;
3083: F146 D5                     PUSH   DE                   ; Save left size & Start Index      ;
3084: F147 3E FF                  LD     A,0FFH               ; Full Octet                        ;
3085: F149         ;
3086: F149 2A 4A F5               LD     HL,(caAllocVector)   ; Start of Map                      ;
3087: F14C 19                     ADD    HL,DE                ; Determine initial Octet			;
3088: F14D         ; Set up Left side                                                          ;
3089: F14D C1                     POP    BC                   ; Left size                         ;
3090: F14E 03                     INC    BC                   ; adjust                            ;
3091: F14F E5                     PUSH   HL                   ; Save initial Octet                ;
3092: F150 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
3093: F153         ; HL = Initial Octet                                                        ;
3094: F153         ; BC = Left Size                                                            ;
3095: F153 D9                     EXX                         ; Use alternate registers           ;
3096: F154 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
3097: F157 E1                     POP    HL                   ; Get Initial Octet                 ;
3098: F158 C1                     POP    BC                   ; Get Right Size                    ;
3099: F159 03                     INC    BC                   ; adjust                            ;
3100: F15A             LookRight:                      ;
3101: F15A ED A1                  CPI                         ; UnSet Bit?                        ;
3102: F15C 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3103: F15E E2 77 F1               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
3104: F161         ;
3105: F161 D9                     EXX                         ; Switch to the Left                ;
3106: F162 ED A9                  CPD                         ; UnSet Bit?                        ;
3107: F164 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3108: F166 E2 6C F1               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
3109: F169 D9                     EXX                         ; switch to right                   ;
3110: F16A 18 EE                  JR     LookRight            ; Keep on looking                   ;
3111: F16C         ;			----------------			                                    ;
3112: F16C             NoMoreLeft:                      ;
3113: F16C D9                     EXX                         ; Switch to Right                   ;
3114: F16D             NoMoreLeftLoop:                      ;
3115: F16D ED A1                  CPI                         ;
3116: F16F 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3117: F171 E2 82 F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
3118: F174 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
3119: F176 76                     HALT                        ;
3120: F177             NoMoreRight:                      ;
3121: F177 D9                     EXX                         ; Switch to Left                    ;
3122: F178             NoMoreRightLoop:                      ;
3123: F178 ED A9                  CPD                         ;
3124: F17A 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3125: F17C E2 82 F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
3126: F17F 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
3127: F181 76                     HALT                        ;
3128: F182             NoFreeBlocks:                      ;
3129: F182 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
3130: F185 C9                     RET                         ;
3131: F186         ;			----------------			                                    ;
3132: F186             FoundFreeOctet:                      ;
3133: F186 BB                     CP     E                    ; Left or Right                     ;
3134: F187 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
3135: F189 2B                     DEC    HL                   ; Adjust for direction              ;
3136: F18A 18 01                  JR     FoundFreeOctet2      ;
3137: F18C         ;
3138: F18C             FoundFreeOctet1:                      ;
3139: F18C 23                     INC    HL                   ; Adjust for direction              ;
3140: F18D             FoundFreeOctet2:                      ;
3141: F18D 01 00 00               LD     BC,00                ; need to keep track of bit         ;
3142: F190             FoundFreeOctet3:                      ;
3143: F190 CB 06                  RLC    (HL)                 ;
3144: F192 03                     INC    BC                   ;
3145: F193 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
3146: F195 CB C6                  SET    0,(HL)               ; Make map bit set                  ;
3147: F197 41                     LD     B,C                  ; Put count in B                    ;
3148: F198             FoundFreeOctet4:                      ;
3149: F198 CB 0E                  RRC    (HL)                 ;
3150: F19A 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
3151: F19C 0B                     DEC    BC                   ; adjust for Zero based value       ;
3152: F19D C5                     PUSH   BC                   ; Save the bit index                ;
3153: F19E ED 4B 4A F5               LD     BC,(caAllocVector)   ; Get Map start                     ;
3154: F1A2 AF                     XOR    A                    ; Clear CY                          ;
3155: F1A3 ED 42                  SBC    HL,BC                ; Get how far in the map            ;
3156: F1A5 CD 55 F2               CALL   MultiplyHLby8        ; Calculate the Octet           ;
3157: F1A8 C1                     POP    BC                   ; Restore index into Octet          ;
3158: F1A9 09                     ADD    HL,BC                ; This is the Block Number          ;
3159: F1AA C9                     RET                         ;
3160: F1AB         ;--------------------------- Get Closest Disk Block ------------------------;
3161: F1AB         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3162: F1AB             CopyDirEntryToUserDMA:                      ;
3163: F1AB 2A 44 F5               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer         ;
3164: F1AE ED 5B 3C F5               LD     DE,(initDAMAddress)  ; Point at User's Buffer            ;
3165: F1B2 01 80 00               LD     BC,cpmRecordSize     ; The entire record                 ;
3166: F1B5 ED B0                  LDIR                        ; Move it                           ;
3167: F1B7 C9                     RET                         ;
3168: F1B8         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3169: F1B8         ;--------------------- Return last Directory Index to Caller ---------------;
3170: F1B8             DirLocationToReturnLoc:                      ;
3171: F1B8 3A 5F F5               LD     A,(directoryIndex)   ; Get last directory Index          ;
3172: F1BB 32 C5 EA               LD     (exitParameterByte),A ; Save for return to Caller         ;
3173: F1BE C9                     RET                         ;
3174: F1BF         ;--------------------- Return last Directory Index to Caller ---------------;
3175: F1BF         ;--------------------------- Check OK to Write to Disk ---------------------;
3176: F1BF             CheckWrite:                      ;
3177: F1BF CD 78 EF               CALL   IsDiskWriteProtected ; Is this disk Write Protected?     ;
3178: F1C2 C8                     RET    Z                    ; OK to write                       ;
3179: F1C3 C3 AB F4               JP     errReadOnlyDisk      ; Report read only disk error		;
3180: F1C6         ;--------------------------- Check OK to Write to Disk ---------------------;
3181: F1C6         ;--------------------------- Check File Write Protect Status ---------------;
3182: F1C6             CheckRODirectory:                      ;
3183: F1C6 CD E5 F0               CALL   GetCurrentDirectoryRecord ; Use Entry in Directory Buffer     ;
3184: F1C9         ; Use HL as the directory entry in Question                                 ;
3185: F1C9             CheckROFile:                      ;
3186: F1C9 11 09 00               LD     DE,fcbROfileIndex    ; Index into FC for RO              ;
3187: F1CC 19                     ADD    HL,DE                ; point at the byte                 ;
3188: F1CD 7E                     LD     A,(HL)               ;
3189: F1CE 17                     RLA                         ; Set CY if RO bit set              ;
3190: F1CF D0                     RET    NC                   ; Return OK                         ;
3191: F1D0 C3 B1 F4               JP     errReadOnlyFile      ; Report to read only File          ;
3192: F1D3         ;--------------------------- Check File Write Protect Status ---------------;
3193: F1D3         ;------------------------- Copy FCB To Directory record --------------------;
3194: F1D3         ; On Entry:                                                                 ;
3195: F1D3         ;			C = Starting position                                           ;
3196: F1D3         ;			E = length of copy                                              ;
3197: F1D3         ;copy the whole file control block                                          ;
3198: F1D3             CopyFCB:                        ;
3199: F1D3 0E 00                  LD     C,0                  ;
3200: F1D5 1E 20                  LD     E,fcbLength          ; Copy all of the FCB		    ;
3201: F1D7         ; On Entry:                                                                 ;
3202: F1D7         ;			C = Starting position                                           ;
3203: F1D7         ;			E = length of copy                                              ;
3204: F1D7             CopyDir:                        ;
3205: F1D7 16 00                  LD     D,0                  ; Make length a word value      ;
3206: F1D9 D5                     PUSH   DE                   ; Length                        ;
3207: F1DA 06 00                  LD     B,0                  ; Make index a word             ;
3208: F1DC 2A C3 EA               LD     HL,(paramDE)         ; HL = source for data          ;
3209: F1DF 09                     ADD    HL,BC                ;
3210: F1E0 EB                     EX     DE,HL                ;
3211: F1E1 CD E5 F0               CALL   GetCurrentDirectoryRecord ; HL pointer to Dir Record      ;
3212: F1E4 EB                     EX     DE,HL                ;
3213: F1E5 C1                     POP    BC                   ; Length                        ;
3214: F1E6 ED B0                  LDIR                        ;
3215: F1E8 CD AA F2               CALL   SeekDir              ; Seek to the dir entry         ;
3216: F1EB C3 AB F0               JP     WriteDir             ; Write the directory element   ;
3217: F1EE         ;------------------------- Copy FCB from Directory record ------------------;
3218: F1EE         ;-------------------------------- Get Block Number -------------------------;
3219: F1EE         ;compute disk block number from current fcb                                ;
3220: F1EE             GetBlockNumber:                      ;
3221: F1EE CD FB F1               CALL   GetDiskMapIndex      ;Return Alloc block index           ;
3222: F1F1 4F                     LD     C,A                  ;
3223: F1F2 06 00                  LD     B,0                  ;
3224: F1F4 CD 08 F2               CALL   GetDiskMapValue      ; Convert to Disk record            ;
3225: F1F7 22 6D F5               LD     (absoluteCPMRecord),HL ; Save                              ;
3226: F1FA C9                     RET                         ;
3227: F1FB         ;-------------------------------- Get Block Number -------------------------;
3228: F1FB         ;-------------------------------- Get Disk Map Index -----------------------;
3229: F1FB         ;Return the  disk map Index for current File Record in the ACC              ;
3230: F1FB             GetDiskMapIndex:                      ;
3231: F1FB 21 4E F5               LD     HL,dpbBSH            ; Block# = Record# / (2***dpbBSH)   ;
3232: F1FE 46                     LD     B,(HL)               ; shift count                       ;
3233: F1FF 3A 6B F5               LD     A,(currentFileRecord) ;
3234: F202             GetDiskMapIndexLoop:                      ;
3235: F202 CB 3F                  SRL    A                    ;
3236: F204 10 FC                  DJNZ   GetDiskMapIndexLoop  ; Loop till done                    ;
3237: F206 00                     NOP                         ;
3238: F207 C9                     RET                         ;
3239: F208         ;-------------------------------- Get Disk Map Index -----------------------;
3240: F208         ;-------------------------------- Get Disk Map Value -----------------------;
3241: F208         ; Enter with Disk Map Index in BC                                           ;
3242: F208         ; Return disk map value  in HL                                              ;
3243: F208             GetDiskMapValue:                      ;
3244: F208 2A C3 EA               LD     HL,(paramDE)         ; FCB                               ;
3245: F20B 11 10 00               LD     DE,fcbDiskMapIndex   ; Index to Allocation Map           ;
3246: F20E 19                     ADD    HL,DE                ; Address of Allocation Map Start   ;
3247: F20F 09                     ADD    HL,BC                ; Point at the targeted map entry   ;
3248: F210 3A 65 F5               LD     A,(byteAllocationFlag) ; Is this a byte or word            ;
3249: F213 B7                     OR     A                    ;
3250: F214 28 04                  JR     Z,GetDiskMap16Bit    ; Skip if word value                ;
3251: F216 6E                     LD     L,(HL)               ;  else its a byte value            ;
3252: F217 26 00                  LD     H,0                  ;load the byte into HL              ;
3253: F219 C9                     RET                         ;
3254: F21A         ;
3255: F21A             GetDiskMap16Bit:                      ;
3256: F21A 09                     ADD    HL,BC                ; make it double width              ;
3257: F21B 56                     LD     D,(HL)               ;
3258: F21C 23                     INC    HL                   ;
3259: F21D 5E                     LD     E,(HL)               ; Load word value into DE           ;
3260: F21E EB                     EX     DE,HL                ; return value in HL                ;
3261: F21F C9                     RET                         ;
3262: F220         ;-------------------------------- Get Disk Map Value -----------------------;
3263: F220         ;-------------------------------- Allocate The Block -----------------------;
3264: F220         ;is  block allocated                                                        ;
3265: F220             WasBlockAllocated:                      ;
3266: F220 2A 6D F5               LD     HL,(absoluteCPMRecord) ; Get the Block Number              ;
3267: F223 7D                     LD     A,L                  ; ZFlag set if                      ;
3268: F224 B4                     OR     H                    ;  absoluteCPMRecord = 0            ;
3269: F225 C9                     RET                         ;
3270: F226         ;-------------------------------- Allocate The Block -----------------------;
3271: F226         ;----------------------------- Set Actual Record Add -----------------------;
3272: F226         ;
3273: F226         ;compute actual record address                                              ;
3274: F226         ; result = absolute CPMRecord * ( 2**BSH)                                  ;
3275: F226             SetActualRecordAdd:                      ;
3276: F226 3A 4E F5               LD     A,(dpbBSH)           ; Block Shift to loop control       ;
3277: F229 47                     LD     B,A
3278: F22A 2A 6D F5               LD     HL,(absoluteCPMRecord) ;
3279: F22D         ;
3280: F22D             SetActualRecordAddLoop:                      ;
3281: F22D 29                     ADD    HL,HL                ;
3282: F22E 10 FD                  DJNZ   SetActualRecordAddLoop ;
3283: F230         ;?	DEC		A								; shl(absolute CPMRecord,dpbBSH);
3284: F230         ;?	JP	NZ,SetActualRecordAddLoop                                           ;
3285: F230         ;
3286: F230         ; HL has Record number for start of the block;                              ;
3287: F230 3A 4F F5               LD     A,(dpbBLM)           ; Get block mask to get current     ;
3288: F233 4F                     LD     C,A                  ;  File Record mod Block            ;
3289: F234 3A 6B F5               LD     A,(currentFileRecord) ; Get index into block              ;
3290: F237 A1                     AND    C                    ; Record index in Block             ;
3291: F238 B5                     OR     L                    ;
3292: F239 6F                     LD     L,A                  ; to HL                             ;
3293: F23A 22 6D F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL            ;
3294: F23D         ; *** Absolute CPM Record now has current record number                     ;
3295: F23D         ; - Starting record number + index into block                               ;
3296: F23D C9                     RET                         ;
3297: F23E         ;----------------------------- Set Actual Record Add -----------------------;
3298: F23E
3299: F23E         ;=========================== Directory Utilities ===========================;
3300: F23E         ; DU
3301: F23E
3302: F23E         ;=========================== General   Utilities ===========================;
3303: F23E
3304: F23E         ;--------------------------- Rotate HL right by value in C ----------------;
3305: F23E         ;
3306: F23E         ; HL = Value to be rotated Right                                           ;
3307: F23E         ;  B = Amount to shift                                                     ;
3308: F23E             RotateRightHLbyB:                      ;
3309: F23E 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
3310: F23F CB 45                  BIT    0,L                  ; is LSB set?                      ;
3311: F241 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
3312: F243 3F                     CCF                         ; else Clear Carry flag            ;
3313: F244             RotateRightHLbyB1:                      ;
3314: F244 CB 1C                  RR     H                    ; Shift thru CY                    ;
3315: F246 CB 1D                  RR     L                    ; ditto                            ;
3316: F248 10 F4                  DJNZ   RotateRightHLbyB     ;
3317: F24A C9                     RET                         ;
3318: F24B         ;
3319: F24B         ;--------------------------- Rotate HL right by value in C ----------------;
3320: F24B         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
3321: F24B         ; HL = Value to be shifted Right                                           ;
3322: F24B             DivideHLby8:                      ;
3323: F24B 06 03                  LD     B,3                  ; 8 = 2**3						   ;
3324: F24D         ;  B = Amount to shift                                                     ;
3325: F24D             ShiftRightHLbyB:                      ;
3326: F24D AF                     XOR    A                    ; else Clear Carry flag            ;
3327: F24E CB 1C                  RR     H                    ; Shift thru CY                    ;
3328: F250 CB 1D                  RR     L                    ; ditto                            ;
3329: F252 10 F9                  DJNZ   ShiftRightHLbyB      ;
3330: F254 C9                     RET                         ;
3331: F255         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
3332: F255         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
3333: F255         ; HL = Value to be shifted Left                                            ;
3334: F255             MultiplyHLby8:                      ;
3335: F255 06 03                  LD     B,3                  ; 8 = 2**3						   ;
3336: F257         ;  B = Amount to shift                                                     ;
3337: F257             ShiftLeftHLbyB:                      ;
3338: F257 AF                     XOR    A                    ; else Clear Carry flag            ;
3339: F258 CB 15                  RL     L                    ; Shift thru CY                    ;
3340: F25A CB 14                  RL     H                    ; ditto                            ;
3341: F25C 10 F9                  DJNZ   ShiftLeftHLbyB       ;
3342: F25E C9                     RET                         ;
3343: F25F         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
3344: F25F         ;----------------------------- Merge ---------------------------------------;
3345: F25F         ; Merge Map Block Numbers between FCB and directory record                  ;
3346: F25F         ; HL has pointer to map for either dir record or FCB,                       ;
3347: F25F         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
3348: F25F         ; it just returns, Else it copies the block number to where DE is pointing  ;
3349: F25F         ;
3350: F25F             Merge:                          ;
3351: F25F 7E                     LD     A,(HL)               ; Get the first byte                ;
3352: F260 23                     INC    HL                   ;
3353: F261 B6                     OR     M                    ; OR it with the second byte        ;
3354: F262 2B                     DEC    HL                   ; Restore HL to start               ;
3355: F263 C0                     RET    NZ                   ; Exit if both are 0s               ;
3356: F264         ; HL points to a non Zero value	                                            ;
3357: F264 1A                     LD     A,(DE)               ; Get the first byte                ;
3358: F265 77                     LD     (HL),A               ; Move it                           ;
3359: F266 13                     INC    DE                   ;
3360: F267 23                     INC    HL                   ; Increment both pointers           ;
3361: F268 1A                     LD     A,(DE)               ; Get the second byte               ;
3362: F269 77                     LD     (HL),A               ; Move it                           ;
3363: F26A 1B                     DEC    DE                   ;
3364: F26B 2B                     DEC    HL                   ; Restore HL & DE to start          ;
3365: F26C C9                     RET                         ;
3366: F26D         ;----------------------------- Merge ---------------------------------------;
3367: F26D         ;------------------------- Set Exit Parameter To 1 -------------------------;
3368: F26D             SetExitParamTo1:                      ;
3369: F26D 3E 01                  LD     A,1                  ;
3370: F26F 32 C5 EA               LD     (exitParameterByte),A ; Put a 1 in the exit parameter     ;
3371: F272 C9                     RET                         ;
3372: F273         ;------------------------- Set Exit Parameter To 1 -------------------------;
3373: F273
3374: F273         ; GU
3375: F273
3376: F273         ;=========================== General   Utilities ===========================;
3377: F273
3378: F273         ;--------------------------- Read Directory Record -------------------------;
3379: F273         ; read a directory entry into the directory buffer                          ;
3380: F273             ReadDirRecord:                      ;
3381: F273 CD 4F EF               CALL   SetDirDMA            ; System Assigned Buffer            ;
3382: F276 CD 58 EF               CALL   ReadBuffer           ; Go to BIOS for the read           ;
3383: F279 C3 4A EF               JP     SetDataDMA           ; Restore DMA                       ;
3384: F27C         ;--------------------------- Read Directory Record -------------------------;
3385: F27C
3386: F27C         ;--------------------------- Read Directory --------------------------------;
3387: F27C         ; Read next directory entry                                                 ;
3388: F27C         ; Enter :                                                                   ;
3389: F27C         ;		C =  TRUE initializing and setting CheckSum                         ;
3390: F27C         ;		  <> TRUE Checking existing CheckSum                                ;
3391: F27C             ReadDirectory:                      ;
3392: F27C ED 5B 53 F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
3393: F280 2A 70 F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
3394: F283 23                     INC    HL                   ; Increment the Index               ;
3395: F284 22 70 F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
3396: F287 AF                     XOR    A                    ; Clear the CY flag                 ;
3397: F288 ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
3398: F28A 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
3399: F28C CD D5 F0               CALL   SetEndDirectory      ;  else we are done                 ;
3400: F28F C9                     RET                         ;
3401: F290         ;
3402: F290         ; Calculate the entry index Position in Buffer                              ;
3403: F290             ReadDirectory0:                      ;
3404: F290 3A 70 F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
3405: F293 E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
3406: F295 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
3407: F297             ReadDirectory1:                      ;
3408: F297 87                     ADD    A,A                  ;
3409: F298 10 FD                  DJNZ   ReadDirectory1       ;
3410: F29A 32 6F F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
3411: F29D B7                     OR     A                    ; Is this the 1st entry?            ;
3412: F29E C0                     RET    NZ                   ;  return if not.                   ;
3413: F29F         ;
3414: F29F C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
3415: F2A0 CD AA F2               CALL   SeekDir              ; Set up for Directory Read         ;
3416: F2A3 CD 73 F2               CALL   ReadDirRecord        ; Read the directory record         ;
3417: F2A6 C1                     POP    BC                   ; Recall initialization flag        ;
3418: F2A7 C3 F5 F2               JP     CheckSumUtility      ; Checksum the directory            ;
3419: F2AA         ;--------------------------- Read Directory --------------------------------;
3420: F2AA         ;--------------------------- Seek Directory --------------------------------;
3421: F2AA         ;seek the record containing the current directory entry					;
3422: F2AA             SeekDir:                        ;
3423: F2AA 2A 70 F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
3424: F2AD 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
3425: F2AF CD 4D F2               CALL   ShiftRightHLbyB      ;
3426: F2B2 22 6D F5               LD     (absoluteCPMRecord),HL ;
3427: F2B5 22 72 F5               LD     (dirRecord),HL       ; Save                              ;
3428: F2B8 C3 BB F2               JP     Seek                 ;
3429: F2BB         ;--------------------------- Seek Directory --------------------------------;
3430: F2BB         ;--------------------------- Seek ------------------------------------------;
3431: F2BB             Seek:                           ;
3432: F2BB 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
3433: F2BE 2A 6D F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
3434: F2C1 ED 5B 4C F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
3435: F2C5         ;
3436: F2C5             Seek0:                          ;
3437: F2C5 03                     INC    BC                   ; Divide the record                 ;
3438: F2C6 AF                     XOR    A                    ;  by the sectors per track         ;
3439: F2C7 ED 52                  SBC    HL,DE                ;
3440: F2C9 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
3441: F2CB         ;
3442: F2CB         ;
3443: F2CB 19                     ADD    HL,DE                ; Gets the sector in the track      ;
3444: F2CC E5                     PUSH   HL                   ; Save Index Sector                 ;
3445: F2CD         ;
3446: F2CD DD 2A 40 F5               LD     IX,(caTrack)         ;
3447: F2D1 DD 71 00               LD     (IX+0),C             ;
3448: F2D4 DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
3449: F2D7         ;
3450: F2D7 EB                     EX     DE,HL                ; Take the index from the record    ;
3451: F2D8 2A 6D F5               LD     HL,(absoluteCPMRecord) ;
3452: F2DB AF                     XOR    A                    ;
3453: F2DC ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
3454: F2DE         ;
3455: F2DE DD 2A 42 F5               LD     IX,(caSector)        ;
3456: F2E2 DD 75 00               LD     (IX+0),L             ;
3457: F2E5 DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
3458: F2E8         ;
3459: F2E8 2A 59 F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
3460: F2EB 09                     ADD    HL,BC                ;  to add to the gross Track        ;
3461: F2EC E5                     PUSH   HL                   ;  which yields the net or          ;
3462: F2ED C1                     POP    BC                   ;  actual track for the record      ;
3463: F2EE CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
3464: F2F1         ;
3465: F2F1 C1                     POP    BC                   ; Get the sector within the track   ;
3466: F2F2 C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
3467: F2F5         ;
3468: F2F5         ;--------------------------- Seek ------------------------------------------;
3469: F2F5         ;--------------------------- Check Sum Utility -----------------------------;
3470: F2F5         ; At entry                                                                  ;
3471: F2F5         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
3472: F2F5         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
3473: F2F5         ;
3474: F2F5             CheckSumUtility:                      ;
3475: F2F5 2A 57 F5               LD     HL,(dpbCKS)          ;
3476: F2F8 ED 5B 72 F5               LD     DE,(dirRecord)       ;
3477: F2FC AF                     XOR    A                    ;
3478: F2FD ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
3479: F2FF D8                     RET    C                    ;  Entries                      ;
3480: F300         ;
3481: F300 C5                     PUSH   BC                   ; Save New/Validate Flag        ;
3482: F301         ;
3483: F301         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
3484: F301             ComputeCheckSum:                      ;
3485: F301 06 80                  LD     B,cpmRecordSize      ;
3486: F303 2A 44 F5               LD     HL,(caDirectoryDMA)  ;
3487: F306 EE 00                  XOR                         ;
3488: F308             ComputeCheckSum1:                      ;
3489: F308 86                     ADD    A,(HL)               ;
3490: F309 23                     INC    HL                   ;
3491: F30A 10 FC                  DJNZ   ComputeCheckSum1     ;
3492: F30C         ; Checksum is in ACC	                                                    ;
3493: F30C         ;
3494: F30C 2A 48 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
3495: F30F ED 5B 72 F5               LD     DE,(dirRecord)       ; Index to this record              ;
3496: F313 19                     ADD    HL,DE                ; Address of this record in vector  ;
3497: F314 C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
3498: F315 0C                     INC    C                    ;
3499: F316 CA 23 F3               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
3500: F319         ;
3501: F319 BE                     CP     M                    ; Else we are checking the value    ;
3502: F31A C8                     RET    Z                    ; Exit if OK                        ;
3503: F31B         ; possible checksum error, are we beyond the end of the disk?               ;
3504: F31B CD FC F0               CALL   StillInDirectory     ;
3505: F31E D0                     RET    NC                   ; OK, if not in the directory       ;
3506: F31F CD 60 EF               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
3507: F322 C9                     RET                         ;  Set disk RO before returning     ;
3508: F323         ;
3509: F323         ;initializing the checksum                                                 ;
3510: F323             SetNewCheckSum:                      ;
3511: F323 77                     LD     (HL),A               ;
3512: F324 C9                     RET                         ;
3513: F325         ;--------------------------- Check Sum Utility -----------------------------;
3514: F325         ;*****************************************************************
3515: F325
3516: F325         ;*****************************************************************
3517: F325         ;********************** File  Routines ***************************
3518: F325         ;-----------------------------------------------------------------
3519: F325         ;-----------------------------------------------------------------
3520: F325         ;-----------------------------------------------------------------
3521: F325         ;write sequential
3522: F325         ;IN  - (DE) FCB address
3523: F325         ;OUT - (A) 00 = success and data available. else no read and no data
3524: F325             vWriteSeq:                      ; func21 (21 - 15) write sequention
3525: F325 CD 83 EF               CALL   ReselectDisk
3526: F328 CD 2C F3               CALL   DiskWriteSeq
3527: F32B C9                     RET
3528: F32C         ;-----------------------------------------------------------------
3529: F32C         ;-----------------------------------------------------------------
3530: F32C         ;*****************************************************************
3531: F32C
3532: F32C         ;-----------------------------------------------------------------
3533: F32C         ;sequential disk write
3534: F32C             DiskWriteSeq:
3535: F32C 3E 01                  LD     A,1
3536: F32E 32 60 F5               LD     (seqDiskIOFlag),A
3537: F331         ;--------
3538: F331         ;disk write
3539: F331             DiskWrite:
3540: F331 3E 00                  LD     A,FALSE
3541: F333 32 5E F5               LD     (readModeFlag),A
3542: F336         ; write record to currently selected file
3543: F336 CD BF F1               CALL   CheckWrite           ; in case write protected
3544: F339 2A C3 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
3545: F33C CD C9 F1               CALL   CheckROFile          ; may be a read-only file
3546: F33F CD B0 EF               CALL   SetRecordVars        ; set local Record parameters
3547: F342 3A 6B F5               LD     A,(currentFileRecord)
3548: F345 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
3549: F347 DA 4E F3               JP     C,DiskWrite1         ; skip if in the same Extent
3550: F34A CD 6D F2               CALL   SetExitParamTo1
3551: F34D C9                     RET                         ; Exit ???????????
3552: F34E
3553: F34E         ; can write the next record, so continue
3554: F34E             DiskWrite1:
3555: F34E CD EE F1               CALL   GetBlockNumber       ; sets up actual block number
3556: F351 CD 20 F2               CALL   WasBlockAllocated
3557: F354 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
3558: F356 C2 A4 F3               JP     NZ,DiskWrite3
3559: F359         ; not allocated -
3560: F359         ; the argument to getblock is the starting position for the disk search
3561: F359         ; and should be the last allocated block for this file,
3562: F359         ; or the value 0 if no space has been allocated
3563: F359
3564: F359 CD FB F1               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
3565: F35C 32 61 F5               LD     (diskMapIndex),A     ; save for later
3566: F35F 01 00 00               LD     BC,0000h             ; may use block zero
3567: F362 B7                     OR     A
3568: F363 CA 6D F3               JP     Z,FirstBlock         ; skip if no previous block
3569: F366         ; previous block exists
3570: F366 4F                     LD     C,A
3571: F367 0B                     DEC    BC                   ; previous block # in BC
3572: F368 CD 08 F2               CALL   GetDiskMapValue      ; previous block # to HL
3573: F36B 44                     LD     B,H
3574: F36C 4D                     LD     C,L                  ; BC=prev block#
3575: F36D         ; BC = 0000, or previous block #
3576: F36D             FirstBlock:
3577: F36D         ;	CALL	GetClosestBlockXX					; block # to HL
3578: F36D CD 35 F1               CALL   GetClosestBlock
3579: F370         ; arrive here with block# or zero
3580: F370 7D                     LD     A,L
3581: F371 B4                     OR     H
3582: F372 C2 7B F3               JP     NZ,BlockOK
3583: F375         ; cannot find a block to allocate
3584: F375 3E 02                  LD     A,2
3585: F377 32 C5 EA               LD     (exitParameterByte),A
3586: F37A C9                     RET                         ; exitParameterByte=2
3587: F37B
3588: F37B             BlockOK:
3589: F37B 22 6D F5               LD     (absoluteCPMRecord),HL ; allocated block number is in HL
3590: F37E EB                     EX     DE,HL                ; block number to DE
3591: F37F 2A C3 EA               LD     HL,(paramDE)
3592: F382 01 10 00               LD     BC,fcbDiskMapIndex
3593: F385 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
3594: F386 3A 65 F5               LD     A,(byteAllocationFlag)
3595: F389 B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
3596: F38A 3A 61 F5               LD     A,(diskMapIndex)     ; recall dm index
3597: F38D CA 97 F3               JP     Z,Allocate16Bit      ; skip if allocating word
3598: F390         ; else allocate using a byte value
3599: F390 CD 57 F4               CALL   AddAtoHL
3600: F393 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
3601: F394 C3 9F F3               JP     DiskWrite2           ; to continue
3602: F397
3603: F397             Allocate16Bit:                      ; allocate a word value
3604: F397
3605: F397 4F                     LD     C,A
3606: F398 06 00                  LD     B,0                  ; double(diskMapIndex)
3607: F39A 09                     ADD    HL,BC
3608: F39B 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
3609: F39C 72                     LD     (HL),D
3610: F39D 23                     INC    HL
3611: F39E 73                     LD     (HL),E               ; double wd
3612: F39F         ; disk write to previously unallocated block
3613: F39F             DiskWrite2:
3614: F39F 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
3615: F3A1 CD 17 F0               CALL   ResetFileWriteFlag
3616: F3A4         ; continue the write operation of no allocation error
3617: F3A4         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
3618: F3A4
3619: F3A4             DiskWrite3:
3620: F3A4 3A C5 EA               LD     A,(exitParameterByte)
3621: F3A7 B7                     OR     A
3622: F3A8 C0                     RET    NZ                   ; stop if non zero returned value
3623: F3A9
3624: F3A9 C5                     PUSH   BC                   ; save write flag ( in C see above)
3625: F3AA CD 26 F2               CALL   SetActualRecordAdd   ; Absolute CPM Record set to actual record number
3626: F3AD CD BB F2               CALL   Seek                 ; to proper file position
3627: F3B0 C1                     POP    BC                   ; get write flag
3628: F3B1 C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
3629: F3B2 CD BB F0               CALL   WriteBuffer          ; written to disk
3630: F3B5 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
3631: F3B6         ; increment record count if fcbRecordCount<=current File Record
3632: F3B6 3A 6B F5               LD     A,(currentFileRecord)
3633: F3B9 21 69 F5               LD     HL,fcbRecordCount
3634: F3BC BE                     CP     M                    ; current File Record-fcbRecordCount
3635: F3BD DA C4 F3               JP     C,DiskWrite4
3636: F3C0         ; fcbRecordCount <= current File Record
3637: F3C0 77                     LD     (HL),A
3638: F3C1 34                     INC    M                    ; fcbRecordCount = current File Record+1
3639: F3C2 0E 02                  LD     C,2                  ; mark as record count incremented
3640: F3C4             DiskWrite4:
3641: F3C4         ; A has current File Record, C=2 if new block or new record#
3642: F3C4 0D                     DEC    C
3643: F3C5 0D                     DEC    C
3644: F3C6 C2 D1 F3               JP     NZ,DiskWrite5
3645: F3C9 F5                     PUSH   AF                   ; save current File Record value
3646: F3CA CD 08 F0               CALL   GetExtentNumberMSB   ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3647: F3CD         ; reset the file write flag to mark as written fcb
3648: F3CD E6 7F                  AND    7FH                  ; not writeFlagMask
3649: F3CF 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
3650: F3D0 F1                     POP    AF                   ; restore current File Record
3651: F3D1             DiskWrite5:
3652: F3D1         ; check for end of extent, if found attempt to open next extent in preparation for next write
3653: F3D1 FE 7F                  CP     highestRecordNumber  ; current File Record=highestRecordNumber?
3654: F3D3 C2 F1 F3               JP     NZ,DiskWrite7        ; skip if not
3655: F3D6         ; may be random access write, if so we are done
3656: F3D6 3A 60 F5               LD     A,(seqDiskIOFlag)
3657: F3D9 B7                     OR     A
3658: F3DA CA F1 F3               JP     Z,DiskWrite7         ; skip next extent open op
3659: F3DD         ; update current fcb before going to next extent
3660: F3DD CD C3 F0               CALL   UpdateRecordVariables ;update variables from I/O in  fcb
3661: F3E0 CD F4 F3               CALL   OpenNextExt          ; readModeFlag=false
3662: F3E3         ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
3663: F3E3 21 C5 EA               LD     HL,exitParameterByte
3664: F3E6 7E                     LD     A,(HL)
3665: F3E7 B7                     OR     A
3666: F3E8 C2 EF F3               JP     NZ,DiskWrite6        ; no space
3667: F3EB         ; space available, set current File Record=255
3668: F3EB 3D                     DEC    A
3669: F3EC 32 6B F5               LD     (currentFileRecord),A ; goes to 00 next time
3670: F3EF             DiskWrite6:
3671: F3EF 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
3672: F3F1             DiskWrite7:
3673: F3F1 C3 C3 F0               JP     UpdateRecordVariables ; update variables from I/O in  fcb
3674: F3F4         ;ret
3675: F3F4         ;-----------------------------------------------------------------
3676: F3F4         ;close the current extent  and open the next one if possible.
3677: F3F4         ;readModeFlag is true if in read mode
3678: F3F4             OpenNextExt:                      ; open$reel
3679: F3F4 AF                     XOR    A
3680: F3F5 32 5D F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
3681: F3F8 CD 5C EE               CALL   CloseDirEntry        ; close current extent
3682: F3FB         ; exitParameterByte remains at enddir if we cannot open the next ext
3683: F3FB CD DC F0               CALL   AtEndOfDirectory
3684: F3FE C8                     RET    Z                    ; return if end
3685: F3FF 2A C3 EA               LD     HL,(paramDE)         ; increment extent number
3686: F402 01 0C 00               LD     BC,fcbExtIndex
3687: F405 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
3688: F406 7E                     LD     A,(HL)
3689: F407 3C                     INC    A
3690: F408 E6 1F                  AND    maxExtValue
3691: F40A 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
3692: F40B CA 1D F4               JP     Z,OpenNextModule     ; move to next module if zero
3693: F40E         ; may be in the same extent group
3694: F40E 47                     LD     B,A
3695: F40F 3A 50 F5               LD     A,(dpbEXM)
3696: F412 A0                     AND    B
3697: F413         ; if result is zero, then not in the same group
3698: F413 21 5D F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
3699: F416 A6                     AND    M                    ; produces a 00 in accumulator if not written
3700: F417 CA 28 F4               JP     Z,OpenNextExt1       ; go to next physical extent
3701: F41A         ; result is non zero, so we must be in same logical ext
3702: F41A C3 46 F4               JP     OpenNextExt2         ; to copy fcb information
3703: F41D         ; extent number overflow, go to next module
3704: F41D
3705: F41D             OpenNextModule:
3706: F41D 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
3707: F420 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
3708: F421 34                     INC    M                    ; fcb(fcbS2Index)=++1
3709: F422         ; module number incremented, check for overflow
3710: F422 7E                     LD     A,(HL)
3711: F423 E6 0F                  AND    moduleMask           ; mask high order bits
3712: F425 CA 51 F4               JP     Z,OpenNextExtError   ; cannot overflow to zero
3713: F428         ; otherwise, ok to continue with new module
3714: F428
3715: F428             OpenNextExt1:
3716: F428 0E 0F                  LD     C,nameLength
3717: F42A CD 2E F0               CALL   SearchForDirectoryRecord ; next extent found?
3718: F42D CD DC F0               CALL   AtEndOfDirectory
3719: F430 C2 46 F4               JP     NZ,OpenNextExt2
3720: F433         ; end of file encountered
3721: F433 3A 5E F5               LD     A,(readModeFlag)
3722: F436 3C                     INC    A                    ; 0ffh becomes 00 if read
3723: F437 CA 51 F4               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
3724: F43A         ; try to extend the current file
3725: F43A CD DC EE               CALL   MakeNewFile
3726: F43D         ; cannot be end of directory
3727: F43D CD DC F0               CALL   AtEndOfDirectory
3728: F440 CA 51 F4               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
3729: F443 C3 49 F4               JP     OpenNextExt3
3730: F446
3731: F446         ; not end of file, open
3732: F446             OpenNextExt2:
3733: F446 CD 22 EE               CALL   CopyDirRecordToFCB
3734: F449             OpenNextExt3:
3735: F449 CD B0 EF               CALL   SetRecordVars        ; Set Record parameters
3736: F44C AF                     XOR    A
3737: F44D 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
3738: F450 C9                     RET                         ; with exitParameterByte = 0
3739: F451
3740: F451         ; cannot move to next extent of this file
3741: F451             OpenNextExtError:
3742: F451 CD 6D F2               CALL   SetExitParamTo1      ; exitParameterByte = 1
3743: F454 C3 11 F0               JP     SetFileWriteFlag     ; ensure that it will not be closed
3744: F457         ;-----------------------------------------------------------------
3745: F457         ;-----------------------------------------------------------------
3746: F457
3747: F457         ;-----------------------------------------------------------------
3748: F457         ;-----------------------------------------------------------------
3749: F457
3750: F457
3751: F457
3752: F457
3753: F457         ;---------------------------------- Is Bit Set -----------------------------;
3754: F457
3755: F457
3756: F457
3757: F457         ;---------------------
3758: F457         ;set exitParameterByte to 1
3759: F457
3760: F457         ;---------------------
3761: F457         ;---------------------
3762: F457         ;*****************************************************************
3763: F457         ;************************ Utilities ******************************
3764: F457         ;*****************************************************************
3765: F457             AddAtoHL:
3766: F457 85                     ADD    A,L
3767: F458 6F                     LD     L,A
3768: F459 D0                     RET    NC
3769: F45A 24                     INC    H
3770: F45B C9                     RET
3771: F45C         ;----------
3772: F45C             DEminusHL2HL:
3773: F45C 7B                     LD     A,E
3774: F45D 95                     SUB    L
3775: F45E 6F                     LD     L,A
3776: F45F 7A                     LD     A,D
3777: F460 9C                     SBC    A,H
3778: F461 67                     LD     H,A
3779: F462 C9                     RET
3780: F463         ;-------------
3781: F463             ShiftRightHLbyC:
3782: F463 0C                     INC    C
3783: F464             ShiftRightHLbyC0:
3784: F464 0D                     DEC    C
3785: F465 C8                     RET    Z
3786: F466 7C                     LD     A,H
3787: F467 B7                     OR     A
3788: F468 1F                     RRA
3789: F469 67                     LD     H,A
3790: F46A 7D                     LD     A,L
3791: F46B 1F                     RRA
3792: F46C 6F                     LD     L,A
3793: F46D C3 64 F4               JP     ShiftRightHLbyC0
3794: F470         ;-------
3795: F470             ShiftLeftHLbyC:
3796: F470 0C                     INC    C
3797: F471             ShiftLeftHLbyC0:
3798: F471 0D                     DEC    C
3799: F472 C8                     RET    Z                    ; exit when done
3800: F473 29                     ADD    HL,HL
3801: F474 C3 71 F4               JP     ShiftLeftHLbyC0
3802: F477         ;*****************************************************************
3803: F477         ;? ;move data length of length C from source DE to HL
3804: F477         ;? MoveX:
3805: F477         ;?	INC		C
3806: F477         ;? MoveX0:
3807: F477         ;?	DEC		C
3808: F477         ;?	RET	Z
3809: F477         ;?	LD	A,(DE)
3810: F477         ;?	LD		(HL),A
3811: F477         ;?	INC		DE
3812: F477         ;?	INC		HL
3813: F477         ;?	JP		MoveX0
3814: F477         ;?
3815: F477         ;********** Console OUT Routines*******************??????
3816: F477
3817: F477         ;---------------------------------- Is Bit Set ------------------------------;
3818: F477         ; Enter HL  contains the bit map                                             ;
3819: F477         ;       B   Has the bit number (0...F)                                       ;
3820: F477         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3821: F477         ;              = 0 if bit is set (1)                                         ;
3822: F477             IsBitSet:                       ;
3823: F477 04                     INC    B                    ;
3824: F478             IsBitSetLoop:                      ;
3825: F478 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3826: F479 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3827: F47B 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3828: F47D 3F                     CCF                         ; else Clear Carry flag              ;
3829: F47E             IsBitSet1:                      ;
3830: F47E CB 1C                  RR     H                    ; Shift thru CY                      ;
3831: F480 CB 1D                  RR     L                    ; ditto                              ;
3832: F482 10 F4                  DJNZ   IsBitSetLoop         ;
3833: F484 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3834: F486 C9                     RET                         ;
3835: F487         ;---------------------------------- Is Bit Set ------------------------------;
3836: F487
3837: F487         ;============================ Set/Reset Vector Bit ==========================;
3838: F487         ;---------------------------------- Set Vector Bit -------------------------;;
3839: F487         ; Enter  HL  contains the bit map vector                                    ;;
3840: F487         ;        B   Has the bit number (0...F)                                     ;;
3841: F487         ; Return HL  Contains the modified bit map vector                           ;;
3842: F487             SetVectorBit:                      ;;
3843: F487 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3844: F488 CD 77 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3845: F48B         ;;
3846: F48B C1                     POP    BC                   ; Get the bit position              ;;
3847: F48C CB FC                  SET    7,H                  ;;
3848: F48E 18 07                  JR     ReAlignVector        ;                                    ;
3849: F490         ;---------------------------------- Set Vector Bit -------------------------;;
3850: F490         ;---------------------------------- Reset Vector Bit -----------------------;;
3851: F490         ; Enter  HL  contains the bit map vector                                    ;;
3852: F490         ;        B   Has the bit number (0...F)                                     ;;
3853: F490         ; Return HL  Contains the modified bit map vector                           ;;
3854: F490             ResetVectorBit:                      ;;
3855: F490 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3856: F491 CD 77 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3857: F494         ;;
3858: F494 C1                     POP    BC                   ; Get the bit position              ;;
3859: F495 CB BC                  RES    7,H                  ;;
3860: F497         ; Fall thru to ReAlignVector                                                 ;
3861: F497         ;---------------------------------- Reset Vector Bit -----------------------;;
3862: F497         ;---------------------------------- Set VectorBit --------------------------;;
3863: F497         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3864: F497         ;
3865: F497             ReAlignVector:                      ;
3866: F497 04                     INC    B                    ;
3867: F498             ReAlignMapLoop:                      ;
3868: F498 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3869: F499 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3870: F49B 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3871: F49D 3F                     CCF                         ; else Clear Carry flag              ;
3872: F49E             ReAlignMap1:                      ;
3873: F49E CB 15                  RL     L                    ; Shift thru CY                      ;
3874: F4A0 CB 14                  RL     H                    ; ditto                              ;
3875: F4A2 10 F4                  DJNZ   ReAlignMapLoop       ;
3876: F4A4 C9                     RET                         ;
3877: F4A5         ;============================ Set/Reset Vector Bit ==========================;
3878: F4A5         ;************Error message World*************************
3879: F4A5             errSelect:
3880: F4A5 21 C4 F4               LD     HL,evSelection
3881: F4A8 C3 BD F4               JP     GoToError
3882: F4AB             errReadOnlyDisk:
3883: F4AB 21 C6 F4               LD     HL,evReadOnlyDisk
3884: F4AE C3 BD F4               JP     GoToError
3885: F4B1             errReadOnlyFile:
3886: F4B1 21 C8 F4               LD     HL,evReadOnlyFile
3887: F4B4 C3 BD F4               JP     GoToError
3888: F4B7             errPermanent:
3889: F4B7 21 C2 F4               LD     HL,evPermanent
3890: F4BA C3 BD F4               JP     GoToError
3891: F4BD         ;************Error message handler **********************
3892: F4BD             GoToError:
3893: F4BD         ;HL = .errorhandler, call subroutine
3894: F4BD 5E                     LD     E,(HL)
3895: F4BE 23                     INC    HL
3896: F4BF 56                     LD     D,(HL)               ; address of routine in DE
3897: F4C0 EB                     EX     DE,HL
3898: F4C1 E9                     JP     (HL)                 ; vector to subroutine
3899: F4C2         ;************ Error Vectors *****************************
3900: F4C2 D0 F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3901: F4C4 DC F4       evSelection: DW     erSelection          ; selerr select error subroutine
3902: F4C6 E2 F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3903: F4C8 E8 F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3904: F4CA         ;************Error Routines ******************************
3905: F4CA             erPermanentNoWait:
3906: F4CA 21 1A F5               LD     HL,emPermanent
3907: F4CD C3 BD F4               JP     GoToError
3908: F4D0             erPermanent:
3909: F4D0 21 1A F5               LD     HL,emPermanent
3910: F4D3 CD F1 F4               CALL   displayAndWait       ; to report the error
3911: F4D6 FE 03                  CP     CTRL_C
3912: F4D8 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3913: F4DB C9                     RET                         ; and ignore the error
3914: F4DC         ;
3915: F4DC             erSelection:
3916: F4DC 21 25 F5               LD     HL,emSelection
3917: F4DF C3 EB F4               JP     waitB4boot           ; wait console before boot
3918: F4E2         ;
3919: F4E2             erReadOnlyDisk:
3920: F4E2 21 31 F5               LD     HL,emReadOnlyDisk
3921: F4E5 C3 EB F4               JP     waitB4boot           ; wait console before boot
3922: F4E8         ;
3923: F4E8             erReadOnlyFile:
3924: F4E8 21 2C F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3925: F4EB         ;
3926: F4EB         ; wait for response before boot
3927: F4EB             waitB4boot:
3928: F4EB CD F1 F4               CALL   displayAndWait
3929: F4EE C3 00 00               JP     WarmBoot
3930: F4F1
3931: F4F1         ;report error to console, message address in HL
3932: F4F1             displayAndWait:
3933: F4F1 E5                     PUSH   HL                   ; save message pointer
3934: F4F2 CD D6 E9               CALL   showCRLF             ; stack mssg address, new line
3935: F4F5 3A 36 F5               LD     A,(currentDisk)
3936: F4F8 C6 41                  ADD    A,ASCII_A
3937: F4FA 32 16 F5               LD     (emDisk),A           ; Problem disk name
3938: F4FD 01 0A F5               LD     BC,emDisk0
3939: F500 CD 3B E9               CALL   Print                ; the error message
3940: F503 C1                     POP    BC
3941: F504 CD 3B E9               CALL   Print                ; error mssage tail
3942: F507 C3 21 E9               JP     ConIn                ; to get the input character
3943: F50A         ;ret
3944: F50A         ;**************Error Messages*******************************
3945: F50A 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3946: F516 20 3A 20 24     emDisk:    DB     ' : $'
3947: F51A 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3948: F525 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3949: F52C 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3950: F531 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3951: F535         ;*****************************************************************
3952: F535
3953: F535         ;********* file control block (fcb) constants ********************
3954: F535             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3955: F535             fcbROfileIndex EQU    09H                  ; high order of first type char
3956: F535             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3957: F535             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3958: F535             fcbS1Index EQU    0DH                  ;13				; S1 index
3959: F535             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3960: F535             fcbRCIndex EQU    0FH                  ;15				; record count field index
3961: F535             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3962: F535
3963: F535             fcbCurrentRecord EQU    21H                  ;33
3964: F535
3965: F535             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3966: F535
3967: F535             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3968: F535             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3969: F535             dirEntryMask EQU    dirEntriesPerRecord-1
3970: F535             fcbShift   EQU    5                    ; log2(fcbLength)
3971: F535         ;
3972: F535
3973: F535
3974: F535
3975: F535             maxExtValue EQU    31                   ; largest extent number
3976: F535             moduleMask EQU    15                   ; limits module number value
3977: F535             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3978: F535             nameLength EQU    15                   ;  name length
3979: F535
3980: F535             emptyDir   EQU    0E5H                 ; empty empty directory entry
3981: F535             recordSeq  EQU    fcbLength            ; nxtrec
3982: F535             recordRandom EQU    recordSeq + 1        ;ranrec random record field (2 bytes)
3983: F535         ;
3984: F535         ;	reserved file indicators
3985: F535         ;	equ	11				; reserved
3986: F535         ;*****************************************************************
3987: F535         ;*****************************************************************
3988: F535
3989: F535         ;***common values shared between bdosi and bdos******************
3990: F535 00          currentUserNumber: DB     0                    ; usrcode current user number
3991: F536         ; paramDE:			DS	2					; ParamsDE information address
3992: F536         ; exitParameterByte:
3993: F536         ; exitParameterWord:	DS	2					; address value to return
3994: F536 FF          currentDisk: DB     -1                   ; curdsk current disk number
3995: F537         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3996: F537
3997: F537         ;********************* Local Variables ***************************
3998: F537         ;     ************************
3999: F537         ;     *** Initialized Data ***
4000: F537
4001: F537 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
4002: F538 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
4003: F53A 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
4004: F53C 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
4005: F53E
4006: F53E         ;     *** Current Disk attributes ****
4007: F53E         ; These are set upon disk select
4008: F53E         ; data must be adjacent, do not insert variables
4009: F53E         ; address of translate vector, not used
4010: F53E         ; ca - currentAddress
4011: F53E
4012: F53E 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
4013: F540 00 00       caTrack:   DW     0000H                ; curtrka current track address
4014: F542 00 00       caSector:  DW     0000H                ; current Sector
4015: F544             caListSizeStart:
4016: F544 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
4017: F546 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
4018: F548 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
4019: F54A 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
4020: F54C             caListSizeEnd:
4021: F54C             caListSize EQU    caListSizeEnd - caListSizeStart
4022: F54C
4023: F54C         ;     ***** Disk Parameter Block *******
4024: F54C         ; data must be adjacent, do not insert variables
4025: F54C         ; dpb - Disk Parameter Block
4026: F54C             dpbStart:
4027: F54C 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
4028: F54E 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
4029: F54F 00          dpbBLM:    DB     00H                  ; blkmsk block mask
4030: F550 00          dpbEXM:    DB     00H                  ; extmsk extent mask
4031: F551 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
4032: F553 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
4033: F555 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
4034: F557 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
4035: F559 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
4036: F55B             dpbEnd:
4037: F55B             dpbSize    EQU    dpbEnd - dpbStart
4038: F55B         ;
4039: F55B
4040: F55B         ;     ************************
4041: F55B
4042: F55B 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
4043: F55D 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
4044: F55E 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
4045: F55F 00          directoryIndex: DB     00H                  ; dirloc directory flag in rename, etc.
4046: F560 00          seqDiskIOFlag: DB     00H                  ; Set to 1 if sequential disk operation
4047: F561 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
4048: F562 00          searchLength: DB     00H                  ; searchl search length
4049: F563 00 00       searchAddress: DW     0000H                ; searcha search address
4050: F565         ;tinfo:	ds	word							; temp for info in "make"
4051: F565 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
4052: F566 00          fResel:    DB     00H                  ; resel reselection flag
4053: F567 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
4054: F568 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
4055: F569 00          fcbRecordCount: DB     00H                  ; record count from current FCB
4056: F56A 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
4057: F56B 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
4058: F56D 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
4059: F56F         ;
4060: F56F         ;	local variables for directory access
4061: F56F 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
4062: F570 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
4063: F572 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
4064: F574
4065: F574         ;********************** data areas ******************************
4066: F574
4067: F574
4068: F574         ;---------------------------------- Stack Area--------------------------------;
4069: F574             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
4070: F5B4             bdosStack:
4071: F5B4         ;
4072: F5B4         ;---------------------------------- Stack Area--------------------------------;
4073: F5B4         ;	end of Basic I/O System
4074: F5B4         ;-----------------------------------------------------------------;
4075: F5B4
4076: F5B4
4077: F5B4         ;
4078: F5B4             Z_HighestLocation:
4079: F5B4             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
4080: F5B4
4081: F5B4
           ************************   Xref   ************************
0000: $               F5B4   0418 0448
4058: absoluteCPMRecord F56D   3225 3266 3278 3293 3426 3433 3451 3589
3765: AddAtoHL        F457   3599
3603: Allocate16Bit   F397   3597
1045: AreWeAtEndOfBuffer EA3A   1041
0086: ASCII_A         0041   3936
0087: ASCII_C         0043
0088: ASCII_K         004B
0095: ASCII_LO_A      0061
0096: ASCII_LO_K      006B
0097: ASCII_LO_P      0070
0038: ASCII_MASK      007F   0988
0089: ASCII_N         004E
0090: ASCII_Q         0051
0091: ASCII_R         0052
0092: ASCII_W         0057
0093: ASCII_Y         0059
0073: ASCII_ZERO      0030
0067: ASTERISK        002A
2957: AtEndOfDirectory F0DC   1433 1601 1790 1864 2324 2355 2413 2505 2833 3683 3718 3727
1137: BackUp          EA9F   1065 1133
1142: BackUp1         EAA7   1138
0295: bcBoot          F600
0298: bcConin         F609   0618 0803 0914 0932
0299: bcConout        F60C   0610 0876 1140 1144 1150 1152
0297: bcConst         F606   0615 0910
0303: bcHome          F618   2570
0300: bcList          F60F   0583 0882
0310: bcListst        F62D
0301: bcPunch         F612   0568
0308: bcRead          F627   2612
0302: bcReader        F615   0549
0311: bcSectran       F630
0304: bcSeldsk        F61B   2227
0307: bcSetdma        F624   2607
0306: bcSetsec        F621   3466
0305: bcSettrk        F61E   2576 3463
0296: bcWboot         F603   0469
0309: bcWrite         F62A   2921
0153: BDOSBase        E800   0154 0156 0327
0122: BDOSE           0005   0123
0154: BDOSEntry       E800
0143: BDOSLength      0E00   0146 0156 0157
4070: bdosStack       F5B4   0343
0333: BdosStart       E800
0056: BELL            0007
0156: BIOSBase        F600
0144: BIOSLength      0A00   0146
0116: BIOSPAGE        0002
0157: BIOSStart       F600   0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 0311 4079
3588: BlockOK         F37B   3582
0253: BlockSize       0800   0275
1060: BSspaceBS       EA48   0999
0034: BYTE            0001   1173
4051: byteAllocationFlag F565   2260 2426 3033 3248 3594
4019: caAllocVector   F54A   1694 2280 2282 2307 2731 3086 3153
4018: caCheckSum      F548   3494
4016: caDirectoryDMA  F544   2247 2599 2972 3163 3486
4012: caDirMaxValue   F53E   2238 2314 2629 3006
4017: caDiskParamBlock F546   1811 2252
4021: caListSize      0008   2248
4020: caListSizeEnd   F54C   4021
4015: caListSizeStart F544   4021
0094: CARET           005E   0842
0836: CaretOut        E948   1034 1115
4014: caSector        F542   2244 2584 3455
4042: caSkewTable     F55B   2236
4013: caTrack         F540   2241 2580 3446
0151: CCPEntry        E000   0153 0157
0142: CCPLength       0800   0146 0153 0157
0928: CheckCTL_S      E9AC   0917
2871: CheckExtents    F084   2865
3182: CheckRODirectory F1C6   1437 1604
3185: CheckROFile     F1C9   3545
3474: CheckSumUtility F2F5   2905 3418
3176: CheckWrite      F1BF   1428 1589 2498 3543
2400: CloseDirEntry   EE5C   1287 2084 3681
2482: CloseDirEntryEnd EECB   2472
2490: CloseDirEntryError EED7   2442 2452 2457
0074: COLON           003A
1171: columnPosition  EAC1   0861 0886 0951 0971 1129
0069: COMMA           002C
2796: CompareExtents  F01D   2872
3484: ComputeCheckSum F301
3488: ComputeCheckSum1 F308   3491
0128: ComTail         0080   0129
0130: ComTailChars    0082
0129: ComTailCount    0081   0130
0905: ConBreak        E98C   0729 0872
0938: ConBreak0       E9BA   0930
0940: ConBreak1       E9BD   0908
0796: ConIn           E921   0501 0987 3942
0869: ConsoleOut      E96B   0843 0855 0860 0948 0956 0963 0965 1057
3204: CopyDir         F1D7   1607 1795
3162: CopyDirEntryToUserDMA F1AB   1340 1405
2358: CopyDirRecordToFCB EE22   3733
3198: CopyFCB         F1D3   2524
0230: cpmRecordSize   0080   0232 0235 0237 3165 3485 3967
0059: CR              000D   0809 0962 0992 1056
0042: CTRL_C          0003   0933 1039 3911
0043: CTRL_E          0005   1004
0044: CTRL_H          0008   0815 0998 1143
0045: CTRL_K          000B
0046: CTRL_L          000C
0047: CTRL_P          0010   0916 1007
0048: CTRL_R          0012   1016
0049: CTRL_S          0013   0929
0050: CTRL_U          0015   1013
0051: CTRL_X          0018   1010
0052: CTRL_Z          001A
3994: currentDisk     F536   1208 1654 2195 2206 2212 2225 2536 2622 2640 2659 3935
4057: currentFileRecord F56B   1504 1514 2685 2932 3233 3289 3547 3632 3669
3990: currentUserNumber F535   0780 0786 2332 2668
0070: DASH            002D
0264: DataBlocks      02C7   0274
0263: DataSectors     0B1C   0264
1432: DeleteFileLoop  EB25   1444
1124: DeleteTheLine   EA8E   1011
1127: DeleteTheLine1  EA8F   1134
3772: DEminusHL2HL    F45C
4061: dirBlockIndex   F56F   2973 3410
0235: DirBuffSize     0080
0250: DirectoryBlockCount 0002   0275
0237: DirectoryEntryPerRecord 0004   0278
4045: directoryIndex  F55F   2822 2886 3171
3967: dirEntriesPerRecord 0004   3969
4062: dirEntryIndex   F570   2882 2948 2958 3004 3393 3395 3404 3423
3969: dirEntryMask    0003   2883 3405
3968: dirEntryShift   0002   3424
0234: DirEntrySize    0020   0237 0275
3170: DirLocationToReturnLoc F1B8   1434 1602 1791
4063: dirRecord       F572   3427 3476 3495
0222: DiskCommandBlock 0046
0221: DiskControlByte 0045
0224: DiskControlTable 0040
1530: DiskEOF         EB84   1510 1517 1522
0418: diskf           000B
4047: diskMapIndex    F561   3565 3596
1499: DiskRead        EB49   2013
0226: DiskReadCode    0001
0231: diskSectorSize  0200   0232 0253 0261
0220: DiskStatusLocation 0043
3539: DiskWrite       F331   2020
3554: DiskWrite1      F34E   3549
3613: DiskWrite2      F39F   3601
3619: DiskWrite3      F3A4   3558
3640: DiskWrite4      F3C4   3635
3651: DiskWrite5      F3D1   3644
3670: DiskWrite6      F3EF   3666
3672: DiskWrite7      F3F1   3654 3658
0227: DiskWriteCode   0002
3534: DiskWriteSeq    F32C   3526
3932: displayAndWait  F4F1   3910 3928
3322: DivideHLby8     F24B   2275 3072 3075
0133: DMABuffer       0080   1210 4004
0063: DOLLAR          0024   0824 2338
0276: dpb3hdAL0       00C0
0277: dpb3hdAL1       0000
0272: dpb3hdBLM       000F
0271: dpb3hdBSH       0004
0278: dpb3hdCKS       0020
0275: dpb3hdDRM       007F   0278
0274: dpb3hdDSM       02C6
0273: dpb3hdEXM       0000
0280: dpb3hdNOH       0002
0279: dpb3hdOFF       0001
0270: dpb3hdSPT       0090
4029: dpbBLM          F54F   3287
4028: dpbBSH          F54E   3231 3276
4034: dpbCKS          F557   3475
4033: dpbDABM         F555   2305
4032: dpbDRM          F553   2627 3392
4031: dpbDSM          F551   2258 2274 2290 3071
4036: dpbEnd          F55B   4037
4030: dpbEXM          F550   2690 2799 3695
4035: dpbOFF          F559   2572 3459
4037: dpbSize         000F   2254
4027: dpbSPT          F54C   3434
4026: dpbStart        F54C   2253 4037
0450: DUMMY           E8A9   0445 0446
3946: emDisk          F516   3937
3945: emDisk0         F50A   3938
3947: emPermanent     F51A   3906 3909
3980: emptyDir        00E5   1439 2328 2839 4001
4001: emptyFCB        F537   2501
3950: emReadOnlyDisk  F531   3920
3949: emReadOnlyFile  F52C   3924
3948: emSelection     F525   3916
0137: END_OF_FILE     001A
0040: EndOfMessage    0000
1050: EndRead         EA3E   0993 0996
4053: entryDisk       F567   0391 2660
0292: EOD             FFFF   2947
0078: EQUAL_SIGN      003D
3908: erPermanent     F4D0   3900
3905: erPermanentNoWait F4CA   2614 2923
3919: erReadOnlyDisk  F4E2   3902
3923: erReadOnlyFile  F4E8   3903
3888: errPermanent    F4B7
3882: errReadOnlyDisk F4AB   3179
3885: errReadOnlyFile F4B1   3191
3879: errSelect       F4A5   2205
3915: erSelection     F4DC   3901
3900: evPermanent     F4C2   3889
3902: evReadOnlyDisk  F4C6   3883
3903: evReadOnlyFile  F4C8   3886
3901: evSelection     F4C4   3880
0061: EXCLAIM_POINT   0021
1175: exitParameterByte EAC5   0510 0619 0730 0756 0781 1515 1655 2088 2098 2109 2116 2129 2342 2402 2491 2884 2898 3172 3370 3585 3620 3663 3737
1176: exitParameterWord EAC5   0347 0398 0550 0639 1631 1695 1741 1812
4056: extentValue     F56A   2692
0029: FALSE           0000   0923 1095 1440 2018 2264 2831 3540
0125: FCB1            005C   0126
0126: FCB2            006C
4043: fcbCopiedFlag   F55D   2484 3680 3698
3963: fcbCurrentRecord 0021
4054: fcbDisk         F568   0349 0386 2662
3961: fcbDiskMapIndex 0010   1596 1605 2418 2423 3023 3025 3245 3592
3957: fcbExtIndex     000C   1429 1590 1606 1786 1794 1850 2067 2091 2147 2373 2466 2475 2711 2863 3686 3706
0015: fcbExtIndexLSB  000C
0016: fcbExtIndexMSB  000E
3956: fcbHiddenfileIndex 000A
3954: fcbLength       0020   2367 2423 2466 2516 3025 3200 3967 3981
3960: fcbRCIndex      000F   1868 2376 2394 2475 2700 2703
4055: fcbRecordCount  F569   1505 2688 2936 3633
3955: fcbROfileIndex  0009   3186
3958: fcbS1Index      000D   2520 2860
3959: fcbS2Index      000E   2073 2094 2164 2765 3706
3970: fcbShift        0005   3406
0170: fCloseFile      0010
0161: fConsoleIn      0001
0162: fConsoleOut     0002
0173: fDeleteFile     0013
0165: fGetConsoleStatus 000B
0179: fGetCurrentDisk 0019
0178: fGetLoginVector 0018
0181: fGetSetUserNumber 0020
0166: fGetVersion     000C
3576: FirstBlock      F36D   3568
0176: fMakeFile       0016
0169: fOpenFile       000F
3132: FoundFreeOctet  F186   3102 3107 3116 3124
3138: FoundFreeOctet1 F18C   3134
3140: FoundFreeOctet2 F18D   3136
3142: FoundFreeOctet3 F190   3145
3148: FoundFreeOctet4 F198   3150
0163: fPrintString    0009
0174: fReadSeq        0014
0164: fReadString     000A
0177: fRenameFile     0017
4052: fResel          F566   0350 0380 2650
0167: fResetSystem    000D
0171: fSearchFirst    0011
0172: fSearchNext     0012
0168: fSelectDisk     000E
0180: fSetDMA         001A
0448: functionCount   0028   0359
0405: functionTable   E857   0364 0418 0448
0175: fWriteSeq       0015
3220: GetBlockNumber  F1EE   1520 3555
3068: GetClosestBlock F135   3578
2970: GetCurrentDirectoryRecord F0E5   1438 1867 2327 2363 2417 2849 3022 3183 3211
3255: GetDiskMap16Bit F21A   3250
3230: GetDiskMapIndex F1FB   3221 3564
3234: GetDiskMapIndexLoop F202   3236
3243: GetDiskMapValue F208   3224 3572
2709: GetExtentAddress EFD4   2359 2689
2763: GetExtentNumberMSB F008   2123 2754 3646
2698: GetFcbRecordDetails EFC7   2682 2929
1863: GetFileSize1    EC19   1891
1889: GetFileSize2    EC3B   1882
1892: GetFileSizeExit EC41   1865
2830: GetNextDirectoryRecord F043   1404 1443 1609 1796 1890 2868 2873
2848: GetNextDirectoryRecord1 F060   2840
2140: GetRandomRecordPosition ED09   1869 1925
2762: GetWriteFileFlagValue F008   2406 2774 2785
3892: GoToError       F4BD   3881 3884 3887 3890 3907
0079: GREATER_THAN    003E
0062: HASH_TAG        0023   0947
3965: highestRecordNumber 007F   3548 3653
2569: Home            EF30   2313 2828
1147: IgnoreTheLine   EAAC   1014
4004: initDAMAddress  F53C   1211 1677 2593 3164
2273: InitDisk        EDA9   2218
2320: InitDisk1       EDEE   2330 2348
2343: InitDisk2       EE0F   2334 2339
2753: InitializeExtentNumberMSB F002   1254 1334 1557
0117: IOBYTE          0003   0638 0658
3822: IsBitSet        F477   2209 2642 3844 3856
3829: IsBitSet1       F47E   3827
3824: IsBitSetLoop    F478   3832
2638: IsDiskWriteProtected EF78   2403 3177
1012: IsItDeleteTheLineU EA19
1009: IsItDeleteTheLineX EA14
1006: IsItPrintToggle EA0F
1096: IsItPrintToggle1 EA70   1094
1000: IsItRubout      EA05
1003: IsPhysicalEOL   EA0A
0808: IsPrintableASCII E92C   0502 0838
1081: ItIsPhysicalEOL EA5D   1005
1088: ItIsPrintToggle EA65   1008
1069: ItIsRubout      EA52   1002
1165: keyboardByte    EABE   0797 0906 0939
0065: L_PAREN         0028
2738: Left            EFF3   2740
0082: LEFT_ARROW      005F
0098: LEFT_CURLY      007B
0146: LengthInBytes   2000   0147 0151 0261
0147: LengthInK       0009
0077: LESS_THAN       003C
0058: LF              000A   0811 0892 0964 0994
1110: LL1             EA7E   1118
0032: LO_NIBBLE_MASK  000F   0785 2160
4003: loggedDisks     F53A   1206 1630 2208 2214 2216
3100: LookRight       F15A   3110
2497: MakeNewFile     EEDC   1559 2107 3725
2303: Mark4Directory  EDD6   2295
3975: maxExtValue     001F   2808 3690
0149: MemorySize      0040   0151
3350: Merge           F25F   2446 2448
2425: MergeAllocationMaps EE81   2463
2440: MergeDirEntryNot0 EE95   2437
2435: MergeFCBisNot0  EE8F   2433
2459: MergeMapLoop    EEB1   2443
2445: MergeWordMaps   EE9C   2428
3976: moduleMask      000F   3711
3334: MultiplyHLby8   F255   2289 3156
0262: myOffset        0001   0263 0279
3978: nameLength      000F   1336 2353 2411 2510 2516 3716
2895: NoDirRecordsMatch F0A2   2834 2846
3128: NoFreeBlocks    F182   3117 3125
3112: NoMoreLeft      F16C   3108
3114: NoMoreLeftLoop  F16D   3118
3120: NoMoreRight     F177   3103
3122: NoMoreRightLoop F178   3126
2667: NoSelect        EFA7   2657
0935: NothingWaiting  E9B8   0926
0054: NULL            0000
0246: NumberOfHeads   0002   0257 0259 0270 0280
0243: NumberOfLogicalDisks 0004
0031: OFF             0000
0030: ON              FFFF
2352: OpenFile        EE19   1256 2097
3678: OpenNextExt     F3F4   1512 3661
3715: OpenNextExt1    F428   3700
3732: OpenNextExt2    F446   3702 3719
3734: OpenNextExt3    F449   3729
3741: OpenNextExtError F451   3712 3723 3728
3705: OpenNextModule  F41D   3692
2392: OpenSetRecordCount EE53   2388 2390
1174: paramDE         EAC3   0338 0384 0681 0973 1052 1107 1328 1402 1594 1676 1853 1923 2031 2366 2393 2421 2499 2502 2507 2519 2651 2669 2699 2710 2764 2825 3208 3244 3544 3591 3685
1173: paramE          EAC2   0340 0392 0777 2194 2655
0064: PERCENT         0025
0071: PERIOD          002E
0120: Pg0CurentDisk   0004
0119: Pg0CurentUser   0004   0120
0068: PLUS_SIGN       002B
0822: Print           E93B   0684 0831 3939 3941
1167: printEchoFlag   EABF   0880 0919 1091
0080: QMARK           003F   1330 2856
1338: QMarkFind       EB05   1331
0066: R_PAREN         0029
0113: RAM             0000   0115 0116 0117 0119 0122 0125 0128 0133 0135
2010: RandomDiskRead  EC66   1977
2017: RandomDiskWrite EC6F   1989
2027: RandomSeek      EC78   2012 2019
2081: RandomSeekClose ECBC   2071
2126: RandomSeekError ED01   2060
2119: RandomSeekErrorBadSeek ECFA   2090 2106 2111
2113: RandomSeekExit  ECF4   2080 2100
2611: ReadBuffer      EF58   1526 3382
3391: ReadDirectory   F27C   2323 2832
3403: ReadDirectory0  F290   3398
3407: ReadDirectory1  F297   3409
3380: ReadDirRecord   F273   3416
1030: ReadEchoRubOut  EA26   1078
4044: readModeFlag    F55E   1501 3541 3721
0983: ReadNext        E9ED   1047 1073 1099 1121
0986: ReadNext0       E9EF   1066 1085
4002: readOnlyVector  F538   1205 1740 2620 2625 2639
1495: ReadSeq         EB44
0970: ReadString      E9E0   0714 1131 1153
3872: ReAlignMap1     F49E   3870
3867: ReAlignMapLoop  F498   3875
3865: ReAlignVector   F497   3848
1519: RecordOK        EB6E   1507
3982: recordRandom    0021   1854 1926 2033
3981: recordSeq       0020   1924 2062 2703 3982
0255: RecordsPerBlock 0010
0239: RecordsPerExtent 0080   1509 2391 3965
0232: recordsPerSector 0004   0255 0270
1600: RenameLoop      EBA4   1610
1102: RepeatLine      EA75   1017
2648: ReselectDisk    EF83   1255 1286 1335 1403 1427 1489 1558 1588 1785 1845 1976 1988 3525
2784: ResetFileWriteFlag F017   3615
3854: ResetVectorBit  F490
0379: ReturnToCaller  E832   0353
0395: ReturnToCaller1 E84D   0382 0388 0617
2746: Right           EFFD   2744 2748
2555: RotateAndReplace EF29   2558
3308: RotateRightHLbyB F23E   3316
3313: RotateRightHLbyB1 F244   3311
0083: RUBOUT          007F   1001
3020: ScanDiskMap     F109   1441 2346
3027: ScanDiskMap0    F113   3059
3052: ScanDiskMap2    F12A   3041
3043: ScanDiskMapWord F124   3035
4049: searchAddress   F563   1401 2826 2836
2820: SearchForDirectoryRecord F02E   1339 1430 1591 1787 1851 2354 2412 2504 3717
4048: searchLength    F562   2823 2850
0284: SectorMask      0003
0249: SectorsPerBlock 0004   0253 0255 0258 0264 0284
0259: SectorsPerCylinder 0024   0262 0263
0248: SectorsPerTrack 0012   0257 0259 0270
3431: Seek            F2BB   1525 3428 3626
3436: Seek0           F2C5   3440
3422: SeekDir         F2AA   2486 3215 3415
2203: Select          ED42   1213 2199
2193: SelectCurrent   ED36   0393 1237 2665
2224: SelectDisk      ED63   2204
2267: SelectDisk1     EDA5   2263
0076: SEMICOLON       003B
4046: seqDiskIOFlag   F560   1497 2029 2930 3536 3656
3275: SetActualRecordAdd F226   1524 3625
3280: SetActualRecordAddLoop F22D   3282
1789: SetAttributesLoop EBEA   1797
2298: SetBitLoop      EDD1   2301
2534: SetCurrentDiskBit EF16
2592: SetDataDMA      EF4A   1212 1678 2910 3383
2598: SetDirDMA       EF4F   2907 3381
2984: SetDirectoryEntry F0F3   2347 2523
2619: SetDiskReadOnly EF60   1722 3506
2603: SetDMA          EF52   2594
2946: SetEndDirectory F0D5   2318 2827 2896 3399
3368: SetExitParamTo1 F26D   1531 3550 3742
2773: SetFileWriteFlag F011   2131 2371 2526 3743
3510: SetNewCheckSum  F323   3499
2875: SetNextPosition F08A   2857 2861 2869
2681: SetRecordVars   EFB0   1503 3546 3735
2720: SetResetMapBit  EFDC   3055
0784: SetUserNumber   E91B   0779
3842: SetVectorBit    F487   2215 2624
3337: ShiftLeftHLbyB  F257   3341
3795: ShiftLeftHLbyC  F470   2539
3797: ShiftLeftHLbyC0 F471   3801
3325: ShiftRightHLbyB F24D   2730 3329 3425
3781: ShiftRightHLbyC F463
3783: ShiftRightHLbyC0 F464   3793
0961: showCRLF        E9D6   0949 1084 3934
0946: showHashCRLF    E9C0   1105 1148
0950: showHashCRLF1   E9C8   0957
0072: SLASH           002F
0055: SOH             0001
0060: SPACE           0020   0817 0859 0889 0955 1139 1149 1151
0291: STACK_SIZE      0020   4069
4069: stackBottom     F574
1170: startingColumn  EAC0   0952 0972 1128
3003: StillInDirectory F0FC   2844 2985 3504
0261: SystemSectors   0011   0262
0057: TAB             0009   0813 0854
0852: TabOut          E958   0507 0529 0829 0839
0858: TabOut0         E95E   0863
2854: TestNextPosition F069   2880
0924: ToggleFlag1     E9A9   0922
0123: TopRAM          0007
0258: TotalNumberOfBlocks 02D0
0257: TotalNumberOfSectors 0B40   0258 0263
0135: TPA             0100
0247: TracksPerHead   0050   0257
0028: TRUE            FFFF   0920 0941 1092 1500 2011 2261 2268 2322 2345 2483 2649 2904
0081: UNDER_SCORE     005F
2928: UpdateRecordVariables F0C3   1527 3660 3673
1163: usersStack      EABC   0342 0396
1285: vCloseFile      EAEC   0423
1844: vComputeFileSize EC04   0442
0500: vConsoleIn      E8AD   0407
0528: vConsoleOut     E8BE   0408
1426: vDeleteFile     EB1A   0426
0605: vDirectConIO    E8D1   0412
0614: vDirectConIO1   E8D9   0608
0290: VERSION         0020   0755
1326: vFindFirst      EAF2   0424
1400: vFindNext       EB0B   0425
1693: vGetAllocAddr   EBD1   0434
0728: vGetConsoleStatus E900   0417
1653: vGetCurrentDisk EBC1   0432
1810: vGetDiskParamBlock EBFD   0438
0637: vGetIOBYTE      E8E7   0413
1629: vGetLoginVector EBBA   0431
1739: vGetReadOnlyMap EBDB   0436
0776: vGetSetUserNumber E90D   0439
0754: vGetVersion     E907   0419
0582: vListOut        E8CD   0411
1556: vMakeFile       EB87   0429
1253: vOpenFile       EAE3   0422
0680: vPrintString    E8F3   0415
0567: vPunchOut       E8C9   0410
0548: vReaderIn       E8C2   0409
1975: vReadRandom     EC59   0440
1488: vReadSeq        EB41   0427
0713: vReadString     E8FC   0416
1587: vRenameFile     EB90   0430
1958: vResetDrive     EC56   0444
1203: vResetSystem    EAC7   0420
1236: vSelectDisk     EAE0   0421
1675: vSetDMA         EBC8   0433
1784: vSetFileAttributes EBE2   0437
0657: vSetIOBYTE      E8EE   0414
1920: vSetRandomRecord EC43   0443
0468: vSystemReset    E8AA   0406
1721: vWriteProtectDisk EBD8   0435
1987: vWriteRandom    EC5F   0441
2003: vWriteRandom0Fill EC65   0447
3524: vWriteSeq       F325   0428
3927: waitB4boot      F4EB   3917 3921
0115: WarmBoot        0000   0934 1043 3912 3929
3265: WasBlockAllocated F220   1521 3556
0035: WORD            0002   1174 1176
0195: WriteAllocated  0000   3557
2920: WriteBuffer     F0BB   2909 3629
0197: WriteCleanBuffer 0002   3614
2902: WriteDir        F0AB   1442 2487 3216
0196: WriteDirectory  0001   2908
3977: writeFlagMask   0080
4078: Z_HighestLocation F5B4   4079
4079: Z_MemoryLeft    004B
0039: ZERO            0000
