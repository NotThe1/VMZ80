0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800
0006: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0007: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0008: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0009: E800         ; 2018-03-02 Refactored the CP/M Suite
0010: E800         ; 2018-02-12 fixed allocate 16 bit problem
0011: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0012: E800         ; 2014-03-14  :  Frank Martyn
0013: E800
0014: E800
0015: E800                        Include ./stdHeader.Z80
0016: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0017: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0018: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0019: E800         ; stdHeader.asm
0020: E800         ; standard equates
0021: E800
0022: E800         ; 2017-03-02 Refactored the CP/M Suite
0023: E800
0024: E800
0025: E800             TRUE       EQU    -1                   ; not false
0026: E800             FALSE      EQU    0000H
0027: E800             ON         EQU    -1
0028: E800             OFF        EQU    0000H
0029: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0030: E800
0031: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0032: E800             WORD       EQU    2                    ; number of bytes for "word" type
0033: E800
0034: E800
0035: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0036: E800             ZERO       EQU    00H                  ; Zero
0037: E800             EndOfMessage EQU    00H
0038: E800
0039: E800             CTRL_C     EQU    03H                  ; ETX
0040: E800             CTRL_E     EQU    05H                  ; physical eol
0041: E800             CTRL_H     EQU    08H                  ; backspace
0042: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0043: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0044: E800             CTRL_P     EQU    10H                  ; prnt toggle
0045: E800             CTRL_R     EQU    12H                  ; repeat line
0046: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0047: E800             CTRL_U     EQU    15H                  ; line delete
0048: E800             CTRL_X     EQU    18H                  ; =ctl-u
0049: E800             CTRL_Z     EQU    1AH                  ; end of file
0050: E800
0051: E800             NULL       EQU    00H                  ; Null
0052: E800             SOH        EQU    01H                  ; Start of Heading
0053: E800             BELL       EQU    07H                  ; Bell
0054: E800             TAB        EQU    09H                  ; Tab
0055: E800             LF         EQU    0AH                  ; Line Feed
0056: E800             CR         EQU    0DH                  ; Carriage Return
0057: E800             SPACE      EQU    20H                  ; Space
0058: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0059: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0060: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0061: E800             PERCENT    EQU    25H                  ; Percent Sign
0062: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0063: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0064: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0065: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0066: E800             COMMA      EQU    2CH                  ; Comma
0067: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0068: E800             PERIOD     EQU    2EH                  ; Period
0069: E800             SLASH      EQU    2FH                  ; /
0070: E800             ASCII_ZERO EQU    30H                  ; zero
0071: E800             COLON      EQU    3AH                  ; Colon
0072: E800
0073: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0074: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0075: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0076: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0077: E800             QMARK      EQU    3FH                  ; Question Mark
0078: E800             UNDER_SCORE EQU    5FH                  ; under score _
0079: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0080: E800             RUBOUT     EQU    7FH                  ; Delete Key
0081: E800
0082: E800
0083: E800             ASCII_A    EQU    'A'
0084: E800             ASCII_C    EQU    'C'
0085: E800             ASCII_K    EQU    'K'
0086: E800             ASCII_N    EQU    'N'
0087: E800             ASCII_Q    EQU    'Q'
0088: E800             ASCII_R    EQU    'R'
0089: E800             ASCII_W    EQU    'W'
0090: E800             ASCII_Y    EQU    'Y'
0091: E800             CARET      EQU    '^'
0092: E800             ASCII_LO_A EQU    'a'
0093: E800             ASCII_LO_K EQU    'k'
0094: E800             ASCII_LO_P EQU    'p'
0095: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0096: E800
0097: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0098: E800                        Include ./osHeader.Z80
0099: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0100: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0101: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0102: E800         ; osHeader.Z80
0103: E800
0104: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0105: E800         ; 2017-03-02 Refactored the CP/M Suite
0106: E800
0107: E800         ; Contains the Equates used by the CP/M system
0108: E800
0109: E800         ;------------------------Page Zero Constants ---------------------------------
0110: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0111: E800
0112: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0113: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0114: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0115: E800
0116: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0117: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0118: E800
0119: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0120: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0121: E800
0122: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0123: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0124: E800
0125: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0126: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0127: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0128: E800         ;-----------------------------------------------------------------------
0129: E800
0130: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0131: E800         ;-----------------------------------------------------------------------
0132: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0133: E800         ;-----------------------------------------------------------------------
0134: E800             END_OF_FILE EQU    1AH                  ; end of file
0135: E800         ;-----------------------------------------------------------------------
0136: E800
0137: E800         ;--------------- CP/M Constants -----------------------------------------
0138: E800
0139: E800             CCPLength  EQU    0800H                ; Constant
0140: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0141: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0142: E800
0143: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0144: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0145: E800
0146: E800             MemorySize EQU    64
0147: E800
0148: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0149: E800
0150: E800             BDOSBase   EQU    CCPEntry + CCPLength
0151: E800             BDOSEntry  EQU    BDOSBase
0152: E800
0153: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0154: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0155: E800         ;-----------------------------------------------------------------------
0156: E800
0157: E800         ;------------------- BDOS System Call Equates --------------------------
0158: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0159: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0160: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0161: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0162: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0163: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0164: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0165: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0166: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0167: E800             fCloseFile EQU    10H                  ; closef - Close File
0168: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0169: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0170: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0171: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0172: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0173: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0174: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0175: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0176: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0177: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0178: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0179: E800         ;-----------------------------------------------------------------------
0180: E800
0181: E800
0182: E800
0183: E800
0184: E800
0185: E800         ;*******************************************************************************
0186: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0187: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0188: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0189: E800         ; sector write) or to an allocation block that has already been allocated to a
0190: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0191: E800         ;*******************************************************************************
0192: E800             WriteAllocated EQU    00H
0193: E800             WriteDirectory EQU    01H
0194: E800             WriteCleanBuffer EQU    02H
0195: E800
0196: E800
0197: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0198: E800                        Include ./diskHeader.Z80
0199: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0200: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0201: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0202: E800         ; diskHeader.asm
0203: E800
0204: E800         ; 2017-03-02 Refactored the CP/M Suite
0205: E800
0206: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0207: E800
0208: E800         ; Contains the Equates used by the CP/M system to handle disks
0209: E800
0210: E800
0211: E800         ;*******************************************************************************
0212: E800         ;
0213: E800         ;     Disk related values
0214: E800         ;
0215: E800         ;
0216: E800         ;*******************************************************************************
0217: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0218: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0219: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0220: E800         ; for boot
0221: E800             DiskControlTable EQU    0040H
0222: E800
0223: E800             DiskReadCode EQU    01H                  ; Code for Read
0224: E800             DiskWriteCode EQU    02H                  ; Code for Write
0225: E800
0226: E800
0227: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0228: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0229: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0230: E800
0231: E800             DirEntrySize EQU    20H                  ; (32)
0232: E800             DirBuffSize EQU    cpmRecordSize
0233: E800
0234: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0235: E800
0236: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0237: E800
0238: E800
0239: E800         ;-------------------------------------------------------------------------------------
0240: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0241: E800
0242: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0243: E800             NumberOfHeads EQU    02H                  ; number of heads
0244: E800             TracksPerHead EQU    50H                  ; 80
0245: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0246: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0247: E800             DirectoryBlockCount EQU    02H                  ;
0248: E800         ;-----------------------------------------------------------------------
0249: E800
0250: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0251: E800
0252: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0253: E800
0254: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0255: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0256: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0257: E800
0258: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0259: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0260: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0261: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0262: E800
0263: E800         ;-----------------------------------------------------------------------
0264: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0265: E800         ;-----------------------------------------------------------------------
0266: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0267: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0268: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0269: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0270: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0271: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0272: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0273: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0274: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0275: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0276: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0277: E800             dpb3hdNOH  EQU    NumberOfHeads
0278: E800
0279: E800         ;*******************************************************************************
0280: E800
0281: E800             SectorMask EQU    SectorsPerBlock - 1
0282: E800
0283: E800         ;***************************************************************************
0284: E800
0285: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0286: E800
0287: E800             VERSION    EQU    20H                  ; Version 2.0
0288: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0289: E800             EOD        EQU    -1                   ; End of Directory
0290: E800
0291: E800         ;************************ BIOS Function Constants ***************************;
0292: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0293: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0294: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0295: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0296: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0297: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0298: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0299: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0300: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0301: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0302: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0303: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0304: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0305: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0306: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0307: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0308: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0309: E800         ;************************ BIOS Function Constants ***************************;
0310: E800
0311: E800         ;============================================================================;
0312: E800         ;	BDOS                                                                     ;
0313: E800         ; Calling into   :                                                           ;
0314: E800         ;					Register  C - Contains BDOS Function Code                ;
0315: E800         ;					Register  A - Holds the Byte argument if any             ;
0316: E800         ;					Register DE - Holds the Word argument if any             ;
0317: E800         ; Returning from :                                                           ;
0318: E800         ;					Register  A - The Byte return value if any               ;
0319: E800         ;					Register HL - The Word return value if any               ;
0320: E800         ;                   ( Register A=L and B=H)                                  ;
0321: E800         ;============================================================================;
0322: E800
0323: E800
0324: E800                        ORG    BDOSBase
0325: E800
0326: E800         ;===========================BDOS Entry=======================================;
0327: E800         ;BDOSEntry:                                                                  ;
0328: E800         ;
0329: E800             BdosStart:                      ;
0330: E800         ;	LD		A,C                                                              ;
0331: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0332: E800         ;
0333: E800         ; Save Calling Arguments                                                     ;
0334: E800 ED 53 BB EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0335: E804 7B                     LD     A,E                  ;
0336: E805 32 BA EA               LD     (paramE),A           ; Save the Byte argument             ;
0337: E808         ; Save users Stack pointer                                                   ;
0338: E808 ED 73 B4 EA               LD     (usersStack),SP      ; We will use our own stack          ;
0339: E80C         ;
0340: E80C         ; initialize variables                                                       ;
0341: E80C 21 00 00               LD     HL,0000H             ;
0342: E80F 22 BD EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0343: E812 AF                     XOR    A                    ;
0344: E813 32 3E F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0345: E816 32 3C F5               LD     (fResel),A           ; Clear re selection flag            ;
0346: E819         ;
0347: E819         ; Set up for return to caller when Function Completes                        ;
0348: E819 21 2F E8               LD     HL,ReturnToCaller    ;
0349: E81C E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0350: E81D         ;
0351: E81D         ; is it a valid function number ?	                                         ;
0352: E81D         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0353: E81D 79                     LD     A,C                  ;
0354: E81E FE 28                  CP     functionCount        ; make sure its a good number        ;
0355: E820 D0                     RET    NC                   ; exit if not a valid function       ;
0356: E821         ;
0357: E821         ; Calculate the index and get vector to go to	                             ;
0358: E821 4B                     LD     C,E                  ; Assume byte argument               ;
0359: E822 21 54 E8               LD     HL,functionTable     ; Get table base                     ;
0360: E825 5F                     LD     E,A                  ; Function number in E               ;
0361: E826 16 00                  LD     D,0                  ;
0362: E828 19                     ADD    HL,DE                ; Have byte location                 ;
0363: E829 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0364: E82A 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0365: E82B 23                     INC    HL                   ;
0366: E82C 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0367: E82D EB                     EX     DE,HL                ; Vector now in HL                   ;
0368: E82E         ;
0369: E82E         ; Vector to Function is in HL                                                ;
0370: E82E E9                     JP     (HL)                 ; Move to Program Counter            ;
0371: E82F         ;===========================BDOS Entry=======================================;
0372: E82F         ;===========================BDOS Exit =======================================;
0373: E82F         ;arrive here at end of processing to return to user                          ;
0374: E82F             ReturnToCaller:                      ;
0375: E82F 3A 3C F5               LD     A,(fResel)           ; get re-selection flag              ;
0376: E832 B7                     OR     A                    ; is it set?                         ;
0377: E833 28 15                  JR     Z,ReturnToCaller1    ;
0378: E835         ;re-selection  may have taken place                                         ;
0379: E835 2A BB EA               LD     HL,(paramDE)         ;
0380: E838 36 00                  LD     (HL),0               ;
0381: E83A 3A 3E F5               LD     A,(fcbDisk)          ;
0382: E83D B7                     OR     A                    ; Disk = 0?                          ;
0383: E83E 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0384: E840         ;
0385: E840 77                     LD     (HL),A               ;
0386: E841 3A 3D F5               LD     A,(entryDisk)        ; get back original Disk             ;
0387: E844 32 BA EA               LD     (paramE),A           ; and select it                      ;
0388: E847 CD 49 EC               CALL   SelectCurrent        ;
0389: E84A         ;
0390: E84A             ReturnToCaller1:                      ;
0391: E84A 2A B4 EA               LD     HL,(usersStack)      ;
0392: E84D F9                     LD     SP,HL                ; restore callers stack              ;
0393: E84E 2A BD EA               LD     HL,(exitParameterWord) ;
0394: E851 7D                     LD     A,L                  ;
0395: E852 44                     LD     B,H                  ; BA = exitParameterWord             ;
0396: E853 C9                     RET                         ;
0397: E854         ;===========================BDOS Exit =======================================;
0398: E854
0399: E854         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0400: E854             functionTable:                      ;
0401: E854 A7 E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0402: E856 AA E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0403: E858 BB E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0404: E85A BF E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0405: E85C C6 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0406: E85E CA E8                  DW     vListOut             ;   5 - List Output                  ;
0407: E860 CE E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0408: E862 E4 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0409: E864 EB E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0410: E866 F0 E8                  DW     vPrintString         ;   9 - Print String                 ;
0411: E868 F9 E8                  DW     vReadString          ;   A - Read Console String          ;
0412: E86A FD E8                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0413: E86C             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0414: E86C 75 F4                  DW     vGetVersion          ;   C - Return Version Number        ;
0415: E86E F5 EB                  DW     vResetSystem         ;   D - Reset Disk System            ;
0416: E870 0E EC                  DW     vSelectDisk          ;   E - Select Disk                  ;
0417: E872 37 EF                  DW     vOpenFile            ;   F - Open File                    ;
0418: E874 40 EF                  DW     vCloseFile           ;  10 - Close File                   ;
0419: E876 46 EF                  DW     vFindFirst           ;  11 - Search For First             ;
0420: E878 5F EF                  DW     vFindNext            ;  12 - Search for Next              ;
0421: E87A 6E EF                  DW     vDeleteFile          ;  13 - Delete File                  ;
0422: E87C 77 EF                  DW     vReadSeq             ;  14 - Read Sequential              ;
0423: E87E 7E EF                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0424: E880 85 EF                  DW     vMakeFile            ;  16 - Make File                    ;
0425: E882 8E EF                  DW     vRenameFile          ;  17 - Rename File                  ;
0426: E884 11 EC                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0427: E886 18 EC                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0428: E888 1F EC                  DW     vSetDMA              ;  1A - Set DMA address              ;
0429: E88A 28 EC                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0430: E88C 2F EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0431: E88E 32 EC                  DW     vGetRoVector         ;  1D - Get Read/Only Vector         ;
0432: E890 39 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0433: E892 42 EC                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0434: E894 04 E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0435: E896 BF EA                  DW     vReadRandom          ;  21 - Read Random                  ;
0436: E898 C5 EA                  DW     vWriteRandom         ;  22 - Write Random                 ;
0437: E89A CB EA                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0438: E89C D1 EA                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0439: E89E D4 EA                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0440: E8A0 A6 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0441: E8A2 A6 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0442: E8A4 D5 EA                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0443: E8A6             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0444: E8A6         ;
0445: E8A6             DUMMY:                          ;
0446: E8A6 76                     HALT                        ;
0447: E8A7         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0448: E8A7
0449: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0450: E8A7         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0451: E8A7         ; same as the warm boot function invoked when you transfer control to the    ;
0452: E8A7         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0453: E8A7         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0454: E8A7         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0455: E8A7         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0456: E8A7         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0457: E8A7         ;																			 ;
0458: E8A7         ;			Function Code	 :	C = 00H                                      ;
0459: E8A7         ;			Entry Parameters:	None                                         ;
0460: E8A7         ;			Exit Parameters :	Does Not Return								 ;
0461: E8A7         ;																			 ;
0462: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0463: E8A7             vSystemReset:
0464: E8A7 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0465: E8AA
0466: E8AA         ;****************************************************************************;
0467: E8AA         ;								IOByte device I/O							 ;
0468: E8AA         ;****************************************************************************;
0469: E8AA
0470: E8AA
0471: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0472: E8AA         ;  This function reads the next byte of data from the console keyboard and   ;
0473: E8AA         ; puts it into register A. If the character input is a graphic character, it ;
0474: E8AA         ; will be echoed back to the console. The only control characters that are   ;
0475: E8AA         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0476: E8AA         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0477: E8AA         ; move the cursor to the next multiple of eight columns. All of the other    ;
0478: E8AA         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0479: E8AA         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0480: E8AA         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0481: E8AA         ; console output should also be sent to the list device. If CONTROL-S is     ;
0482: E8AA         ; found, further output will be suspended until you type another character.  ;
0483: E8AA         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0484: E8AA         ; pressed and disable it the second time. If there is no incoming data       ;
0485: E8AA         ; character, this function will wait until there is one.                     ;
0486: E8AA         ;                                                                            ;
0487: E8AA         ; This is a blocking function                                                ;
0488: E8AA         ;																			 ;
0489: E8AA         ;																			 ;
0490: E8AA         ;			Function Code	:	C = 01H                                      ;
0491: E8AA         ;			Entry Parameters:	None                                         ;
0492: E8AA         ;			Exit Parameters :	A = Data byte from console					 ;
0493: E8AA         ;																			 ;
0494: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0495: E8AA             vConsoleIn:
0496: E8AA CD 19 E9               CALL   ConIn                ; Don't come back without input
0497: E8AD CD 24 E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0498: E8B0 D8                     RET    C                    ; return nothing to echo
0499: E8B1
0500: E8B1 F5                     PUSH   AF                   ; Save printable character
0501: E8B2 4F                     LD     C,A
0502: E8B3 CD 50 E9               CALL   TabOut               ; Send to console. if TAB expand
0503: E8B6 F1                     POP    AF                   ; retrieve exit value
0504: E8B7
0505: E8B7 32 BD EA               LD     (exitParameterByte),A
0506: E8BA C9                     RET
0507: E8BB
0508: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0509: E8BB         ;  This function outputs the data byte in register E to the console. As with ;
0510: E8BB         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0511: E8BB         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0512: E8BB         ; checks to see if there is an incoming character, and if there is,          ;
0513: E8BB         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0514: E8BB         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0515: E8BB         ; printer is  toggled on or off                                              ;
0516: E8BB         ;																			 ;
0517: E8BB         ;			Function Code	:	C = 02H                                      ;
0518: E8BB         ;			Entry Parameters:	E = Data byte to be output					 ;
0519: E8BB         ;			Exit Parameters :	None										 ;
0520: E8BB         ;																			 ;
0521: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0522: E8BB         ;BDOS put parameter in C before entering this routine
0523: E8BB             vConsoleOut:
0524: E8BB CD 50 E9               CALL   TabOut
0525: E8BE C9                     RET
0526: E8BF
0527: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0528: E8BF         ;   function reads the next character from the logical "reader" device into  ;
0529: E8BF         ; register A. In practice, the physical device that is accessed depends      ;
0530: E8BF         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0531: E8BF         ; reader at all; this function will return some arbitrary value such as lAH  ;
0532: E8BF         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0533: E8BF         ; Control is not returned to the calling program until a character has been  ;
0534: E8BF         ; read.                                                                      ;
0535: E8BF         ;                                                                            ;
0536: E8BF         ; This is a blocking function                                                ;
0537: E8BF         ;																			 ;
0538: E8BF         ;			Function Code	:	C = 03H                                      ;
0539: E8BF         ;			Entry Parameters:	None										 ;
0540: E8BF         ;			Exit Parameters :	A = Character Input							 ;
0541: E8BF         ;																			 ;
0542: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0543: E8BF             vReaderIn:
0544: E8BF CD 15 F6               CALL   bcReader
0545: E8C2 32 BD EA               LD     (exitParameterWord),A
0546: E8C5 C9                     RET
0547: E8C6
0548: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0549: E8C6         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0550: E8C6         ; specified character from register E to the logical punch device. Again,    ;
0551: E8C6         ; the actual physical device used, if any, is determined by the BIOS.        ;
0552: E8C6         ; There is no set standard for this device; in some systems the punch        ;
0553: E8C6         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0554: E8C6         ; output to it.                                                              ;
0555: E8C6         ;																			 ;
0556: E8C6         ;			Function Code	:	C = 04H                                      ;
0557: E8C6         ;			Entry Parameters:	E = Data byte to be output					 ;
0558: E8C6         ;			Exit Parameters :	None										 ;
0559: E8C6         ;																			 ;
0560: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0561: E8C6         ;BDOS put parameter in C before entering this routine
0562: E8C6             vPunchOut:
0563: E8C6 CD 12 F6               CALL   bcPunch
0564: E8C9 C9                     RET
0565: E8CA
0566: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0567: E8CA         ;  This function outputs the specified byte in register E to the logical     ;
0568: E8CA         ; list device. As with the reader and the punch, the physical device used    ;
0569: E8CA         ; depends entirely on the BIOS.                                              ;
0570: E8CA         ;																			 ;
0571: E8CA         ;			Function Code	:	C = 05H                                      ;
0572: E8CA         ;			Entry Parameters:	E = Data byte to be output					 ;
0573: E8CA         ;			Exit Parameters :	None										 ;
0574: E8CA         ;																			 ;
0575: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0576: E8CA         ;BDOS put parameter in C before entering this routine
0577: E8CA             vListOut:                       ; func5 (05 - 05) List Output
0578: E8CA CD 0F F6               CALL   bcList               ; direct call to BIOS
0579: E8CD C9                     RET
0580: E8CE
0581: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0582: E8CE         ;  This function serves double duty: it both inputs and outputs characters   ;
0583: E8CE         ; from the console. However, it bypasses the normal control characters and   ;
0584: E8CE         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0585: E8CE         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0586: E8CE         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0587: E8CE         ; then E contains a valid ASCII character that is output to the console.     ;
0588: E8CE         ;  This function works well provided you never have to send a value ofOFFH   ;
0589: E8CE         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0590: E8CE         ; binary data, you cannot use this function, since these values are likely   ;
0591: E8CE         ; to be part of the data stream.                                             ;
0592: E8CE         ;                                                                            ;
0593: E8CE         ;			Function Code	:	C = 06H                                      ;
0594: E8CE         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0595: E8CE         ;								E = Other than 0FFH for Output				 ;
0596: E8CE         ;			Exit Parameters :	A = Input byte or status					 ;
0597: E8CE         ;																			 ;
0598: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0599: E8CE         ;BDOS put parameter in C before entering this routine
0600: E8CE             vDirectConIO:
0601: E8CE 79                     LD     A,C
0602: E8CF 3C                     INC    A
0603: E8D0 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0604: E8D2         ; send byte to console
0605: E8D2 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0606: E8D5 C9                     RET
0607: E8D6
0608: E8D6         ;read byte/status from console
0609: E8D6             vDirectConIO1:
0610: E8D6 CD 06 F6               CALL   bcConst              ; Check Status
0611: E8D9 B7                     OR     A                    ; 00 means not data ready
0612: E8DA CA 4A E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0613: E8DD CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0614: E8E0 32 BD EA               LD     (exitParameterByte),A ; Save it
0615: E8E3 C9                     RET
0616: E8E4
0617: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0618: E8E4         ; This function places the current value of the IOBYTE in register A.        ;
0619: E8E4         ;                                                                            ;
0620: E8E4         ; The IOBYTE structure:                                                      ;
0621: E8E4         ;								+-------+-------+-------+-------+            ;
0622: E8E4         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0623: E8E4         ;								+-------+-------+-------+-------+            ;
0624: E8E4         ;				Logical Device     List | Punch | Reader|Console             ;
0625: E8E4         ;                                                                            ;
0626: E8E4         ;                                                                            ;
0627: E8E4         ;			Function Code	:	C = 07H                                      ;
0628: E8E4         ;			Entry Parameters:	None					  		  			 ;
0629: E8E4         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0630: E8E4         ;																			 ;
0631: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0632: E8E4             vGetIOBYTE:
0633: E8E4 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0634: E8E7 32 BD EA               LD     (exitParameterWord),A ; Return it to caller
0635: E8EA C9                     RET
0636: E8EB         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0637: E8EB         ; This function sets the IOBYTE         									 ;
0638: E8EB         ;                                                                            ;
0639: E8EB         ; The IOBYTE structure:                                                      ;
0640: E8EB         ;								+-------+-------+-------+-------+            ;
0641: E8EB         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0642: E8EB         ;								+-------+-------+-------+-------+            ;
0643: E8EB         ;				Logical Device     List | Punch | Reader|Console             ;
0644: E8EB         ;                                                                            ;
0645: E8EB         ;                                                                            ;
0646: E8EB         ;			Function Code	:	C = 08H                                      ;
0647: E8EB         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0648: E8EB         ;			Exit Parameters :	None                                         ;
0649: E8EB         ;																			 ;
0650: E8EB         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0651: E8EB         ;BDOS put parameter in C before entering this routine
0652: E8EB             vSetIOBYTE:
0653: E8EB 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0654: E8EE 71                     LD     (HL),C               ; Place new vale in it
0655: E8EF C9                     RET
0656: E8F0
0657: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0658: E8F0         ;  This function outputs a string of characters to the console device. The   ;
0659: E8F0         ; address of this string is in registers DE. You must make sure that the last;
0660: E8F0         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0661: E8F0         ; for the end of the string.                                                 ;
0662: E8F0         ;  The "$" itself does not get output to the console.                        ;
0663: E8F0         ;                                                                            ;
0664: E8F0         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0665: E8F0         ; described, checks to see if there is an incoming character, and checks for ;
0666: E8F0         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0667: E8F0         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0668: E8F0         ; the printer).                                                              ;
0669: E8F0         ;                                                                            ;
0670: E8F0         ;			Function Code	:	C = 09H                                      ;
0671: E8F0         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0672: E8F0         ;			Exit Parameters :	None							             ;
0673: E8F0         ;																			 ;
0674: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0675: E8F0             vPrintString:
0676: E8F0 2A BB EA               LD     HL,(paramDE)         ; Get address of the string
0677: E8F3 4D                     LD     C,L
0678: E8F4 44                     LD     B,H                  ; Put it into BC for call
0679: E8F5 CD 33 E9               CALL   Print                ; out to console
0680: E8F8 C9                     RET
0681: E8F9
0682: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0683: E8F9         ;  This function reads a string of characters from the console device        ;
0684: E8F9         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0685: E8F9         ; editing is possible: the operator can backspace, cancel the line and start ;
0686: E8F9         ; over, and use all the normal control functions. What you will ultimately   ;
0687: E8F9         ; see in the buffer is the final version of the character string entered,    ;
0688: E8F9         ; without any of the errors or control characters used to do the line editing;
0689: E8F9         ;                                                                            ;
0690: E8F9         ;  The buffer that you define has a special format. The first byte in the    ;
0691: E8F9         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0692: E8F9         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0693: E8F9         ; were actually placed in the buffer. The following bytes contain            ;
0694: E8F9         ; the characters of the string. Character input will cease either when a     ;
0695: E8F9         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0696: E8F9         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0697: E8F9         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0698: E8F9         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0699: E8F9         ; the "characters input" byte to O. If you attempt to input more than the    ;
0700: E8F9         ; maximum number of characters, the "characters input" count will be the     ;
0701: E8F9         ; same as the maximum value allowed.                                         ;
0702: E8F9         ;                                                                            ;
0703: E8F9         ;			Function Code	:	C = 0AH                                      ;
0704: E8F9         ;			Entry Parameters:	DE = Address string buffer					 ;
0705: E8F9         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0706: E8F9         ;																			 ;
0707: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0708: E8F9             vReadString:
0709: E8F9 CD D8 E9               CALL   ReadString
0710: E8FC C9                     RET
0711: E8FD
0712: E8FD
0713: E8FD
0714: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0715: E8FD         ; This function tells you whether a console input character is waiting to be ;
0716: E8FD         ;processed. Unlike the Console Input functions, which will wait until there  ;
0717: E8FD         ;is input,this function simply checks and returns immediately.               ;
0718: E8FD         ;                                                                            ;
0719: E8FD         ;			Function Code	:	C = 0BH                                      ;
0720: E8FD         ;			Entry Parameters:	None										 ;
0721: E8FD         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0722: E8FD         ;								A = FFH	if incoming Data					 ;
0723: E8FD         ;																			 ;
0724: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0725: E8FD
0726: E8FD         ;check console status
0727: E8FD             vGetConsoleStatus:
0728: E8FD CD 84 E9               CALL   ConBreak
0729: E900 32 BD EA               LD     (exitParameterByte),A
0730: E903 C9                     RET
0731: E904         ;----------
0732: E904         ;----------
0733: E904         ;----------
0734: E904         ;get/set user code
0735: E904         ; IN - (E) = FF its a get else user Number(0-15)
0736: E904         ; OUT - (A) Current user number or no value
0737: E904             vGetSetUserNumber:                      ; func32 (32 - 20)	Get or set User code
0738: E904 3A BA EA               LD     A,(paramE)
0739: E907 FE FF                  CP     0FFH
0740: E909 C2 13 E9               JP     NZ,SetUserNumber     ; interrogate user code instead
0741: E90C 3A 0B F5               LD     A,(currentUserNumber)
0742: E90F 32 BD EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0743: E912 C9                     RET
0744: E913
0745: E913             SetUserNumber:                      ; setusrcode
0746: E913 E6 0F                  AND    LO_NIBBLE_MASK
0747: E915 32 0B F5               LD     (currentUserNumber),A
0748: E918 C9                     RET
0749: E919
0750: E919         ;****************************************************************************;
0751: E919         ;								Character Support Routines					 ;
0752: E919         ;****************************************************************************;
0753: E919
0754: E919         ;****************************************************************************;
0755: E919         ; 								Console Routines							 ;
0756: E919         ;****************************************************************************;
0757: E919
0758: E919         ;-------------------- Return a Character from the console -------------------;
0759: E919         ;return byte from buffer or read from the console                            ;
0760: E919             ConIn:                          ;
0761: E919 21 B6 EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0762: E91C 7E                     LD     A,(HL)               ;
0763: E91D 36 00                  LD     (HL),0               ;
0764: E91F B7                     OR     A                    ;
0765: E920 C0                     RET    NZ                   ;
0766: E921         ;
0767: E921 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0768: E924         ;-------------------- Return a Character from the console -------------------;
0769: E924
0770: E924         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0771: E924         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0772: E924             IsPrintableASCII:                      ;
0773: E924 FE 0D                  CP     CR                   ;
0774: E926 C8                     RET    Z                    ; carriage return?                                                  ;
0775: E927 FE 0A                  CP     LF                   ;
0776: E929 C8                     RET    Z                    ; line feed?                                                        ;
0777: E92A FE 09                  CP     TAB                  ;
0778: E92C C8                     RET    Z                    ; TAB?                                                              ;
0779: E92D FE 08                  CP     CTRL_H               ;
0780: E92F C8                     RET    Z                    ; backspace?                                                        ;
0781: E930 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0782: E932 C9                     RET                         ;
0783: E933         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0784: E933
0785: E933         ;------------------ Print character from (BC) until  $ found ----------------;
0786: E933             Print:                          ;
0787: E933 0A                     LD     A,(BC)               ; Get the next character             ;
0788: E934 FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0789: E936 C8                     RET    Z                    ;  exit if yes                       ;
0790: E937 03                     INC    BC                   ; Update the pointer                 ;
0791: E938 C5                     PUSH   BC                   ; Save it                            ;
0792: E939 4F                     LD     C,A                  ; Does Byte require                  ;
0793: E93A CD 50 E9               CALL   TabOut               ;  special attention - check         ;
0794: E93D C1                     POP    BC                   ; Retrieve the pointer				 ;
0795: E93E 18 F3                  JR     Print                ; Loop back                          ;
0796: E940         ;------------------ Print character from (BC) until  $ found ----------------;
0797: E940
0798: E940         ;-- Send printable character to console. Precede with Caret if needed -------;
0799: E940         ; character is in Reg C                                                      ;
0800: E940             CaretOut:                       ;
0801: E940 79                     LD     A,C                  ;
0802: E941 CD 24 E9               CALL   IsPrintableASCII     ;
0803: E944 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0804: E946         ; send preceding up arrow                                                    ;
0805: E946 F5                     PUSH   AF                   ; Save the character                 ;
0806: E947 0E 5E                  LD     C,CARET              ;
0807: E949 CD 63 E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0808: E94C F1                     POP    AF                   ; Get the character                  ;
0809: E94D F6 40                  OR     40H                  ; Make the graphic a letter          ;
0810: E94F 4F                     LD     C,A                  ; Set up to print                    ;
0811: E950         ; fall thru to TabbOut                                                       ;
0812: E950         ;-- Send printable character to console. Precede with Caret if needed -------;
0813: E950
0814: E950
0815: E950         ;------------- Send printable character to console. Expand if TAB -----------;
0816: E950         ; character is in Reg C                                                      ;
0817: E950             TabOut:                         ;
0818: E950 79                     LD     A,C                  ;
0819: E951 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0820: E953 C2 63 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0821: E956         ;
0822: E956         ; TAB encountered                                                           ;
0823: E956             TabOut0:                        ;
0824: E956 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0825: E958 CD 63 E9               CALL   ConsoleOut           ; Send to Console                    ;
0826: E95B 3A B9 EA               LD     A,(columnPosition)   ; Get Column position                ;
0827: E95E E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0828: E960 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0829: E962 C9                     RET                         ;
0830: E963         ;------------- Send printable character to console. Expand if TAB -----------;
0831: E963         ;-------------------------- Send character to console -----------------------;
0832: E963         ; B  = Count                                                                 ;
0833: E963         ; C  = Character                                                             ;
0834: E963         ; HL = Pointer                                                               ;
0835: E963             ConsoleOut:                      ;
0836: E963         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0837: E963 C5                     PUSH   BC                   ; Save character and Count           ;
0838: E964 CD 84 E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0839: E967 C1                     POP    BC                   ;
0840: E968 C5                     PUSH   BC                   ; Get/save character                 ;
0841: E969         ; Send character to Console	                                                 ;
0842: E969 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0843: E96C C1                     POP    BC                   ;
0844: E96D C5                     PUSH   BC                   ; Get/save character                 ;
0845: E96E         ; is the data to be output to print device?                                  ;
0846: E96E 3A B7 EA               LD     A,(printEchoFlag)    ;
0847: E971 B7                     OR     A                    ;
0848: E972 C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0849: E975 C1                     POP    BC                   ; Get the character                  ;
0850: E976         ;
0851: E976 79                     LD     A,C                  ; Move character to ACC              ;
0852: E977 21 B9 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0853: E97A 34                     INC    M                    ; increment the ColumnPosition       ;
0854: E97B         ;
0855: E97B FE 20                  CP     SPACE                ;
0856: E97D D0                     RET    NC                   ; Exit if ASCII printable            ;
0857: E97E         ;
0858: E97E FE 0A                  CP     LF                   ;
0859: E980 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0860: E981         ;
0861: E981 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0862: E983 C9                     RET                         ;
0863: E984         ;-------------------------- Send character to console -----------------------;
0864: E984
0865: E984
0866: E984         ;
0867: E984
0868: E984         ;--------------------  Check for Status and Control S or C ------------------;
0869: E984         ;  Returns:																	 ;
0870: E984         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0871: E984         ;			ACC = 00   No data Pending										 ;
0872: E984         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0873: E984         ;                                                                            ;
0874: E984             ConBreak:                       ;
0875: E984 3A B6 EA               LD     A,(keyboardByte)     ;
0876: E987 B7                     OR     A                    ;
0877: E988 20 2B                  JR     NZ,ConBreak1         ; Return with FF in ACC              ;
0878: E98A         ;
0879: E98A CD 06 F6               CALL   bcConst              ; Get status                         ;
0880: E98D FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0881: E98F C8                     RET    Z                    ; Return 00 No data pending          ;
0882: E990         ;
0883: E990 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0884: E993         ;
0885: E993         ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>            ;
0886: E993 FE 10                  CP     CTRL_P               ;
0887: E995 20 0D                  JR     NZ,CheckCTL_S        ;
0888: E997 21 B7 EA               LD     HL,printEchoFlag     ;
0889: E99A 3E FF                  LD     A,TRUE               ;
0890: E99C BE                     CP     (HL)                 ;
0891: E99D 20 02                  JR     NZ,ToggleFlag1       ;
0892: E99F 3E 00                  LD     A,FALSE              ;
0893: E9A1             ToggleFlag1:                      ;
0894: E9A1 77                     LD     (HL),A               ;
0895: E9A2 18 0C                  JR     NothingWaiting       ;
0896: E9A4             CheckCTL_S:                      ;
0897: E9A4         ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>           ;
0898: E9A4 FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0899: E9A6 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0900: E9A8         ;
0901: E9A8 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0902: E9AB FE 03                  CP     CTRL_C               ;
0903: E9AD CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0904: E9B0             NothingWaiting:                      ;
0905: E9B0 AF                     XOR    A                    ;
0906: E9B1 C9                     RET                         ; Set ACC = 0 and return             ;
0907: E9B2             ConBreak0:                      ;
0908: E9B2 32 B6 EA               LD     (keyboardByte),A     ; save the byte                      ;
0909: E9B5             ConBreak1:                      ;
0910: E9B5 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0911: E9B7 C9                     RET                         ;
0912: E9B8         ;--------------------  Check for Status and Control S or C ------------------;
0913: E9B8
0914: E9B8         ;------------------------  Console Output Utilities -------------------------;
0915: E9B8             showHashCRLF:                      ;
0916: E9B8 0E 23                  LD     C,HASH_TAG           ;
0917: E9BA CD 63 E9               CALL   ConsoleOut           ; Send # to console                  ;
0918: E9BD CD CE E9               CALL   showCRLF             ;
0919: E9C0             showHashCRLF1:                      ;
0920: E9C0 3E B9                  LD     A,columnPosition     ;
0921: E9C2 21 B8 EA               LD     HL,startingColumn    ;
0922: E9C5 BF                     CP     A,M                  ;
0923: E9C6 D0                     RET    NC                   ;
0924: E9C7 0E 20                  LD     C,SPACE              ;
0925: E9C9 CD 63 E9               CALL   ConsoleOut           ;
0926: E9CC 18 F2                  JR     showHashCRLF1        ;
0927: E9CE         ;Send the Carriage Return Line Feed sequence                                 ;
0928: E9CE             showCRLF:                       ;
0929: E9CE 0E 0D                  LD     C,CR                 ;
0930: E9D0 CD 63 E9               CALL   ConsoleOut           ;
0931: E9D3 0E 0A                  LD     C,LF                 ;
0932: E9D5         ; 	CALL	ConsoleOut					; exit via ConsoleOuts RET           ;
0933: E9D5 C3 63 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0934: E9D8         ;
0935: E9D8         ;------------------------  Console Output Utilities -------------------------;
0936: E9D8
0937: E9D8         ;------------------------- Read a $ terminated String -----------------------;
0938: E9D8         ;read to paramDE address (max length, current length, buffer)               ;
0939: E9D8             ReadString:                      ;
0940: E9D8 3A B9 EA               LD     A,(columnPosition)   ;
0941: E9DB 32 B8 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0942: E9DE 2A BB EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0943: E9E1 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0944: E9E2 23                     INC    HL                   ; Point at actual bytes read         ;
0945: E9E3 06 00                  LD     B,0                  ; Initialize Current Index           ;
0946: E9E5         ; B = current buffer length,                                                ;
0947: E9E5         ; C = maximum buffer length,                                                ;
0948: E9E5         ; HL= next to fill - 1                                                      ;
0949: E9E5         ;
0950: E9E5         ; read next character, BC, HL active                                        ;
0951: E9E5             ReadNext:                       ;
0952: E9E5 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0953: E9E6 E5                     PUSH   HL                   ; Save pointer                       ;
0954: E9E7             ReadNext0:                      ;
0955: E9E7 CD 19 E9               CALL   ConIn                ; Get the next Character             ;
0956: E9EA E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0957: E9EC E1                     POP    HL                   ; Restore Pointer					 ;
0958: E9ED C1                     POP    BC                   ; Restore Current Index and Max Count;
0959: E9EE         ;Is It Carriage Return                                                       ;
0960: E9EE FE 0D                  CP     CR                   ;
0961: E9F0 CA 36 EA               JP     Z,EndRead            ; End the read if yes                ;
0962: E9F3 FE 0A                  CP     LF                   ;
0963: E9F5         ;Is It Linefeed                                                              ;
0964: E9F5 CA 36 EA               JP     Z,EndRead            ; End the read if yes                ;
0965: E9F8         ;Is It BackSpace                                                             ;
0966: E9F8 FE 08                  CP     CTRL_H               ;
0967: E9FA CA 40 EA               JP     Z,BSspaceBS          ;
0968: E9FD             IsItRubout:                      ;
0969: E9FD FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
0970: E9FF CA 4A EA               JP     Z,ItIsRubout         ;
0971: EA02             IsPhysicalEOL:                      ;
0972: EA02 FE 05                  CP     CTRL_E               ;
0973: EA04 CA 55 EA               JP     Z,ItIsPhysicalEOL    ;
0974: EA07             IsItPrintToggle:                      ;
0975: EA07 FE 10                  CP     CTRL_P               ;
0976: EA09 CA 5D EA               JP     Z,ItIsPrintToggle    ;
0977: EA0C             IsItDeleteTheLineX:                      ;
0978: EA0C FE 18                  CP     CTRL_X               ;
0979: EA0E CA 86 EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
0980: EA11             IsItDeleteTheLineU:                      ;
0981: EA11 FE 15                  CP     CTRL_U               ;
0982: EA13 CA A4 EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line       ;
0983: EA16         ;Retype the line                                                             ;
0984: EA16 FE 12                  CP     CTRL_R               ;
0985: EA18 CA 6D EA               JP     Z,RepeatLine         ;
0986: EA1B
0987: EA1B         ;....................... Echo input back to the Console  ....................;
0988: EA1B         ; Full Duplex								                                 ;
0989: EA1B         ; A = Character to display	                                                 ;
0990: EA1B         ; B = current buffer length, (index)                                         ;
0991: EA1B         ; C = maximum buffer length,                                                 ;
0992: EA1B         ; HL= next to fill - 1 (Pointer)                                             ;
0993: EA1B         ;
0994: EA1B         ;ReadEcho                                                                    ;
0995: EA1B 04                     INC    B                    ; Increment byte count		         ;
0996: EA1C 23                     INC    HL                   ; Advance the Pointer                ;
0997: EA1D 77                     LD     (HL),A               ; Put char in buffer                 ;
0998: EA1E         ;
0999: EA1E             ReadEchoRubOut:                      ;
1000: EA1E C5                     PUSH   BC                   ; Save index and length              ;
1001: EA1F E5                     PUSH   HL                   ; Save the Pointer                   ;
1002: EA20 4F                     LD     C,A                  ; Get char                           ;
1003: EA21 CD 40 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1004: EA24 E1                     POP    HL                   ; Restore the Pointer                ;
1005: EA25 C1                     POP    BC                   ; Restore index and length           ;
1006: EA26 7E                     LD     A,(HL)               ; Recall char                        ;
1007: EA27         ; check for Warm Boot                                                        ;
1008: EA27 FE 03                  CP     CTRL_C               ;
1009: EA29 78                     LD     A,B                  ; Get Line position                  ;
1010: EA2A C2 32 EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1011: EA2D FE 01                  CP     1                    ; Beginning of the Line?             ;
1012: EA2F CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1013: EA32         ; Check to see if we are at the end of the buffer                            ;
1014: EA32             AreWeAtEndOfBuffer:                      ;
1015: EA32 B9                     CP     C                    ; Over Max ?					     ;
1016: EA33 DA E5 E9               JP     C,ReadNext           ;  no, Go for more				     ;
1017: EA36         ;
1018: EA36         ; At the end of read                                  					     ;
1019: EA36             EndRead:                        ;
1020: EA36         ; 	POP		HL                                                               ;
1021: EA36 2A BB EA               LD     HL,(paramDE)         ;
1022: EA39 23                     INC    HL                   ;
1023: EA3A         ;
1024: EA3A 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1025: EA3B 0E 0D                  LD     C,CR                 ;
1026: EA3D C3 63 E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1027: EA40         ;....................... Echo input back to the Console  ....................;
1028: EA40         ;.......................... Backspace SPACE BackSpace .......................;
1029: EA40             BSspaceBS:                      ;
1030: EA40 05                     DEC    B                    ;
1031: EA41 2B                     DEC    HL                   ;
1032: EA42 C5                     PUSH   BC                   ;
1033: EA43 E5                     PUSH   HL                   ;
1034: EA44 CD 97 EA               CALL   BackUp               ;
1035: EA47 C3 E7 E9               JP     ReadNext0            ;
1036: EA4A         ;.......................... Backspace SPACE BackSpace .......................;
1037: EA4A         ;.......................... It is RubOut ....................................;
1038: EA4A             ItIsRubout:                      ;
1039: EA4A         ; RUBOUT if possible                                                         ;
1040: EA4A 78                     LD     A,B                  ; Are we at the start of the line    ;
1041: EA4B B7                     OR     A                    ;
1042: EA4C CA E5 E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1043: EA4F         ;adjust pointers back one                                                    ;
1044: EA4F 7E                     LD     A,(HL)               ; ACC = current character            ;
1045: EA50 05                     DEC    B                    ; Adjust the index			    	 ;
1046: EA51 2B                     DEC    HL                   ; Adjust the pointer                 ;
1047: EA52 C3 1E EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1048: EA55         ;.......................... It is RubOut ....................................;
1049: EA55         ;.......................... It is PhysicalEOL ...............................;
1050: EA55             ItIsPhysicalEOL:                      ;
1051: EA55 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1052: EA56 E5                     PUSH   HL                   ; Save pointer                       ;
1053: EA57 CD CE E9               CALL   showCRLF             ; Make new line                      ;
1054: EA5A C3 E7 E9               JP     ReadNext0            ;   and go for next char   			 ;
1055: EA5D         ;.......................... It is PhysicalEOL ...............................;
1056: EA5D         ;.......................... It is PrintToggle ...............................;
1057: EA5D             ItIsPrintToggle:
1058: EA5D E5                     PUSH   HL                   ; Save pointer                       ;
1059: EA5E         ; Toggle the printEcho Flag                                                  ;
1060: EA5E 21 B7 EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1061: EA61 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1062: EA63 BE                     CP     (HL)                 ; Is the flag true?                  ;
1063: EA64 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1064: EA66 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1065: EA68             IsItPrintToggle1:                      ;
1066: EA68 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1067: EA69 E1                     POP    HL                   ; Restore pointer                    ;
1068: EA6A C3 E5 E9               JP     ReadNext             ;   and for another char             ;
1069: EA6D         ;.......................... It is PrintToggle ...............................;
1070: EA6D         ;.......................... RepeatLine ......................................;
1071: EA6D             RepeatLine:                      ;
1072: EA6D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1073: EA6E E5                     PUSH   HL                   ;  for exit                          ;
1074: EA6F CD B8 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1075: EA72         ;
1076: EA72 2A BB EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1077: EA75 23                     INC    HL                   ; Skip past character count          ;
1078: EA76         ;
1079: EA76             LL1:                            ;
1080: EA76 23                     INC    HL                   ; Point at next char to display      ;
1081: EA77 C5                     PUSH   BC                   ; Save counter, in B                 ;
1082: EA78 E5                     PUSH   HL                   ; Save buffer pointer                ;
1083: EA79 4E                     LD     C,M                  ; Get the next character             ;
1084: EA7A CD 40 E9               CALL   CaretOut             ; Display it                         ;
1085: EA7D E1                     POP    HL                   ; Restore                            ;
1086: EA7E C1                     POP    BC                   ;  the counter and pointer           ;
1087: EA7F 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1088: EA81 E1                     POP    HL                   ; Restore values                     ;
1089: EA82 C1                     POP    BC                   ;  from routine entry                ;
1090: EA83 C3 E5 E9               JP     ReadNext             ; Done here !                        ;
1091: EA86         ;.......................... RepeatLine ......................................;
1092: EA86         ;.......................... Delete The Line .................................;
1093: EA86             DeleteTheLine:                      ;
1094: EA86 E1                     POP    HL                   ; Adjust Stack                       ;
1095: EA87         ;                                             ;
1096: EA87             DeleteTheLine1:                      ;
1097: EA87 3A B8 EA               LD     A,(startingColumn)   ;
1098: EA8A 21 B9 EA               LD     HL,columnPosition    ;
1099: EA8D BE                     CP     M                    ; Start of line ?                    ;
1100: EA8E D2 D8 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1101: EA91 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1102: EA92 CD 97 EA               CALL   BackUp               ; Clear 1 column                     ;
1103: EA95 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1104: EA97         ;.......................... Delete The Line .................................;
1105: EA97         ;------------------------ Back-up one screen position -----------------------;
1106: EA97             BackUp:                         ;
1107: EA97 CD 9F EA               CALL   BackUp1              ; Send Backspace                     ;
1108: EA9A 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1109: EA9C CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1110: EA9F         ;does not affect column count                                                ;
1111: EA9F             BackUp1:                        ;
1112: EA9F 0E 08                  LD     C,CTRL_H             ;
1113: EAA1 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1114: EAA4         ;------------------------ Back-up one screen position -----------------------;
1115: EAA4         ;.......................... Ignore The Line .................................;
1116: EAA4             IgnoreTheLine:                      ;
1117: EAA4 CD B8 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1118: EAA7 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1119: EAA9 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1120: EAAC 0E 20                  LD     C,SPACE              ;
1121: EAAE CD 0C F6               CALL   bcConout             ;
1122: EAB1 C3 D8 E9               JP     ReadString           ; Start all over                     ;
1123: EAB4         ;.......................... Ignore The Line .................................;
1124: EAB4
1125: EAB4         ;=====================
1126: EAB4
1127: EAB4         ;------------------------- Read a $ terminated String -----------------------;
1128: EAB4
1129: EAB4
1130: EAB4         ;****************************************************************************
1131: EAB4         ;                           DATA AREA                                       *
1132: EAB4         ;****************************************************************************
1133: EAB4
1134: EAB4         ;------------------------------Non Disk Data Area ---------------------------;
1135: EAB4             usersStack: DS     2                    ; entry stack pointer                ;
1136: EAB6         ;
1137: EAB6 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1138: EAB7         ;
1139: EAB7 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1140: EAB8         ;
1141: EAB8         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1142: EAB8 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1143: EAB9 00          columnPosition: DB     0                    ; Current Column position            ;
1144: EABA         ;
1145: EABA             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1146: EABB             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1147: EABD             exitParameterByte:                      ; Byte returned Value                ;
1148: EABD             exitParameterWord: DS     WORD                 ; Word                           ;
1149: EABF         ;
1150: EABF         ;
1151: EABF         ;------------------------------------ Data Area -----------------------------;
1152: EABF
1153: EABF
1154: EABF
1155: EABF         ;*****************************************************************************;
1156: EABF         ;								Disk I/O									  ;
1157: EABF         ;*****************************************************************************;
1158: EABF
1159: EABF
1160: EABF         ;*****************************************************************
1161: EABF         ;random disk read
1162: EABF         ;IN  - (DE) FCB address
1163: EABF         ;OUT - (A) 01 = Reading unwritten data
1164: EABF         ;	 02 = N/U
1165: EABF         ;	 03 = Cannot close current extent
1166: EABF         ;	 04 = Seek to unwriten Extent
1167: EABF         ;	 05 = N/U
1168: EABF         ;	 06 = Seek past Physical end of Disk
1169: EABF             vReadRandom:                      ; func33 (33 - 21) Read Random record
1170: EABF CD CC F2               CALL   Reselect
1171: EAC2 C3 D6 EA               JP     RandomDiskRead       ; to perform the disk read
1172: EAC5         ;*****************************************************************
1173: EAC5         ;write random record
1174: EAC5         ;IN  - (DE) FCB address
1175: EAC5         ;OUT - (A) 01 = Reading unwritten data
1176: EAC5         ;	 02 = N/U
1177: EAC5         ;	 03 = Cannot close current extent
1178: EAC5         ;	 04 = Seek to unwriten Extent
1179: EAC5         ;	 05 = Cannot create new Extent because of directory overflow
1180: EAC5         ;	 06 = Seek past Physical end of Disk
1181: EAC5             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1182: EAC5 CD CC F2               CALL   Reselect
1183: EAC8 C3 DF EA               JP     RandomDiskWrite      ; to perform the disk write
1184: EACB         ;ret ;jmp goback
1185: EACB         ;*****************************************************************
1186: EACB         ;return file size (0-65536)
1187: EACB         ;IN  - (DE) FCB address
1188: EACB             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1189: EACB CD CC F2               CALL   Reselect
1190: EACE C3 8C EB               JP     GetFileSize
1191: EAD1         ;*****************************************************************
1192: EAD1         ;set random record
1193: EAD1         ;IN  - (DE) FCB address
1194: EAD1         ;OUT - Random Record Field is set
1195: EAD1             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1196: EAD1 C3 79 EB               JP     SetRandomRecord
1197: EAD4         ;*****************************************************************
1198: EAD4         ;Reset Drive
1199: EAD4         ;IN  - (DE) Drive Vector
1200: EAD4         ;OUT - (A) 00
1201: EAD4             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1202: EAD4         ; Not Yet Implemented   **************
1203: EAD4 C9                     RET
1204: EAD5         ;*****************************************************************
1205: EAD5         ;*****************************************************************
1206: EAD5         ;Write Random With Zero Fill
1207: EAD5         ;IN  - (DE) FCB address
1208: EAD5         ;OUT - (A) Return Code		see Function 34
1209: EAD5             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1210: EAD5         ; Not Yet Implemented   **************
1211: EAD5 C9                     RET
1212: EAD6         ;*****************************************************************
1213: EAD6         ;******************< Random I/O Stuff ****************************
1214: EAD6         ;*****************************************************************
1215: EAD6         ;random disk read
1216: EAD6             RandomDiskRead:                      ; randiskread
1217: EAD6 0E FF                  LD     C,TRUE               ; marked as read operation
1218: EAD8 CD E8 EA               CALL   RandomSeek
1219: EADB CC BE EF               CALL   Z,DiskRead           ; if seek successful
1220: EADE C9                     RET
1221: EADF         ;*****************************************************************
1222: EADF         ;random disk write
1223: EADF             RandomDiskWrite:                      ; randiskwrite
1224: EADF 0E 00                  LD     C,FALSE              ; marked as read operation
1225: EAE1 CD E8 EA               CALL   RandomSeek
1226: EAE4 CC 01 F0               CALL   Z,DiskWrite          ; if seek successful
1227: EAE7 C9                     RET
1228: EAE8         ;*****************************************************************
1229: EAE8         ;*****************************************************************
1230: EAE8         ;random access seek operation, C=0ffh if read mode
1231: EAE8         ;fcb is assumed to address an active file control block
1232: EAE8         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1233: EAE8             RandomSeek:
1234: EAE8 AF                     XOR    A
1235: EAE9 32 36 F5               LD     (seqReadFlag),A      ; marked as random access operation
1236: EAEC C5                     PUSH   BC                   ; save r/w flag
1237: EAED 2A BB EA               LD     HL,(paramDE)
1238: EAF0 EB                     EX     DE,HL                ; DE will hold base of fcb
1239: EAF1 21 21 00               LD     HL,RANDOM_REC_FIELD
1240: EAF4 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1241: EAF5 7E                     LD     A,(HL)
1242: EAF6 E6 7F                  AND    7FH
1243: EAF8 F5                     PUSH   AF                   ; record number
1244: EAF9 7E                     LD     A,(HL)
1245: EAFA 17                     RLA                         ; cy=lsb of extent#
1246: EAFB 23                     INC    HL
1247: EAFC 7E                     LD     A,(HL)
1248: EAFD 17                     RLA
1249: EAFE E6 1F                  AND    11111B               ; A=ext#
1250: EB00 4F                     LD     C,A                  ; C holds extent number, record stacked
1251: EB01 7E                     LD     A,(HL)
1252: EB02 1F                     RRA
1253: EB03 1F                     RRA
1254: EB04 1F                     RRA
1255: EB05 1F                     RRA
1256: EB06 E6 0F                  AND    1111B                ; mod#
1257: EB08 47                     LD     B,A                  ; B holds module#, C holds ext#
1258: EB09 F1                     POP    AF                   ; recall sought record #
1259: EB0A         ;check to insure that high byte of ran rec = 00
1260: EB0A 23                     INC    HL
1261: EB0B 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1262: EB0C 2C                     INC    L
1263: EB0D 2D                     DEC    L
1264: EB0E 2E 06                  LD     L,06                 ; zero flag, l=6
1265: EB10         ; produce error 6, seek past physical eod
1266: EB10 C2 71 EB               JP     NZ,RandomSeekError
1267: EB13         ; otherwise, high byte = 0, A = sought record
1268: EB13 21 20 00               LD     HL,NEXT_RECORD
1269: EB16 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1270: EB17 77                     LD     (HL),A               ; sought rec# stored away
1271: EB18         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1272: EB18         ; the r/w flag is still stacked.  compare fcb values
1273: EB18 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1274: EB1B 19                     ADD    HL,DE
1275: EB1C 79                     LD     A,C                  ; A=seek ext#
1276: EB1D 96                     SUB    M
1277: EB1E C2 2C EB               JP     NZ,RandomSeekClose   ; tests for = extents
1278: EB21         ; extents match, check mod#
1279: EB21 21 0E 00               LD     HL,fcbS2Index
1280: EB24 19                     ADD    HL,DE
1281: EB25 78                     LD     A,B                  ; B=seek mod#
1282: EB26         ; could be overflow at eof, producing module#
1283: EB26         ; of 90H or 10H, so compare all but fwf
1284: EB26 96                     SUB    M
1285: EB27 E6 7F                  AND    7FH
1286: EB29 CA 64 EB               JP     Z,RandomSeekExit     ; same?
1287: EB2C             RandomSeekClose:
1288: EB2C C5                     PUSH   BC
1289: EB2D D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1290: EB2E CD A1 F1               CALL   CloseDirEntry        ; current extent closed
1291: EB31 D1                     POP    DE
1292: EB32 C1                     POP    BC                   ; recall parameters and fill
1293: EB33 2E 03                  LD     L,03                 ; cannot close error #3
1294: EB35 3A BD EA               LD     A,(exitParameterByte)
1295: EB38 3C                     INC    A
1296: EB39 CA 6A EB               JP     Z,RandomSeekErrorBadSeek
1297: EB3C 21 0C 00               LD     HL,fcbExtIndex
1298: EB3F 19                     ADD    HL,DE
1299: EB40 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1300: EB41 21 0E 00               LD     HL,fcbS2Index
1301: EB44 19                     ADD    HL,DE
1302: EB45 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1303: EB46 CD F9 F2               CALL   OpenFile             ; is the file present?
1304: EB49 3A BD EA               LD     A,(exitParameterByte)
1305: EB4C 3C                     INC    A
1306: EB4D C2 64 EB               JP     NZ,RandomSeekExit    ; open successful?
1307: EB50         ; cannot open the file, read mode?
1308: EB50 C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1309: EB51 C5                     PUSH   BC                   ; everyone expects this item stacked
1310: EB52 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1311: EB54 0C                     INC    C                    ; becomes 00 if read operation
1312: EB55 CA 6A EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1313: EB58 CD 49 F1               CALL   MakeNewFile          ; write operation, make new extent
1314: EB5B 2E 05                  LD     L,05                 ; cannot create new extent #5
1315: EB5D 3A BD EA               LD     A,(exitParameterByte)
1316: EB60 3C                     INC    A
1317: EB61 CA 6A EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1318: EB64         ; file make operation successful
1319: EB64             RandomSeekExit:                      ; seekok:
1320: EB64 C1                     POP    BC                   ; discard r/w flag
1321: EB65 AF                     XOR    A
1322: EB66 32 BD EA               LD     (exitParameterByte),A
1323: EB69 C9                     RET                         ; with zero set
1324: EB6A
1325: EB6A             RandomSeekErrorBadSeek:
1326: EB6A         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1327: EB6A         ; appears as overflow with file write flag set
1328: EB6A E5                     PUSH   HL                   ; save error flag
1329: EB6B CD C3 F2               CALL   GetModuleNum         ; HL = .fcbS2Index
1330: EB6E 36 C0                  LD     (HL),11000000B
1331: EB70 E1                     POP    HL                   ; and drop through
1332: EB71             RandomSeekError:                      ; seekerr:
1333: EB71 C1                     POP    BC                   ; discard r/w flag
1334: EB72 7D                     LD     A,L
1335: EB73 32 BD EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1336: EB76         ; SetFileWriteFlag returns non-zero accumulator for err
1337: EB76 C3 CC F3               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1338: EB79         ;ret
1339: EB79         ;
1340: EB79         ;*****************************************************************
1341: EB79             SetRandomRecord:                      ; setrandom
1342: EB79 2A BB EA               LD     HL,(paramDE)
1343: EB7C 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1344: EB7F CD C8 EB               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1345: EB82 21 21 00               LD     HL,RANDOM_REC_FIELD
1346: EB85 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1347: EB86 71                     LD     (HL),C
1348: EB87 23                     INC    HL
1349: EB88 70                     LD     (HL),B
1350: EB89 23                     INC    HL
1351: EB8A 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1352: EB8B C9                     RET
1353: EB8C         ;*****************************************************************
1354: EB8C         ;compute logical file size for current fcb
1355: EB8C             GetFileSize:                      ; getfilesize
1356: EB8C 0E 0C                  LD     C,fcbExtIndex
1357: EB8E CD 3C F3               CALL   Search4DirElement
1358: EB91         ; zero the receiving Ramdom record field
1359: EB91 2A BB EA               LD     HL,(paramDE)
1360: EB94 11 21 00               LD     DE,RANDOM_REC_FIELD
1361: EB97 19                     ADD    HL,DE
1362: EB98 E5                     PUSH   HL                   ; save position
1363: EB99 72                     LD     (HL),D
1364: EB9A 23                     INC    HL
1365: EB9B 72                     LD     (HL),D
1366: EB9C 23                     INC    HL
1367: EB9D 72                     LD     (HL),D               ; =00 00 00
1368: EB9E             GetFileSize1:                      ; getsize:
1369: EB9E CD E0 ED               CALL   EndOfDirectory
1370: EBA1 CA C6 EB               JP     Z,GetFileSizeExit
1371: EBA4         ; current fcb addressed by dptr
1372: EBA4 CD CC EE               CALL   GetDirElementAddress
1373: EBA7 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1374: EBAA CD C8 EB               CALL   GetRandomRecordPosition
1375: EBAD         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1376: EBAD E1                     POP    HL
1377: EBAE E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1378: EBAF 5F                     LD     E,A                  ; save cy
1379: EBB0 79                     LD     A,C
1380: EBB1 96                     SUB    M
1381: EBB2 23                     INC    HL                   ; ls byte
1382: EBB3 78                     LD     A,B
1383: EBB4 9E                     SBC    A,(HL)
1384: EBB5 23                     INC    HL                   ; middle byte
1385: EBB6 7B                     LD     A,E
1386: EBB7 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1387: EBB8 DA C0 EB               JP     C,GetFileSize2       ; for another try
1388: EBBB         ; fcb is less or equal, fill from directory
1389: EBBB 73                     LD     (HL),E
1390: EBBC 2B                     DEC    HL
1391: EBBD 70                     LD     (HL),B
1392: EBBE 2B                     DEC    HL
1393: EBBF 71                     LD     (HL),C
1394: EBC0             GetFileSize2:                      ; getnextsize:
1395: EBC0 CD 54 F3               CALL   Search4NextDirElement
1396: EBC3 C3 9E EB               JP     GetFileSize1
1397: EBC6             GetFileSizeExit:                      ; setsize:
1398: EBC6 E1                     POP    HL                   ; discard .fcb(random record field)
1399: EBC7 C9                     RET
1400: EBC8         ;-----------------------------------------------------------------
1401: EBC8         ;compute random record position
1402: EBC8             GetRandomRecordPosition:                      ; compute$rr
1403: EBC8 EB                     EX     DE,HL
1404: EBC9 19                     ADD    HL,DE
1405: EBCA         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1406: EBCA 4E                     LD     C,(HL)
1407: EBCB 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1408: EBCD 21 0C 00               LD     HL,fcbExtIndex
1409: EBD0 19                     ADD    HL,DE
1410: EBD1 7E                     LD     A,(HL)
1411: EBD2 0F                     RRCA
1412: EBD3 E6 80                  AND    80H                  ; A=e000 0000
1413: EBD5 81                     ADD    A,C
1414: EBD6 4F                     LD     C,A
1415: EBD7 3E 00                  LD     A,0
1416: EBD9 88                     ADC    A,B
1417: EBDA 47                     LD     B,A
1418: EBDB         ; BC = 0000 000? errrr rrrr
1419: EBDB 7E                     LD     A,(HL)
1420: EBDC 0F                     RRCA
1421: EBDD E6 0F                  AND    LO_NIBBLE_MASK
1422: EBDF 80                     ADD    A,B
1423: EBE0 47                     LD     B,A
1424: EBE1         ; BC = 000? eeee errrr rrrr
1425: EBE1 21 0E 00               LD     HL,fcbS2Index
1426: EBE4 19                     ADD    HL,DE
1427: EBE5 7E                     LD     A,(HL)               ; A=XXX? mmmm
1428: EBE6 87                     ADD    A,A
1429: EBE7 87                     ADD    A,A
1430: EBE8 87                     ADD    A,A
1431: EBE9 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1432: EBEA F5                     PUSH   AF
1433: EBEB 80                     ADD    A,B
1434: EBEC 47                     LD     B,A
1435: EBED         ; cy=?, BC = mmmm eeee errr rrrr
1436: EBED F5                     PUSH   AF                   ; possible second carry
1437: EBEE E1                     POP    HL                   ; cy = lsb of L
1438: EBEF 7D                     LD     A,L                  ; cy = lsb of A
1439: EBF0 E1                     POP    HL                   ; cy = lsb of L
1440: EBF1 B5                     OR     L                    ; cy/cy = lsb of A
1441: EBF2 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1442: EBF4 C9                     RET
1443: EBF5         ;-----------------------------------------------------------------
1444: EBF5
1445: EBF5         ;*****************************************************************
1446: EBF5         ;****************** Random I/O Stuff >****************************
1447: EBF5         ;*****************************************************************
1448: EBF5
1449: EBF5
1450: EBF5
1451: EBF5
1452: EBF5         ;*****************************************************************
1453: EBF5         ;********************** Disk  I/O ********************************
1454: EBF5         ;*****************************************************************
1455: EBF5
1456: EBF5         ;reset disk system - initialize to disk 0
1457: EBF5             vResetSystem:                      ; func13 (13 - 0D)	 Reset Disk System
1458: EBF5 21 00 00               LD     HL,0
1459: EBF8 22 0E F5               LD     (ReadOnlyVector),HL
1460: EBFB 22 10 F5               LD     (loggedDisks),HL     ; clear the vectors for R/O and Logged Disks
1461: EBFE AF                     XOR    A                    ; also clear the current disk
1462: EBFF 32 0C F5               LD     (currentDisk),A      ; note that currentUserNumber remains unchanged
1463: EC02 21 80 00               LD     HL,DMABuffer
1464: EC05 22 12 F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = DMABuffer
1465: EC08 CD D1 ED               CALL   SetDataDMA           ; to data dma address
1466: EC0B C3 55 EC               JP     Select
1467: EC0E         ;ret ;jmp goback
1468: EC0E         ;-----------------------------------------------------------------
1469: EC0E         ;select disk in (E) paramDE
1470: EC0E         ; IN - (E) disk number -- 0=A  1=B ...15=P
1471: EC0E             vSelectDisk:                      ; func14 (14 - 0E)	Select Current Disk
1472: EC0E C3 49 EC               JP     SelectCurrent
1473: EC11         ;ret ;jmp goba
1474: EC11         ;-----------------------------------------------------------------
1475: EC11         ;return the login vector
1476: EC11         ;OUT - (HL) loggedDisks
1477: EC11             vGetLoginVector:                      ; func24: (24 - 18) Return login Vector
1478: EC11 2A 10 F5               LD     HL,(loggedDisks)
1479: EC14 22 BD EA               LD     (exitParameterWord),HL
1480: EC17 C9                     RET
1481: EC18         ;-----------------------------------------------------------------
1482: EC18         ;return selected disk number
1483: EC18         ;OUT - A current disk -- 0=A  1=B ...15=P
1484: EC18             vGetCurrentDisk:                      ; func25 (25 - 19)	Get Current Disk
1485: EC18 3A 0C F5               LD     A,(currentDisk)
1486: EC1B 32 BD EA               LD     (exitParameterByte),A
1487: EC1E C9                     RET
1488: EC1F         ;-----------------------------------------------------------------
1489: EC1F         ;set the subsequent dma address to paramDE
1490: EC1F         ;IN - (HL) value to set as DMA
1491: EC1F             vSetDMA:                        ; func26 (25 - 1A) Set Dma Address
1492: EC1F 2A BB EA               LD     HL,(paramDE)
1493: EC22 22 12 F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = paramDE
1494: EC25 C3 D1 ED               JP     SetDataDMA           ; to data dma address
1495: EC28         ;-----------------------------------------------------------------
1496: EC28         ;return the Allocation Vector Address
1497: EC28         ;OUT - (HL) Allocation Vector Address
1498: EC28             vGetAllocAddr:                      ; func27 (27 - 1B) Get Allocation Vector Address
1499: EC28 2A 20 F5               LD     HL,(caAllocVector)
1500: EC2B 22 BD EA               LD     (exitParameterWord),HL
1501: EC2E C9                     RET
1502: EC2F         ;-----------------------------------------------------------------
1503: EC2F         ;;write protect current disk
1504: EC2F             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1505: EC2F C3 D4 EC               JP     SetDiskReadOnly
1506: EC32         ;-----------------------------------------------------------------
1507: EC32         ;return r/o bit vector
1508: EC32         ;OUT - (HL) Read Only Vector Vector
1509: EC32             vGetRoVector:                      ; func29 (29 - 1D)	Get read Only vector
1510: EC32 2A 0E F5               LD     HL,(ReadOnlyVector)
1511: EC35 22 BD EA               LD     (exitParameterWord),HL
1512: EC38 C9                     RET
1513: EC39         ;-----------------------------------------------------------------
1514: EC39         ;;set file Attributes
1515: EC39             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1516: EC39 CD CC F2               CALL   Reselect
1517: EC3C CD 21 EF               CALL   SetAttributes
1518: EC3F C3 B6 F2               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1519: EC42         ;-----------------------------------------------------------------
1520: EC42         ;return address of disk parameter block
1521: EC42         ; OUT - (HL) Disk Parameter Black for current drive
1522: EC42             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1523: EC42 2A 1C F5               LD     HL,(caDiskParamBlock)
1524: EC45 22 BD EA               LD     (exitParameterWord),HL
1525: EC48 C9                     RET
1526: EC49         ;-----------------------------------------------------------------
1527: EC49
1528: EC49             SelectCurrent:                      ; curselect
1529: EC49 3A BA EA               LD     A,(paramE)
1530: EC4C 21 0C F5               LD     HL,currentDisk
1531: EC4F BE                     CP     M
1532: EC50 C8                     RET    Z                    ; exit if parame = Current disk
1533: EC51 77                     LD     (HL),A
1534: EC52 C3 55 EC               JP     Select
1535: EC55         ;*****************************************************************
1536: EC55         ; select Login Drive
1537: EC55             Select:
1538: EC55 2A 10 F5               LD     HL,(loggedDisks)
1539: EC58 3A 0C F5               LD     A,(currentDisk)
1540: EC5B 4F                     LD     C,A
1541: EC5C CD 57 F4               CALL   ShiftRightHLbyC      ; see if we already have drive logged in
1542: EC5F E5                     PUSH   HL                   ; save result
1543: EC60 EB                     EX     DE,HL                ; send to seldsk
1544: EC61 CD 79 EC               CALL   SelectDisk
1545: EC64 E1                     POP    HL                   ; get back logged disk vector
1546: EC65 CC 7B F4               CALL   Z,errSelect
1547: EC68 7D                     LD     A,L                  ; get logged disks
1548: EC69 1F                     RRA
1549: EC6A D8                     RET    C                    ; exit if the disk already logged in
1550: EC6B
1551: EC6B 2A 10 F5               LD     HL,(loggedDisks)     ; else log in a differenet disk
1552: EC6E 4D                     LD     C,L
1553: EC6F 44                     LD     B,H                  ; BC has logged disk
1554: EC70 CD C1 EC               CALL   SetCurrentDiskBit
1555: EC73 22 10 F5               LD     (loggedDisks),HL     ; save result
1556: EC76 C3 EB EC               JP     InitDisk
1557: EC79         ;*****************************************************************
1558: EC79         ; select the disk drive given by currentDisk, and fill the base addresses
1559: EC79         ; caTrack - caAllocVector, then fill the values of the disk parameter block
1560: EC79             SelectDisk:
1561: EC79 3A 0C F5               LD     A,(currentDisk)
1562: EC7C 4F                     LD     C,A                  ; prepare for Bios Call
1563: EC7D CD 1B F6               CALL   bcSeldsk
1564: EC80 7C                     LD     A,H                  ; HL = 0000 if error, otherwise disk headers
1565: EC81 B5                     OR     L
1566: EC82 C8                     RET    Z                    ; exit if error, with Zflag set
1567: EC83 5E                     LD     E,(HL)
1568: EC84 23                     INC    HL
1569: EC85 56                     LD     D,(HL)               ; Disk Header Block pointer in DE
1570: EC86 23                     INC    HL
1571: EC87 22 14 F5               LD     (caDirMaxValue),HL
1572: EC8A 23                     INC    HL
1573: EC8B 23                     INC    HL
1574: EC8C 22 16 F5               LD     (caTrack),HL
1575: EC8F 23                     INC    HL
1576: EC90 23                     INC    HL
1577: EC91 22 18 F5               LD     (caSector),HL
1578: EC94 23                     INC    HL
1579: EC95 23                     INC    HL
1580: EC96 EB                     EX     DE,HL                ; DE points at Directory DMA, HL at Skew Table
1581: EC97 22 31 F5               LD     (caSkewTable),HL
1582: EC9A 21 1A F5               LD     HL,caDirectoryDMA
1583: EC9D 0E 08                  LD     C,caListSize
1584: EC9F CD 6B F4               CALL   Move                 ; finish filling in address list
1585: ECA2
1586: ECA2 2A 1C F5               LD     HL,(caDiskParamBlock)
1587: ECA5 EB                     EX     DE,HL                ; DE is source
1588: ECA6 21 22 F5               LD     HL,dpbStart          ; start of Disk Parameter Block
1589: ECA9 0E 0F                  LD     C,dpbSize
1590: ECAB CD 6B F4               CALL   Move                 ; load the table
1591: ECAE 2A 27 F5               LD     HL,(dpbDSM)          ; max entry number
1592: ECB1 7C                     LD     A,H                  ; if 00 then < 255
1593: ECB2 21 3B F5               LD     HL,single            ; point at the single byte entry flag
1594: ECB5 36 FF                  LD     (HL),TRUE            ; assume its less than 255
1595: ECB7 B7                     OR     A                    ; assumtion confirmed ?
1596: ECB8 CA BD EC               JP     Z,SelectDisk1        ; skip if yes
1597: ECBB 36 00                  LD     (HL),FALSE           ; correct assumption, set falg to false
1598: ECBD
1599: ECBD             SelectDisk1:
1600: ECBD 3E FF                  LD     A,TRUE
1601: ECBF B7                     OR     A                    ; Set Sign, reset Carry and   Zero
1602: ECC0 C9                     RET
1603: ECC1
1604: ECC1         ;---------------
1605: ECC1         ; set a "1" value in currentDisk position of BC
1606: ECC1         ; return in HL
1607: ECC1             SetCurrentDiskBit:
1608: ECC1 C5                     PUSH   BC                   ; save input parameter
1609: ECC2 3A 0C F5               LD     A,(currentDisk)
1610: ECC5 4F                     LD     C,A                  ; ready parameter for shift
1611: ECC6 21 01 00               LD     HL,1                 ; number to shift
1612: ECC9 CD 64 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1613: ECCC C1                     POP    BC                   ; original mask
1614: ECCD 79                     LD     A,C
1615: ECCE B5                     OR     L
1616: ECCF 6F                     LD     L,A
1617: ECD0 78                     LD     A,B
1618: ECD1 B4                     OR     H
1619: ECD2 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1620: ECD3 C9                     RET
1621: ECD4         ;--------------
1622: ECD4         ;set current disk to read only
1623: ECD4             SetDiskReadOnly:
1624: ECD4 21 0E F5               LD     HL,ReadOnlyVector
1625: ECD7 4E                     LD     C,(HL)
1626: ECD8 23                     INC    HL
1627: ECD9 46                     LD     B,(HL)
1628: ECDA CD C1 EC               CALL   SetCurrentDiskBit    ; sets bit to 1
1629: ECDD 22 0E F5               LD     (ReadOnlyVector),HL
1630: ECE0         ; high water mark in directory goes to max
1631: ECE0 2A 29 F5               LD     HL,(dpbDRM)          ; directory max
1632: ECE3 EB                     EX     DE,HL                ; DE = directory max
1633: ECE4 2A 14 F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value
1634: ECE7 73                     LD     (HL),E
1635: ECE8 23                     INC    HL
1636: ECE9 72                     LD     (HL),D               ; cdrmax = dpbDRM
1637: ECEA C9                     RET
1638: ECEB         ;----------------------- initialize the current disk
1639: ECEB         ;
1640: ECEB         ;exitParameterByte = false ;set to true if $ file exists
1641: ECEB         ; compute the length of the allocation vector - 2
1642: ECEB
1643: ECEB             InitDisk:
1644: ECEB 2A 27 F5               LD     HL,(dpbDSM)          ; get max allocation value
1645: ECEE 0E 03                  LD     C,3                  ; we want dpbDSM/8
1646: ECF0         ; number of bytes in alloc vector is (dpbDSM/8)+1
1647: ECF0 CD 57 F4               CALL   ShiftRightHLbyC
1648: ECF3 23                     INC    HL                   ; HL = dpbDSM/8+1
1649: ECF4 44                     LD     B,H
1650: ECF5 4D                     LD     C,L                  ; BC has size of AllocationVector
1651: ECF6 2A 20 F5               LD     HL,(caAllocVector)   ; base of allocation vector
1652: ECF9         ;fill the allocation vector with zeros
1653: ECF9             InitDisk0:
1654: ECF9 36 00                  LD     (HL),0
1655: ECFB 23                     INC    HL                   ; alloc(i)=0
1656: ECFC 0B                     DEC    BC                   ; count length down
1657: ECFD 78                     LD     A,B
1658: ECFE B1                     OR     C
1659: ECFF C2 F9 EC               JP     NZ,InitDisk0
1660: ED02         ; set the reserved space for the directory
1661: ED02 2A 2B F5               LD     HL,(dpbDABM)         ; get the directory block reserved bits
1662: ED05 EB                     EX     DE,HL
1663: ED06 2A 20 F5               LD     HL,(caAllocVector)   ; HL=.alloc()
1664: ED09 73                     LD     (HL),E
1665: ED0A 23                     INC    HL
1666: ED0B 72                     LD     (HL),D               ; sets reserved directory blks
1667: ED0C         ; allocation vector initialized, home disk
1668: ED0C CD B0 ED               CALL   Home
1669: ED0F         ; caDirMaxValue = 3 (scans at least one directory record)
1670: ED0F 2A 14 F5               LD     HL,(caDirMaxValue)
1671: ED12 36 03                  LD     (HL),3
1672: ED14 23                     INC    HL
1673: ED15 36 00                  LD     (HL),0               ; caDirMaxValue = 0003
1674: ED17
1675: ED17 CD CA ED               CALL   SetEndDirectory      ; dirEntryIndex = EOD
1676: ED1A         ; read directory entries and check for allocated storage
1677: ED1A             InitDisk1:
1678: ED1A 0E FF                  LD     C,TRUE
1679: ED1C CD F2 ED               CALL   ReadDirectory
1680: ED1F CD E0 ED               CALL   EndOfDirectory
1681: ED22 C8                     RET    Z                    ; return if end of directory
1682: ED23         ; not end of directory, valid entry?
1683: ED23 CD CC EE               CALL   GetDirElementAddress ; HL = caDirectoryDMA + dirBlockIndex
1684: ED26 3E E5                  LD     A,emptyDir
1685: ED28 BE                     CP     M
1686: ED29 CA 1A ED               JP     Z,InitDisk1          ; go get another item
1687: ED2C         ; not emptyDir, user code the same?
1688: ED2C 3A 0B F5               LD     A,(currentUserNumber)
1689: ED2F BE                     CP     M
1690: ED30 C2 3E ED               JP     NZ,InitDisk2
1691: ED33         ; same user code, check for '$' submit
1692: ED33 23                     INC    HL
1693: ED34 7E                     LD     A,(HL)               ; first character
1694: ED35 D6 24                  SUB    DOLLAR               ; dollar file?
1695: ED37 C2 3E ED               JP     NZ,InitDisk2
1696: ED3A         ; dollar file found, mark in exitParameterByte
1697: ED3A 3D                     DEC    A
1698: ED3B 32 BD EA               LD     (exitParameterByte),A ; exitParameterByte = 255
1699: ED3E             InitDisk2:
1700: ED3E         ; now scan the disk map for allocated blocks
1701: ED3E 0E 01                  LD     C,1                  ; set to allocated
1702: ED40 CD 49 ED               CALL   ScanDiskMap
1703: ED43 CD D5 EE               CALL   SetDirectoryEntry    ; set DirMaxVAlue to dirEntryIndex
1704: ED46 C3 1A ED               JP     InitDisk1            ; for another entry
1705: ED49         ;
1706: ED49         ;-------------Scan the disk map for unallocated entry-----------------------------------
1707: ED49         ; scan the disk map addressed by dptr for non-zero entries.  The allocation
1708: ED49         ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
1709: ED49             ScanDiskMap:
1710: ED49 CD CC EE               CALL   GetDirElementAddress ; HL = buffa + dptr
1711: ED4C         ; HL addresses the beginning of the directory entry
1712: ED4C 11 10 00               LD     DE,fcbDiskMapIndex
1713: ED4F 19                     ADD    HL,DE                ; hl now addresses the disk map
1714: ED50 C5                     PUSH   BC                   ; save the set/reset bit
1715: ED51 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; size of Disk Allocation Map + 1
1716: ED53
1717: ED53             ScanDiskMap0:                      ; loop once for each disk map entry
1718: ED53 D1                     POP    DE                   ; recall the set/reset bit
1719: ED54 0D                     DEC    C
1720: ED55 C8                     RET    Z
1721: ED56
1722: ED56 D5                     PUSH   DE                   ; save the set/reset bit
1723: ED57 3A 3B F5               LD     A,(single)           ; single byte entry flag
1724: ED5A B7                     OR     A
1725: ED5B CA 66 ED               JP     Z,ScanDiskMap1       ; skip if two byte value
1726: ED5E         ; single byte scan operation
1727: ED5E C5                     PUSH   BC                   ; save counter
1728: ED5F E5                     PUSH   HL                   ; save map address
1729: ED60 4E                     LD     C,(HL)
1730: ED61 06 00                  LD     B,0                  ; BC=block#
1731: ED63 C3 6C ED               JP     ScanDiskMap2
1732: ED66         ; two byte scan operation
1733: ED66             ScanDiskMap1:
1734: ED66 0D                     DEC    C                    ; adjust counter for double byte
1735: ED67 C5                     PUSH   BC                   ; save counter
1736: ED68         ;	MOV		C,M
1737: ED68 46                     LD     B,(HL)
1738: ED69 23                     INC    HL
1739: ED6A         ;	MOV		B,M								; BC=block#
1740: ED6A 4E                     LD     C,(HL)               ; BC=block#
1741: ED6B E5                     PUSH   HL                   ; save map address
1742: ED6C             ScanDiskMap2:                      ; arrive here with BC=block#, E=0/1
1743: ED6C 79                     LD     A,C
1744: ED6D B0                     OR     B                    ; skip if = 0000
1745: ED6E C4 9E ED               CALL   NZ,SetAllocBit       ; bit set to 0/1 its in C
1746: ED71 E1                     POP    HL
1747: ED72 23                     INC    HL                   ; to next bit position
1748: ED73 C1                     POP    BC                   ; recall counter
1749: ED74 C3 53 ED               JP     ScanDiskMap0         ; for another item
1750: ED77         ;
1751: ED77         ;-----------------------------------
1752: ED77         ;given allocation vector position BC, return with byte
1753: ED77         ;containing BC shifted so that the least significant
1754: ED77         ;bit is in the low order accumulator position.  HL is
1755: ED77         ;the address of the byte for possible replacement in
1756: ED77         ;memory upon return, and D contains the number of shifts
1757: ED77         ;required to place the returned value back into position
1758: ED77
1759: ED77             GetAllocBit:                      ; getallocbit
1760: ED77 79                     LD     A,C
1761: ED78 E6 07                  AND    111b
1762: ED7A 3C                     INC    A
1763: ED7B 5F                     LD     E,A
1764: ED7C 57                     LD     D,A
1765: ED7D         ; d and e both contain the number of bit positions to shift
1766: ED7D 79                     LD     A,C
1767: ED7E 0F                     RRCA
1768: ED7F 0F                     RRCA
1769: ED80 0F                     RRCA
1770: ED81 E6 1F                  AND    11111b
1771: ED83 4F                     LD     C,A                  ; C shr 3 to C
1772: ED84 78                     LD     A,B
1773: ED85 87                     ADD    A,A
1774: ED86 87                     ADD    A,A
1775: ED87 87                     ADD    A,A
1776: ED88 87                     ADD    A,A
1777: ED89 87                     ADD    A,A                  ; B shl 5
1778: ED8A B1                     OR     C
1779: ED8B 4F                     LD     C,A                  ; bbbccccc to C
1780: ED8C 78                     LD     A,B
1781: ED8D 0F                     RRCA
1782: ED8E 0F                     RRCA
1783: ED8F 0F                     RRCA
1784: ED90 E6 1F                  AND    11111b
1785: ED92 47                     LD     B,A                  ; BC shr 3 to BC
1786: ED93 2A 20 F5               LD     HL,(caAllocVector)   ; base address of allocation vector
1787: ED96 09                     ADD    HL,BC
1788: ED97 7E                     LD     A,(HL)               ; byte to A, hl = .alloc(BC shr 3)
1789: ED98         ;now move the bit to the low order position of A
1790: ED98             GetAllocBitl:
1791: ED98 07                     RLCA
1792: ED99 1D                     DEC    E
1793: ED9A C2 98 ED               JP     NZ,GetAllocBitl
1794: ED9D C9                     RET
1795: ED9E
1796: ED9E         ;-----------------------------------
1797: ED9E         ; BC is the bit position of ALLOC to set or reset.  The
1798: ED9E         ; value of the bit is in register E.
1799: ED9E             SetAllocBit:
1800: ED9E D5                     PUSH   DE
1801: ED9F CD 77 ED               CALL   GetAllocBit          ; shifted val A, count in D
1802: EDA2 E6 FE                  AND    11111110b            ; mask low bit to zero (may be set)
1803: EDA4 C1                     POP    BC
1804: EDA5 B1                     OR     C                    ; low bit of C is masked into A
1805: EDA6 C3 A9 ED               JP     RotateAndReplace     ; to rotate back into proper position
1806: EDA9         ;ret
1807: EDA9         ;-----------------------------------
1808: EDA9         ; byte value from ALLOC is in register A, with shift count
1809: EDA9         ; in register C (to place bit back into position), and
1810: EDA9         ; target ALLOC position in registers HL, rotate and replace
1811: EDA9             RotateAndReplace:
1812: EDA9 0F                     RRCA
1813: EDAA 15                     DEC    D
1814: EDAB C2 A9 ED               JP     NZ,RotateAndReplace  ; back into position
1815: EDAE 77                     LD     (HL),A               ; back to ALLOC
1816: EDAF C9                     RET
1817: EDB0         ;-----------------------------------
1818: EDB0
1819: EDB0         ;move to home position, then offset to start of dir
1820: EDB0             Home:
1821: EDB0 CD 18 F6               CALL   bcHome               ; move to track 00, sector 00 reference
1822: EDB3 21 2F F5               LD     HL,dpbOFF            ; get track ofset at begining
1823: EDB6 4E                     LD     C,(HL)
1824: EDB7 23                     INC    HL
1825: EDB8 46                     LD     B,(HL)
1826: EDB9 CD 1E F6               CALL   bcSettrk             ; select first directory position
1827: EDBC
1828: EDBC AF                     XOR    A                    ; constant zero to accumulator
1829: EDBD 2A 16 F5               LD     HL,(caTrack)
1830: EDC0 77                     LD     (HL),A
1831: EDC1 23                     INC    HL
1832: EDC2 77                     LD     (HL),A               ; curtrk=0000
1833: EDC3 2A 18 F5               LD     HL,(caSector)
1834: EDC6 77                     LD     (HL),A
1835: EDC7 23                     INC    HL
1836: EDC8 77                     LD     (HL),A               ; currec=0000
1837: EDC9 C9                     RET
1838: EDCA
1839: EDCA
1840: EDCA         ;*****************************************************************
1841: EDCA
1842: EDCA         ;*****************************************************************
1843: EDCA         ;*****************************************************************
1844: EDCA         ; set directory counter to end  -1
1845: EDCA             SetEndDirectory:
1846: EDCA 21 FF FF               LD     HL,EOD
1847: EDCD 22 46 F5               LD     (dirEntryIndex),HL
1848: EDD0 C9                     RET
1849: EDD1         ;---------------
1850: EDD1             SetDataDMA:                      ; setdata
1851: EDD1 21 12 F5               LD     HL,InitDAMAddress
1852: EDD4 C3 DA ED               JP     SetDMA               ; to complete the call
1853: EDD7         ;---------------
1854: EDD7             SetDirDMA:                      ; setdir
1855: EDD7 21 1A F5               LD     HL,caDirectoryDMA
1856: EDDA
1857: EDDA             SetDMA:                         ; setdma
1858: EDDA 4E                     LD     C,(HL)
1859: EDDB 23                     INC    HL
1860: EDDC 46                     LD     B,(HL)               ; parameter ready
1861: EDDD C3 24 F6               JP     bcSetdma             ; call bios to set
1862: EDE0         ;---------------
1863: EDE0         ;---------------
1864: EDE0         ; return zero flag if at end of directory
1865: EDE0         ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
1866: EDE0             EndOfDirectory:
1867: EDE0 21 46 F5               LD     HL,dirEntryIndex
1868: EDE3 7E                     LD     A,(HL)               ; may be 0ffh
1869: EDE4 23                     INC    HL
1870: EDE5 BE                     CP     M                    ; low(dirEntryIndex) = high(dirEntryIndex)?
1871: EDE6 C0                     RET    NZ                   ; non zero returned if different
1872: EDE7         ; high and low the same, = 0ffh?
1873: EDE7 3C                     INC    A                    ; 0ffh becomes 00 if so
1874: EDE8 C9                     RET
1875: EDE9         ;---------------
1876: EDE9         ; read a directory entry into the directory buffer
1877: EDE9             ReadDirRecord:
1878: EDE9 CD D7 ED               CALL   SetDirDMA            ; directory dma
1879: EDEC CD 3A F2               CALL   ReadBuffer           ; directory record loaded
1880: EDEF C3 D1 ED               JP     SetDataDMA           ; to data dma address
1881: EDF2         ;ret
1882: EDF2         ;---------------
1883: EDF2         ; read next directory entry, with C=true if initializing
1884: EDF2             ReadDirectory:
1885: EDF2 2A 29 F5               LD     HL,(dpbDRM)
1886: EDF5 EB                     EX     DE,HL                ; determine number of directory entries
1887: EDF6 2A 46 F5               LD     HL,(dirEntryIndex)   ; index into directory
1888: EDF9 23                     INC    HL
1889: EDFA 22 46 F5               LD     (dirEntryIndex),HL   ; initialize directory index
1890: EDFD         ; continue while dpbDRM >= dirEntryIndex (dpbDRM-dirEntryIndex no cy)
1891: EDFD CD 50 F4               CALL   DEminusHL2HL         ; DE-HL - processed all entries ?
1892: EE00 D2 07 EE               JP     NC,ReadDirectory0    ; no - do it again
1893: EE03         ; yes, set dirEntryIndex to end of directory
1894: EE03 CD CA ED               CALL   SetEndDirectory
1895: EE06 C9                     RET
1896: EE07
1897: EE07         ; not at end of directory, seek next element, initialization flag is in C
1898: EE07             ReadDirectory0:
1899: EE07 3A 46 F5               LD     A,(dirEntryIndex)
1900: EE0A E6 03                  AND    dirEntryMask         ; low(dirEntryIndex) and dirEntryMask
1901: EE0C 06 05                  LD     B,fcbShift           ; to multiply by fcb size to get the correct index in dir record
1902: EE0E             ReadDirectory1:
1903: EE0E 87                     ADD    A,A
1904: EE0F 05                     DEC    B
1905: EE10 C2 0E EE               JP     NZ,ReadDirectory1
1906: EE13         ; A = (low(dirEntryIndex) and dirEntryMask) shl fcbShift
1907: EE13 32 45 F5               LD     (dirBlockIndex),A    ; ready for next dir operation
1908: EE16 B7                     OR     A
1909: EE17 C0                     RET    NZ                   ; return if not a new record (Directory Block)
1910: EE18 C5                     PUSH   BC                   ; save initialization flag C
1911: EE19 CD 23 EE               CALL   SeekDir              ; seek$dir seek proper record
1912: EE1C CD E9 ED               CALL   ReadDirRecord        ; read the directory record
1913: EE1F C1                     POP    BC                   ; recall initialization flag
1914: EE20 C3 97 EE               JP     CalculateCheckSum    ; checksum the directory elt
1915: EE23         ;---------
1916: EE23         ;seek the record containing the current dir entry
1917: EE23             SeekDir:
1918: EE23 2A 46 F5               LD     HL,(dirEntryIndex)   ; directory counter to HL
1919: EE26 0E 02                  LD     C,dirEntryShift      ; 4 entries per record
1920: EE28 CD 57 F4               CALL   ShiftRightHLbyC      ; value to HL
1921: EE2B 22 43 F5               LD     (currentBlock),HL
1922: EE2E 22 48 F5               LD     (dirRecord),HL       ; ready for seek
1923: EE31 C3 34 EE               JP     Seek
1924: EE34         ;---------------------------
1925: EE34             Seek:                           ; seek
1926: EE34         ;seek the track given by currentBlock (actual record number)
1927: EE34
1928: EE34 21 43 F5               LD     HL,currentBlock      ; contains the cpm record number
1929: EE37 4E                     LD     C,(HL)               ; Actual Record Number Low
1930: EE38 23                     INC    HL
1931: EE39 46                     LD     B,(HL)               ; Actual Record Number High
1932: EE3A 2A 18 F5               LD     HL,(caSector)        ; Current Sector
1933: EE3D 5E                     LD     E,(HL)               ; Current Sector Number Low
1934: EE3E 23                     INC    HL
1935: EE3F 56                     LD     D,(HL)               ; Current Sector Number High
1936: EE40 2A 16 F5               LD     HL,(caTrack)         ; Current track
1937: EE43 7E                     LD     A,(HL)               ; Current track Number Low - temp
1938: EE44 23                     INC    HL
1939: EE45 66                     LD     H,(HL)               ; Current track Number High
1940: EE46 6F                     LD     L,A                  ; Current track Number Low
1941: EE47         ;(BC) - cpmRecord Number
1942: EE47         ;(DE) - Current Sector
1943: EE47         ;(HL) - Current Track
1944: EE47
1945: EE47         ;loop while currentBlock < currec   ?????
1946: EE47             Seek0:
1947: EE47 79                     LD     A,C                  ;   Current Sector
1948: EE48 93                     SUB    E                    ;
1949: EE49 78                     LD     A,B                  ; - cpmRecord Number
1950: EE4A 9A                     SBC    A,D                  ;
1951: EE4B D2 5D EE               JP     NC,Seek1             ; skip if cpmRecord Number >= Current Sector
1952: EE4E
1953: EE4E E5                     PUSH   HL
1954: EE4F 2A 22 F5               LD     HL,(dpbSPT)
1955: EE52 7B                     LD     A,E
1956: EE53 95                     SUB    L
1957: EE54 5F                     LD     E,A
1958: EE55 7A                     LD     A,D
1959: EE56 9C                     SBC    A,H
1960: EE57 57                     LD     D,A
1961: EE58 E1                     POP    HL
1962: EE59 2B                     DEC    HL
1963: EE5A C3 47 EE               JP     Seek0
1964: EE5D
1965: EE5D             Seek1:
1966: EE5D
1967: EE5D E5                     PUSH   HL                   ; Save Current Track
1968: EE5E 2A 22 F5               LD     HL,(dpbSPT)          ; records per track
1969: EE61 19                     ADD    HL,DE                ; HL = Current Sector + sectorsPerClynder
1970: EE62 79                     LD     A,C                  ;     cpmRecord Number
1971: EE63 95                     SUB    L                    ;
1972: EE64 78                     LD     A,B                  ;  - HL (above)
1973: EE65 9C                     SBC    A,H                  ;
1974: EE66 DA 6F EE               JP     C,Seek2              ; skip if cpmRecord Number > HL (above)
1975: EE69
1976: EE69 EB                     EX     DE,HL
1977: EE6A
1978: EE6A E1                     POP    HL
1979: EE6B 23                     INC    HL
1980: EE6C C3 5D EE               JP     Seek1
1981: EE6F
1982: EE6F             Seek2:
1983: EE6F E1                     POP    HL                   ; retreive Current Track
1984: EE70 C5                     PUSH   BC                   ; save  cpmRecord Number
1985: EE71 D5                     PUSH   DE                   ; save  Current Sector
1986: EE72 E5                     PUSH   HL                   ; save CurrentTrack
1987: EE73         ; stack contains CurrentTrack , Current Sector, cpmRecord Number
1988: EE73 EB                     EX     DE,HL                ; DE => CurrentTrack, HL => Current Sector
1989: EE74 2A 2F F5               LD     HL,(dpbOFF)          ; Block Zero starting Track
1990: EE77 19                     ADD    HL,DE                ; HL =  actual physical Track number
1991: EE78 44                     LD     B,H
1992: EE79 4D                     LD     C,L                  ; BC has physical Track number
1993: EE7A CD 1E F6               CALL   bcSettrk             ; track set up
1994: EE7D         ; note that BC - curtrk is difference to move in bios
1995: EE7D D1                     POP    DE                   ; recall CurrentTrack
1996: EE7E 2A 16 F5               LD     HL,(caTrack)         ; point at current Track
1997: EE81 73                     LD     (HL),E
1998: EE82 23                     INC    HL
1999: EE83 72                     LD     (HL),D               ; current Track updated
2000: EE84         ; now compute sector as currentBlock-currec
2001: EE84 D1                     POP    DE                   ; recall Current Sector
2002: EE85 2A 18 F5               LD     HL,(caSector)        ; point at current Sector
2003: EE88 73                     LD     (HL),E
2004: EE89 23                     INC    HL
2005: EE8A 72                     LD     (HL),D               ; current sector updated / DE has currentSector
2006: EE8B C1                     POP    BC                   ; recall cpmRecord Number
2007: EE8C 79                     LD     A,C                  ; cpmRecord Number
2008: EE8D 93                     SUB    E
2009: EE8E 4F                     LD     C,A                  ; - currentSector
2010: EE8F 78                     LD     A,B
2011: EE90 9A                     SBC    A,D
2012: EE91 47                     LD     B,A                  ; back into BC
2013: EE92 C3 21 F6               JP     bcSetsec             ; sector selected
2014: EE95         ;ret
2015: EE95         ;************* CheckSum *******************************
2016: EE95         ; compute current checksum record
2017: EE95         ; if C = TRUE , update the allocation vector
2018: EE95         ;
2019: EE95         ; or check for = if not dirRecord < dpbCKS ????
2020: EE95
2021: EE95             NewCheckSum:
2022: EE95 0E FF                  LD     C,TRUE
2023: EE97
2024: EE97             CalculateCheckSum:
2025: EE97 2A 48 F5               LD     HL,(dirRecord)
2026: EE9A EB                     EX     DE,HL
2027: EE9B 2A 2D F5               LD     HL,(dpbCKS)          ; size of checksum vector
2028: EE9E CD 50 F4               CALL   DEminusHL2HL         ; DE-HL
2029: EEA1 D0                     RET    NC                   ; skip checksum if past checksum vector size
2030: EEA2 C5                     PUSH   BC                   ; save init flag
2031: EEA3 CD BF EE               CALL   ComputeCheckSum      ; check sum value to A
2032: EEA6 2A 1E F5               LD     HL,(caCheckSum)      ; address of check sum vector
2033: EEA9 EB                     EX     DE,HL
2034: EEAA 2A 48 F5               LD     HL,(dirRecord)       ; value of dirRecord
2035: EEAD 19                     ADD    HL,DE                ; HL = .check(dirRecord)
2036: EEAE C1                     POP    BC                   ; recall true=0ffh or false=00 to C
2037: EEAF 0C                     INC    C                    ; 0ffh produces zero flag
2038: EEB0 CA BD EE               JP     Z,SetNewCheckSum
2039: EEB3         ; not initializing, compare
2040: EEB3 BE                     CP     M                    ; compute$cs=check(dirRecord)?
2041: EEB4 C8                     RET    Z                    ; no message if ok
2042: EEB5         ; possible checksum error, are we beyond the end of the disk?
2043: EEB5 CD DE EE               CALL   StillInDirectory
2044: EEB8 D0                     RET    NC                   ; no message if so
2045: EEB9 CD D4 EC               CALL   SetDiskReadOnly      ; read/only disk set
2046: EEBC C9                     RET
2047: EEBD
2048: EEBD         ;initializing the checksum
2049: EEBD             SetNewCheckSum:
2050: EEBD 77                     LD     (HL),A
2051: EEBE C9                     RET
2052: EEBF         ;------------------
2053: EEBF         ;compute checksum for current directory buffer
2054: EEBF             ComputeCheckSum:
2055: EEBF 0E 80                  LD     C,cpmRecordSize      ; size of directory buffer
2056: EEC1 2A 1A F5               LD     HL,(caDirectoryDMA)  ; current directory buffer
2057: EEC4 AF                     XOR    A                    ; clear checksum value
2058: EEC5             ComputeCheckSum0:
2059: EEC5 86                     ADD    A,(HL)
2060: EEC6 23                     INC    HL
2061: EEC7 0D                     DEC    C                    ; cs=cs+buff(cpmRecordSize-C)
2062: EEC8 C2 C5 EE               JP     NZ,ComputeCheckSum0
2063: EECB C9                     RET                         ; with checksum in A
2064: EECC         ;*****************************************************************
2065: EECC         ; compute the address of a directory element at positon dirBlockIndex in the buffer
2066: EECC             GetDirElementAddress:
2067: EECC 2A 1A F5               LD     HL,(caDirectoryDMA)
2068: EECF 3A 45 F5               LD     A,(dirBlockIndex)
2069: EED2 C3 4B F4               JP     AddAtoHL
2070: EED5         ;---------------------
2071: EED5         ;if not still in directory set max value
2072: EED5             SetDirectoryEntry:
2073: EED5 CD DE EE               CALL   StillInDirectory
2074: EED8 D8                     RET    C
2075: EED9         ; return if yes,otherwise, HL = DirMaxValue+1, DE = directoryCount
2076: EED9
2077: EED9 13                     INC    DE
2078: EEDA 72                     LD     (HL),D
2079: EEDB 2B                     DEC    HL
2080: EEDC 73                     LD     (HL),E
2081: EEDD C9                     RET
2082: EEDE         ; return CY if entry is still in Directory
2083: EEDE             StillInDirectory:
2084: EEDE 2A 46 F5               LD     HL,(dirEntryIndex)
2085: EEE1 EB                     EX     DE,HL                ; DE = directory counter
2086: EEE2 2A 14 F5               LD     HL,(caDirMaxValue)   ; HL=caDirMaxValue
2087: EEE5 7B                     LD     A,E
2088: EEE6 96                     SUB    M                    ; low(dirEntryIndex) - low(cdrmax)
2089: EEE7 23                     INC    HL                   ; HL = .cdrmax+1
2090: EEE8 7A                     LD     A,D
2091: EEE9 9E                     SBC    A,(HL)               ; hi(dirEntryIndex) - hig(cdrmax)
2092: EEEA         ;condition dirEntryIndex - cdrmax  produces cy if cdrmax>dirEntryIndex
2093: EEEA C9                     RET
2094: EEEB         ;---------------------
2095: EEEB         ;compute fcbRCIndex and NEXT_RECORD addresses for get/setfcb
2096: EEEB         ; returns with DE pointing at RC from FCB
2097: EEEB         ;         with HL pointing at Next Record
2098: EEEB             GetFcbAddress:                      ; getfcba
2099: EEEB 2A BB EA               LD     HL,(paramDE)
2100: EEEE 11 0F 00               LD     DE,fcbRCIndex
2101: EEF1 19                     ADD    HL,DE
2102: EEF2 EB                     EX     DE,HL                ; DE=.fcb(fcbRCIndex)
2103: EEF3 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;RATS
2104: EEF6 19                     ADD    HL,DE                ; HL=.fcb(NEXT_RECORD)
2105: EEF7 C9                     RET
2106: EEF8         ;---------------------
2107: EEF8         ;set variables from currently fcb - NEXT_RECORD, RC, EXM
2108: EEF8             SetRecordVars:
2109: EEF8 CD EB EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2110: EEFB 7E                     LD     A,(HL)
2111: EEFC 32 41 F5               LD     (cpmRecord),A        ; cpmRecord=fcb(NEXT_RECORD)
2112: EEFF EB                     EX     DE,HL
2113: EF00 7E                     LD     A,(HL)
2114: EF01 32 3F F5               LD     (fcbRecordCount),A   ; fcbRecordCount=fcb(fcbRCIndex)
2115: EF04 CD C4 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2116: EF07 3A 26 F5               LD     A,(dpbEXM)           ; extent mask to a
2117: EF0A A6                     AND    M                    ; fcb(fcbExtIndex) and dpbEXM
2118: EF0B 32 40 F5               LD     (extentValue),A      ; save extent number
2119: EF0E C9                     RET
2120: EF0F         ;---------------------
2121: EF0F         ;update variables from I/O in  fcb
2122: EF0F             UpdateRecordVars:
2123: EF0F CD EB EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2124: EF12 3A 36 F5               LD     A,(seqReadFlag)
2125: EF15 4F                     LD     C,A                  ; =1 if sequential i/o
2126: EF16 3A 41 F5               LD     A,(cpmRecord)        ; get NEXT_RECORD
2127: EF19 81                     ADD    A,C
2128: EF1A 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=cpmRecord+seqReadFlag
2129: EF1B EB                     EX     DE,HL
2130: EF1C 3A 3F F5               LD     A,(fcbRecordCount)
2131: EF1F 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2132: EF20 C9                     RET
2133: EF21         ;---------------------
2134: EF21         ;set file Attributes for current fcb
2135: EF21             SetAttributes:
2136: EF21 0E 0C                  LD     C,fcbExtIndex
2137: EF23 CD 3C F3               CALL   Search4DirElement    ; through file type
2138: EF26             SetAttributes1:
2139: EF26 CD E0 ED               CALL   EndOfDirectory
2140: EF29 C8                     RET    Z                    ; exit at end of dir
2141: EF2A 0E 00                  LD     C,0
2142: EF2C 1E 0C                  LD     E,fcbExtIndex        ;copy name
2143: EF2E CD FD F3               CALL   CopyDir
2144: EF31 CD 54 F3               CALL   Search4NextDirElement
2145: EF34 C3 26 EF               JP     SetAttributes1
2146: EF37         ;
2147: EF37         ;*****************************************************************
2148: EF37
2149: EF37         ;*****************************************************************
2150: EF37         ;********************** File  Routines ***************************
2151: EF37         ;*****************************************************************
2152: EF37         ;open file
2153: EF37         ; IN  - (DE)	FCB Address
2154: EF37         ; OUT - (A)	Directory Code
2155: EF37         ;	0-3 = success ; 0FFH = File Not Found
2156: EF37             vOpenFile:                      ;
2157: EF37 CD BD F2               CALL   ClearModuleNum       ; clear the module number
2158: EF3A CD CC F2               CALL   Reselect             ; do we need to reselect disk?
2159: EF3D C3 F9 F2               JP     OpenFile
2160: EF40         ;ret ;jmp goback
2161: EF40         ;-----------------------------------------------------------------
2162: EF40         ;close file
2163: EF40             vCloseFile:                      ; func16: (16 - 10) Close File
2164: EF40 CD CC F2               CALL   Reselect
2165: EF43 C3 A1 F1               JP     CloseDirEntry
2166: EF46         ;-----------------------------------------------------------------
2167: EF46         ;search for first occurrence of a file
2168: EF46         ; In - (DE)	FCB Address
2169: EF46         ; OUT - (A)	Directory Code
2170: EF46         ;	0-3 = success ; 0FFH = File Not Found
2171: EF46             vFindFirst:                      ; func17: (17 - 11) Search for first
2172: EF46 0E 00                  LD     C,0                  ; length assuming '?' true
2173: EF48 2A BB EA               LD     HL,(paramDE)
2174: EF4B 7E                     LD     A,(HL)
2175: EF4C FE 3F                  CP     QMARK                ; no reselect if ?
2176: EF4E CA 59 EF               JP     Z,QMarkSelect        ; skip reselect if so
2177: EF51
2178: EF51 CD BD F2               CALL   ClearModuleNum       ; module number zeroed
2179: EF54 CD CC F2               CALL   Reselect
2180: EF57 0E 0F                  LD     C,nameLength
2181: EF59             QMarkSelect:                      ; qselect:
2182: EF59 CD 3C F3               CALL   Search4DirElement
2183: EF5C C3 EA F3               JP     CopyDirEntryToUser   ; copy directory entry to user
2184: EF5F         ;-----------------------------------------------------------------
2185: EF5F         ;search for next occurrence of a file name
2186: EF5F         ; OUT - (A)	Directory Code
2187: EF5F         ;	0-3 = success ; 0FFH = File Not Found
2188: EF5F             vFindNext:                      ; func18: (18 - 12) Search for next
2189: EF5F 2A 39 F5               LD     HL,(searchAddress)
2190: EF62 22 BB EA               LD     (paramDE),HL
2191: EF65 CD CC F2               CALL   Reselect
2192: EF68 CD 54 F3               CALL   Search4NextDirElement
2193: EF6B C3 EA F3               JP     CopyDirEntryToUser   ; copy directory entry to user
2194: EF6E         ;-----------------------------------------------------------------
2195: EF6E         ;search for next occurrence of a file name
2196: EF6E         ; OUT - (A)	Directory Code
2197: EF6E         ;delete a file
2198: EF6E             vDeleteFile:                      ; func18: (19 - 13) Delete File
2199: EF6E CD CC F2               CALL   Reselect
2200: EF71 CD 7F F1               CALL   DeleteFile
2201: EF74 C3 B6 F2               JP     DirLocationToReturnLoc
2202: EF77         ;-----------------------------------------------------------------
2203: EF77         ;read sequential
2204: EF77         ;IN  - (DE) FCB address
2205: EF77         ;OUT - (A) 00 = success and data available. else no read and no data
2206: EF77             vReadSeq:                       ; func20: (20 - 14) read sequential
2207: EF77 CD CC F2               CALL   Reselect
2208: EF7A CD B9 EF               CALL   ReadSeq
2209: EF7D C9                     RET
2210: EF7E         ;-----------------------------------------------------------------
2211: EF7E         ;write sequential
2212: EF7E         ;IN  - (DE) FCB address
2213: EF7E         ;OUT - (A) 00 = success and data available. else no read and no data
2214: EF7E             vWriteSeq:                      ; func21 (21 - 15) write sequention
2215: EF7E CD CC F2               CALL   Reselect
2216: EF81 CD FC EF               CALL   DiskWriteSeq
2217: EF84 C9                     RET
2218: EF85         ;-----------------------------------------------------------------
2219: EF85         ; Make file
2220: EF85         ; In - (DE)	FCB Address
2221: EF85         ; OUT - (A)	Directory Code
2222: EF85         ;	0-3 = success ; 0FFH = File Not Found
2223: EF85             vMakeFile:                      ; func22 (22 - 16) Make file
2224: EF85 CD BD F2               CALL   ClearModuleNum       ; set S2 to Zero
2225: EF88 CD CC F2               CALL   Reselect
2226: EF8B C3 49 F1               JP     MakeNewFile
2227: EF8E         ;-----------------------------------------------------------------
2228: EF8E         ; Rename file
2229: EF8E         ; In - (DE)	FCB Address
2230: EF8E         ; OUT - (A)	Directory Code
2231: EF8E         ;	0-3 = success ; 0FFH = File Not Found
2232: EF8E             vRenameFile:                      ; func23 (23 - 17) Rename File
2233: EF8E CD CC F2               CALL   Reselect
2234: EF91 CD 24 F1               CALL   Rename
2235: EF94 C3 B6 F2               JP     DirLocationToReturnLoc
2236: EF97         ;-----------------------------------------------------------------
2237: EF97         ;-----------------------------------------------------------------
2238: EF97         ;*****************************************************************
2239: EF97         ;-----------------------------------------------------------------
2240: EF97         ;check current directory element for read/only status
2241: EF97             CheckRODirectory:
2242: EF97 CD CC EE               CALL   GetDirElementAddress ; address of element
2243: EF9A         ;	JMP	CheckROFile
2244: EF9A         ;------------
2245: EF9A         ;check current buff(dptr) or fcb(0) for r/o status
2246: EF9A             CheckROFile:
2247: EF9A 11 09 00               LD     DE,fcbROfileIndex
2248: EF9D 19                     ADD    HL,DE                ; offset to ro bit
2249: EF9E 7E                     LD     A,(HL)
2250: EF9F 17                     RLA
2251: EFA0 D0                     RET    NC                   ; return if not set
2252: EFA1 C3 87 F4               JP     errReadOnlyFile      ; exit to read only disk message
2253: EFA4         ;-----------------------------------------------------------------
2254: EFA4         ;check for write protected disk
2255: EFA4             CheckWrite:
2256: EFA4 CD AB EF               CALL   DoNotWrite
2257: EFA7 C8                     RET    Z                    ; ok to write if not rodsk
2258: EFA8 C3 81 F4               JP     errReadOnlyDisk      ; read only disk error
2259: EFAB         ;-----------------------------------------------------------------
2260: EFAB         ;return true if dir checksum difference occurred
2261: EFAB             DoNotWrite:
2262: EFAB 2A 0E F5               LD     HL,(ReadOnlyVector)
2263: EFAE 3A 0C F5               LD     A,(currentDisk)
2264: EFB1 4F                     LD     C,A
2265: EFB2 CD 57 F4               CALL   ShiftRightHLbyC
2266: EFB5 7D                     LD     A,L
2267: EFB6 E6 1B                  AND    1BH                  ; 01BH
2268: EFB8 C9                     RET                         ; non zero if nowrite
2269: EFB9         ;-----------------------------------------------------------------
2270: EFB9         ;sequential disk read operation
2271: EFB9             ReadSeq:
2272: EFB9 3E 01                  LD     A,1
2273: EFBB 32 36 F5               LD     (seqReadFlag),A      ; set flag for seqential read
2274: EFBE         ;---
2275: EFBE         ; read the disk
2276: EFBE         ; read the next record from the current fcb
2277: EFBE             DiskRead:
2278: EFBE 3E FF                  LD     A,TRUE
2279: EFC0 32 34 F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
2280: EFC3
2281: EFC3 CD F8 EE               CALL   SetRecordVars        ; sets cpmRecord, fcbRecordCount and EXM
2282: EFC6 3A 41 F5               LD     A,(cpmRecord)
2283: EFC9 21 3F F5               LD     HL,fcbRecordCount
2284: EFCC BE                     CP     M                    ; cpmRecord-fcbRecordCount
2285: EFCD         ; skip if  cpmRecord < fcbRecordCount
2286: EFCD DA E3 EF               JP     C,RecordOK
2287: EFD0         ; not enough records in the extent
2288: EFD0 FE 80                  CP     RecordsPerExtent     ; cpmRecord = 128?   *** Records in an Extent
2289: EFD2 C2 F9 EF               JP     NZ,DiskEOF           ; skip if cpmRecord<>128
2290: EFD5 CD C1 F0               CALL   OpenNextExt          ; go to next extent if so
2291: EFD8 AF                     XOR    A
2292: EFD9 32 41 F5               LD     (cpmRecord),A        ; cpmRecord=00
2293: EFDC         ; now check for open ok
2294: EFDC 3A BD EA               LD     A,(exitParameterByte)
2295: EFDF B7                     OR     A
2296: EFE0 C2 F9 EF               JP     NZ,DiskEOF
2297: EFE3         ; stop at eof
2298: EFE3         ; arrive with fcb addressing a record to read
2299: EFE3             RecordOK:                       ; recordok:
2300: EFE3 CD 8A F2               CALL   GetBlockNumber       ; save it in currentBlock
2301: EFE6 CD 97 F2               CALL   IsAllocated          ; currentBlock=0000?
2302: EFE9 CA F9 EF               JP     Z,DiskEOF            ; get out if not allocated already
2303: EFEC
2304: EFEC CD 9D F2               CALL   SetActualRecordAdd   ; currentBlock now a record value
2305: EFEF CD 34 EE               CALL   Seek                 ; to proper track,sector
2306: EFF2 CD 3A F2               CALL   ReadBuffer           ; to dma address
2307: EFF5 CD 0F EF               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
2308: EFF8 C9                     RET
2309: EFF9             DiskEOF:                        ; diskeof:
2310: EFF9 C3 D3 F3               JP     SetLowReturnTo1      ; exitParameterByte = 1
2311: EFFC         ;ret
2312: EFFC         ;-----------------------------------------------------------------
2313: EFFC         ;sequential disk write
2314: EFFC             DiskWriteSeq:
2315: EFFC 3E 01                  LD     A,1
2316: EFFE 32 36 F5               LD     (seqReadFlag),A
2317: F001         ;--------
2318: F001         ;disk write
2319: F001             DiskWrite:
2320: F001 3E 00                  LD     A,FALSE
2321: F003 32 34 F5               LD     (readModeFlag),A
2322: F006         ; write record to currently selected file
2323: F006 CD A4 EF               CALL   CheckWrite           ; in case write protected
2324: F009 2A BB EA               LD     HL,(paramDE)         ; HL = .fcb(0)
2325: F00C CD 9A EF               CALL   CheckROFile          ; may be a read-only file
2326: F00F CD F8 EE               CALL   SetRecordVars        ; set local Record parameters
2327: F012 3A 41 F5               LD     A,(cpmRecord)
2328: F015 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
2329: F017 DA 1E F0               JP     C,DiskWrite1         ; skip if in the same Extent
2330: F01A CD D3 F3               CALL   SetLowReturnTo1
2331: F01D C9                     RET                         ; Exit ???????????
2332: F01E
2333: F01E         ; can write the next record, so continue
2334: F01E             DiskWrite1:
2335: F01E CD 8A F2               CALL   GetBlockNumber       ; sets up actual block number
2336: F021 CD 97 F2               CALL   IsAllocated
2337: F024 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
2338: F026 C2 71 F0               JP     NZ,DiskWrite3
2339: F029         ; not allocated -
2340: F029         ; the argument to getblock is the starting position for the disk search
2341: F029         ; and should be the last allocated block for this file,
2342: F029         ; or the value 0 if no space has been allocated
2343: F029
2344: F029 CD 12 F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
2345: F02C 32 37 F5               LD     (diskMapIndex),A     ; save for later
2346: F02F 01 00 00               LD     BC,0000h             ; may use block zero
2347: F032 B7                     OR     A
2348: F033 CA 3D F0               JP     Z,FirstBlock         ; skip if no previous block
2349: F036         ; previous block exists
2350: F036 4F                     LD     C,A
2351: F037 0B                     DEC    BC                   ; previous block # in BC
2352: F038 CD 32 F4               CALL   GetDiskMapValue      ; previous block # to HL
2353: F03B 44                     LD     B,H
2354: F03C 4D                     LD     C,L                  ; BC=prev block#
2355: F03D         ; BC = 0000, or previous block #
2356: F03D             FirstBlock:
2357: F03D CD 50 F2               CALL   GetClosestBlock      ; block # to HL
2358: F040         ; arrive here with block# or zero
2359: F040 7D                     LD     A,L
2360: F041 B4                     OR     H
2361: F042 C2 4B F0               JP     NZ,BlockOK
2362: F045         ; cannot find a block to allocate
2363: F045 3E 02                  LD     A,2
2364: F047 32 BD EA               LD     (exitParameterByte),A
2365: F04A C9                     RET                         ; exitParameterByte=2
2366: F04B
2367: F04B             BlockOK:
2368: F04B 22 43 F5               LD     (currentBlock),HL    ; allocated block number is in HL
2369: F04E EB                     EX     DE,HL                ; block number to DE
2370: F04F 2A BB EA               LD     HL,(paramDE)
2371: F052 01 10 00               LD     BC,fcbDiskMapIndex
2372: F055 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
2373: F056 3A 3B F5               LD     A,(single)
2374: F059 B7                     OR     A                    ; set flags for single byte dm
2375: F05A 3A 37 F5               LD     A,(diskMapIndex)     ; recall dm index
2376: F05D CA 67 F0               JP     Z,Allocate16Bit      ; skip if allocating word
2377: F060         ; else allocate using a byte value
2378: F060 CD 4B F4               CALL   AddAtoHL
2379: F063 73                     LD     (HL),E               ; single byte alloc
2380: F064 C3 6F F0               JP     DiskWrite2           ; to continue
2381: F067
2382: F067             Allocate16Bit:                      ; allocate a word value
2383: F067
2384: F067 4F                     LD     C,A
2385: F068 06 00                  LD     B,0                  ; double(diskMapIndex)
2386: F06A 09                     ADD    HL,BC
2387: F06B 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
2388: F06C 72                     LD     (HL),D
2389: F06D 23                     INC    HL
2390: F06E 73                     LD     (HL),E               ; double wd
2391: F06F         ; disk write to previously unallocated block
2392: F06F             DiskWrite2:
2393: F06F 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
2394: F071
2395: F071         ; continue the write operation of no allocation error
2396: F071         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
2397: F071
2398: F071             DiskWrite3:
2399: F071 3A BD EA               LD     A,(exitParameterByte)
2400: F074 B7                     OR     A
2401: F075 C0                     RET    NZ                   ; stop if non zero returned value
2402: F076
2403: F076 C5                     PUSH   BC                   ; save write flag ( in C see above)
2404: F077 CD 9D F2               CALL   SetActualRecordAdd   ; currentBlock set to actual record number
2405: F07A CD 34 EE               CALL   Seek                 ; to proper file position
2406: F07D C1                     POP    BC                   ; get write flag
2407: F07E C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
2408: F07F CD 32 F2               CALL   WriteBuffer          ; written to disk
2409: F082 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
2410: F083         ; increment record count if fcbRecordCount<=cpmRecord
2411: F083 3A 41 F5               LD     A,(cpmRecord)
2412: F086 21 3F F5               LD     HL,fcbRecordCount
2413: F089 BE                     CP     M                    ; cpmRecord-fcbRecordCount
2414: F08A DA 91 F0               JP     C,DiskWrite4
2415: F08D         ; fcbRecordCount <= cpmRecord
2416: F08D 77                     LD     (HL),A
2417: F08E 34                     INC    M                    ; fcbRecordCount = cpmRecord+1
2418: F08F 0E 02                  LD     C,2                  ; mark as record count incremented
2419: F091             DiskWrite4:
2420: F091         ; A has cpmRecord, C=2 if new block or new record#
2421: F091 0D                     DEC    C
2422: F092 0D                     DEC    C
2423: F093 C2 9E F0               JP     NZ,DiskWrite5
2424: F096 F5                     PUSH   AF                   ; save cpmRecord value
2425: F097 CD C3 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2426: F09A         ; reset the file write flag to mark as written fcb
2427: F09A E6 7F                  AND    7FH                  ; not writeFlagMask
2428: F09C 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2429: F09D F1                     POP    AF                   ; restore cpmRecord
2430: F09E             DiskWrite5:
2431: F09E         ; check for end of extent, if found attempt to open next extent in preparation for next write
2432: F09E FE 7F                  CP     highestRecordNumber  ; cpmRecord=highestRecordNumber?
2433: F0A0 C2 BE F0               JP     NZ,DiskWrite7        ; skip if not
2434: F0A3         ; may be random access write, if so we are done
2435: F0A3 3A 36 F5               LD     A,(seqReadFlag)
2436: F0A6 B7                     OR     A
2437: F0A7 CA BE F0               JP     Z,DiskWrite7         ; skip next extent open op
2438: F0AA         ; update current fcb before going to next extent
2439: F0AA CD 0F EF               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2440: F0AD CD C1 F0               CALL   OpenNextExt          ; readModeFlag=false
2441: F0B0         ; cpmRecord remains at highestRecordNumber causing eof if no more directory space is available
2442: F0B0 21 BD EA               LD     HL,exitParameterByte
2443: F0B3 7E                     LD     A,(HL)
2444: F0B4 B7                     OR     A
2445: F0B5 C2 BC F0               JP     NZ,DiskWrite6        ; no space
2446: F0B8         ; space available, set cpmRecord=255
2447: F0B8 3D                     DEC    A
2448: F0B9 32 41 F5               LD     (cpmRecord),A        ; goes to 00 next time
2449: F0BC             DiskWrite6:
2450: F0BC 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
2451: F0BE             DiskWrite7:
2452: F0BE C3 0F EF               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2453: F0C1         ;ret
2454: F0C1         ;-----------------------------------------------------------------
2455: F0C1         ;close the current extent  and open the next one if possible.
2456: F0C1         ;readModeFlag is true if in read mode
2457: F0C1             OpenNextExt:                      ; open$reel
2458: F0C1 AF                     XOR    A
2459: F0C2 32 33 F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
2460: F0C5 CD A1 F1               CALL   CloseDirEntry        ; close current extent
2461: F0C8         ; exitParameterByte remains at enddir if we cannot open the next ext
2462: F0C8 CD E0 ED               CALL   EndOfDirectory
2463: F0CB C8                     RET    Z                    ; return if end
2464: F0CC 2A BB EA               LD     HL,(paramDE)         ; increment extent number
2465: F0CF 01 0C 00               LD     BC,fcbExtIndex
2466: F0D2 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
2467: F0D3 7E                     LD     A,(HL)
2468: F0D4 3C                     INC    A
2469: F0D5 E6 1F                  AND    maxExtValue
2470: F0D7 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
2471: F0D8 CA EA F0               JP     Z,OpenNextModule     ; move to next module if zero
2472: F0DB         ; may be in the same extent group
2473: F0DB 47                     LD     B,A
2474: F0DC 3A 26 F5               LD     A,(dpbEXM)
2475: F0DF A0                     AND    B
2476: F0E0         ; if result is zero, then not in the same group
2477: F0E0 21 33 F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
2478: F0E3 A6                     AND    M                    ; produces a 00 in accumulator if not written
2479: F0E4 CA F5 F0               JP     Z,OpenNextExt1       ; go to next physical extent
2480: F0E7         ; result is non zero, so we must be in same logical ext
2481: F0E7 C3 13 F1               JP     OpenNextExt2         ; to copy fcb information
2482: F0EA         ; extent number overflow, go to next module
2483: F0EA
2484: F0EA             OpenNextModule:
2485: F0EA 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
2486: F0ED 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
2487: F0EE 34                     INC    M                    ; fcb(fcbS2Index)=++1
2488: F0EF         ; module number incremented, check for overflow
2489: F0EF 7E                     LD     A,(HL)
2490: F0F0 E6 0F                  AND    moduleMask           ; mask high order bits
2491: F0F2 CA 1E F1               JP     Z,OpenNextExtError   ; cannot overflow to zero
2492: F0F5         ; otherwise, ok to continue with new module
2493: F0F5
2494: F0F5             OpenNextExt1:
2495: F0F5 0E 0F                  LD     C,nameLength
2496: F0F7 CD 3C F3               CALL   Search4DirElement    ; next extent found?
2497: F0FA CD E0 ED               CALL   EndOfDirectory
2498: F0FD C2 13 F1               JP     NZ,OpenNextExt2
2499: F100         ; end of file encountered
2500: F100 3A 34 F5               LD     A,(readModeFlag)
2501: F103 3C                     INC    A                    ; 0ffh becomes 00 if read
2502: F104 CA 1E F1               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
2503: F107         ; try to extend the current file
2504: F107 CD 49 F1               CALL   MakeNewFile
2505: F10A         ; cannot be end of directory
2506: F10A CD E0 ED               CALL   EndOfDirectory
2507: F10D CA 1E F1               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
2508: F110 C3 16 F1               JP     OpenNextExt3
2509: F113
2510: F113         ; not end of file, open
2511: F113             OpenNextExt2:
2512: F113 CD 02 F3               CALL   OpenFileCopyFCB
2513: F116             OpenNextExt3:
2514: F116 CD F8 EE               CALL   SetRecordVars        ; Set Record parameters
2515: F119 AF                     XOR    A
2516: F11A 32 BD EA               LD     (exitParameterByte),A ; exitParameterByte = 0
2517: F11D C9                     RET                         ; with exitParameterByte = 0
2518: F11E
2519: F11E         ; cannot move to next extent of this file
2520: F11E             OpenNextExtError:
2521: F11E CD D3 F3               CALL   SetLowReturnTo1      ; exitParameterByte = 1
2522: F121 C3 CC F3               JP     SetFileWriteFlag     ; ensure that it will not be closed
2523: F124         ;-----------------------------------------------------------------
2524: F124         ;rename the file described by the first half of the currently addressed FCB.
2525: F124         ;the new name is contained in the last half of the FCB. The file name and type
2526: F124         ;are changed, but the reel number is ignored.  the user number is identical
2527: F124             Rename:
2528: F124 CD A4 EF               CALL   CheckWrite           ; may be write protected
2529: F127         ; search up to the extent field
2530: F127 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
2531: F129 CD 3C F3               CALL   Search4DirElement
2532: F12C         ; copy position 0
2533: F12C 2A BB EA               LD     HL,(paramDE)
2534: F12F 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
2535: F130 11 10 00               LD     DE,fcbDiskMapIndex
2536: F133 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
2537: F134 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
2538: F135         ; assume the same disk drive for new named file
2539: F135             Rename1:
2540: F135 CD E0 ED               CALL   EndOfDirectory
2541: F138 C8                     RET    Z                    ; stop at end of dir
2542: F139         ; not end of directory, rename next element
2543: F139 CD 97 EF               CALL   CheckRODirectory     ; may be read-only file
2544: F13C 0E 10                  LD     C,fcbDiskMapIndex
2545: F13E 1E 0C                  LD     E,fcbExtIndex
2546: F140 CD FD F3               CALL   CopyDir
2547: F143         ; element renamed, move to next
2548: F143 CD 54 F3               CALL   Search4NextDirElement
2549: F146 C3 35 F1               JP     Rename1
2550: F149         ;-----------------------------------------------------------------
2551: F149         ;create a new file by creating a directory entry then opening the file
2552: F149             MakeNewFile:
2553: F149 CD A4 EF               CALL   CheckWrite           ; may be write protected
2554: F14C 2A BB EA               LD     HL,(paramDE)
2555: F14F E5                     PUSH   HL                   ; save fcb address, look for e5
2556: F150 21 0D F5               LD     HL,emptyFCB
2557: F153 22 BB EA               LD     (paramDE),HL         ; paramDE = .empty
2558: F156 0E 01                  LD     C,1
2559: F158 CD 3C F3               CALL   Search4DirElement    ; length 1 match on empty entry
2560: F15B CD E0 ED               CALL   EndOfDirectory       ; zero flag set if no space
2561: F15E E1                     POP    HL                   ; recall paramDE address
2562: F15F 22 BB EA               LD     (paramDE),HL         ; in case we return here
2563: F162 C8                     RET    Z                    ; return with error condition 255 if not found
2564: F163 EB                     EX     DE,HL                ; DE = paramDE address
2565: F164         ; clear the remainder of the fcb
2566: F164 21 0F 00               LD     HL,nameLength
2567: F167 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
2568: F168 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
2569: F16A AF                     XOR    A                    ; clear accumulator to 00 for fill
2570: F16B             MakeNewFile1:
2571: F16B 77                     LD     (HL),A
2572: F16C 23                     INC    HL
2573: F16D 0D                     DEC    C
2574: F16E C2 6B F1               JP     NZ,MakeNewFile1
2575: F171 21 0D 00               LD     HL,fcbS1Index
2576: F174 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
2577: F175 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
2578: F176 CD D5 EE               CALL   SetDirectoryEntry    ; may have extended the directory
2579: F179         ; now copy entry to the directory
2580: F179 CD F6 F3               CALL   CopyFCB
2581: F17C         ; and set the file write flag to "1"
2582: F17C C3 CC F3               JP     SetFileWriteFlag
2583: F17F         ;-----------------------------------------------------------------
2584: F17F         ;delete the currently addressed file
2585: F17F             DeleteFile:
2586: F17F CD A4 EF               CALL   CheckWrite           ; write protected ?
2587: F182 0E 0C                  LD     C,fcbExtIndex        ; extent number field
2588: F184 CD 3C F3               CALL   Search4DirElement    ; search through file type
2589: F187             DeleteFile1:
2590: F187         ; loop while directory matches
2591: F187 CD E0 ED               CALL   EndOfDirectory
2592: F18A C8                     RET    Z                    ; exit if end
2593: F18B         ; set each non zero disk map entry to 0 in the allocation vector
2594: F18B CD 97 EF               CALL   CheckRODirectory     ; ro disk error if found
2595: F18E CD CC EE               CALL   GetDirElementAddress ; HL=.buff(dptr)
2596: F191 36 E5                  LD     (HL),emptyDir
2597: F193 0E 00                  LD     C,0
2598: F195 CD 49 ED               CALL   ScanDiskMap          ; alloc elts set to 0
2599: F198 CD 24 F2               CALL   WriteDir             ; write the directory
2600: F19B CD 54 F3               CALL   Search4NextDirElement ; to next element
2601: F19E C3 87 F1               JP     DeleteFile1          ; for another record
2602: F1A1         ;-----------------------------------------------------------------
2603: F1A1         ;locate the directory element and re-write it
2604: F1A1             CloseDirEntry:
2605: F1A1 AF                     XOR    A
2606: F1A2 32 BD EA               LD     (exitParameterByte),A
2607: F1A5 CD AB EF               CALL   DoNotWrite           ; return TRUE (0) if checksum change
2608: F1A8 C0                     RET    NZ                   ; skip close if r/o disk
2609: F1A9         ; check file write flag - 0 indicates written
2610: F1A9 CD C3 F2               CALL   GetModuleNum         ; fcb(fcbS2Index) in A
2611: F1AC E6 80                  AND    writeFlagMask
2612: F1AE C0                     RET    NZ                   ; return if bit remains set
2613: F1AF 0E 0F                  LD     C,nameLength
2614: F1B1 CD 3C F3               CALL   Search4DirElement    ; locate file
2615: F1B4 CD E0 ED               CALL   EndOfDirectory
2616: F1B7 C8                     RET    Z                    ; return if not found
2617: F1B8         ; merge the disk map at paramDE with that at buff(dptr)
2618: F1B8 01 10 00               LD     BC,fcbDiskMapIndex
2619: F1BB CD CC EE               CALL   GetDirElementAddress
2620: F1BE 09                     ADD    HL,BC
2621: F1BF EB                     EX     DE,HL                ; DE is .buff(dptr+16)
2622: F1C0 2A BB EA               LD     HL,(paramDE)
2623: F1C3 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
2624: F1C4 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of single byte dm
2625: F1C6             CloseDirEntry1:
2626: F1C6 3A 3B F5               LD     A,(single)
2627: F1C9 B7                     OR     A
2628: F1CA CA E1 F1               JP     Z,CloseDirEntry4     ; skip to double
2629: F1CD         ; this is a single byte map
2630: F1CD         ; if fcb(i) = 0 then fcb(i) = buff(i)
2631: F1CD         ; if buff(i) = 0 then buff(i) = fcb(i)
2632: F1CD         ; if fcb(i) <> buff(i) then error
2633: F1CD 7E                     LD     A,(HL)
2634: F1CE B7                     OR     A
2635: F1CF 1A                     LD     A,(DE)
2636: F1D0 C2 D4 F1               JP     NZ,CloseDirEntry2
2637: F1D3         ; fcb(i) = 0
2638: F1D3 77                     LD     (HL),A               ; fcb(i) = buff(i)
2639: F1D4             CloseDirEntry2:
2640: F1D4 B7                     OR     A
2641: F1D5 C2 DA F1               JP     NZ,CloseDirEntry3
2642: F1D8         ; buff(i) = 0
2643: F1D8 7E                     LD     A,(HL)
2644: F1D9 12                     LD     (DE),AE              ; buff(i)=fcb(i)
2645: F1DA             CloseDirEntry3:
2646: F1DA BE                     CP     M
2647: F1DB C2 19 F2               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
2648: F1DE C3 F6 F1               JP     CloseDirEntry5       ; if merge ok
2649: F1E1
2650: F1E1         ; this is a double byte merge operation
2651: F1E1             CloseDirEntry4:
2652: F1E1 CD 42 F2               CALL   Merge                ; buff = fcb if buff 0000
2653: F1E4 EB                     EX     DE,HL
2654: F1E5 CD 42 F2               CALL   Merge
2655: F1E8 EB                     EX     DE,HL                ; fcb = buff if fcb 0000
2656: F1E9         ; they should be identical at this point
2657: F1E9 1A                     LD     A,(DE)
2658: F1EA BE                     CP     M
2659: F1EB C2 19 F2               JP     NZ,CloseDirEntryError ; low same?
2660: F1EE 13                     INC    DE
2661: F1EF 23                     INC    HL                   ; to high byte
2662: F1F0 1A                     LD     A,(DE)
2663: F1F1 BE                     CP     M
2664: F1F2 C2 19 F2               JP     NZ,CloseDirEntryError ; high same?
2665: F1F5         ;	merge operation ok for this pair
2666: F1F5 0D                     DEC    C                    ; extra count for double byte
2667: F1F6             CloseDirEntry5:
2668: F1F6 13                     INC    DE
2669: F1F7 23                     INC    HL                   ; to next byte position
2670: F1F8 0D                     DEC    C
2671: F1F9 C2 C6 F1               JP     NZ,CloseDirEntry1    ; for more
2672: F1FC         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
2673: F1FC 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
2674: F1FF 09                     ADD    HL,BC
2675: F200 EB                     EX     DE,HL
2676: F201 09                     ADD    HL,BC
2677: F202         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
2678: F202 1A                     LD     A,(DE)               ; current user extent number
2679: F203         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
2680: F203 BE                     CP     M
2681: F204 DA 10 F2               JP     C,CloseDirEntryEnd
2682: F207         ; fcb extent number >= dir extent number
2683: F207 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
2684: F208         ; update directory record count field
2685: F208 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
2686: F20B 09                     ADD    HL,BC
2687: F20C EB                     EX     DE,HL
2688: F20D 09                     ADD    HL,BC
2689: F20E         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
2690: F20E 7E                     LD     A,(HL)
2691: F20F 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
2692: F210             CloseDirEntryEnd:
2693: F210 3E FF                  LD     A,TRUE
2694: F212 32 33 F5               LD     (fcbCopiedFlag),A    ; mark as copied
2695: F215 CD 1E F2               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
2696: F218 C9                     RET
2697: F219
2698: F219         ; elements did not merge correctly
2699: F219             CloseDirEntryError:
2700: F219 21 BD EA               LD     HL,exitParameterByte
2701: F21C 35                     DEC    M                    ; =255 non zero flag set
2702: F21D C9                     RET
2703: F21E         ;-----------------------------------------------------------------
2704: F21E         ;enter from CloseDirEntry to seek and copy current element
2705: F21E             SeekCopy:
2706: F21E CD 23 EE               CALL   SeekDir              ; to the directory element
2707: F221 C3 24 F2               JP     WriteDir             ; write the directory element
2708: F224         ;ret
2709: F224         ;-----------------------------------------------------------------
2710: F224         ;write the current directory entry, set checksum
2711: F224             WriteDir:
2712: F224 CD 95 EE               CALL   NewCheckSum          ; initialize entry
2713: F227 CD D7 ED               CALL   SetDirDMA            ; directory dma
2714: F22A 0E 01                  LD     C,1                  ; indicates a write directory operation
2715: F22C CD 32 F2               CALL   WriteBuffer          ; write the buffer
2716: F22F C3 D1 ED               JP     SetDataDMA           ; to data dma address
2717: F232         ;ret
2718: F232         ;-----------------------------------------------------------------
2719: F232         ;write buffer and check condition
2720: F232         ;write type (wrtype) is in register C
2721: F232         ;wrtype = 0 => normal write operation		WriteAllocated
2722: F232         ;wrtype = 1 => directory write operation	WriteDirectory
2723: F232         ;wrtype = 2 => start of new block			WriteCleanBuffer
2724: F232             WriteBuffer:
2725: F232 CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
2726: F235 B7                     OR     A
2727: F236 C2 A0 F4               JP     NZ,erPermanentNoWait ; error if not 00
2728: F239 C9                     RET
2729: F23A         ;-----------------------------------------------------------------
2730: F23A         ;read buffer and check condition
2731: F23A             ReadBuffer:
2732: F23A CD 27 F6               CALL   bcRead               ; current drive, track, sector, dma
2733: F23D B7                     OR     A
2734: F23E C2 A0 F4               JP     NZ,erPermanentNoWait
2735: F241 C9                     RET
2736: F242         ;-----------------------------------------------------------------
2737: F242         ;HL = .fcb1(i), DE = .fcb2(i),
2738: F242         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
2739: F242             Merge:
2740: F242 7E                     LD     A,(HL)
2741: F243 23                     INC    HL
2742: F244 B6                     OR     M
2743: F245 2B                     DEC    HL
2744: F246 C0                     RET    NZ                   ; return if = 0000
2745: F247 1A                     LD     A,(DE)
2746: F248 77                     LD     (HL),A
2747: F249 13                     INC    DE
2748: F24A 23                     INC    HL                   ; low byte copied
2749: F24B 1A                     LD     A,(DE)
2750: F24C 77                     LD     (HL),A
2751: F24D 1B                     DEC    DE
2752: F24E 2B                     DEC    HL                   ; back to input form
2753: F24F C9                     RET
2754: F250         ;-----------------------------------------------------------------
2755: F250         ;compute closest disk block number from current block
2756: F250         ;given allocation vector position BC, find the zero bit closest to this position
2757: F250         ;by searching left and right.
2758: F250         ;if found, set the bit to one and return the bit position in hl.
2759: F250         ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
2760: F250             GetClosestBlock:
2761: F250 50                     LD     D,B
2762: F251 59                     LD     E,C                  ; copy of starting position to de
2763: F252             TestLeft:
2764: F252 79                     LD     A,C
2765: F253 B0                     OR     B
2766: F254 CA 63 F2               JP     Z,TestRight          ; skip if left=0000
2767: F257         ; left not at position zero, bit zero?
2768: F257 0B                     DEC    BC
2769: F258 D5                     PUSH   DE
2770: F259 C5                     PUSH   BC                   ; left,right pushed
2771: F25A CD 77 ED               CALL   GetAllocBit
2772: F25D 1F                     RRA
2773: F25E D2 7E F2               JP     NC,ReturnBlockNumber ; return block number if zero
2774: F261         ; bit is one, so try the right
2775: F261 C1                     POP    BC
2776: F262 D1                     POP    DE                   ; left, right restored
2777: F263             TestRight:
2778: F263 2A 27 F5               LD     HL,(dpbDSM)          ; value of maximum allocation#
2779: F266 7B                     LD     A,E
2780: F267 95                     SUB    L
2781: F268 7A                     LD     A,D
2782: F269 9C                     SBC    A,H                  ; right=dpbDSM?
2783: F26A D2 86 F2               JP     NC,ReturnBlockZero   ; return block 0000 if so
2784: F26D 13                     INC    DE
2785: F26E C5                     PUSH   BC
2786: F26F D5                     PUSH   DE                   ; left, right pushed
2787: F270 42                     LD     B,D
2788: F271 4B                     LD     C,E                  ; ready right for call
2789: F272 CD 77 ED               CALL   GetAllocBit
2790: F275 1F                     RRA
2791: F276 D2 7E F2               JP     NC,ReturnBlockNumber ; return block number if zero
2792: F279 D1                     POP    DE
2793: F27A C1                     POP    BC                   ; restore left and right pointers
2794: F27B C3 52 F2               JP     TestLeft             ; for another attempt
2795: F27E             ReturnBlockNumber:
2796: F27E 17                     RLA
2797: F27F 3C                     INC    A                    ; bit back into position and set to 1
2798: F280         ; 	D contains the number of shifts required to reposition
2799: F280 CD A9 ED               CALL   RotateAndReplace     ; move bit back to position and store
2800: F283 E1                     POP    HL
2801: F284 D1                     POP    DE                   ; HL returned value, DE discarded
2802: F285 C9                     RET
2803: F286
2804: F286         ; cannot find an available bit, return 0000
2805: F286             ReturnBlockZero:
2806: F286 21 00 00               LD     HL,0000H
2807: F289 C9                     RET
2808: F28A         ;-----------------------------------------------------------------
2809: F28A         ;compute disk block number from current fcb
2810: F28A             GetBlockNumber:
2811: F28A CD 12 F4               CALL   GetDiskMapIndex      ; 0...15 in register A
2812: F28D 4F                     LD     C,A
2813: F28E 06 00                  LD     B,0
2814: F290 CD 32 F4               CALL   GetDiskMapValue      ; return value in HL
2815: F293 22 43 F5               LD     (currentBlock),HL    ; save for later
2816: F296 C9                     RET
2817: F297         ;-----------------------------------------------------------------
2818: F297         ;is  block allocated
2819: F297             IsAllocated:
2820: F297 2A 43 F5               LD     HL,(currentBlock)
2821: F29A 7D                     LD     A,L
2822: F29B B4                     OR     H
2823: F29C C9                     RET
2824: F29D         ;-----------------------------------------------------------------
2825: F29D         ;compute actual record address
2826: F29D         ; result = currentBlock * ( 2**BSH)
2827: F29D             SetActualRecordAdd:
2828: F29D 3A 24 F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
2829: F2A0 2A 43 F5               LD     HL,(currentBlock)
2830: F2A3
2831: F2A3             SetActualRecordAdd1:
2832: F2A3 29                     ADD    HL,HL
2833: F2A4 3D                     DEC    A                    ; shl(currentBlock,dpbBSH)
2834: F2A5 C2 A3 F2               JP     NZ,SetActualRecordAdd1
2835: F2A8         ; HL has Record number for start of the block;
2836: F2A8 3A 25 F5               LD     A,(dpbBLM)           ; get block mask
2837: F2AB 4F                     LD     C,A                  ; to get cpmRecord mod Block
2838: F2AC 3A 41 F5               LD     A,(cpmRecord)        ; get index into block
2839: F2AF A1                     AND    C                    ; masked value in A
2840: F2B0 B5                     OR     L
2841: F2B1 6F                     LD     L,A                  ; to HL
2842: F2B2 22 43 F5               LD     (currentBlock),HL    ; currentBlock=HL or (cpmRecord and dpbBLM)
2843: F2B5         ; *** currentBlock now has current record number - Starting record number + index into block
2844: F2B5 C9                     RET
2845: F2B6         ;-----------------------------------------------------------------
2846: F2B6         ;---------------------
2847: F2B6         ;copy directory location to exitParameterByte
2848: F2B6             DirLocationToReturnLoc:
2849: F2B6 3A 35 F5               LD     A,(directoryFlag)
2850: F2B9 32 BD EA               LD     (exitParameterByte),A
2851: F2BC C9                     RET
2852: F2BD         ;---------------------
2853: F2BD         ;clear the module number field for user open/make (S2)
2854: F2BD             ClearModuleNum:
2855: F2BD CD C3 F2               CALL   GetModuleNum
2856: F2C0 36 00                  LD     (HL),0               ; fcb(fcbS2Index)=0
2857: F2C2 C9                     RET
2858: F2C3         ;---------------------
2859: F2C3         ;get data module number (high order bit is fwf -file write flag)
2860: F2C3             GetModuleNum:
2861: F2C3 2A BB EA               LD     HL,(paramDE)
2862: F2C6 11 0E 00               LD     DE,fcbS2Index
2863: F2C9 19                     ADD    HL,DE                ; HL=.fcb(fcbS2Index)
2864: F2CA 7E                     LD     A,(HL)
2865: F2CB C9                     RET                         ; A=fcb(fcbS2Index)
2866: F2CC         ;---------------------
2867: F2CC         ;check current fcb to see if reselection necessary
2868: F2CC             Reselect:
2869: F2CC 3E FF                  LD     A,TRUE
2870: F2CE 32 3C F5               LD     (fResel),A           ;mark possible reselect
2871: F2D1 2A BB EA               LD     HL,(paramDE)
2872: F2D4 7E                     LD     A,(HL)               ; drive select code
2873: F2D5 E6 1F                  AND    00011111B            ; non zero is auto drive select
2874: F2D7 3D                     DEC    A                    ; drive code normalized to 0..30, or 255
2875: F2D8 32 BA EA               LD     (paramE),A           ; save drive code
2876: F2DB FE 1E                  CP     30
2877: F2DD D2 F0 F2               JP     NC,NoSelect
2878: F2E0         ; auto select function, save currentDisk
2879: F2E0 3A 0C F5               LD     A,(currentDisk)
2880: F2E3 32 3D F5               LD     (entryDisk),A        ; entryDisk=currentDisk
2881: F2E6 7E                     LD     A,(HL)
2882: F2E7 32 3E F5               LD     (fcbDisk),A          ; save drive code
2883: F2EA E6 E0                  AND    11100000B
2884: F2EC 77                     LD     (HL),A               ; preserve hi bits
2885: F2ED CD 49 EC               CALL   SelectCurrent
2886: F2F0             NoSelect:                       ; noselect:
2887: F2F0
2888: F2F0 3A 0B F5               LD     A,(currentUserNumber) ; set user code 0...31
2889: F2F3 2A BB EA               LD     HL,(paramDE)
2890: F2F6 B6                     OR     M
2891: F2F7 77                     LD     (HL),A
2892: F2F8 C9                     RET
2893: F2F9         ;---------------------
2894: F2F9         ;search for the directory entry, copy to fcb
2895: F2F9             OpenFile:
2896: F2F9 0E 0F                  LD     C,nameLength
2897: F2FB CD 3C F3               CALL   Search4DirElement
2898: F2FE CD E0 ED               CALL   EndOfDirectory
2899: F301 C8                     RET    Z                    ; return with exitParameterByte=255 if end
2900: F302
2901: F302         ; not end of directory, copy fcb information
2902: F302             OpenFileCopyFCB:
2903: F302 CD C4 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2904: F305 7E                     LD     A,(HL)
2905: F306 F5                     PUSH   AF
2906: F307 E5                     PUSH   HL                   ; save extent#
2907: F308 CD CC EE               CALL   GetDirElementAddress
2908: F30B EB                     EX     DE,HL                ; DE = .buff(dptr)
2909: F30C 2A BB EA               LD     HL,(paramDE)         ; HL=.fcb(0)
2910: F30F 0E 20                  LD     C,NEXT_RECORD        ; length of move operation
2911: F311 D5                     PUSH   DE                   ; save .buff(dptr)
2912: F312 CD 6B F4               CALL   Move                 ; from .buff(dptr) to .fcb(0)
2913: F315         ; note that entire fcb is copied, including indicators
2914: F315 CD CC F3               CALL   SetFileWriteFlag     ; sets file write flag
2915: F318 D1                     POP    DE
2916: F319 21 0C 00               LD     HL,fcbExtIndex
2917: F31C 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbExtIndex)
2918: F31D 4E                     LD     C,(HL)               ; C = directory extent number
2919: F31E 21 0F 00               LD     HL,fcbRCIndex        ; point at the record Count field
2920: F321 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbRCIndex)
2921: F322 46                     LD     B,(HL)               ; B holds directory record count
2922: F323 E1                     POP    HL
2923: F324 F1                     POP    AF
2924: F325 77                     LD     (HL),A               ; restore extent number
2925: F326         ; HL = .user extent#, B = dir rec cnt, C = dir extent#
2926: F326         ; if user ext < dir ext then user := 128 records
2927: F326         ; if user ext = dir ext then user := dir records
2928: F326         ; if user ext > dir ext then user := 0 records
2929: F326 79                     LD     A,C
2930: F327 BE                     CP     M
2931: F328 78                     LD     A,B                  ; ready dir fcbRCIndex
2932: F329 CA 33 F3               JP     Z,OpenRecordCount    ; if same, user gets dir fcbRCIndex
2933: F32C 3E 00                  LD     A,0
2934: F32E DA 33 F3               JP     C,OpenRecordCount    ; user is larger
2935: F331 3E 80                  LD     A,RecordsPerExtent   ; directory is larger >>>RecordsPerExtent
2936: F333             OpenRecordCount:                      ;Acc has record count to fill
2937: F333 2A BB EA               LD     HL,(paramDE)
2938: F336 11 0F 00               LD     DE,fcbRCIndex
2939: F339 19                     ADD    HL,DE
2940: F33A 77                     LD     (HL),A
2941: F33B C9                     RET
2942: F33C
2943: F33C         ;---------------------
2944: F33C         ;search for directory element of length C at info
2945: F33C             Search4DirElement:
2946: F33C 3E FF                  LD     A,0FFH
2947: F33E 32 35 F5               LD     (directoryFlag),A    ; changed if actually found
2948: F341 21 38 F5               LD     HL,searchLength
2949: F344 71                     LD     (HL),C               ; searchLength = C
2950: F345 2A BB EA               LD     HL,(paramDE)
2951: F348 22 39 F5               LD     (searchAddress),HL   ; searchAddress = paramDE
2952: F34B CD CA ED               CALL   SetEndDirectory      ; dirEntryIndex = enddir
2953: F34E CD B0 ED               CALL   Home                 ; to start at the beginning
2954: F351 C3 54 F3               JP     Search4NextDirElement
2955: F354         ;---------------------
2956: F354         ;search for the next directory element, assuming a previous
2957: F354         ;call on search which sets searchAddress and searchLength
2958: F354             Search4NextDirElement:
2959: F354 0E 00                  LD     C,FALSE
2960: F356 CD F2 ED               CALL   ReadDirectory        ; read next dir element
2961: F359 CD E0 ED               CALL   EndOfDirectory
2962: F35C CA BB F3               JP     Z,SearchDone         ; skip to end if so
2963: F35F         ; not end of directory, scan for match
2964: F35F 2A 39 F5               LD     HL,(searchAddress)
2965: F362 EB                     EX     DE,HL                ; DE=beginning of user fcb
2966: F363 1A                     LD     A,(DE)               ; first character
2967: F364 FE E5                  CP     emptyDir             ; keep scanning if Dir entry is empty
2968: F366 CA 71 F3               JP     Z,Search4NextDirElement1
2969: F369         ; not emptyDir, may be end of logical directory
2970: F369 D5                     PUSH   DE                   ; save search address
2971: F36A CD DE EE               CALL   StillInDirectory     ; past logical end?
2972: F36D D1                     POP    DE                   ; recall address
2973: F36E D2 BB F3               JP     NC,SearchDone        ; artificial stop
2974: F371             Search4NextDirElement1:
2975: F371 CD CC EE               CALL   GetDirElementAddress ; HL = buffa+dptr
2976: F374 3A 38 F5               LD     A,(searchLength)
2977: F377 4F                     LD     C,A                  ; length of search to c
2978: F378 06 00                  LD     B,0                  ; bcounts up, c counts down
2979: F37A             Search4NextLoop:
2980: F37A 79                     LD     A,C
2981: F37B B7                     OR     A
2982: F37C CA AA F3               JP     Z,EndDirElementSearch
2983: F37F 1A                     LD     A,(DE)
2984: F380 FE 3F                  CP     QMARK
2985: F382 CA A3 F3               JP     Z,Search4NextOK      ; ? matches all
2986: F385         ; scan next character if not fcbS1Index
2987: F385 78                     LD     A,B
2988: F386 FE 0D                  CP     fcbS1Index
2989: F388 CA A3 F3               JP     Z,Search4NextOK
2990: F38B         ; not the fcbS1Index field, extent field?
2991: F38B FE 0C                  CP     fcbExtIndex          ; may be extent field
2992: F38D 1A                     LD     A,(DE)               ; fcb character
2993: F38E CA 9A F3               JP     Z,Search4Ext         ; skip to search extent
2994: F391 96                     SUB    M
2995: F392 E6 7F                  AND    07FH                 ; mask-out flags/extent modulus
2996: F394 C2 54 F3               JP     NZ,Search4NextDirElement ; skip if not matched
2997: F397 C3 A3 F3               JP     Search4NextOK        ;matched character
2998: F39A
2999: F39A         ; A has fcb character attempt an extent # match
3000: F39A             Search4Ext:
3001: F39A C5                     PUSH   BC                   ; save counters
3002: F39B 4E                     LD     C,(HL)               ; directory character to c
3003: F39C CD D9 F3               CALL   CompareExtents       ; compare user/dir char
3004: F39F C1                     POP    BC                   ; recall counters
3005: F3A0 C2 54 F3               JP     NZ,Search4NextDirElement ; skip if no match
3006: F3A3
3007: F3A3         ; current character matches
3008: F3A3             Search4NextOK:
3009: F3A3 13                     INC    DE
3010: F3A4 23                     INC    HL
3011: F3A5 04                     INC    B
3012: F3A6 0D                     DEC    C
3013: F3A7 C3 7A F3               JP     Search4NextLoop
3014: F3AA
3015: F3AA         ; entire name matches, return dir position
3016: F3AA             EndDirElementSearch:
3017: F3AA 3A 46 F5               LD     A,(dirEntryIndex)
3018: F3AD E6 03                  AND    dirEntryMask
3019: F3AF 32 BD EA               LD     (exitParameterByte),A
3020: F3B2         ; exitParameterByte = low(dirEntryIndex) and 11b
3021: F3B2 21 35 F5               LD     HL,directoryFlag
3022: F3B5 7E                     LD     A,(HL)
3023: F3B6 17                     RLA
3024: F3B7 D0                     RET    NC                   ; directoryFlag=0ffh?
3025: F3B8         ; yes, change it to 0 to mark as found
3026: F3B8 AF                     XOR    A
3027: F3B9 77                     LD     (HL),A               ; directoryFlag=0
3028: F3BA C9                     RET
3029: F3BB
3030: F3BB         ; end of directory, or empty name
3031: F3BB             SearchDone:
3032: F3BB CD CA ED               CALL   SetEndDirectory      ; may be artifical end
3033: F3BE 3E FF                  LD     A,0FFH
3034: F3C0 32 BD EA               LD     (exitParameterByte),A
3035: F3C3 C9                     RET
3036: F3C4         ;---------------------
3037: F3C4         ;get current extent field address to (HL)
3038: F3C4             GetExtentAddress:
3039: F3C4 2A BB EA               LD     HL,(paramDE)
3040: F3C7 11 0C 00               LD     DE,fcbExtIndex
3041: F3CA 19                     ADD    HL,DE                ;HL=.fcb(fcbExtIndex)
3042: F3CB C9                     RET
3043: F3CC         ;---------------------
3044: F3CC         ;Set file write flag
3045: F3CC             SetFileWriteFlag:
3046: F3CC CD C3 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3047: F3CF F6 80                  OR     writeFlagMask        ; set fwf (file write flag) to "1"
3048: F3D1 77                     LD     (HL),A               ; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
3049: F3D2 C9                     RET                         ; also returns non zero in accumulator
3050: F3D3         ;---------------------
3051: F3D3         ;set exitParameterByte to 1
3052: F3D3             SetLowReturnTo1:
3053: F3D3 3E 01                  LD     A,1
3054: F3D5 32 BD EA               LD     (exitParameterByte),A
3055: F3D8 C9                     RET
3056: F3D9         ;---------------------
3057: F3D9         ;compare extent# in A with that in C, return nonzero if they do not match
3058: F3D9             CompareExtents:
3059: F3D9 C5                     PUSH   BC                   ; save C's original value
3060: F3DA F5                     PUSH   AF
3061: F3DB 3A 26 F5               LD     A,(dpbEXM)
3062: F3DE 2F                     CPL
3063: F3DF 47                     LD     B,A
3064: F3E0         ; B has negated form of extent mask
3065: F3E0 79                     LD     A,C
3066: F3E1 A0                     AND    B
3067: F3E2 4F                     LD     C,A                  ; low bits removed from C
3068: F3E3 F1                     POP    AF
3069: F3E4 A0                     AND    B                    ; low bits removed from A
3070: F3E5 91                     SUB    C
3071: F3E6 E6 1F                  AND    maxExtValue          ; set flags
3072: F3E8 C1                     POP    BC                   ; restore original values
3073: F3E9 C9                     RET
3074: F3EA         ;---------------------
3075: F3EA         ;copy the directory entry to the user buffer
3076: F3EA             CopyDirEntryToUser:
3077: F3EA 2A 1A F5               LD     HL,(caDirectoryDMA)
3078: F3ED EB                     EX     DE,HL                ; source is directory buffer
3079: F3EE 2A 12 F5               LD     HL,(InitDAMAddress)  ; destination is user dma address
3080: F3F1 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3081: F3F3 C3 6B F4               JP     Move
3082: F3F6         ;---------------------
3083: F3F6         ;copy the whole file control block
3084: F3F6             CopyFCB:
3085: F3F6 0E 00                  LD     C,0
3086: F3F8 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3087: F3FA C3 FD F3               JP     CopyDir
3088: F3FD         ;---------------------
3089: F3FD         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3090: F3FD             CopyDir:
3091: F3FD D5                     PUSH   DE                   ; save length for later
3092: F3FE 06 00                  LD     B,0                  ; double index to BC
3093: F400 2A BB EA               LD     HL,(paramDE)         ; HL = source for data
3094: F403 09                     ADD    HL,BC
3095: F404 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3096: F405 CD CC EE               CALL   GetDirElementAddress ; HL=.buff(dptr), destination
3097: F408 C1                     POP    BC                   ; DE=source, HL=dest, C=length
3098: F409 CD 6B F4               CALL   Move                 ; data moved
3099: F40C         ;enter from close to seek and copy current element
3100: F40C             SeekAndCopy:                      ; seek$copy:
3101: F40C CD 23 EE               CALL   SeekDir              ; seek$dir ;to the directory element
3102: F40F C3 24 F2               JP     WriteDir             ; write the directory element
3103: F412         ;---------------------
3104: F412         ;Return the  disk map Index for cpmRecord in the ACC
3105: F412         ;  account for multiple extents in 1 physical Directory entry
3106: F412             GetDiskMapIndex:                      ; dm$position
3107: F412 21 24 F5               LD     HL,dpbBSH            ; get block shift value
3108: F415 4E                     LD     C,(HL)               ; shift count to C
3109: F416 3A 41 F5               LD     A,(cpmRecord)        ; current virtual record to A
3110: F419             GetDiskMapIndex1:
3111: F419 B7                     OR     A                    ; reset the carry flag
3112: F41A 1F                     RRA
3113: F41B 0D                     DEC    C
3114: F41C C2 19 F4               JP     NZ,GetDiskMapIndex1
3115: F41F         ; A = shr(cpmRecord,dpbBSH) = cpmRecord/2**(sect/block)
3116: F41F         ; A has the relative position in the block.
3117: F41F 47                     LD     B,A                  ; save it for later addition
3118: F420 3E 08                  LD     A,8
3119: F422 96                     SUB    M                    ; 8-dpbBSH to accumulator
3120: F423 4F                     LD     C,A                  ; extent shift count in register c
3121: F424 3A 40 F5               LD     A,(extentValue)      ; extent value ani extmsk
3122: F427             GetDiskMapIndex2:                      ; dmpos1:
3123: F427         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3124: F427         ; shift is 4,3,2,1,0
3125: F427 0D                     DEC    C
3126: F428 CA 30 F4               JP     Z,GetDiskMapIndex3
3127: F42B B7                     OR     A                    ; clear the carry flag
3128: F42C 17                     RLA
3129: F42D C3 27 F4               JP     GetDiskMapIndex2
3130: F430
3131: F430         ; The ACC has the Block Number for this record
3132: F430             GetDiskMapIndex3:
3133: F430         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3134: F430 80                     ADD    A,B                  ; add the previous shr(cpmRecord,dpbBSH) value
3135: F431         ; A is one of the following values, depending upon alloc
3136: F431         ; bks dpbBSH
3137: F431         ; 1k   3     v/8 + extentValue * 16
3138: F431         ; 2k   4     v/16+ extentValue * 8
3139: F431         ; 4k   5     v/32+ extentValue * 4
3140: F431         ; 8k   6     v/64+ extentValue * 2
3141: F431         ; 16k  7     v/128+extentValue * 1
3142: F431 C9                     RET                         ; with disk map position in A
3143: F432         ;---------------------
3144: F432         ; Enter with Disk Map Index in BG
3145: F432         ; Return disk map value  in HL
3146: F432             GetDiskMapValue:
3147: F432 2A BB EA               LD     HL,(paramDE)         ; base address of file control block
3148: F435 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3149: F438 19                     ADD    HL,DE                ; HL =.diskmap
3150: F439 09                     ADD    HL,BC                ; index by a single byte value
3151: F43A 3A 3B F5               LD     A,(single)           ; single byte/map entry?
3152: F43D B7                     OR     A
3153: F43E CA 45 F4               JP     Z,GetDiskMap16Bit    ; get disk map single byte
3154: F441 6E                     LD     L,(HL)
3155: F442 26 00                  LD     H,0
3156: F444 C9                     RET                         ; with HL=00bb
3157: F445             GetDiskMap16Bit:                      ; getdmd:
3158: F445 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3159: F446         ; double precision value returned
3160: F446 56                     LD     D,(HL)
3161: F447 23                     INC    HL
3162: F448 5E                     LD     E,(HL)
3163: F449 EB                     EX     DE,HL
3164: F44A C9                     RET
3165: F44B         ;---------------------
3166: F44B         ;---------------------
3167: F44B         ;*****************************************************************
3168: F44B         ;************************ Utilities ******************************
3169: F44B         ;*****************************************************************
3170: F44B             AddAtoHL:
3171: F44B 85                     ADD    A,L
3172: F44C 6F                     LD     L,A
3173: F44D D0                     RET    NC
3174: F44E 24                     INC    H
3175: F44F C9                     RET
3176: F450         ;----------
3177: F450             DEminusHL2HL:
3178: F450 7B                     LD     A,E
3179: F451 95                     SUB    L
3180: F452 6F                     LD     L,A
3181: F453 7A                     LD     A,D
3182: F454 9C                     SBC    A,H
3183: F455 67                     LD     H,A
3184: F456 C9                     RET
3185: F457         ;-------------
3186: F457             ShiftRightHLbyC:
3187: F457 0C                     INC    C
3188: F458             ShiftRightHLbyC0:
3189: F458 0D                     DEC    C
3190: F459 C8                     RET    Z
3191: F45A 7C                     LD     A,H
3192: F45B B7                     OR     A
3193: F45C 1F                     RRA
3194: F45D 67                     LD     H,A
3195: F45E 7D                     LD     A,L
3196: F45F 1F                     RRA
3197: F460 6F                     LD     L,A
3198: F461 C3 58 F4               JP     ShiftRightHLbyC0
3199: F464         ;-------
3200: F464             ShiftLeftHLbyC:
3201: F464 0C                     INC    C
3202: F465             ShiftLeftHLbyC0:
3203: F465 0D                     DEC    C
3204: F466 C8                     RET    Z                    ; exit when done
3205: F467 29                     ADD    HL,HL
3206: F468 C3 65 F4               JP     ShiftLeftHLbyC0
3207: F46B         ;*****************************************************************
3208: F46B         ;move data length of length C from source DE to HL
3209: F46B             Move:
3210: F46B 0C                     INC    C
3211: F46C             Move0:
3212: F46C 0D                     DEC    C
3213: F46D C8                     RET    Z
3214: F46E 1A                     LD     A,(DE)
3215: F46F 77                     LD     (HL),A
3216: F470 13                     INC    DE
3217: F471 23                     INC    HL
3218: F472 C3 6C F4               JP     Move0
3219: F475
3220: F475         ;********** Console OUT Routines*******************
3221: F475
3222: F475
3223: F475
3224: F475
3225: F475
3226: F475         ;********************************************************
3227: F475         ;return version number
3228: F475             vGetVersion:                      ; func12 (12 - 0C)	 Get Verson
3229: F475 3E 20                  LD     A,VERSION
3230: F477 32 BD EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION (high = 00)
3231: F47A C9                     RET
3232: F47B         ;************Error message World*************************
3233: F47B             errSelect:
3234: F47B 21 9A F4               LD     HL,evSelection
3235: F47E C3 93 F4               JP     GoToError
3236: F481             errReadOnlyDisk:
3237: F481 21 9C F4               LD     HL,evReadOnlyDisk
3238: F484 C3 93 F4               JP     GoToError
3239: F487             errReadOnlyFile:
3240: F487 21 9E F4               LD     HL,evReadOnlyFile
3241: F48A C3 93 F4               JP     GoToError
3242: F48D             errPermanent:
3243: F48D 21 98 F4               LD     HL,evPermanent
3244: F490 C3 93 F4               JP     GoToError
3245: F493         ;************Error message handler **********************
3246: F493             GoToError:
3247: F493         ;HL = .errorhandler, call subroutine
3248: F493 5E                     LD     E,(HL)
3249: F494 23                     INC    HL
3250: F495 56                     LD     D,(HL)               ; address of routine in DE
3251: F496 EB                     EX     DE,HL
3252: F497 E9                     JP     (HL)                 ; vector to subroutine
3253: F498         ;************ Error Vectors *****************************
3254: F498 A6 F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3255: F49A B2 F4       evSelection: DW     erSelection          ; selerr select error subroutine
3256: F49C B8 F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3257: F49E BE F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3258: F4A0         ;************Error Routines ******************************
3259: F4A0             erPermanentNoWait:
3260: F4A0 21 F0 F4               LD     HL,emPermanent
3261: F4A3 C3 93 F4               JP     GoToError
3262: F4A6             erPermanent:
3263: F4A6 21 F0 F4               LD     HL,emPermanent
3264: F4A9 CD C7 F4               CALL   displayAndWait       ; to report the error
3265: F4AC FE 03                  CP     CTRL_C
3266: F4AE CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3267: F4B1 C9                     RET                         ; and ignore the error
3268: F4B2         ;
3269: F4B2             erSelection:
3270: F4B2 21 FB F4               LD     HL,emSelection
3271: F4B5 C3 C1 F4               JP     waitB4boot           ; wait console before boot
3272: F4B8         ;
3273: F4B8             erReadOnlyDisk:
3274: F4B8 21 07 F5               LD     HL,emReadOnlyDisk
3275: F4BB C3 C1 F4               JP     waitB4boot           ; wait console before boot
3276: F4BE         ;
3277: F4BE             erReadOnlyFile:
3278: F4BE 21 02 F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3279: F4C1         ;
3280: F4C1         ; wait for response before boot
3281: F4C1             waitB4boot:
3282: F4C1 CD C7 F4               CALL   displayAndWait
3283: F4C4 C3 00 00               JP     WarmBoot
3284: F4C7
3285: F4C7         ;report error to console, message address in HL
3286: F4C7             displayAndWait:
3287: F4C7 E5                     PUSH   HL                   ; save message pointer
3288: F4C8 CD CE E9               CALL   showCRLF             ; stack mssg address, new line
3289: F4CB 3A 0C F5               LD     A,(currentDisk)
3290: F4CE C6 41                  ADD    A,ASCII_A
3291: F4D0 32 EC F4               LD     (emDisk),A           ; Problem disk name
3292: F4D3 01 E0 F4               LD     BC,emDisk0
3293: F4D6 CD 33 E9               CALL   Print                ; the error message
3294: F4D9 C1                     POP    BC
3295: F4DA CD 33 E9               CALL   Print                ; error mssage tail
3296: F4DD C3 19 E9               JP     ConIn                ; to get the input character
3297: F4E0         ;ret
3298: F4E0         ;**************Error Messages*******************************
3299: F4E0 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3300: F4EC 20 3A 20 24     emDisk:    DB     ' : $'
3301: F4F0 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3302: F4FB 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3303: F502 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3304: F507 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3305: F50B         ;*****************************************************************
3306: F50B
3307: F50B         ;********* file control block (fcb) constants ********************
3308: F50B             fcbLength  EQU    32                   ; fcblen file control block size
3309: F50B             fcbROfileIndex EQU    9                    ; high order of first type char
3310: F50B             fcbHiddenfileIndex EQU    10                   ; invisible file in dir command
3311: F50B             fcbExtIndex EQU    12                   ; extent number field index
3312: F50B             fcbS1Index EQU    13                   ; S1 index
3313: F50B             fcbS2Index EQU    14                   ; S2 data module number index
3314: F50B             fcbRCIndex EQU    15                   ; record count field index
3315: F50B             fcbDiskMapIndex EQU    16                   ; dskmap disk map field
3316: F50B
3317: F50B             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3318: F50B
3319: F50B             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3320: F50B             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3321: F50B             dirEntryMask EQU    dirEntriesPerRecord-1
3322: F50B             fcbShift   EQU    5                    ; log2(fcbLength)
3323: F50B         ;
3324: F50B
3325: F50B
3326: F50B
3327: F50B             maxExtValue EQU    31                   ; largest extent number
3328: F50B             moduleMask EQU    15                   ; limits module number value
3329: F50B             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3330: F50B             nameLength EQU    15                   ; namlen name length
3331: F50B
3332: F50B             emptyDir   EQU    0E5H                 ; empty empty directory entry
3333: F50B             NEXT_RECORD EQU    fcbLength            ; nxtrec
3334: F50B             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3335: F50B         ;
3336: F50B         ;	reserved file indicators
3337: F50B         ;	equ	11				; reserved
3338: F50B         ;*****************************************************************
3339: F50B         ;*****************************************************************
3340: F50B
3341: F50B         ;***common values shared between bdosi and bdos******************
3342: F50B 00          currentUserNumber: DB     0                    ; usrcode current user number
3343: F50C         ; paramDE:			DS	2					; ParamsDE information address
3344: F50C         ; exitParameterByte:
3345: F50C         ; exitParameterWord:	DS	2					; address value to return
3346: F50C FF          currentDisk: DB     -1                   ; curdsk current disk number
3347: F50D         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3348: F50D
3349: F50D         ;********************* Local Variables ***************************
3350: F50D         ;     ************************
3351: F50D         ;     *** Initialized Data ***
3352: F50D
3353: F50D E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3354: F50E 00 00       ReadOnlyVector: DW     0                    ; rodsk read only disk vector
3355: F510 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3356: F512 80 00       InitDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3357: F514
3358: F514         ;     *** Current Disk attributes ****
3359: F514         ; These are set upon disk select
3360: F514         ; data must be adjacent, do not insert variables
3361: F514         ; address of translate vector, not used
3362: F514         ; ca - currentAddress
3363: F514
3364: F514 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3365: F516 00 00       caTrack:   DW     0000H                ; curtrka current track address
3366: F518 00 00       caSector:  DW     0000H                ; current Sector
3367: F51A             caListSizeStart:
3368: F51A 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3369: F51C 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3370: F51E 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3371: F520 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3372: F522             caListSizeEnd:
3373: F522             caListSize EQU    caListSizeEnd - caListSizeStart
3374: F522
3375: F522         ;     ***** Disk Parameter Block *******
3376: F522         ; data must be adjacent, do not insert variables
3377: F522         ; dpb - Disk Parameter Block
3378: F522             dpbStart:
3379: F522 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3380: F524 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3381: F525 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3382: F526 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3383: F527 00 00       dpbDSM:    DW     0000H                ; maxall maximum allocation number
3384: F529 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3385: F52B 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3386: F52D 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3387: F52F 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3388: F531             dpbEnd:
3389: F531             dpbSize    EQU    dpbEnd - dpbStart
3390: F531         ;
3391: F531
3392: F531         ;     ************************
3393: F531
3394: F531 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3395: F533 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3396: F534 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3397: F535 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3398: F536 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3399: F537 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3400: F538 00          searchLength: DB     00H                  ; searchl search length
3401: F539 00 00       searchAddress: DW     0000H                ; searcha search address
3402: F53B         ;tinfo:	ds	word							; temp for info in "make"
3403: F53B 00          single:    DB     00H                  ; set true if single byte allocation map
3404: F53C 00          fResel:    DB     00H                  ; resel reselection flag
3405: F53D 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3406: F53E 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3407: F53F 00          fcbRecordCount: DB     00H                  ; record count from current fcb
3408: F540 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3409: F541 00 00       cpmRecord: DW     0000H                ; current virtual record - NEXT_RECORD
3410: F543 00 00       currentBlock: DW     0000H                ; arecord current actual record
3411: F545         ;
3412: F545         ;	local variables for directory access
3413: F545 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3414: F546 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3415: F548 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3416: F54A
3417: F54A         ;********************** data areas ******************************
3418: F54A
3419: F54A
3420: F54A         ;---------------------------------- Stack Area--------------------------------;
3421: F54A             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3422: F58A             bdosStack:
3423: F58A         ;
3424: F58A         ;---------------------------------- Stack Area--------------------------------;
3425: F58A         ;	end of Basic I/O System
3426: F58A         ;-----------------------------------------------------------------;
3427: F58A
3428: F58A
3429: F58A         ;
3430: F58A             Z_HighestLocation:
3431: F58A             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3432: F58A
3433: F58A
           ************************   Xref   ************************
0000: $               F58A   0413 0443
3170: AddAtoHL        F44B   2069 2378
2382: Allocate16Bit   F067   2376
1014: AreWeAtEndOfBuffer EA32   1010
0083: ASCII_A         0041   3290
0084: ASCII_C         0043
0085: ASCII_K         004B
0092: ASCII_LO_A      0061
0093: ASCII_LO_K      006B
0094: ASCII_LO_P      0070
0035: ASCII_MASK      007F   0956
0086: ASCII_N         004E
0087: ASCII_Q         0051
0088: ASCII_R         0052
0089: ASCII_W         0057
0090: ASCII_Y         0059
0070: ASCII_ZERO      0030
0064: ASTERISK        002A
1106: BackUp          EA97   1034 1102
1111: BackUp1         EA9F   1107
0292: bcBoot          F600
0295: bcConin         F609   0613 0767 0883 0901
0296: bcConout        F60C   0605 0842 1109 1113 1119 1121
0294: bcConst         F606   0610 0879
0300: bcHome          F618   1821
0297: bcList          F60F   0578 0848
0307: bcListst        F62D
0298: bcPunch         F612   0563
0305: bcRead          F627   2732
0299: bcReader        F615   0544
0308: bcSectran       F630
0301: bcSeldsk        F61B   1563
0304: bcSetdma        F624   1861
0303: bcSetsec        F621   2013
0302: bcSettrk        F61E   1826 1993
0293: bcWboot         F603   0464
0306: bcWrite         F62A   2725
0150: BDOSBase        E800   0151 0153 0324
0119: BDOSE           0005   0120
0151: BDOSEntry       E800
0140: BDOSLength      0E00   0143 0153 0154
3422: bdosStack       F58A
0329: BdosStart       E800
0053: BELL            0007
0153: BIOSBase        F600
0141: BIOSLength      0A00   0143
0113: BIOSPAGE        0002
0154: BIOSStart       F600   0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 3431
2367: BlockOK         F04B   2361
0250: BlockSize       0800   0272
1029: BSspaceBS       EA40   0967
0031: BYTE            0001   1145
3371: caAllocVector   F520   1499 1651 1663 1786
3370: caCheckSum      F51E   2032
3368: caDirectoryDMA  F51A   1582 1855 2056 2067 3077
3364: caDirMaxValue   F514   1571 1633 1670 2086
3369: caDiskParamBlock F51C   1523 1586
2024: CalculateCheckSum EE97   1914
3373: caListSize      0008   1583
3372: caListSizeEnd   F522   3373
3367: caListSizeStart F51A   3373
0091: CARET           005E   0806
0800: CaretOut        E940   1003 1084
3366: caSector        F518   1577 1833 1932 2002
3394: caSkewTable     F531   1581
3365: caTrack         F516   1574 1829 1936 1996
0148: CCPEntry        E000   0150 0154
0139: CCPLength       0800   0143 0150 0154
0896: CheckCTL_S      E9A4   0887
2241: CheckRODirectory EF97   2543 2594
2246: CheckROFile     EF9A   2325
2255: CheckWrite      EFA4   2323 2528 2553 2586
2854: ClearModuleNum  F2BD   2157 2178 2224
2604: CloseDirEntry   F1A1   1290 2165 2460
2625: CloseDirEntry1  F1C6   2671
2639: CloseDirEntry2  F1D4   2636
2645: CloseDirEntry3  F1DA   2641
2651: CloseDirEntry4  F1E1   2628
2667: CloseDirEntry5  F1F6   2648
2692: CloseDirEntryEnd F210   2681
2699: CloseDirEntryError F219   2647 2659 2664
0071: COLON           003A
1143: columnPosition  EAB9   0826 0852 0920 0940 1098
0066: COMMA           002C
3058: CompareExtents  F3D9   3003
2054: ComputeCheckSum EEBF   2031
2058: ComputeCheckSum0 EEC5   2062
0125: ComTail         0080   0126
0127: ComTailChars    0082
0126: ComTailCount    0081   0127
0874: ConBreak        E984   0728 0838
0907: ConBreak0       E9B2   0899
0909: ConBreak1       E9B5   0877
0760: ConIn           E919   0496 0955 3296
0835: ConsoleOut      E963   0807 0820 0825 0917 0925 0930 0933 1026
3090: CopyDir         F3FD   2143 2546 3087
3076: CopyDirEntryToUser F3EA   2183 2193
3084: CopyFCB         F3F6   2580
3409: cpmRecord       F541   2111 2126 2282 2292 2327 2411 2448 2838 3109
0227: cpmRecordSize   0080   0229 0232 0234 2055 3080 3319
0056: CR              000D   0773 0929 0960 1025
0039: CTRL_C          0003   0902 1008 3265
0040: CTRL_E          0005   0972
0041: CTRL_H          0008   0779 0966 1112
0042: CTRL_K          000B
0043: CTRL_L          000C
0044: CTRL_P          0010   0886 0975
0045: CTRL_R          0012   0984
0046: CTRL_S          0013   0898
0047: CTRL_U          0015   0981
0048: CTRL_X          0018   0978
0049: CTRL_Z          001A
3410: currentBlock    F543   1921 1928 2368 2815 2820 2829 2842
3346: currentDisk     F50C   1462 1485 1530 1539 1561 1609 2263 2879 3289
3342: currentUserNumber F50B   0741 0747 1688 2888
0067: DASH            002D
0261: DataBlocks      02C7   0271
0260: DataSectors     0B1C   0261
2585: DeleteFile      F17F   2200
2589: DeleteFile1     F187   2601
1093: DeleteTheLine   EA86   0979
1096: DeleteTheLine1  EA87   1103
3177: DEminusHL2HL    F450   1891 2028
3413: dirBlockIndex   F545   1907 2068
0232: DirBuffSize     0080
0247: DirectoryBlockCount 0002   0272
0234: DirectoryEntryPerRecord 0004   0275
3397: directoryFlag   F535   2849 2947 3021
3319: dirEntriesPerRecord 0004   3321
3414: dirEntryIndex   F546   1847 1867 1887 1889 1899 1918 2084 3017
3321: dirEntryMask    0003   1900 3018
3320: dirEntryShift   0002   1919
0231: DirEntrySize    0020   0234 0272
2848: DirLocationToReturnLoc F2B6   1518 2201 2235
3415: dirRecord       F548   1922 2025 2034
0219: DiskCommandBlock 0046
0218: DiskControlByte 0045
0221: DiskControlTable 0040
2309: DiskEOF         EFF9   2289 2296 2302
0413: diskf           000B
3399: diskMapIndex    F537   2345 2375
2277: DiskRead        EFBE   1219
0223: DiskReadCode    0001
0228: diskSectorSize  0200   0229 0250 0258
0217: DiskStatusLocation 0043
2319: DiskWrite       F001   1226
2334: DiskWrite1      F01E   2329
2392: DiskWrite2      F06F   2380
2398: DiskWrite3      F071   2338
2419: DiskWrite4      F091   2414
2430: DiskWrite5      F09E   2423
2449: DiskWrite6      F0BC   2445
2451: DiskWrite7      F0BE   2433 2437
0224: DiskWriteCode   0002
2314: DiskWriteSeq    EFFC   2216
3286: displayAndWait  F4C7   3264 3282
0130: DMABuffer       0080   1463 3356
0060: DOLLAR          0024   0788 1694
2261: DoNotWrite      EFAB   2256 2607
0273: dpb3hdAL0       00C0
0274: dpb3hdAL1       0000
0269: dpb3hdBLM       000F
0268: dpb3hdBSH       0004
0275: dpb3hdCKS       0020
0272: dpb3hdDRM       007F   0275
0271: dpb3hdDSM       02C6
0270: dpb3hdEXM       0000
0277: dpb3hdNOH       0002
0276: dpb3hdOFF       0001
0267: dpb3hdSPT       0090
3381: dpbBLM          F525   2836
3380: dpbBSH          F524   2828 3107
3386: dpbCKS          F52D   2027
3385: dpbDABM         F52B   1661
3384: dpbDRM          F529   1631 1885
3383: dpbDSM          F527   1591 1644 2778
3388: dpbEnd          F531   3389
3382: dpbEXM          F526   2116 2474 3061
3387: dpbOFF          F52F   1822 1989
3389: dpbSize         000F   1589
3379: dpbSPT          F522   1954 1968
3378: dpbStart        F522   1588 3389
0445: DUMMY           E8A6   0440 0441
3300: emDisk          F4EC   3291
3299: emDisk0         F4E0   3292
3301: emPermanent     F4F0   3260 3263
3332: emptyDir        00E5   1684 2596 2967 3353
3353: emptyFCB        F50D   2556
3304: emReadOnlyDisk  F507   3274
3303: emReadOnlyFile  F502   3278
3302: emSelection     F4FB   3270
0134: END_OF_FILE     001A
3016: EndDirElementSearch F3AA   2982
1866: EndOfDirectory  EDE0   1369 1680 2139 2462 2497 2506 2540 2560 2591 2615 2898 2961
0037: EndOfMessage    0000
1019: EndRead         EA36   0961 0964
3405: entryDisk       F53D   0386 2880
0289: EOD             FFFF   1846
0075: EQUAL_SIGN      003D
3262: erPermanent     F4A6   3254
3259: erPermanentNoWait F4A0   2727 2734
3273: erReadOnlyDisk  F4B8   3256
3277: erReadOnlyFile  F4BE   3257
3242: errPermanent    F48D
3236: errReadOnlyDisk F481   2258
3239: errReadOnlyFile F487   2252
3233: errSelect       F47B   1546
3269: erSelection     F4B2   3255
3254: evPermanent     F498   3243
3256: evReadOnlyDisk  F49C   3237
3257: evReadOnlyFile  F49E   3240
3255: evSelection     F49A   3234
0058: EXCLAIM_POINT   0021
1147: exitParameterByte EABD   0505 0614 0729 0742 1294 1304 1315 1322 1335 1486 1698 2294 2364 2399 2442 2516 2606 2700 2850 3019 3034 3054 3230
1148: exitParameterWord EABD   0342 0393 0545 0634 1479 1500 1511 1524
3408: extentValue     F540   2118 3121
0026: FALSE           0000   0892 1064 1224 1597 2320 2959
0122: FCB1            005C   0123
0123: FCB2            006C
3395: fcbCopiedFlag   F533   2459 2477 2694
3406: fcbDisk         F53E   0344 0381 2882
3315: fcbDiskMapIndex 0010   1712 1715 2371 2535 2544 2618 2624 3148
3311: fcbExtIndex     000C   1273 1297 1356 1408 2136 2142 2465 2485 2530 2545 2587 2673 2685 2916 2991 3040
3310: fcbHiddenfileIndex 000A
3308: fcbLength       0020   1715 2568 2624 2673 3086 3319 3333
3314: fcbRCIndex      000F   1373 2100 2103 2685 2919 2938
3407: fcbRecordCount  F53F   2114 2130 2283 2412
3309: fcbROfileIndex  0009   2247
3312: fcbS1Index      000D   2575 2988
3313: fcbS2Index      000E   1279 1300 1425 2485 2862
3322: fcbShift        0005   1901
0167: fCloseFile      0010
0158: fConsoleIn      0001
0159: fConsoleOut     0002
0170: fDeleteFile     0013
0162: fGetConsoleStatus 000B
0176: fGetCurrentDisk 0019
0175: fGetLoginVector 0018
0178: fGetSetUserNumber 0020
0163: fGetVersion     000C
2356: FirstBlock      F03D   2348
0173: fMakeFile       0016
0166: fOpenFile       000F
0160: fPrintString    0009
0171: fReadSeq        0014
0161: fReadString     000A
0174: fRenameFile     0017
3404: fResel          F53C   0345 0375 2870
0164: fResetSystem    000D
0168: fSearchFirst    0011
0169: fSearchNext     0012
0165: fSelectDisk     000E
0177: fSetDMA         001A
0443: functionCount   0028   0354
0400: functionTable   E854   0359 0413 0443
0172: fWriteSeq       0015
1759: GetAllocBit     ED77   1801 2771 2789
1790: GetAllocBitl    ED98   1793
2810: GetBlockNumber  F28A   2300 2335
2760: GetClosestBlock F250   2357
2066: GetDirElementAddress EECC   1372 1683 1710 2242 2595 2619 2907 2975 3096
3157: GetDiskMap16Bit F445   3153
3106: GetDiskMapIndex F412   2344 2811
3110: GetDiskMapIndex1 F419   3114
3122: GetDiskMapIndex2 F427   3129
3132: GetDiskMapIndex3 F430   3126
3146: GetDiskMapValue F432   2352 2814
3038: GetExtentAddress F3C4   2115 2903
2098: GetFcbAddress   EEEB   2109 2123
1355: GetFileSize     EB8C   1190
1368: GetFileSize1    EB9E   1396
1394: GetFileSize2    EBC0   1387
1397: GetFileSizeExit EBC6   1370
2860: GetModuleNum    F2C3   1329 2425 2610 2855 3046
1402: GetRandomRecordPosition EBC8   1344 1374
3246: GoToError       F493   3235 3238 3241 3244 3261
0076: GREATER_THAN    003E
0059: HASH_TAG        0023   0916
3317: highestRecordNumber 007F   2328 2432
1820: Home            EDB0   1668 2953
1116: IgnoreTheLine   EAA4   0982
3356: InitDAMAddress  F512   1464 1493 1851 3079
1643: InitDisk        ECEB   1556
1653: InitDisk0       ECF9   1659
1677: InitDisk1       ED1A   1686 1704
1699: InitDisk2       ED3E   1690 1695
0114: IOBYTE          0003   0633 0653
2819: IsAllocated     F297   2301 2336
0980: IsItDeleteTheLineU EA11
0977: IsItDeleteTheLineX EA0C
0974: IsItPrintToggle EA07
1065: IsItPrintToggle1 EA68   1063
0968: IsItRubout      E9FD
0971: IsPhysicalEOL   EA02
0772: IsPrintableASCII E924   0497 0802
1050: ItIsPhysicalEOL EA55   0973
1057: ItIsPrintToggle EA5D   0976
1038: ItIsRubout      EA4A   0970
1137: keyboardByte    EAB6   0761 0875 0908
0062: L_PAREN         0028
0079: LEFT_ARROW      005F
0095: LEFT_CURLY      007B
0143: LengthInBytes   2000   0144 0148 0258
0144: LengthInK       0009
0074: LESS_THAN       003C
0055: LF              000A   0775 0858 0931 0962
1079: LL1             EA76   1087
0029: LO_NIBBLE_MASK  000F   0746 1421
3355: loggedDisks     F510   1460 1478 1538 1551 1555
2552: MakeNewFile     F149   1313 2226 2504
2570: MakeNewFile1    F16B   2574
3327: maxExtValue     001F   2469 3071
0146: MemorySize      0040   0148
2739: Merge           F242   2652 2654
3328: moduleMask      000F   2490
3209: Move            F46B   1584 1590 2912 3081 3098
3211: Move0           F46C   3218
0259: myOffset        0001   0260 0276
3330: nameLength      000F   2180 2495 2566 2568 2613 2896
2021: NewCheckSum     EE95   2712
3333: NEXT_RECORD     0020   1268 1343 2103 2910 3334
2886: NoSelect        F2F0   2877
0904: NothingWaiting  E9B0   0895
0051: NULL            0000
0243: NumberOfHeads   0002   0254 0256 0267 0277
0240: NumberOfLogicalDisks 0004
0028: OFF             0000
0027: ON              FFFF
2895: OpenFile        F2F9   1303 2159
2902: OpenFileCopyFCB F302   2512
2457: OpenNextExt     F0C1   2290 2440
2494: OpenNextExt1    F0F5   2479
2511: OpenNextExt2    F113   2481 2498
2513: OpenNextExt3    F116   2508
2520: OpenNextExtError F11E   2491 2502 2507
2484: OpenNextModule  F0EA   2471
2936: OpenRecordCount F333   2932 2934
1146: paramDE         EABB   0334 0379 0676 0942 1021 1076 1237 1342 1359 1492 2099 2173 2190 2324 2370 2464 2533 2554 2557 2562 2622 2861 2871 2889 2909 2937 2950 3039 3093 3147
1145: paramE          EABA   0336 0387 0738 1529 2875
0061: PERCENT         0025
0068: PERIOD          002E
0117: Pg0CurentDisk   0004
0116: Pg0CurentUser   0004   0117
0065: PLUS_SIGN       002B
0786: Print           E933   0679 0795 3293 3295
1139: printEchoFlag   EAB7   0846 0888 1060
0077: QMARK           003F   2175 2984
2181: QMarkSelect     EF59   2176
0063: R_PAREN         0029
0110: RAM             0000   0112 0113 0114 0116 0119 0122 0125 0130 0132
3334: RANDOM_REC_FIELD 0021   1239 1345 1360
1216: RandomDiskRead  EAD6   1171
1223: RandomDiskWrite EADF   1183
1233: RandomSeek      EAE8   1218 1225
1287: RandomSeekClose EB2C   1277
1332: RandomSeekError EB71   1266
1325: RandomSeekErrorBadSeek EB6A   1296 1312 1317
1319: RandomSeekExit  EB64   1286 1306
2731: ReadBuffer      F23A   1879 2306
1884: ReadDirectory   EDF2   1679 2960
1898: ReadDirectory0  EE07   1892
1902: ReadDirectory1  EE0E   1905
1877: ReadDirRecord   EDE9   1912
0999: ReadEchoRubOut  EA1E   1047
3396: readModeFlag    F534   2279 2321 2500
0951: ReadNext        E9E5   1016 1042 1068 1090
0954: ReadNext0       E9E7   1035 1054
3354: ReadOnlyVector  F50E   1459 1510 1624 1629 2262
2271: ReadSeq         EFB9   2208
0939: ReadString      E9D8   0709 1100 1122
2299: RecordOK        EFE3   2286
0252: RecordsPerBlock 0010
0236: RecordsPerExtent 0080   2288 2935 3317
0229: recordsPerSector 0004   0252 0267
2527: Rename          F124   2234
2539: Rename1         F135   2549
1071: RepeatLine      EA6D   0985
2868: Reselect        F2CC   1170 1182 1189 1516 2158 2164 2179 2191 2199 2207 2215 2225 2233
2795: ReturnBlockNumber F27E   2773 2791
2805: ReturnBlockZero F286   2783
0374: ReturnToCaller  E82F   0348
0390: ReturnToCaller1 E84A   0377 0383 0612
1811: RotateAndReplace EDA9   1805 1814 2799
0080: RUBOUT          007F   0969
1709: ScanDiskMap     ED49   1702 2598
1717: ScanDiskMap0    ED53   1749
1733: ScanDiskMap1    ED66   1725
1742: ScanDiskMap2    ED6C   1731
2945: Search4DirElement F33C   1357 2137 2182 2496 2531 2559 2588 2614 2897
3000: Search4Ext      F39A   2993
2958: Search4NextDirElement F354   1395 2144 2192 2548 2600 2954 2996 3005
2974: Search4NextDirElement1 F371   2968
2979: Search4NextLoop F37A   3013
3008: Search4NextOK   F3A3   2985 2989 2997
3401: searchAddress   F539   2189 2951 2964
3031: SearchDone      F3BB   2962 2973
3400: searchLength    F538   2948 2976
0281: SectorMask      0003
0246: SectorsPerBlock 0004   0250 0252 0255 0261 0281
0256: SectorsPerCylinder 0024   0259 0260
0245: SectorsPerTrack 0012   0254 0256 0267
1925: Seek            EE34   1923 2305 2405
1946: Seek0           EE47   1963
1965: Seek1           EE5D   1951 1980
1982: Seek2           EE6F   1974
3100: SeekAndCopy     F40C
2705: SeekCopy        F21E   2695
1917: SeekDir         EE23   1911 2706 3101
1537: Select          EC55   1466 1534
1528: SelectCurrent   EC49   0388 1472 2885
1560: SelectDisk      EC79   1544
1599: SelectDisk1     ECBD   1596
0073: SEMICOLON       003B
3398: seqReadFlag     F536   1235 2124 2273 2316 2435
2827: SetActualRecordAdd F29D   2304 2404
2831: SetActualRecordAdd1 F2A3   2834
1799: SetAllocBit     ED9E   1745
2135: SetAttributes   EF21   1517
2138: SetAttributes1  EF26   2145
1607: SetCurrentDiskBit ECC1   1554 1628
1850: SetDataDMA      EDD1   1465 1494 1880 2716
1854: SetDirDMA       EDD7   1878 2713
2072: SetDirectoryEntry EED5   1703 2578
1623: SetDiskReadOnly ECD4   1505 2045
1857: SetDMA          EDDA   1852
1845: SetEndDirectory EDCA   1675 1894 2952 3032
3045: SetFileWriteFlag F3CC   1337 2522 2582 2914
3052: SetLowReturnTo1 F3D3   2310 2330 2521
2049: SetNewCheckSum  EEBD   2038
1341: SetRandomRecord EB79   1196
2108: SetRecordVars   EEF8   2281 2326 2514
0745: SetUserNumber   E913   0740
3200: ShiftLeftHLbyC  F464   1612
3202: ShiftLeftHLbyC0 F465   3206
3186: ShiftRightHLbyC F457   1541 1647 1920 2265
3188: ShiftRightHLbyC0 F458   3198
0928: showCRLF        E9CE   0918 1053 3288
0915: showHashCRLF    E9B8   1074 1117
0919: showHashCRLF1   E9C0   0926
3403: single          F53B   1593 1723 2373 2626 3151
0069: SLASH           002F
0052: SOH             0001
0057: SPACE           0020   0781 0824 0855 0924 1108 1118 1120
0288: STACK_SIZE      0020   3421
3421: stackBottom     F54A
1142: startingColumn  EAB8   0921 0941 1097
2083: StillInDirectory EEDE   2043 2073 2971
0258: SystemSectors   0011   0259
0054: TAB             0009   0777 0819
0817: TabOut          E950   0502 0524 0793 0803
0823: TabOut0         E956   0828
2763: TestLeft        F252   2794
2777: TestRight       F263   2766
0893: ToggleFlag1     E9A1   0891
0120: TopRAM          0007
0255: TotalNumberOfBlocks 02D0
0254: TotalNumberOfSectors 0B40   0255 0260
0132: TPA             0100
0244: TracksPerHead   0050   0254
0025: TRUE            FFFF   0889 0910 1061 1217 1594 1600 1678 2022 2278 2693 2869
0078: UNDER_SCORE     005F
2122: UpdateRecordVars EF0F   2307 2439 2452
1135: usersStack      EAB4   0338 0391
2163: vCloseFile      EF40   0418
1188: vComputeFileSize EACB   0437
0495: vConsoleIn      E8AA   0402
0523: vConsoleOut     E8BB   0403
2198: vDeleteFile     EF6E   0421
0600: vDirectConIO    E8CE   0407
0609: vDirectConIO1   E8D6   0603
0287: VERSION         0020   3229
2171: vFindFirst      EF46   0419
2188: vFindNext       EF5F   0420
1498: vGetAllocAddr   EC28   0429
0727: vGetConsoleStatus E8FD   0412
1484: vGetCurrentDisk EC18   0427
1522: vGetDiskParamBlock EC42   0433
0632: vGetIOBYTE      E8E4   0408
1477: vGetLoginVector EC11   0426
1509: vGetRoVector    EC32   0431
0737: vGetSetUserNumber E904   0434
3228: vGetVersion     F475   0414
0577: vListOut        E8CA   0406
2223: vMakeFile       EF85   0424
2156: vOpenFile       EF37   0417
0675: vPrintString    E8F0   0410
0562: vPunchOut       E8C6   0405
0543: vReaderIn       E8BF   0404
1169: vReadRandom     EABF   0435
2206: vReadSeq        EF77   0422
0708: vReadString     E8F9   0411
2232: vRenameFile     EF8E   0425
1201: vResetDrive     EAD4   0439
1457: vResetSystem    EBF5   0415
1471: vSelectDisk     EC0E   0416
1491: vSetDMA         EC1F   0428
1515: vSetFileAttributes EC39   0432
0652: vSetIOBYTE      E8EB   0409
1195: vSetRandomRecord EAD1   0438
0463: vSystemReset    E8A7   0401
1504: vWriteProtectDisk EC2F   0430
1181: vWriteRandom    EAC5   0436
1209: vWriteRandom0Fill EAD5   0442
2214: vWriteSeq       EF7E   0423
3281: waitB4boot      F4C1   3271 3275
0112: WarmBoot        0000   0903 1012 3266 3283
0032: WORD            0002   1146 1148
0192: WriteAllocated  0000   2337
2724: WriteBuffer     F232   2408 2715
0194: WriteCleanBuffer 0002   2393
2711: WriteDir        F224   2599 2707 3102
0193: WriteDirectory  0001
3329: writeFlagMask   0080   2611 3047
3430: Z_HighestLocation F58A   3431
3431: Z_MemoryLeft    0075
0036: ZERO            0000
