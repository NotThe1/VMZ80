0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800         ; 2017-12-28 Started to refactor to Z80 idiom
0006: E800         ; 2017-03-31 added vector for BDOS Call 5 -ListOut
0007: E800         ; 2017-03-02 Refactored the CP/M Suite
0008: E800         ; 2017-02-12 fixed allocate 16 bit problem
0009: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0010: E800         ; 2014-03-14  :  Frank Martyn
0011: E800
0012: E800
0013: E800                        Include ./stdHeader.Z80
0014: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0015: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0016: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0017: E800         ; stdHeader.asm
0018: E800         ; standard equates
0019: E800
0020: E800         ; 2017-03-02 Refactored the CP/M Suite
0021: E800
0022: E800
0023: E800             TRUE       EQU    -1                   ; not false
0024: E800             FALSE      EQU    0000H
0025: E800             ON         EQU    -1
0026: E800             OFF        EQU    0000H
0027: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0028: E800
0029: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0030: E800             WORD       EQU    2                    ; number of bytes for "word" type
0031: E800
0032: E800
0033: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0034: E800             ZERO       EQU    00H                  ; Zero
0035: E800             EndOfMessage EQU    00H
0036: E800
0037: E800             CTRL_C     EQU    03H                  ; ETX
0038: E800             CTRL_E     EQU    05H                  ; physical eol
0039: E800             CTRL_H     EQU    08H                  ; backspace
0040: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0041: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0042: E800             CTRL_P     EQU    10H                  ; prnt toggle
0043: E800             CTRL_R     EQU    12H                  ; repeat line
0044: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0045: E800             CTRL_U     EQU    15H                  ; line delete
0046: E800             CTRL_X     EQU    18H                  ; =ctl-u
0047: E800             CTRL_Z     EQU    1AH                  ; end of file
0048: E800
0049: E800             NULL       EQU    00H                  ; Null
0050: E800             SOH        EQU    01H                  ; Start of Heading
0051: E800             BELL       EQU    07H                  ; Bell
0052: E800             TAB        EQU    09H                  ; Tab
0053: E800             LF         EQU    0AH                  ; Line Feed
0054: E800             CR         EQU    0DH                  ; Carriage Return
0055: E800             SPACE      EQU    20H                  ; Space
0056: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0057: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0058: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0059: E800             PERCENT    EQU    25H                  ; Percent Sign
0060: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0061: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0062: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0063: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0064: E800             COMMA      EQU    2CH                  ; Comma
0065: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0066: E800             PERIOD     EQU    2EH                  ; Period
0067: E800             SLASH      EQU    2FH                  ; /
0068: E800             ASCII_ZERO EQU    30H                  ; zero
0069: E800             COLON      EQU    3AH                  ; Colon
0070: E800
0071: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0072: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0073: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0074: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0075: E800             QMARK      EQU    3FH                  ; Question Mark
0076: E800             UNDER_SCORE EQU    5FH                  ; under score _
0077: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0078: E800             RUBOUT     EQU    7FH                  ; Delete Key
0079: E800
0080: E800
0081: E800             ASCII_A    EQU    'A'
0082: E800             ASCII_C    EQU    'C'
0083: E800             ASCII_K    EQU    'K'
0084: E800             ASCII_N    EQU    'N'
0085: E800             ASCII_Q    EQU    'Q'
0086: E800             ASCII_R    EQU    'R'
0087: E800             ASCII_W    EQU    'W'
0088: E800             ASCII_Y    EQU    'Y'
0089: E800             CARET      EQU    '^'
0090: E800             ASCII_LO_A EQU    'a'
0091: E800             ASCII_LO_K EQU    'k'
0092: E800             ASCII_LO_P EQU    'p'
0093: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0094: E800
0095: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0096: E800                        Include ./osHeader.Z80
0097: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0098: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0099: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0100: E800         ; osHeader.Z80
0101: E800
0102: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0103: E800         ; 2017-03-02 Refactored the CP/M Suite
0104: E800
0105: E800         ; Contains the Equates used by the CP/M system
0106: E800
0107: E800         ;------------------------Page Zero Constants ---------------------------------
0108: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0109: E800
0110: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0111: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0112: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0113: E800
0114: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0115: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0116: E800
0117: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0118: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0119: E800
0120: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0121: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0122: E800
0123: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0124: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0125: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0126: E800         ;-----------------------------------------------------------------------
0127: E800
0128: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0129: E800         ;-----------------------------------------------------------------------
0130: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0131: E800         ;-----------------------------------------------------------------------
0132: E800             END_OF_FILE EQU    1AH                  ; end of file
0133: E800         ;-----------------------------------------------------------------------
0134: E800
0135: E800         ;--------------- CP/M Constants -----------------------------------------
0136: E800
0137: E800             CCPLength  EQU    0800H                ; Constant
0138: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0139: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0140: E800
0141: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0142: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0143: E800
0144: E800             MemorySize EQU    64
0145: E800
0146: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0147: E800
0148: E800             BDOSBase   EQU    CCPEntry + CCPLength
0149: E800             BDOSEntry  EQU    BDOSBase
0150: E800
0151: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0152: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0153: E800         ;-----------------------------------------------------------------------
0154: E800
0155: E800         ;------------------- BDOS System Call Equates --------------------------
0156: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0157: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0158: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0159: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0160: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0161: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0162: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0163: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0164: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0165: E800             fCloseFile EQU    10H                  ; closef - Close File
0166: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0167: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0168: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0169: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0170: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0171: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0172: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0173: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0174: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0175: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0176: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0177: E800         ;-----------------------------------------------------------------------
0178: E800
0179: E800
0180: E800
0181: E800
0182: E800
0183: E800         ;*******************************************************************************
0184: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0185: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0186: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0187: E800         ; sector write) or to an allocation block that has already been allocated to a
0188: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0189: E800         ;*******************************************************************************
0190: E800             WriteAllocated EQU    00H
0191: E800             WriteDirectory EQU    01H
0192: E800             WriteCleanBuffer EQU    02H
0193: E800
0194: E800
0195: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0196: E800                        Include ./diskHeader.Z80
0197: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0198: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0199: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0200: E800         ; diskHeader.asm
0201: E800
0202: E800         ; 2017-03-02 Refactored the CP/M Suite
0203: E800
0204: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0205: E800
0206: E800         ; Contains the Equates used by the CP/M system to handle disks
0207: E800
0208: E800
0209: E800         ;*******************************************************************************
0210: E800         ;
0211: E800         ;     Disk related values
0212: E800         ;
0213: E800         ;
0214: E800         ;*******************************************************************************
0215: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0216: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0217: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0218: E800         ; for boot
0219: E800             DiskControlTable EQU    0040H
0220: E800
0221: E800             DiskReadCode EQU    01H                  ; Code for Read
0222: E800             DiskWriteCode EQU    02H                  ; Code for Write
0223: E800
0224: E800
0225: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0226: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0227: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0228: E800
0229: E800             DirEntrySize EQU    20H                  ; (32)
0230: E800             DirBuffSize EQU    cpmRecordSize
0231: E800
0232: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0233: E800
0234: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0235: E800
0236: E800
0237: E800         ;-------------------------------------------------------------------------------------
0238: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0239: E800
0240: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0241: E800             NumberOfHeads EQU    02H                  ; number of heads
0242: E800             TracksPerHead EQU    50H                  ; 80
0243: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0244: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0245: E800             DirectoryBlockCount EQU    02H                  ;
0246: E800         ;-----------------------------------------------------------------------
0247: E800
0248: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0249: E800
0250: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0251: E800
0252: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0253: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0254: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0255: E800
0256: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0257: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0258: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0259: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0260: E800
0261: E800         ;-----------------------------------------------------------------------
0262: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0263: E800         ;-----------------------------------------------------------------------
0264: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0265: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0266: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0267: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0268: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0269: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0270: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0271: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0272: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0273: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0274: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0275: E800             dpb3hdNOH  EQU    NumberOfHeads
0276: E800
0277: E800         ;*******************************************************************************
0278: E800
0279: E800             SectorMask EQU    SectorsPerBlock - 1
0280: E800
0281: E800         ;***************************************************************************
0282: E800
0283: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0284: E800
0285: E800             VERSION    EQU    20H                  ; Version 2.0
0286: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0287: E800             EOD        EQU    -1                   ; End of Directory
0288: E800
0289: E800         ;************************ BIOS Function Constants ***************************;
0290: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	              ;
0291: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                  ;
0292: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function             ;
0293: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function              ;
0294: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function             ;
0295: E800             bcList     EQU    BIOSStart+3*5        ; List Output function                ;
0296: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function               ;
0297: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function               ;
0298: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                  ;
0299: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function                ;
0300: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                  ;
0301: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                 ;
0302: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                    ;
0303: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                  ;
0304: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                 ;
0305: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function                ;
0306: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                    ;
0307: E800         ;************************ BIOS Function Constants ***************************;
0308: E800
0309: E800         ;=============================================================================;
0310: E800         ;	BDOS                                                                      ;
0311: E800         ; Calling into   :                                                            ;
0312: E800         ;                	Register  C - Contains BDOS Function Code                 ;
0313: E800         ;                	Register  A - Holds the Byte argument if any              ;
0314: E800         ;                	Register DE - Holds the Word argument if any              ;
0315: E800         ; Returning from :                                                            ;
0316: E800         ;                	Register  A - The Byte return value if any                ;
0317: E800         ;                	Register HL - The Word return value if any                ;
0318: E800         ;                   ( Register A=L and B=H)                                   ;
0319: E800         ;=============================================================================;
0320: E800
0321: E800
0322: E800                        ORG    BDOSBase
0323: E800
0324: E800         ;===========================BDOS Entry========================================;
0325: E800         ;BDOSEntry:                                                                   ;
0326: E800         ;
0327: E800             BdosStart:                      ;
0328: E800         ;	LD		A,C                                                               ;
0329: E800         ; 	LD		(FunctionValue),A			; Save the function number            ;
0330: E800         ;
0331: E800         ; Save Calling Arguments                                                      ;
0332: E800 ED 53 C3 EA               LD     (paramDE),DE         ; Save the Word Argument              ;
0333: E804 7B                     LD     A,E                  ;
0334: E805 32 C2 EA               LD     (paramE),A           ; Save the Byte argument              ;
0335: E808         ; Save users Stack pointer                                                    ;
0336: E808 ED 73 BC EA               LD     (usersStack),SP      ; We will use our own stack           ;
0337: E80C         ;
0338: E80C         ; initialize variables                                                        ;
0339: E80C 21 00 00               LD     HL,0000H             ;
0340: E80F 22 C5 EA               LD     (exitParameterWord),HL ; Assume all is well for return       ;
0341: E812 AF                     XOR    A                    ;
0342: E813 32 46 F5               LD     (fcbDisk),A          ; Initialize to 00                    ;
0343: E816 32 44 F5               LD     (fResel),A           ; Clear re selection flag             ;
0344: E819         ;
0345: E819         ; Set up for return to caller when Function Completes                         ;
0346: E819 21 2F E8               LD     HL,ReturnToCaller    ;
0347: E81C E5                     PUSH   HL                   ;Set up to ReturnToCaller             ;
0348: E81D         ;
0349: E81D         ; is it a valid fuction number ?	                                          ;
0350: E81D         ;	LD		A,(FunctionValue)			; Get the Function Number             ;
0351: E81D 79                     LD     A,C                  ;
0352: E81E FE 28                  CP     functionCount        ; make sure its a good number         ;
0353: E820 D0                     RET    NC                   ; exit if not a valid function        ;
0354: E821         ;
0355: E821         ; Calculate the index and get vector to go to	                              ;
0356: E821 4B                     LD     C,E                  ; Assume byte argument                ;
0357: E822 21 56 E8               LD     HL,functionTable     ; Get table base                      ;
0358: E825 5F                     LD     E,A                  ; Function number in E                ;
0359: E826 16 00                  LD     D,0                  ;
0360: E828 19                     ADD    HL,DE                ; Have byte location                  ;
0361: E829 19                     ADD    HL,DE                ;  but we want a Word offset          ;
0362: E82A 5E                     LD     E,(HL)               ; Get LSB of vector                   ;
0363: E82B 23                     INC    HL                   ;
0364: E82C 56                     LD     D,(HL)               ; Get MSB of vector                   ;
0365: E82D EB                     EX     DE,HL                ; Vector now in HL                    ;
0366: E82E         ;
0367: E82E         ; Load vector into HL                                         ;
0368: E82E E9                     JP     (HL)                 ; Move to Program Counter             ;
0369: E82F         ;===========================BDOS Entry========================================;
0370: E82F         ;===========================BDOS Exit ========================================;
0371: E82F         ;arrive here at end of processing to return to user                          ;
0372: E82F             ReturnToCaller:                      ;
0373: E82F 3A 44 F5               LD     A,(fResel)           ; get re-selection flag               ;
0374: E832 B7                     OR     A                    ; is it set?                          ;
0375: E833 CA 4C E8               JP     Z,ReturnToCaller1    ;
0376: E836         ;re-selection  may have taken place                                          ;
0377: E836 2A C3 EA               LD     HL,(paramDE)         ;
0378: E839 36 00                  LD     (HL),0               ;
0379: E83B 3A 46 F5               LD     A,(fcbDisk)          ;
0380: E83E B7                     OR     A                    ; Disk = 0?                           ;
0381: E83F CA 4C E8               JP     Z,ReturnToCaller1    ; exit if yes                  		  ;
0382: E842         ;
0383: E842 77                     LD     (HL),A               ;
0384: E843 3A 45 F5               LD     A,(entryDisk)        ; get back original Disk              ;
0385: E846 32 C2 EA               LD     (paramE),A           ; and select it                       ;
0386: E849 CD 51 EC               CALL   SelectCurrent        ;
0387: E84C         ;
0388: E84C             ReturnToCaller1:                      ;
0389: E84C 2A BC EA               LD     HL,(usersStack)      ;
0390: E84F F9                     LD     SP,HL                ; restore callers stack               ;
0391: E850 2A C5 EA               LD     HL,(exitParameterWord) ;
0392: E853 7D                     LD     A,L                  ;
0393: E854 44                     LD     B,H                  ; BA = exitParameterWord               ;
0394: E855 C9                     RET                         ;
0395: E856         ;===========================BDOS Exit ========================================;
0396: E856
0397: E856         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++++;
0398: E856             functionTable:                      ;
0399: E856 A9 E8                  DW     vSystemReset         ;   0 - System Reset                  ;
0400: E858 AC E8                  DW     vConsoleIn           ;   1 - Console Input                 ;
0401: E85A BD E8                  DW     vConsoleOut          ;   2 - Console Output                ;
0402: E85C C1 E8                  DW     vReaderIn            ;   3 - Reader Input                  ;
0403: E85E C8 E8                  DW     vPunchOut            ;   4 - Punch Output                  ;
0404: E860 CC E8                  DW     vListOut             ;   5 - List Output                   ;
0405: E862 D0 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O            ;
0406: E864 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                  ;
0407: E866 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                  ;
0408: E868 F3 E8                  DW     vPrintString         ;   9 - Print String                  ;
0409: E86A FC E8                  DW     vReadString          ;   A - Read Console String           ;
0410: E86C 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status            ;
0411: E86E             diskf      EQU    ($-functionTable)/2  ; disk functions                      ;
0412: E86E 7D F4                  DW     vGetVersion          ;   C - Return Version Number         ;
0413: E870 FD EB                  DW     vResetSystem         ;   D - Reset Disk System             ;
0414: E872 16 EC                  DW     vSelectDisk          ;   E - Select Disk                   ;
0415: E874 3F EF                  DW     vOpenFile            ;   F - Open File                     ;
0416: E876 48 EF                  DW     vCloseFile           ;  10 - Close File                    ;
0417: E878 4E EF                  DW     vFindFirst           ;  11 - Search For First              ;
0418: E87A 67 EF                  DW     vFindNext            ;  12 - Search for Next               ;
0419: E87C 76 EF                  DW     vDeleteFile          ;  13 - Delete File                   ;
0420: E87E 7F EF                  DW     vReadSeq             ;  14 - Read Sequential               ;
0421: E880 86 EF                  DW     vWriteSeq            ;  15 - Write Sequential              ;
0422: E882 8D EF                  DW     vMakeFile            ;  16 - Make File                     ;
0423: E884 96 EF                  DW     vRenameFile          ;  17 - Rename File                   ;
0424: E886 19 EC                  DW     vGetLoginVector      ;  18 - Return Login Vector           ;
0425: E888 20 EC                  DW     vGetCurrentDisk      ;  19 - Return Current Disk           ;
0426: E88A 27 EC                  DW     vSetDMA              ;  1A - Set DMA address               ;
0427: E88C 30 EC                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)              ;
0428: E88E 37 EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk            ;
0429: E890 3A EC                  DW     vGetRoVector         ;  1D - Get Read/Only Vector          ;
0430: E892 41 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??        ;
0431: E894 4A EC                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)    ;
0432: E896 07 E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code             ;
0433: E898 C7 EA                  DW     vReadRandom          ;  21 - Read Random                   ;
0434: E89A CD EA                  DW     vWriteRandom         ;  22 - Write Random                  ;
0435: E89C D3 EA                  DW     vComputeFileSize     ;  23 - Compute File Size             ;
0436: E89E D9 EA                  DW     vSetRandomRecord     ;  24 - Set Random Record             ;
0437: E8A0 DC EA                  DW     vResetDrive          ;  25 - Reset Drive                   ;
0438: E8A2 A8 E8                  DW     DUMMY                ;  26 - Access Drive (not supported)  ;
0439: E8A4 A8 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)    ;
0440: E8A6 DD EA                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill           ;
0441: E8A8             functionCount EQU    ($-functionTable)/2  ; Number of  functions                ;
0442: E8A8         ;
0443: E8A8             DUMMY:                          ;
0444: E8A8 76                     HALT                        ;
0445: E8A9         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++++;
0446: E8A9
0447: E8A9         ;-------------------------- System Reset - 0 (0) -----------------------------;
0448: E8A9         ;  The system reset function makes CP/M do a complete reset, exactly the same ;
0449: E8A9         ; as the warm boot function invoked when you transfer control to the WARMBOOT ;
0450: E8A9         ; point. In addition to resetting the BDOS, this function reloads the CCP,    ;
0451: E8A9         ; rebuilds the allocation vectors for the currently logged disks, sets the    ;
0452: E8A9         ; DMA address (used byCP/M to address the disk read/write buffer) to 80H,     ;
0453: E8A9         ; marks all disks as being Read/Write status, and transfers control to the    ;
0454: E8A9         ; CCP. The CCP then outputs its prompt to the console.                        ;
0455: E8A9         ;																			  ;
0456: E8A9         ;			Function Code	 :	C = 00H                                       ;
0457: E8A9         ;           Entry Parameters:	None                                          ;
0458: E8A9         ;           Exit Parameters :	Does Not Return								  ;
0459: E8A9         ;																			  ;
0460: E8A9         ;-------------------------- System Reset - 0 (0) -----------------------------;
0461: E8A9             vSystemReset:
0462: E8A9 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0463: E8AC
0464: E8AC         ;*****************************************************************************;
0465: E8AC         ;								IOByte device I/O							  ;
0466: E8AC         ;*****************************************************************************;
0467: E8AC
0468: E8AC
0469: E8AC         ;-------------------------- Read Console Byte - 1 (1) ------------------------;
0470: E8AC         ;  This function reads the next byte of data from the console keyboard and    ;
0471: E8AC         ; puts it into register A. If the character input is a graphic character, it  ;
0472: E8AC         ; will be echoed back to the console. The only control characters that are    ;
0473: E8AC         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case     ;
0474: E8AC         ; of a TAB character, the BDOS outputs as many spaces as are required to      ;
0475: E8AC         ; move the cursor to the next multiple of eight columns. All of the other     ;
0476: E8AC         ; control characters, including CONTROL-C, are input but are not echoed.      ;
0477: E8AC         ;  This function also checks for CONTROL-S (XOFF) to see if console output    ;
0478: E8AC         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if      ;
0479: E8AC         ; console output should also be sent to the list device. If CONTROL-S is      ;
0480: E8AC         ; found, further output will be suspended until you type another character.   ;
0481: E8AC         ; CONTROL-P will enable the echoing of console output the first time it is    ;
0482: E8AC         ; pressed and disable it the second time. If there is no incoming data        ;
0483: E8AC         ; character, this function will wait until there is one.                      ;
0484: E8AC         ;                                                                             ;
0485: E8AC         ; This is a blocking function                                                 ;
0486: E8AC         ;																			  ;
0487: E8AC         ;																			  ;
0488: E8AC         ;			Function Code	:	C = 01H                                       ;
0489: E8AC         ;           Entry Parameters:	None                                          ;
0490: E8AC         ;           Exit Parameters :	A = Data byte from console					  ;
0491: E8AC         ;																			  ;
0492: E8AC         ;-------------------------- Read Console Byte - 1 (1) ------------------------;
0493: E8AC             vConsoleIn:
0494: E8AC CD 1C E9               CALL   ConIn                ; Don't come back without input
0495: E8AF CD 27 E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0496: E8B2 D8                     RET    C                    ; return nothing to echo
0497: E8B3
0498: E8B3 F5                     PUSH   AF                   ; Save printable character
0499: E8B4 4F                     LD     C,A
0500: E8B5 CD 55 E9               CALL   TabOut               ; Send to console. if TAB expand
0501: E8B8 F1                     POP    AF                   ; retrieve exit value
0502: E8B9
0503: E8B9 32 C5 EA               LD     (exitParameterByte),A
0504: E8BC C9                     RET
0505: E8BD
0506: E8BD         ;------------------------- Write Console Byte - 2 (2) ------------------------;
0507: E8BD         ;  This function outputs the data byte in register E to the console. As with  ;
0508: E8BD         ; function 1, if the data byte is a TAB character, it will be expanded by the ;
0509: E8BD         ; BDOS to the next column that is a multiple of eight. The BDOS also checks   ;
0510: E8BD         ; to see if there is an incoming character, and if there is, checks to see if ;
0511: E8BD         ; it is a CONTROL-S ,in which case console output is suspended or CONTROL-P,  ;
0512: E8BD         ; in which case echoing of console output to the printer is toggled on or off);
0513: E8BD         ;																			  ;
0514: E8BD         ;			Function Code	:	C = 02H                                       ;
0515: E8BD         ;           Entry Parameters:	E = Data byte to be output					  ;
0516: E8BD         ;           Exit Parameters :	None										  ;
0517: E8BD         ;																			  ;
0518: E8BD         ;------------------------- Write Console Byte - 2 (2) ------------------------;
0519: E8BD         ;BDOS put parameter in C before entering this routine
0520: E8BD             vConsoleOut:
0521: E8BD CD 55 E9               CALL   TabOut
0522: E8C0 C9                     RET
0523: E8C1
0524: E8C1         ;--------------------------- Read Reader Byte - 3 (3) ------------------------;
0525: E8C1         ;   function reads the next character from the logical "reader" device into   ;
0526: E8C1         ; register A. In practice, the physical device that is accessed depends       ;
0527: E8C1         ; entirely on how your BIOS is configured. In some systems, there is no       ;
0528: E8C1         ; reader at all; this function will return some arbitrary value such as lAH   ;
0529: E8C1         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').      ;
0530: E8C1         ; Control is not returned to the calling program until a character has been   ;
0531: E8C1         ; read.                                                                       ;
0532: E8C1         ;                                                                             ;
0533: E8C1         ; This is a blocking function                                                 ;
0534: E8C1         ;																			  ;
0535: E8C1         ;			Function Code	:	C = 03H                                       ;
0536: E8C1         ;           Entry Parameters:	None										  ;
0537: E8C1         ;           Exit Parameters :	A = Character Input							  ;
0538: E8C1         ;																			  ;
0539: E8C1         ;--------------------------- Read Reader Byte - 3 (3) ------------------------;
0540: E8C1             vReaderIn:
0541: E8C1 CD 15 F6               CALL   bcReader
0542: E8C4 32 C5 EA               LD     (exitParameterWord),A
0543: E8C7 C9                     RET
0544: E8C8
0545: E8C8         ;--------------------------- Write Punch Byte - 4 (4) ------------------------;
0546: E8C8         ;  This function is a counterpart to the Read "Reader" Byte It outputs the    ;
0547: E8C8         ; specified character from register E to the logical punch device. Again, the ;
0548: E8C8         ; actual physical device used, if any, is determined by the BIOS. There is no ;
0549: E8C8         ; set standard for this device; in some systems the punch device is a         ;
0550: E8C8         ; "bit bucket," so called because it absorbs all data that you output to it.  ;
0551: E8C8         ;																			  ;
0552: E8C8         ;			Function Code	:	C = 04H                                       ;
0553: E8C8         ;           Entry Parameters:	E = Data byte to be output					  ;
0554: E8C8         ;           Exit Parameters :	None										  ;
0555: E8C8         ;																			  ;
0556: E8C8         ;--------------------------- Write Punch Byte - 4 (4) ------------------------;
0557: E8C8         ;BDOS put parameter in C before entering this routine
0558: E8C8             vPunchOut:
0559: E8C8 CD 12 F6               CALL   bcPunch
0560: E8CB C9                     RET
0561: E8CC
0562: E8CC         ;---------------------------- Write List Byte - 5 (5) ------------------------;
0563: E8CC         ;  This function outputs the specified byte in register E to the logical list ;
0564: E8CC         ; device. As with the reader and the punch, the physical device used depends  ;
0565: E8CC         ; entirely on the BIOS.                                                       ;
0566: E8CC         ;																			  ;
0567: E8CC         ;			Function Code	:	C = 05H                                       ;
0568: E8CC         ;           Entry Parameters:	E = Data byte to be output					  ;
0569: E8CC         ;           Exit Parameters :	None										  ;
0570: E8CC         ;																			  ;
0571: E8CC         ;---------------------------- Write List Byte - 5 (5) ------------------------;
0572: E8CC         ;BDOS put parameter in C before entering this routine
0573: E8CC             vListOut:                       ; func5 (05 - 05) List Output
0574: E8CC CD 0F F6               CALL   bcList               ; direct call to BIOS
0575: E8CF C9                     RET
0576: E8D0
0577: E8D0         ;--------------------------- Direct Console I/O - 6 (6) ----------------------;
0578: E8D0         ;  This function serves double duty: it both inputs and outputs characters    ;
0579: E8D0         ; from the console. However, it bypasses the normal control characters and    ;
0580: E8D0         ; line editing features (such as CONTROL-P and CONTROL-S) normally associated ;
0581: E8D0         ; with console I( O. Hence the name "direct" (or "unadorned" as Digital       ;
0582: E8D0         ; Research describes it). If the value in register E is not OFFH, then E      ;
0583: E8D0         ; contains a valid ASCII character that is output to the console.             ;
0584: E8D0         ;  This function works well provided you never have to send a value ofOFFH or ;
0585: E8D0         ; expect to receive a value ofOOH. Ifyou do need to send or receive pure      ;
0586: E8D0         ; binary data, you cannot use this function, since these values are likely to ;
0587: E8D0         ; be part of the data stream.                                                 ;
0588: E8D0         ;                                                                             ;
0589: E8D0         ;			Function Code	:	C = 06H                                       ;
0590: E8D0         ;           Entry Parameters:	E = 0FFH for Input					  		  ;
0591: E8D0         ;								E = Other than 0FFH for Output				  ;
0592: E8D0         ;           Exit Parameters :	A = Input byte or status					  ;
0593: E8D0         ;																			  ;
0594: E8D0         ;--------------------------- Direct Console I/O - 6 (6) ----------------------;
0595: E8D0         ;BDOS put parameter in C before entering this routine
0596: E8D0             vDirectConIO:
0597: E8D0 79                     LD     A,C
0598: E8D1 3C                     INC    A
0599: E8D2 CA D9 E8               JP     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0600: E8D5         ; send byte to console
0601: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0602: E8D8 C9                     RET
0603: E8D9
0604: E8D9         ;read byte/status from console
0605: E8D9             vDirectConIO1:
0606: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0607: E8DC B7                     OR     A                    ; 00 means not data ready
0608: E8DD CA 4C E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0609: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0610: E8E3 32 C5 EA               LD     (exitParameterByte),A ; Save it
0611: E8E6 C9                     RET
0612: E8E7
0613: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ----------------------;
0614: E8E7         ; This function places the current value of the IOBYTE in register A.         ;
0615: E8E7         ;                                                                             ;
0616: E8E7         ; The IOBYTE structure:                                                       ;
0617: E8E7         ;								+-------+-------+-------+-------+             ;
0618: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |             ;
0619: E8E7         ;								+-------+-------+-------+-------+             ;
0620: E8E7         ;				Logical Device     List | Punch | Reader|Console              ;
0621: E8E7         ;                                                                             ;
0622: E8E7         ;                                                                             ;
0623: E8E7         ;			Function Code	:	C = 07H                                       ;
0624: E8E7         ;           Entry Parameters:	None					  		  			  ;
0625: E8E7         ;           Exit Parameters :	A = Current IOBYTE value					  ;
0626: E8E7         ;																			  ;
0627: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ----------------------;
0628: E8E7             vGetIOBYTE:
0629: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0630: E8EA 32 C5 EA               LD     (exitParameterWord),A ; Return it to caller
0631: E8ED C9                     RET
0632: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ----------------------;
0633: E8EE         ; This function sets the IOBYTE         ;
0634: E8EE         ;                                                                             ;
0635: E8EE         ; The IOBYTE structure:                                                       ;
0636: E8EE         ;								+-------+-------+-------+-------+             ;
0637: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |             ;
0638: E8EE         ;								+-------+-------+-------+-------+             ;
0639: E8EE         ;				Logical Device     List | Punch | Reader|Console              ;
0640: E8EE         ;                                                                             ;
0641: E8EE         ;                                                                             ;
0642: E8EE         ;			Function Code	:	C = 08H                                       ;
0643: E8EE         ;           Entry Parameters:	E = New IOBYTE value	  		  			  ;
0644: E8EE         ;           Exit Parameters :	None					  ;
0645: E8EE         ;																			  ;
0646: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ----------------------;
0647: E8EE         ;BDOS put parameter in C before entering this routine
0648: E8EE             vSetIOBYTE:
0649: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0650: E8F1 71                     LD     (HL),C               ; Place new vale in it
0651: E8F2 C9                     RET
0652: E8F3
0653: E8F3         ;---------------------- Display $ terminated String - 9 (9) ------------------;
0654: E8F3         ;  This function outputs a string of characters to the console device. The    ;
0655: E8F3         ; address of this string is in registers DE. You must make sure that the last ;
0656: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker    ;
0657: E8F3         ; for the end of the string.                                                  ;
0658: E8F3         ;  The "$" itself does not get output to the console.                         ;
0659: E8F3         ;                                                                             ;
0660: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously      ;
0661: E8F3         ; described, checks to see if there is an incoming character, and checks for  ;
0662: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered) ;
0663: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to        ;
0664: E8F3         ; the printer).                                                               ;
0665: E8F3         ;                                                                             ;
0666: E8F3         ;			Function Code	:	C = 09H                                       ;
0667: E8F3         ;           Entry Parameters:	DE = Address of the first byte of the string  ;
0668: E8F3         ;           Exit Parameters :	None					  ;                   ;
0669: E8F3         ;																			  ;
0670: E8F3         ;---------------------- Display $ terminated String - 9 (9) ------------------;
0671: E8F3             vPrintString:
0672: E8F3 2A C3 EA               LD     HL,(paramDE)         ; Get address of the string
0673: E8F6 4D                     LD     C,L
0674: E8F7 44                     LD     B,H                  ; Put it into BC for call
0675: E8F8 CD 36 E9               CALL   Print                ; out to console
0676: E8FB C9                     RET
0677: E8FC
0678: E8FC         ;-------------------------- Read Console String - A (10) ---------------------;
0679: E8FC         ;  This function reads a string of characters from the console device         ;
0680: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line      ;
0681: E8FC         ; editing is possible: the operator can backspace, cancel the line and start  ;
0682: E8FC         ; over, and use all the normal control functions. What you will ultimately    ;
0683: E8FC         ; see in the buffer is the final version of the character string entered,     ;
0684: E8FC         ; without any of the errors or control characters used to do the line editing.;
0685: E8FC         ;                                                                             ;
0686: E8FC         ;  The buffer that you define has a special format. The first byte in the     ;
0687: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.      ;
0688: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters    ;
0689: E8FC         ; were actually placed in the buffer. The following bytes contain             ;
0690: E8FC         ; the characters of the string. Character input will cease either when a      ;
0691: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,        ;
0692: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not   ;
0693: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If      ;
0694: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets        ;
0695: E8FC         ; the "characters input" byte to O. If you attempt to input more than the     ;
0696: E8FC         ; maximum number of characters, the "characters input" count will be the      ;
0697: E8FC         ; same as the maximum value allowed.                                          ;
0698: E8FC         ;                                                                             ;
0699: E8FC         ;			Function Code	:	C = 0AH                                       ;
0700: E8FC         ;           Entry Parameters:	DE = Address string buffer					  ;
0701: E8FC         ;           Exit Parameters :	String Buffer with console bytes in it        ;
0702: E8FC         ;																			  ;
0703: E8FC         ;-------------------------- Read Console String - A (10) ---------------------;
0704: E8FC             vReadString:
0705: E8FC CD E0 E9               CALL   ReadString
0706: E8FF C9                     RET
0707: E900
0708: E900
0709: E900
0710: E900         ;------------------------- Read Console Status - B (11) ----------------------;
0711: E900         ; This function tells you whether a console input character is waiting to be  ;
0712: E900         ;processed. Unlike the Console Input functions, which will wait until there   ;
0713: E900         ;is input,this function simply checks and returns immediately.                ;
0714: E900         ;                                                                             ;
0715: E900         ;			Function Code	:	C = 0BH                                       ;
0716: E900         ;           Entry Parameters:	None										  ;
0717: E900         ;           Exit Parameters :	A = 00H if no incoming Data					  ;
0718: E900         ;								A = FFH	if incoming Data					  ;
0719: E900         ;																			  ;
0720: E900         ;------------------------- Read Console Status - B (11) ----------------------;
0721: E900
0722: E900         ;check console status
0723: E900             vGetConsoleStatus:
0724: E900 CD 8A E9               CALL   ConBreak
0725: E903 32 C5 EA               LD     (exitParameterByte),A
0726: E906 C9                     RET
0727: E907         ;----------
0728: E907         ;get/set user code
0729: E907         ; IN - (E) = FF its a get else user Number(0-15)
0730: E907         ; OUT - (A) Current user number or no value
0731: E907             vGetSetUserNumber:                      ; func32 (32 - 20)	Get or set User code
0732: E907 3A C2 EA               LD     A,(paramE)
0733: E90A FE FF                  CP     0FFH
0734: E90C C2 16 E9               JP     NZ,SetUserNumber     ; interrogate user code instead
0735: E90F 3A 13 F5               LD     A,(currentUserNumber)
0736: E912 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0737: E915 C9                     RET
0738: E916
0739: E916             SetUserNumber:                      ; setusrcode
0740: E916 E6 0F                  AND    LO_NIBBLE_MASK
0741: E918 32 13 F5               LD     (currentUserNumber),A
0742: E91B C9                     RET
0743: E91C
0744: E91C         ;****************************************************************************;
0745: E91C         ;								Character Support Routines					 ;
0746: E91C         ;****************************************************************************;
0747: E91C
0748: E91C         ;****************************************************************************;
0749: E91C         ; 								Console Routines							 ;
0750: E91C         ;****************************************************************************;
0751: E91C
0752: E91C         ;-------------------- Return a Character from the console -------------------;
0753: E91C         ;return byte from buffer or read from the console                            ;
0754: E91C             ConIn:                          ;
0755: E91C 21 BE EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0756: E91F 7E                     LD     A,(HL)               ;
0757: E920 36 00                  LD     (HL),0               ;
0758: E922 B7                     OR     A                    ;
0759: E923 C0                     RET    NZ                   ;
0760: E924         ;
0761: E924 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0762: E927         ;-------------------- Return a Character from the console -------------------;
0763: E927
0764: E927         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0765: E927         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0766: E927             IsPrintableASCII:                      ;
0767: E927 FE 0D                  CP     CR                   ;
0768: E929 C8                     RET    Z                    ; carriage return?                                                  ;
0769: E92A FE 0A                  CP     LF                   ;
0770: E92C C8                     RET    Z                    ; line feed?                                                        ;
0771: E92D FE 09                  CP     TAB                  ;
0772: E92F C8                     RET    Z                    ; TAB?                                                              ;
0773: E930 FE 08                  CP     CTRL_H               ;
0774: E932 C8                     RET    Z                    ; backspace?                                                        ;
0775: E933 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0776: E935 C9                     RET                         ;
0777: E936         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0778: E936
0779: E936         ;------------------ Print character from (BC) until  $ found ----------------;
0780: E936             Print:                          ;
0781: E936 0A                     LD     A,(BC)               ; Get the next character             ;
0782: E937 FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0783: E939 C8                     RET    Z                    ;  exit if yes                       ;
0784: E93A 03                     INC    BC                   ; Update the pointer                 ;
0785: E93B C5                     PUSH   BC                   ; Save it                            ;
0786: E93C 4F                     LD     C,A                  ; Does Byte require                  ;
0787: E93D CD 55 E9               CALL   TabOut               ;  special attention - check         ;
0788: E940 C1                     POP    BC                   ; Retrieve the pointer				 ;
0789: E941 C3 36 E9               JP     Print                ; Loop back                          ;
0790: E944         ;------------------ Print character from (BC) until  $ found ----------------;
0791: E944
0792: E944         ;-- Send printable character to console. Precede with Caret if needed -------;
0793: E944         ; character is in Reg C                                                      ;
0794: E944             CaretOut:                       ;
0795: E944 79                     LD     A,C                  ;
0796: E945 CD 27 E9               CALL   IsPrintableASCII     ;
0797: E948 D2 55 E9               JP     NC,TabOut            ; Skip if Caret not needed           ;
0798: E94B         ; send preceding up arrow                                                    ;
0799: E94B F5                     PUSH   AF                   ; Save the character                 ;
0800: E94C 0E 5E                  LD     C,CARET              ;
0801: E94E CD 69 E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0802: E951 F1                     POP    AF                   ; Get the character                  ;
0803: E952 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0804: E954 4F                     LD     C,A                  ; Set up to print                    ;
0805: E955         ; fall thru to TabbOut                                                       ;
0806: E955         ;-- Send printable character to console. Precede with Caret if needed -------;
0807: E955
0808: E955
0809: E955         ;------------- Send printable character to console. Expand if TAB -----------;
0810: E955         ; character is in Reg C                                                      ;
0811: E955             TabOut:                         ;
0812: E955 79                     LD     A,C                  ;
0813: E956 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0814: E958 C2 69 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0815: E95B         ;
0816: E95B         ; TAB encountered                                                           ;
0817: E95B             TabOut0:                        ;
0818: E95B 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0819: E95D CD 69 E9               CALL   ConsoleOut           ; Send to Console                    ;
0820: E960 3A C1 EA               LD     A,(columnPosition)   ; Get Column position                ;
0821: E963 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0822: E965 C2 5B E9               JP     NZ,TabOut0           ; Do again if not                    ;
0823: E968 C9                     RET                         ;
0824: E969         ;------------- Send printable character to console. Expand if TAB -----------;
0825: E969         ;-------------------------- Send character to console -----------------------;
0826: E969         ; B  = Count                                                                 ;
0827: E969         ; C  = Character                                                             ;
0828: E969         ; HL = Pointer                                                               ;
0829: E969             ConsoleOut:                      ;
0830: E969         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0831: E969 C5                     PUSH   BC                   ; Save character and Count           ;
0832: E96A CD 8A E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0833: E96D C1                     POP    BC                   ;
0834: E96E C5                     PUSH   BC                   ; Get/save character                 ;
0835: E96F         ; Send character to Console	                                                 ;
0836: E96F CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0837: E972 C1                     POP    BC                   ;
0838: E973 C5                     PUSH   BC                   ; Get/save character                 ;
0839: E974         ; is the data to be output to print device?                                  ;
0840: E974 3A BF EA               LD     A,(printEchoFlag)    ;
0841: E977 B7                     OR     A                    ;
0842: E978 C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0843: E97B C1                     POP    BC                   ; Get the character                  ;
0844: E97C         ;
0845: E97C 79                     LD     A,C                  ; Move character to ACC              ;
0846: E97D 21 C1 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0847: E980 34                     INC    M                    ; increment the ColumnPosition       ;
0848: E981         ;
0849: E981 FE 20                  CP     SPACE                ;
0850: E983 D0                     RET    NC                   ; Exit if ASCII printable            ;
0851: E984         ;
0852: E984 FE 0A                  CP     LF                   ;
0853: E986 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0854: E987         ;
0855: E987 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0856: E989 C9                     RET                         ;
0857: E98A         ;-------------------------- Send character to console -----------------------;
0858: E98A
0859: E98A
0860: E98A         ;
0861: E98A
0862: E98A         ;--------------------  Check for Status and Control S or C ------------------;
0863: E98A         ;  Returns:																	 ;
0864: E98A         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0865: E98A         ;			ACC = 00   No data Pending										 ;
0866: E98A         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0867: E98A         ;                                                                            ;
0868: E98A             ConBreak:                       ;
0869: E98A 3A BE EA               LD     A,(keyboardByte)     ;
0870: E98D B7                     OR     A                    ;
0871: E98E C2 BD E9               JP     NZ,ConBreak1         ; Return with FF in ACC              ;
0872: E991         ;
0873: E991 CD 06 F6               CALL   bcConst              ; Get status                         ;
0874: E994 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0875: E996 C8                     RET    Z                    ; Return 00 No data pending          ;
0876: E997         ;
0877: E997 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0878: E99A         ;
0879: E99A         ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>            ;
0880: E99A FE 10                  CP     CTRL_P               ;
0881: E99C 20 0D                  JR     NZ,CheckCTL_S        ;
0882: E99E 21 BF EA               LD     HL,printEchoFlag     ;
0883: E9A1 3E FF                  LD     A,TRUE               ;
0884: E9A3 BE                     CP     (HL)                 ;
0885: E9A4 20 02                  JR     NZ,ToggleFlag1       ;
0886: E9A6 3E 00                  LD     A,FALSE              ;
0887: E9A8             ToggleFlag1:                      ;
0888: E9A8 77                     LD     (HL),A               ;
0889: E9A9 18 0D                  JR     NothingWaiting       ;
0890: E9AB             CheckCTL_S:                      ;
0891: E9AB         ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>           ;
0892: E9AB FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0893: E9AD C2 BA E9               JP     NZ,ConBreak0         ;   and and return 0FFH              ;
0894: E9B0         ;
0895: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0896: E9B3 FE 03                  CP     CTRL_C               ;
0897: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0898: E9B8             NothingWaiting:                      ;
0899: E9B8 AF                     XOR    A                    ;
0900: E9B9 C9                     RET                         ; Set ACC = 0 and return             ;
0901: E9BA             ConBreak0:                      ;
0902: E9BA 32 BE EA               LD     (keyboardByte),A     ; save the byte                      ;
0903: E9BD             ConBreak1:                      ;
0904: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0905: E9BF C9                     RET                         ;
0906: E9C0         ;--------------------  Check for Status and Control S or C ------------------;
0907: E9C0
0908: E9C0         ;------------------------  Console Output Utilities -------------------------;
0909: E9C0             showHashCRLF:                      ;
0910: E9C0 0E 23                  LD     C,HASH_TAG           ;
0911: E9C2 CD 69 E9               CALL   ConsoleOut           ; Send # to console                  ;
0912: E9C5 CD D6 E9               CALL   showCRLF             ;
0913: E9C8             showHashCRLF1:                      ;
0914: E9C8 3E C1                  LD     A,columnPosition     ;
0915: E9CA 21 C0 EA               LD     HL,startingColumn    ;
0916: E9CD BF                     CP     A,M                  ;
0917: E9CE D0                     RET    NC                   ;
0918: E9CF 0E 20                  LD     C,SPACE              ;
0919: E9D1 CD 69 E9               CALL   ConsoleOut           ;
0920: E9D4 18 F2                  JR     showHashCRLF1        ;
0921: E9D6         ;Send the Carriage Return Line Feed sequence                                 ;
0922: E9D6             showCRLF:                       ;
0923: E9D6 0E 0D                  LD     C,CR                 ;
0924: E9D8 CD 69 E9               CALL   ConsoleOut           ;
0925: E9DB 0E 0A                  LD     C,LF                 ;
0926: E9DD         ; 	CALL	ConsoleOut					; exit via ConsoleOuts RET           ;
0927: E9DD C3 69 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0928: E9E0         ;
0929: E9E0         ;------------------------  Console Output Utilities -------------------------;
0930: E9E0
0931: E9E0         ;------------------------- Read a $ terminated String -----------------------;
0932: E9E0         ;read to paramDE address (max length, current length, buffer)               ;
0933: E9E0             ReadString:                      ;
0934: E9E0 3A C1 EA               LD     A,(columnPosition)   ;
0935: E9E3 32 C0 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0936: E9E6 2A C3 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0937: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0938: E9EA 23                     INC    HL                   ; Point at actual bytes read         ;
0939: E9EB         ; 	PUSH	HL							; Save for EndRead                   ;
0940: E9EB 06 00                  LD     B,0                  ; Initialize Current Index           ;
0941: E9ED         ; B = current buffer length,                                                ;
0942: E9ED         ; C = maximum buffer length,                                                ;
0943: E9ED         ; HL= next to fill - 1                                                      ;
0944: E9ED         ;
0945: E9ED         ; read next character, BC, HL active                                        ;
0946: E9ED             ReadNext:                       ;
0947: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0948: E9EE E5                     PUSH   HL                   ; Save pointer                       ;
0949: E9EF             ReadNext0:                      ;
0950: E9EF CD 1C E9               CALL   ConIn                ; Get the next Character             ;
0951: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0952: E9F4 E1                     POP    HL                   ; Restore Pointer					 ;
0953: E9F5 C1                     POP    BC                   ; Restore Current Index and Max Count;
0954: E9F6         ;Is It Carriage Return                                                       ;
0955: E9F6 FE 0D                  CP     CR                   ;
0956: E9F8 CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0957: E9FB FE 0A                  CP     LF                   ;
0958: E9FD         ;Is It Linefeed                                                              ;
0959: E9FD CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0960: EA00         ;Is It BackSpace                                                             ;
0961: EA00 FE 08                  CP     CTRL_H               ;
0962: EA02 CA 48 EA               JP     Z,BSspaceBS          ;
0963: EA05             IsItRubout:                      ;
0964: EA05 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
0965: EA07 CA 52 EA               JP     Z,ItIsRubout         ;
0966: EA0A             IsPhysicalEOL:                      ;
0967: EA0A FE 05                  CP     CTRL_E               ;
0968: EA0C CA 5D EA               JP     Z,ItIsPhysicalEOL    ;
0969: EA0F             IsItPrintToggle:                      ;
0970: EA0F FE 10                  CP     CTRL_P               ;
0971: EA11 CA 65 EA               JP     Z,ItIsPrintToggle    ;
0972: EA14             IsItDeleteTheLineX:                      ;
0973: EA14 FE 18                  CP     CTRL_X               ;
0974: EA16 CA 8E EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
0975: EA19             IsItDeleteTheLineU:                      ;
0976: EA19 FE 15                  CP     CTRL_U               ;
0977: EA1B CA AC EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line       ;
0978: EA1E         ;Retype the line                                                             ;
0979: EA1E FE 12                  CP     CTRL_R               ;
0980: EA20 CA 75 EA               JP     Z,RepeatLine         ;
0981: EA23
0982: EA23         ;....................... Echo input back to the Console  ....................;
0983: EA23         ; Full Duplex								                                 ;
0984: EA23         ; A = Character to display	                                                 ;
0985: EA23         ; B = current buffer length, (index)                                         ;
0986: EA23         ; C = maximum buffer length,                                                 ;
0987: EA23         ; HL= next to fill - 1 (Pointer)                                             ;
0988: EA23         ;
0989: EA23         ;ReadEcho                                                                    ;
0990: EA23 04                     INC    B                    ; Increment byte count		         ;
0991: EA24 23                     INC    HL                   ; Advance the Pointer                ;
0992: EA25 77                     LD     (HL),A               ; Put char in buffer                 ;
0993: EA26         ;
0994: EA26             ReadEchoRubOut:                      ;
0995: EA26 C5                     PUSH   BC                   ; Save index and length              ;
0996: EA27 E5                     PUSH   HL                   ; Save the Pointer                   ;
0997: EA28 4F                     LD     C,A                  ; Get char                           ;
0998: EA29 CD 44 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
0999: EA2C E1                     POP    HL                   ; Restore the Pointer                ;
1000: EA2D C1                     POP    BC                   ; Restore index and length           ;
1001: EA2E 7E                     LD     A,(HL)               ; Recall char                        ;
1002: EA2F         ; check for Warm Boot                                                        ;
1003: EA2F FE 03                  CP     CTRL_C               ;
1004: EA31 78                     LD     A,B                  ; Get Line position                  ;
1005: EA32 C2 3A EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1006: EA35 FE 01                  CP     1                    ; Beginning of the Line?             ;
1007: EA37 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1008: EA3A         ; Check to see if we are at the end of the buffer                            ;
1009: EA3A             AreWeAtEndOfBuffer:                      ;
1010: EA3A B9                     CP     C                    ; Over Max ?					     ;
1011: EA3B DA ED E9               JP     C,ReadNext           ;  no, Go for more				     ;
1012: EA3E         ;
1013: EA3E         ; At the end of read                                  					     ;
1014: EA3E             EndRead:                        ;
1015: EA3E         ; 	POP		HL                                                               ;
1016: EA3E 2A C3 EA               LD     HL,(paramDE)         ;
1017: EA41 23                     INC    HL                   ;
1018: EA42         ;
1019: EA42 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1020: EA43 0E 0D                  LD     C,CR                 ;
1021: EA45 C3 69 E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1022: EA48         ;....................... Echo input back to the Console  ....................;
1023: EA48         ;.......................... Backspace SPACE BackSpace .......................;
1024: EA48             BSspaceBS:                      ;
1025: EA48 05                     DEC    B                    ;
1026: EA49 2B                     DEC    HL                   ;
1027: EA4A C5                     PUSH   BC                   ;
1028: EA4B E5                     PUSH   HL                   ;
1029: EA4C CD 9F EA               CALL   BackUp               ;
1030: EA4F C3 EF E9               JP     ReadNext0            ;
1031: EA52         ;.......................... Backspace SPACE BackSpace .......................;
1032: EA52         ;.......................... It is RubOut ....................................;
1033: EA52             ItIsRubout:                      ;
1034: EA52         ; RUBOUT if possible                                                         ;
1035: EA52 78                     LD     A,B                  ; Are we at the start of the line    ;
1036: EA53 B7                     OR     A                    ;
1037: EA54 CA ED E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1038: EA57         ;adjust pointers back one                                                    ;
1039: EA57 7E                     LD     A,(HL)               ; ACC = current character            ;
1040: EA58 05                     DEC    B                    ; Adjust the index			    	 ;
1041: EA59 2B                     DEC    HL                   ; Adjust the pointer                 ;
1042: EA5A C3 26 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1043: EA5D         ;.......................... It is RubOut ....................................;
1044: EA5D         ;.......................... It is PhysicalEOL ...............................;
1045: EA5D             ItIsPhysicalEOL:                      ;
1046: EA5D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1047: EA5E E5                     PUSH   HL                   ; Save pointer                       ;
1048: EA5F CD D6 E9               CALL   showCRLF             ; Make new line                      ;
1049: EA62 C3 EF E9               JP     ReadNext0            ;   and go for next char   			 ;
1050: EA65         ;.......................... It is PhysicalEOL ...............................;
1051: EA65         ;.......................... It is PrintToggle ...............................;
1052: EA65             ItIsPrintToggle:
1053: EA65 E5                     PUSH   HL                   ; Save pointer                       ;
1054: EA66         ; Toggle the printEcho Flag                                                  ;
1055: EA66 21 BF EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1056: EA69 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1057: EA6B BE                     CP     (HL)                 ; Is the flag true?                  ;
1058: EA6C 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1059: EA6E 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1060: EA70             IsItPrintToggle1:                      ;
1061: EA70 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1062: EA71 E1                     POP    HL                   ; Restore pointer                    ;
1063: EA72 C3 ED E9               JP     ReadNext             ;   and for another char             ;
1064: EA75         ;.......................... It is PrintToggle ...............................;
1065: EA75         ;.......................... RepeatLine ......................................;
1066: EA75             RepeatLine:                      ;
1067: EA75 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1068: EA76 E5                     PUSH   HL                   ;  for exit                          ;
1069: EA77 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1070: EA7A         ;
1071: EA7A 2A C3 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1072: EA7D 23                     INC    HL                   ; Skip past character count          ;
1073: EA7E         ;
1074: EA7E             LL1:                            ;
1075: EA7E 23                     INC    HL                   ; Point at next char to display      ;
1076: EA7F C5                     PUSH   BC                   ; Save counter, in B                 ;
1077: EA80 E5                     PUSH   HL                   ; Save buffer pointer                ;
1078: EA81 4E                     LD     C,M                  ; Get the next character             ;
1079: EA82 CD 44 E9               CALL   CaretOut             ; Display it                         ;
1080: EA85 E1                     POP    HL                   ; Restore                            ;
1081: EA86 C1                     POP    BC                   ;  the counter and pointer           ;
1082: EA87 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1083: EA89 E1                     POP    HL                   ; Restore values                     ;
1084: EA8A C1                     POP    BC                   ;  from routine entry                ;
1085: EA8B C3 ED E9               JP     ReadNext             ; Done here !                        ;
1086: EA8E         ;.......................... RepeatLine ......................................;
1087: EA8E         ;.......................... Delete The Line .................................;
1088: EA8E         ;
1089: EA8E             DeleteTheLine:                      ;
1090: EA8E E1                     POP    HL                   ; Adjust Stack                       ;
1091: EA8F         ;                                             ;
1092: EA8F             DeleteTheLine1:                      ;
1093: EA8F 3A C0 EA               LD     A,(startingColumn)   ;
1094: EA92 21 C1 EA               LD     HL,columnPosition    ;
1095: EA95 BE                     CP     M                    ; Start of line ?                    ;
1096: EA96 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1097: EA99 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1098: EA9A CD 9F EA               CALL   BackUp               ; Clear 1 column                     ;
1099: EA9D 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1100: EA9F         ;
1101: EA9F         ;.......................... Delete The Line .................................;
1102: EA9F         ;------------------------ Back-up one screen position -----------------------;
1103: EA9F             BackUp:                         ;
1104: EA9F CD A7 EA               CALL   BackUp1              ; Send Backspace                     ;
1105: EAA2 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1106: EAA4 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1107: EAA7         ;does not affect column count                                                ;
1108: EAA7             BackUp1:                        ;
1109: EAA7 0E 08                  LD     C,CTRL_H             ;
1110: EAA9 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1111: EAAC         ;------------------------ Back-up one screen position -----------------------;
1112: EAAC         ;.......................... Ignore The Line .................................;
1113: EAAC             IgnoreTheLine:                      ;
1114: EAAC CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1115: EAAF 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1116: EAB1 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1117: EAB4 0E 20                  LD     C,SPACE              ;
1118: EAB6 CD 0C F6               CALL   bcConout             ;
1119: EAB9 C3 E0 E9               JP     ReadString           ; Start all over                     ;
1120: EABC         ;.......................... Ignore The Line .................................;
1121: EABC
1122: EABC         ;=====================
1123: EABC
1124: EABC         ;------------------------- Read a $ terminated String -----------------------;
1125: EABC
1126: EABC
1127: EABC         ;****************************************************************************
1128: EABC         ;                           DATA AREA                                       *
1129: EABC         ;****************************************************************************
1130: EABC
1131: EABC         ;------------------------------Non Disk Data Area ---------------------------;
1132: EABC             usersStack: DS     2                    ; entry stack pointer                ;
1133: EABE         ;
1134: EABE 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1135: EABF         ;
1136: EABF 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1137: EAC0         ;
1138: EAC0         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1139: EAC0 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1140: EAC1 00          columnPosition: DB     0                    ; Current Column position            ;
1141: EAC2         ;
1142: EAC2             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1143: EAC3             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1144: EAC5             exitParameterByte:                      ; Byte returned Value                ;
1145: EAC5             exitParameterWord: DS     WORD                 ; Word                           ;
1146: EAC7         ;
1147: EAC7         ;
1148: EAC7         ;------------------------------------ Data Area -----------------------------;
1149: EAC7
1150: EAC7
1151: EAC7
1152: EAC7         ;*****************************************************************************;
1153: EAC7         ;								Disk I/O									  ;
1154: EAC7         ;*****************************************************************************;
1155: EAC7
1156: EAC7
1157: EAC7         ;*****************************************************************
1158: EAC7         ;random disk read
1159: EAC7         ;IN  - (DE) FCB address
1160: EAC7         ;OUT - (A) 01 = Reading unwritten data
1161: EAC7         ;	 02 = N/U
1162: EAC7         ;	 03 = Cannot close current extent
1163: EAC7         ;	 04 = Seek to unwriten Extent
1164: EAC7         ;	 05 = N/U
1165: EAC7         ;	 06 = Seek past Physical end of Disk
1166: EAC7             vReadRandom:                      ; func33 (33 - 21) Read Random record
1167: EAC7 CD D4 F2               CALL   Reselect
1168: EACA C3 DE EA               JP     RandomDiskRead       ; to perform the disk read
1169: EACD         ;*****************************************************************
1170: EACD         ;write random record
1171: EACD         ;IN  - (DE) FCB address
1172: EACD         ;OUT - (A) 01 = Reading unwritten data
1173: EACD         ;	 02 = N/U
1174: EACD         ;	 03 = Cannot close current extent
1175: EACD         ;	 04 = Seek to unwriten Extent
1176: EACD         ;	 05 = Cannot create new Extent because of directory overflow
1177: EACD         ;	 06 = Seek past Physical end of Disk
1178: EACD             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1179: EACD CD D4 F2               CALL   Reselect
1180: EAD0 C3 E7 EA               JP     RandomDiskWrite      ; to perform the disk write
1181: EAD3         ;ret ;jmp goback
1182: EAD3         ;*****************************************************************
1183: EAD3         ;return file size (0-65536)
1184: EAD3         ;IN  - (DE) FCB address
1185: EAD3             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1186: EAD3 CD D4 F2               CALL   Reselect
1187: EAD6 C3 94 EB               JP     GetFileSize
1188: EAD9         ;*****************************************************************
1189: EAD9         ;set random record
1190: EAD9         ;IN  - (DE) FCB address
1191: EAD9         ;OUT - Random Record Field is set
1192: EAD9             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1193: EAD9 C3 81 EB               JP     SetRandomRecord
1194: EADC         ;*****************************************************************
1195: EADC         ;Reset Drive
1196: EADC         ;IN  - (DE) Drive Vector
1197: EADC         ;OUT - (A) 00
1198: EADC             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1199: EADC         ; Not Yet Implemented   **************
1200: EADC C9                     RET
1201: EADD         ;*****************************************************************
1202: EADD         ;*****************************************************************
1203: EADD         ;Write Random With Zero Fill
1204: EADD         ;IN  - (DE) FCB address
1205: EADD         ;OUT - (A) Return Code		see Function 34
1206: EADD             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1207: EADD         ; Not Yet Implemented   **************
1208: EADD C9                     RET
1209: EADE         ;*****************************************************************
1210: EADE         ;******************< Random I/O Stuff ****************************
1211: EADE         ;*****************************************************************
1212: EADE         ;random disk read
1213: EADE             RandomDiskRead:                      ; randiskread
1214: EADE 0E FF                  LD     C,TRUE               ; marked as read operation
1215: EAE0 CD F0 EA               CALL   RandomSeek
1216: EAE3 CC C6 EF               CALL   Z,DiskRead           ; if seek successful
1217: EAE6 C9                     RET
1218: EAE7         ;*****************************************************************
1219: EAE7         ;random disk write
1220: EAE7             RandomDiskWrite:                      ; randiskwrite
1221: EAE7 0E 00                  LD     C,FALSE              ; marked as read operation
1222: EAE9 CD F0 EA               CALL   RandomSeek
1223: EAEC CC 09 F0               CALL   Z,DiskWrite          ; if seek successful
1224: EAEF C9                     RET
1225: EAF0         ;*****************************************************************
1226: EAF0         ;*****************************************************************
1227: EAF0         ;random access seek operation, C=0ffh if read mode
1228: EAF0         ;fcb is assumed to address an active file control block
1229: EAF0         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1230: EAF0             RandomSeek:
1231: EAF0 AF                     XOR    A
1232: EAF1 32 3E F5               LD     (seqReadFlag),A      ; marked as random access operation
1233: EAF4 C5                     PUSH   BC                   ; save r/w flag
1234: EAF5 2A C3 EA               LD     HL,(paramDE)
1235: EAF8 EB                     EX     DE,HL                ; DE will hold base of fcb
1236: EAF9 21 21 00               LD     HL,RANDOM_REC_FIELD
1237: EAFC 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1238: EAFD 7E                     LD     A,(HL)
1239: EAFE E6 7F                  AND    7FH
1240: EB00 F5                     PUSH   AF                   ; record number
1241: EB01 7E                     LD     A,(HL)
1242: EB02 17                     RLA                         ; cy=lsb of extent#
1243: EB03 23                     INC    HL
1244: EB04 7E                     LD     A,(HL)
1245: EB05 17                     RLA
1246: EB06 E6 1F                  AND    11111B               ; A=ext#
1247: EB08 4F                     LD     C,A                  ; C holds extent number, record stacked
1248: EB09 7E                     LD     A,(HL)
1249: EB0A 1F                     RRA
1250: EB0B 1F                     RRA
1251: EB0C 1F                     RRA
1252: EB0D 1F                     RRA
1253: EB0E E6 0F                  AND    1111B                ; mod#
1254: EB10 47                     LD     B,A                  ; B holds module#, C holds ext#
1255: EB11 F1                     POP    AF                   ; recall sought record #
1256: EB12         ;check to insure that high byte of ran rec = 00
1257: EB12 23                     INC    HL
1258: EB13 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1259: EB14 2C                     INC    L
1260: EB15 2D                     DEC    L
1261: EB16 2E 06                  LD     L,06                 ; zero flag, l=6
1262: EB18         ; produce error 6, seek past physical eod
1263: EB18 C2 79 EB               JP     NZ,RandomSeekError
1264: EB1B         ; otherwise, high byte = 0, A = sought record
1265: EB1B 21 20 00               LD     HL,NEXT_RECORD
1266: EB1E 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1267: EB1F 77                     LD     (HL),A               ; sought rec# stored away
1268: EB20         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1269: EB20         ; the r/w flag is still stacked.  compare fcb values
1270: EB20 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1271: EB23 19                     ADD    HL,DE
1272: EB24 79                     LD     A,C                  ; A=seek ext#
1273: EB25 96                     SUB    M
1274: EB26 C2 34 EB               JP     NZ,RandomSeekClose   ; tests for = extents
1275: EB29         ; extents match, check mod#
1276: EB29 21 0E 00               LD     HL,fcbS2Index
1277: EB2C 19                     ADD    HL,DE
1278: EB2D 78                     LD     A,B                  ; B=seek mod#
1279: EB2E         ; could be overflow at eof, producing module#
1280: EB2E         ; of 90H or 10H, so compare all but fwf
1281: EB2E 96                     SUB    M
1282: EB2F E6 7F                  AND    7FH
1283: EB31 CA 6C EB               JP     Z,RandomSeekExit     ; same?
1284: EB34             RandomSeekClose:
1285: EB34 C5                     PUSH   BC
1286: EB35 D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1287: EB36 CD A9 F1               CALL   CloseDirEntry        ; current extent closed
1288: EB39 D1                     POP    DE
1289: EB3A C1                     POP    BC                   ; recall parameters and fill
1290: EB3B 2E 03                  LD     L,03                 ; cannot close error #3
1291: EB3D 3A C5 EA               LD     A,(exitParameterByte)
1292: EB40 3C                     INC    A
1293: EB41 CA 72 EB               JP     Z,RandomSeekErrorBadSeek
1294: EB44 21 0C 00               LD     HL,fcbExtIndex
1295: EB47 19                     ADD    HL,DE
1296: EB48 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1297: EB49 21 0E 00               LD     HL,fcbS2Index
1298: EB4C 19                     ADD    HL,DE
1299: EB4D 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1300: EB4E CD 01 F3               CALL   OpenFile             ; is the file present?
1301: EB51 3A C5 EA               LD     A,(exitParameterByte)
1302: EB54 3C                     INC    A
1303: EB55 C2 6C EB               JP     NZ,RandomSeekExit    ; open successful?
1304: EB58         ; cannot open the file, read mode?
1305: EB58 C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1306: EB59 C5                     PUSH   BC                   ; everyone expects this item stacked
1307: EB5A 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1308: EB5C 0C                     INC    C                    ; becomes 00 if read operation
1309: EB5D CA 72 EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1310: EB60 CD 51 F1               CALL   MakeNewFile          ; write operation, make new extent
1311: EB63 2E 05                  LD     L,05                 ; cannot create new extent #5
1312: EB65 3A C5 EA               LD     A,(exitParameterByte)
1313: EB68 3C                     INC    A
1314: EB69 CA 72 EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1315: EB6C         ; file make operation successful
1316: EB6C             RandomSeekExit:                      ; seekok:
1317: EB6C C1                     POP    BC                   ; discard r/w flag
1318: EB6D AF                     XOR    A
1319: EB6E 32 C5 EA               LD     (exitParameterByte),A
1320: EB71 C9                     RET                         ; with zero set
1321: EB72
1322: EB72             RandomSeekErrorBadSeek:
1323: EB72         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1324: EB72         ; appears as overflow with file write flag set
1325: EB72 E5                     PUSH   HL                   ; save error flag
1326: EB73 CD CB F2               CALL   GetModuleNum         ; HL = .fcbS2Index
1327: EB76 36 C0                  LD     (HL),11000000B
1328: EB78 E1                     POP    HL                   ; and drop through
1329: EB79             RandomSeekError:                      ; seekerr:
1330: EB79 C1                     POP    BC                   ; discard r/w flag
1331: EB7A 7D                     LD     A,L
1332: EB7B 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1333: EB7E         ; SetFileWriteFlag returns non-zero accumulator for err
1334: EB7E C3 D4 F3               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1335: EB81         ;ret
1336: EB81         ;
1337: EB81         ;*****************************************************************
1338: EB81             SetRandomRecord:                      ; setrandom
1339: EB81 2A C3 EA               LD     HL,(paramDE)
1340: EB84 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1341: EB87 CD D0 EB               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1342: EB8A 21 21 00               LD     HL,RANDOM_REC_FIELD
1343: EB8D 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1344: EB8E 71                     LD     (HL),C
1345: EB8F 23                     INC    HL
1346: EB90 70                     LD     (HL),B
1347: EB91 23                     INC    HL
1348: EB92 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1349: EB93 C9                     RET
1350: EB94         ;*****************************************************************
1351: EB94         ;compute logical file size for current fcb
1352: EB94             GetFileSize:                      ; getfilesize
1353: EB94 0E 0C                  LD     C,fcbExtIndex
1354: EB96 CD 44 F3               CALL   Search4DirElement
1355: EB99         ; zero the receiving Ramdom record field
1356: EB99 2A C3 EA               LD     HL,(paramDE)
1357: EB9C 11 21 00               LD     DE,RANDOM_REC_FIELD
1358: EB9F 19                     ADD    HL,DE
1359: EBA0 E5                     PUSH   HL                   ; save position
1360: EBA1 72                     LD     (HL),D
1361: EBA2 23                     INC    HL
1362: EBA3 72                     LD     (HL),D
1363: EBA4 23                     INC    HL
1364: EBA5 72                     LD     (HL),D               ; =00 00 00
1365: EBA6             GetFileSize1:                      ; getsize:
1366: EBA6 CD E8 ED               CALL   EndOfDirectory
1367: EBA9 CA CE EB               JP     Z,GetFileSizeExit
1368: EBAC         ; current fcb addressed by dptr
1369: EBAC CD D4 EE               CALL   GetDirElementAddress
1370: EBAF 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1371: EBB2 CD D0 EB               CALL   GetRandomRecordPosition
1372: EBB5         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1373: EBB5 E1                     POP    HL
1374: EBB6 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1375: EBB7 5F                     LD     E,A                  ; save cy
1376: EBB8 79                     LD     A,C
1377: EBB9 96                     SUB    M
1378: EBBA 23                     INC    HL                   ; ls byte
1379: EBBB 78                     LD     A,B
1380: EBBC 9E                     SBC    A,(HL)
1381: EBBD 23                     INC    HL                   ; middle byte
1382: EBBE 7B                     LD     A,E
1383: EBBF 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1384: EBC0 DA C8 EB               JP     C,GetFileSize2       ; for another try
1385: EBC3         ; fcb is less or equal, fill from directory
1386: EBC3 73                     LD     (HL),E
1387: EBC4 2B                     DEC    HL
1388: EBC5 70                     LD     (HL),B
1389: EBC6 2B                     DEC    HL
1390: EBC7 71                     LD     (HL),C
1391: EBC8             GetFileSize2:                      ; getnextsize:
1392: EBC8 CD 5C F3               CALL   Search4NextDirElement
1393: EBCB C3 A6 EB               JP     GetFileSize1
1394: EBCE             GetFileSizeExit:                      ; setsize:
1395: EBCE E1                     POP    HL                   ; discard .fcb(random record field)
1396: EBCF C9                     RET
1397: EBD0         ;-----------------------------------------------------------------
1398: EBD0         ;compute random record position
1399: EBD0             GetRandomRecordPosition:                      ; compute$rr
1400: EBD0 EB                     EX     DE,HL
1401: EBD1 19                     ADD    HL,DE
1402: EBD2         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1403: EBD2 4E                     LD     C,(HL)
1404: EBD3 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1405: EBD5 21 0C 00               LD     HL,fcbExtIndex
1406: EBD8 19                     ADD    HL,DE
1407: EBD9 7E                     LD     A,(HL)
1408: EBDA 0F                     RRCA
1409: EBDB E6 80                  AND    80H                  ; A=e000 0000
1410: EBDD 81                     ADD    A,C
1411: EBDE 4F                     LD     C,A
1412: EBDF 3E 00                  LD     A,0
1413: EBE1 88                     ADC    A,B
1414: EBE2 47                     LD     B,A
1415: EBE3         ; BC = 0000 000? errrr rrrr
1416: EBE3 7E                     LD     A,(HL)
1417: EBE4 0F                     RRCA
1418: EBE5 E6 0F                  AND    LO_NIBBLE_MASK
1419: EBE7 80                     ADD    A,B
1420: EBE8 47                     LD     B,A
1421: EBE9         ; BC = 000? eeee errrr rrrr
1422: EBE9 21 0E 00               LD     HL,fcbS2Index
1423: EBEC 19                     ADD    HL,DE
1424: EBED 7E                     LD     A,(HL)               ; A=XXX? mmmm
1425: EBEE 87                     ADD    A,A
1426: EBEF 87                     ADD    A,A
1427: EBF0 87                     ADD    A,A
1428: EBF1 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1429: EBF2 F5                     PUSH   AF
1430: EBF3 80                     ADD    A,B
1431: EBF4 47                     LD     B,A
1432: EBF5         ; cy=?, BC = mmmm eeee errr rrrr
1433: EBF5 F5                     PUSH   AF                   ; possible second carry
1434: EBF6 E1                     POP    HL                   ; cy = lsb of L
1435: EBF7 7D                     LD     A,L                  ; cy = lsb of A
1436: EBF8 E1                     POP    HL                   ; cy = lsb of L
1437: EBF9 B5                     OR     L                    ; cy/cy = lsb of A
1438: EBFA E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1439: EBFC C9                     RET
1440: EBFD         ;-----------------------------------------------------------------
1441: EBFD
1442: EBFD         ;*****************************************************************
1443: EBFD         ;****************** Random I/O Stuff >****************************
1444: EBFD         ;*****************************************************************
1445: EBFD
1446: EBFD
1447: EBFD         ;? ;------------------
1448: EBFD         ;? ;back-up one screen position
1449: EBFD         ;? BackUp:
1450: EBFD         ;?  	CALL	PutCntl_H
1451: EBFD         ;? 	LD		C,SPACE
1452: EBFD         ;? 	CALL	bcConout
1453: EBFD         ;? ;send CTRL_H to console without affecting column count
1454: EBFD         ;? PutCntl_H:
1455: EBFD         ;? 	LD		C,CTRL_H
1456: EBFD         ;? 	JP		bcConout
1457: EBFD         ;? 	;ret
1458: EBFD         ;----------------------------------------------------------------
1459: EBFD         ;
1460: EBFD
1461: EBFD
1462: EBFD
1463: EBFD
1464: EBFD         ;*****************************************************************
1465: EBFD         ;********************** Disk  I/O ********************************
1466: EBFD         ;*****************************************************************
1467: EBFD
1468: EBFD         ;reset disk system - initialize to disk 0
1469: EBFD             vResetSystem:                      ; func13 (13 - 0D)	 Reset Disk System
1470: EBFD 21 00 00               LD     HL,0
1471: EC00 22 16 F5               LD     (ReadOnlyVector),HL
1472: EC03 22 18 F5               LD     (loggedDisks),HL     ; clear the vectors for R/O and Logged Disks
1473: EC06 AF                     XOR    A                    ; also clear the current disk
1474: EC07 32 14 F5               LD     (currentDisk),A      ; note that currentUserNumber remains unchanged
1475: EC0A 21 80 00               LD     HL,DMABuffer
1476: EC0D 22 1A F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = DMABuffer
1477: EC10 CD D9 ED               CALL   SetDataDMA           ; to data dma address
1478: EC13 C3 5D EC               JP     Select
1479: EC16         ;ret ;jmp goback
1480: EC16         ;-----------------------------------------------------------------
1481: EC16         ;select disk in (E) paramDE
1482: EC16         ; IN - (E) disk number -- 0=A  1=B ...15=P
1483: EC16             vSelectDisk:                      ; func14 (14 - 0E)	Select Current Disk
1484: EC16 C3 51 EC               JP     SelectCurrent
1485: EC19         ;ret ;jmp goba
1486: EC19         ;-----------------------------------------------------------------
1487: EC19         ;return the login vector
1488: EC19         ;OUT - (HL) loggedDisks
1489: EC19             vGetLoginVector:                      ; func24: (24 - 18) Return login Vector
1490: EC19 2A 18 F5               LD     HL,(loggedDisks)
1491: EC1C 22 C5 EA               LD     (exitParameterWord),HL
1492: EC1F C9                     RET
1493: EC20         ;-----------------------------------------------------------------
1494: EC20         ;return selected disk number
1495: EC20         ;OUT - A current disk -- 0=A  1=B ...15=P
1496: EC20             vGetCurrentDisk:                      ; func25 (25 - 19)	Get Current Disk
1497: EC20 3A 14 F5               LD     A,(currentDisk)
1498: EC23 32 C5 EA               LD     (exitParameterByte),A
1499: EC26 C9                     RET
1500: EC27         ;-----------------------------------------------------------------
1501: EC27         ;set the subsequent dma address to paramDE
1502: EC27         ;IN - (HL) value to set as DMA
1503: EC27             vSetDMA:                        ; func26 (25 - 1A) Set Dma Address
1504: EC27 2A C3 EA               LD     HL,(paramDE)
1505: EC2A 22 1A F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = paramDE
1506: EC2D C3 D9 ED               JP     SetDataDMA           ; to data dma address
1507: EC30         ;-----------------------------------------------------------------
1508: EC30         ;return the Allocation Vector Address
1509: EC30         ;OUT - (HL) Allocation Vector Address
1510: EC30             vGetAllocAddr:                      ; func27 (27 - 1B) Get Allocation Vector Address
1511: EC30 2A 28 F5               LD     HL,(caAllocVector)
1512: EC33 22 C5 EA               LD     (exitParameterWord),HL
1513: EC36 C9                     RET
1514: EC37         ;-----------------------------------------------------------------
1515: EC37         ;;write protect current disk
1516: EC37             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1517: EC37 C3 DC EC               JP     SetDiskReadOnly
1518: EC3A         ;-----------------------------------------------------------------
1519: EC3A         ;return r/o bit vector
1520: EC3A         ;OUT - (HL) Read Only Vector Vector
1521: EC3A             vGetRoVector:                      ; func29 (29 - 1D)	Get read Only vector
1522: EC3A 2A 16 F5               LD     HL,(ReadOnlyVector)
1523: EC3D 22 C5 EA               LD     (exitParameterWord),HL
1524: EC40 C9                     RET
1525: EC41         ;-----------------------------------------------------------------
1526: EC41         ;;set file Attributes
1527: EC41             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1528: EC41 CD D4 F2               CALL   Reselect
1529: EC44 CD 29 EF               CALL   SetAttributes
1530: EC47 C3 BE F2               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1531: EC4A         ;-----------------------------------------------------------------
1532: EC4A         ;return address of disk parameter block
1533: EC4A         ; OUT - (HL) Disk Parameter Black for current drive
1534: EC4A             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1535: EC4A 2A 24 F5               LD     HL,(caDiskParamBlock)
1536: EC4D 22 C5 EA               LD     (exitParameterWord),HL
1537: EC50 C9                     RET
1538: EC51         ;-----------------------------------------------------------------
1539: EC51
1540: EC51             SelectCurrent:                      ; curselect
1541: EC51 3A C2 EA               LD     A,(paramE)
1542: EC54 21 14 F5               LD     HL,currentDisk
1543: EC57 BE                     CP     M
1544: EC58 C8                     RET    Z                    ; exit if parame = Current disk
1545: EC59 77                     LD     (HL),A
1546: EC5A C3 5D EC               JP     Select
1547: EC5D         ;*****************************************************************
1548: EC5D         ; select Login Drive
1549: EC5D             Select:
1550: EC5D 2A 18 F5               LD     HL,(loggedDisks)
1551: EC60 3A 14 F5               LD     A,(currentDisk)
1552: EC63 4F                     LD     C,A
1553: EC64 CD 5F F4               CALL   ShiftRightHLbyC      ; see if we already have drive logged in
1554: EC67 E5                     PUSH   HL                   ; save result
1555: EC68 EB                     EX     DE,HL                ; send to seldsk
1556: EC69 CD 81 EC               CALL   SelectDisk
1557: EC6C E1                     POP    HL                   ; get back logged disk vector
1558: EC6D CC 83 F4               CALL   Z,errSelect
1559: EC70 7D                     LD     A,L                  ; get logged disks
1560: EC71 1F                     RRA
1561: EC72 D8                     RET    C                    ; exit if the disk already logged in
1562: EC73
1563: EC73 2A 18 F5               LD     HL,(loggedDisks)     ; else log in a differenet disk
1564: EC76 4D                     LD     C,L
1565: EC77 44                     LD     B,H                  ; BC has logged disk
1566: EC78 CD C9 EC               CALL   SetCurrentDiskBit
1567: EC7B 22 18 F5               LD     (loggedDisks),HL     ; save result
1568: EC7E C3 F3 EC               JP     InitDisk
1569: EC81         ;*****************************************************************
1570: EC81         ; select the disk drive given by currentDisk, and fill the base addresses
1571: EC81         ; caTrack - caAllocVector, then fill the values of the disk parameter block
1572: EC81             SelectDisk:
1573: EC81 3A 14 F5               LD     A,(currentDisk)
1574: EC84 4F                     LD     C,A                  ; prepare for Bios Call
1575: EC85 CD 1B F6               CALL   bcSeldsk
1576: EC88 7C                     LD     A,H                  ; HL = 0000 if error, otherwise disk headers
1577: EC89 B5                     OR     L
1578: EC8A C8                     RET    Z                    ; exit if error, with Zflag set
1579: EC8B 5E                     LD     E,(HL)
1580: EC8C 23                     INC    HL
1581: EC8D 56                     LD     D,(HL)               ; Disk Header Block pointer in DE
1582: EC8E 23                     INC    HL
1583: EC8F 22 1C F5               LD     (caDirMaxValue),HL
1584: EC92 23                     INC    HL
1585: EC93 23                     INC    HL
1586: EC94 22 1E F5               LD     (caTrack),HL
1587: EC97 23                     INC    HL
1588: EC98 23                     INC    HL
1589: EC99 22 20 F5               LD     (caSector),HL
1590: EC9C 23                     INC    HL
1591: EC9D 23                     INC    HL
1592: EC9E EB                     EX     DE,HL                ; DE points at Directory DMA, HL at Skew Table
1593: EC9F 22 39 F5               LD     (caSkewTable),HL
1594: ECA2 21 22 F5               LD     HL,caDirectoryDMA
1595: ECA5 0E 08                  LD     C,caListSize
1596: ECA7 CD 73 F4               CALL   Move                 ; finish filling in address list
1597: ECAA
1598: ECAA 2A 24 F5               LD     HL,(caDiskParamBlock)
1599: ECAD EB                     EX     DE,HL                ; DE is source
1600: ECAE 21 2A F5               LD     HL,dpbStart          ; start of Disk Parameter Block
1601: ECB1 0E 0F                  LD     C,dpbSize
1602: ECB3 CD 73 F4               CALL   Move                 ; load the table
1603: ECB6 2A 2F F5               LD     HL,(dpbDSM)          ; max entry number
1604: ECB9 7C                     LD     A,H                  ; if 00 then < 255
1605: ECBA 21 43 F5               LD     HL,single            ; point at the single byte entry flag
1606: ECBD 36 FF                  LD     (HL),TRUE            ; assume its less than 255
1607: ECBF B7                     OR     A                    ; assumtion confirmed ?
1608: ECC0 CA C5 EC               JP     Z,SelectDisk1        ; skip if yes
1609: ECC3 36 00                  LD     (HL),FALSE           ; correct assumption, set falg to false
1610: ECC5
1611: ECC5             SelectDisk1:
1612: ECC5 3E FF                  LD     A,TRUE
1613: ECC7 B7                     OR     A                    ; Set Sign, reset Carry and   Zero
1614: ECC8 C9                     RET
1615: ECC9
1616: ECC9         ;---------------
1617: ECC9         ; set a "1" value in currentDisk position of BC
1618: ECC9         ; return in HL
1619: ECC9             SetCurrentDiskBit:
1620: ECC9 C5                     PUSH   BC                   ; save input parameter
1621: ECCA 3A 14 F5               LD     A,(currentDisk)
1622: ECCD 4F                     LD     C,A                  ; ready parameter for shift
1623: ECCE 21 01 00               LD     HL,1                 ; number to shift
1624: ECD1 CD 6C F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1625: ECD4 C1                     POP    BC                   ; original mask
1626: ECD5 79                     LD     A,C
1627: ECD6 B5                     OR     L
1628: ECD7 6F                     LD     L,A
1629: ECD8 78                     LD     A,B
1630: ECD9 B4                     OR     H
1631: ECDA 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1632: ECDB C9                     RET
1633: ECDC         ;--------------
1634: ECDC         ;set current disk to read only
1635: ECDC             SetDiskReadOnly:
1636: ECDC 21 16 F5               LD     HL,ReadOnlyVector
1637: ECDF 4E                     LD     C,(HL)
1638: ECE0 23                     INC    HL
1639: ECE1 46                     LD     B,(HL)
1640: ECE2 CD C9 EC               CALL   SetCurrentDiskBit    ; sets bit to 1
1641: ECE5 22 16 F5               LD     (ReadOnlyVector),HL
1642: ECE8         ; high water mark in directory goes to max
1643: ECE8 2A 31 F5               LD     HL,(dpbDRM)          ; directory max
1644: ECEB EB                     EX     DE,HL                ; DE = directory max
1645: ECEC 2A 1C F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value
1646: ECEF 73                     LD     (HL),E
1647: ECF0 23                     INC    HL
1648: ECF1 72                     LD     (HL),D               ; cdrmax = dpbDRM
1649: ECF2 C9                     RET
1650: ECF3         ;----------------------- initialize the current disk
1651: ECF3         ;
1652: ECF3         ;exitParameterByte = false ;set to true if $ file exists
1653: ECF3         ; compute the length of the allocation vector - 2
1654: ECF3
1655: ECF3             InitDisk:
1656: ECF3 2A 2F F5               LD     HL,(dpbDSM)          ; get max allocation value
1657: ECF6 0E 03                  LD     C,3                  ; we want dpbDSM/8
1658: ECF8         ; number of bytes in alloc vector is (dpbDSM/8)+1
1659: ECF8 CD 5F F4               CALL   ShiftRightHLbyC
1660: ECFB 23                     INC    HL                   ; HL = dpbDSM/8+1
1661: ECFC 44                     LD     B,H
1662: ECFD 4D                     LD     C,L                  ; BC has size of AllocationVector
1663: ECFE 2A 28 F5               LD     HL,(caAllocVector)   ; base of allocation vector
1664: ED01         ;fill the allocation vector with zeros
1665: ED01             InitDisk0:
1666: ED01 36 00                  LD     (HL),0
1667: ED03 23                     INC    HL                   ; alloc(i)=0
1668: ED04 0B                     DEC    BC                   ; count length down
1669: ED05 78                     LD     A,B
1670: ED06 B1                     OR     C
1671: ED07 C2 01 ED               JP     NZ,InitDisk0
1672: ED0A         ; set the reserved space for the directory
1673: ED0A 2A 33 F5               LD     HL,(dpbDABM)         ; get the directory block reserved bits
1674: ED0D EB                     EX     DE,HL
1675: ED0E 2A 28 F5               LD     HL,(caAllocVector)   ; HL=.alloc()
1676: ED11 73                     LD     (HL),E
1677: ED12 23                     INC    HL
1678: ED13 72                     LD     (HL),D               ; sets reserved directory blks
1679: ED14         ; allocation vector initialized, home disk
1680: ED14 CD B8 ED               CALL   Home
1681: ED17         ; caDirMaxValue = 3 (scans at least one directory record)
1682: ED17 2A 1C F5               LD     HL,(caDirMaxValue)
1683: ED1A 36 03                  LD     (HL),3
1684: ED1C 23                     INC    HL
1685: ED1D 36 00                  LD     (HL),0               ; caDirMaxValue = 0003
1686: ED1F
1687: ED1F CD D2 ED               CALL   SetEndDirectory      ; dirEntryIndex = EOD
1688: ED22         ; read directory entries and check for allocated storage
1689: ED22             InitDisk1:
1690: ED22 0E FF                  LD     C,TRUE
1691: ED24 CD FA ED               CALL   ReadDirectory
1692: ED27 CD E8 ED               CALL   EndOfDirectory
1693: ED2A C8                     RET    Z                    ; return if end of directory
1694: ED2B         ; not end of directory, valid entry?
1695: ED2B CD D4 EE               CALL   GetDirElementAddress ; HL = caDirectoryDMA + dirBlockIndex
1696: ED2E 3E E5                  LD     A,emptyDir
1697: ED30 BE                     CP     M
1698: ED31 CA 22 ED               JP     Z,InitDisk1          ; go get another item
1699: ED34         ; not emptyDir, user code the same?
1700: ED34 3A 13 F5               LD     A,(currentUserNumber)
1701: ED37 BE                     CP     M
1702: ED38 C2 46 ED               JP     NZ,InitDisk2
1703: ED3B         ; same user code, check for '$' submit
1704: ED3B 23                     INC    HL
1705: ED3C 7E                     LD     A,(HL)               ; first character
1706: ED3D D6 24                  SUB    DOLLAR               ; dollar file?
1707: ED3F C2 46 ED               JP     NZ,InitDisk2
1708: ED42         ; dollar file found, mark in exitParameterByte
1709: ED42 3D                     DEC    A
1710: ED43 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte = 255
1711: ED46             InitDisk2:
1712: ED46         ; now scan the disk map for allocated blocks
1713: ED46 0E 01                  LD     C,1                  ; set to allocated
1714: ED48 CD 51 ED               CALL   ScanDiskMap
1715: ED4B CD DD EE               CALL   SetDirectoryEntry    ; set DirMaxVAlue to dirEntryIndex
1716: ED4E C3 22 ED               JP     InitDisk1            ; for another entry
1717: ED51         ;
1718: ED51         ;-------------Scan the disk map for unallocated entry-----------------------------------
1719: ED51         ; scan the disk map addressed by dptr for non-zero entries.  The allocation
1720: ED51         ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
1721: ED51             ScanDiskMap:
1722: ED51 CD D4 EE               CALL   GetDirElementAddress ; HL = buffa + dptr
1723: ED54         ; HL addresses the beginning of the directory entry
1724: ED54 11 10 00               LD     DE,fcbDiskMapIndex
1725: ED57 19                     ADD    HL,DE                ; hl now addresses the disk map
1726: ED58 C5                     PUSH   BC                   ; save the set/reset bit
1727: ED59 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; size of Disk Allocation Map + 1
1728: ED5B
1729: ED5B             ScanDiskMap0:                      ; loop once for each disk map entry
1730: ED5B D1                     POP    DE                   ; recall the set/reset bit
1731: ED5C 0D                     DEC    C
1732: ED5D C8                     RET    Z
1733: ED5E
1734: ED5E D5                     PUSH   DE                   ; save the set/reset bit
1735: ED5F 3A 43 F5               LD     A,(single)           ; single byte entry flag
1736: ED62 B7                     OR     A
1737: ED63 CA 6E ED               JP     Z,ScanDiskMap1       ; skip if two byte value
1738: ED66         ; single byte scan operation
1739: ED66 C5                     PUSH   BC                   ; save counter
1740: ED67 E5                     PUSH   HL                   ; save map address
1741: ED68 4E                     LD     C,(HL)
1742: ED69 06 00                  LD     B,0                  ; BC=block#
1743: ED6B C3 74 ED               JP     ScanDiskMap2
1744: ED6E         ; two byte scan operation
1745: ED6E             ScanDiskMap1:
1746: ED6E 0D                     DEC    C                    ; adjust counter for double byte
1747: ED6F C5                     PUSH   BC                   ; save counter
1748: ED70         ;	MOV		C,M
1749: ED70 46                     LD     B,(HL)
1750: ED71 23                     INC    HL
1751: ED72         ;	MOV		B,M								; BC=block#
1752: ED72 4E                     LD     C,(HL)               ; BC=block#
1753: ED73 E5                     PUSH   HL                   ; save map address
1754: ED74             ScanDiskMap2:                      ; arrive here with BC=block#, E=0/1
1755: ED74 79                     LD     A,C
1756: ED75 B0                     OR     B                    ; skip if = 0000
1757: ED76 C4 A6 ED               CALL   NZ,SetAllocBit       ; bit set to 0/1 its in C
1758: ED79 E1                     POP    HL
1759: ED7A 23                     INC    HL                   ; to next bit position
1760: ED7B C1                     POP    BC                   ; recall counter
1761: ED7C C3 5B ED               JP     ScanDiskMap0         ; for another item
1762: ED7F         ;
1763: ED7F         ;-----------------------------------
1764: ED7F         ;given allocation vector position BC, return with byte
1765: ED7F         ;containing BC shifted so that the least significant
1766: ED7F         ;bit is in the low order accumulator position.  HL is
1767: ED7F         ;the address of the byte for possible replacement in
1768: ED7F         ;memory upon return, and D contains the number of shifts
1769: ED7F         ;required to place the returned value back into position
1770: ED7F
1771: ED7F             GetAllocBit:                      ; getallocbit
1772: ED7F 79                     LD     A,C
1773: ED80 E6 07                  AND    111b
1774: ED82 3C                     INC    A
1775: ED83 5F                     LD     E,A
1776: ED84 57                     LD     D,A
1777: ED85         ; d and e both contain the number of bit positions to shift
1778: ED85 79                     LD     A,C
1779: ED86 0F                     RRCA
1780: ED87 0F                     RRCA
1781: ED88 0F                     RRCA
1782: ED89 E6 1F                  AND    11111b
1783: ED8B 4F                     LD     C,A                  ; C shr 3 to C
1784: ED8C 78                     LD     A,B
1785: ED8D 87                     ADD    A,A
1786: ED8E 87                     ADD    A,A
1787: ED8F 87                     ADD    A,A
1788: ED90 87                     ADD    A,A
1789: ED91 87                     ADD    A,A                  ; B shl 5
1790: ED92 B1                     OR     C
1791: ED93 4F                     LD     C,A                  ; bbbccccc to C
1792: ED94 78                     LD     A,B
1793: ED95 0F                     RRCA
1794: ED96 0F                     RRCA
1795: ED97 0F                     RRCA
1796: ED98 E6 1F                  AND    11111b
1797: ED9A 47                     LD     B,A                  ; BC shr 3 to BC
1798: ED9B 2A 28 F5               LD     HL,(caAllocVector)   ; base address of allocation vector
1799: ED9E 09                     ADD    HL,BC
1800: ED9F 7E                     LD     A,(HL)               ; byte to A, hl = .alloc(BC shr 3)
1801: EDA0         ;now move the bit to the low order position of A
1802: EDA0             GetAllocBitl:
1803: EDA0 07                     RLCA
1804: EDA1 1D                     DEC    E
1805: EDA2 C2 A0 ED               JP     NZ,GetAllocBitl
1806: EDA5 C9                     RET
1807: EDA6
1808: EDA6         ;-----------------------------------
1809: EDA6         ; BC is the bit position of ALLOC to set or reset.  The
1810: EDA6         ; value of the bit is in register E.
1811: EDA6             SetAllocBit:
1812: EDA6 D5                     PUSH   DE
1813: EDA7 CD 7F ED               CALL   GetAllocBit          ; shifted val A, count in D
1814: EDAA E6 FE                  AND    11111110b            ; mask low bit to zero (may be set)
1815: EDAC C1                     POP    BC
1816: EDAD B1                     OR     C                    ; low bit of C is masked into A
1817: EDAE C3 B1 ED               JP     RotateAndReplace     ; to rotate back into proper position
1818: EDB1         ;ret
1819: EDB1         ;-----------------------------------
1820: EDB1         ; byte value from ALLOC is in register A, with shift count
1821: EDB1         ; in register C (to place bit back into position), and
1822: EDB1         ; target ALLOC position in registers HL, rotate and replace
1823: EDB1             RotateAndReplace:
1824: EDB1 0F                     RRCA
1825: EDB2 15                     DEC    D
1826: EDB3 C2 B1 ED               JP     NZ,RotateAndReplace  ; back into position
1827: EDB6 77                     LD     (HL),A               ; back to ALLOC
1828: EDB7 C9                     RET
1829: EDB8         ;-----------------------------------
1830: EDB8
1831: EDB8         ;move to home position, then offset to start of dir
1832: EDB8             Home:
1833: EDB8 CD 18 F6               CALL   bcHome               ; move to track 00, sector 00 reference
1834: EDBB 21 37 F5               LD     HL,dpbOFF            ; get track ofset at begining
1835: EDBE 4E                     LD     C,(HL)
1836: EDBF 23                     INC    HL
1837: EDC0 46                     LD     B,(HL)
1838: EDC1 CD 1E F6               CALL   bcSettrk             ; select first directory position
1839: EDC4
1840: EDC4 AF                     XOR    A                    ; constant zero to accumulator
1841: EDC5 2A 1E F5               LD     HL,(caTrack)
1842: EDC8 77                     LD     (HL),A
1843: EDC9 23                     INC    HL
1844: EDCA 77                     LD     (HL),A               ; curtrk=0000
1845: EDCB 2A 20 F5               LD     HL,(caSector)
1846: EDCE 77                     LD     (HL),A
1847: EDCF 23                     INC    HL
1848: EDD0 77                     LD     (HL),A               ; currec=0000
1849: EDD1 C9                     RET
1850: EDD2
1851: EDD2
1852: EDD2         ;*****************************************************************
1853: EDD2
1854: EDD2         ;*****************************************************************
1855: EDD2         ;*****************************************************************
1856: EDD2         ; set directory counter to end  -1
1857: EDD2             SetEndDirectory:
1858: EDD2 21 FF FF               LD     HL,EOD
1859: EDD5 22 4E F5               LD     (dirEntryIndex),HL
1860: EDD8 C9                     RET
1861: EDD9         ;---------------
1862: EDD9             SetDataDMA:                      ; setdata
1863: EDD9 21 1A F5               LD     HL,InitDAMAddress
1864: EDDC C3 E2 ED               JP     SetDMA               ; to complete the call
1865: EDDF         ;---------------
1866: EDDF             SetDirDMA:                      ; setdir
1867: EDDF 21 22 F5               LD     HL,caDirectoryDMA
1868: EDE2
1869: EDE2             SetDMA:                         ; setdma
1870: EDE2 4E                     LD     C,(HL)
1871: EDE3 23                     INC    HL
1872: EDE4 46                     LD     B,(HL)               ; parameter ready
1873: EDE5 C3 24 F6               JP     bcSetdma             ; call bios to set
1874: EDE8         ;---------------
1875: EDE8         ;---------------
1876: EDE8         ; return zero flag if at end of directory
1877: EDE8         ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
1878: EDE8             EndOfDirectory:
1879: EDE8 21 4E F5               LD     HL,dirEntryIndex
1880: EDEB 7E                     LD     A,(HL)               ; may be 0ffh
1881: EDEC 23                     INC    HL
1882: EDED BE                     CP     M                    ; low(dirEntryIndex) = high(dirEntryIndex)?
1883: EDEE C0                     RET    NZ                   ; non zero returned if different
1884: EDEF         ; high and low the same, = 0ffh?
1885: EDEF 3C                     INC    A                    ; 0ffh becomes 00 if so
1886: EDF0 C9                     RET
1887: EDF1         ;---------------
1888: EDF1         ; read a directory entry into the directory buffer
1889: EDF1             ReadDirRecord:
1890: EDF1 CD DF ED               CALL   SetDirDMA            ; directory dma
1891: EDF4 CD 42 F2               CALL   ReadBuffer           ; directory record loaded
1892: EDF7 C3 D9 ED               JP     SetDataDMA           ; to data dma address
1893: EDFA         ;ret
1894: EDFA         ;---------------
1895: EDFA         ; read next directory entry, with C=true if initializing
1896: EDFA             ReadDirectory:
1897: EDFA 2A 31 F5               LD     HL,(dpbDRM)
1898: EDFD EB                     EX     DE,HL                ; determine number of directory entries
1899: EDFE 2A 4E F5               LD     HL,(dirEntryIndex)   ; index into directory
1900: EE01 23                     INC    HL
1901: EE02 22 4E F5               LD     (dirEntryIndex),HL   ; initialize directory index
1902: EE05         ; continue while dpbDRM >= dirEntryIndex (dpbDRM-dirEntryIndex no cy)
1903: EE05 CD 58 F4               CALL   DEminusHL2HL         ; DE-HL - processed all entries ?
1904: EE08 D2 0F EE               JP     NC,ReadDirectory0    ; no - do it again
1905: EE0B         ; yes, set dirEntryIndex to end of directory
1906: EE0B CD D2 ED               CALL   SetEndDirectory
1907: EE0E C9                     RET
1908: EE0F
1909: EE0F         ; not at end of directory, seek next element, initialization flag is in C
1910: EE0F             ReadDirectory0:
1911: EE0F 3A 4E F5               LD     A,(dirEntryIndex)
1912: EE12 E6 03                  AND    dirEntryMask         ; low(dirEntryIndex) and dirEntryMask
1913: EE14 06 05                  LD     B,fcbShift           ; to multiply by fcb size to get the correct index in dir record
1914: EE16             ReadDirectory1:
1915: EE16 87                     ADD    A,A
1916: EE17 05                     DEC    B
1917: EE18 C2 16 EE               JP     NZ,ReadDirectory1
1918: EE1B         ; A = (low(dirEntryIndex) and dirEntryMask) shl fcbShift
1919: EE1B 32 4D F5               LD     (dirBlockIndex),A    ; ready for next dir operation
1920: EE1E B7                     OR     A
1921: EE1F C0                     RET    NZ                   ; return if not a new record (Directory Block)
1922: EE20 C5                     PUSH   BC                   ; save initialization flag C
1923: EE21 CD 2B EE               CALL   SeekDir              ; seek$dir seek proper record
1924: EE24 CD F1 ED               CALL   ReadDirRecord        ; read the directory record
1925: EE27 C1                     POP    BC                   ; recall initialization flag
1926: EE28 C3 9F EE               JP     CalculateCheckSum    ; checksum the directory elt
1927: EE2B         ;---------
1928: EE2B         ;seek the record containing the current dir entry
1929: EE2B             SeekDir:
1930: EE2B 2A 4E F5               LD     HL,(dirEntryIndex)   ; directory counter to HL
1931: EE2E 0E 02                  LD     C,dirEntryShift      ; 4 entries per record
1932: EE30 CD 5F F4               CALL   ShiftRightHLbyC      ; value to HL
1933: EE33 22 4B F5               LD     (currentBlock),HL
1934: EE36 22 50 F5               LD     (dirRecord),HL       ; ready for seek
1935: EE39 C3 3C EE               JP     Seek
1936: EE3C         ;---------------------------
1937: EE3C             Seek:                           ; seek
1938: EE3C         ;seek the track given by currentBlock (actual record number)
1939: EE3C
1940: EE3C 21 4B F5               LD     HL,currentBlock      ; contains the cpm record number
1941: EE3F 4E                     LD     C,(HL)               ; Actual Record Number Low
1942: EE40 23                     INC    HL
1943: EE41 46                     LD     B,(HL)               ; Actual Record Number High
1944: EE42 2A 20 F5               LD     HL,(caSector)        ; Current Sector
1945: EE45 5E                     LD     E,(HL)               ; Current Sector Number Low
1946: EE46 23                     INC    HL
1947: EE47 56                     LD     D,(HL)               ; Current Sector Number High
1948: EE48 2A 1E F5               LD     HL,(caTrack)         ; Current track
1949: EE4B 7E                     LD     A,(HL)               ; Current track Number Low - temp
1950: EE4C 23                     INC    HL
1951: EE4D 66                     LD     H,(HL)               ; Current track Number High
1952: EE4E 6F                     LD     L,A                  ; Current track Number Low
1953: EE4F         ;(BC) - cpmRecord Number
1954: EE4F         ;(DE) - Current Sector
1955: EE4F         ;(HL) - Current Track
1956: EE4F
1957: EE4F         ;loop while currentBlock < currec   ?????
1958: EE4F             Seek0:
1959: EE4F 79                     LD     A,C                  ;   Current Sector
1960: EE50 93                     SUB    E                    ;
1961: EE51 78                     LD     A,B                  ; - cpmRecord Number
1962: EE52 9A                     SBC    A,D                  ;
1963: EE53 D2 65 EE               JP     NC,Seek1             ; skip if cpmRecord Number >= Current Sector
1964: EE56
1965: EE56 E5                     PUSH   HL
1966: EE57 2A 2A F5               LD     HL,(dpbSPT)
1967: EE5A 7B                     LD     A,E
1968: EE5B 95                     SUB    L
1969: EE5C 5F                     LD     E,A
1970: EE5D 7A                     LD     A,D
1971: EE5E 9C                     SBC    A,H
1972: EE5F 57                     LD     D,A
1973: EE60 E1                     POP    HL
1974: EE61 2B                     DEC    HL
1975: EE62 C3 4F EE               JP     Seek0
1976: EE65
1977: EE65             Seek1:
1978: EE65
1979: EE65 E5                     PUSH   HL                   ; Save Current Track
1980: EE66 2A 2A F5               LD     HL,(dpbSPT)          ; records per track
1981: EE69 19                     ADD    HL,DE                ; HL = Current Sector + sectorsPerClynder
1982: EE6A 79                     LD     A,C                  ;     cpmRecord Number
1983: EE6B 95                     SUB    L                    ;
1984: EE6C 78                     LD     A,B                  ;  - HL (above)
1985: EE6D 9C                     SBC    A,H                  ;
1986: EE6E DA 77 EE               JP     C,Seek2              ; skip if cpmRecord Number > HL (above)
1987: EE71
1988: EE71 EB                     EX     DE,HL
1989: EE72
1990: EE72 E1                     POP    HL
1991: EE73 23                     INC    HL
1992: EE74 C3 65 EE               JP     Seek1
1993: EE77
1994: EE77             Seek2:
1995: EE77 E1                     POP    HL                   ; retreive Current Track
1996: EE78 C5                     PUSH   BC                   ; save  cpmRecord Number
1997: EE79 D5                     PUSH   DE                   ; save  Current Sector
1998: EE7A E5                     PUSH   HL                   ; save CurrentTrack
1999: EE7B         ; stack contains CurrentTrack , Current Sector, cpmRecord Number
2000: EE7B EB                     EX     DE,HL                ; DE => CurrentTrack, HL => Current Sector
2001: EE7C 2A 37 F5               LD     HL,(dpbOFF)          ; Block Zero starting Track
2002: EE7F 19                     ADD    HL,DE                ; HL =  actual physical Track number
2003: EE80 44                     LD     B,H
2004: EE81 4D                     LD     C,L                  ; BC has physical Track number
2005: EE82 CD 1E F6               CALL   bcSettrk             ; track set up
2006: EE85         ; note that BC - curtrk is difference to move in bios
2007: EE85 D1                     POP    DE                   ; recall CurrentTrack
2008: EE86 2A 1E F5               LD     HL,(caTrack)         ; point at current Track
2009: EE89 73                     LD     (HL),E
2010: EE8A 23                     INC    HL
2011: EE8B 72                     LD     (HL),D               ; current Track updated
2012: EE8C         ; now compute sector as currentBlock-currec
2013: EE8C D1                     POP    DE                   ; recall Current Sector
2014: EE8D 2A 20 F5               LD     HL,(caSector)        ; point at current Sector
2015: EE90 73                     LD     (HL),E
2016: EE91 23                     INC    HL
2017: EE92 72                     LD     (HL),D               ; current sector updated / DE has currentSector
2018: EE93 C1                     POP    BC                   ; recall cpmRecord Number
2019: EE94 79                     LD     A,C                  ; cpmRecord Number
2020: EE95 93                     SUB    E
2021: EE96 4F                     LD     C,A                  ; - currentSector
2022: EE97 78                     LD     A,B
2023: EE98 9A                     SBC    A,D
2024: EE99 47                     LD     B,A                  ; back into BC
2025: EE9A C3 21 F6               JP     bcSetsec             ; sector selected
2026: EE9D         ;ret
2027: EE9D         ;************* CheckSum *******************************
2028: EE9D         ; compute current checksum record
2029: EE9D         ; if C = TRUE , update the allocation vector
2030: EE9D         ;
2031: EE9D         ; or check for = if not dirRecord < dpbCKS ????
2032: EE9D
2033: EE9D             NewCheckSum:
2034: EE9D 0E FF                  LD     C,TRUE
2035: EE9F
2036: EE9F             CalculateCheckSum:
2037: EE9F 2A 50 F5               LD     HL,(dirRecord)
2038: EEA2 EB                     EX     DE,HL
2039: EEA3 2A 35 F5               LD     HL,(dpbCKS)          ; size of checksum vector
2040: EEA6 CD 58 F4               CALL   DEminusHL2HL         ; DE-HL
2041: EEA9 D0                     RET    NC                   ; skip checksum if past checksum vector size
2042: EEAA C5                     PUSH   BC                   ; save init flag
2043: EEAB CD C7 EE               CALL   ComputeCheckSum      ; check sum value to A
2044: EEAE 2A 26 F5               LD     HL,(caCheckSum)      ; address of check sum vector
2045: EEB1 EB                     EX     DE,HL
2046: EEB2 2A 50 F5               LD     HL,(dirRecord)       ; value of dirRecord
2047: EEB5 19                     ADD    HL,DE                ; HL = .check(dirRecord)
2048: EEB6 C1                     POP    BC                   ; recall true=0ffh or false=00 to C
2049: EEB7 0C                     INC    C                    ; 0ffh produces zero flag
2050: EEB8 CA C5 EE               JP     Z,SetNewCheckSum
2051: EEBB         ; not initializing, compare
2052: EEBB BE                     CP     M                    ; compute$cs=check(dirRecord)?
2053: EEBC C8                     RET    Z                    ; no message if ok
2054: EEBD         ; possible checksum error, are we beyond the end of the disk?
2055: EEBD CD E6 EE               CALL   StillInDirectory
2056: EEC0 D0                     RET    NC                   ; no message if so
2057: EEC1 CD DC EC               CALL   SetDiskReadOnly      ; read/only disk set
2058: EEC4 C9                     RET
2059: EEC5
2060: EEC5         ;initializing the checksum
2061: EEC5             SetNewCheckSum:
2062: EEC5 77                     LD     (HL),A
2063: EEC6 C9                     RET
2064: EEC7         ;------------------
2065: EEC7         ;compute checksum for current directory buffer
2066: EEC7             ComputeCheckSum:
2067: EEC7 0E 80                  LD     C,cpmRecordSize      ; size of directory buffer
2068: EEC9 2A 22 F5               LD     HL,(caDirectoryDMA)  ; current directory buffer
2069: EECC AF                     XOR    A                    ; clear checksum value
2070: EECD             ComputeCheckSum0:
2071: EECD 86                     ADD    A,(HL)
2072: EECE 23                     INC    HL
2073: EECF 0D                     DEC    C                    ; cs=cs+buff(cpmRecordSize-C)
2074: EED0 C2 CD EE               JP     NZ,ComputeCheckSum0
2075: EED3 C9                     RET                         ; with checksum in A
2076: EED4         ;*****************************************************************
2077: EED4         ; compute the address of a directory element at positon dirBlockIndex in the buffer
2078: EED4             GetDirElementAddress:
2079: EED4 2A 22 F5               LD     HL,(caDirectoryDMA)
2080: EED7 3A 4D F5               LD     A,(dirBlockIndex)
2081: EEDA C3 53 F4               JP     AddAtoHL
2082: EEDD         ;---------------------
2083: EEDD         ;if not still in directory set max value
2084: EEDD             SetDirectoryEntry:
2085: EEDD CD E6 EE               CALL   StillInDirectory
2086: EEE0 D8                     RET    C
2087: EEE1         ; return if yes,otherwise, HL = DirMaxValue+1, DE = directoryCount
2088: EEE1
2089: EEE1 13                     INC    DE
2090: EEE2 72                     LD     (HL),D
2091: EEE3 2B                     DEC    HL
2092: EEE4 73                     LD     (HL),E
2093: EEE5 C9                     RET
2094: EEE6         ; return CY if entry is still in Directory
2095: EEE6             StillInDirectory:
2096: EEE6 2A 4E F5               LD     HL,(dirEntryIndex)
2097: EEE9 EB                     EX     DE,HL                ; DE = directory counter
2098: EEEA 2A 1C F5               LD     HL,(caDirMaxValue)   ; HL=caDirMaxValue
2099: EEED 7B                     LD     A,E
2100: EEEE 96                     SUB    M                    ; low(dirEntryIndex) - low(cdrmax)
2101: EEEF 23                     INC    HL                   ; HL = .cdrmax+1
2102: EEF0 7A                     LD     A,D
2103: EEF1 9E                     SBC    A,(HL)               ; hi(dirEntryIndex) - hig(cdrmax)
2104: EEF2         ;condition dirEntryIndex - cdrmax  produces cy if cdrmax>dirEntryIndex
2105: EEF2 C9                     RET
2106: EEF3         ;---------------------
2107: EEF3         ;compute fcbRCIndex and NEXT_RECORD addresses for get/setfcb
2108: EEF3         ; returns with DE pointing at RC from FCB
2109: EEF3         ;         with HL pointing at Next Record
2110: EEF3             GetFcbAddress:                      ; getfcba
2111: EEF3 2A C3 EA               LD     HL,(paramDE)
2112: EEF6 11 0F 00               LD     DE,fcbRCIndex
2113: EEF9 19                     ADD    HL,DE
2114: EEFA EB                     EX     DE,HL                ; DE=.fcb(fcbRCIndex)
2115: EEFB 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;RATS
2116: EEFE 19                     ADD    HL,DE                ; HL=.fcb(NEXT_RECORD)
2117: EEFF C9                     RET
2118: EF00         ;---------------------
2119: EF00         ;set variables from currently fcb - NEXT_RECORD, RC, EXM
2120: EF00             SetRecordVars:
2121: EF00 CD F3 EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2122: EF03 7E                     LD     A,(HL)
2123: EF04 32 49 F5               LD     (cpmRecord),A        ; cpmRecord=fcb(NEXT_RECORD)
2124: EF07 EB                     EX     DE,HL
2125: EF08 7E                     LD     A,(HL)
2126: EF09 32 47 F5               LD     (fcbRecordCount),A   ; fcbRecordCount=fcb(fcbRCIndex)
2127: EF0C CD CC F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2128: EF0F 3A 2E F5               LD     A,(dpbEXM)           ; extent mask to a
2129: EF12 A6                     AND    M                    ; fcb(fcbExtIndex) and dpbEXM
2130: EF13 32 48 F5               LD     (extentValue),A      ; save extent number
2131: EF16 C9                     RET
2132: EF17         ;---------------------
2133: EF17         ;update variables from I/O in  fcb
2134: EF17             UpdateRecordVars:
2135: EF17 CD F3 EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2136: EF1A 3A 3E F5               LD     A,(seqReadFlag)
2137: EF1D 4F                     LD     C,A                  ; =1 if sequential i/o
2138: EF1E 3A 49 F5               LD     A,(cpmRecord)        ; get NEXT_RECORD
2139: EF21 81                     ADD    A,C
2140: EF22 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=cpmRecord+seqReadFlag
2141: EF23 EB                     EX     DE,HL
2142: EF24 3A 47 F5               LD     A,(fcbRecordCount)
2143: EF27 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2144: EF28 C9                     RET
2145: EF29         ;---------------------
2146: EF29         ;set file Attributes for current fcb
2147: EF29             SetAttributes:
2148: EF29 0E 0C                  LD     C,fcbExtIndex
2149: EF2B CD 44 F3               CALL   Search4DirElement    ; through file type
2150: EF2E             SetAttributes1:
2151: EF2E CD E8 ED               CALL   EndOfDirectory
2152: EF31 C8                     RET    Z                    ; exit at end of dir
2153: EF32 0E 00                  LD     C,0
2154: EF34 1E 0C                  LD     E,fcbExtIndex        ;copy name
2155: EF36 CD 05 F4               CALL   CopyDir
2156: EF39 CD 5C F3               CALL   Search4NextDirElement
2157: EF3C C3 2E EF               JP     SetAttributes1
2158: EF3F         ;
2159: EF3F         ;*****************************************************************
2160: EF3F
2161: EF3F         ;*****************************************************************
2162: EF3F         ;********************** File  Routines ***************************
2163: EF3F         ;*****************************************************************
2164: EF3F         ;open file
2165: EF3F         ; IN  - (DE)	FCB Address
2166: EF3F         ; OUT - (A)	Directory Code
2167: EF3F         ;	0-3 = success ; 0FFH = File Not Found
2168: EF3F             vOpenFile:                      ;
2169: EF3F CD C5 F2               CALL   ClearModuleNum       ; clear the module number
2170: EF42 CD D4 F2               CALL   Reselect             ; do we need to reselect disk?
2171: EF45 C3 01 F3               JP     OpenFile
2172: EF48         ;ret ;jmp goback
2173: EF48         ;-----------------------------------------------------------------
2174: EF48         ;close file
2175: EF48             vCloseFile:                      ; func16: (16 - 10) Close File
2176: EF48 CD D4 F2               CALL   Reselect
2177: EF4B C3 A9 F1               JP     CloseDirEntry
2178: EF4E         ;-----------------------------------------------------------------
2179: EF4E         ;search for first occurrence of a file
2180: EF4E         ; In - (DE)	FCB Address
2181: EF4E         ; OUT - (A)	Directory Code
2182: EF4E         ;	0-3 = success ; 0FFH = File Not Found
2183: EF4E             vFindFirst:                      ; func17: (17 - 11) Search for first
2184: EF4E 0E 00                  LD     C,0                  ; length assuming '?' true
2185: EF50 2A C3 EA               LD     HL,(paramDE)
2186: EF53 7E                     LD     A,(HL)
2187: EF54 FE 3F                  CP     QMARK                ; no reselect if ?
2188: EF56 CA 61 EF               JP     Z,QMarkSelect        ; skip reselect if so
2189: EF59
2190: EF59 CD C5 F2               CALL   ClearModuleNum       ; module number zeroed
2191: EF5C CD D4 F2               CALL   Reselect
2192: EF5F 0E 0F                  LD     C,nameLength
2193: EF61             QMarkSelect:                      ; qselect:
2194: EF61 CD 44 F3               CALL   Search4DirElement
2195: EF64 C3 F2 F3               JP     CopyDirEntryToUser   ; copy directory entry to user
2196: EF67         ;-----------------------------------------------------------------
2197: EF67         ;search for next occurrence of a file name
2198: EF67         ; OUT - (A)	Directory Code
2199: EF67         ;	0-3 = success ; 0FFH = File Not Found
2200: EF67             vFindNext:                      ; func18: (18 - 12) Search for next
2201: EF67 2A 41 F5               LD     HL,(searchAddress)
2202: EF6A 22 C3 EA               LD     (paramDE),HL
2203: EF6D CD D4 F2               CALL   Reselect
2204: EF70 CD 5C F3               CALL   Search4NextDirElement
2205: EF73 C3 F2 F3               JP     CopyDirEntryToUser   ; copy directory entry to user
2206: EF76         ;-----------------------------------------------------------------
2207: EF76         ;search for next occurrence of a file name
2208: EF76         ; OUT - (A)	Directory Code
2209: EF76         ;delete a file
2210: EF76             vDeleteFile:                      ; func18: (19 - 13) Delete File
2211: EF76 CD D4 F2               CALL   Reselect
2212: EF79 CD 87 F1               CALL   DeleteFile
2213: EF7C C3 BE F2               JP     DirLocationToReturnLoc
2214: EF7F         ;-----------------------------------------------------------------
2215: EF7F         ;read sequential
2216: EF7F         ;IN  - (DE) FCB address
2217: EF7F         ;OUT - (A) 00 = success and data available. else no read and no data
2218: EF7F             vReadSeq:                       ; func20: (20 - 14) read sequential
2219: EF7F CD D4 F2               CALL   Reselect
2220: EF82 CD C1 EF               CALL   ReadSeq
2221: EF85 C9                     RET
2222: EF86         ;-----------------------------------------------------------------
2223: EF86         ;write sequential
2224: EF86         ;IN  - (DE) FCB address
2225: EF86         ;OUT - (A) 00 = success and data available. else no read and no data
2226: EF86             vWriteSeq:                      ; func21 (21 - 15) write sequention
2227: EF86 CD D4 F2               CALL   Reselect
2228: EF89 CD 04 F0               CALL   DiskWriteSeq
2229: EF8C C9                     RET
2230: EF8D         ;-----------------------------------------------------------------
2231: EF8D         ; Make file
2232: EF8D         ; In - (DE)	FCB Address
2233: EF8D         ; OUT - (A)	Directory Code
2234: EF8D         ;	0-3 = success ; 0FFH = File Not Found
2235: EF8D             vMakeFile:                      ; func22 (22 - 16) Make file
2236: EF8D CD C5 F2               CALL   ClearModuleNum       ; set S2 to Zero
2237: EF90 CD D4 F2               CALL   Reselect
2238: EF93 C3 51 F1               JP     MakeNewFile
2239: EF96         ;-----------------------------------------------------------------
2240: EF96         ; Rename file
2241: EF96         ; In - (DE)	FCB Address
2242: EF96         ; OUT - (A)	Directory Code
2243: EF96         ;	0-3 = success ; 0FFH = File Not Found
2244: EF96             vRenameFile:                      ; func23 (23 - 17) Rename File
2245: EF96 CD D4 F2               CALL   Reselect
2246: EF99 CD 2C F1               CALL   Rename
2247: EF9C C3 BE F2               JP     DirLocationToReturnLoc
2248: EF9F         ;-----------------------------------------------------------------
2249: EF9F         ;-----------------------------------------------------------------
2250: EF9F         ;*****************************************************************
2251: EF9F         ;-----------------------------------------------------------------
2252: EF9F         ;check current directory element for read/only status
2253: EF9F             CheckRODirectory:
2254: EF9F CD D4 EE               CALL   GetDirElementAddress ; address of element
2255: EFA2         ;	JMP	CheckROFile
2256: EFA2         ;------------
2257: EFA2         ;check current buff(dptr) or fcb(0) for r/o status
2258: EFA2             CheckROFile:
2259: EFA2 11 09 00               LD     DE,fcbROfileIndex
2260: EFA5 19                     ADD    HL,DE                ; offset to ro bit
2261: EFA6 7E                     LD     A,(HL)
2262: EFA7 17                     RLA
2263: EFA8 D0                     RET    NC                   ; return if not set
2264: EFA9 C3 8F F4               JP     errReadOnlyFile      ; exit to read only disk message
2265: EFAC         ;-----------------------------------------------------------------
2266: EFAC         ;check for write protected disk
2267: EFAC             CheckWrite:
2268: EFAC CD B3 EF               CALL   DoNotWrite
2269: EFAF C8                     RET    Z                    ; ok to write if not rodsk
2270: EFB0 C3 89 F4               JP     errReadOnlyDisk      ; read only disk error
2271: EFB3         ;-----------------------------------------------------------------
2272: EFB3         ;return true if dir checksum difference occurred
2273: EFB3             DoNotWrite:
2274: EFB3 2A 16 F5               LD     HL,(ReadOnlyVector)
2275: EFB6 3A 14 F5               LD     A,(currentDisk)
2276: EFB9 4F                     LD     C,A
2277: EFBA CD 5F F4               CALL   ShiftRightHLbyC
2278: EFBD 7D                     LD     A,L
2279: EFBE E6 1B                  AND    1BH                  ; 01BH
2280: EFC0 C9                     RET                         ; non zero if nowrite
2281: EFC1         ;-----------------------------------------------------------------
2282: EFC1         ;sequential disk read operation
2283: EFC1             ReadSeq:
2284: EFC1 3E 01                  LD     A,1
2285: EFC3 32 3E F5               LD     (seqReadFlag),A      ; set flag for seqential read
2286: EFC6         ;---
2287: EFC6         ; read the disk
2288: EFC6         ; read the next record from the current fcb
2289: EFC6             DiskRead:
2290: EFC6 3E FF                  LD     A,TRUE
2291: EFC8 32 3C F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
2292: EFCB
2293: EFCB CD 00 EF               CALL   SetRecordVars        ; sets cpmRecord, fcbRecordCount and EXM
2294: EFCE 3A 49 F5               LD     A,(cpmRecord)
2295: EFD1 21 47 F5               LD     HL,fcbRecordCount
2296: EFD4 BE                     CP     M                    ; cpmRecord-fcbRecordCount
2297: EFD5         ; skip if  cpmRecord < fcbRecordCount
2298: EFD5 DA EB EF               JP     C,RecordOK
2299: EFD8         ; not enough records in the extent
2300: EFD8 FE 80                  CP     RecordsPerExtent     ; cpmRecord = 128?   *** Records in an Extent
2301: EFDA C2 01 F0               JP     NZ,DiskEOF           ; skip if cpmRecord<>128
2302: EFDD CD C9 F0               CALL   OpenNextExt          ; go to next extent if so
2303: EFE0 AF                     XOR    A
2304: EFE1 32 49 F5               LD     (cpmRecord),A        ; cpmRecord=00
2305: EFE4         ; now check for open ok
2306: EFE4 3A C5 EA               LD     A,(exitParameterByte)
2307: EFE7 B7                     OR     A
2308: EFE8 C2 01 F0               JP     NZ,DiskEOF
2309: EFEB         ; stop at eof
2310: EFEB         ; arrive with fcb addressing a record to read
2311: EFEB             RecordOK:                       ; recordok:
2312: EFEB CD 92 F2               CALL   GetBlockNumber       ; save it in currentBlock
2313: EFEE CD 9F F2               CALL   IsAllocated          ; currentBlock=0000?
2314: EFF1 CA 01 F0               JP     Z,DiskEOF            ; get out if not allocated already
2315: EFF4
2316: EFF4 CD A5 F2               CALL   SetActualRecordAdd   ; currentBlock now a record value
2317: EFF7 CD 3C EE               CALL   Seek                 ; to proper track,sector
2318: EFFA CD 42 F2               CALL   ReadBuffer           ; to dma address
2319: EFFD CD 17 EF               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
2320: F000 C9                     RET
2321: F001             DiskEOF:                        ; diskeof:
2322: F001 C3 DB F3               JP     SetLowReturnTo1      ; exitParameterByte = 1
2323: F004         ;ret
2324: F004         ;-----------------------------------------------------------------
2325: F004         ;sequential disk write
2326: F004             DiskWriteSeq:
2327: F004 3E 01                  LD     A,1
2328: F006 32 3E F5               LD     (seqReadFlag),A
2329: F009         ;--------
2330: F009         ;disk write
2331: F009             DiskWrite:
2332: F009 3E 00                  LD     A,FALSE
2333: F00B 32 3C F5               LD     (readModeFlag),A
2334: F00E         ; write record to currently selected file
2335: F00E CD AC EF               CALL   CheckWrite           ; in case write protected
2336: F011 2A C3 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
2337: F014 CD A2 EF               CALL   CheckROFile          ; may be a read-only file
2338: F017 CD 00 EF               CALL   SetRecordVars        ; set local Record parameters
2339: F01A 3A 49 F5               LD     A,(cpmRecord)
2340: F01D FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
2341: F01F DA 26 F0               JP     C,DiskWrite1         ; skip if in the same Extent
2342: F022 CD DB F3               CALL   SetLowReturnTo1
2343: F025 C9                     RET                         ; Exit ???????????
2344: F026
2345: F026         ; can write the next record, so continue
2346: F026             DiskWrite1:
2347: F026 CD 92 F2               CALL   GetBlockNumber       ; sets up actual block number
2348: F029 CD 9F F2               CALL   IsAllocated
2349: F02C 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
2350: F02E C2 79 F0               JP     NZ,DiskWrite3
2351: F031         ; not allocated -
2352: F031         ; the argument to getblock is the starting position for the disk search
2353: F031         ; and should be the last allocated block for this file,
2354: F031         ; or the value 0 if no space has been allocated
2355: F031
2356: F031 CD 1A F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
2357: F034 32 3F F5               LD     (diskMapIndex),A     ; save for later
2358: F037 01 00 00               LD     BC,0000h             ; may use block zero
2359: F03A B7                     OR     A
2360: F03B CA 45 F0               JP     Z,FirstBlock         ; skip if no previous block
2361: F03E         ; previous block exists
2362: F03E 4F                     LD     C,A
2363: F03F 0B                     DEC    BC                   ; previous block # in BC
2364: F040 CD 3A F4               CALL   GetDiskMapValue      ; previous block # to HL
2365: F043 44                     LD     B,H
2366: F044 4D                     LD     C,L                  ; BC=prev block#
2367: F045         ; BC = 0000, or previous block #
2368: F045             FirstBlock:
2369: F045 CD 58 F2               CALL   GetClosestBlock      ; block # to HL
2370: F048         ; arrive here with block# or zero
2371: F048 7D                     LD     A,L
2372: F049 B4                     OR     H
2373: F04A C2 53 F0               JP     NZ,BlockOK
2374: F04D         ; cannot find a block to allocate
2375: F04D 3E 02                  LD     A,2
2376: F04F 32 C5 EA               LD     (exitParameterByte),A
2377: F052 C9                     RET                         ; exitParameterByte=2
2378: F053
2379: F053             BlockOK:
2380: F053 22 4B F5               LD     (currentBlock),HL    ; allocated block number is in HL
2381: F056 EB                     EX     DE,HL                ; block number to DE
2382: F057 2A C3 EA               LD     HL,(paramDE)
2383: F05A 01 10 00               LD     BC,fcbDiskMapIndex
2384: F05D 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
2385: F05E 3A 43 F5               LD     A,(single)
2386: F061 B7                     OR     A                    ; set flags for single byte dm
2387: F062 3A 3F F5               LD     A,(diskMapIndex)     ; recall dm index
2388: F065 CA 6F F0               JP     Z,Allocate16Bit      ; skip if allocating word
2389: F068         ; else allocate using a byte value
2390: F068 CD 53 F4               CALL   AddAtoHL
2391: F06B 73                     LD     (HL),E               ; single byte alloc
2392: F06C C3 77 F0               JP     DiskWrite2           ; to continue
2393: F06F
2394: F06F             Allocate16Bit:                      ; allocate a word value
2395: F06F
2396: F06F 4F                     LD     C,A
2397: F070 06 00                  LD     B,0                  ; double(diskMapIndex)
2398: F072 09                     ADD    HL,BC
2399: F073 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
2400: F074 72                     LD     (HL),D
2401: F075 23                     INC    HL
2402: F076 73                     LD     (HL),E               ; double wd
2403: F077         ; disk write to previously unallocated block
2404: F077             DiskWrite2:
2405: F077 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
2406: F079
2407: F079         ; continue the write operation of no allocation error
2408: F079         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
2409: F079
2410: F079             DiskWrite3:
2411: F079 3A C5 EA               LD     A,(exitParameterByte)
2412: F07C B7                     OR     A
2413: F07D C0                     RET    NZ                   ; stop if non zero returned value
2414: F07E
2415: F07E C5                     PUSH   BC                   ; save write flag ( in C see above)
2416: F07F CD A5 F2               CALL   SetActualRecordAdd   ; currentBlock set to actual record number
2417: F082 CD 3C EE               CALL   Seek                 ; to proper file position
2418: F085 C1                     POP    BC                   ; get write flag
2419: F086 C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
2420: F087 CD 3A F2               CALL   WriteBuffer          ; written to disk
2421: F08A C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
2422: F08B         ; increment record count if fcbRecordCount<=cpmRecord
2423: F08B 3A 49 F5               LD     A,(cpmRecord)
2424: F08E 21 47 F5               LD     HL,fcbRecordCount
2425: F091 BE                     CP     M                    ; cpmRecord-fcbRecordCount
2426: F092 DA 99 F0               JP     C,DiskWrite4
2427: F095         ; fcbRecordCount <= cpmRecord
2428: F095 77                     LD     (HL),A
2429: F096 34                     INC    M                    ; fcbRecordCount = cpmRecord+1
2430: F097 0E 02                  LD     C,2                  ; mark as record count incremented
2431: F099             DiskWrite4:
2432: F099         ; A has cpmRecord, C=2 if new block or new record#
2433: F099 0D                     DEC    C
2434: F09A 0D                     DEC    C
2435: F09B C2 A6 F0               JP     NZ,DiskWrite5
2436: F09E F5                     PUSH   AF                   ; save cpmRecord value
2437: F09F CD CB F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2438: F0A2         ; reset the file write flag to mark as written fcb
2439: F0A2 E6 7F                  AND    7FH                  ; not writeFlagMask
2440: F0A4 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2441: F0A5 F1                     POP    AF                   ; restore cpmRecord
2442: F0A6             DiskWrite5:
2443: F0A6         ; check for end of extent, if found attempt to open next extent in preparation for next write
2444: F0A6 FE 7F                  CP     highestRecordNumber  ; cpmRecord=highestRecordNumber?
2445: F0A8 C2 C6 F0               JP     NZ,DiskWrite7        ; skip if not
2446: F0AB         ; may be random access write, if so we are done
2447: F0AB 3A 3E F5               LD     A,(seqReadFlag)
2448: F0AE B7                     OR     A
2449: F0AF CA C6 F0               JP     Z,DiskWrite7         ; skip next extent open op
2450: F0B2         ; update current fcb before going to next extent
2451: F0B2 CD 17 EF               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2452: F0B5 CD C9 F0               CALL   OpenNextExt          ; readModeFlag=false
2453: F0B8         ; cpmRecord remains at highestRecordNumber causing eof if no more directory space is available
2454: F0B8 21 C5 EA               LD     HL,exitParameterByte
2455: F0BB 7E                     LD     A,(HL)
2456: F0BC B7                     OR     A
2457: F0BD C2 C4 F0               JP     NZ,DiskWrite6        ; no space
2458: F0C0         ; space available, set cpmRecord=255
2459: F0C0 3D                     DEC    A
2460: F0C1 32 49 F5               LD     (cpmRecord),A        ; goes to 00 next time
2461: F0C4             DiskWrite6:
2462: F0C4 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
2463: F0C6             DiskWrite7:
2464: F0C6 C3 17 EF               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2465: F0C9         ;ret
2466: F0C9         ;-----------------------------------------------------------------
2467: F0C9         ;close the current extent  and open the next one if possible.
2468: F0C9         ;readModeFlag is true if in read mode
2469: F0C9             OpenNextExt:                      ; open$reel
2470: F0C9 AF                     XOR    A
2471: F0CA 32 3B F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
2472: F0CD CD A9 F1               CALL   CloseDirEntry        ; close current extent
2473: F0D0         ; exitParameterByte remains at enddir if we cannot open the next ext
2474: F0D0 CD E8 ED               CALL   EndOfDirectory
2475: F0D3 C8                     RET    Z                    ; return if end
2476: F0D4 2A C3 EA               LD     HL,(paramDE)         ; increment extent number
2477: F0D7 01 0C 00               LD     BC,fcbExtIndex
2478: F0DA 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
2479: F0DB 7E                     LD     A,(HL)
2480: F0DC 3C                     INC    A
2481: F0DD E6 1F                  AND    maxExtValue
2482: F0DF 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
2483: F0E0 CA F2 F0               JP     Z,OpenNextModule     ; move to next module if zero
2484: F0E3         ; may be in the same extent group
2485: F0E3 47                     LD     B,A
2486: F0E4 3A 2E F5               LD     A,(dpbEXM)
2487: F0E7 A0                     AND    B
2488: F0E8         ; if result is zero, then not in the same group
2489: F0E8 21 3B F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
2490: F0EB A6                     AND    M                    ; produces a 00 in accumulator if not written
2491: F0EC CA FD F0               JP     Z,OpenNextExt1       ; go to next physical extent
2492: F0EF         ; result is non zero, so we must be in same logical ext
2493: F0EF C3 1B F1               JP     OpenNextExt2         ; to copy fcb information
2494: F0F2         ; extent number overflow, go to next module
2495: F0F2
2496: F0F2             OpenNextModule:
2497: F0F2 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
2498: F0F5 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
2499: F0F6 34                     INC    M                    ; fcb(fcbS2Index)=++1
2500: F0F7         ; module number incremented, check for overflow
2501: F0F7 7E                     LD     A,(HL)
2502: F0F8 E6 0F                  AND    moduleMask           ; mask high order bits
2503: F0FA CA 26 F1               JP     Z,OpenNextExtError   ; cannot overflow to zero
2504: F0FD         ; otherwise, ok to continue with new module
2505: F0FD
2506: F0FD             OpenNextExt1:
2507: F0FD 0E 0F                  LD     C,nameLength
2508: F0FF CD 44 F3               CALL   Search4DirElement    ; next extent found?
2509: F102 CD E8 ED               CALL   EndOfDirectory
2510: F105 C2 1B F1               JP     NZ,OpenNextExt2
2511: F108         ; end of file encountered
2512: F108 3A 3C F5               LD     A,(readModeFlag)
2513: F10B 3C                     INC    A                    ; 0ffh becomes 00 if read
2514: F10C CA 26 F1               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
2515: F10F         ; try to extend the current file
2516: F10F CD 51 F1               CALL   MakeNewFile
2517: F112         ; cannot be end of directory
2518: F112 CD E8 ED               CALL   EndOfDirectory
2519: F115 CA 26 F1               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
2520: F118 C3 1E F1               JP     OpenNextExt3
2521: F11B
2522: F11B         ; not end of file, open
2523: F11B             OpenNextExt2:
2524: F11B CD 0A F3               CALL   OpenFileCopyFCB
2525: F11E             OpenNextExt3:
2526: F11E CD 00 EF               CALL   SetRecordVars        ; Set Record parameters
2527: F121 AF                     XOR    A
2528: F122 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
2529: F125 C9                     RET                         ; with exitParameterByte = 0
2530: F126
2531: F126         ; cannot move to next extent of this file
2532: F126             OpenNextExtError:
2533: F126 CD DB F3               CALL   SetLowReturnTo1      ; exitParameterByte = 1
2534: F129 C3 D4 F3               JP     SetFileWriteFlag     ; ensure that it will not be closed
2535: F12C         ;-----------------------------------------------------------------
2536: F12C         ;rename the file described by the first half of the currently addressed FCB.
2537: F12C         ;the new name is contained in the last half of the FCB. The file name and type
2538: F12C         ;are changed, but the reel number is ignored.  the user number is identical
2539: F12C             Rename:
2540: F12C CD AC EF               CALL   CheckWrite           ; may be write protected
2541: F12F         ; search up to the extent field
2542: F12F 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
2543: F131 CD 44 F3               CALL   Search4DirElement
2544: F134         ; copy position 0
2545: F134 2A C3 EA               LD     HL,(paramDE)
2546: F137 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
2547: F138 11 10 00               LD     DE,fcbDiskMapIndex
2548: F13B 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
2549: F13C 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
2550: F13D         ; assume the same disk drive for new named file
2551: F13D             Rename1:
2552: F13D CD E8 ED               CALL   EndOfDirectory
2553: F140 C8                     RET    Z                    ; stop at end of dir
2554: F141         ; not end of directory, rename next element
2555: F141 CD 9F EF               CALL   CheckRODirectory     ; may be read-only file
2556: F144 0E 10                  LD     C,fcbDiskMapIndex
2557: F146 1E 0C                  LD     E,fcbExtIndex
2558: F148 CD 05 F4               CALL   CopyDir
2559: F14B         ; element renamed, move to next
2560: F14B CD 5C F3               CALL   Search4NextDirElement
2561: F14E C3 3D F1               JP     Rename1
2562: F151         ;-----------------------------------------------------------------
2563: F151         ;create a new file by creating a directory entry then opening the file
2564: F151             MakeNewFile:
2565: F151 CD AC EF               CALL   CheckWrite           ; may be write protected
2566: F154 2A C3 EA               LD     HL,(paramDE)
2567: F157 E5                     PUSH   HL                   ; save fcb address, look for e5
2568: F158 21 15 F5               LD     HL,emptyFCB
2569: F15B 22 C3 EA               LD     (paramDE),HL         ; paramDE = .empty
2570: F15E 0E 01                  LD     C,1
2571: F160 CD 44 F3               CALL   Search4DirElement    ; length 1 match on empty entry
2572: F163 CD E8 ED               CALL   EndOfDirectory       ; zero flag set if no space
2573: F166 E1                     POP    HL                   ; recall paramDE address
2574: F167 22 C3 EA               LD     (paramDE),HL         ; in case we return here
2575: F16A C8                     RET    Z                    ; return with error condition 255 if not found
2576: F16B EB                     EX     DE,HL                ; DE = paramDE address
2577: F16C         ; clear the remainder of the fcb
2578: F16C 21 0F 00               LD     HL,nameLength
2579: F16F 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
2580: F170 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
2581: F172 AF                     XOR    A                    ; clear accumulator to 00 for fill
2582: F173             MakeNewFile1:
2583: F173 77                     LD     (HL),A
2584: F174 23                     INC    HL
2585: F175 0D                     DEC    C
2586: F176 C2 73 F1               JP     NZ,MakeNewFile1
2587: F179 21 0D 00               LD     HL,fcbS1Index
2588: F17C 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
2589: F17D 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
2590: F17E CD DD EE               CALL   SetDirectoryEntry    ; may have extended the directory
2591: F181         ; now copy entry to the directory
2592: F181 CD FE F3               CALL   CopyFCB
2593: F184         ; and set the file write flag to "1"
2594: F184 C3 D4 F3               JP     SetFileWriteFlag
2595: F187         ;-----------------------------------------------------------------
2596: F187         ;delete the currently addressed file
2597: F187             DeleteFile:
2598: F187 CD AC EF               CALL   CheckWrite           ; write protected ?
2599: F18A 0E 0C                  LD     C,fcbExtIndex        ; extent number field
2600: F18C CD 44 F3               CALL   Search4DirElement    ; search through file type
2601: F18F             DeleteFile1:
2602: F18F         ; loop while directory matches
2603: F18F CD E8 ED               CALL   EndOfDirectory
2604: F192 C8                     RET    Z                    ; exit if end
2605: F193         ; set each non zero disk map entry to 0 in the allocation vector
2606: F193 CD 9F EF               CALL   CheckRODirectory     ; ro disk error if found
2607: F196 CD D4 EE               CALL   GetDirElementAddress ; HL=.buff(dptr)
2608: F199 36 E5                  LD     (HL),emptyDir
2609: F19B 0E 00                  LD     C,0
2610: F19D CD 51 ED               CALL   ScanDiskMap          ; alloc elts set to 0
2611: F1A0 CD 2C F2               CALL   WriteDir             ; write the directory
2612: F1A3 CD 5C F3               CALL   Search4NextDirElement ; to next element
2613: F1A6 C3 8F F1               JP     DeleteFile1          ; for another record
2614: F1A9         ;-----------------------------------------------------------------
2615: F1A9         ;locate the directory element and re-write it
2616: F1A9             CloseDirEntry:
2617: F1A9 AF                     XOR    A
2618: F1AA 32 C5 EA               LD     (exitParameterByte),A
2619: F1AD CD B3 EF               CALL   DoNotWrite           ; return TRUE (0) if checksum change
2620: F1B0 C0                     RET    NZ                   ; skip close if r/o disk
2621: F1B1         ; check file write flag - 0 indicates written
2622: F1B1 CD CB F2               CALL   GetModuleNum         ; fcb(fcbS2Index) in A
2623: F1B4 E6 80                  AND    writeFlagMask
2624: F1B6 C0                     RET    NZ                   ; return if bit remains set
2625: F1B7 0E 0F                  LD     C,nameLength
2626: F1B9 CD 44 F3               CALL   Search4DirElement    ; locate file
2627: F1BC CD E8 ED               CALL   EndOfDirectory
2628: F1BF C8                     RET    Z                    ; return if not found
2629: F1C0         ; merge the disk map at paramDE with that at buff(dptr)
2630: F1C0 01 10 00               LD     BC,fcbDiskMapIndex
2631: F1C3 CD D4 EE               CALL   GetDirElementAddress
2632: F1C6 09                     ADD    HL,BC
2633: F1C7 EB                     EX     DE,HL                ; DE is .buff(dptr+16)
2634: F1C8 2A C3 EA               LD     HL,(paramDE)
2635: F1CB 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
2636: F1CC 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of single byte dm
2637: F1CE             CloseDirEntry1:
2638: F1CE 3A 43 F5               LD     A,(single)
2639: F1D1 B7                     OR     A
2640: F1D2 CA E9 F1               JP     Z,CloseDirEntry4     ; skip to double
2641: F1D5         ; this is a single byte map
2642: F1D5         ; if fcb(i) = 0 then fcb(i) = buff(i)
2643: F1D5         ; if buff(i) = 0 then buff(i) = fcb(i)
2644: F1D5         ; if fcb(i) <> buff(i) then error
2645: F1D5 7E                     LD     A,(HL)
2646: F1D6 B7                     OR     A
2647: F1D7 1A                     LD     A,(DE)
2648: F1D8 C2 DC F1               JP     NZ,CloseDirEntry2
2649: F1DB         ; fcb(i) = 0
2650: F1DB 77                     LD     (HL),A               ; fcb(i) = buff(i)
2651: F1DC             CloseDirEntry2:
2652: F1DC B7                     OR     A
2653: F1DD C2 E2 F1               JP     NZ,CloseDirEntry3
2654: F1E0         ; buff(i) = 0
2655: F1E0 7E                     LD     A,(HL)
2656: F1E1 12                     LD     (DE),AE              ; buff(i)=fcb(i)
2657: F1E2             CloseDirEntry3:
2658: F1E2 BE                     CP     M
2659: F1E3 C2 21 F2               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
2660: F1E6 C3 FE F1               JP     CloseDirEntry5       ; if merge ok
2661: F1E9
2662: F1E9         ; this is a double byte merge operation
2663: F1E9             CloseDirEntry4:
2664: F1E9 CD 4A F2               CALL   Merge                ; buff = fcb if buff 0000
2665: F1EC EB                     EX     DE,HL
2666: F1ED CD 4A F2               CALL   Merge
2667: F1F0 EB                     EX     DE,HL                ; fcb = buff if fcb 0000
2668: F1F1         ; they should be identical at this point
2669: F1F1 1A                     LD     A,(DE)
2670: F1F2 BE                     CP     M
2671: F1F3 C2 21 F2               JP     NZ,CloseDirEntryError ; low same?
2672: F1F6 13                     INC    DE
2673: F1F7 23                     INC    HL                   ; to high byte
2674: F1F8 1A                     LD     A,(DE)
2675: F1F9 BE                     CP     M
2676: F1FA C2 21 F2               JP     NZ,CloseDirEntryError ; high same?
2677: F1FD         ;	merge operation ok for this pair
2678: F1FD 0D                     DEC    C                    ; extra count for double byte
2679: F1FE             CloseDirEntry5:
2680: F1FE 13                     INC    DE
2681: F1FF 23                     INC    HL                   ; to next byte position
2682: F200 0D                     DEC    C
2683: F201 C2 CE F1               JP     NZ,CloseDirEntry1    ; for more
2684: F204         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
2685: F204 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
2686: F207 09                     ADD    HL,BC
2687: F208 EB                     EX     DE,HL
2688: F209 09                     ADD    HL,BC
2689: F20A         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
2690: F20A 1A                     LD     A,(DE)               ; current user extent number
2691: F20B         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
2692: F20B BE                     CP     M
2693: F20C DA 18 F2               JP     C,CloseDirEntryEnd
2694: F20F         ; fcb extent number >= dir extent number
2695: F20F 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
2696: F210         ; update directory record count field
2697: F210 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
2698: F213 09                     ADD    HL,BC
2699: F214 EB                     EX     DE,HL
2700: F215 09                     ADD    HL,BC
2701: F216         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
2702: F216 7E                     LD     A,(HL)
2703: F217 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
2704: F218             CloseDirEntryEnd:
2705: F218 3E FF                  LD     A,TRUE
2706: F21A 32 3B F5               LD     (fcbCopiedFlag),A    ; mark as copied
2707: F21D CD 26 F2               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
2708: F220 C9                     RET
2709: F221
2710: F221         ; elements did not merge correctly
2711: F221             CloseDirEntryError:
2712: F221 21 C5 EA               LD     HL,exitParameterByte
2713: F224 35                     DEC    M                    ; =255 non zero flag set
2714: F225 C9                     RET
2715: F226         ;-----------------------------------------------------------------
2716: F226         ;enter from CloseDirEntry to seek and copy current element
2717: F226             SeekCopy:
2718: F226 CD 2B EE               CALL   SeekDir              ; to the directory element
2719: F229 C3 2C F2               JP     WriteDir             ; write the directory element
2720: F22C         ;ret
2721: F22C         ;-----------------------------------------------------------------
2722: F22C         ;write the current directory entry, set checksum
2723: F22C             WriteDir:
2724: F22C CD 9D EE               CALL   NewCheckSum          ; initialize entry
2725: F22F CD DF ED               CALL   SetDirDMA            ; directory dma
2726: F232 0E 01                  LD     C,1                  ; indicates a write directory operation
2727: F234 CD 3A F2               CALL   WriteBuffer          ; write the buffer
2728: F237 C3 D9 ED               JP     SetDataDMA           ; to data dma address
2729: F23A         ;ret
2730: F23A         ;-----------------------------------------------------------------
2731: F23A         ;write buffer and check condition
2732: F23A         ;write type (wrtype) is in register C
2733: F23A         ;wrtype = 0 => normal write operation		WriteAllocated
2734: F23A         ;wrtype = 1 => directory write operation	WriteDirectory
2735: F23A         ;wrtype = 2 => start of new block			WriteCleanBuffer
2736: F23A             WriteBuffer:
2737: F23A CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
2738: F23D B7                     OR     A
2739: F23E C2 A8 F4               JP     NZ,erPermanentNoWait ; error if not 00
2740: F241 C9                     RET
2741: F242         ;-----------------------------------------------------------------
2742: F242         ;read buffer and check condition
2743: F242             ReadBuffer:
2744: F242 CD 27 F6               CALL   bcRead               ; current drive, track, sector, dma
2745: F245 B7                     OR     A
2746: F246 C2 A8 F4               JP     NZ,erPermanentNoWait
2747: F249 C9                     RET
2748: F24A         ;-----------------------------------------------------------------
2749: F24A         ;HL = .fcb1(i), DE = .fcb2(i),
2750: F24A         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
2751: F24A             Merge:
2752: F24A 7E                     LD     A,(HL)
2753: F24B 23                     INC    HL
2754: F24C B6                     OR     M
2755: F24D 2B                     DEC    HL
2756: F24E C0                     RET    NZ                   ; return if = 0000
2757: F24F 1A                     LD     A,(DE)
2758: F250 77                     LD     (HL),A
2759: F251 13                     INC    DE
2760: F252 23                     INC    HL                   ; low byte copied
2761: F253 1A                     LD     A,(DE)
2762: F254 77                     LD     (HL),A
2763: F255 1B                     DEC    DE
2764: F256 2B                     DEC    HL                   ; back to input form
2765: F257 C9                     RET
2766: F258         ;-----------------------------------------------------------------
2767: F258         ;compute closest disk block number from current block
2768: F258         ;given allocation vector position BC, find the zero bit closest to this position
2769: F258         ;by searching left and right.
2770: F258         ;if found, set the bit to one and return the bit position in hl.
2771: F258         ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
2772: F258             GetClosestBlock:
2773: F258 50                     LD     D,B
2774: F259 59                     LD     E,C                  ; copy of starting position to de
2775: F25A             TestLeft:
2776: F25A 79                     LD     A,C
2777: F25B B0                     OR     B
2778: F25C CA 6B F2               JP     Z,TestRight          ; skip if left=0000
2779: F25F         ; left not at position zero, bit zero?
2780: F25F 0B                     DEC    BC
2781: F260 D5                     PUSH   DE
2782: F261 C5                     PUSH   BC                   ; left,right pushed
2783: F262 CD 7F ED               CALL   GetAllocBit
2784: F265 1F                     RRA
2785: F266 D2 86 F2               JP     NC,ReturnBlockNumber ; return block number if zero
2786: F269         ; bit is one, so try the right
2787: F269 C1                     POP    BC
2788: F26A D1                     POP    DE                   ; left, right restored
2789: F26B             TestRight:
2790: F26B 2A 2F F5               LD     HL,(dpbDSM)          ; value of maximum allocation#
2791: F26E 7B                     LD     A,E
2792: F26F 95                     SUB    L
2793: F270 7A                     LD     A,D
2794: F271 9C                     SBC    A,H                  ; right=dpbDSM?
2795: F272 D2 8E F2               JP     NC,ReturnBlockZero   ; return block 0000 if so
2796: F275 13                     INC    DE
2797: F276 C5                     PUSH   BC
2798: F277 D5                     PUSH   DE                   ; left, right pushed
2799: F278 42                     LD     B,D
2800: F279 4B                     LD     C,E                  ; ready right for call
2801: F27A CD 7F ED               CALL   GetAllocBit
2802: F27D 1F                     RRA
2803: F27E D2 86 F2               JP     NC,ReturnBlockNumber ; return block number if zero
2804: F281 D1                     POP    DE
2805: F282 C1                     POP    BC                   ; restore left and right pointers
2806: F283 C3 5A F2               JP     TestLeft             ; for another attempt
2807: F286             ReturnBlockNumber:
2808: F286 17                     RLA
2809: F287 3C                     INC    A                    ; bit back into position and set to 1
2810: F288         ; 	D contains the number of shifts required to reposition
2811: F288 CD B1 ED               CALL   RotateAndReplace     ; move bit back to position and store
2812: F28B E1                     POP    HL
2813: F28C D1                     POP    DE                   ; HL returned value, DE discarded
2814: F28D C9                     RET
2815: F28E
2816: F28E         ; cannot find an available bit, return 0000
2817: F28E             ReturnBlockZero:
2818: F28E 21 00 00               LD     HL,0000H
2819: F291 C9                     RET
2820: F292         ;-----------------------------------------------------------------
2821: F292         ;compute disk block number from current fcb
2822: F292             GetBlockNumber:
2823: F292 CD 1A F4               CALL   GetDiskMapIndex      ; 0...15 in register A
2824: F295 4F                     LD     C,A
2825: F296 06 00                  LD     B,0
2826: F298 CD 3A F4               CALL   GetDiskMapValue      ; return value in HL
2827: F29B 22 4B F5               LD     (currentBlock),HL    ; save for later
2828: F29E C9                     RET
2829: F29F         ;-----------------------------------------------------------------
2830: F29F         ;is  block allocated
2831: F29F             IsAllocated:
2832: F29F 2A 4B F5               LD     HL,(currentBlock)
2833: F2A2 7D                     LD     A,L
2834: F2A3 B4                     OR     H
2835: F2A4 C9                     RET
2836: F2A5         ;-----------------------------------------------------------------
2837: F2A5         ;compute actual record address
2838: F2A5         ; result = currentBlock * ( 2**BSH)
2839: F2A5             SetActualRecordAdd:
2840: F2A5 3A 2C F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
2841: F2A8 2A 4B F5               LD     HL,(currentBlock)
2842: F2AB
2843: F2AB             SetActualRecordAdd1:
2844: F2AB 29                     ADD    HL,HL
2845: F2AC 3D                     DEC    A                    ; shl(currentBlock,dpbBSH)
2846: F2AD C2 AB F2               JP     NZ,SetActualRecordAdd1
2847: F2B0         ; HL has Record number for start of the block;
2848: F2B0 3A 2D F5               LD     A,(dpbBLM)           ; get block mask
2849: F2B3 4F                     LD     C,A                  ; to get cpmRecord mod Block
2850: F2B4 3A 49 F5               LD     A,(cpmRecord)        ; get index into block
2851: F2B7 A1                     AND    C                    ; masked value in A
2852: F2B8 B5                     OR     L
2853: F2B9 6F                     LD     L,A                  ; to HL
2854: F2BA 22 4B F5               LD     (currentBlock),HL    ; currentBlock=HL or (cpmRecord and dpbBLM)
2855: F2BD         ; *** currentBlock now has current record number - Starting record number + index into block
2856: F2BD C9                     RET
2857: F2BE         ;-----------------------------------------------------------------
2858: F2BE         ;---------------------
2859: F2BE         ;copy directory location to exitParameterByte
2860: F2BE             DirLocationToReturnLoc:
2861: F2BE 3A 3D F5               LD     A,(directoryFlag)
2862: F2C1 32 C5 EA               LD     (exitParameterByte),A
2863: F2C4 C9                     RET
2864: F2C5         ;---------------------
2865: F2C5         ;clear the module number field for user open/make (S2)
2866: F2C5             ClearModuleNum:
2867: F2C5 CD CB F2               CALL   GetModuleNum
2868: F2C8 36 00                  LD     (HL),0               ; fcb(fcbS2Index)=0
2869: F2CA C9                     RET
2870: F2CB         ;---------------------
2871: F2CB         ;get data module number (high order bit is fwf -file write flag)
2872: F2CB             GetModuleNum:
2873: F2CB 2A C3 EA               LD     HL,(paramDE)
2874: F2CE 11 0E 00               LD     DE,fcbS2Index
2875: F2D1 19                     ADD    HL,DE                ; HL=.fcb(fcbS2Index)
2876: F2D2 7E                     LD     A,(HL)
2877: F2D3 C9                     RET                         ; A=fcb(fcbS2Index)
2878: F2D4         ;---------------------
2879: F2D4         ;check current fcb to see if reselection necessary
2880: F2D4             Reselect:
2881: F2D4 3E FF                  LD     A,TRUE
2882: F2D6 32 44 F5               LD     (fResel),A           ;mark possible reselect
2883: F2D9 2A C3 EA               LD     HL,(paramDE)
2884: F2DC 7E                     LD     A,(HL)               ; drive select code
2885: F2DD E6 1F                  AND    00011111B            ; non zero is auto drive select
2886: F2DF 3D                     DEC    A                    ; drive code normalized to 0..30, or 255
2887: F2E0 32 C2 EA               LD     (paramE),A           ; save drive code
2888: F2E3 FE 1E                  CP     30
2889: F2E5 D2 F8 F2               JP     NC,NoSelect
2890: F2E8         ; auto select function, save currentDisk
2891: F2E8 3A 14 F5               LD     A,(currentDisk)
2892: F2EB 32 45 F5               LD     (entryDisk),A        ; entryDisk=currentDisk
2893: F2EE 7E                     LD     A,(HL)
2894: F2EF 32 46 F5               LD     (fcbDisk),A          ; save drive code
2895: F2F2 E6 E0                  AND    11100000B
2896: F2F4 77                     LD     (HL),A               ; preserve hi bits
2897: F2F5 CD 51 EC               CALL   SelectCurrent
2898: F2F8             NoSelect:                       ; noselect:
2899: F2F8
2900: F2F8 3A 13 F5               LD     A,(currentUserNumber) ; set user code 0...31
2901: F2FB 2A C3 EA               LD     HL,(paramDE)
2902: F2FE B6                     OR     M
2903: F2FF 77                     LD     (HL),A
2904: F300 C9                     RET
2905: F301         ;---------------------
2906: F301         ;search for the directory entry, copy to fcb
2907: F301             OpenFile:
2908: F301 0E 0F                  LD     C,nameLength
2909: F303 CD 44 F3               CALL   Search4DirElement
2910: F306 CD E8 ED               CALL   EndOfDirectory
2911: F309 C8                     RET    Z                    ; return with exitParameterByte=255 if end
2912: F30A
2913: F30A         ; not end of directory, copy fcb information
2914: F30A             OpenFileCopyFCB:
2915: F30A CD CC F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2916: F30D 7E                     LD     A,(HL)
2917: F30E F5                     PUSH   AF
2918: F30F E5                     PUSH   HL                   ; save extent#
2919: F310 CD D4 EE               CALL   GetDirElementAddress
2920: F313 EB                     EX     DE,HL                ; DE = .buff(dptr)
2921: F314 2A C3 EA               LD     HL,(paramDE)         ; HL=.fcb(0)
2922: F317 0E 20                  LD     C,NEXT_RECORD        ; length of move operation
2923: F319 D5                     PUSH   DE                   ; save .buff(dptr)
2924: F31A CD 73 F4               CALL   Move                 ; from .buff(dptr) to .fcb(0)
2925: F31D         ; note that entire fcb is copied, including indicators
2926: F31D CD D4 F3               CALL   SetFileWriteFlag     ; sets file write flag
2927: F320 D1                     POP    DE
2928: F321 21 0C 00               LD     HL,fcbExtIndex
2929: F324 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbExtIndex)
2930: F325 4E                     LD     C,(HL)               ; C = directory extent number
2931: F326 21 0F 00               LD     HL,fcbRCIndex        ; point at the record Count field
2932: F329 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbRCIndex)
2933: F32A 46                     LD     B,(HL)               ; B holds directory record count
2934: F32B E1                     POP    HL
2935: F32C F1                     POP    AF
2936: F32D 77                     LD     (HL),A               ; restore extent number
2937: F32E         ; HL = .user extent#, B = dir rec cnt, C = dir extent#
2938: F32E         ; if user ext < dir ext then user := 128 records
2939: F32E         ; if user ext = dir ext then user := dir records
2940: F32E         ; if user ext > dir ext then user := 0 records
2941: F32E 79                     LD     A,C
2942: F32F BE                     CP     M
2943: F330 78                     LD     A,B                  ; ready dir fcbRCIndex
2944: F331 CA 3B F3               JP     Z,OpenRecordCount    ; if same, user gets dir fcbRCIndex
2945: F334 3E 00                  LD     A,0
2946: F336 DA 3B F3               JP     C,OpenRecordCount    ; user is larger
2947: F339 3E 80                  LD     A,RecordsPerExtent   ; directory is larger >>>RecordsPerExtent
2948: F33B             OpenRecordCount:                      ;Acc has record count to fill
2949: F33B 2A C3 EA               LD     HL,(paramDE)
2950: F33E 11 0F 00               LD     DE,fcbRCIndex
2951: F341 19                     ADD    HL,DE
2952: F342 77                     LD     (HL),A
2953: F343 C9                     RET
2954: F344
2955: F344         ;---------------------
2956: F344         ;search for directory element of length C at info
2957: F344             Search4DirElement:
2958: F344 3E FF                  LD     A,0FFH
2959: F346 32 3D F5               LD     (directoryFlag),A    ; changed if actually found
2960: F349 21 40 F5               LD     HL,searchLength
2961: F34C 71                     LD     (HL),C               ; searchLength = C
2962: F34D 2A C3 EA               LD     HL,(paramDE)
2963: F350 22 41 F5               LD     (searchAddress),HL   ; searchAddress = paramDE
2964: F353 CD D2 ED               CALL   SetEndDirectory      ; dirEntryIndex = enddir
2965: F356 CD B8 ED               CALL   Home                 ; to start at the beginning
2966: F359 C3 5C F3               JP     Search4NextDirElement
2967: F35C         ;---------------------
2968: F35C         ;search for the next directory element, assuming a previous
2969: F35C         ;call on search which sets searchAddress and searchLength
2970: F35C             Search4NextDirElement:
2971: F35C 0E 00                  LD     C,FALSE
2972: F35E CD FA ED               CALL   ReadDirectory        ; read next dir element
2973: F361 CD E8 ED               CALL   EndOfDirectory
2974: F364 CA C3 F3               JP     Z,SearchDone         ; skip to end if so
2975: F367         ; not end of directory, scan for match
2976: F367 2A 41 F5               LD     HL,(searchAddress)
2977: F36A EB                     EX     DE,HL                ; DE=beginning of user fcb
2978: F36B 1A                     LD     A,(DE)               ; first character
2979: F36C FE E5                  CP     emptyDir             ; keep scanning if Dir entry is empty
2980: F36E CA 79 F3               JP     Z,Search4NextDirElement1
2981: F371         ; not emptyDir, may be end of logical directory
2982: F371 D5                     PUSH   DE                   ; save search address
2983: F372 CD E6 EE               CALL   StillInDirectory     ; past logical end?
2984: F375 D1                     POP    DE                   ; recall address
2985: F376 D2 C3 F3               JP     NC,SearchDone        ; artificial stop
2986: F379             Search4NextDirElement1:
2987: F379 CD D4 EE               CALL   GetDirElementAddress ; HL = buffa+dptr
2988: F37C 3A 40 F5               LD     A,(searchLength)
2989: F37F 4F                     LD     C,A                  ; length of search to c
2990: F380 06 00                  LD     B,0                  ; bcounts up, c counts down
2991: F382             Search4NextLoop:
2992: F382 79                     LD     A,C
2993: F383 B7                     OR     A
2994: F384 CA B2 F3               JP     Z,EndDirElementSearch
2995: F387 1A                     LD     A,(DE)
2996: F388 FE 3F                  CP     QMARK
2997: F38A CA AB F3               JP     Z,Search4NextOK      ; ? matches all
2998: F38D         ; scan next character if not fcbS1Index
2999: F38D 78                     LD     A,B
3000: F38E FE 0D                  CP     fcbS1Index
3001: F390 CA AB F3               JP     Z,Search4NextOK
3002: F393         ; not the fcbS1Index field, extent field?
3003: F393 FE 0C                  CP     fcbExtIndex          ; may be extent field
3004: F395 1A                     LD     A,(DE)               ; fcb character
3005: F396 CA A2 F3               JP     Z,Search4Ext         ; skip to search extent
3006: F399 96                     SUB    M
3007: F39A E6 7F                  AND    07FH                 ; mask-out flags/extent modulus
3008: F39C C2 5C F3               JP     NZ,Search4NextDirElement ; skip if not matched
3009: F39F C3 AB F3               JP     Search4NextOK        ;matched character
3010: F3A2
3011: F3A2         ; A has fcb character attempt an extent # match
3012: F3A2             Search4Ext:
3013: F3A2 C5                     PUSH   BC                   ; save counters
3014: F3A3 4E                     LD     C,(HL)               ; directory character to c
3015: F3A4 CD E1 F3               CALL   CompareExtents       ; compare user/dir char
3016: F3A7 C1                     POP    BC                   ; recall counters
3017: F3A8 C2 5C F3               JP     NZ,Search4NextDirElement ; skip if no match
3018: F3AB
3019: F3AB         ; current character matches
3020: F3AB             Search4NextOK:
3021: F3AB 13                     INC    DE
3022: F3AC 23                     INC    HL
3023: F3AD 04                     INC    B
3024: F3AE 0D                     DEC    C
3025: F3AF C3 82 F3               JP     Search4NextLoop
3026: F3B2
3027: F3B2         ; entire name matches, return dir position
3028: F3B2             EndDirElementSearch:
3029: F3B2 3A 4E F5               LD     A,(dirEntryIndex)
3030: F3B5 E6 03                  AND    dirEntryMask
3031: F3B7 32 C5 EA               LD     (exitParameterByte),A
3032: F3BA         ; exitParameterByte = low(dirEntryIndex) and 11b
3033: F3BA 21 3D F5               LD     HL,directoryFlag
3034: F3BD 7E                     LD     A,(HL)
3035: F3BE 17                     RLA
3036: F3BF D0                     RET    NC                   ; directoryFlag=0ffh?
3037: F3C0         ; yes, change it to 0 to mark as found
3038: F3C0 AF                     XOR    A
3039: F3C1 77                     LD     (HL),A               ; directoryFlag=0
3040: F3C2 C9                     RET
3041: F3C3
3042: F3C3         ; end of directory, or empty name
3043: F3C3             SearchDone:
3044: F3C3 CD D2 ED               CALL   SetEndDirectory      ; may be artifical end
3045: F3C6 3E FF                  LD     A,0FFH
3046: F3C8 32 C5 EA               LD     (exitParameterByte),A
3047: F3CB C9                     RET
3048: F3CC         ;---------------------
3049: F3CC         ;get current extent field address to (HL)
3050: F3CC             GetExtentAddress:
3051: F3CC 2A C3 EA               LD     HL,(paramDE)
3052: F3CF 11 0C 00               LD     DE,fcbExtIndex
3053: F3D2 19                     ADD    HL,DE                ;HL=.fcb(fcbExtIndex)
3054: F3D3 C9                     RET
3055: F3D4         ;---------------------
3056: F3D4         ;Set file write flag
3057: F3D4             SetFileWriteFlag:
3058: F3D4 CD CB F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3059: F3D7 F6 80                  OR     writeFlagMask        ; set fwf (file write flag) to "1"
3060: F3D9 77                     LD     (HL),A               ; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
3061: F3DA C9                     RET                         ; also returns non zero in accumulator
3062: F3DB         ;---------------------
3063: F3DB         ;set exitParameterByte to 1
3064: F3DB             SetLowReturnTo1:
3065: F3DB 3E 01                  LD     A,1
3066: F3DD 32 C5 EA               LD     (exitParameterByte),A
3067: F3E0 C9                     RET
3068: F3E1         ;---------------------
3069: F3E1         ;compare extent# in A with that in C, return nonzero if they do not match
3070: F3E1             CompareExtents:
3071: F3E1 C5                     PUSH   BC                   ; save C's original value
3072: F3E2 F5                     PUSH   AF
3073: F3E3 3A 2E F5               LD     A,(dpbEXM)
3074: F3E6 2F                     CPL
3075: F3E7 47                     LD     B,A
3076: F3E8         ; B has negated form of extent mask
3077: F3E8 79                     LD     A,C
3078: F3E9 A0                     AND    B
3079: F3EA 4F                     LD     C,A                  ; low bits removed from C
3080: F3EB F1                     POP    AF
3081: F3EC A0                     AND    B                    ; low bits removed from A
3082: F3ED 91                     SUB    C
3083: F3EE E6 1F                  AND    maxExtValue          ; set flags
3084: F3F0 C1                     POP    BC                   ; restore original values
3085: F3F1 C9                     RET
3086: F3F2         ;---------------------
3087: F3F2         ;copy the directory entry to the user buffer
3088: F3F2             CopyDirEntryToUser:
3089: F3F2 2A 22 F5               LD     HL,(caDirectoryDMA)
3090: F3F5 EB                     EX     DE,HL                ; source is directory buffer
3091: F3F6 2A 1A F5               LD     HL,(InitDAMAddress)  ; destination is user dma address
3092: F3F9 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3093: F3FB C3 73 F4               JP     Move
3094: F3FE         ;---------------------
3095: F3FE         ;copy the whole file control block
3096: F3FE             CopyFCB:
3097: F3FE 0E 00                  LD     C,0
3098: F400 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3099: F402 C3 05 F4               JP     CopyDir
3100: F405         ;---------------------
3101: F405         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3102: F405             CopyDir:
3103: F405 D5                     PUSH   DE                   ; save length for later
3104: F406 06 00                  LD     B,0                  ; double index to BC
3105: F408 2A C3 EA               LD     HL,(paramDE)         ; HL = source for data
3106: F40B 09                     ADD    HL,BC
3107: F40C EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3108: F40D CD D4 EE               CALL   GetDirElementAddress ; HL=.buff(dptr), destination
3109: F410 C1                     POP    BC                   ; DE=source, HL=dest, C=length
3110: F411 CD 73 F4               CALL   Move                 ; data moved
3111: F414         ;enter from close to seek and copy current element
3112: F414             SeekAndCopy:                      ; seek$copy:
3113: F414 CD 2B EE               CALL   SeekDir              ; seek$dir ;to the directory element
3114: F417 C3 2C F2               JP     WriteDir             ; write the directory element
3115: F41A         ;---------------------
3116: F41A         ;Return the  disk map Index for cpmRecord in the ACC
3117: F41A         ;  account for multiple extents in 1 physical Directory entry
3118: F41A             GetDiskMapIndex:                      ; dm$position
3119: F41A 21 2C F5               LD     HL,dpbBSH            ; get block shift value
3120: F41D 4E                     LD     C,(HL)               ; shift count to C
3121: F41E 3A 49 F5               LD     A,(cpmRecord)        ; current virtual record to A
3122: F421             GetDiskMapIndex1:
3123: F421 B7                     OR     A                    ; reset the carry flag
3124: F422 1F                     RRA
3125: F423 0D                     DEC    C
3126: F424 C2 21 F4               JP     NZ,GetDiskMapIndex1
3127: F427         ; A = shr(cpmRecord,dpbBSH) = cpmRecord/2**(sect/block)
3128: F427         ; A has the relative position in the block.
3129: F427 47                     LD     B,A                  ; save it for later addition
3130: F428 3E 08                  LD     A,8
3131: F42A 96                     SUB    M                    ; 8-dpbBSH to accumulator
3132: F42B 4F                     LD     C,A                  ; extent shift count in register c
3133: F42C 3A 48 F5               LD     A,(extentValue)      ; extent value ani extmsk
3134: F42F             GetDiskMapIndex2:                      ; dmpos1:
3135: F42F         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3136: F42F         ; shift is 4,3,2,1,0
3137: F42F 0D                     DEC    C
3138: F430 CA 38 F4               JP     Z,GetDiskMapIndex3
3139: F433 B7                     OR     A                    ; clear the carry flag
3140: F434 17                     RLA
3141: F435 C3 2F F4               JP     GetDiskMapIndex2
3142: F438
3143: F438         ; The ACC has the Block Number for this record
3144: F438             GetDiskMapIndex3:
3145: F438         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3146: F438 80                     ADD    A,B                  ; add the previous shr(cpmRecord,dpbBSH) value
3147: F439         ; A is one of the following values, depending upon alloc
3148: F439         ; bks dpbBSH
3149: F439         ; 1k   3     v/8 + extentValue * 16
3150: F439         ; 2k   4     v/16+ extentValue * 8
3151: F439         ; 4k   5     v/32+ extentValue * 4
3152: F439         ; 8k   6     v/64+ extentValue * 2
3153: F439         ; 16k  7     v/128+extentValue * 1
3154: F439 C9                     RET                         ; with disk map position in A
3155: F43A         ;---------------------
3156: F43A         ; Enter with Disk Map Index in BG
3157: F43A         ; Return disk map value  in HL
3158: F43A             GetDiskMapValue:
3159: F43A 2A C3 EA               LD     HL,(paramDE)         ; base address of file control block
3160: F43D 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3161: F440 19                     ADD    HL,DE                ; HL =.diskmap
3162: F441 09                     ADD    HL,BC                ; index by a single byte value
3163: F442 3A 43 F5               LD     A,(single)           ; single byte/map entry?
3164: F445 B7                     OR     A
3165: F446 CA 4D F4               JP     Z,GetDiskMap16Bit    ; get disk map single byte
3166: F449 6E                     LD     L,(HL)
3167: F44A 26 00                  LD     H,0
3168: F44C C9                     RET                         ; with HL=00bb
3169: F44D             GetDiskMap16Bit:                      ; getdmd:
3170: F44D 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3171: F44E         ; double precision value returned
3172: F44E 56                     LD     D,(HL)
3173: F44F 23                     INC    HL
3174: F450 5E                     LD     E,(HL)
3175: F451 EB                     EX     DE,HL
3176: F452 C9                     RET
3177: F453         ;---------------------
3178: F453         ;---------------------
3179: F453         ;*****************************************************************
3180: F453         ;************************ Utilities ******************************
3181: F453         ;*****************************************************************
3182: F453             AddAtoHL:
3183: F453 85                     ADD    A,L
3184: F454 6F                     LD     L,A
3185: F455 D0                     RET    NC
3186: F456 24                     INC    H
3187: F457 C9                     RET
3188: F458         ;----------
3189: F458             DEminusHL2HL:
3190: F458 7B                     LD     A,E
3191: F459 95                     SUB    L
3192: F45A 6F                     LD     L,A
3193: F45B 7A                     LD     A,D
3194: F45C 9C                     SBC    A,H
3195: F45D 67                     LD     H,A
3196: F45E C9                     RET
3197: F45F         ;-------------
3198: F45F             ShiftRightHLbyC:
3199: F45F 0C                     INC    C
3200: F460             ShiftRightHLbyC0:
3201: F460 0D                     DEC    C
3202: F461 C8                     RET    Z
3203: F462 7C                     LD     A,H
3204: F463 B7                     OR     A
3205: F464 1F                     RRA
3206: F465 67                     LD     H,A
3207: F466 7D                     LD     A,L
3208: F467 1F                     RRA
3209: F468 6F                     LD     L,A
3210: F469 C3 60 F4               JP     ShiftRightHLbyC0
3211: F46C         ;-------
3212: F46C             ShiftLeftHLbyC:
3213: F46C 0C                     INC    C
3214: F46D             ShiftLeftHLbyC0:
3215: F46D 0D                     DEC    C
3216: F46E C8                     RET    Z                    ; exit when done
3217: F46F 29                     ADD    HL,HL
3218: F470 C3 6D F4               JP     ShiftLeftHLbyC0
3219: F473         ;*****************************************************************
3220: F473         ;move data length of length C from source DE to HL
3221: F473             Move:
3222: F473 0C                     INC    C
3223: F474             Move0:
3224: F474 0D                     DEC    C
3225: F475 C8                     RET    Z
3226: F476 1A                     LD     A,(DE)
3227: F477 77                     LD     (HL),A
3228: F478 13                     INC    DE
3229: F479 23                     INC    HL
3230: F47A C3 74 F4               JP     Move0
3231: F47D
3232: F47D         ;********** Console OUT Routines*******************
3233: F47D
3234: F47D
3235: F47D
3236: F47D
3237: F47D
3238: F47D         ;********************************************************
3239: F47D         ;return version number
3240: F47D             vGetVersion:                      ; func12 (12 - 0C)	 Get Verson
3241: F47D 3E 20                  LD     A,VERSION
3242: F47F 32 C5 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION (high = 00)
3243: F482 C9                     RET
3244: F483         ;************Error message World*************************
3245: F483             errSelect:
3246: F483 21 A2 F4               LD     HL,evSelection
3247: F486 C3 9B F4               JP     GoToError
3248: F489             errReadOnlyDisk:
3249: F489 21 A4 F4               LD     HL,evReadOnlyDisk
3250: F48C C3 9B F4               JP     GoToError
3251: F48F             errReadOnlyFile:
3252: F48F 21 A6 F4               LD     HL,evReadOnlyFile
3253: F492 C3 9B F4               JP     GoToError
3254: F495             errPermanent:
3255: F495 21 A0 F4               LD     HL,evPermanent
3256: F498 C3 9B F4               JP     GoToError
3257: F49B         ;************Error message handler **********************
3258: F49B             GoToError:
3259: F49B         ;HL = .errorhandler, call subroutine
3260: F49B 5E                     LD     E,(HL)
3261: F49C 23                     INC    HL
3262: F49D 56                     LD     D,(HL)               ; address of routine in DE
3263: F49E EB                     EX     DE,HL
3264: F49F E9                     JP     (HL)                 ; vector to subroutine
3265: F4A0         ;************ Error Vectors *****************************
3266: F4A0 AE F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3267: F4A2 BA F4       evSelection: DW     erSelection          ; selerr select error subroutine
3268: F4A4 C0 F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3269: F4A6 C6 F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3270: F4A8         ;************Error Routines ******************************
3271: F4A8             erPermanentNoWait:
3272: F4A8 21 F8 F4               LD     HL,emPermanent
3273: F4AB C3 9B F4               JP     GoToError
3274: F4AE             erPermanent:
3275: F4AE 21 F8 F4               LD     HL,emPermanent
3276: F4B1 CD CF F4               CALL   displayAndWait       ; to report the error
3277: F4B4 FE 03                  CP     CTRL_C
3278: F4B6 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3279: F4B9 C9                     RET                         ; and ignore the error
3280: F4BA         ;
3281: F4BA             erSelection:
3282: F4BA 21 03 F5               LD     HL,emSelection
3283: F4BD C3 C9 F4               JP     waitB4boot           ; wait console before boot
3284: F4C0         ;
3285: F4C0             erReadOnlyDisk:
3286: F4C0 21 0F F5               LD     HL,emReadOnlyDisk
3287: F4C3 C3 C9 F4               JP     waitB4boot           ; wait console before boot
3288: F4C6         ;
3289: F4C6             erReadOnlyFile:
3290: F4C6 21 0A F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3291: F4C9         ;
3292: F4C9         ; wait for response before boot
3293: F4C9             waitB4boot:
3294: F4C9 CD CF F4               CALL   displayAndWait
3295: F4CC C3 00 00               JP     WarmBoot
3296: F4CF
3297: F4CF         ;report error to console, message address in HL
3298: F4CF             displayAndWait:
3299: F4CF E5                     PUSH   HL                   ; save message pointer
3300: F4D0 CD D6 E9               CALL   showCRLF             ; stack mssg address, new line
3301: F4D3 3A 14 F5               LD     A,(currentDisk)
3302: F4D6 C6 41                  ADD    A,ASCII_A
3303: F4D8 32 F4 F4               LD     (emDisk),A           ; Problem disk name
3304: F4DB 01 E8 F4               LD     BC,emDisk0
3305: F4DE CD 36 E9               CALL   Print                ; the error message
3306: F4E1 C1                     POP    BC
3307: F4E2 CD 36 E9               CALL   Print                ; error mssage tail
3308: F4E5 C3 1C E9               JP     ConIn                ; to get the input character
3309: F4E8         ;ret
3310: F4E8         ;**************Error Messages*******************************
3311: F4E8 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3312: F4F4 20 3A 20 24     emDisk:    DB     ' : $'
3313: F4F8 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3314: F503 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3315: F50A 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3316: F50F 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3317: F513         ;*****************************************************************
3318: F513
3319: F513         ;********* file control block (fcb) constants ********************
3320: F513             fcbLength  EQU    32                   ; fcblen file control block size
3321: F513             fcbROfileIndex EQU    9                    ; high order of first type char
3322: F513             fcbHiddenfileIndex EQU    10                   ; invisible file in dir command
3323: F513             fcbExtIndex EQU    12                   ; extent number field index
3324: F513             fcbS1Index EQU    13                   ; S1 index
3325: F513             fcbS2Index EQU    14                   ; S2 data module number index
3326: F513             fcbRCIndex EQU    15                   ; record count field index
3327: F513             fcbDiskMapIndex EQU    16                   ; dskmap disk map field
3328: F513
3329: F513             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3330: F513
3331: F513             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3332: F513             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3333: F513             dirEntryMask EQU    dirEntriesPerRecord-1
3334: F513             fcbShift   EQU    5                    ; log2(fcbLength)
3335: F513         ;
3336: F513
3337: F513
3338: F513
3339: F513             maxExtValue EQU    31                   ; largest extent number
3340: F513             moduleMask EQU    15                   ; limits module number value
3341: F513             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3342: F513             nameLength EQU    15                   ; namlen name length
3343: F513
3344: F513             emptyDir   EQU    0E5H                 ; empty empty directory entry
3345: F513             NEXT_RECORD EQU    fcbLength            ; nxtrec
3346: F513             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3347: F513         ;
3348: F513         ;	reserved file indicators
3349: F513         ;	equ	11				; reserved
3350: F513         ;*****************************************************************
3351: F513         ;*****************************************************************
3352: F513
3353: F513         ;***common values shared between bdosi and bdos******************
3354: F513 00          currentUserNumber: DB     0                    ; usrcode current user number
3355: F514         ; paramDE:			DS	2					; ParamsDE information address
3356: F514         ; exitParameterByte:
3357: F514         ; exitParameterWord:	DS	2					; address value to return
3358: F514 FF          currentDisk: DB     -1                   ; curdsk current disk number
3359: F515         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3360: F515
3361: F515         ;********************* Local Variables ***************************
3362: F515         ;     ************************
3363: F515         ;     *** Initialized Data ***
3364: F515
3365: F515 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3366: F516 00 00       ReadOnlyVector: DW     0                    ; rodsk read only disk vector
3367: F518 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3368: F51A 80 00       InitDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3369: F51C
3370: F51C         ;     *** Current Disk attributes ****
3371: F51C         ; These are set upon disk select
3372: F51C         ; data must be adjacent, do not insert variables
3373: F51C         ; address of translate vector, not used
3374: F51C         ; ca - currentAddress
3375: F51C
3376: F51C 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3377: F51E 00 00       caTrack:   DW     0000H                ; curtrka current track address
3378: F520 00 00       caSector:  DW     0000H                ; current Sector
3379: F522             caListSizeStart:
3380: F522 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3381: F524 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3382: F526 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3383: F528 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3384: F52A             caListSizeEnd:
3385: F52A             caListSize EQU    caListSizeEnd - caListSizeStart
3386: F52A
3387: F52A         ;     ***** Disk Parameter Block *******
3388: F52A         ; data must be adjacent, do not insert variables
3389: F52A         ; dpb - Disk Parameter Block
3390: F52A             dpbStart:
3391: F52A 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3392: F52C 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3393: F52D 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3394: F52E 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3395: F52F 00 00       dpbDSM:    DW     0000H                ; maxall maximum allocation number
3396: F531 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3397: F533 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3398: F535 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3399: F537 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3400: F539             dpbEnd:
3401: F539             dpbSize    EQU    dpbEnd - dpbStart
3402: F539         ;
3403: F539
3404: F539         ;     ************************
3405: F539
3406: F539 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3407: F53B 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3408: F53C 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3409: F53D 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3410: F53E 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3411: F53F 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3412: F540 00          searchLength: DB     00H                  ; searchl search length
3413: F541 00 00       searchAddress: DW     0000H                ; searcha search address
3414: F543         ;tinfo:	ds	word							; temp for info in "make"
3415: F543 00          single:    DB     00H                  ; set true if single byte allocation map
3416: F544 00          fResel:    DB     00H                  ; resel reselection flag
3417: F545 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3418: F546 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3419: F547 00          fcbRecordCount: DB     00H                  ; record count from current fcb
3420: F548 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3421: F549 00 00       cpmRecord: DW     0000H                ; current virtual record - NEXT_RECORD
3422: F54B 00 00       currentBlock: DW     0000H                ; arecord current actual record
3423: F54D         ;
3424: F54D         ;	local variables for directory access
3425: F54D 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3426: F54E 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3427: F550 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3428: F552
3429: F552         ;********************** data areas ******************************
3430: F552
3431: F552
3432: F552         ;---------------------------------- Stack Area--------------------------------;
3433: F552             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3434: F592             bdosStack:
3435: F592         ;
3436: F592         ;---------------------------------- Stack Area--------------------------------;
3437: F592         ;	end of Basic I/O System
3438: F592         ;-----------------------------------------------------------------;
3439: F592
3440: F592
3441: F592         ;
3442: F592             Z_HighestLocation:
3443: F592             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3444: F592
3445: F592
           ************************   Xref   ************************
0000: $               F592   0411 0441
3182: AddAtoHL        F453   2081 2390
2394: Allocate16Bit   F06F   2388
1009: AreWeAtEndOfBuffer EA3A   1005
0081: ASCII_A         0041   3302
0082: ASCII_C         0043
0083: ASCII_K         004B
0090: ASCII_LO_A      0061
0091: ASCII_LO_K      006B
0092: ASCII_LO_P      0070
0033: ASCII_MASK      007F   0951
0084: ASCII_N         004E
0085: ASCII_Q         0051
0086: ASCII_R         0052
0087: ASCII_W         0057
0088: ASCII_Y         0059
0068: ASCII_ZERO      0030
0062: ASTERISK        002A
1103: BackUp          EA9F   1029 1098
1108: BackUp1         EAA7   1104
0290: bcBoot          F600
0293: bcConin         F609   0609 0761 0877 0895
0294: bcConout        F60C   0601 0836 1106 1110 1116 1118
0292: bcConst         F606   0606 0873
0298: bcHome          F618   1833
0295: bcList          F60F   0574 0842
0305: bcListst        F62D
0296: bcPunch         F612   0559
0303: bcRead          F627   2744
0297: bcReader        F615   0541
0306: bcSectran       F630
0299: bcSeldsk        F61B   1575
0302: bcSetdma        F624   1873
0301: bcSetsec        F621   2025
0300: bcSettrk        F61E   1838 2005
0291: bcWboot         F603   0462
0304: bcWrite         F62A   2737
0148: BDOSBase        E800   0149 0151 0322
0117: BDOSE           0005   0118
0149: BDOSEntry       E800
0138: BDOSLength      0E00   0141 0151 0152
3434: bdosStack       F592
0327: BdosStart       E800
0051: BELL            0007
0151: BIOSBase        F600
0139: BIOSLength      0A00   0141
0111: BIOSPAGE        0002
0152: BIOSStart       F600   0290 0291 0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 3443
2379: BlockOK         F053   2373
0248: BlockSize       0800   0270
1024: BSspaceBS       EA48   0962
0029: BYTE            0001   1142
3383: caAllocVector   F528   1511 1663 1675 1798
3382: caCheckSum      F526   2044
3380: caDirectoryDMA  F522   1594 1867 2068 2079 3089
3376: caDirMaxValue   F51C   1583 1645 1682 2098
3381: caDiskParamBlock F524   1535 1598
2036: CalculateCheckSum EE9F   1926
3385: caListSize      0008   1595
3384: caListSizeEnd   F52A   3385
3379: caListSizeStart F522   3385
0089: CARET           005E   0800
0794: CaretOut        E944   0998 1079
3378: caSector        F520   1589 1845 1944 2014
3406: caSkewTable     F539   1593
3377: caTrack         F51E   1586 1841 1948 2008
0146: CCPEntry        E000   0148 0152
0137: CCPLength       0800   0141 0148 0152
0890: CheckCTL_S      E9AB   0881
2253: CheckRODirectory EF9F   2555 2606
2258: CheckROFile     EFA2   2337
2267: CheckWrite      EFAC   2335 2540 2565 2598
2866: ClearModuleNum  F2C5   2169 2190 2236
2616: CloseDirEntry   F1A9   1287 2177 2472
2637: CloseDirEntry1  F1CE   2683
2651: CloseDirEntry2  F1DC   2648
2657: CloseDirEntry3  F1E2   2653
2663: CloseDirEntry4  F1E9   2640
2679: CloseDirEntry5  F1FE   2660
2704: CloseDirEntryEnd F218   2693
2711: CloseDirEntryError F221   2659 2671 2676
0069: COLON           003A
1140: columnPosition  EAC1   0820 0846 0914 0934 1094
0064: COMMA           002C
3070: CompareExtents  F3E1   3015
2066: ComputeCheckSum EEC7   2043
2070: ComputeCheckSum0 EECD   2074
0123: ComTail         0080   0124
0125: ComTailChars    0082
0124: ComTailCount    0081   0125
0868: ConBreak        E98A   0724 0832
0901: ConBreak0       E9BA   0893
0903: ConBreak1       E9BD   0871
0754: ConIn           E91C   0494 0950 3308
0829: ConsoleOut      E969   0801 0814 0819 0911 0919 0924 0927 1021
3102: CopyDir         F405   2155 2558 3099
3088: CopyDirEntryToUser F3F2   2195 2205
3096: CopyFCB         F3FE   2592
3421: cpmRecord       F549   2123 2138 2294 2304 2339 2423 2460 2850 3121
0225: cpmRecordSize   0080   0227 0230 0232 2067 3092 3331
0054: CR              000D   0767 0923 0955 1020
0037: CTRL_C          0003   0896 1003 3277
0038: CTRL_E          0005   0967
0039: CTRL_H          0008   0773 0961 1109
0040: CTRL_K          000B
0041: CTRL_L          000C
0042: CTRL_P          0010   0880 0970
0043: CTRL_R          0012   0979
0044: CTRL_S          0013   0892
0045: CTRL_U          0015   0976
0046: CTRL_X          0018   0973
0047: CTRL_Z          001A
3422: currentBlock    F54B   1933 1940 2380 2827 2832 2841 2854
3358: currentDisk     F514   1474 1497 1542 1551 1573 1621 2275 2891 3301
3354: currentUserNumber F513   0735 0741 1700 2900
0065: DASH            002D
0259: DataBlocks      02C7   0269
0258: DataSectors     0B1C   0259
2597: DeleteFile      F187   2212
2601: DeleteFile1     F18F   2613
1089: DeleteTheLine   EA8E   0974
1092: DeleteTheLine1  EA8F   1099
3189: DEminusHL2HL    F458   1903 2040
3425: dirBlockIndex   F54D   1919 2080
0230: DirBuffSize     0080
0245: DirectoryBlockCount 0002   0270
0232: DirectoryEntryPerRecord 0004   0273
3409: directoryFlag   F53D   2861 2959 3033
3331: dirEntriesPerRecord 0004   3333
3426: dirEntryIndex   F54E   1859 1879 1899 1901 1911 1930 2096 3029
3333: dirEntryMask    0003   1912 3030
3332: dirEntryShift   0002   1931
0229: DirEntrySize    0020   0232 0270
2860: DirLocationToReturnLoc F2BE   1530 2213 2247
3427: dirRecord       F550   1934 2037 2046
0217: DiskCommandBlock 0046
0216: DiskControlByte 0045
0219: DiskControlTable 0040
2321: DiskEOF         F001   2301 2308 2314
0411: diskf           000B
3411: diskMapIndex    F53F   2357 2387
2289: DiskRead        EFC6   1216
0221: DiskReadCode    0001
0226: diskSectorSize  0200   0227 0248 0256
0215: DiskStatusLocation 0043
2331: DiskWrite       F009   1223
2346: DiskWrite1      F026   2341
2404: DiskWrite2      F077   2392
2410: DiskWrite3      F079   2350
2431: DiskWrite4      F099   2426
2442: DiskWrite5      F0A6   2435
2461: DiskWrite6      F0C4   2457
2463: DiskWrite7      F0C6   2445 2449
0222: DiskWriteCode   0002
2326: DiskWriteSeq    F004   2228
3298: displayAndWait  F4CF   3276 3294
0128: DMABuffer       0080   1475 3368
0058: DOLLAR          0024   0782 1706
2273: DoNotWrite      EFB3   2268 2619
0271: dpb3hdAL0       00C0
0272: dpb3hdAL1       0000
0267: dpb3hdBLM       000F
0266: dpb3hdBSH       0004
0273: dpb3hdCKS       0020
0270: dpb3hdDRM       007F   0273
0269: dpb3hdDSM       02C6
0268: dpb3hdEXM       0000
0275: dpb3hdNOH       0002
0274: dpb3hdOFF       0001
0265: dpb3hdSPT       0090
3393: dpbBLM          F52D   2848
3392: dpbBSH          F52C   2840 3119
3398: dpbCKS          F535   2039
3397: dpbDABM         F533   1673
3396: dpbDRM          F531   1643 1897
3395: dpbDSM          F52F   1603 1656 2790
3400: dpbEnd          F539   3401
3394: dpbEXM          F52E   2128 2486 3073
3399: dpbOFF          F537   1834 2001
3401: dpbSize         000F   1601
3391: dpbSPT          F52A   1966 1980
3390: dpbStart        F52A   1600 3401
0443: DUMMY           E8A8   0438 0439
3312: emDisk          F4F4   3303
3311: emDisk0         F4E8   3304
3313: emPermanent     F4F8   3272 3275
3344: emptyDir        00E5   1696 2608 2979 3365
3365: emptyFCB        F515   2568
3316: emReadOnlyDisk  F50F   3286
3315: emReadOnlyFile  F50A   3290
3314: emSelection     F503   3282
0132: END_OF_FILE     001A
3028: EndDirElementSearch F3B2   2994
1878: EndOfDirectory  EDE8   1366 1692 2151 2474 2509 2518 2552 2572 2603 2627 2910 2973
0035: EndOfMessage    0000
1014: EndRead         EA3E   0956 0959
3417: entryDisk       F545   0384 2892
0287: EOD             FFFF   1858
0073: EQUAL_SIGN      003D
3274: erPermanent     F4AE   3266
3271: erPermanentNoWait F4A8   2739 2746
3285: erReadOnlyDisk  F4C0   3268
3289: erReadOnlyFile  F4C6   3269
3254: errPermanent    F495
3248: errReadOnlyDisk F489   2270
3251: errReadOnlyFile F48F   2264
3245: errSelect       F483   1558
3281: erSelection     F4BA   3267
3266: evPermanent     F4A0   3255
3268: evReadOnlyDisk  F4A4   3249
3269: evReadOnlyFile  F4A6   3252
3267: evSelection     F4A2   3246
0056: EXCLAIM_POINT   0021
1144: exitParameterByte EAC5   0503 0610 0725 0736 1291 1301 1312 1319 1332 1498 1710 2306 2376 2411 2454 2528 2618 2712 2862 3031 3046 3066 3242
1145: exitParameterWord EAC5   0340 0391 0542 0630 1491 1512 1523 1536
3420: extentValue     F548   2130 3133
0024: FALSE           0000   0886 1059 1221 1609 2332 2971
0120: FCB1            005C   0121
0121: FCB2            006C
3407: fcbCopiedFlag   F53B   2471 2489 2706
3418: fcbDisk         F546   0342 0379 2894
3327: fcbDiskMapIndex 0010   1724 1727 2383 2547 2556 2630 2636 3160
3323: fcbExtIndex     000C   1270 1294 1353 1405 2148 2154 2477 2497 2542 2557 2599 2685 2697 2928 3003 3052
3322: fcbHiddenfileIndex 000A
3320: fcbLength       0020   1727 2580 2636 2685 3098 3331 3345
3326: fcbRCIndex      000F   1370 2112 2115 2697 2931 2950
3419: fcbRecordCount  F547   2126 2142 2295 2424
3321: fcbROfileIndex  0009   2259
3324: fcbS1Index      000D   2587 3000
3325: fcbS2Index      000E   1276 1297 1422 2497 2874
3334: fcbShift        0005   1913
0165: fCloseFile      0010
0156: fConsoleIn      0001
0157: fConsoleOut     0002
0168: fDeleteFile     0013
0160: fGetConsoleStatus 000B
0174: fGetCurrentDisk 0019
0173: fGetLoginVector 0018
0176: fGetSetUserNumber 0020
0161: fGetVersion     000C
2368: FirstBlock      F045   2360
0171: fMakeFile       0016
0164: fOpenFile       000F
0158: fPrintString    0009
0169: fReadSeq        0014
0159: fReadString     000A
0172: fRenameFile     0017
3416: fResel          F544   0343 0373 2882
0162: fResetSystem    000D
0166: fSearchFirst    0011
0167: fSearchNext     0012
0163: fSelectDisk     000E
0175: fSetDMA         001A
0441: functionCount   0028   0352
0398: functionTable   E856   0357 0411 0441
0170: fWriteSeq       0015
1771: GetAllocBit     ED7F   1813 2783 2801
1802: GetAllocBitl    EDA0   1805
2822: GetBlockNumber  F292   2312 2347
2772: GetClosestBlock F258   2369
2078: GetDirElementAddress EED4   1369 1695 1722 2254 2607 2631 2919 2987 3108
3169: GetDiskMap16Bit F44D   3165
3118: GetDiskMapIndex F41A   2356 2823
3122: GetDiskMapIndex1 F421   3126
3134: GetDiskMapIndex2 F42F   3141
3144: GetDiskMapIndex3 F438   3138
3158: GetDiskMapValue F43A   2364 2826
3050: GetExtentAddress F3CC   2127 2915
2110: GetFcbAddress   EEF3   2121 2135
1352: GetFileSize     EB94   1187
1365: GetFileSize1    EBA6   1393
1391: GetFileSize2    EBC8   1384
1394: GetFileSizeExit EBCE   1367
2872: GetModuleNum    F2CB   1326 2437 2622 2867 3058
1399: GetRandomRecordPosition EBD0   1341 1371
3258: GoToError       F49B   3247 3250 3253 3256 3273
0074: GREATER_THAN    003E
0057: HASH_TAG        0023   0910
3329: highestRecordNumber 007F   2340 2444
1832: Home            EDB8   1680 2965
1113: IgnoreTheLine   EAAC   0977
3368: InitDAMAddress  F51A   1476 1505 1863 3091
1655: InitDisk        ECF3   1568
1665: InitDisk0       ED01   1671
1689: InitDisk1       ED22   1698 1716
1711: InitDisk2       ED46   1702 1707
0112: IOBYTE          0003   0629 0649
2831: IsAllocated     F29F   2313 2348
0975: IsItDeleteTheLineU EA19
0972: IsItDeleteTheLineX EA14
0969: IsItPrintToggle EA0F
1060: IsItPrintToggle1 EA70   1058
0963: IsItRubout      EA05
0966: IsPhysicalEOL   EA0A
0766: IsPrintableASCII E927   0495 0796
1045: ItIsPhysicalEOL EA5D   0968
1052: ItIsPrintToggle EA65   0971
1033: ItIsRubout      EA52   0965
1134: keyboardByte    EABE   0755 0869 0902
0060: L_PAREN         0028
0077: LEFT_ARROW      005F
0093: LEFT_CURLY      007B
0141: LengthInBytes   2000   0142 0146 0256
0142: LengthInK       0009
0072: LESS_THAN       003C
0053: LF              000A   0769 0852 0925 0957
1074: LL1             EA7E   1082
0027: LO_NIBBLE_MASK  000F   0740 1418
3367: loggedDisks     F518   1472 1490 1550 1563 1567
2564: MakeNewFile     F151   1310 2238 2516
2582: MakeNewFile1    F173   2586
3339: maxExtValue     001F   2481 3083
0144: MemorySize      0040   0146
2751: Merge           F24A   2664 2666
3340: moduleMask      000F   2502
3221: Move            F473   1596 1602 2924 3093 3110
3223: Move0           F474   3230
0257: myOffset        0001   0258 0274
3342: nameLength      000F   2192 2507 2578 2580 2625 2908
2033: NewCheckSum     EE9D   2724
3345: NEXT_RECORD     0020   1265 1340 2115 2922 3346
2898: NoSelect        F2F8   2889
0898: NothingWaiting  E9B8   0889
0049: NULL            0000
0241: NumberOfHeads   0002   0252 0254 0265 0275
0238: NumberOfLogicalDisks 0004
0026: OFF             0000
0025: ON              FFFF
2907: OpenFile        F301   1300 2171
2914: OpenFileCopyFCB F30A   2524
2469: OpenNextExt     F0C9   2302 2452
2506: OpenNextExt1    F0FD   2491
2523: OpenNextExt2    F11B   2493 2510
2525: OpenNextExt3    F11E   2520
2532: OpenNextExtError F126   2503 2514 2519
2496: OpenNextModule  F0F2   2483
2948: OpenRecordCount F33B   2944 2946
1143: paramDE         EAC3   0332 0377 0672 0936 1016 1071 1234 1339 1356 1504 2111 2185 2202 2336 2382 2476 2545 2566 2569 2574 2634 2873 2883 2901 2921 2949 2962 3051 3105 3159
1142: paramE          EAC2   0334 0385 0732 1541 2887
0059: PERCENT         0025
0066: PERIOD          002E
0115: Pg0CurentDisk   0004
0114: Pg0CurentUser   0004   0115
0063: PLUS_SIGN       002B
0780: Print           E936   0675 0789 3305 3307
1136: printEchoFlag   EABF   0840 0882 1055
0075: QMARK           003F   2187 2996
2193: QMarkSelect     EF61   2188
0061: R_PAREN         0029
0108: RAM             0000   0110 0111 0112 0114 0117 0120 0123 0128 0130
3346: RANDOM_REC_FIELD 0021   1236 1342 1357
1213: RandomDiskRead  EADE   1168
1220: RandomDiskWrite EAE7   1180
1230: RandomSeek      EAF0   1215 1222
1284: RandomSeekClose EB34   1274
1329: RandomSeekError EB79   1263
1322: RandomSeekErrorBadSeek EB72   1293 1309 1314
1316: RandomSeekExit  EB6C   1283 1303
2743: ReadBuffer      F242   1891 2318
1896: ReadDirectory   EDFA   1691 2972
1910: ReadDirectory0  EE0F   1904
1914: ReadDirectory1  EE16   1917
1889: ReadDirRecord   EDF1   1924
0994: ReadEchoRubOut  EA26   1042
3408: readModeFlag    F53C   2291 2333 2512
0946: ReadNext        E9ED   1011 1037 1063 1085
0949: ReadNext0       E9EF   1030 1049
3366: ReadOnlyVector  F516   1471 1522 1636 1641 2274
2283: ReadSeq         EFC1   2220
0933: ReadString      E9E0   0705 1096 1119
2311: RecordOK        EFEB   2298
0250: RecordsPerBlock 0010
0234: RecordsPerExtent 0080   2300 2947 3329
0227: recordsPerSector 0004   0250 0265
2539: Rename          F12C   2246
2551: Rename1         F13D   2561
1066: RepeatLine      EA75   0980
2880: Reselect        F2D4   1167 1179 1186 1528 2170 2176 2191 2203 2211 2219 2227 2237 2245
2807: ReturnBlockNumber F286   2785 2803
2817: ReturnBlockZero F28E   2795
0372: ReturnToCaller  E82F   0346
0388: ReturnToCaller1 E84C   0375 0381 0608
1823: RotateAndReplace EDB1   1817 1826 2811
0078: RUBOUT          007F   0964
1721: ScanDiskMap     ED51   1714 2610
1729: ScanDiskMap0    ED5B   1761
1745: ScanDiskMap1    ED6E   1737
1754: ScanDiskMap2    ED74   1743
2957: Search4DirElement F344   1354 2149 2194 2508 2543 2571 2600 2626 2909
3012: Search4Ext      F3A2   3005
2970: Search4NextDirElement F35C   1392 2156 2204 2560 2612 2966 3008 3017
2986: Search4NextDirElement1 F379   2980
2991: Search4NextLoop F382   3025
3020: Search4NextOK   F3AB   2997 3001 3009
3413: searchAddress   F541   2201 2963 2976
3043: SearchDone      F3C3   2974 2985
3412: searchLength    F540   2960 2988
0279: SectorMask      0003
0244: SectorsPerBlock 0004   0248 0250 0253 0259 0279
0254: SectorsPerCylinder 0024   0257 0258
0243: SectorsPerTrack 0012   0252 0254 0265
1937: Seek            EE3C   1935 2317 2417
1958: Seek0           EE4F   1975
1977: Seek1           EE65   1963 1992
1994: Seek2           EE77   1986
3112: SeekAndCopy     F414
2717: SeekCopy        F226   2707
1929: SeekDir         EE2B   1923 2718 3113
1549: Select          EC5D   1478 1546
1540: SelectCurrent   EC51   0386 1484 2897
1572: SelectDisk      EC81   1556
1611: SelectDisk1     ECC5   1608
0071: SEMICOLON       003B
3410: seqReadFlag     F53E   1232 2136 2285 2328 2447
2839: SetActualRecordAdd F2A5   2316 2416
2843: SetActualRecordAdd1 F2AB   2846
1811: SetAllocBit     EDA6   1757
2147: SetAttributes   EF29   1529
2150: SetAttributes1  EF2E   2157
1619: SetCurrentDiskBit ECC9   1566 1640
1862: SetDataDMA      EDD9   1477 1506 1892 2728
1866: SetDirDMA       EDDF   1890 2725
2084: SetDirectoryEntry EEDD   1715 2590
1635: SetDiskReadOnly ECDC   1517 2057
1869: SetDMA          EDE2   1864
1857: SetEndDirectory EDD2   1687 1906 2964 3044
3057: SetFileWriteFlag F3D4   1334 2534 2594 2926
3064: SetLowReturnTo1 F3DB   2322 2342 2533
2061: SetNewCheckSum  EEC5   2050
1338: SetRandomRecord EB81   1193
2120: SetRecordVars   EF00   2293 2338 2526
0739: SetUserNumber   E916   0734
3212: ShiftLeftHLbyC  F46C   1624
3214: ShiftLeftHLbyC0 F46D   3218
3198: ShiftRightHLbyC F45F   1553 1659 1932 2277
3200: ShiftRightHLbyC0 F460   3210
0922: showCRLF        E9D6   0912 1048 3300
0909: showHashCRLF    E9C0   1069 1114
0913: showHashCRLF1   E9C8   0920
3415: single          F543   1605 1735 2385 2638 3163
0067: SLASH           002F
0050: SOH             0001
0055: SPACE           0020   0775 0818 0849 0918 1105 1115 1117
0286: STACK_SIZE      0020   3433
3433: stackBottom     F552
1139: startingColumn  EAC0   0915 0935 1093
2095: StillInDirectory EEE6   2055 2085 2983
0256: SystemSectors   0011   0257
0052: TAB             0009   0771 0813
0811: TabOut          E955   0500 0521 0787 0797
0817: TabOut0         E95B   0822
2775: TestLeft        F25A   2806
2789: TestRight       F26B   2778
0887: ToggleFlag1     E9A8   0885
0118: TopRAM          0007
0253: TotalNumberOfBlocks 02D0
0252: TotalNumberOfSectors 0B40   0253 0258
0130: TPA             0100
0242: TracksPerHead   0050   0252
0023: TRUE            FFFF   0883 0904 1056 1214 1606 1612 1690 2034 2290 2705 2881
0076: UNDER_SCORE     005F
2134: UpdateRecordVars EF17   2319 2451 2464
1132: usersStack      EABC   0336 0389
2175: vCloseFile      EF48   0416
1185: vComputeFileSize EAD3   0435
0493: vConsoleIn      E8AC   0400
0520: vConsoleOut     E8BD   0401
2210: vDeleteFile     EF76   0419
0596: vDirectConIO    E8D0   0405
0605: vDirectConIO1   E8D9   0599
0285: VERSION         0020   3241
2183: vFindFirst      EF4E   0417
2200: vFindNext       EF67   0418
1510: vGetAllocAddr   EC30   0427
0723: vGetConsoleStatus E900   0410
1496: vGetCurrentDisk EC20   0425
1534: vGetDiskParamBlock EC4A   0431
0628: vGetIOBYTE      E8E7   0406
1489: vGetLoginVector EC19   0424
1521: vGetRoVector    EC3A   0429
0731: vGetSetUserNumber E907   0432
3240: vGetVersion     F47D   0412
0573: vListOut        E8CC   0404
2235: vMakeFile       EF8D   0422
2168: vOpenFile       EF3F   0415
0671: vPrintString    E8F3   0408
0558: vPunchOut       E8C8   0403
0540: vReaderIn       E8C1   0402
1166: vReadRandom     EAC7   0433
2218: vReadSeq        EF7F   0420
0704: vReadString     E8FC   0409
2244: vRenameFile     EF96   0423
1198: vResetDrive     EADC   0437
1469: vResetSystem    EBFD   0413
1483: vSelectDisk     EC16   0414
1503: vSetDMA         EC27   0426
1527: vSetFileAttributes EC41   0430
0648: vSetIOBYTE      E8EE   0407
1192: vSetRandomRecord EAD9   0436
0461: vSystemReset    E8A9   0399
1516: vWriteProtectDisk EC37   0428
1178: vWriteRandom    EACD   0434
1206: vWriteRandom0Fill EADD   0440
2226: vWriteSeq       EF86   0421
3293: waitB4boot      F4C9   3283 3287
0110: WarmBoot        0000   0897 1007 3278 3295
0030: WORD            0002   1143 1145
0190: WriteAllocated  0000   2349
2736: WriteBuffer     F23A   2420 2727
0192: WriteCleanBuffer 0002   2405
2723: WriteDir        F22C   2611 2719 3114
0191: WriteDirectory  0001
3341: writeFlagMask   0080   2623 3059
3442: Z_HighestLocation F592   3443
3443: Z_MemoryLeft    006D
0034: ZERO            0000
