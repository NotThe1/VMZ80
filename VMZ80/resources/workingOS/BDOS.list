0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process Rename File (17H)
0005: E800
0006: E800         ; 2019-02-04 Fixed bdosStack problem
0007: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0008: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0009: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0010: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0011: E800         ; 2018-03-02 Refactored the CP/M Suite
0012: E800         ; 2018-02-12 fixed allocate 16 bit problem
0013: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0014: E800         ; 2014-03-14  :  Frank Martyn
0015: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0016: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.asm
0023: E800         ; standard equates
0024: E800
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; not false
0029: E800             FALSE      EQU    0000H
0030: E800             ON         EQU    -1
0031: E800             OFF        EQU    0000H
0032: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0033: E800
0034: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0035: E800             WORD       EQU    2                    ; number of bytes for "word" type
0036: E800
0037: E800
0038: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0039: E800             ZERO       EQU    00H                  ; Zero
0040: E800             EndOfMessage EQU    00H
0041: E800
0042: E800             CTRL_C     EQU    03H                  ; ETX
0043: E800             CTRL_E     EQU    05H                  ; physical eol
0044: E800             CTRL_H     EQU    08H                  ; backspace
0045: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0046: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0047: E800             CTRL_P     EQU    10H                  ; prnt toggle
0048: E800             CTRL_R     EQU    12H                  ; repeat line
0049: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0050: E800             CTRL_U     EQU    15H                  ; line delete
0051: E800             CTRL_X     EQU    18H                  ; =ctl-u
0052: E800             CTRL_Z     EQU    1AH                  ; end of file
0053: E800
0054: E800             NULL       EQU    00H                  ; Null
0055: E800             SOH        EQU    01H                  ; Start of Heading
0056: E800             BELL       EQU    07H                  ; Bell
0057: E800             TAB        EQU    09H                  ; Tab
0058: E800             LF         EQU    0AH                  ; Line Feed
0059: E800             CR         EQU    0DH                  ; Carriage Return
0060: E800             SPACE      EQU    20H                  ; Space
0061: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0062: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0064: E800             PERCENT    EQU    25H                  ; Percent Sign
0065: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0066: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0067: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0068: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0069: E800             COMMA      EQU    2CH                  ; Comma
0070: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0071: E800             PERIOD     EQU    2EH                  ; Period
0072: E800             SLASH      EQU    2FH                  ; /
0073: E800             ASCII_ZERO EQU    30H                  ; zero
0074: E800             COLON      EQU    3AH                  ; Colon
0075: E800
0076: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0077: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0078: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0079: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0080: E800             QMARK      EQU    3FH                  ; Question Mark
0081: E800             UNDER_SCORE EQU    5FH                  ; under score _
0082: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0083: E800             RUBOUT     EQU    7FH                  ; Delete Key
0084: E800
0085: E800
0086: E800             ASCII_A    EQU    'A'
0087: E800             ASCII_C    EQU    'C'
0088: E800             ASCII_K    EQU    'K'
0089: E800             ASCII_N    EQU    'N'
0090: E800             ASCII_Q    EQU    'Q'
0091: E800             ASCII_R    EQU    'R'
0092: E800             ASCII_W    EQU    'W'
0093: E800             ASCII_Y    EQU    'Y'
0094: E800             CARET      EQU    '^'
0095: E800             ASCII_LO_A EQU    'a'
0096: E800             ASCII_LO_K EQU    'k'
0097: E800             ASCII_LO_P EQU    'p'
0098: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0099: E800
0100: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E800                        Include ./osHeader.Z80
0102: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0103: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0104: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0105: E800         ; osHeader.Z80
0106: E800
0107: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0108: E800         ; 2017-03-02 Refactored the CP/M Suite
0109: E800
0110: E800         ; Contains the Equates used by the CP/M system
0111: E800
0112: E800         ;------------------------Page Zero Constants ---------------------------------
0113: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0114: E800
0115: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0116: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0117: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0118: E800
0119: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0120: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0121: E800
0122: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0123: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0124: E800
0125: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0126: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0127: E800
0128: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0129: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0130: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0131: E800         ;-----------------------------------------------------------------------
0132: E800
0133: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0134: E800         ;-----------------------------------------------------------------------
0135: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0136: E800         ;-----------------------------------------------------------------------
0137: E800             END_OF_FILE EQU    1AH                  ; end of file
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;--------------- CP/M Constants -----------------------------------------
0141: E800
0142: E800             CCPLength  EQU    0800H                ; Constant
0143: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0144: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0145: E800
0146: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0147: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0148: E800
0149: E800             MemorySize EQU    64
0150: E800
0151: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0152: E800
0153: E800             BDOSBase   EQU    CCPEntry + CCPLength
0154: E800             BDOSEntry  EQU    BDOSBase
0155: E800
0156: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0157: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0158: E800         ;-----------------------------------------------------------------------
0159: E800
0160: E800         ;------------------- BDOS System Call Equates --------------------------
0161: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0162: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0163: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0164: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0165: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0166: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0167: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0168: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0169: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0170: E800             fCloseFile EQU    10H                  ; closef - Close File
0171: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0172: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0173: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0174: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0175: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0176: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0177: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0178: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0179: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0180: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0181: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0182: E800         ;-----------------------------------------------------------------------
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800
0188: E800         ;*******************************************************************************
0189: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0190: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0191: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0192: E800         ; sector write) or to an allocation block that has already been allocated to a
0193: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0194: E800         ;*******************************************************************************
0195: E800             WriteAllocated EQU    00H
0196: E800             WriteDirectory EQU    01H
0197: E800             WriteCleanBuffer EQU    02H
0198: E800
0199: E800
0200: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E800                        Include ./diskHeader.Z80
0202: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0203: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0204: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0205: E800         ; diskHeader.asm
0206: E800
0207: E800         ; 2017-03-02 Refactored the CP/M Suite
0208: E800
0209: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0210: E800
0211: E800         ; Contains the Equates used by the CP/M system to handle disks
0212: E800
0213: E800
0214: E800         ;*******************************************************************************
0215: E800         ;
0216: E800         ;     Disk related values
0217: E800         ;
0218: E800         ;
0219: E800         ;*******************************************************************************
0220: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0221: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0222: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0223: E800         ; for boot
0224: E800             DiskControlTable EQU    0040H
0225: E800
0226: E800             DiskReadCode EQU    01H                  ; Code for Read
0227: E800             DiskWriteCode EQU    02H                  ; Code for Write
0228: E800
0229: E800
0230: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0231: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0232: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0233: E800
0234: E800             DirEntrySize EQU    20H                  ; (32)
0235: E800             DirBuffSize EQU    cpmRecordSize
0236: E800
0237: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0238: E800
0239: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0240: E800
0241: E800
0242: E800         ;-------------------------------------------------------------------------------------
0243: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0244: E800
0245: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0246: E800             NumberOfHeads EQU    02H                  ; number of heads
0247: E800             TracksPerHead EQU    50H                  ; 80
0248: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0249: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0250: E800             DirectoryBlockCount EQU    02H                  ;
0251: E800         ;-----------------------------------------------------------------------
0252: E800
0253: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0254: E800
0255: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0256: E800
0257: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0258: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0259: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0260: E800
0261: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0262: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0263: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0264: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0265: E800
0266: E800         ;-----------------------------------------------------------------------
0267: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0268: E800         ;-----------------------------------------------------------------------
0269: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0270: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0271: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0272: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0273: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0274: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0275: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0276: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0277: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0278: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0279: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0280: E800             dpb3hdNOH  EQU    NumberOfHeads
0281: E800
0282: E800         ;*******************************************************************************
0283: E800
0284: E800             SectorMask EQU    SectorsPerBlock - 1
0285: E800
0286: E800         ;***************************************************************************
0287: E800
0288: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0289: E800
0290: E800             VERSION    EQU    20H                  ; Version 2.0
0291: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0292: E800             EOD        EQU    -1                   ; End of Directory
0293: E800
0294: E800         ;************************ BIOS Function Constants ***************************;
0295: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0296: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0297: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0298: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0299: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0300: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0301: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0302: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0303: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0304: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0305: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0306: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0307: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0308: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0309: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0310: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0311: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0312: E800         ;************************ BIOS Function Constants ***************************;
0313: E800
0314: E800         ;============================================================================;
0315: E800         ;	BDOS                                                                     ;
0316: E800         ; Calling into   :                                                           ;
0317: E800         ;					Register  C - Contains BDOS Function Code                ;
0318: E800         ;					Register  A - Holds the Byte argument if any             ;
0319: E800         ;					Register DE - Holds the Word argument if any             ;
0320: E800         ; Returning from :                                                           ;
0321: E800         ;					Register  A - The Byte return value if any               ;
0322: E800         ;					Register HL - The Word return value if any               ;
0323: E800         ;                   ( Register A=L and B=H)                                  ;
0324: E800         ;============================================================================;
0325: E800
0326: E800
0327: E800                        ORG    BDOSBase
0328: E800
0329: E800         ;===========================BDOS Entry=======================================;
0330: E800         ;BDOSEntry:                                                                  ;
0331: E800         ;
0332: E800         ;
0333: E800             BdosStart:                      ;
0334: E800         ;	LD		A,C                                                              ;
0335: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0336: E800         ;
0337: E800         ; Save Calling Arguments                                                     ;
0338: E800 ED 53 C3 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0339: E804 7B                     LD     A,E                  ;
0340: E805 32 C2 EA               LD     (paramE),A           ; Save the Byte argument             ;
0341: E808         ; Save users Stack pointer                                                   ;
0342: E808 ED 73 BC EA               LD     (usersStack),SP      ; Save the User's stack				 ;
0343: E80C 31 DD F5               LD     SP,bdosStack         ; We will use our own stack			 ;
0344: E80F         ;
0345: E80F         ; initialize variables                                                       ;
0346: E80F 21 00 00               LD     HL,0000H             ;
0347: E812 22 C5 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0348: E815 AF                     XOR    A                    ;
0349: E816 32 91 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0350: E819 32 8F F5               LD     (fResel),A           ; Clear re selection flag            ;
0351: E81C         ;
0352: E81C         ; Set up for return to caller when Function Completes                        ;
0353: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0354: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0355: E820         ;
0356: E820         ; is it a valid function number ?	                                         ;
0357: E820         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0358: E820 79                     LD     A,C                  ;
0359: E821 FE 28                  CP     functionCount        ; make sure its a good number        ;
0360: E823 D0                     RET    NC                   ; exit if not a valid function       ;
0361: E824         ;
0362: E824         ; Calculate the index and get vector to go to	                             ;
0363: E824 4B                     LD     C,E                  ; Assume byte argument               ;
0364: E825 21 57 E8               LD     HL,functionTable     ; Get table base                     ;
0365: E828 5F                     LD     E,A                  ; Function number in E               ;
0366: E829 16 00                  LD     D,0                  ;
0367: E82B 19                     ADD    HL,DE                ; Have byte location                 ;
0368: E82C 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0369: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0370: E82E 23                     INC    HL                   ;
0371: E82F 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0372: E830 EB                     EX     DE,HL                ; Vector now in HL                   ;
0373: E831         ;
0374: E831         ; Vector to Function is in HL                                                ;
0375: E831 E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0376: E832         ;===========================BDOS Entry=======================================;
0377: E832         ;===========================BDOS Exit =======================================;
0378: E832         ;arrive here at end of processing to return to user                          ;
0379: E832             ReturnToCaller:                      ;
0380: E832 3A 8F F5               LD     A,(fResel)           ; get re-selection flag              ;
0381: E835 B7                     OR     A                    ; is it set?                         ;
0382: E836 28 15                  JR     Z,ReturnToCaller1    ;
0383: E838         ;re-selection  may have taken place                                         ;
0384: E838 2A C3 EA               LD     HL,(paramDE)         ;
0385: E83B 36 00                  LD     (HL),0               ;
0386: E83D 3A 91 F5               LD     A,(fcbDisk)          ;
0387: E840 B7                     OR     A                    ; Disk = 0?                          ;
0388: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0389: E843         ;
0390: E843 77                     LD     (HL),A               ;
0391: E844 3A 90 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0392: E847 32 C2 EA               LD     (paramE),A           ; and select it                      ;
0393: E84A CD EA EC               CALL   SelectCurrent        ;
0394: E84D         ;
0395: E84D             ReturnToCaller1:                      ;
0396: E84D 2A BC EA               LD     HL,(usersStack)      ;
0397: E850 F9                     LD     SP,HL                ; restore callers stack              ;
0398: E851 2A C5 EA               LD     HL,(exitParameterWord) ;
0399: E854 7D                     LD     A,L                  ;
0400: E855 44                     LD     B,H                  ; BA = exitParameterWord             ;
0401: E856 C9                     RET                         ;
0402: E857         ;===========================BDOS Exit =======================================;
0403: E857
0404: E857         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0405: E857             functionTable:                      ;
0406: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0407: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0408: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0409: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0410: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0411: E861 CD E8                  DW     vListOut             ;   5 - List Output                  ;
0412: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0413: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0414: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0415: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                 ;
0416: E86B FC E8                  DW     vReadString          ;   A - Read Console String          ;
0417: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0418: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0419: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0420: E871 C7 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0421: E873 E0 EA                  DW     vSelectDisk          ;   E - Select Disk                  ;
0422: E875 E3 EA                  DW     vOpenFile            ;   F - Open File                    ;
0423: E877 EC EA                  DW     vCloseFile           ;  10 - Close File                   ;
0424: E879 F2 EA                  DW     vFindFirst           ;  11 - Search For First             ;
0425: E87B 0B EB                  DW     vFindNext            ;  12 - Search for Next              ;
0426: E87D 1A EB                  DW     vDeleteFile          ;  13 - Delete File                  ;
0427: E87F 99 F2                  DW     vReadSeq             ;  14 - Read Sequential              ;
0428: E881 A0 F2                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0429: E883 45 EB                  DW     vMakeFile            ;  16 - Make File                    ;
0430: E885 4E EB                  DW     vRenameFile          ;  17 - Rename File                  ;
0431: E887 7C EB                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0432: E889 83 EB                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0433: E88B 8A EB                  DW     vSetDMA              ;  1A - Set DMA address              ;
0434: E88D 93 EB                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0435: E88F 9A EB                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0436: E891 9D EB                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0437: E893 E1 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0438: E895 A4 EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0439: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0440: E899 AC EB                  DW     vReadRandom          ;  21 - Read Random                  ;
0441: E89B B2 EB                  DW     vWriteRandom         ;  22 - Write Random                 ;
0442: E89D B8 EB                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0443: E89F BE EB                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0444: E8A1 AB EB                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0445: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0446: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0447: E8A7 C1 EB                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0448: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0449: E8A9         ;
0450: E8A9             DUMMY:                          ;
0451: E8A9 76                     HALT                        ;
0452: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0453: E8AA
0454: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0455: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0456: E8AA         ; same as the warm boot function invoked when you transfer control to the    ;
0457: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0458: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0459: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0460: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0461: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0462: E8AA         ;																			 ;
0463: E8AA         ;			Function Code	 :	C = 00H                                      ;
0464: E8AA         ;			Entry Parameters:	None                                         ;
0465: E8AA         ;			Exit Parameters :	Does Not Return								 ;
0466: E8AA         ;																			 ;
0467: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0468: E8AA             vSystemReset:
0469: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0470: E8AD
0471: E8AD         ;****************************************************************************;
0472: E8AD         ;								IOByte device I/O							 ;
0473: E8AD         ;****************************************************************************;
0474: E8AD
0475: E8AD
0476: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0477: E8AD         ;  This function reads the next byte of data from the console keyboard and   ;
0478: E8AD         ; puts it into register A. If the character input is a graphic character, it ;
0479: E8AD         ; will be echoed back to the console. The only control characters that are   ;
0480: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0481: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0482: E8AD         ; move the cursor to the next multiple of eight columns. All of the other    ;
0483: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0484: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0485: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0486: E8AD         ; console output should also be sent to the list device. If CONTROL-S is     ;
0487: E8AD         ; found, further output will be suspended until you type another character.  ;
0488: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0489: E8AD         ; pressed and disable it the second time. If there is no incoming data       ;
0490: E8AD         ; character, this function will wait until there is one.                     ;
0491: E8AD         ;                                                                            ;
0492: E8AD         ; This is a blocking function                                                ;
0493: E8AD         ;																			 ;
0494: E8AD         ;																			 ;
0495: E8AD         ;			Function Code	:	C = 01H                                      ;
0496: E8AD         ;			Entry Parameters:	None                                         ;
0497: E8AD         ;			Exit Parameters :	A = Data byte from console					 ;
0498: E8AD         ;																			 ;
0499: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0500: E8AD             vConsoleIn:
0501: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0502: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0503: E8B3 D8                     RET    C                    ; return nothing to echo
0504: E8B4
0505: E8B4 F5                     PUSH   AF                   ; Save printable character
0506: E8B5 4F                     LD     C,A
0507: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0508: E8B9 F1                     POP    AF                   ; retrieve exit value
0509: E8BA
0510: E8BA 32 C5 EA               LD     (exitParameterByte),A
0511: E8BD C9                     RET
0512: E8BE
0513: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0514: E8BE         ;  This function outputs the data byte in register E to the console. As with ;
0515: E8BE         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0516: E8BE         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0517: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0518: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0519: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0520: E8BE         ; printer is  toggled on or off                                              ;
0521: E8BE         ;																			 ;
0522: E8BE         ;			Function Code	:	C = 02H                                      ;
0523: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0524: E8BE         ;			Exit Parameters :	None										 ;
0525: E8BE         ;																			 ;
0526: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0527: E8BE         ;BDOS put parameter in C before entering this routine
0528: E8BE             vConsoleOut:
0529: E8BE CD 58 E9               CALL   TabOut
0530: E8C1 C9                     RET
0531: E8C2
0532: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0533: E8C2         ;   function reads the next character from the logical "reader" device into  ;
0534: E8C2         ; register A. In practice, the physical device that is accessed depends      ;
0535: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0536: E8C2         ; reader at all; this function will return some arbitrary value such as lAH  ;
0537: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0538: E8C2         ; Control is not returned to the calling program until a character has been  ;
0539: E8C2         ; read.                                                                      ;
0540: E8C2         ;                                                                            ;
0541: E8C2         ; This is a blocking function                                                ;
0542: E8C2         ;																			 ;
0543: E8C2         ;			Function Code	:	C = 03H                                      ;
0544: E8C2         ;			Entry Parameters:	None										 ;
0545: E8C2         ;			Exit Parameters :	A = Character Input							 ;
0546: E8C2         ;																			 ;
0547: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0548: E8C2             vReaderIn:
0549: E8C2 CD 15 F6               CALL   bcReader
0550: E8C5 32 C5 EA               LD     (exitParameterWord),A
0551: E8C8 C9                     RET
0552: E8C9
0553: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0554: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0555: E8C9         ; specified character from register E to the logical punch device. Again,    ;
0556: E8C9         ; the actual physical device used, if any, is determined by the BIOS.        ;
0557: E8C9         ; There is no set standard for this device; in some systems the punch        ;
0558: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0559: E8C9         ; output to it.                                                              ;
0560: E8C9         ;																			 ;
0561: E8C9         ;			Function Code	:	C = 04H                                      ;
0562: E8C9         ;			Entry Parameters:	E = Data byte to be output					 ;
0563: E8C9         ;			Exit Parameters :	None										 ;
0564: E8C9         ;																			 ;
0565: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0566: E8C9         ;BDOS put parameter in C before entering this routine
0567: E8C9             vPunchOut:
0568: E8C9 CD 12 F6               CALL   bcPunch
0569: E8CC C9                     RET
0570: E8CD
0571: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0572: E8CD         ;  This function outputs the specified byte in register E to the logical     ;
0573: E8CD         ; list device. As with the reader and the punch, the physical device used    ;
0574: E8CD         ; depends entirely on the BIOS.                                              ;
0575: E8CD         ;																			 ;
0576: E8CD         ;			Function Code	:	C = 05H                                      ;
0577: E8CD         ;			Entry Parameters:	E = Data byte to be output					 ;
0578: E8CD         ;			Exit Parameters :	None										 ;
0579: E8CD         ;																			 ;
0580: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0581: E8CD         ;BDOS put parameter in C before entering this routine
0582: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0583: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0584: E8D0 C9                     RET
0585: E8D1
0586: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0587: E8D1         ;  This function serves double duty: it both inputs and outputs characters   ;
0588: E8D1         ; from the console. However, it bypasses the normal control characters and   ;
0589: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0590: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0591: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0592: E8D1         ; then E contains a valid ASCII character that is output to the console.     ;
0593: E8D1         ;  This function works well provided you never have to send a value ofOFFH   ;
0594: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0595: E8D1         ; binary data, you cannot use this function, since these values are likely   ;
0596: E8D1         ; to be part of the data stream.                                             ;
0597: E8D1         ;                                                                            ;
0598: E8D1         ;			Function Code	:	C = 06H                                      ;
0599: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0600: E8D1         ;								E = Other than 0FFH for Output				 ;
0601: E8D1         ;			Exit Parameters :	A = Input byte or status					 ;
0602: E8D1         ;																			 ;
0603: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0604: E8D1         ;BDOS put parameter in C before entering this routine
0605: E8D1             vDirectConIO:
0606: E8D1 79                     LD     A,C
0607: E8D2 3C                     INC    A
0608: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0609: E8D5         ; send byte to console
0610: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0611: E8D8 C9                     RET
0612: E8D9
0613: E8D9         ;read byte/status from console
0614: E8D9             vDirectConIO1:
0615: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0616: E8DC B7                     OR     A                    ; 00 means not data ready
0617: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0618: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0619: E8E3 32 C5 EA               LD     (exitParameterByte),A ; Save it
0620: E8E6 C9                     RET
0621: E8E7
0622: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0623: E8E7         ; This function places the current value of the IOBYTE in register A.        ;
0624: E8E7         ;                                                                            ;
0625: E8E7         ; The IOBYTE structure:                                                      ;
0626: E8E7         ;								+-------+-------+-------+-------+            ;
0627: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0628: E8E7         ;								+-------+-------+-------+-------+            ;
0629: E8E7         ;				Logical Device     List | Punch | Reader|Console             ;
0630: E8E7         ;                                                                            ;
0631: E8E7         ;                                                                            ;
0632: E8E7         ;			Function Code	:	C = 07H                                      ;
0633: E8E7         ;			Entry Parameters:	None					  		  			 ;
0634: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0635: E8E7         ;																			 ;
0636: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0637: E8E7             vGetIOBYTE:
0638: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0639: E8EA 32 C5 EA               LD     (exitParameterWord),A ; Return it to caller
0640: E8ED C9                     RET
0641: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0642: E8EE         ; This function sets the IOBYTE         									 ;
0643: E8EE         ;                                                                            ;
0644: E8EE         ; The IOBYTE structure:                                                      ;
0645: E8EE         ;								+-------+-------+-------+-------+            ;
0646: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0647: E8EE         ;								+-------+-------+-------+-------+            ;
0648: E8EE         ;				Logical Device     List | Punch | Reader|Console             ;
0649: E8EE         ;                                                                            ;
0650: E8EE         ;                                                                            ;
0651: E8EE         ;			Function Code	:	C = 08H                                      ;
0652: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0653: E8EE         ;			Exit Parameters :	None                                         ;
0654: E8EE         ;																			 ;
0655: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0656: E8EE         ;BDOS put parameter in C before entering this routine
0657: E8EE             vSetIOBYTE:
0658: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0659: E8F1 71                     LD     (HL),C               ; Place new vale in it
0660: E8F2 C9                     RET
0661: E8F3
0662: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0663: E8F3         ;  This function outputs a string of characters to the console device. The   ;
0664: E8F3         ; address of this string is in registers DE. You must make sure that the last;
0665: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0666: E8F3         ; for the end of the string.                                                 ;
0667: E8F3         ;  The "$" itself does not get output to the console.                        ;
0668: E8F3         ;                                                                            ;
0669: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0670: E8F3         ; described, checks to see if there is an incoming character, and checks for ;
0671: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0672: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0673: E8F3         ; the printer).                                                              ;
0674: E8F3         ;                                                                            ;
0675: E8F3         ;			Function Code	:	C = 09H                                      ;
0676: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0677: E8F3         ;			Exit Parameters :	None							             ;
0678: E8F3         ;																			 ;
0679: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0680: E8F3             vPrintString:
0681: E8F3 2A C3 EA               LD     HL,(paramDE)         ; Get address of the string
0682: E8F6 4D                     LD     C,L
0683: E8F7 44                     LD     B,H                  ; Put it into BC for call
0684: E8F8 CD 3B E9               CALL   Print                ; out to console
0685: E8FB C9                     RET
0686: E8FC
0687: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0688: E8FC         ;  This function reads a string of characters from the console device        ;
0689: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0690: E8FC         ; editing is possible: the operator can backspace, cancel the line and start ;
0691: E8FC         ; over, and use all the normal control functions. What you will ultimately   ;
0692: E8FC         ; see in the buffer is the final version of the character string entered,    ;
0693: E8FC         ; without any of the errors or control characters used to do the line editing;
0694: E8FC         ;                                                                            ;
0695: E8FC         ;  The buffer that you define has a special format. The first byte in the    ;
0696: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0697: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0698: E8FC         ; were actually placed in the buffer. The following bytes contain            ;
0699: E8FC         ; the characters of the string. Character input will cease either when a     ;
0700: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0701: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0702: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0703: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0704: E8FC         ; the "characters input" byte to O. If you attempt to input more than the    ;
0705: E8FC         ; maximum number of characters, the "characters input" count will be the     ;
0706: E8FC         ; same as the maximum value allowed.                                         ;
0707: E8FC         ;                                                                            ;
0708: E8FC         ;			Function Code	:	C = 0AH                                      ;
0709: E8FC         ;			Entry Parameters:	DE = Address string buffer					 ;
0710: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0711: E8FC         ;																			 ;
0712: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0713: E8FC             vReadString:
0714: E8FC CD E0 E9               CALL   ReadString
0715: E8FF C9                     RET
0716: E900
0717: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0718: E900         ; This function tells you whether a console input character is waiting to be ;
0719: E900         ;processed. Unlike the Console Input functions, which will wait until there  ;
0720: E900         ;is input,this function simply checks and returns immediately.               ;
0721: E900         ;                                                                            ;
0722: E900         ;			Function Code	:	C = 0BH                                      ;
0723: E900         ;			Entry Parameters:	None										 ;
0724: E900         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0725: E900         ;								A = FFH	if incoming Data					 ;
0726: E900         ;																			 ;
0727: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0728: E900             vGetConsoleStatus:
0729: E900 CD 8C E9               CALL   ConBreak
0730: E903 32 C5 EA               LD     (exitParameterByte),A
0731: E906 C9                     RET
0732: E907
0733: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0734: E907         ;  This function tells you which version of CP/M you are currently running.  ;
0735: E907         ; A two-byte value is returned:                                              ;
0736: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0737: E907         ;	L = OOH for all releases before CP/M 2.0                                 ;
0738: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0739: E907         ;		and so on for any subsequent releases.                               ;
0740: E907         ;                                                                            ;
0741: E907         ; This information is of interest only if your program has some version      ;
0742: E907         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0743: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0744: E907         ; Therefore, if your program uses Random I/O, put this check at the          ;
0745: E907         ; beginning to ensure that it is indeed running under the appropriate        ;
0746: E907         ; version of CP/M.                                                           ;
0747: E907         ;                                                                            ;
0748: E907         ;			Function Code	:	C = 0CH                                      ;
0749: E907         ;			Entry Parameters:	None										 ;
0750: E907         ;			Exit Parameters :	HL =Version Number Code						 ;
0751: E907         ;								A = FFH	if incoming Data					 ;
0752: E907         ;																			 ;
0753: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0754: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0755: E907 3E 20                  LD     A,VERSION
0756: E909 32 C5 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0757: E90C C9                     RET
0758: E90D
0759: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0760: E90D         ;  This subroutine either sets or gets the current user number. The current  ;
0761: E90D         ; user number determines which file directory entries are matched during all ;
0762: E90D         ; disk file operations. When you call this function, the contents of the     ;
0763: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0764: E90D         ; will return the current user number in the A register. If you set E to a   ;
0765: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0766: E90D         ; will set the current user number to this value.                            ;
0767: E90D         ;                                                                            ;
0768: E90D         ;			Function Code	:	C = 0CH                                      ;
0769: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0770: E90D         ;								  = 0 to 15 to set User Number				 ;
0771: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0772: E90D         ;								A = FFH	if incoming Data					 ;
0773: E90D         ;																			 ;
0774: E90D         ;                                                                            ;
0775: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0776: E90D             vGetSetUserNumber:
0777: E90D 3A C2 EA               LD     A,(paramE)
0778: E910 FE FF                  CP     0FFH
0779: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0780: E914 3A 5E F5               LD     A,(currentUserNumber)
0781: E917 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0782: E91A C9                     RET
0783: E91B
0784: E91B             SetUserNumber:
0785: E91B E6 0F                  AND    LO_NIBBLE_MASK
0786: E91D 32 5E F5               LD     (currentUserNumber),A
0787: E920 C9                     RET
0788: E921
0789: E921         ;****************************************************************************;
0790: E921         ;								Character Support Routines					 ;
0791: E921         ;****************************************************************************;
0792: E921
0793: E921
0794: E921         ;-------------------- Return a Character from the console -------------------;
0795: E921         ;return byte from buffer or read from the console                            ;
0796: E921             ConIn:                          ;
0797: E921 21 BE EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0798: E924 7E                     LD     A,(HL)               ;
0799: E925 36 00                  LD     (HL),0               ;
0800: E927 B7                     OR     A                    ;
0801: E928 C0                     RET    NZ                   ;
0802: E929         ;
0803: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0804: E92C         ;-------------------- Return a Character from the console -------------------;
0805: E92C
0806: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0807: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0808: E92C             IsPrintableASCII:                      ;
0809: E92C FE 0D                  CP     CR                   ;
0810: E92E C8                     RET    Z                    ; carriage return?                                                  ;
0811: E92F FE 0A                  CP     LF                   ;
0812: E931 C8                     RET    Z                    ; line feed?                                                        ;
0813: E932 FE 09                  CP     TAB                  ;
0814: E934 C8                     RET    Z                    ; TAB?                                                              ;
0815: E935 FE 08                  CP     CTRL_H               ;
0816: E937 C8                     RET    Z                    ; backspace?                                                        ;
0817: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0818: E93A C9                     RET                         ;
0819: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0820: E93B
0821: E93B         ;------------------ Print character from (BC) until  $ found ----------------;
0822: E93B             Print:                          ;
0823: E93B 0A                     LD     A,(BC)               ; Get the next character             ;
0824: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0825: E93E C8                     RET    Z                    ;  exit if yes                       ;
0826: E93F 03                     INC    BC                   ; Update the pointer                 ;
0827: E940 C5                     PUSH   BC                   ; Save it                            ;
0828: E941 4F                     LD     C,A                  ; Does Byte require                  ;
0829: E942 CD 58 E9               CALL   TabOut               ;  special attention - check         ;
0830: E945 C1                     POP    BC                   ; Retrieve the pointer				 ;
0831: E946 18 F3                  JR     Print                ; Loop back                          ;
0832: E948         ;------------------ Print character from (BC) until  $ found ----------------;
0833: E948
0834: E948         ;-- Send printable character to console. Precede with Caret if needed -------;
0835: E948         ; character is in Reg C                                                      ;
0836: E948             CaretOut:                       ;
0837: E948 79                     LD     A,C                  ;
0838: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0839: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0840: E94E         ; send preceding up arrow                                                    ;
0841: E94E F5                     PUSH   AF                   ; Save the character                 ;
0842: E94F 0E 5E                  LD     C,CARET              ;
0843: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0844: E954 F1                     POP    AF                   ; Get the character                  ;
0845: E955 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0846: E957 4F                     LD     C,A                  ; Set up to print                    ;
0847: E958         ; fall thru to TabbOut                                                       ;
0848: E958         ;-- Send printable character to console. Precede with Caret if needed -------;
0849: E958
0850: E958         ;------------- Send printable character to console. Expand if TAB -----------;
0851: E958         ; character is in Reg C                                                      ;
0852: E958             TabOut:                         ;
0853: E958 79                     LD     A,C                  ;
0854: E959 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0855: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0856: E95E         ;
0857: E95E         ; TAB encountered                                                           ;
0858: E95E             TabOut0:                        ;
0859: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0860: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                    ;
0861: E963 3A C1 EA               LD     A,(columnPosition)   ; Get Column position                ;
0862: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0863: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0864: E96A C9                     RET                         ;
0865: E96B         ;------------- Send printable character to console. Expand if TAB -----------;
0866: E96B
0867: E96B         ;-------------------------- Send character to console -----------------------;
0868: E96B         ; C  = Character to be output                                                ;
0869: E96B             ConsoleOut:                      ;
0870: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0871: E96B C5                     PUSH   BC                   ; Save character and Count           ;
0872: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0873: E96F C1                     POP    BC                   ;
0874: E970 C5                     PUSH   BC                   ; Get/save character                 ;
0875: E971         ; Send character to Console	                                                 ;
0876: E971 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0877: E974 C1                     POP    BC                   ;
0878: E975 C5                     PUSH   BC                   ; Get/save character                 ;
0879: E976         ; is the data to be output to print device?                                  ;
0880: E976 3A BF EA               LD     A,(printEchoFlag)    ;
0881: E979 B7                     OR     A                    ;
0882: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0883: E97D C1                     POP    BC                   ; Get the character                  ;
0884: E97E         ;
0885: E97E 79                     LD     A,C                  ; Put character to ACC               ;
0886: E97F 21 C1 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0887: E982 34                     INC    M                    ; increment the ColumnPosition       ;
0888: E983         ;
0889: E983 FE 20                  CP     SPACE                ;
0890: E985 D0                     RET    NC                   ; Exit if ASCII printable            ;
0891: E986         ;
0892: E986 FE 0A                  CP     LF                   ;
0893: E988 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0894: E989         ;
0895: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0896: E98B C9                     RET                         ;
0897: E98C         ;-------------------------- Send character to console -----------------------;
0898: E98C
0899: E98C         ;--------------------  Check for Status and Control S or C ------------------;
0900: E98C         ;  Returns:																	 ;
0901: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0902: E98C         ;			ACC = 00   No data Pending										 ;
0903: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0904: E98C         ;                                                                            ;
0905: E98C             ConBreak:                       ;
0906: E98C 3A BE EA               LD     A,(keyboardByte)     ;
0907: E98F B7                     OR     A                    ; If there is a char waiting         ;
0908: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0909: E992         ;
0910: E992 CD 06 F6               CALL   bcConst              ; Get status                         ;
0911: E995 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0912: E997 C8                     RET    Z                    ; Return 00 No data pending          ;
0913: E998         ;
0914: E998 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0915: E99B         ;
0916: E99B FE 10                  CP     CTRL_P               ;
0917: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0918: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0919: E99F 21 BF EA               LD     HL,printEchoFlag     ;
0920: E9A2 3E FF                  LD     A,TRUE               ;
0921: E9A4 BE                     CP     (HL)                 ;
0922: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0923: E9A7 3E 00                  LD     A,FALSE              ;
0924: E9A9             ToggleFlag1:                      ;
0925: E9A9 77                     LD     (HL),A               ;
0926: E9AA 18 0C                  JR     NothingWaiting       ;
0927: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0928: E9AC             CheckCTL_S:                      ;
0929: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0930: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0931: E9B0         ;
0932: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0933: E9B3 FE 03                  CP     CTRL_C               ;
0934: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0935: E9B8             NothingWaiting:                      ;
0936: E9B8 AF                     XOR    A                    ;
0937: E9B9 C9                     RET                         ; Set ACC = 0 and return             ;
0938: E9BA             ConBreak0:                      ;
0939: E9BA 32 BE EA               LD     (keyboardByte),A     ; save the byte                      ;
0940: E9BD             ConBreak1:                      ;
0941: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0942: E9BF C9                     RET                         ;
0943: E9C0         ;--------------------  Check for Status and Control S or C ------------------;
0944: E9C0
0945: E9C0         ;------------------------  Console Output Utilities -------------------------;
0946: E9C0             showHashCRLF:                      ;
0947: E9C0 0E 23                  LD     C,HASH_TAG           ;
0948: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                  ;
0949: E9C5 CD D6 E9               CALL   showCRLF             ;
0950: E9C8             showHashCRLF1:                      ;
0951: E9C8 3E C1                  LD     A,columnPosition     ;
0952: E9CA 21 C0 EA               LD     HL,startingColumn    ;
0953: E9CD BF                     CP     A,M                  ;
0954: E9CE D0                     RET    NC                   ;
0955: E9CF 0E 20                  LD     C,SPACE              ;
0956: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0957: E9D4 18 F2                  JR     showHashCRLF1        ;
0958: E9D6         ;------------------------  Console Output Utilities -------------------------;
0959: E9D6
0960: E9D6         ;------------------------  Send Carriage Return and Line Feed ---------------;
0961: E9D6             showCRLF:                       ;
0962: E9D6 0E 0D                  LD     C,CR                 ;
0963: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0964: E9DB 0E 0A                  LD     C,LF                 ;
0965: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0966: E9E0         ;------------------------  Send Carriage Return and Line Feed ---------------;
0967: E9E0
0968: E9E0         ;------------------------- Read a $ terminated String -----------------------;
0969: E9E0         ;read to paramDE address (max length, current length, buffer)               ;
0970: E9E0             ReadString:                      ;
0971: E9E0 3A C1 EA               LD     A,(columnPosition)   ;
0972: E9E3 32 C0 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0973: E9E6 2A C3 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0974: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0975: E9EA 23                     INC    HL                   ; Point at actual bytes read         ;
0976: E9EB 06 00                  LD     B,0                  ; Initialize Current Count           ;
0977: E9ED         ;
0978: E9ED         ; B = Current Count                                                      ;
0979: E9ED         ; C = Maximum characters                                                 ;
0980: E9ED         ; HL= Insertion Pointer                                                  ;
0981: E9ED         ;
0982: E9ED         ; read next character, BC, HL active                                        ;
0983: E9ED             ReadNext:                       ;
0984: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0985: E9EE E5                     PUSH   HL                   ; Save pointer                       ;
0986: E9EF             ReadNext0:                      ;
0987: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character             ;
0988: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0989: E9F4 E1                     POP    HL                   ; Restore Pointer					 ;
0990: E9F5 C1                     POP    BC                   ; Restore Current Index and Max Count;
0991: E9F6         ;Is It Carriage Return                                                       ;
0992: E9F6 FE 0D                  CP     CR                   ;
0993: E9F8 CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0994: E9FB FE 0A                  CP     LF                   ;
0995: E9FD         ;Is It Linefeed                                                              ;
0996: E9FD CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0997: EA00         ;Is It BackSpace                                                             ;
0998: EA00 FE 08                  CP     CTRL_H               ;
0999: EA02 CA 48 EA               JP     Z,BSspaceBS          ;
1000: EA05             IsItRubout:                      ;
1001: EA05 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
1002: EA07 CA 52 EA               JP     Z,ItIsRubout         ;
1003: EA0A             IsPhysicalEOL:                      ;
1004: EA0A FE 05                  CP     CTRL_E               ;
1005: EA0C CA 5D EA               JP     Z,ItIsPhysicalEOL    ;
1006: EA0F             IsItPrintToggle:                      ;
1007: EA0F FE 10                  CP     CTRL_P               ;
1008: EA11 CA 65 EA               JP     Z,ItIsPrintToggle    ;
1009: EA14             IsItDeleteTheLineX:                      ;
1010: EA14 FE 18                  CP     CTRL_X               ;
1011: EA16 CA 8E EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1012: EA19             IsItDeleteTheLineU:                      ;
1013: EA19 FE 15                  CP     CTRL_U               ;
1014: EA1B CA AC EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1015: EA1E         ;Retype the line                                                             ;
1016: EA1E FE 12                  CP     CTRL_R               ;
1017: EA20 CA 75 EA               JP     Z,RepeatLine         ;
1018: EA23
1019: EA23         ;....................... Echo input back to the Console  ....................;
1020: EA23         ; Full Duplex								                                 ;
1021: EA23         ; A = Character to display	                                                 ;
1022: EA23         ; B = current char count                                                     ;
1023: EA23         ; C = maximum buffer length                                                  ;
1024: EA23         ; HL= buffer pointer                                                         ;
1025: EA23         ;ReadEcho                                                                    ;
1026: EA23 04                     INC    B                    ; Increment byte count		         ;
1027: EA24 23                     INC    HL                   ; Advance the Pointer                ;
1028: EA25 77                     LD     (HL),A               ; Put char in buffer                 ;
1029: EA26         ;
1030: EA26             ReadEchoRubOut:                      ;
1031: EA26 C5                     PUSH   BC                   ; Save index and length              ;
1032: EA27 E5                     PUSH   HL                   ; Save the Pointer                   ;
1033: EA28 4F                     LD     C,A                  ; Get char                           ;
1034: EA29 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1035: EA2C E1                     POP    HL                   ; Restore the Pointer                ;
1036: EA2D C1                     POP    BC                   ; Restore index and length           ;
1037: EA2E 7E                     LD     A,(HL)               ; Recall char                        ;
1038: EA2F         ; check for Warm Boot                                                        ;
1039: EA2F FE 03                  CP     CTRL_C               ;
1040: EA31 78                     LD     A,B                  ; Get Line position                  ;
1041: EA32 C2 3A EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1042: EA35 FE 01                  CP     1                    ; Beginning of the Line?             ;
1043: EA37 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1044: EA3A         ; Check to see if we are at the end of the buffer                            ;
1045: EA3A             AreWeAtEndOfBuffer:                      ;
1046: EA3A B9                     CP     C                    ; Over Max ?					     ;
1047: EA3B DA ED E9               JP     C,ReadNext           ;  no, Go for more				     ;
1048: EA3E         ;
1049: EA3E         ; At the end of read                                  					     ;
1050: EA3E             EndRead:                        ;
1051: EA3E         ; 	POP		HL                                                               ;
1052: EA3E 2A C3 EA               LD     HL,(paramDE)         ;
1053: EA41 23                     INC    HL                   ;
1054: EA42         ;
1055: EA42 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1056: EA43 0E 0D                  LD     C,CR                 ;
1057: EA45 C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1058: EA48         ;....................... Echo input back to the Console  ....................;
1059: EA48         ;.......................... Backspace SPACE BackSpace .......................;
1060: EA48             BSspaceBS:                      ;
1061: EA48 05                     DEC    B                    ;
1062: EA49 2B                     DEC    HL                   ;
1063: EA4A C5                     PUSH   BC                   ;
1064: EA4B E5                     PUSH   HL                   ;
1065: EA4C CD 9F EA               CALL   BackUp               ;
1066: EA4F C3 EF E9               JP     ReadNext0            ;
1067: EA52         ;.......................... Backspace SPACE BackSpace .......................;
1068: EA52         ;.......................... It is RubOut ....................................;
1069: EA52             ItIsRubout:                      ;
1070: EA52         ; RUBOUT if possible                                                         ;
1071: EA52 78                     LD     A,B                  ; Are we at the start of the line    ;
1072: EA53 B7                     OR     A                    ;
1073: EA54 CA ED E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1074: EA57         ;adjust pointers back one                                                    ;
1075: EA57 7E                     LD     A,(HL)               ; ACC = current character            ;
1076: EA58 05                     DEC    B                    ; Adjust the index			    	 ;
1077: EA59 2B                     DEC    HL                   ; Adjust the pointer                 ;
1078: EA5A C3 26 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1079: EA5D         ;.......................... It is RubOut ....................................;
1080: EA5D         ;.......................... It is PhysicalEOL ...............................;
1081: EA5D             ItIsPhysicalEOL:                      ;
1082: EA5D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1083: EA5E E5                     PUSH   HL                   ; Save pointer                       ;
1084: EA5F CD D6 E9               CALL   showCRLF             ; Make new line                      ;
1085: EA62 C3 EF E9               JP     ReadNext0            ;   and go for next char   			 ;
1086: EA65         ;.......................... It is PhysicalEOL ...............................;
1087: EA65         ;.......................... It is PrintToggle ...............................;
1088: EA65             ItIsPrintToggle:                      ;
1089: EA65 E5                     PUSH   HL                   ; Save pointer                       ;
1090: EA66         ; Toggle the printEcho Flag                                                  ;
1091: EA66 21 BF EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1092: EA69 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1093: EA6B BE                     CP     (HL)                 ; Is the flag true?                  ;
1094: EA6C 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1095: EA6E 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1096: EA70             IsItPrintToggle1:                      ;
1097: EA70 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1098: EA71 E1                     POP    HL                   ; Restore pointer                    ;
1099: EA72 C3 ED E9               JP     ReadNext             ;   and for another char             ;
1100: EA75         ;.......................... It is PrintToggle ...............................;
1101: EA75         ;.......................... RepeatLine ......................................;
1102: EA75             RepeatLine:                      ;
1103: EA75 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1104: EA76 E5                     PUSH   HL                   ;  for exit                          ;
1105: EA77 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1106: EA7A         ;
1107: EA7A 2A C3 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1108: EA7D 23                     INC    HL                   ; Skip past character count          ;
1109: EA7E         ;
1110: EA7E             LL1:                            ;
1111: EA7E 23                     INC    HL                   ; Point at next char to display      ;
1112: EA7F C5                     PUSH   BC                   ; Save counter, in B                 ;
1113: EA80 E5                     PUSH   HL                   ; Save buffer pointer                ;
1114: EA81 4E                     LD     C,M                  ; Get the next character             ;
1115: EA82 CD 48 E9               CALL   CaretOut             ; Display it                         ;
1116: EA85 E1                     POP    HL                   ; Restore                            ;
1117: EA86 C1                     POP    BC                   ;  the counter and pointer           ;
1118: EA87 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1119: EA89 E1                     POP    HL                   ; Restore values                     ;
1120: EA8A C1                     POP    BC                   ;  from routine entry                ;
1121: EA8B C3 ED E9               JP     ReadNext             ; Done here !                        ;
1122: EA8E         ;.......................... RepeatLine ......................................;
1123: EA8E         ;.......................... Delete The Line .................................;
1124: EA8E             DeleteTheLine:                      ;
1125: EA8E E1                     POP    HL                   ; Adjust Stack                       ;
1126: EA8F         ;                                             ;
1127: EA8F             DeleteTheLine1:                      ;
1128: EA8F 3A C0 EA               LD     A,(startingColumn)   ;
1129: EA92 21 C1 EA               LD     HL,columnPosition    ;
1130: EA95 BE                     CP     M                    ; Start of line ?                    ;
1131: EA96 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1132: EA99 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1133: EA9A CD 9F EA               CALL   BackUp               ; Clear 1 column                     ;
1134: EA9D 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1135: EA9F         ;.......................... Delete The Line .................................;
1136: EA9F         ;------------------------ Back-up one screen position -----------------------;
1137: EA9F             BackUp:                         ;
1138: EA9F CD A7 EA               CALL   BackUp1              ; Send Backspace                     ;
1139: EAA2 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1140: EAA4 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1141: EAA7         ;does not affect column count                                                ;
1142: EAA7             BackUp1:                        ;
1143: EAA7 0E 08                  LD     C,CTRL_H             ;
1144: EAA9 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1145: EAAC         ;------------------------ Back-up one screen position -----------------------;
1146: EAAC         ;.......................... Ignore The Line .................................;
1147: EAAC             IgnoreTheLine:                      ;
1148: EAAC CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1149: EAAF 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1150: EAB1 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1151: EAB4 0E 20                  LD     C,SPACE              ;
1152: EAB6 CD 0C F6               CALL   bcConout             ;
1153: EAB9 C3 E0 E9               JP     ReadString           ; Start all over                     ;
1154: EABC         ;.......................... Ignore The Line .................................;
1155: EABC
1156: EABC         ;------------------------- Read a $ terminated String -----------------------;
1157: EABC
1158: EABC         ;****************************************************************************
1159: EABC         ;                           DATA AREA                                       *
1160: EABC         ;****************************************************************************
1161: EABC
1162: EABC         ;------------------------------Non Disk Data Area ---------------------------;
1163: EABC             usersStack: DS     2                    ; entry stack pointer                ;
1164: EABE         ;
1165: EABE 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1166: EABF         ;
1167: EABF 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1168: EAC0         ;
1169: EAC0         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1170: EAC0 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1171: EAC1 00          columnPosition: DB     0                    ; Current Column position            ;
1172: EAC2         ;
1173: EAC2             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1174: EAC3             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1175: EAC5             exitParameterByte:                      ; Byte returned Value                ;
1176: EAC5             exitParameterWord: DS     WORD                 ; Word                           ;
1177: EAC7         ;
1178: EAC7         ;
1179: EAC7         ;------------------------------------ Data Area -----------------------------;
1180: EAC7
1181: EAC7
1182: EAC7
1183: EAC7         ;****************************************************************************;
1184: EAC7         ;								Disk I/O									 ;
1185: EAC7         ;****************************************************************************;
1186: EAC7
1187: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1188: EAC7         ;  This function requests CP/M to completely reset the disk file system.     ;
1189: EAC7         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1190: EAC7         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1191: EAC7         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1192: EAC7         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1193: EAC7         ; in each logical disk as each disk is accessed. This involves reading the   ;
1194: EAC7         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1195: EAC7         ; which keep track of which allocation blocks are free and which             ;
1196: EAC7         ; are used for file storage.                                                 ;
1197: EAC7         ;                                                                            ;
1198: EAC7         ;			Function Code	:	C = 0DH                                      ;
1199: EAC7         ;			Entry Parameters:	None										 ;
1200: EAC7         ;			Exit Parameters :	None										 ;
1201: EAC7         ;																			 ;
1202: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1203: EAC7             vResetSystem:
1204: EAC7 21 00 00               LD     HL,0
1205: EACA 22 61 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1206: EACD 22 63 F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1207: EAD0 AF                     XOR    A                    ; Clear the current disk
1208: EAD1 32 5F F5               LD     (currentDisk),A
1209: EAD4         ; note that currentUserNumber remains unchanged
1210: EAD4 21 80 00               LD     HL,DMABuffer
1211: EAD7 22 65 F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1212: EADA CD FE EE               CALL   SetDataDMA           ; to data DMA address
1213: EADD C3 F6 EC               JP     Select
1214: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1215: EAE0         ;  This function makes the logical disk named in register E the default disk;
1216: EAE0         ; All subsequent references to disk files that do not specify the disk will ;
1217: EAE0         ; use this default. When you reference a disk file that does have an        ;
1218: EAE0         ; explicit logical disk in its name you do not have to issue another        ;
1219: EAE0         ; Select Disk function; the BDOS will take care of that for you.            ;
1220: EAE0         ;                                                                           ;
1221: EAE0         ;  Notice the way in which the logical disk is specified in register E.     ;
1222: EAE0         ; It is not the same as the disk drive specification in the first byte of   ;
1223: EAE0         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1224: EAE0         ; "use the current default disk" (as specified in the last Select Disk      ;
1225: EAE0         ; call or by the operator on the console). With this function, a value      ;
1226: EAE0         ; of OOH in register A means that A is the selected drive, a value of       ;
1227: EAE0         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1228: EAE0         ; 16 drives in the system.                                                  ;
1229: EAE0         ;                                                                           ;
1230: EAE0         ;			Function Code	:	C = 0EH                                     ;
1231: EAE0         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1232: EAE0         ;			Exit Parameters :	None										;
1233: EAE0         ;																			;
1234: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1235: EAE0
1236: EAE0             vSelectDisk:
1237: EAE0 C3 EA EC               JP     SelectCurrent
1238: EAE3
1239: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1240: EAE3         ;  This function opens a specified file for reading or writing. The FCB,    ;
1241: EAE3         ; whose address must be in register DE, tells CP/M the user number,         ;
1242: EAE3         ; the logical disk, the file name, and the file type. All other bytes of    ;
1243: EAE3         ; the FCB will normally be set to O.                                        ;
1244: EAE3         ;  The code returned by the BDOS in register A indicates whether the file   ;
1245: EAE3         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1246: EAE3         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1247: EAE3         ; then the file has been opened.                                            ;
1248: EAE3         ;			Function Code	:	C  = 0FH                                    ;
1249: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1250: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1251: EAE3         ;																			;
1252: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1253: EAE3             vOpenFile:
1254: EAE3 CD B6 EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1255: EAE6 CD 37 EF               CALL   ReselectDisk         ; do we need to reselect disk?
1256: EAE9 C3 CD ED               JP     OpenFile
1257: EAEC
1258: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1259: EAEC         ;  This function terminates the processing of a file to which you have      ;
1260: EAEC         ; written information. Under CP/M you do not need to close a file that you  ;
1261: EAEC         ; have been reading. However, if you ever intend for your program to        ;
1262: EAEC         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1263: EAEC         ; should close all files regardless of their use.                           ;
1264: EAEC         ;  The Close File function, like Open File, returns a directory code in     ;
1265: EAEC         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1266: EAEC         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1267: EAEC         ; been closed.                                                              ;
1268: EAEC         ;                                                                           ;
1269: EAEC         ;  When the BDOS closes a file to which data has been written, it writes    ;
1270: EAEC         ; the current contents of the FCB out to the disk directory, updating       ;
1271: EAEC         ; an existing directory entry by matching the disk, name, type, and         ;
1272: EAEC         ; extent number in the same manner that the Open File function does.        ;
1273: EAEC         ; Note that the BDOS does not transfer the last record of the file to the   ;
1274: EAEC         ; disk during the close operation. It merely updates the file directory.    ;
1275: EAEC         ; You must arrange to flush any partly filled record to the disk. If the    ;
1276: EAEC         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1277: EAEC         ; arrange to fill the unused portion of the record with the standard lAH    ;
1278: EAEC         ; end-of-file characters as CP/M expects.                                   ;
1279: EAEC         ;                                                                           ;
1280: EAEC         ;			Function Code	:	C  = 10FH                                   ;
1281: EAEC         ;			Entry Parameters:	DE = Address of File Control Block			;
1282: EAEC         ;			Exit Parameters :	A  = Directory Code							;
1283: EAEC         ;																			;
1284: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1285: EAEC             vCloseFile:
1286: EAEC CD 37 EF               CALL   ReselectDisk
1287: EAEF C3 10 EE               JP     CloseDirEntry
1288: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1289: EAF2         ;  This function scans down the file directory for the first entry that     ;
1290: EAF2         ; matches the file name, type, and extent in the FCB addressed by DE.       ;
1291: EAF2         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
1292: EAF2         ; more character positions. Where a "?" occurs, the BDOS will match any     ;
1293: EAF2         ; character in the corresponding position in the file directory. This is    ;
1294: EAF2         ; known as ambiguous file name matching.                                    ;
1295: EAF2         ;  The first byte of an FCB normally contains the logical disk number code. ;
1296: EAF2         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
1297: EAF2         ; and so on up to a possible maximum of 16 for disk P. However, if this     ;
1298: EAF2         ; byte contains a "?", the BDOS will search the default logical disk and    ;
1299: EAF2         ; will match the file name and type regardless of the user number. This     ;
1300: EAF2         ; function is normally used in conjunction with the Search Next function.   ;
1301: EAF2         ; Search First, in the process of matching a file, leaves certain           ;
1302: EAF2         ; variables in the BDOS set, ready for a subsequent Search Next.            ;
1303: EAF2         ;  Both Search First and Search Next return a directory code in the         ;
1304: EAF2         ; A register. With Search First, A = OFFH when no files match the FCB,      ;
1305: EAF2         ; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
1306: EAF2         ;                                                                           ;
1307: EAF2         ;  To locate the particular directory entry that either the Search First    ;
1308: EAF2         ; or Search Next function matched, multiply the directory code returned     ;
1309: EAF2         ; in A by the length of a directory entry (32 bytes). This is easily done   ;
1310: EAF2         ; by adding the A register to itself five times. Then add the DMA address   ;
1311: EAF2         ; to get the actual address where the matched directory entry is stored.    ;
1312: EAF2         ;  There are many occasions when you may need to write a program that will  ;
1313: EAF2         ; accept an ambiguous file name and operate on all of the file names that   ;
1314: EAF2         ; match it. (The DIR and ERA commands built into the CCP are examples that  ;
1315: EAF2         ; use ambiguous file names.) To do this, you must use several BDOS          ;
1316: EAF2         ; functions: the Set DMA Address function (code 26), this function          ;
1317: EAF2         ; (Search First), and Search Next (code 18). All of this is shown in the    ;
1318: EAF2         ; subroutine given in Figure 5-17.                                          ;
1319: EAF2         ;                                                                           ;
1320: EAF2         ;                                                                           ;
1321: EAF2         ;			Function Code	:	C  = 11FH                                   ;
1322: EAF2         ;			Entry Parameters:	DE = Address of File Control Block			;
1323: EAF2         ;			Exit Parameters :	A  = Directory Code							;
1324: EAF2         ;																			;
1325: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1326: EAF2             vFindFirst:
1327: EAF2 0E 00                  LD     C,0                  ; Length assuming '?' true
1328: EAF4 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB
1329: EAF7 7E                     LD     A,(HL)               ; DIsk/User No
1330: EAF8 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1331: EAFA CA 05 EB               JP     Z,QMarkFind          ;  if Yes, skip disk reselect
1332: EAFD         ;  and reset of EXT
1333: EAFD
1334: EAFD CD B6 EF               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1335: EB00 CD 37 EF               CALL   ReselectDisk         ; Use FCB to set currentDisk
1336: EB03 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1337: EB05
1338: EB05             QMarkFind:
1339: EB05 CD E2 EF               CALL   SearchForDirectoryRecord ; Find the directory record
1340: EB08 C3 4D F1               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1341: EB0B
1342: EB0B         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1343: EB0B         ;	This function searches down the file directory for the next file name,  ;
1344: EB0B         ; type, and extent that match the FCB specified in a previous Search First  ;
1345: EB0B         ; function call. Search First and Search Next are the only BDOS functions   ;
1346: EB0B         ; that must be used together. As you can see, the Search Next function      ;
1347: EB0B         ; does not require an FCB address as an input parameter-all the necessary   ;
1348: EB0B         ; information will have been left in the BDOS on the Search First call.     ;
1349: EB0B         ; Like Search First, Search Next returns a directory code in the A register,;
1350: EB0B         ; in this case, if A = OFFH, it means that there are no more files that     ;
1351: EB0B         ; match the file control block. If A is not OFFH, it will be a value of     ;
1352: EB0B         ; 0, 1, 2, or 3, indicating the relative directory entry number.            ;
1353: EB0B         ;                                                                           ;
1354: EB0B         ;  There are two ways of using the Search First/ Next calls. Consider a     ;
1355: EB0B         ; simple file copying program that takes as input an ambiguous file name.   ;
1356: EB0B         ; You could scan the file directory, matching all of the possible file      ;
1357: EB0B         ; names, possibly displaying them on the console, and storing the names of  ;
1358: EB0B         ; the files to be copied in a table inside your program. This would have    ;
1359: EB0B         ; the advantage of enabling you to present the file names to the operator   ;
1360: EB0B         ; before any copying occurred. You could even arrange for the operator to   ;
1361: EB0B         ; select which files to copy on a file-by-file basis. One disadvantage      ;
1362: EB0B         ; would be that you could not accurately predict how many files might be    ;
1363: EB0B         ; selected. On some hard disk systems you might have to accommodate several ;
1364: EB0B         ; thousand file names.                                                      ;
1365: EB0B         ;  The alternative way of handling the problem would be to match one file   ;
1366: EB0B         ; name, copy it, then match the next file name, copy it, and so on. If you  ;
1367: EB0B         ; gave the operator the choice of selecting which files to copy, this person;
1368: EB0B         ; would have to wait at the terminal as each file was being copied, but the ;
1369: EB0B         ; program would not need to have large table areas set aside to hold file   ;
1370: EB0B         ; names. This solution to the problem is slightly more complicated, as you  ;
1371: EB0B         ; can see from the logic in Figure 5-17.                                    ;
1372: EB0B         ;  The subroutine in Figure 5-17, Get Next File (GNF), contains all of the  ;
1373: EB0B         ; necessary logic to search down a directory for both alternatives described;
1374: EB0B         ; It does require that you indicate on entry whether it should search for   ;
1375: EB0B         ; the first or next file match, by setting A to zero or some nonzero value  ;
1376: EB0B         ; respectively.                                                             ;
1377: EB0B         ;  You can see from Figure 5-17 that whenever the subroutine is called to   ;
1378: EB0B         ; get the next file, you must execute a Search First function to re-find    ;
1379: EB0B         ; the  previous file. Only then can a Search Next be issued. As with all    ;
1380: EB0B         ; functions that return a directory code in A, if this value is not OFFH, it;
1381: EB0B         ; will be the relative directory entry number in the directory record       ;
1382: EB0B         ; currently in memory. This directory record will have been read into memory;
1383: EB0B         ; at whatever address was specified at the last Set DMA Address function    ;
1384: EB0B         ; call. Notwithstanding its odd name, the DMA Address is simply the address ;
1385: EB0B         ; into which any record input from disk will be placed. If the Set DMA      ;
1386: EB0B         ; Address function has not been used to change the value, then the CP/M     ;
1387: EB0B         ; default DMA address, location 0080H, will be used to hold the directory   ;
1388: EB0B         ; record.                                                                   ;
1389: EB0B         ;  The actual code for locating the address of the particular directory     ;
1390: EB0B         ;  entry matched by the Search First/ Next functions is shown in Figure 5-17;
1391: EB0B         ;  near the label GNFC. The method involves multiplying the directory code  ;
1392: EB0B         ;  by 32 and then adding this product to the current DMA address.	        ;
1393: EB0B         ;                                                                           ;
1394: EB0B         ;                                                                           ;
1395: EB0B         ;			Function Code	:	C  = 12FH                                   ;
1396: EB0B         ;			Entry Parameters:	None , Assume previous Search First Call	;
1397: EB0B         ;			Exit Parameters :	A  = Directory Code							;
1398: EB0B         ;																			;
1399: EB0B         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1400: EB0B             vFindNext:
1401: EB0B 2A 8C F5               LD     HL,(searchAddress)   ; Get Current Dir Entry
1402: EB0E 22 C3 EA               LD     (paramDE),HL         ; Get the user's FCB
1403: EB11 CD 37 EF               CALL   ReselectDisk         ; Reselect if needed
1404: EB14 CD F7 EF               CALL   GetNextDirectoryRecord ; Go find the next directory record
1405: EB17 C3 4D F1               JP     CopyDirEntryToUserDMA ; Copy directory entry to user
1406: EB1A
1407: EB1A         ;--------------------------------Delete File - 13 (19) ---------------------;
1408: EB1A         ; This function logically deletes from the file directory files that match  ;
1409: EB1A         ; the FCB addressed by DE. It does so by replacing the first byte of each   ;
1410: EB1A         ; relevant directory entry (remember, a single file can have several        ;
1411: EB1A         ; entries, one for each extent) by the value OE5H. This flags the directory ;
1412: EB1A         ; entry as being available for use.                                         ;
1413: EB1A         ;                                                                           ;
1414: EB1A         ;  Like the previous two functions, Search First and Search Next, this      ;
1415: EB1A         ; function can take an ambiguous file name and type as part of the          ;
1416: EB1A         ; File Control Block, but unlike those functions, the logical disk select   ;
1417: EB1A         ; code cannot be a"?". This function returns a directory code in A in the   ;
1418: EB1A         ; same way as the previous file operations.                                 ;
1419: EB1A         ;                                                                           ;
1420: EB1A         ;                                                                           ;
1421: EB1A         ;			Function Code	:	C  = 13FH                                   ;
1422: EB1A         ;			Entry Parameters:	DE = Address of File Control Block			;
1423: EB1A         ;			Exit Parameters :	A  = Directory Code							;
1424: EB1A         ;																			;
1425: EB1A         ;--------------------------------Delete File - 13 (19) ---------------------;
1426: EB1A             vDeleteFile:
1427: EB1A CD 37 EF               CALL   ReselectDisk         ; Reselect if needed
1428: EB1D CD 23 EB               CALL   DeleteFile
1429: EB20 C3 5A F1               JP     DirLocationToReturnLoc ; Return directory Index to caller
1430: EB23
1431: EB23             DeleteFile:
1432: EB23 CD 61 F1               CALL   CheckWrite           ; Terminate with error if Disk R/O
1433: EB26 0E 0C                  LD     C,fcbExtIndex        ; Load the extent number field
1434: EB28 CD E2 EF               CALL   SearchForDirectoryRecord ; Look for directory entry
1435: EB2B
1436: EB2B             DeleteFileLoop:
1437: EB2B CD 7E F0               CALL   AtEndOfDirectory     ; Have we worked thru all entries
1438: EB2E C8                     RET    Z                    ;  exit if we have
1439: EB2F         ; set each non zero disk map entry to 0 in the allocation vector
1440: EB2F CD 68 F1               CALL   CheckRODirectory     ; Terminate with error if File R/O
1441: EB32 CD 87 F0               CALL   GetCurrentDirectoryRecord ; Point to Directory Entry
1442: EB35 36 E5                  LD     (HL),emptyDir        ; Mark as Empty
1443: EB37 0E 00                  LD     C,FALSE              ; Set flag for remove
1444: EB39 CD AB F0               CALL   ScanDiskMap          ; Reclaim Bisk Blocks, set to 0
1445: EB3C CD 5F F0               CALL   WriteDir             ; Update the directory
1446: EB3F CD F7 EF               CALL   GetNextDirectoryRecord ; Look for more
1447: EB42 C3 2B EB               JP     DeleteFileLoop       ; Loop
1448: EB45
1449: EB45         ;--------------------------------- Make File - 16 (22) ---------------------;
1450: EB45         ;  This function creates a new file of the specified name and type. You must;
1451: EB45         ; first ensure that no file of the same name and type already exists on the ;
1452: EB45         ; same logical disk, either by trying to open the file (if this succeeds,   ;
1453: EB45         ; the file already exists) or by unconditionally erasing the file.          ;
1454: EB45         ;  In addition to creating the file and its associated file directory entry,;
1455: EB45         ; this function also effectively opens the file so that it is ready for     ;
1456: EB45         ; records to be written to it.                                              ;
1457: EB45         ;  This function returns a normal directory code if the file creation has   ;
1458: EB45         ; completed successfully or a value of OFFH if there is insufficient        ;
1459: EB45         ; disk or directory space.                                                  ;
1460: EB45         ;  Note that this function cannot accept an ambiguous file name in the FCB. ;
1461: EB45         ;                                                                           ;
1462: EB45         ;                                                                           ;
1463: EB45         ;			Function Code	:	C  = 16FH                                   ;
1464: EB45         ;			Entry Parameters:	DE = Address of File Control Block			;
1465: EB45         ;			Exit Parameters :	A  = Directory Code							;
1466: EB45         ;																			;
1467: EB45         ;---------------------------- Make File - 16 (22) --------------------------;
1468: EB45             vMakeFile:
1469: EB45 CD B6 EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1470: EB48 CD 37 EF               CALL   ReselectDisk         ; Reselect if needed
1471: EB4B C3 90 EE               JP     MakeNewFile          ; Go Make it
1472: EB4E
1473: EB4E         ;-------------------------- Rename File - 17 (23) --------------------------;
1474: EB4E         ;  This function renames an existing file name and type to a new name and   ;
1475: EB4E         ; type. It is unusual in that it uses a single FCB to store both the old    ;
1476: EB4E         ; file name and type (in the first 16 bytes) and the new file name and type ;
1477: EB4E         ; (in the second 16 bytes).                                                 ;
1478: EB4E         ;  This function returns a normal directory code if the file rename was     ;
1479: EB4E         ; completed successfully or a value of OFFH if the old file name could not  ;
1480: EB4E         ; be found.                                                                 ;
1481: EB4E         ;                                                                           ;
1482: EB4E         ;  The Rename File function only checks that the old file name and type     ;
1483: EB4E         ; exist; it makes no check to ensure that the new name and type combination ;
1484: EB4E         ; does not already exist. Therefore, you should try to open the new file    ;
1485: EB4E         ; name and type. If you succeed, do not attempt the rename operation.       ;
1486: EB4E         ; CP/M will create more than one file of the same name and type, and you    ;
1487: EB4E         ; stand to lose the information in both files as you attempt to sort out    ;
1488: EB4E         ; the problem.                                                              ;
1489: EB4E         ;  Never use ambiguous file names in a rename operation; it produces strange;
1490: EB4E         ; effects and may result in files being irreparably damaged. This function  ;
1491: EB4E         ; will change all occurrences of the old file name to the new name.         ;
1492: EB4E         ;                                                                           ;
1493: EB4E         ;                                                                           ;
1494: EB4E         ;			Function Code	:	C  = 17FH                                   ;
1495: EB4E         ;			Entry Parameters:	DE = Address of File Control Block			;
1496: EB4E         ;			Exit Parameters :	A  = Directory Code							;
1497: EB4E         ;																			;
1498: EB4E         ;-------------------------- Rename File - 17 (23) --------------------------;
1499: EB4E             vRenameFile:
1500: EB4E CD 37 EF               CALL   ReselectDisk         ; Reselect if needed
1501: EB51 CD 57 EB               CALL   Rename
1502: EB54 C3 5A F1               JP     DirLocationToReturnLoc ; Return directory Index to caller
1503: EB57
1504: EB57             Rename:
1505: EB57 CD 61 F1               CALL   CheckWrite           ; Terminate with error if Disk R/O
1506: EB5A 0E 0C                  LD     C,fcbExtIndex        ; Match user#, Name & Type only
1507: EB5C CD E2 EF               CALL   SearchForDirectoryRecord
1508: EB5F
1509: EB5F         ; Move the old use number to the new entry (2nd half of FCB)
1510: EB5F 2A C3 EA               LD     HL,(paramDE)         ; FCB pointer
1511: EB62 7E                     LD     A,(HL)               ; First byte of Dir entry
1512: EB63 11 10 00               LD     DE,fcbDiskMapIndex   ; Use second half of FCB
1513: EB66 19                     ADD    HL,DE                ; Point at the second half of FCB
1514: EB67 77                     LD     (HL),A               ; Put into new name user position
1515: EB68
1516: EB68             RenameLoop:
1517: EB68 CD 7E F0               CALL   AtEndOfDirectory     ; have we checked the whole dir
1518: EB6B C8                     RET    Z                    ;  exit if yes
1519: EB6C         ; process this match
1520: EB6C CD 68 F1               CALL   CheckRODirectory     ; Terminate with error if File R/O
1521: EB6F 0E 10                  LD     C,fcbDiskMapIndex    ; Set starting position
1522: EB71 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1523: EB73 CD 79 F1               CALL   CopyDir              ; copy from FCB to dir entry
1524: EB76         ; element renamed, move to next
1525: EB76 CD F7 EF               CALL   GetNextDirectoryRecord ; Look for more dir entries
1526: EB79 C3 68 EB               JP     RenameLoop           ; Loop
1527: EB7C
1528: EB7C
1529: EB7C
1530: EB7C
1531: EB7C         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1532: EB7C         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1533: EB7C         ; This function returns a bit map, called the login vector, in register pair ;
1534: EB7C         ; HL, indicating which logical disk drives have been selected since the last ;
1535: EB7C         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1536: EB7C         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1537: EB7C         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1538: EB7C         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1539: EB7C         ;  Logical disks can be selected programmatically through any file operation ;
1540: EB7C         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1541: EB7C         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1542: EB7C         ; where "X" is equal to A, B, ... , P.                                       ;
1543: EB7C         ;                                                                            ;
1544: EB7C         ;			Function Code	:	C = 018H                                     ;
1545: EB7C         ;			Entry Parameters:	None										 ;
1546: EB7C         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1547: EB7C         ;																			 ;
1548: EB7C         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1549: EB7C             vGetLoginVector:
1550: EB7C 2A 63 F5               LD     HL,(loggedDisks)
1551: EB7F 22 C5 EA               LD     (exitParameterWord),HL
1552: EB82 C9                     RET
1553: EB83         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1554: EB83         ;   This function returns the current default disk set by the last Select    ;
1555: EB83         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1556: EB83         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1557: EB83         ;                                                                            ;
1558: EB83         ;  This function returns the current default disk in coded form.             ;
1559: EB83         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1560: EB83         ; If you need to convert this to the corresponding ASCII character, simply   ;
1561: EB83         ; add 41H to register A. Use this function when you convert a file name and  ;
1562: EB83         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1563: EB83         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1564: EB83         ; You must therefore use this function to determine the logical disk letter  ;
1565: EB83         ; for the default drive.                                                     ;
1566: EB83         ;                                                                            ;
1567: EB83         ;			Function Code	:	C = 019H                                     ;
1568: EB83         ;			Entry Parameters:	None										 ;
1569: EB83         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1570: EB83         ;																			 ;
1571: EB83         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1572: EB83             vGetCurrentDisk:
1573: EB83 3A 5F F5               LD     A,(currentDisk)
1574: EB86 32 C5 EA               LD     (exitParameterByte),A
1575: EB89 C9                     RET
1576: EB8A         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1577: EB8A         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1578: EB8A         ; value. The name is an historic relic dating back to the Intel Development  ;
1579: EB8A         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1580: EB8A         ; its hardware, could read data from a diskette directly into memory or      ;
1581: EB8A         ; write data to a diskette directly from memory. The name DMA address now    ;
1582: EB8A         ; applies to the address of the buffer to and from which data is             ;
1583: EB8A         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1584: EB8A         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1585: EB8A         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1586: EB8A         ; value of 0080H.                                                            ;
1587: EB8A         ;                                                                            ;
1588: EB8A         ;			Function Code	:	C = 0A9H                                     ;
1589: EB8A         ;			Entry Parameters:	DE = DMA Address							 ;
1590: EB8A         ;			Exit Parameters :	None										 ;
1591: EB8A         ;																			 ;
1592: EB8A         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1593: EB8A             vSetDMA:
1594: EB8A 2A C3 EA               LD     HL,(paramDE)
1595: EB8D 22 65 F5               LD     (initDAMAddress),HL
1596: EB90 C3 FE EE               JP     SetDataDMA
1597: EB93
1598: EB93         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1599: EB93         ;  This function returns the base, or starting, address of the allocation    ;
1600: EB93         ; vector for the currently selected logical disk. This information,          ;
1601: EB93         ; indicating which parts of the disk are assigned, is used by utility        ;
1602: EB93         ; programs and the BDOS itself to determine how much unused space is on the  ;
1603: EB93         ; logical disk, to locate an unused allocation block in order to extend      ;
1604: EB93         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1605: EB93         ;                                                                            ;
1606: EB93         ;			Function Code	:	C = 01BH                                     ;
1607: EB93         ;			Entry Parameters:	None										 ;
1608: EB93         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1609: EB93         ;																			 ;
1610: EB93         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1611: EB93             vGetAllocAddr:
1612: EB93 2A 73 F5               LD     HL,(caAllocVector)
1613: EB96 22 C5 EA               LD     (exitParameterWord),HL
1614: EB99 C9                     RET
1615: EB9A
1616: EB9A         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1617: EB9A         ;  This function logically sets the currently selected disk to a Read-Only   ;
1618: EB9A         ; state. Any attempts to execute a Write Sequential or Write Random function ;
1619: EB9A         ; to the selected disk will be intercepted by the BDOS, and the following    ;
1620: EB9A         ; message will appear on the console:                                        ;
1621: EB9A         ;	BDOS Err on X: R/O                                                       ;
1622: EB9A         ;	where X: is the selected disk.                                           ;
1623: EB9A         ;                                                                            ;
1624: EB9A         ;  Once you have requested Read-Only status for the currently selected       ;
1625: EB9A         ; logical disk, this status will persist even if you proceed to select       ;
1626: EB9A         ; other logical disks. In fact, it will remain in force until the next warm  ;
1627: EB9A         ; boot or Reset Disk System function call.                                   ;
1628: EB9A         ;  Digital Research documentation refers to this function code as Disk Write ;
1629: EB9A         ; Protect. The Read-Only description is used here because it corresponds     ;
1630: EB9A         ; to the error message produced if your program attempts to write on         ;
1631: EB9A         ; the disk.                                                                  ;
1632: EB9A         ;                                                                            ;
1633: EB9A         ;			Function Code	:	C = 01CH                                     ;
1634: EB9A         ;			Entry Parameters:	None										 ;
1635: EB9A         ;			Exit Parameters :	None										 ;
1636: EB9A         ;																			 ;
1637: EB9A         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1638: EB9A         ;;write protect current disk
1639: EB9A             vWriteProtectDisk:
1640: EB9A C3 14 EF               JP     SetDiskReadOnly
1641: EB9D
1642: EB9D         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1643: EB9D         ;  This function returns a bit map in registers H and L showing which logical;
1644: EB9D         ; disks in the system have been set to Read-Only status, either by the       ;
1645: EB9D         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1646: EB9D         ; BDOS itself, because it detected that a diskette had been changed.         ;
1647: EB9D         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1648: EB9D         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1649: EB9D         ; the specific logical disk is set to I if the disk has been set to          ;
1650: EB9D         ; Read-Only status.                                                          ;
1651: EB9D         ;                                                                            ;
1652: EB9D         ;			Function Code	:	C = 01DH                                     ;
1653: EB9D         ;			Entry Parameters:	None										 ;
1654: EB9D         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1655: EB9D         ;																			 ;
1656: EB9D         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1657: EB9D             vGetReadOnlyMap:
1658: EB9D 2A 61 F5               LD     HL,(readOnlyVector)
1659: EBA0 22 C5 EA               LD     (exitParameterWord),HL
1660: EBA3 C9                     RET
1661: EBA4
1662: EBA4         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1663: EBA4         ;  This function returns the address of the disk parameter block (DPB) for   ;
1664: EBA4         ; the last selected logical disk. The DPB describes the physical             ;
1665: EBA4         ; characteristics of a specific logical disk-information mainly of interest  ;
1666: EBA4         ; for system utility programs.                                               ;
1667: EBA4         ;                                                                            ;
1668: EBA4         ;			Function Code	:	C = 1FH                                      ;
1669: EBA4         ;			Entry Parameters:	None										 ;
1670: EBA4         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1671: EBA4         ;																			 ;
1672: EBA4         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1673: EBA4             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1674: EBA4 2A 6F F5               LD     HL,(caDiskParamBlock)
1675: EBA7 22 C5 EA               LD     (exitParameterWord),HL
1676: EBAA C9                     RET
1677: EBAB
1678: EBAB         ;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
1679: EBAB         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1680: EBAB         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1681: EBAB         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1682: EBAB
1683: EBAB         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1684: EBAB         ;  This function resets individual disk drives. It is a more precise version ;
1685: EBAB         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1686: EBAB         ; specific logical; disks rather than all of them.                           ;
1687: EBAB         ;  The bit map in DE shows which disks are to be reset. The least significant;
1688: EBAB         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1689: EBAB         ; The bits set to I indicate the disks to be reset.                          ;
1690: EBAB         ;  Note that this function returns a zero value in A in order to maintain    ;
1691: EBAB         ; compatibility with MP/ M.                                                  ;
1692: EBAB         ;                                                                            ;
1693: EBAB         ;			Function Code	:	C = 25H                                      ;
1694: EBAB         ;			Entry Parameters:	DE = Logical Drive Bit Vector					 ;
1695: EBAB         ;			Exit Parameters :	A = 00H										 ;
1696: EBAB         ;																			 ;
1697: EBAB         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1698: EBAB         ;Reset Drive
1699: EBAB         ;IN  - (DE) Drive Vector
1700: EBAB         ;OUT - (A) 00
1701: EBAB             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1702: EBAB         ; Not Yet Implemented   **************
1703: EBAB C9                     RET
1704: EBAC         ;*****************************************************************
1705: EBAC
1706: EBAC         ;-----------------------------------------------------------------
1707: EBAC
1708: EBAC         ;*****************************************************************
1709: EBAC         ;random disk read
1710: EBAC         ;IN  - (DE) FCB address
1711: EBAC         ;OUT - (A) 01 = Reading unwritten data
1712: EBAC         ;	 02 = N/U
1713: EBAC         ;	 03 = Cannot close current extent
1714: EBAC         ;	 04 = Seek to unwriten Extent
1715: EBAC         ;	 05 = N/U
1716: EBAC         ;	 06 = Seek past Physical end of Disk
1717: EBAC             vReadRandom:                      ; func33 (33 - 21) Read Random record
1718: EBAC CD 37 EF               CALL   ReselectDisk
1719: EBAF C3 C2 EB               JP     RandomDiskRead       ; to perform the disk read
1720: EBB2         ;*****************************************************************
1721: EBB2         ;write random record
1722: EBB2         ;IN  - (DE) FCB address
1723: EBB2         ;OUT - (A) 01 = Reading unwritten data
1724: EBB2         ;	 02 = N/U
1725: EBB2         ;	 03 = Cannot close current extent
1726: EBB2         ;	 04 = Seek to unwriten Extent
1727: EBB2         ;	 05 = Cannot create new Extent because of directory overflow
1728: EBB2         ;	 06 = Seek past Physical end of Disk
1729: EBB2             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1730: EBB2 CD 37 EF               CALL   ReselectDisk
1731: EBB5 C3 CB EB               JP     RandomDiskWrite      ; to perform the disk write
1732: EBB8         ;ret ;jmp goback
1733: EBB8         ;*****************************************************************
1734: EBB8         ;return file size (0-65536)
1735: EBB8         ;IN  - (DE) FCB address
1736: EBB8             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1737: EBB8 CD 37 EF               CALL   ReselectDisk
1738: EBBB C3 78 EC               JP     GetFileSize
1739: EBBE         ;*****************************************************************
1740: EBBE         ;set random record
1741: EBBE         ;IN  - (DE) FCB address
1742: EBBE         ;OUT - Random Record Field is set
1743: EBBE             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1744: EBBE C3 65 EC               JP     SetRandomRecord
1745: EBC1         ;? ;*****************************************************************
1746: EBC1         ;? ;Reset Drive
1747: EBC1         ;? ;IN  - (DE) Drive Vector
1748: EBC1         ;? ;OUT - (A) 00
1749: EBC1         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
1750: EBC1         ;? ; Not Yet Implemented   **************
1751: EBC1         ;?	RET
1752: EBC1         ;*****************************************************************
1753: EBC1         ;*****************************************************************
1754: EBC1         ;Write Random With Zero Fill
1755: EBC1         ;IN  - (DE) FCB address
1756: EBC1         ;OUT - (A) Return Code		see Function 34
1757: EBC1             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1758: EBC1         ; Not Yet Implemented   **************
1759: EBC1 C9                     RET
1760: EBC2         ;*****************************************************************
1761: EBC2         ;******************< Random I/O Stuff ****************************
1762: EBC2         ;*****************************************************************
1763: EBC2         ;random disk read
1764: EBC2             RandomDiskRead:                      ; randiskread
1765: EBC2 0E FF                  LD     C,TRUE               ; marked as read operation
1766: EBC4 CD D4 EB               CALL   RandomSeek
1767: EBC7 CC AC F2               CALL   Z,DiskRead           ; if seek successful
1768: EBCA C9                     RET
1769: EBCB         ;*****************************************************************
1770: EBCB         ;random disk write
1771: EBCB             RandomDiskWrite:                      ; randiskwrite
1772: EBCB 0E 00                  LD     C,FALSE              ; marked as read operation
1773: EBCD CD D4 EB               CALL   RandomSeek
1774: EBD0 CC EF F2               CALL   Z,DiskWrite          ; if seek successful
1775: EBD3 C9                     RET
1776: EBD4         ;*****************************************************************
1777: EBD4         ;*****************************************************************
1778: EBD4         ;random access seek operation, C=0ffh if read mode
1779: EBD4         ;fcb is assumed to address an active file control block
1780: EBD4         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1781: EBD4             RandomSeek:
1782: EBD4 AF                     XOR    A
1783: EBD5 32 89 F5               LD     (seqReadFlag),A      ; marked as random access operation
1784: EBD8 C5                     PUSH   BC                   ; save r/w flag
1785: EBD9 2A C3 EA               LD     HL,(paramDE)
1786: EBDC EB                     EX     DE,HL                ; DE will hold base of fcb
1787: EBDD 21 21 00               LD     HL,RANDOM_REC_FIELD
1788: EBE0 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1789: EBE1 7E                     LD     A,(HL)
1790: EBE2 E6 7F                  AND    7FH
1791: EBE4 F5                     PUSH   AF                   ; record number
1792: EBE5 7E                     LD     A,(HL)
1793: EBE6 17                     RLA                         ; cy=lsb of extent#
1794: EBE7 23                     INC    HL
1795: EBE8 7E                     LD     A,(HL)
1796: EBE9 17                     RLA
1797: EBEA E6 1F                  AND    11111B               ; A=ext#
1798: EBEC 4F                     LD     C,A                  ; C holds extent number, record stacked
1799: EBED 7E                     LD     A,(HL)
1800: EBEE 1F                     RRA
1801: EBEF 1F                     RRA
1802: EBF0 1F                     RRA
1803: EBF1 1F                     RRA
1804: EBF2 E6 0F                  AND    1111B                ; mod#
1805: EBF4 47                     LD     B,A                  ; B holds module#, C holds ext#
1806: EBF5 F1                     POP    AF                   ; recall sought record #
1807: EBF6         ;check to insure that high byte of ran rec = 00
1808: EBF6 23                     INC    HL
1809: EBF7 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1810: EBF8 2C                     INC    L
1811: EBF9 2D                     DEC    L
1812: EBFA 2E 06                  LD     L,06                 ; zero flag, l=6
1813: EBFC         ; produce error 6, seek past physical eod
1814: EBFC C2 5D EC               JP     NZ,RandomSeekError
1815: EBFF         ; otherwise, high byte = 0, A = sought record
1816: EBFF 21 20 00               LD     HL,NEXT_RECORD
1817: EC02 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1818: EC03 77                     LD     (HL),A               ; sought rec# stored away
1819: EC04         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1820: EC04         ; the r/w flag is still stacked.  compare fcb values
1821: EC04 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1822: EC07 19                     ADD    HL,DE
1823: EC08 79                     LD     A,C                  ; A=seek ext#
1824: EC09 96                     SUB    M
1825: EC0A C2 18 EC               JP     NZ,RandomSeekClose   ; tests for = extents
1826: EC0D         ; extents match, check mod#
1827: EC0D 21 0E 00               LD     HL,fcbS2Index
1828: EC10 19                     ADD    HL,DE
1829: EC11 78                     LD     A,B                  ; B=seek mod#
1830: EC12         ; could be overflow at eof, producing module#
1831: EC12         ; of 90H or 10H, so compare all but fwf
1832: EC12 96                     SUB    M
1833: EC13 E6 7F                  AND    7FH
1834: EC15 CA 50 EC               JP     Z,RandomSeekExit     ; same?
1835: EC18             RandomSeekClose:
1836: EC18 C5                     PUSH   BC
1837: EC19 D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1838: EC1A CD 10 EE               CALL   CloseDirEntry        ; current extent closed
1839: EC1D D1                     POP    DE
1840: EC1E C1                     POP    BC                   ; recall parameters and fill
1841: EC1F 2E 03                  LD     L,03                 ; cannot close error #3
1842: EC21 3A C5 EA               LD     A,(exitParameterByte)
1843: EC24 3C                     INC    A
1844: EC25 CA 56 EC               JP     Z,RandomSeekErrorBadSeek
1845: EC28 21 0C 00               LD     HL,fcbExtIndex
1846: EC2B 19                     ADD    HL,DE
1847: EC2C 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1848: EC2D 21 0E 00               LD     HL,fcbS2Index
1849: EC30 19                     ADD    HL,DE
1850: EC31 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1851: EC32 CD CD ED               CALL   OpenFile             ; is the file present?
1852: EC35 3A C5 EA               LD     A,(exitParameterByte)
1853: EC38 3C                     INC    A
1854: EC39 C2 50 EC               JP     NZ,RandomSeekExit    ; open successful?
1855: EC3C         ; cannot open the file, read mode?
1856: EC3C C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1857: EC3D C5                     PUSH   BC                   ; everyone expects this item stacked
1858: EC3E 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1859: EC40 0C                     INC    C                    ; becomes 00 if read operation
1860: EC41 CA 56 EC               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1861: EC44 CD 90 EE               CALL   MakeNewFile          ; write operation, make new extent
1862: EC47 2E 05                  LD     L,05                 ; cannot create new extent #5
1863: EC49 3A C5 EA               LD     A,(exitParameterByte)
1864: EC4C 3C                     INC    A
1865: EC4D CA 56 EC               JP     Z,RandomSeekErrorBadSeek ; no dir space
1866: EC50         ; file make operation successful
1867: EC50             RandomSeekExit:                      ; seekok:
1868: EC50 C1                     POP    BC                   ; discard r/w flag
1869: EC51 AF                     XOR    A
1870: EC52 32 C5 EA               LD     (exitParameterByte),A
1871: EC55 C9                     RET                         ; with zero set
1872: EC56
1873: EC56             RandomSeekErrorBadSeek:
1874: EC56         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1875: EC56         ; appears as overflow with file write flag set
1876: EC56 E5                     PUSH   HL                   ; save error flag
1877: EC57 CD BC EF               CALL   GetExtentNumberMSB   ; HL = .fcbS2Index
1878: EC5A 36 C0                  LD     (HL),11000000B
1879: EC5C E1                     POP    HL                   ; and drop through
1880: EC5D             RandomSeekError:                      ; seekerr:
1881: EC5D C1                     POP    BC                   ; discard r/w flag
1882: EC5E 7D                     LD     A,L
1883: EC5F 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1884: EC62         ; SetFileWriteFlag returns non-zero accumulator for err
1885: EC62 C3 C5 EF               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1886: EC65         ;ret
1887: EC65         ;
1888: EC65         ;*****************************************************************
1889: EC65             SetRandomRecord:                      ; setrandom
1890: EC65 2A C3 EA               LD     HL,(paramDE)
1891: EC68 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1892: EC6B CD B4 EC               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1893: EC6E 21 21 00               LD     HL,RANDOM_REC_FIELD
1894: EC71 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1895: EC72 71                     LD     (HL),C
1896: EC73 23                     INC    HL
1897: EC74 70                     LD     (HL),B
1898: EC75 23                     INC    HL
1899: EC76 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1900: EC77 C9                     RET
1901: EC78         ;*****************************************************************
1902: EC78         ;compute logical file size for current fcb
1903: EC78             GetFileSize:                      ; getfilesize
1904: EC78 0E 0C                  LD     C,fcbExtIndex
1905: EC7A CD E2 EF               CALL   SearchForDirectoryRecord
1906: EC7D         ; zero the receiving Ramdom record field
1907: EC7D 2A C3 EA               LD     HL,(paramDE)
1908: EC80 11 21 00               LD     DE,RANDOM_REC_FIELD
1909: EC83 19                     ADD    HL,DE
1910: EC84 E5                     PUSH   HL                   ; save position
1911: EC85 72                     LD     (HL),D
1912: EC86 23                     INC    HL
1913: EC87 72                     LD     (HL),D
1914: EC88 23                     INC    HL
1915: EC89 72                     LD     (HL),D               ; =00 00 00
1916: EC8A             GetFileSize1:                      ; getsize:
1917: EC8A CD 7E F0               CALL   AtEndOfDirectory
1918: EC8D CA B2 EC               JP     Z,GetFileSizeExit
1919: EC90         ; current fcb addressed by dptr
1920: EC90 CD 87 F0               CALL   GetCurrentDirectoryRecord
1921: EC93 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1922: EC96 CD B4 EC               CALL   GetRandomRecordPosition
1923: EC99         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1924: EC99 E1                     POP    HL
1925: EC9A E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1926: EC9B 5F                     LD     E,A                  ; save cy
1927: EC9C 79                     LD     A,C
1928: EC9D 96                     SUB    M
1929: EC9E 23                     INC    HL                   ; ls byte
1930: EC9F 78                     LD     A,B
1931: ECA0 9E                     SBC    A,(HL)
1932: ECA1 23                     INC    HL                   ; middle byte
1933: ECA2 7B                     LD     A,E
1934: ECA3 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1935: ECA4 DA AC EC               JP     C,GetFileSize2       ; for another try
1936: ECA7         ; fcb is less or equal, fill from directory
1937: ECA7 73                     LD     (HL),E
1938: ECA8 2B                     DEC    HL
1939: ECA9 70                     LD     (HL),B
1940: ECAA 2B                     DEC    HL
1941: ECAB 71                     LD     (HL),C
1942: ECAC             GetFileSize2:                      ; getnextsize:
1943: ECAC CD F7 EF               CALL   GetNextDirectoryRecord
1944: ECAF C3 8A EC               JP     GetFileSize1
1945: ECB2             GetFileSizeExit:                      ; setsize:
1946: ECB2 E1                     POP    HL                   ; discard .fcb(random record field)
1947: ECB3 C9                     RET
1948: ECB4         ;-----------------------------------------------------------------
1949: ECB4         ;compute random record position
1950: ECB4             GetRandomRecordPosition:                      ; compute$rr
1951: ECB4 EB                     EX     DE,HL
1952: ECB5 19                     ADD    HL,DE
1953: ECB6         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1954: ECB6 4E                     LD     C,(HL)
1955: ECB7 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1956: ECB9 21 0C 00               LD     HL,fcbExtIndex
1957: ECBC 19                     ADD    HL,DE
1958: ECBD 7E                     LD     A,(HL)
1959: ECBE 0F                     RRCA
1960: ECBF E6 80                  AND    80H                  ; A=e000 0000
1961: ECC1 81                     ADD    A,C
1962: ECC2 4F                     LD     C,A
1963: ECC3 3E 00                  LD     A,0
1964: ECC5 88                     ADC    A,B
1965: ECC6 47                     LD     B,A
1966: ECC7         ; BC = 0000 000? errrr rrrr
1967: ECC7 7E                     LD     A,(HL)
1968: ECC8 0F                     RRCA
1969: ECC9 E6 0F                  AND    LO_NIBBLE_MASK
1970: ECCB 80                     ADD    A,B
1971: ECCC 47                     LD     B,A
1972: ECCD         ; BC = 000? eeee errrr rrrr
1973: ECCD 21 0E 00               LD     HL,fcbS2Index
1974: ECD0 19                     ADD    HL,DE
1975: ECD1 7E                     LD     A,(HL)               ; A=XXX? mmmm
1976: ECD2 87                     ADD    A,A
1977: ECD3 87                     ADD    A,A
1978: ECD4 87                     ADD    A,A
1979: ECD5 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1980: ECD6 F5                     PUSH   AF
1981: ECD7 80                     ADD    A,B
1982: ECD8 47                     LD     B,A
1983: ECD9         ; cy=?, BC = mmmm eeee errr rrrr
1984: ECD9 F5                     PUSH   AF                   ; possible second carry
1985: ECDA E1                     POP    HL                   ; cy = lsb of L
1986: ECDB 7D                     LD     A,L                  ; cy = lsb of A
1987: ECDC E1                     POP    HL                   ; cy = lsb of L
1988: ECDD B5                     OR     L                    ; cy/cy = lsb of A
1989: ECDE E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1990: ECE0 C9                     RET
1991: ECE1         ;-----------------------------------------------------------------
1992: ECE1
1993: ECE1
1994: ECE1
1995: ECE1         ;*****************************************************************
1996: ECE1         ;********************** Disk  I/O ********************************
1997: ECE1         ;*****************************************************************
1998: ECE1         ;-----------------------------------------------------------------
1999: ECE1         ;;set file Attributes
2000: ECE1             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
2001: ECE1 CD 37 EF               CALL   ReselectDisk
2002: ECE4 CD 83 F2               CALL   SetAttributes
2003: ECE7 C3 5A F1               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
2004: ECEA         ;-----------------------------------------------------------------
2005: ECEA         ;--------------------------- Select  Drive ---------------------------------;
2006: ECEA         ; Establish the disk found in (paramE) as the current disk drive            ;
2007: ECEA             SelectCurrent:                      ;
2008: ECEA 3A C2 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
2009: ECED 21 5F F5               LD     HL,currentDisk       ; Get the current disk              ;
2010: ECF0 BE                     CP     M                    ; Are the the same ?                ;
2011: ECF1 C8                     RET    Z                    ; Exit if yes, nothing to do        ;
2012: ECF2 77                     LD     (HL),A               ;  else update curretDisk and       ;
2013: ECF3 C3 F6 EC               JP     Select               ;  select it                        ;
2014: ECF6         ;--------------------------- Select  Drive ---------------------------------;
2015: ECF6         ;--------------------------- Select Login Drive ----------------------------;
2016: ECF6         ; select Login Drive                                                       ;
2017: ECF6             Select:                         ;
2018: ECF6 CD 17 ED               CALL   SelectDisk           ; Select the Disk                   ;
2019: ECF9 CC CE F4               CALL   Z,errSelect          ;
2020: ECFC 21 5F F5               LD     HL,currentDisk       ;
2021: ECFF 46                     LD     B,(HL)               ; Get Current Disk                  ;
2022: ED00 2A 63 F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
2023: ED03 CD A0 F4               CALL   IsBitSet             ;
2024: ED06 C0                     RET    NZ                   ; Exit if already logged in         ;
2025: ED07         ;                                                                           ;
2026: ED07 21 5F F5               LD     HL,currentDisk       ;
2027: ED0A 46                     LD     B,(HL)               ; Get Current Disk                  ;
2028: ED0B 2A 63 F5               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
2029: ED0E CD B0 F4               CALL   SetVectorBit         ;
2030: ED11 22 63 F5               LD     (loggedDisks),HL     ; Update the Vector                 ;
2031: ED14         ;
2032: ED14 C3 5D ED               JP     InitDisk             ;
2033: ED17         ;--------------------------- Select Login Drive ----------------------------;
2034: ED17         ;--------------------------- Select Disk ------------------------------------;
2035: ED17         ;*****************************************************************          ;
2036: ED17         ; select the disk drive given by currentDisk, and fill the base addresses   ;
2037: ED17         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
2038: ED17             SelectDisk:                      ;
2039: ED17 3A 5F F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
2040: ED1A 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
2041: ED1B CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
2042: ED1E 7C                     LD     A,H                  ; Return Pointer to                  ;
2043: ED1F B5                     OR     L                    ;  Disk Parameter Header             ;
2044: ED20 C8                     RET    Z                    ; exit if error, with HL = 0000      ;
2045: ED21         ;
2046: ED21 5E                     LD     E,(HL)               ;
2047: ED22 23                     INC    HL                   ;
2048: ED23 56                     LD     D,(HL)               ; Skew Table in DE                   ;
2049: ED24 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
2050: ED25 ED 53 84 F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
2051: ED29         ;
2052: ED29 22 67 F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
2053: ED2C 23                     INC    HL                   ;
2054: ED2D 23                     INC    HL                   ; HL = Last Track #                  ;
2055: ED2E 22 69 F5               LD     (caTrack),HL         ; Move to Current Track #            ;
2056: ED31 23                     INC    HL                   ;
2057: ED32 23                     INC    HL                   ; HL = Last Sector #                 ;
2058: ED33 22 6B F5               LD     (caSector),HL        ; Move to Current Sector #           ;
2059: ED36 23                     INC    HL                   ;
2060: ED37 23                     INC    HL                   ;
2061: ED38 11 6D F5               LD     DE,caDirectoryDMA    ;
2062: ED3B 01 08 00               LD     BC,caListSize        ;
2063: ED3E ED B0                  LDIR                        ;
2064: ED40         ;
2065: ED40         ; finish filling in address list                                             ;
2066: ED40 2A 6F F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
2067: ED43 11 75 F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
2068: ED46 01 0F 00               LD     BC,dpbSize           ;
2069: ED49 ED B0                  LDIR                        ; Move DPB to current                ;
2070: ED4B         ;
2071: ED4B         ; Determine if Byte or Word Allocation Table	                             ;
2072: ED4B 2A 7A F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
2073: ED4E 7C                     LD     A,H                  ; If  its 00 then < 255              ;
2074: ED4F 21 8E F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
2075: ED52 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
2076: ED54 B7                     OR     A                    ;  is the assumption confirmed ?     ;
2077: ED55 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
2078: ED57 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
2079: ED59         ;
2080: ED59         ; Set Sign, reset Carry and Zero to indicate success                         ;
2081: ED59             SelectDisk1:                      ;
2082: ED59 3E FF                  LD     A,TRUE               ;
2083: ED5B B7                     OR     A                    ;
2084: ED5C C9                     RET                         ;
2085: ED5D         ;--------------------------- Select Disk ------------------------------------;
2086: ED5D         ;--------------------------- Initialize Disk --------------------------------;
2087: ED5D             InitDisk:                       ;
2088: ED5D 2A 7A F5               LD     HL,(dpbDSM)          ; Maximum allocation value           ;
2089: ED60 CD 9D F1               CALL   DivideHLby8          ; Length of Map                      ;
2090: ED63 E5                     PUSH   HL                   ; Save Length                        ;
2091: ED64 E5                     PUSH   HL                   ; Save for end of MAP                ;
2092: ED65 C1                     POP    BC                   ; BC = dpbDSM/8                      ;
2093: ED66         ; Clear the Allocation Vector	                                             ;
2094: ED66 2A 73 F5               LD     HL,(caAllocVector)   ; Allocation vector Start            ;
2095: ED69 36 00                  LD     (HL),0               ; Clear location                     ;
2096: ED6B ED 5B 73 F5               LD     DE,(caAllocVector)   ;
2097: ED6F 13                     INC    DE                   ; Allocation vector Start + 1        ;
2098: ED70 ED B0                  LDIR                        ; Cascade 00 thru Map                ;
2099: ED72         ; Force bits at End of Map                                                   ;
2100: ED72 EB                     EX     DE,HL                ; Put last Map byte into DE          ;
2101: ED73 E1                     POP    HL                   ;
2102: ED74 23                     INC    HL                   ;
2103: ED75 CD A7 F1               CALL   MultiplyHLby8        ; Blocks if all bits used            ;
2104: ED78 ED 4B 7A F5               LD     BC,(dpbDSM)          ; Actual block max                   ;
2105: ED7C 03                     INC    BC                   ; Now has size of the Map            ;
2106: ED7D AF                     XOR    A                    ; Clear CY                           ;
2107: ED7E ED 42                  SBC    HL,BC                ; Extra unused bits                  ;
2108: ED80 BD                     CP     L                    ;  are there any                     ;
2109: ED81 28 07                  JR     Z,Mark4Directory     ;
2110: ED83 45                     LD     B,L                  ; Number of bits to set              ;
2111: ED84 EB                     EX     DE,HL                ; Put last Map byte into HL          ;
2112: ED85             SetBitLoop:                      ;
2113: ED85 37                     SCF                         ;
2114: ED86 CB 16                  RL     (HL)                 ; Set LSB                            ;
2115: ED88 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                 ;
2116: ED8A         ;
2117: ED8A             Mark4Directory:                      ;
2118: ED8A         ; Mark the reserved space for the directory                                  ;
2119: ED8A 2A 7E F5               LD     HL,(dpbDABM)         ; Directory block reserved bits      ;
2120: ED8D EB                     EX     DE,HL                ;
2121: ED8E 2A 73 F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector      ;
2122: ED91 73                     LD     (HL),E               ;
2123: ED92 23                     INC    HL                   ;
2124: ED93 72                     LD     (HL),D               ; Put reserved blocks in Vector      ;
2125: ED94         ; end of Map                                                                 ;
2126: ED94         ; Home disk, and set current track and sector to 00                          ;
2127: ED94 CD E4 EE               CALL   Home                 ;
2128: ED97 2A 67 F5               LD     HL,(caDirMaxValue)   ;
2129: ED9A 36 03                  LD     (HL),3               ;
2130: ED9C 23                     INC    HL                   ;
2131: ED9D 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003       ;
2132: ED9F CD 77 F0               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)           ;
2133: EDA2         ;
2134: EDA2             InitDisk1:                      ;
2135: EDA2         ; Process the directory                                                      ;
2136: EDA2 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	     ;
2137: EDA4 CD C8 F1               CALL   ReadDirectory        ; Get the directory Record           ;
2138: EDA7 CD 7E F0               CALL   AtEndOfDirectory     ; Are we Done ?                      ;
2139: EDAA C8                     RET    Z                    ;  Exit if Yes                       ;
2140: EDAB         ; Not end of directory, valid entry?                                         ;
2141: EDAB CD 87 F0               CALL   GetCurrentDirectoryRecord ; Calculate location of the element  ;
2142: EDAE 3E E5                  LD     A,emptyDir           ;
2143: EDB0 BE                     CP     M                    ; Is it an Empty Dir Entry           ;
2144: EDB1 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                 ;
2145: EDB3         ; Not emptyDir, user code the same?                                          ;
2146: EDB3 3A 5E F5               LD     A,(currentUserNumber) ;
2147: EDB6 BE                     CP     M                    ;
2148: EDB7 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users   ;
2149: EDB9         ; Same user, check for '$' submit                                            ;
2150: EDB9 23                     INC    HL                   ;
2151: EDBA 7E                     LD     A,(HL)               ;
2152: EDBB D6 24                  SUB    DOLLAR               ; Is first Char a $                  ;
2153: EDBD 20 04                  JR     NZ,InitDisk2         ;
2154: EDBF         ; dollar file found, mark in exitParameterByte                               ;
2155: EDBF 3D                     DEC    A                    ; Set A to FFH                       ;
2156: EDC0 32 C5 EA               LD     (exitParameterByte),A ; Return it the exit parameter       ;
2157: EDC3             InitDisk2:                      ;
2158: EDC3         ; now scan the disk map for allocated blocks                                 ;
2159: EDC3 0E FF                  LD     C,TRUE               ; set to allocated                   ;
2160: EDC5 CD AB F0               CALL   ScanDiskMap          ;
2161: EDC8 CD 95 F0               CALL   SetDirectoryEntry    ; Mark directory entry               ;
2162: EDCB 18 D5                  JR     InitDisk1            ; Loop for another entry             ;
2163: EDCD         ;--------------------------- Initialize Disk --------------------------------;
2164: EDCD         ;----------------------------- Open File -----------------------------------;
2165: EDCD         ;search for the directory entry matching FCB at paramDE						;
2166: EDCD             OpenFile:                       ;
2167: EDCD 0E 0F                  LD     C,nameLength         ;
2168: EDCF CD E2 EF               CALL   SearchForDirectoryRecord ;
2169: EDD2 CD 7E F0               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
2170: EDD5 C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
2171: EDD6         ;
2172: EDD6             CopyDirRecordToFCB:                      ;
2173: EDD6 CD 88 EF               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
2174: EDD9 7E                     LD     A,(HL)               ; Get the EXT                      	;
2175: EDDA F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
2176: EDDB E5                     PUSH   HL                   ;  also save FCB's pointer         	;
2177: EDDC CD 87 F0               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
2178: EDDF E5                     PUSH   HL                   ; Save Directory Record address    	;
2179: EDE0         ;
2180: EDE0 ED 5B C3 EA               LD     DE,(paramDE)         ;
2181: EDE4 01 20 00               LD     BC,fcbLength         ;
2182: EDE7 ED B0                  LDIR                        ; Move dir record to FCB           	;
2183: EDE9         ;
2184: EDE9         ; note that entire fcb is copied, including indicators                    	;
2185: EDE9 CD C5 EF               CALL   SetFileWriteFlag     ; Set clean file flag				;
2186: EDEC D1                     POP    DE                   ; Get Directory Record address     	;
2187: EDED 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
2188: EDF0 19                     ADD    HL,DE                ; Directory's EXT address          	;
2189: EDF1 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
2190: EDF2 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
2191: EDF5 19                     ADD    HL,DE                ; Directory's RC address           	;
2192: EDF6 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
2193: EDF7 E1                     POP    HL                   ; Get FCB's Extent Address         	;
2194: EDF8 F1                     POP    AF                   ; Get FCB's Extent Value           	;
2195: EDF9 77                     LD     (HL),A               ; Restore Extent Value             	;
2196: EDFA         ; if user ext < dir ext then user := 128 records                           	;
2197: EDFA         ; if user ext = dir ext then user := dir records                           	;
2198: EDFA         ; if user ext > dir ext then user := 0 records                             	;
2199: EDFA 79                     LD     A,C                  ; Get the Dir's EXT                	;
2200: EDFB BE                     CP     M                    ; Does it match the FCB'd          	;
2201: EDFC 78                     LD     A,B                  ; Get the Dir's  record count      	;
2202: EDFD CA 07 EE               JP     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
2203: EE00 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
2204: EE02 DA 07 EE               JP     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
2205: EE05 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
2206: EE07             OpenSetRecordCount:                      ;
2207: EE07 2A C3 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
2208: EE0A 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
2209: EE0D 19                     ADD    HL,DE                ; FCB's record count               	;
2210: EE0E 77                     LD     (HL),A               ; Set the value                    	;
2211: EE0F C9                     RET                         ;
2212: EE10         ;----------------------------- Open File -----------------------------------;
2213: EE10         ;---------------------------- Close Directory Entry ------------------------;
2214: EE10             CloseDirEntry:                      ;
2215: EE10 AF                     XOR    A                    ;
2216: EE11 32 C5 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
2217: EE14 CD 2C EF               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
2218: EE17 C0                     RET    NZ                   ; Skip close if r/o disk            ;
2219: EE18         ; check file write flag - 0 indicates written                               ;
2220: EE18 CD BC EF               CALL   GetWriteFileFlagValue ; Get file's WriteFileFlag          ;
2221: EE1B CB 7F                  BIT    7,A                  ;  Has it changed ?					;
2222: EE1D         ;	AND		writeFlagMask				; Apply the RO Flag for S2          ;
2223: EE1D C0                     RET    NZ                   ; Skip close if clean file          ;
2224: EE1E         ;
2225: EE1E 0E 0F                  LD     C,nameLength         ;
2226: EE20 CD E2 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
2227: EE23 CD 7E F0               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
2228: EE26 C8                     RET    Z                    ;  exit if at EOD                   ;
2229: EE27         ;
2230: EE27         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
2231: EE27 CD 87 F0               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
2232: EE2A 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
2233: EE2D 09                     ADD    HL,BC                ;
2234: EE2E EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
2235: EE2F 2A C3 EA               LD     HL,(paramDE)         ;
2236: EE32 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
2237: EE33 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
2238: EE35         ;
2239: EE35             MergeAllocationMaps:                      ;
2240: EE35 3A 8E F5               LD     A,(byteAllocationFlag) ;
2241: EE38 B7                     OR     A                    ;
2242: EE39 CA 50 EE               JP     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2243: EE3C         ; process byte size Map	                                                    ;
2244: EE3C 7E                     LD     A,(HL)               ; FCB Block number                  ;
2245: EE3D B7                     OR     A                    ; Is it 0 ?                         ;
2246: EE3E 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2247: EE3F C2 43 EE               JP     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2248: EE42 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2249: EE43             MergeFCBisNot0:                      ;
2250: EE43 B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2251: EE44 C2 49 EE               JP     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2252: EE47 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2253: EE48 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2254: EE49             MergeDirEntryNot0:                      ;
2255: EE49 BE                     CP     M                    ; Do FCB and Dir match values       ;
2256: EE4A C2 8B EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2257: EE4D C3 65 EE               JP     MergeMapLoop         ; Go see if there is more           ;
2258: EE50         ;
2259: EE50             MergeWordMaps:                      ;
2260: EE50 CD B1 F1               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2261: EE53 EB                     EX     DE,HL                ;
2262: EE54 CD B1 F1               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2263: EE57 EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2264: EE58 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2265: EE59 BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2266: EE5A C2 8B EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2267: EE5D 13                     INC    DE                   ;
2268: EE5E 23                     INC    HL                   ; move on to the MSB                ;
2269: EE5F 1A                     LD     A,(DE)               ;
2270: EE60 BE                     CP     M                    ; do the check for equality         ;
2271: EE61 C2 8B EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2272: EE64 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2273: EE65             MergeMapLoop:                      ;
2274: EE65 13                     INC    DE                   ; Advance to the next positions     ;
2275: EE66 23                     INC    HL                   ; in The Maps                       ;
2276: EE67 0D                     DEC    C                    ; Are we done ?                     ;
2277: EE68 C2 35 EE               JP     NZ,MergeAllocationMaps ;  No, do it again                  ;
2278: EE6B         ;
2279: EE6B         ; Check the EXT                                                             ;
2280: EE6B 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2281: EE6E 09                     ADD    HL,BC                ;
2282: EE6F EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2283: EE70 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2284: EE71 1A                     LD     A,(DE)               ; FCB's extent number               ;
2285: EE72 BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2286: EE73 DA 7F EE               JP     C,CloseDirEntryEnd   ;  we are done if yes               ;
2287: EE76 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2288: EE77         ; Update directory record count field                                       ;
2289: EE77 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2290: EE7A 09                     ADD    HL,BC                ;
2291: EE7B EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2292: EE7C 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2293: EE7D 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2294: EE7E 12                     LD     (DE),A               ;  the Directory Record RC          ;
2295: EE7F         ;
2296: EE7F             CloseDirEntryEnd:                      ;
2297: EE7F 3E FF                  LD     A,TRUE               ;
2298: EE81 32 86 F5               LD     (fcbCopiedFlag),A    ;Set copied flag as true            ;
2299: EE84         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2300: EE84 CD F6 F1               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2301: EE87 C3 5F F0               JP     WriteDir             ; Write the directory element       ;
2302: EE8A C9                     RET                         ;
2303: EE8B         ;
2304: EE8B             CloseDirEntryError:                      ;
2305: EE8B 21 C5 EA               LD     HL,exitParameterByte ;
2306: EE8E 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2307: EE8F C9                     RET                         ;
2308: EE90         ;---------------------------- Close Directory Entry ------------------------;
2309: EE90         ;----------------------------------- Make new File -------------------------;
2310: EE90         ;create a new file by creating a directory entry then opening the file      ;
2311: EE90             MakeNewFile:                      ;
2312: EE90 CD 61 F1               CALL   CheckWrite           ; Terminate with error if Disk R/O  ;
2313: EE93 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB                       ;
2314: EE96 E5                     PUSH   HL                   ; FCB                               ;
2315: EE97 21 60 F5               LD     HL,emptyFCB          ;
2316: EE9A 22 C3 EA               LD     (paramDE),HL         ; Find the first empty dir record   ;
2317: EE9D 0E 01                  LD     C,1                  ;
2318: EE9F CD E2 EF               CALL   SearchForDirectoryRecord ; 0F5H in first position            ;
2319: EEA2 CD 7E F0               CALL   AtEndOfDirectory     ; Check if at end of directory      ;
2320: EEA5 E1                     POP    HL                   ; Recall the FCB pointer            ;
2321: EEA6 22 C3 EA               LD     (paramDE),HL         ;  in case we return here           ;
2322: EEA9 C8                     RET    Z                    ; Exit with No Dir space error      ;
2323: EEAA         ; fill Allocation Map with Zeros	                                        ;
2324: EEAA 11 0F 00               LD     DE,nameLength        ;
2325: EEAD 19                     ADD    HL,DE                ; Start of fill                     ;
2326: EEAE 36 00                  LD     (HL),00              ; Prime the values                  ;
2327: EEB0 E5                     PUSH   HL                   ;
2328: EEB1 D1                     POP    DE                   ; Copy to DE                        ;
2329: EEB2 13                     INC    DE                   ; adjust the to pointer             ;
2330: EEB3 01 10 00               LD     BC,fcbLength-nameLength-1 ; number of bytes to fill           ;
2331: EEB6 ED B0                  LDIR                        ;
2332: EEB8         ;
2333: EEB8 2A C3 EA               LD     HL,(paramDE)         ; get FCB                           ;
2334: EEBB 11 0D 00               LD     DE,fcbS1Index        ; Get the S1 index                  ;
2335: EEBE 19                     ADD    HL,DE                ; Point to S1                       ;
2336: EEBF 36 00                  LD     (HL),0               ; Set to 0                          ;
2337: EEC1 CD 95 F0               CALL   SetDirectoryEntry    ; Update directory entry            ;
2338: EEC4 CD 75 F1               CALL   CopyFCB              ; Update dir entry to Disk          ;
2339: EEC7         ; and set the file write flag to "1"                                        ;
2340: EEC7 C3 C5 EF               JP     SetFileWriteFlag     ; Set the clean entry flag          ;
2341: EECA         ;----------------------------------- Make new File -------------------------;
2342: EECA
2343: EECA         ; DIO
2344: EECA
2345: EECA         ;---------------
2346: EECA         ; set a "1" value in currentDisk position of BC
2347: EECA         ; return in HL
2348: EECA             SetCurrentDiskBit:
2349: EECA C5                     PUSH   BC                   ; save input parameter
2350: EECB 3A 5F F5               LD     A,(currentDisk)
2351: EECE 4F                     LD     C,A                  ; ready parameter for shift
2352: EECF 21 01 00               LD     HL,1                 ; number to shift
2353: EED2 CD 99 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
2354: EED5 C1                     POP    BC                   ; original mask
2355: EED6 79                     LD     A,C
2356: EED7 B5                     OR     L
2357: EED8 6F                     LD     L,A
2358: EED9 78                     LD     A,B
2359: EEDA B4                     OR     H
2360: EEDB 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
2361: EEDC C9                     RET
2362: EEDD         ;--------------
2363: EEDD
2364: EEDD         ;--------------------------- Scan      Map ----------------------------------;
2365: EEDD         ;-----------------------------------
2366: EEDD         ; byte value from ALLOC is in register A, with shift count
2367: EEDD         ; in register C (to place bit back into position), and
2368: EEDD         ; target ALLOC position in registers HL, rotate and replace
2369: EEDD             RotateAndReplace:
2370: EEDD 0F                     RRCA
2371: EEDE 15                     DEC    D
2372: EEDF C2 DD EE               JP     NZ,RotateAndReplace  ; back into position
2373: EEE2 77                     LD     (HL),A               ; back to ALLOC
2374: EEE3 C9                     RET
2375: EEE4         ;-----------------------------------
2376: EEE4
2377: EEE4         ;*****************************************************************
2378: EEE4
2379: EEE4         ;*****************************************************************
2380: EEE4         ;=========================== Disk Utilities ================================;
2381: EEE4         ;--------------------------- Home The Current Disk ------------------------;
2382: EEE4         ;move to home position, then offset to start of dir                        ;
2383: EEE4             Home:                           ;
2384: EEE4 CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks      ;
2385: EEE7         ; if Buffer needs to be written    ;
2386: EEE7 21 82 F5               LD     HL,dpbOFF            ; Number of tracks before directory;
2387: EEEA 4E                     LD     C,(HL)               ;
2388: EEEB 23                     INC    HL                   ;
2389: EEEC 46                     LD     B,(HL)               ;
2390: EEED CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position  ;
2391: EEF0         ;
2392: EEF0         ; Set Current Track and Sector to 00                                       ;
2393: EEF0 AF                     XOR    A                    ; set ACC to 00                    ;
2394: EEF1 2A 69 F5               LD     HL,(caTrack)         ;
2395: EEF4 77                     LD     (HL),A               ;
2396: EEF5 23                     INC    HL                   ;
2397: EEF6 77                     LD     (HL),A               ;
2398: EEF7 2A 6B F5               LD     HL,(caSector)        ;
2399: EEFA 77                     LD     (HL),A               ;
2400: EEFB 23                     INC    HL                   ;
2401: EEFC 77                     LD     (HL),A               ;
2402: EEFD C9                     RET                         ;
2403: EEFE         ;
2404: EEFE         ;--------------------------- Home The Current Disk ------------------------;
2405: EEFE         ;--------------------------- Set DMAs -------------------------------------;
2406: EEFE             SetDataDMA:                      ;
2407: EEFE 21 65 F5               LD     HL,initDAMAddress    ;
2408: EF01 18 03                  JR     SetDMA               ; Skip to complete the call        ;
2409: EF03         ;	LD		BC,initDAMAddress                                              ;
2410: EF03         ;	JP		bcSetdma					; Call BIOS to set                 ;
2411: EF03         ;
2412: EF03             SetDirDMA:                      ;
2413: EF03 21 6D F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
2414: EF06         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
2415: EF06         ;	JP		bcSetdma					; Call BIOS to set                 ;
2416: EF06         ;
2417: EF06             SetDMA:                         ;
2418: EF06 4E                     LD     C,(HL)               ;
2419: EF07 23                     INC    HL                   ;
2420: EF08 46                     LD     B,(HL)               ; parameter ready              ;
2421: EF09 C3 24 F6               JP     bcSetdma             ; call bios to set             ;
2422: EF0C         ;--------------------------- Set DMAs -------------------------------------;
2423: EF0C         ;--------------------------- Read Buffer ----------------------------------;
2424: EF0C         ;reads into current DMA, using current Disk,Track and Sector               ;
2425: EF0C             ReadBuffer:                      ;
2426: EF0C CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
2427: EF0F B7                     OR     A                    ; Check status                     ;
2428: EF10 C2 F3 F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2429: EF13 C9                     RET                         ;
2430: EF14         ;--------------------------- Read Buffer ----------------------------------;
2431: EF14         ;--------------------------- Set Current Disk Read Only --------------------;
2432: EF14         ;set current disk to read only                                              ;
2433: EF14             SetDiskReadOnly:                      ;
2434: EF14 2A 61 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2435: EF17         ;
2436: EF17 3A 5F F5               LD     A,(currentDisk)      ; Get the current disk              ;
2437: EF1A 47                     LD     B,A                  ; Move into B                       ;
2438: EF1B CD B0 F4               CALL   SetVectorBit         ; Set the bit	                    ;
2439: EF1E 22 61 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2440: EF21         ;
2441: EF21 2A 7C F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2442: EF24 EB                     EX     DE,HL                ;
2443: EF25 2A 67 F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2444: EF28 73                     LD     (HL),E               ;
2445: EF29 23                     INC    HL                   ;
2446: EF2A 72                     LD     (HL),D               ;
2447: EF2B C9                     RET                         ;
2448: EF2C         ;--------------------------- Set disk Read Only ----------------------------;
2449: EF2C         ;--------------------------- Is Disk Write Protected -----------------------;
2450: EF2C         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2451: EF2C         ;					= reset if Write Protected		(NZ)					;
2452: EF2C             IsDiskWriteProtected:                      ;
2453: EF2C 2A 61 F5               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2454: EF2F 3A 5F F5               LD     A,(currentDisk)      ; Get current disk                  ;
2455: EF32 47                     LD     B,A                  ;
2456: EF33 CD A0 F4               CALL   IsBitSet             ; Check the bit                     ;
2457: EF36 C9                     RET                         ; NZ if Disk is RO                  ;
2458: EF37         ;--------------------------- Is Disk Write Protected -----------------------;
2459: EF37
2460: EF37         ;------------------------- Reselect Disk if Necessary ----------------------;
2461: EF37         ;check current fcb to see if reselection necessary                         ;
2462: EF37             ReselectDisk:                      ;
2463: EF37 3E FF                  LD     A,TRUE               ;
2464: EF39 32 8F F5               LD     (fResel),A           ; Mark as possible reselect         ;
2465: EF3C 2A C3 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2466: EF3F 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2467: EF40 E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2468: EF42 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2469: EF43 32 C2 EA               LD     (paramE),A           ; Save drive code                   ;
2470: EF46 FE 1E                  CP     30                   ;
2471: EF48 D2 5B EF               JP     NC,NoSelect          ; Skip drive >= 30                  ;
2472: EF4B         ;
2473: EF4B 3A 5F F5               LD     A,(currentDisk)      ; Determine the current drive       ;
2474: EF4E 32 90 F5               LD     (entryDisk),A        ; Save it                           ;
2475: EF51 7E                     LD     A,(HL)               ;
2476: EF52 32 91 F5               LD     (fcbDisk),A          ; Get calling disk                  ;
2477: EF55 E6 E0                  AND    11100000B            ;
2478: EF57 77                     LD     (HL),A               ; Preserve User Number              ;
2479: EF58 CD EA EC               CALL   SelectCurrent        ; Select the new disk               ;
2480: EF5B         ;
2481: EF5B             NoSelect:                       ;
2482: EF5B 3A 5E F5               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2483: EF5E 2A C3 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2484: EF61 B6                     OR     M                    ; Combine                           ;
2485: EF62 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2486: EF63 C9                     RET                         ;
2487: EF64         ;------------------------- Reselect Disk if Necessary ----------------------;
2488: EF64
2489: EF64
2490: EF64         ;=========================== Disk Utilities ================================;
2491: EF64
2492: EF64         ;=========================== File Utilities ================================;
2493: EF64         ;--------------------------- Set Record Variables -------------------------;
2494: EF64         ;set variables from currently FCB - Current Record, RC, EXM                ;
2495: EF64             SetRecordVars:                      ;
2496: EF64 CD 7B EF               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2497: EF67         ;  and HL => .CurrentRecord        ;
2498: EF67 7E                     LD     A,(HL)               ;
2499: EF68 32 94 F5               LD     (currentFileRecord),A ; Save current record              ;
2500: EF6B EB                     EX     DE,HL                ;
2501: EF6C 7E                     LD     A,(HL)               ;
2502: EF6D 32 92 F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2503: EF70 CD 88 EF               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2504: EF73 3A 79 F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2505: EF76 A6                     AND    M                    ; Remove unwanted bits             ;
2506: EF77 32 93 F5               LD     (extentValue),A      ; Store the value                  ;
2507: EF7A C9                     RET                         ;
2508: EF7B         ;--------------------------- Set Record Variables -------------------------;
2509: EF7B         ;----------------------Get File Record Count and Current Record------------;
2510: EF7B         ; returns with DE pointing at RC from FCB                                  ;
2511: EF7B         ;         with HL pointing at Current Record                               ;
2512: EF7B             GetFcbRecordDetails:                      ;
2513: EF7B 2A C3 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2514: EF7E 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2515: EF81 19                     ADD    HL,DE                ;
2516: EF82 EB                     EX     DE,HL                ; DE Points to Record Count        ;
2517: EF83 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;
2518: EF86 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2519: EF87 C9                     RET                         ;
2520: EF88         ;----------------------Get File Record Count and Current Record------------;
2521: EF88         ;----------------------Get FileExtent--------------------------------------;
2522: EF88         ;get current extent field address to (HL)                                 ;
2523: EF88             GetExtentAddress:                      ;
2524: EF88 2A C3 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2525: EF8B 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2526: EF8E 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2527: EF8F C9                     RET                         ;
2528: EF90         ;----------------------Get FileExtent--------------------------------------;
2529: EF90         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2530: EF90         ; At Entry:	BC Contains to the Block to be modified                        ;
2531: EF90         ;			E  = TRUE if bit is to be set                                  ;
2532: EF90         ;			E  <> TRUE if bit is to be reset                               ;
2533: EF90         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2534: EF90             SetResetMapBit:                      ;
2535: EF90         ;
2536: EF90 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2537: EF93 09                     ADD    HL,BC                ;  to HL                           ;
2538: EF94 4B                     LD     C,E                  ; Move the flag to E               ;
2539: EF95         ;
2540: EF95 7D                     LD     A,L                  ; LSB of the Block Number          ;
2541: EF96 E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2542: EF98 F5                     PUSH   AF                   ; Save the OctetBit                ;
2543: EF99 06 03                  LD     B,3                  ;
2544: EF9B CD 9F F1               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2545: EF9E ED 5B 73 F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2546: EFA2 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2547: EFA3 F1                     POP    AF                   ;
2548: EFA4 47                     LD     B,A                  ; Get the bit                      ;
2549: EFA5         ;
2550: EFA5 04                     INC    B                    ; Adjust for looping               ;
2551: EFA6 C5                     PUSH   BC                   ; Will need this later             ;
2552: EFA7             Left:                           ;
2553: EFA7 CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2554: EFA9 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2555: EFAB C1                     POP    BC                   ; Restore loop limit and           ;
2556: EFAC 37                     SCF                         ;  set/reset flag                  ;
2557: EFAD 0C                     INC    C                    ; was C = TRUE                     ;
2558: EFAE 28 01                  JR     Z,Right              ; Skip if Set                      ;
2559: EFB0 3F                     CCF                         ; Set for Reset                    ;
2560: EFB1             Right:                          ;
2561: EFB1 CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2562: EFB3 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2563: EFB5 C9                     RET                         ;
2564: EFB6         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2565: EFB6         ;--------------------- Initialize Extent Number MSB -----------------------;
2566: EFB6         ;clear the Extent number field for user open/make (S2)                    ;
2567: EFB6             InitializeExtentNumberMSB:                      ;
2568: EFB6 CD BC EF               CALL   GetExtentNumberMSB   ;
2569: EFB9 36 00                  LD     (HL),0               ; Set it to = 0            ;
2570: EFBB C9                     RET                         ;
2571: EFBC         ;--------------------- Initialize Extent Number MSB -----------------------;
2572: EFBC         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2573: EFBC         ; Get S2 value                                                             ;
2574: EFBC         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
2575: EFBC         ;			HL = Address of S2 for the FCB pointed to by paramDE           ;
2576: EFBC             GetWriteFileFlagValue:                      ; S2 bit 7                 ;
2577: EFBC             GetExtentNumberMSB:                      ; S2 bits 0-6              ;
2578: EFBC 2A C3 EA               LD     HL,(paramDE)         ; FCB address              ;
2579: EFBF 11 0E 00               LD     DE,fcbS2Index        ; Index to value           ;
2580: EFC2 19                     ADD    HL,DE                ; Address of value         ;
2581: EFC3 7E                     LD     A,(HL)               ; load into ACC            ;
2582: EFC4 C9                     RET                         ;
2583: EFC5         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2584: EFC5         ;--------------------------- Set File Write Flag----------------------------;
2585: EFC5         ;Set file write flag in FCB in (paramDE)									;
2586: EFC5         ; Used to indicate the FCB is clean. No need to write on close				;
2587: EFC5             SetFileWriteFlag:                      ;
2588: EFC5 CD BC EF               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2589: EFC8 CB FE                  SET    7,(HL)               ; Set the FileWriteFlag				;
2590: EFCA C9                     RET                         ;
2591: EFCB         ;?	OR		writeFlagMask				; Set the flag , bit 7 of S2        ;
2592: EFCB         ;?	LD		(HL),A						; Put into FCB                      ;
2593: EFCB         ;?	RET	                                                                    ;
2594: EFCB         ;--------------------------- Set File Write Flag----------------------------;
2595: EFCB         ;--------------------------- Reset File Write Flag--------------------------;
2596: EFCB         ;Reset file write flag in FCB in (paramDE)									;
2597: EFCB         ; Used to indicate the FCB is dirty. Need to write on close					;
2598: EFCB             ResetFileWriteFlag:                      ;
2599: EFCB CD BC EF               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2600: EFCE CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag			;
2601: EFD0 C9                     RET                         ;
2602: EFD1         ;?	AND		0FFH-writeFlagMask			; Remove the flag bit		        ;
2603: EFD1         ;?	LD		(HL),A						; Put into FCB                      ;
2604: EFD1         ;?	RET	                                                                    ;
2605: EFD1         ;--------------------------- Reset File Write Flag--------------------------;
2606: EFD1         ;-------------------------- Compare FCB Extents ----------------------------;
2607: EFD1         ; Enters:	A containing Target FCB EXT value								;
2608: EFD1         ;			HL Points at Possible FCB EXT value								;
2609: EFD1         ;compare extent# in A with that in C, return nonzero if they do not match	;
2610: EFD1             CompareExtents:                      ;
2611: EFD1 C5                     PUSH   BC                   ; Save Callers Registers			;
2612: EFD2 F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2613: EFD3 3A 79 F5               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2614: EFD6 2F                     CPL                         ; Complement for And           		;
2615: EFD7 47                     LD     B,A                  ; Put negated Mask into B      		;
2616: EFD8 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2617: EFD9 A0                     AND    B                    ; Apply the Mask               		;
2618: EFDA 4F                     LD     C,A                  ; Low bits removed from C      		;
2619: EFDB F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2620: EFDC A0                     AND    B                    ; Apply the Mask               		;
2621: EFDD 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2622: EFDE E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2623: EFE0 C1                     POP    BC                   ; Restore Callers Registers    		;
2624: EFE1 C9                     RET                         ;
2625: EFE2         ;-------------------------- Compare FCB Extents ----------------------------;
2626: EFE2         ;---------------------Search for Directory Record --------------------------;
2627: EFE2         ;  Search for directory record of length C.									;
2628: EFE2         ; Target is pointed to by paramDE. The whole directory is searched.			;
2629: EFE2         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2630: EFE2         ; matched directory record													;
2631: EFE2         ; Entry:	C = Search Length                                               ;
2632: EFE2         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2633: EFE2         ;								-1 (EOD) if there is no match				;
2634: EFE2             SearchForDirectoryRecord:                      ;
2635: EFE2 3E FF                  LD     A,0FFH               ;
2636: EFE4 32 88 F5               LD     (directoryIndex),A   ; Initialize directory Index        ;
2637: EFE7 21 8B F5               LD     HL,searchLength      ;
2638: EFEA 71                     LD     (HL),C               ; Save Search Length                ;
2639: EFEB 2A C3 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2640: EFEE 22 8C F5               LD     (searchAddress),HL   ; Start of search                   ;
2641: EFF1 CD 77 F0               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2642: EFF4 CD E4 EE               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2643: EFF7         ;
2644: EFF7             GetNextDirectoryRecord:                      ;
2645: EFF7 0E 00                  LD     C,FALSE              ;
2646: EFF9 CD C8 F1               CALL   ReadDirectory        ; Read next Dir Record              ;
2647: EFFC CD 7E F0               CALL   AtEndOfDirectory     ;
2648: EFFF CA 56 F0               JP     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2649: F002         ;
2650: F002 2A 8C F5               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2651: F005 EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2652: F006 1A                     LD     A,(DE)               ; User Number                       ;
2653: F007 FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2654: F009 CA 14 F0               JP     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2655: F00C         ;
2656: F00C         ; Check to be sure we are sill in the Directory                             ;
2657: F00C D5                     PUSH   DE                   ; Save search address               ;
2658: F00D CD 9E F0               CALL   StillInDirectory     ; Still in the directorY            ;
2659: F010 D1                     POP    DE                   ; Recall address                    ;
2660: F011 D2 56 F0               JP     NC,NoDirRecordsMatch ; Get out if past directory			;
2661: F014         ;
2662: F014             GetNextDirectoryRecord1:                      ;
2663: F014 CD 87 F0               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2664: F017 3A 8B F5               LD     A,(searchLength)     ;
2665: F01A 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2666: F01B 06 00                  LD     B,0                  ; Character Index (up)              ;
2667: F01D         ;
2668: F01D             TestNextPosition:                      ;
2669: F01D 1A                     LD     A,(DE)               ;
2670: F01E FE 3F                  CP     QMARK                ; ? is always a char match          ;
2671: F020 CA 3E F0               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2672: F023         ;
2673: F023 78                     LD     A,B                  ;
2674: F024 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2675: F026 CA 3E F0               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2676: F029         ; not the fcbS1Index field, extent field?                                  ;
2677: F029 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2678: F02B 1A                     LD     A,(DE)               ; Get next character                ;
2679: F02C CA 38 F0               JP     Z,CheckExtents       ; Skip to search extent             ;
2680: F02F 96                     SUB    M                    ; Do they match ?                   ;
2681: F030 E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2682: F032 C2 F7 EF               JP     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2683: F035 C3 3E F0               JP     SetNextPosition      ; Matched the character             ;
2684: F038         ;                                                                           ;
2685: F038             CheckExtents:                      ;
2686: F038 CD D1 EF               CALL   CompareExtents       ; Matching EXTs is work             ;
2687: F03B C2 F7 EF               JP     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2688: F03E         ;
2689: F03E             SetNextPosition:                      ;
2690: F03E 13                     INC    DE                   ; Pointer to Looking FOR            ;
2691: F03F 23                     INC    HL                   ; Pointer to Looking IN             ;
2692: F040 04                     INC    B                    ; Character Index in FCB            ;
2693: F041 0D                     DEC    C                    ; Length of search                  ;
2694: F042 C2 1D F0               JP     NZ,TestNextPosition  ;
2695: F045         ; Match Found, entire name matches                                          ;
2696: F045 3A 99 F5               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2697: F048 E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2698: F04A 32 C5 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2699: F04D         ;
2700: F04D 21 88 F5               LD     HL,directoryIndex    ; Point at Directory Flag           ;
2701: F050 7E                     LD     A,(HL)               ; Get value                         ;
2702: F051 17                     RLA                         ; Set Carry if Flag = -1            ;
2703: F052 D0                     RET    NC                   ; Return with flag still -1         ;
2704: F053         ;
2705: F053 AF                     XOR    A                    ; Else Clear the flag               ;
2706: F054 77                     LD     (HL),A               ;
2707: F055 C9                     RET                         ;  and exit                         ;
2708: F056         ;------                                                                     ;
2709: F056             NoDirRecordsMatch:                      ;
2710: F056 CD 77 F0               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2711: F059 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2712: F05B 32 C5 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2713: F05E C9                     RET                         ;
2714: F05F         ;---------------------Search for Directory Record --------------------------;
2715: F05F         ;---------------------------- Write Current Directory Entry ----------------;
2716: F05F             WriteDir:                       ;
2717: F05F         ;	CALL	NewCheckSum						; initialize entry              ;
2718: F05F 0E FF                  LD     C,TRUE               ;
2719: F061 CD 41 F2               CALL   CheckSumUtility      ; Set New CheckSum              ;
2720: F064         ;
2721: F064 CD 03 EF               CALL   SetDirDMA            ; Directory DMA                 ;
2722: F067 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
2723: F069 CD 6F F0               CALL   WriteBuffer          ; Write the buffer              ;
2724: F06C C3 FE EE               JP     SetDataDMA           ; Reset DMA to default			;
2725: F06F         ;
2726: F06F         ;---------------------------- Write Current Directory Entry ----------------;
2727: F06F         ;----------------------------------- Write Buffer --------------------------;
2728: F06F         ; Write buffer and check condition. Current drive,Track, Sector and DMA     ;
2729: F06F         ; Are set up prior to calling this routine                                  ;
2730: F06F         ;                                                                           ;
2731: F06F         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
2732: F06F         ;				1 => directory write operation	WriteDirectory              ;
2733: F06F         ;				2 => start of new block			WriteCleanBuffer			;
2734: F06F             WriteBuffer:                      ;
2735: F06F CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
2736: F072 B7                     OR     A                    ; Get return code                   ;
2737: F073 C2 F3 F4               JP     NZ,erPermanentNoWait ; Error if not 00                   ;
2738: F076 C9                     RET                         ;
2739: F077         ;----------------------------------- Write Buffer --------------------------;
2740: F077         ; FU
2741: F077         ;=========================== File Utilities ================================;
2742: F077
2743: F077         ;=========================== Directory Utilities ===========================;
2744: F077         ;--------------------------- Set End of Directory indicator ----------------;
2745: F077             SetEndDirectory:                      ;
2746: F077 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
2747: F07A 22 99 F5               LD     (dirEntryIndex),HL   ;
2748: F07D C9                     RET                         ;
2749: F07E         ;--------------------------- Set End of Directory indicator ----------------;
2750: F07E         ;--------------------------- Are we at End Of Directory --------------------;
2751: F07E         ; Tests to see if we are at the End Of the Directory                        ;
2752: F07E         ;                                                                           ;
2753: F07E         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
2754: F07E         ;			 Z Flag reset if still in directory                             ;
2755: F07E         ;
2756: F07E             AtEndOfDirectory:                      ;
2757: F07E 21 99 F5               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
2758: F081 7E                     LD     A,(HL)               ; Get it                            ;
2759: F082 23                     INC    HL                   ; Point at MSB	of Dir Index		;
2760: F083 BE                     CP     M                    ; LSB = MSB ?                       ;
2761: F084 C0                     RET    NZ                   ;  exit if not if different         ;
2762: F085         ; Same.  are they = 0ffh?           ;
2763: F085 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
2764: F086 C9                     RET                         ;
2765: F087         ;--------------------------- Are we at End Of Directory --------------------;
2766: F087         ;--------------------------- Get Directory Element -------------------------;
2767: F087         ; compute the address of a directory element in Directory Buffer            ;
2768: F087         ; Returns:  HL = Address of the specific directory Record                   ;
2769: F087             GetCurrentDirectoryRecord:                      ;
2770: F087 C5                     PUSH   BC                   ; Save BC                           ;
2771: F088 2A 6D F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
2772: F08B 3A 98 F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
2773: F08E 4F                     LD     C,A                  ;
2774: F08F AF                     XOR    A                    ; Set to Zero and reset CY          ;
2775: F090 47                     LD     B,A                  ;
2776: F091 ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
2777: F093 C1                     POP    BC                   ; Restore	                        ;
2778: F094 C9                     RET                         ;
2779: F095         ;--------------------------- Get Directory Element -------------------------;
2780: F095         ;--------------------------- Set Directory Entry ---------------------------;
2781: F095         ; Will update directory if not in the directory                             ;
2782: F095         ;
2783: F095             SetDirectoryEntry:                      ;
2784: F095 CD 9E F0               CALL   StillInDirectory     ;
2785: F098 D8                     RET    C                    ; Exit if still in the Directory  	;
2786: F099         ;
2787: F099         ; StillInDirectory will return with:                                        ;
2788: F099         ;									DE = Directory entry number             ;
2789: F099         ;									HL = Address of entry number + 1        ;
2790: F099 13                     INC    DE                   ;
2791: F09A 72                     LD     (HL),D               ;
2792: F09B 2B                     DEC    HL                   ;
2793: F09C 73                     LD     (HL),E               ;
2794: F09D C9                     RET                         ;
2795: F09E         ;--------------------------- Set Directory Entry ---------------------------;
2796: F09E         ;--------------------------- Are we sill in the Directory ------------------;
2797: F09E         ;Returns	:                                                               ;
2798: F09E         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
2799: F09E         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
2800: F09E         ;			HL = (address of Index Value) + 1                               ;
2801: F09E         ;			DE = Directory Index Value                                      ;
2802: F09E             StillInDirectory:                      ;
2803: F09E 2A 99 F5               LD     HL,(dirEntryIndex)   ;
2804: F0A1 EB                     EX     DE,HL                ; DE = directory counter            ;
2805: F0A2 2A 67 F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
2806: F0A5 7B                     LD     A,E                  ;
2807: F0A6 96                     SUB    M                    ;
2808: F0A7 23                     INC    HL                   ;
2809: F0A8 7A                     LD     A,D                  ;
2810: F0A9 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
2811: F0AA C9                     RET                         ;  <= Directory Max Value       ;
2812: F0AB         ;--------------------------- Are we sill in the Directory ------------------;
2813: F0AB         ;--------------------------- Scan Disk Map ---------------------------------;
2814: F0AB         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
2815: F0AB         ;                                                                           ;
2816: F0AB         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
2817: F0AB         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
2818: F0AB         ;
2819: F0AB             ScanDiskMap:                      ;
2820: F0AB C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
2821: F0AC CD 87 F0               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
2822: F0AF 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
2823: F0B2 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
2824: F0B3 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
2825: F0B5         ;
2826: F0B5             ScanDiskMap0:                      ;
2827: F0B5 D1                     POP    DE                   ; Recall the set/reset Info         ;
2828: F0B6 0D                     DEC    C                    ;
2829: F0B7 C8                     RET    Z                    ; Loop once for each disk map entry ;
2830: F0B8         ;
2831: F0B8 D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
2832: F0B9 3A 8E F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
2833: F0BC B7                     OR     A                    ;
2834: F0BD 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
2835: F0BF         ;  Byte Allocation scan operation                                           ;
2836: F0BF C5                     PUSH   BC                   ; Save counter                      ;
2837: F0C0 E5                     PUSH   HL                   ; Save map address                  ;
2838: F0C1 4E                     LD     C,(HL)               ;
2839: F0C2 06 00                  LD     B,0                  ; BC=block# for Byte                ;
2840: F0C4 18 06                  JR     ScanDiskMap2         ;
2841: F0C6         ; Word scan operation                                                       ;
2842: F0C6             ScanDiskMapWord:                      ;
2843: F0C6 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
2844: F0C7 C5                     PUSH   BC                   ; Save counter                      ;
2845: F0C8 46                     LD     B,(HL)               ;
2846: F0C9 23                     INC    HL                   ;
2847: F0CA 4E                     LD     C,(HL)               ; BC=block# for Word                ;
2848: F0CB E5                     PUSH   HL                   ; Save map address                  ;
2849: F0CC         ;
2850: F0CC         ; Arrive here with BC=block#, E=0/1	                                        ;
2851: F0CC             ScanDiskMap2:                      ;
2852: F0CC 79                     LD     A,C                  ;
2853: F0CD B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
2854: F0CE C4 90 EF               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
2855: F0D1 E1                     POP    HL                   ;
2856: F0D2 23                     INC    HL                   ; to next bit position              ;
2857: F0D3 C1                     POP    BC                   ; recall counter                    ;
2858: F0D4 C3 B5 F0               JP     ScanDiskMap0         ; for another item                  ;
2859: F0D7         ;
2860: F0D7         ;--------------------------- Scan Disk Map ---------------------------------;
2861: F0D7         ;--------------------------- Get Closest Disk Block ------------------------;
2862: F0D7         ; Find the closest available disk block, and mark in Map as allocated       ;
2863: F0D7         ; Enter	BC	= Block number to base the search on                            ;
2864: F0D7         ; Exit	HL	= 0000 if There are no available open blocks                    ;
2865: F0D7         ;			= block number of available and marked block                    ;
2866: F0D7         ;
2867: F0D7             GetClosestBlock:                      ;
2868: F0D7 C5                     PUSH   BC                   ; save the starting Block #         ;
2869: F0D8         ;
2870: F0D8 2A 7A F5               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
2871: F0DB CD 9D F1               CALL   DivideHLby8          ; Length of Map	                    ;
2872: F0DE EB                     EX     DE,HL                ; put size into DE			        ;
2873: F0DF E1                     POP    HL                   ; Block number into HL              ;
2874: F0E0 CD 9D F1               CALL   DivideHLby8          ; Length of Map                     ;
2875: F0E3 EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
2876: F0E4 AF                     XOR    A                    ; Reset CY                          ;
2877: F0E5 ED 52                  SBC    HL,DE                ; Size for right                    ;
2878: F0E7         ; DE = Start Index                                                          ;
2879: F0E7         ; DE = Left Size                                                            ;
2880: F0E7         ; HL	= Right Size                                                        ;
2881: F0E7 E5                     PUSH   HL                   ; Save right size                   ;
2882: F0E8 D5                     PUSH   DE                   ; Save left size & Start Index      ;
2883: F0E9 3E FF                  LD     A,0FFH               ; Full Octet                        ;
2884: F0EB         ;
2885: F0EB 2A 73 F5               LD     HL,(caAllocVector)   ; Start of Map                      ;
2886: F0EE 19                     ADD    HL,DE                ; Determine initial Octet			;
2887: F0EF         ; Set up Left side                                                          ;
2888: F0EF C1                     POP    BC                   ; Left size                         ;
2889: F0F0 03                     INC    BC                   ; adjust                            ;
2890: F0F1 E5                     PUSH   HL                   ; Save initial Octet                ;
2891: F0F2 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
2892: F0F5         ; HL = Initial Octet                                                        ;
2893: F0F5         ; BC = Left Size                                                            ;
2894: F0F5 D9                     EXX                         ; Use alternate registers           ;
2895: F0F6 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
2896: F0F9 E1                     POP    HL                   ; Get Initial Octet                 ;
2897: F0FA C1                     POP    BC                   ; Get Right Size                    ;
2898: F0FB 03                     INC    BC                   ; adjust                            ;
2899: F0FC             LookRight:                      ;
2900: F0FC ED A1                  CPI                         ; UnSet Bit?                        ;
2901: F0FE 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2902: F100 E2 19 F1               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
2903: F103         ;
2904: F103 D9                     EXX                         ; Switch to the Left                ;
2905: F104 ED A9                  CPD                         ; UnSet Bit?                        ;
2906: F106 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2907: F108 E2 0E F1               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
2908: F10B D9                     EXX                         ; switch to right                   ;
2909: F10C 18 EE                  JR     LookRight            ; Keep on looking                   ;
2910: F10E         ;			----------------			                                    ;
2911: F10E             NoMoreLeft:                      ;
2912: F10E D9                     EXX                         ; Switch to Right                   ;
2913: F10F             NoMoreLeftLoop:                      ;
2914: F10F ED A1                  CPI                         ;
2915: F111 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2916: F113 E2 24 F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
2917: F116 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
2918: F118 76                     HALT                        ;
2919: F119             NoMoreRight:                      ;
2920: F119 D9                     EXX                         ; Switch to Left                    ;
2921: F11A             NoMoreRightLoop:                      ;
2922: F11A ED A9                  CPD                         ;
2923: F11C 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2924: F11E E2 24 F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
2925: F121 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
2926: F123 76                     HALT                        ;
2927: F124             NoFreeBlocks:                      ;
2928: F124 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
2929: F127 C9                     RET                         ;
2930: F128         ;			----------------			                                    ;
2931: F128             FoundFreeOctet:                      ;
2932: F128 BB                     CP     E                    ; Left or Right                     ;
2933: F129 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
2934: F12B 2B                     DEC    HL                   ; Adjust for direction              ;
2935: F12C 18 01                  JR     FoundFreeOctet2      ;
2936: F12E         ;
2937: F12E             FoundFreeOctet1:                      ;
2938: F12E 23                     INC    HL                   ; Adjust for direction              ;
2939: F12F             FoundFreeOctet2:                      ;
2940: F12F 01 00 00               LD     BC,00                ; need to keep track of bit         ;
2941: F132             FoundFreeOctet3:                      ;
2942: F132 CB 06                  RLC    (HL)                 ;
2943: F134 03                     INC    BC                   ;
2944: F135 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
2945: F137 CB C6                  SET    0,(HL)               ; Make map bit set                  ;
2946: F139 41                     LD     B,C                  ; Put count in B                    ;
2947: F13A             FoundFreeOctet4:                      ;
2948: F13A CB 0E                  RRC    (HL)                 ;
2949: F13C 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
2950: F13E 0B                     DEC    BC                   ; adjust for Zero based value       ;
2951: F13F C5                     PUSH   BC                   ; Save the bit index                ;
2952: F140 ED 4B 73 F5               LD     BC,(caAllocVector)   ; Get Map start                     ;
2953: F144 AF                     XOR    A                    ; Clear CY                          ;
2954: F145 ED 42                  SBC    HL,BC                ; Get how far in the map            ;
2955: F147 CD A7 F1               CALL   MultiplyHLby8        ; Calculate the Octet           ;
2956: F14A C1                     POP    BC                   ; Restore index into Octet          ;
2957: F14B 09                     ADD    HL,BC                ; This is the Block Number          ;
2958: F14C C9                     RET                         ;
2959: F14D         ;--------------------------- Get Closest Disk Block ------------------------;
2960: F14D         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
2961: F14D             CopyDirEntryToUserDMA:                      ;
2962: F14D 2A 6D F5               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer         ;
2963: F150 ED 5B 65 F5               LD     DE,(initDAMAddress)  ; Point at User's Buffer            ;
2964: F154 01 80 00               LD     BC,cpmRecordSize     ; The entire record                 ;
2965: F157 ED B0                  LDIR                        ; Move it                           ;
2966: F159 C9                     RET                         ;
2967: F15A         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
2968: F15A         ;--------------------- Return last Directory Index to Caller ---------------;
2969: F15A             DirLocationToReturnLoc:                      ;
2970: F15A 3A 88 F5               LD     A,(directoryIndex)   ; Get last directory Index          ;
2971: F15D 32 C5 EA               LD     (exitParameterByte),A ; Save for return to Caller         ;
2972: F160 C9                     RET                         ;
2973: F161         ;--------------------- Return last Directory Index to Caller ---------------;
2974: F161         ;--------------------------- Check OK to Write to Disk ---------------------;
2975: F161             CheckWrite:                      ;
2976: F161 CD 2C EF               CALL   IsDiskWriteProtected ; Is this disk Write Protected?     ;
2977: F164 C8                     RET    Z                    ; OK to write                       ;
2978: F165 C3 D4 F4               JP     errReadOnlyDisk      ; Report read only disk error		;
2979: F168         ;--------------------------- Check OK to Write to Disk ---------------------;
2980: F168         ;--------------------------- Check File Write Protect Status ---------------;
2981: F168             CheckRODirectory:                      ;
2982: F168 CD 87 F0               CALL   GetCurrentDirectoryRecord ; Use Entry in Directory Buffer     ;
2983: F16B         ; Use HL as the directory entry in Question                                 ;
2984: F16B             CheckROFile:                      ;
2985: F16B 11 09 00               LD     DE,fcbROfileIndex    ; Index into FC for RO              ;
2986: F16E 19                     ADD    HL,DE                ; point at the byte                 ;
2987: F16F 7E                     LD     A,(HL)               ;
2988: F170 17                     RLA                         ; Set CY if RO bit set              ;
2989: F171 D0                     RET    NC                   ; Return OK                         ;
2990: F172 C3 DA F4               JP     errReadOnlyFile      ; Report to read only File          ;
2991: F175         ;--------------------------- Check File Write Protect Status ---------------;
2992: F175         ;------------------------- Copy FCB To Directory record --------------------;
2993: F175         ; On Entry:                                                                 ;
2994: F175         ;			C = Starting position                                           ;
2995: F175         ;			E = length of copy                                              ;
2996: F175         ;copy the whole file control block                                          ;
2997: F175             CopyFCB:                        ;
2998: F175 0E 00                  LD     C,0                  ;
2999: F177 1E 20                  LD     E,fcbLength          ; Copy all of the FCB		    ;
3000: F179         ; On Entry:                                                                 ;
3001: F179         ;			C = Starting position                                           ;
3002: F179         ;			E = length of copy                                              ;
3003: F179             CopyDir:                        ;
3004: F179 16 00                  LD     D,0                  ; Make length a word value      ;
3005: F17B D5                     PUSH   DE                   ; Length                        ;
3006: F17C 06 00                  LD     B,0                  ; Make index a word             ;
3007: F17E 2A C3 EA               LD     HL,(paramDE)         ; HL = source for data          ;
3008: F181 09                     ADD    HL,BC                ;
3009: F182 EB                     EX     DE,HL                ;
3010: F183 CD 87 F0               CALL   GetCurrentDirectoryRecord ; HL pointer to Dir Record      ;
3011: F186 EB                     EX     DE,HL                ;
3012: F187 C1                     POP    BC                   ; Length                        ;
3013: F188 ED B0                  LDIR                        ;
3014: F18A CD F6 F1               CALL   SeekDir              ; Seek to the dir entry         ;
3015: F18D C3 5F F0               JP     WriteDir             ; Write the directory element   ;
3016: F190         ;------------------------- Copy FCB from Directory record ------------------;
3017: F190
3018: F190         ;=========================== Directory Utilities ===========================;
3019: F190         ; DU
3020: F190
3021: F190         ;=========================== General   Utilities ===========================;
3022: F190
3023: F190         ;--------------------------- Rotate HL right by value in C ----------------;
3024: F190         ;
3025: F190         ; HL = Value to be rotated Right                                           ;
3026: F190         ;  B = Amount to shift                                                     ;
3027: F190             RotateRightHLbyB:                      ;
3028: F190 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
3029: F191 CB 45                  BIT    0,L                  ; is LSB set?                      ;
3030: F193 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
3031: F195 3F                     CCF                         ; else Clear Carry flag            ;
3032: F196             RotateRightHLbyB1:                      ;
3033: F196 CB 1C                  RR     H                    ; Shift thru CY                    ;
3034: F198 CB 1D                  RR     L                    ; ditto                            ;
3035: F19A 10 F4                  DJNZ   RotateRightHLbyB     ;
3036: F19C C9                     RET                         ;
3037: F19D         ;
3038: F19D         ;--------------------------- Rotate HL right by value in C ----------------;
3039: F19D         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
3040: F19D         ; HL = Value to be shifted Right                                           ;
3041: F19D             DivideHLby8:                      ;
3042: F19D 06 03                  LD     B,3                  ; 8 = 2**3						   ;
3043: F19F         ;  B = Amount to shift                                                     ;
3044: F19F             ShiftRightHLbyB:                      ;
3045: F19F AF                     XOR    A                    ; else Clear Carry flag            ;
3046: F1A0 CB 1C                  RR     H                    ; Shift thru CY                    ;
3047: F1A2 CB 1D                  RR     L                    ; ditto                            ;
3048: F1A4 10 F9                  DJNZ   ShiftRightHLbyB      ;
3049: F1A6 C9                     RET                         ;
3050: F1A7         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
3051: F1A7         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
3052: F1A7         ; HL = Value to be shifted Left                                            ;
3053: F1A7             MultiplyHLby8:                      ;
3054: F1A7 06 03                  LD     B,3                  ; 8 = 2**3						   ;
3055: F1A9         ;  B = Amount to shift                                                     ;
3056: F1A9             ShiftLeftHLbyB:                      ;
3057: F1A9 AF                     XOR    A                    ; else Clear Carry flag            ;
3058: F1AA CB 15                  RL     L                    ; Shift thru CY                    ;
3059: F1AC CB 14                  RL     H                    ; ditto                            ;
3060: F1AE 10 F9                  DJNZ   ShiftLeftHLbyB       ;
3061: F1B0 C9                     RET                         ;
3062: F1B1         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
3063: F1B1         ;----------------------------- Merge ---------------------------------------;
3064: F1B1         ; Merge Map Block Numbers between FCB and directory record                  ;
3065: F1B1         ; HL has pointer to map for either dir record or FCB,                       ;
3066: F1B1         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
3067: F1B1         ; it just returns, Else it copies the block number to where DE is pointing  ;
3068: F1B1         ;
3069: F1B1             Merge:                          ;
3070: F1B1 7E                     LD     A,(HL)               ; Get the first byte                ;
3071: F1B2 23                     INC    HL                   ;
3072: F1B3 B6                     OR     M                    ; OR it with the second byte        ;
3073: F1B4 2B                     DEC    HL                   ; Restore HL to start               ;
3074: F1B5 C0                     RET    NZ                   ; Exit if both are 0s               ;
3075: F1B6         ; HL points to a non Zero value	                                            ;
3076: F1B6 1A                     LD     A,(DE)               ; Get the first byte                ;
3077: F1B7 77                     LD     (HL),A               ; Move it                           ;
3078: F1B8 13                     INC    DE                   ;
3079: F1B9 23                     INC    HL                   ; Increment both pointers           ;
3080: F1BA 1A                     LD     A,(DE)               ; Get the second byte               ;
3081: F1BB 77                     LD     (HL),A               ; Move it                           ;
3082: F1BC 1B                     DEC    DE                   ;
3083: F1BD 2B                     DEC    HL                   ; Restore HL & DE to start          ;
3084: F1BE C9                     RET                         ;
3085: F1BF         ;----------------------------- Merge ---------------------------------------;
3086: F1BF
3087: F1BF         ; GU
3088: F1BF
3089: F1BF         ;=========================== General   Utilities ===========================;
3090: F1BF
3091: F1BF         ;--------------------------- Read Directory Record -------------------------;
3092: F1BF         ; read a directory entry into the directory buffer                          ;
3093: F1BF             ReadDirRecord:                      ;
3094: F1BF CD 03 EF               CALL   SetDirDMA            ; System Assigned Buffer            ;
3095: F1C2 CD 0C EF               CALL   ReadBuffer           ; Go to BIOS for the read           ;
3096: F1C5 C3 FE EE               JP     SetDataDMA           ; Restore DMA                       ;
3097: F1C8         ;--------------------------- Read Directory Record -------------------------;
3098: F1C8
3099: F1C8         ;--------------------------- Read Directory --------------------------------;
3100: F1C8         ; Read next directory entry                                                 ;
3101: F1C8         ; Enter :                                                                   ;
3102: F1C8         ;		C =  TRUE initializing and setting CheckSum                         ;
3103: F1C8         ;		  <> TRUE Checking existing CheckSum                                ;
3104: F1C8             ReadDirectory:                      ;
3105: F1C8 ED 5B 7C F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
3106: F1CC 2A 99 F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
3107: F1CF 23                     INC    HL                   ; Increment the Index               ;
3108: F1D0 22 99 F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
3109: F1D3 AF                     XOR    A                    ; Clear the CY flag                 ;
3110: F1D4 ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
3111: F1D6 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
3112: F1D8 CD 77 F0               CALL   SetEndDirectory      ;  else we are done                 ;
3113: F1DB C9                     RET                         ;
3114: F1DC         ;
3115: F1DC         ; Calculate the entry index Position in Buffer                              ;
3116: F1DC             ReadDirectory0:                      ;
3117: F1DC 3A 99 F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
3118: F1DF E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
3119: F1E1 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
3120: F1E3             ReadDirectory1:                      ;
3121: F1E3 87                     ADD    A,A                  ;
3122: F1E4 10 FD                  DJNZ   ReadDirectory1       ;
3123: F1E6 32 98 F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
3124: F1E9 B7                     OR     A                    ; Is this the 1st entry?            ;
3125: F1EA C0                     RET    NZ                   ;  return if not.                   ;
3126: F1EB         ;
3127: F1EB C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
3128: F1EC CD F6 F1               CALL   SeekDir              ; Set up for Directory Read         ;
3129: F1EF CD BF F1               CALL   ReadDirRecord        ; Read the directory record         ;
3130: F1F2 C1                     POP    BC                   ; Recall initialization flag        ;
3131: F1F3 C3 41 F2               JP     CheckSumUtility      ; Checksum the directory            ;
3132: F1F6         ;--------------------------- Read Directory --------------------------------;
3133: F1F6         ;--------------------------- Seek Directory --------------------------------;
3134: F1F6         ;seek the record containing the current directory entry					;
3135: F1F6             SeekDir:                        ;
3136: F1F6 2A 99 F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
3137: F1F9 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
3138: F1FB CD 9F F1               CALL   ShiftRightHLbyB      ;
3139: F1FE 22 96 F5               LD     (absoluteCPMRecord),HL ;
3140: F201 22 9B F5               LD     (dirRecord),HL       ; Save                              ;
3141: F204 C3 07 F2               JP     Seek                 ;
3142: F207         ;--------------------------- Seek Directory --------------------------------;
3143: F207         ;--------------------------- Seek ------------------------------------------;
3144: F207             Seek:                           ;
3145: F207 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
3146: F20A 2A 96 F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
3147: F20D ED 5B 75 F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
3148: F211         ;
3149: F211             Seek0:                          ;
3150: F211 03                     INC    BC                   ; Divide the record                 ;
3151: F212 AF                     XOR    A                    ;  by the sectors per track         ;
3152: F213 ED 52                  SBC    HL,DE                ;
3153: F215 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
3154: F217         ;
3155: F217         ;
3156: F217 19                     ADD    HL,DE                ; Gets the sector in the track      ;
3157: F218 E5                     PUSH   HL                   ; Save Index Sector                 ;
3158: F219         ;
3159: F219 DD 2A 69 F5               LD     IX,(caTrack)         ;
3160: F21D DD 71 00               LD     (IX+0),C             ;
3161: F220 DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
3162: F223         ;
3163: F223 EB                     EX     DE,HL                ; Take the index from the record    ;
3164: F224 2A 96 F5               LD     HL,(absoluteCPMRecord) ;
3165: F227 AF                     XOR    A                    ;
3166: F228 ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
3167: F22A         ;
3168: F22A DD 2A 6B F5               LD     IX,(caSector)        ;
3169: F22E DD 75 00               LD     (IX+0),L             ;
3170: F231 DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
3171: F234         ;
3172: F234 2A 82 F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
3173: F237 09                     ADD    HL,BC                ;  to add to the gross Track        ;
3174: F238 E5                     PUSH   HL                   ;  which yields the net or          ;
3175: F239 C1                     POP    BC                   ;  actual track for the record      ;
3176: F23A CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
3177: F23D         ;
3178: F23D C1                     POP    BC                   ; Get the sector within the track   ;
3179: F23E C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
3180: F241         ;
3181: F241         ;--------------------------- Seek ------------------------------------------;
3182: F241         ;--------------------------- Check Sum Utility -----------------------------;
3183: F241         ; At entry                                                                  ;
3184: F241         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
3185: F241         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
3186: F241         ;
3187: F241             CheckSumUtility:                      ;
3188: F241 2A 80 F5               LD     HL,(dpbCKS)          ;
3189: F244 ED 5B 9B F5               LD     DE,(dirRecord)       ;
3190: F248 AF                     XOR    A                    ;
3191: F249 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
3192: F24B D8                     RET    C                    ;  Entries                      ;
3193: F24C         ;
3194: F24C C5                     PUSH   BC                   ; Save New/Validate Flag        ;
3195: F24D         ;
3196: F24D         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
3197: F24D             ComputeCheckSum:                      ;
3198: F24D 06 80                  LD     B,cpmRecordSize      ;
3199: F24F 2A 6D F5               LD     HL,(caDirectoryDMA)  ;
3200: F252 EE 00                  XOR                         ;
3201: F254             ComputeCheckSum1:                      ;
3202: F254 86                     ADD    A,(HL)               ;
3203: F255 23                     INC    HL                   ;
3204: F256 10 FC                  DJNZ   ComputeCheckSum1     ;
3205: F258         ; Checksum is in ACC	                                                    ;
3206: F258         ;
3207: F258 2A 71 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
3208: F25B ED 5B 9B F5               LD     DE,(dirRecord)       ; Index to this record              ;
3209: F25F 19                     ADD    HL,DE                ; Address of this record in vector  ;
3210: F260 C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
3211: F261 0C                     INC    C                    ;
3212: F262 CA 6F F2               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
3213: F265         ;
3214: F265 BE                     CP     M                    ; Else we are checking the value    ;
3215: F266 C8                     RET    Z                    ; Exit if OK                        ;
3216: F267         ; possible checksum error, are we beyond the end of the disk?               ;
3217: F267 CD 9E F0               CALL   StillInDirectory     ;
3218: F26A D0                     RET    NC                   ; OK, if not in the directory       ;
3219: F26B CD 14 EF               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
3220: F26E C9                     RET                         ;  Set disk RO before returning     ;
3221: F26F         ;
3222: F26F         ;initializing the checksum                                                 ;
3223: F26F             SetNewCheckSum:                      ;
3224: F26F 77                     LD     (HL),A               ;
3225: F270 C9                     RET                         ;
3226: F271         ;--------------------------- Check Sum Utility -----------------------------;
3227: F271
3228: F271
3229: F271         ;---------------------
3230: F271         ;update variables from I/O in  fcb
3231: F271             UpdateRecordVars:
3232: F271 CD 7B EF               CALL   GetFcbRecordDetails  ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
3233: F274 3A 89 F5               LD     A,(seqReadFlag)
3234: F277 4F                     LD     C,A                  ; =1 if sequential i/o
3235: F278 3A 94 F5               LD     A,(currentFileRecord) ; get NEXT_RECORD
3236: F27B 81                     ADD    A,C
3237: F27C 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=current File Record+seqReadFlag
3238: F27D EB                     EX     DE,HL
3239: F27E 3A 92 F5               LD     A,(fcbRecordCount)
3240: F281 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
3241: F282 C9                     RET
3242: F283         ;---------------------
3243: F283         ;set file Attributes for current fcb
3244: F283             SetAttributes:
3245: F283 0E 0C                  LD     C,fcbExtIndex
3246: F285 CD E2 EF               CALL   SearchForDirectoryRecord ; through file type
3247: F288             SetAttributes1:
3248: F288 CD 7E F0               CALL   AtEndOfDirectory
3249: F28B C8                     RET    Z                    ; exit at end of dir
3250: F28C 0E 00                  LD     C,0
3251: F28E 1E 0C                  LD     E,fcbExtIndex        ;copy name
3252: F290 CD 79 F1               CALL   CopyDir
3253: F293 CD F7 EF               CALL   GetNextDirectoryRecord
3254: F296 C3 88 F2               JP     SetAttributes1
3255: F299         ;
3256: F299         ;*****************************************************************
3257: F299
3258: F299         ;*****************************************************************
3259: F299         ;********************** File  Routines ***************************
3260: F299         ;-----------------------------------------------------------------
3261: F299         ;-----------------------------------------------------------------
3262: F299         ;read sequential
3263: F299         ;IN  - (DE) FCB address
3264: F299         ;OUT - (A) 00 = success and data available. else no read and no data
3265: F299             vReadSeq:                       ; func20: (20 - 14) read sequential
3266: F299 CD 37 EF               CALL   ReselectDisk
3267: F29C CD A7 F2               CALL   ReadSeq
3268: F29F C9                     RET
3269: F2A0         ;-----------------------------------------------------------------
3270: F2A0         ;write sequential
3271: F2A0         ;IN  - (DE) FCB address
3272: F2A0         ;OUT - (A) 00 = success and data available. else no read and no data
3273: F2A0             vWriteSeq:                      ; func21 (21 - 15) write sequention
3274: F2A0 CD 37 EF               CALL   ReselectDisk
3275: F2A3 CD EA F2               CALL   DiskWriteSeq
3276: F2A6 C9                     RET
3277: F2A7         ;-----------------------------------------------------------------
3278: F2A7         ;-----------------------------------------------------------------
3279: F2A7         ;*****************************************************************
3280: F2A7
3281: F2A7         ;-----------------------------------------------------------------
3282: F2A7         ;sequential disk read operation
3283: F2A7             ReadSeq:
3284: F2A7 3E 01                  LD     A,1
3285: F2A9 32 89 F5               LD     (seqReadFlag),A      ; set flag for seqential read
3286: F2AC         ;---
3287: F2AC         ; read the disk
3288: F2AC         ; read the next record from the current fcb
3289: F2AC             DiskRead:
3290: F2AC 3E FF                  LD     A,TRUE
3291: F2AE 32 87 F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
3292: F2B1
3293: F2B1 CD 64 EF               CALL   SetRecordVars        ; sets current File Record, fcbRecordCount and EXM
3294: F2B4 3A 94 F5               LD     A,(currentFileRecord)
3295: F2B7 21 92 F5               LD     HL,fcbRecordCount
3296: F2BA BE                     CP     M                    ; current File Record-fcbRecordCount
3297: F2BB         ; skip if  current File Record < fcbRecordCount
3298: F2BB DA D1 F2               JP     C,RecordOK
3299: F2BE         ; not enough records in the extent
3300: F2BE FE 80                  CP     RecordsPerExtent     ; current File Record = 128?   *** Records in an Extent
3301: F2C0 C2 E7 F2               JP     NZ,DiskEOF           ; skip if current File Record<>128
3302: F2C3 CD B2 F3               CALL   OpenNextExt          ; go to next extent if so
3303: F2C6 AF                     XOR    A
3304: F2C7 32 94 F5               LD     (currentFileRecord),A ; current File Record=00
3305: F2CA         ; now check for open ok
3306: F2CA 3A C5 EA               LD     A,(exitParameterByte)
3307: F2CD B7                     OR     A
3308: F2CE C2 E7 F2               JP     NZ,DiskEOF
3309: F2D1         ; stop at eof
3310: F2D1         ; arrive with fcb addressing a record to read
3311: F2D1             RecordOK:                       ; recordok:
3312: F2D1 CD 15 F4               CALL   GetBlockNumber       ; save it in Absolute CPM Record
3313: F2D4 CD 22 F4               CALL   IsAllocated          ; Absolute CPM Record=0000?
3314: F2D7 CA E7 F2               JP     Z,DiskEOF            ; get out if not allocated already
3315: F2DA
3316: F2DA CD 28 F4               CALL   SetActualRecordAdd   ; Absolute CPM Record now a record value
3317: F2DD CD 07 F2               CALL   Seek                 ; to proper track,sector
3318: F2E0 CD 0C EF               CALL   ReadBuffer           ; to dma address
3319: F2E3 CD 71 F2               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
3320: F2E6 C9                     RET
3321: F2E7             DiskEOF:                        ; diskeof:
3322: F2E7 C3 41 F4               JP     SetLowReturnTo1      ; exitParameterByte = 1
3323: F2EA         ;ret
3324: F2EA         ;-----------------------------------------------------------------
3325: F2EA         ;sequential disk write
3326: F2EA             DiskWriteSeq:
3327: F2EA 3E 01                  LD     A,1
3328: F2EC 32 89 F5               LD     (seqReadFlag),A
3329: F2EF         ;--------
3330: F2EF         ;disk write
3331: F2EF             DiskWrite:
3332: F2EF 3E 00                  LD     A,FALSE
3333: F2F1 32 87 F5               LD     (readModeFlag),A
3334: F2F4         ; write record to currently selected file
3335: F2F4 CD 61 F1               CALL   CheckWrite           ; in case write protected
3336: F2F7 2A C3 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
3337: F2FA CD 6B F1               CALL   CheckROFile          ; may be a read-only file
3338: F2FD CD 64 EF               CALL   SetRecordVars        ; set local Record parameters
3339: F300 3A 94 F5               LD     A,(currentFileRecord)
3340: F303 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
3341: F305 DA 0C F3               JP     C,DiskWrite1         ; skip if in the same Extent
3342: F308 CD 41 F4               CALL   SetLowReturnTo1
3343: F30B C9                     RET                         ; Exit ???????????
3344: F30C
3345: F30C         ; can write the next record, so continue
3346: F30C             DiskWrite1:
3347: F30C CD 15 F4               CALL   GetBlockNumber       ; sets up actual block number
3348: F30F CD 22 F4               CALL   IsAllocated
3349: F312 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
3350: F314 C2 62 F3               JP     NZ,DiskWrite3
3351: F317         ; not allocated -
3352: F317         ; the argument to getblock is the starting position for the disk search
3353: F317         ; and should be the last allocated block for this file,
3354: F317         ; or the value 0 if no space has been allocated
3355: F317
3356: F317 CD 47 F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
3357: F31A 32 8A F5               LD     (diskMapIndex),A     ; save for later
3358: F31D 01 00 00               LD     BC,0000h             ; may use block zero
3359: F320 B7                     OR     A
3360: F321 CA 2B F3               JP     Z,FirstBlock         ; skip if no previous block
3361: F324         ; previous block exists
3362: F324 4F                     LD     C,A
3363: F325 0B                     DEC    BC                   ; previous block # in BC
3364: F326 CD 67 F4               CALL   GetDiskMapValue      ; previous block # to HL
3365: F329 44                     LD     B,H
3366: F32A 4D                     LD     C,L                  ; BC=prev block#
3367: F32B         ; BC = 0000, or previous block #
3368: F32B             FirstBlock:
3369: F32B         ;	CALL	GetClosestBlockXX					; block # to HL
3370: F32B CD D7 F0               CALL   GetClosestBlock
3371: F32E         ; arrive here with block# or zero
3372: F32E 7D                     LD     A,L
3373: F32F B4                     OR     H
3374: F330 C2 39 F3               JP     NZ,BlockOK
3375: F333         ; cannot find a block to allocate
3376: F333 3E 02                  LD     A,2
3377: F335 32 C5 EA               LD     (exitParameterByte),A
3378: F338 C9                     RET                         ; exitParameterByte=2
3379: F339
3380: F339             BlockOK:
3381: F339 22 96 F5               LD     (absoluteCPMRecord),HL ; allocated block number is in HL
3382: F33C EB                     EX     DE,HL                ; block number to DE
3383: F33D 2A C3 EA               LD     HL,(paramDE)
3384: F340 01 10 00               LD     BC,fcbDiskMapIndex
3385: F343 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
3386: F344 3A 8E F5               LD     A,(byteAllocationFlag)
3387: F347 B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
3388: F348 3A 8A F5               LD     A,(diskMapIndex)     ; recall dm index
3389: F34B CA 55 F3               JP     Z,Allocate16Bit      ; skip if allocating word
3390: F34E         ; else allocate using a byte value
3391: F34E CD 80 F4               CALL   AddAtoHL
3392: F351 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
3393: F352 C3 5D F3               JP     DiskWrite2           ; to continue
3394: F355
3395: F355             Allocate16Bit:                      ; allocate a word value
3396: F355
3397: F355 4F                     LD     C,A
3398: F356 06 00                  LD     B,0                  ; double(diskMapIndex)
3399: F358 09                     ADD    HL,BC
3400: F359 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
3401: F35A 72                     LD     (HL),D
3402: F35B 23                     INC    HL
3403: F35C 73                     LD     (HL),E               ; double wd
3404: F35D         ; disk write to previously unallocated block
3405: F35D             DiskWrite2:
3406: F35D 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
3407: F35F CD CB EF               CALL   ResetFileWriteFlag
3408: F362         ; continue the write operation of no allocation error
3409: F362         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
3410: F362
3411: F362             DiskWrite3:
3412: F362 3A C5 EA               LD     A,(exitParameterByte)
3413: F365 B7                     OR     A
3414: F366 C0                     RET    NZ                   ; stop if non zero returned value
3415: F367
3416: F367 C5                     PUSH   BC                   ; save write flag ( in C see above)
3417: F368 CD 28 F4               CALL   SetActualRecordAdd   ; Absolute CPM Record set to actual record number
3418: F36B CD 07 F2               CALL   Seek                 ; to proper file position
3419: F36E C1                     POP    BC                   ; get write flag
3420: F36F C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
3421: F370 CD 6F F0               CALL   WriteBuffer          ; written to disk
3422: F373 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
3423: F374         ; increment record count if fcbRecordCount<=current File Record
3424: F374 3A 94 F5               LD     A,(currentFileRecord)
3425: F377 21 92 F5               LD     HL,fcbRecordCount
3426: F37A BE                     CP     M                    ; current File Record-fcbRecordCount
3427: F37B DA 82 F3               JP     C,DiskWrite4
3428: F37E         ; fcbRecordCount <= current File Record
3429: F37E 77                     LD     (HL),A
3430: F37F 34                     INC    M                    ; fcbRecordCount = current File Record+1
3431: F380 0E 02                  LD     C,2                  ; mark as record count incremented
3432: F382             DiskWrite4:
3433: F382         ; A has current File Record, C=2 if new block or new record#
3434: F382 0D                     DEC    C
3435: F383 0D                     DEC    C
3436: F384 C2 8F F3               JP     NZ,DiskWrite5
3437: F387 F5                     PUSH   AF                   ; save current File Record value
3438: F388 CD BC EF               CALL   GetExtentNumberMSB   ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3439: F38B         ; reset the file write flag to mark as written fcb
3440: F38B E6 7F                  AND    7FH                  ; not writeFlagMask
3441: F38D 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
3442: F38E F1                     POP    AF                   ; restore current File Record
3443: F38F             DiskWrite5:
3444: F38F         ; check for end of extent, if found attempt to open next extent in preparation for next write
3445: F38F FE 7F                  CP     highestRecordNumber  ; current File Record=highestRecordNumber?
3446: F391 C2 AF F3               JP     NZ,DiskWrite7        ; skip if not
3447: F394         ; may be random access write, if so we are done
3448: F394 3A 89 F5               LD     A,(seqReadFlag)
3449: F397 B7                     OR     A
3450: F398 CA AF F3               JP     Z,DiskWrite7         ; skip next extent open op
3451: F39B         ; update current fcb before going to next extent
3452: F39B CD 71 F2               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
3453: F39E CD B2 F3               CALL   OpenNextExt          ; readModeFlag=false
3454: F3A1         ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
3455: F3A1 21 C5 EA               LD     HL,exitParameterByte
3456: F3A4 7E                     LD     A,(HL)
3457: F3A5 B7                     OR     A
3458: F3A6 C2 AD F3               JP     NZ,DiskWrite6        ; no space
3459: F3A9         ; space available, set current File Record=255
3460: F3A9 3D                     DEC    A
3461: F3AA 32 94 F5               LD     (currentFileRecord),A ; goes to 00 next time
3462: F3AD             DiskWrite6:
3463: F3AD 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
3464: F3AF             DiskWrite7:
3465: F3AF C3 71 F2               JP     UpdateRecordVars     ; update variables from I/O in  fcb
3466: F3B2         ;ret
3467: F3B2         ;-----------------------------------------------------------------
3468: F3B2         ;close the current extent  and open the next one if possible.
3469: F3B2         ;readModeFlag is true if in read mode
3470: F3B2             OpenNextExt:                      ; open$reel
3471: F3B2 AF                     XOR    A
3472: F3B3 32 86 F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
3473: F3B6 CD 10 EE               CALL   CloseDirEntry        ; close current extent
3474: F3B9         ; exitParameterByte remains at enddir if we cannot open the next ext
3475: F3B9 CD 7E F0               CALL   AtEndOfDirectory
3476: F3BC C8                     RET    Z                    ; return if end
3477: F3BD 2A C3 EA               LD     HL,(paramDE)         ; increment extent number
3478: F3C0 01 0C 00               LD     BC,fcbExtIndex
3479: F3C3 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
3480: F3C4 7E                     LD     A,(HL)
3481: F3C5 3C                     INC    A
3482: F3C6 E6 1F                  AND    maxExtValue
3483: F3C8 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
3484: F3C9 CA DB F3               JP     Z,OpenNextModule     ; move to next module if zero
3485: F3CC         ; may be in the same extent group
3486: F3CC 47                     LD     B,A
3487: F3CD 3A 79 F5               LD     A,(dpbEXM)
3488: F3D0 A0                     AND    B
3489: F3D1         ; if result is zero, then not in the same group
3490: F3D1 21 86 F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
3491: F3D4 A6                     AND    M                    ; produces a 00 in accumulator if not written
3492: F3D5 CA E6 F3               JP     Z,OpenNextExt1       ; go to next physical extent
3493: F3D8         ; result is non zero, so we must be in same logical ext
3494: F3D8 C3 04 F4               JP     OpenNextExt2         ; to copy fcb information
3495: F3DB         ; extent number overflow, go to next module
3496: F3DB
3497: F3DB             OpenNextModule:
3498: F3DB 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
3499: F3DE 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
3500: F3DF 34                     INC    M                    ; fcb(fcbS2Index)=++1
3501: F3E0         ; module number incremented, check for overflow
3502: F3E0 7E                     LD     A,(HL)
3503: F3E1 E6 0F                  AND    moduleMask           ; mask high order bits
3504: F3E3 CA 0F F4               JP     Z,OpenNextExtError   ; cannot overflow to zero
3505: F3E6         ; otherwise, ok to continue with new module
3506: F3E6
3507: F3E6             OpenNextExt1:
3508: F3E6 0E 0F                  LD     C,nameLength
3509: F3E8 CD E2 EF               CALL   SearchForDirectoryRecord ; next extent found?
3510: F3EB CD 7E F0               CALL   AtEndOfDirectory
3511: F3EE C2 04 F4               JP     NZ,OpenNextExt2
3512: F3F1         ; end of file encountered
3513: F3F1 3A 87 F5               LD     A,(readModeFlag)
3514: F3F4 3C                     INC    A                    ; 0ffh becomes 00 if read
3515: F3F5 CA 0F F4               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
3516: F3F8         ; try to extend the current file
3517: F3F8 CD 90 EE               CALL   MakeNewFile
3518: F3FB         ; cannot be end of directory
3519: F3FB CD 7E F0               CALL   AtEndOfDirectory
3520: F3FE CA 0F F4               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
3521: F401 C3 07 F4               JP     OpenNextExt3
3522: F404
3523: F404         ; not end of file, open
3524: F404             OpenNextExt2:
3525: F404 CD D6 ED               CALL   CopyDirRecordToFCB
3526: F407             OpenNextExt3:
3527: F407 CD 64 EF               CALL   SetRecordVars        ; Set Record parameters
3528: F40A AF                     XOR    A
3529: F40B 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
3530: F40E C9                     RET                         ; with exitParameterByte = 0
3531: F40F
3532: F40F         ; cannot move to next extent of this file
3533: F40F             OpenNextExtError:
3534: F40F CD 41 F4               CALL   SetLowReturnTo1      ; exitParameterByte = 1
3535: F412 C3 C5 EF               JP     SetFileWriteFlag     ; ensure that it will not be closed
3536: F415         ;-----------------------------------------------------------------
3537: F415         ;-----------------------------------------------------------------
3538: F415
3539: F415         ;-----------------------------------------------------------------
3540: F415         ;-----------------------------------------------------------------
3541: F415
3542: F415
3543: F415         ;-----------------------------------------------------------------
3544: F415         ;compute disk block number from current fcb
3545: F415             GetBlockNumber:
3546: F415 CD 47 F4               CALL   GetDiskMapIndex      ; 0...15 in register A
3547: F418 4F                     LD     C,A
3548: F419 06 00                  LD     B,0
3549: F41B CD 67 F4               CALL   GetDiskMapValue      ; return value in HL
3550: F41E 22 96 F5               LD     (absoluteCPMRecord),HL ; save for later
3551: F421 C9                     RET
3552: F422         ;-----------------------------------------------------------------
3553: F422         ;is  block allocated
3554: F422             IsAllocated:
3555: F422 2A 96 F5               LD     HL,(absoluteCPMRecord)
3556: F425 7D                     LD     A,L
3557: F426 B4                     OR     H
3558: F427 C9                     RET
3559: F428         ;-----------------------------------------------------------------
3560: F428         ;compute actual record address
3561: F428         ; result = absolute CPMRecord * ( 2**BSH)
3562: F428             SetActualRecordAdd:
3563: F428 3A 77 F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
3564: F42B 2A 96 F5               LD     HL,(absoluteCPMRecord)
3565: F42E
3566: F42E             SetActualRecordAdd1:
3567: F42E 29                     ADD    HL,HL
3568: F42F 3D                     DEC    A                    ; shl(absolute CPMRecord,dpbBSH)
3569: F430 C2 2E F4               JP     NZ,SetActualRecordAdd1
3570: F433         ; HL has Record number for start of the block;
3571: F433 3A 78 F5               LD     A,(dpbBLM)           ; get block mask
3572: F436 4F                     LD     C,A                  ; to get current File Record mod Block
3573: F437 3A 94 F5               LD     A,(currentFileRecord) ; get index into block
3574: F43A A1                     AND    C                    ; masked value in A
3575: F43B B5                     OR     L
3576: F43C 6F                     LD     L,A                  ; to HL
3577: F43D 22 96 F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL or (current File Record and dpbBLM)
3578: F440         ; *** Absolute CPM Record now has current record number - Starting record number + index into block
3579: F440 C9                     RET
3580: F441         ;-----------------------------------------------------------------
3581: F441         ;---------------------------------- Is Bit Set ------------------------------;
3582: F441
3583: F441
3584: F441
3585: F441         ;---------------------
3586: F441         ;set exitParameterByte to 1
3587: F441             SetLowReturnTo1:
3588: F441 3E 01                  LD     A,1
3589: F443 32 C5 EA               LD     (exitParameterByte),A
3590: F446 C9                     RET
3591: F447         ;---------------------
3592: F447         ;---------------------
3593: F447         ;Return the  disk map Index for current File Record in the ACC
3594: F447         ;  account for multiple extents in 1 physical Directory entry
3595: F447             GetDiskMapIndex:                      ; dm$position
3596: F447 21 77 F5               LD     HL,dpbBSH            ; get block shift value
3597: F44A 4E                     LD     C,(HL)               ; shift count to C
3598: F44B 3A 94 F5               LD     A,(currentFileRecord) ; current virtual record to A
3599: F44E             GetDiskMapIndex1:
3600: F44E B7                     OR     A                    ; reset the carry flag
3601: F44F 1F                     RRA
3602: F450 0D                     DEC    C
3603: F451 C2 4E F4               JP     NZ,GetDiskMapIndex1
3604: F454         ; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
3605: F454         ; A has the relative position in the block.
3606: F454 47                     LD     B,A                  ; save it for later addition
3607: F455 3E 08                  LD     A,8
3608: F457 96                     SUB    M                    ; 8-dpbBSH to accumulator
3609: F458 4F                     LD     C,A                  ; extent shift count in register c
3610: F459 3A 93 F5               LD     A,(extentValue)      ; extent value ani extmsk
3611: F45C             GetDiskMapIndex2:                      ; dmpos1:
3612: F45C         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3613: F45C         ; shift is 4,3,2,1,0
3614: F45C 0D                     DEC    C
3615: F45D CA 65 F4               JP     Z,GetDiskMapIndex3
3616: F460 B7                     OR     A                    ; clear the carry flag
3617: F461 17                     RLA
3618: F462 C3 5C F4               JP     GetDiskMapIndex2
3619: F465
3620: F465         ; The ACC has the Block Number for this record
3621: F465             GetDiskMapIndex3:
3622: F465         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3623: F465 80                     ADD    A,B                  ; add the previous shr(current File Record,dpbBSH) value
3624: F466         ; A is one of the following values, depending upon alloc
3625: F466         ; bks dpbBSH
3626: F466         ; 1k   3     v/8 + extentValue * 16
3627: F466         ; 2k   4     v/16+ extentValue * 8
3628: F466         ; 4k   5     v/32+ extentValue * 4
3629: F466         ; 8k   6     v/64+ extentValue * 2
3630: F466         ; 16k  7     v/128+extentValue * 1
3631: F466 C9                     RET                         ; with disk map position in A
3632: F467         ;---------------------
3633: F467         ; Enter with Disk Map Index in BG
3634: F467         ; Return disk map value  in HL
3635: F467             GetDiskMapValue:
3636: F467 2A C3 EA               LD     HL,(paramDE)         ; base address of file control block
3637: F46A 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3638: F46D 19                     ADD    HL,DE                ; HL =.diskmap
3639: F46E 09                     ADD    HL,BC                ; index by a  byte value
3640: F46F 3A 8E F5               LD     A,(byteAllocationFlag) ;  byte map entry?
3641: F472 B7                     OR     A
3642: F473 CA 7A F4               JP     Z,GetDiskMap16Bit    ; get disk map  byte
3643: F476 6E                     LD     L,(HL)
3644: F477 26 00                  LD     H,0
3645: F479 C9                     RET                         ; with HL=00bb
3646: F47A             GetDiskMap16Bit:                      ; getdmd:
3647: F47A 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3648: F47B         ; double precision value returned
3649: F47B 56                     LD     D,(HL)
3650: F47C 23                     INC    HL
3651: F47D 5E                     LD     E,(HL)
3652: F47E EB                     EX     DE,HL
3653: F47F C9                     RET
3654: F480         ;---------------------
3655: F480         ;---------------------
3656: F480         ;*****************************************************************
3657: F480         ;************************ Utilities ******************************
3658: F480         ;*****************************************************************
3659: F480             AddAtoHL:
3660: F480 85                     ADD    A,L
3661: F481 6F                     LD     L,A
3662: F482 D0                     RET    NC
3663: F483 24                     INC    H
3664: F484 C9                     RET
3665: F485         ;----------
3666: F485             DEminusHL2HL:
3667: F485 7B                     LD     A,E
3668: F486 95                     SUB    L
3669: F487 6F                     LD     L,A
3670: F488 7A                     LD     A,D
3671: F489 9C                     SBC    A,H
3672: F48A 67                     LD     H,A
3673: F48B C9                     RET
3674: F48C         ;-------------
3675: F48C             ShiftRightHLbyC:
3676: F48C 0C                     INC    C
3677: F48D             ShiftRightHLbyC0:
3678: F48D 0D                     DEC    C
3679: F48E C8                     RET    Z
3680: F48F 7C                     LD     A,H
3681: F490 B7                     OR     A
3682: F491 1F                     RRA
3683: F492 67                     LD     H,A
3684: F493 7D                     LD     A,L
3685: F494 1F                     RRA
3686: F495 6F                     LD     L,A
3687: F496 C3 8D F4               JP     ShiftRightHLbyC0
3688: F499         ;-------
3689: F499             ShiftLeftHLbyC:
3690: F499 0C                     INC    C
3691: F49A             ShiftLeftHLbyC0:
3692: F49A 0D                     DEC    C
3693: F49B C8                     RET    Z                    ; exit when done
3694: F49C 29                     ADD    HL,HL
3695: F49D C3 9A F4               JP     ShiftLeftHLbyC0
3696: F4A0         ;*****************************************************************
3697: F4A0         ;? ;move data length of length C from source DE to HL
3698: F4A0         ;? MoveX:
3699: F4A0         ;?	INC		C
3700: F4A0         ;? MoveX0:
3701: F4A0         ;?	DEC		C
3702: F4A0         ;?	RET	Z
3703: F4A0         ;?	LD	A,(DE)
3704: F4A0         ;?	LD		(HL),A
3705: F4A0         ;?	INC		DE
3706: F4A0         ;?	INC		HL
3707: F4A0         ;?	JP		MoveX0
3708: F4A0         ;?
3709: F4A0         ;********** Console OUT Routines*******************??????
3710: F4A0
3711: F4A0         ;---------------------------------- Is Bit Set ------------------------------;
3712: F4A0         ; Enter HL  contains the bit map                                             ;
3713: F4A0         ;       B   Has the bit number (0...F)                                       ;
3714: F4A0         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3715: F4A0         ;              = 0 if bit is set (1)                                         ;
3716: F4A0             IsBitSet:                       ;
3717: F4A0 04                     INC    B                    ;
3718: F4A1             IsBitSetLoop:                      ;
3719: F4A1 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3720: F4A2 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3721: F4A4 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3722: F4A6 3F                     CCF                         ; else Clear Carry flag              ;
3723: F4A7             IsBitSet1:                      ;
3724: F4A7 CB 1C                  RR     H                    ; Shift thru CY                      ;
3725: F4A9 CB 1D                  RR     L                    ; ditto                              ;
3726: F4AB 10 F4                  DJNZ   IsBitSetLoop         ;
3727: F4AD CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3728: F4AF C9                     RET                         ;
3729: F4B0         ;---------------------------------- Is Bit Set ------------------------------;
3730: F4B0
3731: F4B0         ;============================ Set/Reset Vector Bit ==========================;
3732: F4B0         ;---------------------------------- Set Vector Bit -------------------------;;
3733: F4B0         ; Enter  HL  contains the bit map vector                                    ;;
3734: F4B0         ;        B   Has the bit number (0...F)                                     ;;
3735: F4B0         ; Return HL  Contains the modified bit map vector                           ;;
3736: F4B0             SetVectorBit:                      ;;
3737: F4B0 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3738: F4B1 CD A0 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3739: F4B4         ;;
3740: F4B4 C1                     POP    BC                   ; Get the bit position              ;;
3741: F4B5 CB FC                  SET    7,H                  ;;
3742: F4B7 18 07                  JR     ReAlignVector        ;                                    ;
3743: F4B9         ;---------------------------------- Set Vector Bit -------------------------;;
3744: F4B9         ;---------------------------------- Reset Vector Bit -----------------------;;
3745: F4B9         ; Enter  HL  contains the bit map vector                                    ;;
3746: F4B9         ;        B   Has the bit number (0...F)                                     ;;
3747: F4B9         ; Return HL  Contains the modified bit map vector                           ;;
3748: F4B9             ResetVectorBit:                      ;;
3749: F4B9 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3750: F4BA CD A0 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3751: F4BD         ;;
3752: F4BD C1                     POP    BC                   ; Get the bit position              ;;
3753: F4BE CB BC                  RES    7,H                  ;;
3754: F4C0         ; Fall thru to ReAlignVector                                                 ;
3755: F4C0         ;---------------------------------- Reset Vector Bit -----------------------;;
3756: F4C0         ;---------------------------------- Set VectorBit --------------------------;;
3757: F4C0         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3758: F4C0         ;
3759: F4C0             ReAlignVector:                      ;
3760: F4C0 04                     INC    B                    ;
3761: F4C1             ReAlignMapLoop:                      ;
3762: F4C1 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3763: F4C2 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3764: F4C4 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3765: F4C6 3F                     CCF                         ; else Clear Carry flag              ;
3766: F4C7             ReAlignMap1:                      ;
3767: F4C7 CB 15                  RL     L                    ; Shift thru CY                      ;
3768: F4C9 CB 14                  RL     H                    ; ditto                              ;
3769: F4CB 10 F4                  DJNZ   ReAlignMapLoop       ;
3770: F4CD C9                     RET                         ;
3771: F4CE         ;============================ Set/Reset Vector Bit ==========================;
3772: F4CE         ;************Error message World*************************
3773: F4CE             errSelect:
3774: F4CE 21 ED F4               LD     HL,evSelection
3775: F4D1 C3 E6 F4               JP     GoToError
3776: F4D4             errReadOnlyDisk:
3777: F4D4 21 EF F4               LD     HL,evReadOnlyDisk
3778: F4D7 C3 E6 F4               JP     GoToError
3779: F4DA             errReadOnlyFile:
3780: F4DA 21 F1 F4               LD     HL,evReadOnlyFile
3781: F4DD C3 E6 F4               JP     GoToError
3782: F4E0             errPermanent:
3783: F4E0 21 EB F4               LD     HL,evPermanent
3784: F4E3 C3 E6 F4               JP     GoToError
3785: F4E6         ;************Error message handler **********************
3786: F4E6             GoToError:
3787: F4E6         ;HL = .errorhandler, call subroutine
3788: F4E6 5E                     LD     E,(HL)
3789: F4E7 23                     INC    HL
3790: F4E8 56                     LD     D,(HL)               ; address of routine in DE
3791: F4E9 EB                     EX     DE,HL
3792: F4EA E9                     JP     (HL)                 ; vector to subroutine
3793: F4EB         ;************ Error Vectors *****************************
3794: F4EB F9 F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3795: F4ED 05 F5       evSelection: DW     erSelection          ; selerr select error subroutine
3796: F4EF 0B F5       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3797: F4F1 11 F5       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3798: F4F3         ;************Error Routines ******************************
3799: F4F3             erPermanentNoWait:
3800: F4F3 21 43 F5               LD     HL,emPermanent
3801: F4F6 C3 E6 F4               JP     GoToError
3802: F4F9             erPermanent:
3803: F4F9 21 43 F5               LD     HL,emPermanent
3804: F4FC CD 1A F5               CALL   displayAndWait       ; to report the error
3805: F4FF FE 03                  CP     CTRL_C
3806: F501 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3807: F504 C9                     RET                         ; and ignore the error
3808: F505         ;
3809: F505             erSelection:
3810: F505 21 4E F5               LD     HL,emSelection
3811: F508 C3 14 F5               JP     waitB4boot           ; wait console before boot
3812: F50B         ;
3813: F50B             erReadOnlyDisk:
3814: F50B 21 5A F5               LD     HL,emReadOnlyDisk
3815: F50E C3 14 F5               JP     waitB4boot           ; wait console before boot
3816: F511         ;
3817: F511             erReadOnlyFile:
3818: F511 21 55 F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3819: F514         ;
3820: F514         ; wait for response before boot
3821: F514             waitB4boot:
3822: F514 CD 1A F5               CALL   displayAndWait
3823: F517 C3 00 00               JP     WarmBoot
3824: F51A
3825: F51A         ;report error to console, message address in HL
3826: F51A             displayAndWait:
3827: F51A E5                     PUSH   HL                   ; save message pointer
3828: F51B CD D6 E9               CALL   showCRLF             ; stack mssg address, new line
3829: F51E 3A 5F F5               LD     A,(currentDisk)
3830: F521 C6 41                  ADD    A,ASCII_A
3831: F523 32 3F F5               LD     (emDisk),A           ; Problem disk name
3832: F526 01 33 F5               LD     BC,emDisk0
3833: F529 CD 3B E9               CALL   Print                ; the error message
3834: F52C C1                     POP    BC
3835: F52D CD 3B E9               CALL   Print                ; error mssage tail
3836: F530 C3 21 E9               JP     ConIn                ; to get the input character
3837: F533         ;ret
3838: F533         ;**************Error Messages*******************************
3839: F533 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3840: F53F 20 3A 20 24     emDisk:    DB     ' : $'
3841: F543 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3842: F54E 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3843: F555 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3844: F55A 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3845: F55E         ;*****************************************************************
3846: F55E
3847: F55E         ;********* file control block (fcb) constants ********************
3848: F55E             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3849: F55E             fcbROfileIndex EQU    09H                  ; high order of first type char
3850: F55E             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3851: F55E             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3852: F55E             fcbS1Index EQU    0DH                  ;13				; S1 index
3853: F55E             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3854: F55E             fcbRCIndex EQU    0FH                  ;15				; record count field index
3855: F55E             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3856: F55E
3857: F55E             fcbCurrentRecord EQU    21H                  ;33
3858: F55E
3859: F55E             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3860: F55E
3861: F55E             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3862: F55E             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3863: F55E             dirEntryMask EQU    dirEntriesPerRecord-1
3864: F55E             fcbShift   EQU    5                    ; log2(fcbLength)
3865: F55E         ;
3866: F55E
3867: F55E
3868: F55E
3869: F55E             maxExtValue EQU    31                   ; largest extent number
3870: F55E             moduleMask EQU    15                   ; limits module number value
3871: F55E             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3872: F55E             nameLength EQU    15                   ; namlen name length
3873: F55E
3874: F55E             emptyDir   EQU    0E5H                 ; empty empty directory entry
3875: F55E             NEXT_RECORD EQU    fcbLength            ; nxtrec
3876: F55E             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3877: F55E         ;
3878: F55E         ;	reserved file indicators
3879: F55E         ;	equ	11				; reserved
3880: F55E         ;*****************************************************************
3881: F55E         ;*****************************************************************
3882: F55E
3883: F55E         ;***common values shared between bdosi and bdos******************
3884: F55E 00          currentUserNumber: DB     0                    ; usrcode current user number
3885: F55F         ; paramDE:			DS	2					; ParamsDE information address
3886: F55F         ; exitParameterByte:
3887: F55F         ; exitParameterWord:	DS	2					; address value to return
3888: F55F FF          currentDisk: DB     -1                   ; curdsk current disk number
3889: F560         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3890: F560
3891: F560         ;********************* Local Variables ***************************
3892: F560         ;     ************************
3893: F560         ;     *** Initialized Data ***
3894: F560
3895: F560 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3896: F561 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
3897: F563 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3898: F565 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3899: F567
3900: F567         ;     *** Current Disk attributes ****
3901: F567         ; These are set upon disk select
3902: F567         ; data must be adjacent, do not insert variables
3903: F567         ; address of translate vector, not used
3904: F567         ; ca - currentAddress
3905: F567
3906: F567 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3907: F569 00 00       caTrack:   DW     0000H                ; curtrka current track address
3908: F56B 00 00       caSector:  DW     0000H                ; current Sector
3909: F56D             caListSizeStart:
3910: F56D 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3911: F56F 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3912: F571 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3913: F573 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3914: F575             caListSizeEnd:
3915: F575             caListSize EQU    caListSizeEnd - caListSizeStart
3916: F575
3917: F575         ;     ***** Disk Parameter Block *******
3918: F575         ; data must be adjacent, do not insert variables
3919: F575         ; dpb - Disk Parameter Block
3920: F575             dpbStart:
3921: F575 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3922: F577 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3923: F578 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3924: F579 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3925: F57A 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3926: F57C 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3927: F57E 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3928: F580 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3929: F582 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3930: F584             dpbEnd:
3931: F584             dpbSize    EQU    dpbEnd - dpbStart
3932: F584         ;
3933: F584
3934: F584         ;     ************************
3935: F584
3936: F584 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3937: F586 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3938: F587 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3939: F588 00          directoryIndex: DB     00H                  ; dirloc directory flag in rename, etc.
3940: F589 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3941: F58A 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3942: F58B 00          searchLength: DB     00H                  ; searchl search length
3943: F58C 00 00       searchAddress: DW     0000H                ; searcha search address
3944: F58E         ;tinfo:	ds	word							; temp for info in "make"
3945: F58E 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3946: F58F 00          fResel:    DB     00H                  ; resel reselection flag
3947: F590 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3948: F591 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3949: F592 00          fcbRecordCount: DB     00H                  ; record count from current FCB
3950: F593 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3951: F594 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3952: F596 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3953: F598         ;
3954: F598         ;	local variables for directory access
3955: F598 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3956: F599 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3957: F59B 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3958: F59D
3959: F59D         ;********************** data areas ******************************
3960: F59D
3961: F59D
3962: F59D         ;---------------------------------- Stack Area--------------------------------;
3963: F59D             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3964: F5DD             bdosStack:
3965: F5DD         ;
3966: F5DD         ;---------------------------------- Stack Area--------------------------------;
3967: F5DD         ;	end of Basic I/O System
3968: F5DD         ;-----------------------------------------------------------------;
3969: F5DD
3970: F5DD
3971: F5DD         ;
3972: F5DD             Z_HighestLocation:
3973: F5DD             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3974: F5DD
3975: F5DD
           ************************   Xref   ************************
0000: $               F5DD   0418 0448
3952: absoluteCPMRecord F596   3139 3146 3164 3381 3550 3555 3564 3577
3659: AddAtoHL        F480   3391
3395: Allocate16Bit   F355   3389
1045: AreWeAtEndOfBuffer EA3A   1041
0086: ASCII_A         0041   3830
0087: ASCII_C         0043
0088: ASCII_K         004B
0095: ASCII_LO_A      0061
0096: ASCII_LO_K      006B
0097: ASCII_LO_P      0070
0038: ASCII_MASK      007F   0988
0089: ASCII_N         004E
0090: ASCII_Q         0051
0091: ASCII_R         0052
0092: ASCII_W         0057
0093: ASCII_Y         0059
0073: ASCII_ZERO      0030
0067: ASTERISK        002A
2756: AtEndOfDirectory F07E   1437 1517 1917 2138 2169 2227 2319 2647 3248 3475 3510 3519
1137: BackUp          EA9F   1065 1133
1142: BackUp1         EAA7   1138
0295: bcBoot          F600
0298: bcConin         F609   0618 0803 0914 0932
0299: bcConout        F60C   0610 0876 1140 1144 1150 1152
0297: bcConst         F606   0615 0910
0303: bcHome          F618   2384
0300: bcList          F60F   0583 0882
0310: bcListst        F62D
0301: bcPunch         F612   0568
0308: bcRead          F627   2426
0302: bcReader        F615   0549
0311: bcSectran       F630
0304: bcSeldsk        F61B   2041
0307: bcSetdma        F624   2421
0306: bcSetsec        F621   3179
0305: bcSettrk        F61E   2390 3176
0296: bcWboot         F603   0469
0309: bcWrite         F62A   2735
0153: BDOSBase        E800   0154 0156 0327
0122: BDOSE           0005   0123
0154: BDOSEntry       E800
0143: BDOSLength      0E00   0146 0156 0157
3964: bdosStack       F5DD   0343
0333: BdosStart       E800
0056: BELL            0007
0156: BIOSBase        F600
0144: BIOSLength      0A00   0146
0116: BIOSPAGE        0002
0157: BIOSStart       F600   0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 0311 3973
3380: BlockOK         F339   3374
0253: BlockSize       0800   0275
1060: BSspaceBS       EA48   0999
0034: BYTE            0001   1173
3945: byteAllocationFlag F58E   2074 2240 2832 3386 3640
3913: caAllocVector   F573   1612 2094 2096 2121 2545 2885 2952
3912: caCheckSum      F571   3207
3910: caDirectoryDMA  F56D   2061 2413 2771 2962 3199
3906: caDirMaxValue   F567   2052 2128 2443 2805
3911: caDiskParamBlock F56F   1674 2066
3915: caListSize      0008   2062
3914: caListSizeEnd   F575   3915
3909: caListSizeStart F56D   3915
0094: CARET           005E   0842
0836: CaretOut        E948   1034 1115
3908: caSector        F56B   2058 2398 3168
3936: caSkewTable     F584   2050
3907: caTrack         F569   2055 2394 3159
0151: CCPEntry        E000   0153 0157
0142: CCPLength       0800   0146 0153 0157
0928: CheckCTL_S      E9AC   0917
2685: CheckExtents    F038   2679
2981: CheckRODirectory F168   1440 1520
2984: CheckROFile     F16B   3337
3187: CheckSumUtility F241   2719 3131
2975: CheckWrite      F161   1432 1505 2312 3335
2214: CloseDirEntry   EE10   1287 1838 3473
2296: CloseDirEntryEnd EE7F   2286
2304: CloseDirEntryError EE8B   2256 2266 2271
0074: COLON           003A
1171: columnPosition  EAC1   0861 0886 0951 0971 1129
0069: COMMA           002C
2610: CompareExtents  EFD1   2686
3197: ComputeCheckSum F24D
3201: ComputeCheckSum1 F254   3204
0128: ComTail         0080   0129
0130: ComTailChars    0082
0129: ComTailCount    0081   0130
0905: ConBreak        E98C   0729 0872
0938: ConBreak0       E9BA   0930
0940: ConBreak1       E9BD   0908
0796: ConIn           E921   0501 0987 3836
0869: ConsoleOut      E96B   0843 0855 0860 0948 0956 0963 0965 1057
3003: CopyDir         F179   1523 3252
2961: CopyDirEntryToUserDMA F14D   1340 1405
2172: CopyDirRecordToFCB EDD6   3525
2997: CopyFCB         F175   2338
0230: cpmRecordSize   0080   0232 0235 0237 2964 3198 3861
0059: CR              000D   0809 0962 0992 1056
0042: CTRL_C          0003   0933 1039 3805
0043: CTRL_E          0005   1004
0044: CTRL_H          0008   0815 0998 1143
0045: CTRL_K          000B
0046: CTRL_L          000C
0047: CTRL_P          0010   0916 1007
0048: CTRL_R          0012   1016
0049: CTRL_S          0013   0929
0050: CTRL_U          0015   1013
0051: CTRL_X          0018   1010
0052: CTRL_Z          001A
3888: currentDisk     F55F   1208 1573 2009 2020 2026 2039 2350 2436 2454 2473 3829
3951: currentFileRecord F594   2499 3235 3294 3304 3339 3424 3461 3573 3598
3884: currentUserNumber F55E   0780 0786 2146 2482
0070: DASH            002D
0264: DataBlocks      02C7   0274
0263: DataSectors     0B1C   0264
1431: DeleteFile      EB23   1428
1436: DeleteFileLoop  EB2B   1447
1124: DeleteTheLine   EA8E   1011
1127: DeleteTheLine1  EA8F   1134
3666: DEminusHL2HL    F485
3955: dirBlockIndex   F598   2772 3123
0235: DirBuffSize     0080
0250: DirectoryBlockCount 0002   0275
0237: DirectoryEntryPerRecord 0004   0278
3939: directoryIndex  F588   2636 2700 2970
3861: dirEntriesPerRecord 0004   3863
3956: dirEntryIndex   F599   2696 2747 2757 2803 3106 3108 3117 3136
3863: dirEntryMask    0003   2697 3118
3862: dirEntryShift   0002   3137
0234: DirEntrySize    0020   0237 0275
2969: DirLocationToReturnLoc F15A   1429 1502 2003
3957: dirRecord       F59B   3140 3189 3208
0222: DiskCommandBlock 0046
0221: DiskControlByte 0045
0224: DiskControlTable 0040
3321: DiskEOF         F2E7   3301 3308 3314
0418: diskf           000B
3941: diskMapIndex    F58A   3357 3388
3289: DiskRead        F2AC   1767
0226: DiskReadCode    0001
0231: diskSectorSize  0200   0232 0253 0261
0220: DiskStatusLocation 0043
3331: DiskWrite       F2EF   1774
3346: DiskWrite1      F30C   3341
3405: DiskWrite2      F35D   3393
3411: DiskWrite3      F362   3350
3432: DiskWrite4      F382   3427
3443: DiskWrite5      F38F   3436
3462: DiskWrite6      F3AD   3458
3464: DiskWrite7      F3AF   3446 3450
0227: DiskWriteCode   0002
3326: DiskWriteSeq    F2EA   3275
3826: displayAndWait  F51A   3804 3822
3041: DivideHLby8     F19D   2089 2871 2874
0133: DMABuffer       0080   1210 3898
0063: DOLLAR          0024   0824 2152
0276: dpb3hdAL0       00C0
0277: dpb3hdAL1       0000
0272: dpb3hdBLM       000F
0271: dpb3hdBSH       0004
0278: dpb3hdCKS       0020
0275: dpb3hdDRM       007F   0278
0274: dpb3hdDSM       02C6
0273: dpb3hdEXM       0000
0280: dpb3hdNOH       0002
0279: dpb3hdOFF       0001
0270: dpb3hdSPT       0090
3923: dpbBLM          F578   3571
3922: dpbBSH          F577   3563 3596
3928: dpbCKS          F580   3188
3927: dpbDABM         F57E   2119
3926: dpbDRM          F57C   2441 3105
3925: dpbDSM          F57A   2072 2088 2104 2870
3930: dpbEnd          F584   3931
3924: dpbEXM          F579   2504 2613 3487
3929: dpbOFF          F582   2386 3172
3931: dpbSize         000F   2068
3921: dpbSPT          F575   3147
3920: dpbStart        F575   2067 3931
0450: DUMMY           E8A9   0445 0446
3840: emDisk          F53F   3831
3839: emDisk0         F533   3832
3841: emPermanent     F543   3800 3803
3874: emptyDir        00E5   1442 2142 2653 3895
3895: emptyFCB        F560   2315
3844: emReadOnlyDisk  F55A   3814
3843: emReadOnlyFile  F555   3818
3842: emSelection     F54E   3810
0137: END_OF_FILE     001A
0040: EndOfMessage    0000
1050: EndRead         EA3E   0993 0996
3947: entryDisk       F590   0391 2474
0292: EOD             FFFF   2746
0078: EQUAL_SIGN      003D
3802: erPermanent     F4F9   3794
3799: erPermanentNoWait F4F3   2428 2737
3813: erReadOnlyDisk  F50B   3796
3817: erReadOnlyFile  F511   3797
3782: errPermanent    F4E0
3776: errReadOnlyDisk F4D4   2978
3779: errReadOnlyFile F4DA   2990
3773: errSelect       F4CE   2019
3809: erSelection     F505   3795
3794: evPermanent     F4EB   3783
3796: evReadOnlyDisk  F4EF   3777
3797: evReadOnlyFile  F4F1   3780
3795: evSelection     F4ED   3774
0061: EXCLAIM_POINT   0021
1175: exitParameterByte EAC5   0510 0619 0730 0756 0781 1574 1842 1852 1863 1870 1883 2156 2216 2305 2698 2712 2971 3306 3377 3412 3455 3529 3589
1176: exitParameterWord EAC5   0347 0398 0550 0639 1551 1613 1659 1675
3950: extentValue     F593   2506 3610
0029: FALSE           0000   0923 1095 1443 1772 2078 2645 3332
0125: FCB1            005C   0126
0126: FCB2            006C
3937: fcbCopiedFlag   F586   2298 3472 3490
3857: fcbCurrentRecord 0021
3948: fcbDisk         F591   0349 0386 2476
3855: fcbDiskMapIndex 0010   1512 1521 2232 2237 2822 2824 3384 3637
3851: fcbExtIndex     000C   1433 1506 1522 1821 1845 1904 1956 2187 2280 2289 2525 2677 3245 3251 3478 3498
0015: fcbExtIndexLSB  000C
0016: fcbExtIndexMSB  000E
3850: fcbHiddenfileIndex 000A
3848: fcbLength       0020   2181 2237 2280 2330 2824 2999 3861 3875
3854: fcbRCIndex      000F   1921 2190 2208 2289 2514 2517
3949: fcbRecordCount  F592   2502 3239 3295 3425
3849: fcbROfileIndex  0009   2985
3852: fcbS1Index      000D   2334 2674
3853: fcbS2Index      000E   1827 1848 1973 2579 3498
3864: fcbShift        0005   3119
0170: fCloseFile      0010
0161: fConsoleIn      0001
0162: fConsoleOut     0002
0173: fDeleteFile     0013
0165: fGetConsoleStatus 000B
0179: fGetCurrentDisk 0019
0178: fGetLoginVector 0018
0181: fGetSetUserNumber 0020
0166: fGetVersion     000C
3368: FirstBlock      F32B   3360
0176: fMakeFile       0016
0169: fOpenFile       000F
2931: FoundFreeOctet  F128   2901 2906 2915 2923
2937: FoundFreeOctet1 F12E   2933
2939: FoundFreeOctet2 F12F   2935
2941: FoundFreeOctet3 F132   2944
2947: FoundFreeOctet4 F13A   2949
0163: fPrintString    0009
0174: fReadSeq        0014
0164: fReadString     000A
0177: fRenameFile     0017
3946: fResel          F58F   0350 0380 2464
0167: fResetSystem    000D
0171: fSearchFirst    0011
0172: fSearchNext     0012
0168: fSelectDisk     000E
0180: fSetDMA         001A
0448: functionCount   0028   0359
0405: functionTable   E857   0364 0418 0448
0175: fWriteSeq       0015
3545: GetBlockNumber  F415   3312 3347
2867: GetClosestBlock F0D7   3370
2769: GetCurrentDirectoryRecord F087   1441 1920 2141 2177 2231 2663 2821 2982 3010
3646: GetDiskMap16Bit F47A   3642
3595: GetDiskMapIndex F447   3356 3546
3599: GetDiskMapIndex1 F44E   3603
3611: GetDiskMapIndex2 F45C   3618
3621: GetDiskMapIndex3 F465   3615
3635: GetDiskMapValue F467   3364 3549
2523: GetExtentAddress EF88   2173 2503
2577: GetExtentNumberMSB EFBC   1877 2568 3438
2512: GetFcbRecordDetails EF7B   2496 3232
1903: GetFileSize     EC78   1738
1916: GetFileSize1    EC8A   1944
1942: GetFileSize2    ECAC   1935
1945: GetFileSizeExit ECB2   1918
2644: GetNextDirectoryRecord EFF7   1404 1446 1525 1943 2682 2687 3253
2662: GetNextDirectoryRecord1 F014   2654
1950: GetRandomRecordPosition ECB4   1892 1922
2576: GetWriteFileFlagValue EFBC   2220 2588 2599
3786: GoToError       F4E6   3775 3778 3781 3784 3801
0079: GREATER_THAN    003E
0062: HASH_TAG        0023   0947
3859: highestRecordNumber 007F   3340 3445
2383: Home            EEE4   2127 2642
1147: IgnoreTheLine   EAAC   1014
3898: initDAMAddress  F565   1211 1595 2407 2963
2087: InitDisk        ED5D   2032
2134: InitDisk1       EDA2   2144 2162
2157: InitDisk2       EDC3   2148 2153
2567: InitializeExtentNumberMSB EFB6   1254 1334 1469
0117: IOBYTE          0003   0638 0658
3554: IsAllocated     F422   3313 3348
3716: IsBitSet        F4A0   2023 2456 3738 3750
3723: IsBitSet1       F4A7   3721
3718: IsBitSetLoop    F4A1   3726
2452: IsDiskWriteProtected EF2C   2217 2976
1012: IsItDeleteTheLineU EA19
1009: IsItDeleteTheLineX EA14
1006: IsItPrintToggle EA0F
1096: IsItPrintToggle1 EA70   1094
1000: IsItRubout      EA05
1003: IsPhysicalEOL   EA0A
0808: IsPrintableASCII E92C   0502 0838
1081: ItIsPhysicalEOL EA5D   1005
1088: ItIsPrintToggle EA65   1008
1069: ItIsRubout      EA52   1002
1165: keyboardByte    EABE   0797 0906 0939
0065: L_PAREN         0028
2552: Left            EFA7   2554
0082: LEFT_ARROW      005F
0098: LEFT_CURLY      007B
0146: LengthInBytes   2000   0147 0151 0261
0147: LengthInK       0009
0077: LESS_THAN       003C
0058: LF              000A   0811 0892 0964 0994
1110: LL1             EA7E   1118
0032: LO_NIBBLE_MASK  000F   0785 1969
3897: loggedDisks     F563   1206 1550 2022 2028 2030
2899: LookRight       F0FC   2909
2311: MakeNewFile     EE90   1471 1861 3517
2117: Mark4Directory  ED8A   2109
3869: maxExtValue     001F   2622 3482
0149: MemorySize      0040   0151
3069: Merge           F1B1   2260 2262
2239: MergeAllocationMaps EE35   2277
2254: MergeDirEntryNot0 EE49   2251
2249: MergeFCBisNot0  EE43   2247
2273: MergeMapLoop    EE65   2257
2259: MergeWordMaps   EE50   2242
3870: moduleMask      000F   3503
3053: MultiplyHLby8   F1A7   2103 2955
0262: myOffset        0001   0263 0279
3872: nameLength      000F   1336 2167 2225 2324 2330 3508
3875: NEXT_RECORD     0020   1816 1891 2517 3876
2709: NoDirRecordsMatch F056   2648 2660
2927: NoFreeBlocks    F124   2916 2924
2911: NoMoreLeft      F10E   2907
2913: NoMoreLeftLoop  F10F   2917
2919: NoMoreRight     F119   2902
2921: NoMoreRightLoop F11A   2925
2481: NoSelect        EF5B   2471
0935: NothingWaiting  E9B8   0926
0054: NULL            0000
0246: NumberOfHeads   0002   0257 0259 0270 0280
0243: NumberOfLogicalDisks 0004
0031: OFF             0000
0030: ON              FFFF
2166: OpenFile        EDCD   1256 1851
3470: OpenNextExt     F3B2   3302 3453
3507: OpenNextExt1    F3E6   3492
3524: OpenNextExt2    F404   3494 3511
3526: OpenNextExt3    F407   3521
3533: OpenNextExtError F40F   3504 3515 3520
3497: OpenNextModule  F3DB   3484
2206: OpenSetRecordCount EE07   2202 2204
1174: paramDE         EAC3   0338 0384 0681 0973 1052 1107 1328 1402 1510 1594 1785 1890 1907 2180 2207 2235 2313 2316 2321 2333 2465 2483 2513 2524 2578 2639 3007 3336 3383 3477 3636
1173: paramE          EAC2   0340 0392 0777 2008 2469
0064: PERCENT         0025
0071: PERIOD          002E
0120: Pg0CurentDisk   0004
0119: Pg0CurentUser   0004   0120
0068: PLUS_SIGN       002B
0822: Print           E93B   0684 0831 3833 3835
1167: printEchoFlag   EABF   0880 0919 1091
0080: QMARK           003F   1330 2670
1338: QMarkFind       EB05   1331
0066: R_PAREN         0029
0113: RAM             0000   0115 0116 0117 0119 0122 0125 0128 0133 0135
3876: RANDOM_REC_FIELD 0021   1787 1893 1908
1764: RandomDiskRead  EBC2   1719
1771: RandomDiskWrite EBCB   1731
1781: RandomSeek      EBD4   1766 1773
1835: RandomSeekClose EC18   1825
1880: RandomSeekError EC5D   1814
1873: RandomSeekErrorBadSeek EC56   1844 1860 1865
1867: RandomSeekExit  EC50   1834 1854
2425: ReadBuffer      EF0C   3095 3318
3104: ReadDirectory   F1C8   2137 2646
3116: ReadDirectory0  F1DC   3111
3120: ReadDirectory1  F1E3   3122
3093: ReadDirRecord   F1BF   3129
1030: ReadEchoRubOut  EA26   1078
3938: readModeFlag    F587   3291 3333 3513
0983: ReadNext        E9ED   1047 1073 1099 1121
0986: ReadNext0       E9EF   1066 1085
3896: readOnlyVector  F561   1205 1658 2434 2439 2453
3283: ReadSeq         F2A7   3267
0970: ReadString      E9E0   0714 1131 1153
3766: ReAlignMap1     F4C7   3764
3761: ReAlignMapLoop  F4C1   3769
3759: ReAlignVector   F4C0   3742
3311: RecordOK        F2D1   3298
0255: RecordsPerBlock 0010
0239: RecordsPerExtent 0080   2205 3300 3859
0232: recordsPerSector 0004   0255 0270
1504: Rename          EB57   1501
1516: RenameLoop      EB68   1526
1102: RepeatLine      EA75   1017
2462: ReselectDisk    EF37   1255 1286 1335 1403 1427 1470 1500 1718 1730 1737 2001 3266 3274
2598: ResetFileWriteFlag EFCB   3407
3748: ResetVectorBit  F4B9
0379: ReturnToCaller  E832   0353
0395: ReturnToCaller1 E84D   0382 0388 0617
2560: Right           EFB1   2558 2562
2369: RotateAndReplace EEDD   2372
3027: RotateRightHLbyB F190   3035
3032: RotateRightHLbyB1 F196   3030
0083: RUBOUT          007F   1001
2819: ScanDiskMap     F0AB   1444 2160
2826: ScanDiskMap0    F0B5   2858
2851: ScanDiskMap2    F0CC   2840
2842: ScanDiskMapWord F0C6   2834
3943: searchAddress   F58C   1401 2640 2650
2634: SearchForDirectoryRecord EFE2   1339 1434 1507 1905 2168 2226 2318 3246 3509
3942: searchLength    F58B   2637 2664
0284: SectorMask      0003
0249: SectorsPerBlock 0004   0253 0255 0258 0264 0284
0259: SectorsPerCylinder 0024   0262 0263
0248: SectorsPerTrack 0012   0257 0259 0270
3144: Seek            F207   3141 3317 3418
3149: Seek0           F211   3153
3135: SeekDir         F1F6   2300 3014 3128
2017: Select          ECF6   1213 2013
2007: SelectCurrent   ECEA   0393 1237 2479
2038: SelectDisk      ED17   2018
2081: SelectDisk1     ED59   2077
0076: SEMICOLON       003B
3940: seqReadFlag     F589   1783 3233 3285 3328 3448
3562: SetActualRecordAdd F428   3316 3417
3566: SetActualRecordAdd1 F42E   3569
3244: SetAttributes   F283   2002
3247: SetAttributes1  F288   3254
2112: SetBitLoop      ED85   2115
2348: SetCurrentDiskBit EECA
2406: SetDataDMA      EEFE   1212 1596 2724 3096
2412: SetDirDMA       EF03   2721 3094
2783: SetDirectoryEntry F095   2161 2337
2433: SetDiskReadOnly EF14   1640 3219
2417: SetDMA          EF06   2408
2745: SetEndDirectory F077   2132 2641 2710 3112
2587: SetFileWriteFlag EFC5   1885 2185 2340 3535
3587: SetLowReturnTo1 F441   3322 3342 3534
3223: SetNewCheckSum  F26F   3212
2689: SetNextPosition F03E   2671 2675 2683
1889: SetRandomRecord EC65   1744
2495: SetRecordVars   EF64   3293 3338 3527
2534: SetResetMapBit  EF90   2854
0784: SetUserNumber   E91B   0779
3736: SetVectorBit    F4B0   2029 2438
3056: ShiftLeftHLbyB  F1A9   3060
3689: ShiftLeftHLbyC  F499   2353
3691: ShiftLeftHLbyC0 F49A   3695
3044: ShiftRightHLbyB F19F   2544 3048 3138
3675: ShiftRightHLbyC F48C
3677: ShiftRightHLbyC0 F48D   3687
0961: showCRLF        E9D6   0949 1084 3828
0946: showHashCRLF    E9C0   1105 1148
0950: showHashCRLF1   E9C8   0957
0072: SLASH           002F
0055: SOH             0001
0060: SPACE           0020   0817 0859 0889 0955 1139 1149 1151
0291: STACK_SIZE      0020   3963
3963: stackBottom     F59D
1170: startingColumn  EAC0   0952 0972 1128
2802: StillInDirectory F09E   2658 2784 3217
0261: SystemSectors   0011   0262
0057: TAB             0009   0813 0854
0852: TabOut          E958   0507 0529 0829 0839
0858: TabOut0         E95E   0863
2668: TestNextPosition F01D   2694
0924: ToggleFlag1     E9A9   0922
0123: TopRAM          0007
0258: TotalNumberOfBlocks 02D0
0257: TotalNumberOfSectors 0B40   0258 0263
0135: TPA             0100
0247: TracksPerHead   0050   0257
0028: TRUE            FFFF   0920 0941 1092 1765 2075 2082 2136 2159 2297 2463 2718 3290
0081: UNDER_SCORE     005F
3231: UpdateRecordVars F271   3319 3452 3465
1163: usersStack      EABC   0342 0396
1285: vCloseFile      EAEC   0423
1736: vComputeFileSize EBB8   0442
0500: vConsoleIn      E8AD   0407
0528: vConsoleOut     E8BE   0408
1426: vDeleteFile     EB1A   0426
0605: vDirectConIO    E8D1   0412
0614: vDirectConIO1   E8D9   0608
0290: VERSION         0020   0755
1326: vFindFirst      EAF2   0424
1400: vFindNext       EB0B   0425
1611: vGetAllocAddr   EB93   0434
0728: vGetConsoleStatus E900   0417
1572: vGetCurrentDisk EB83   0432
1673: vGetDiskParamBlock EBA4   0438
0637: vGetIOBYTE      E8E7   0413
1549: vGetLoginVector EB7C   0431
1657: vGetReadOnlyMap EB9D   0436
0776: vGetSetUserNumber E90D   0439
0754: vGetVersion     E907   0419
0582: vListOut        E8CD   0411
1468: vMakeFile       EB45   0429
1253: vOpenFile       EAE3   0422
0680: vPrintString    E8F3   0415
0567: vPunchOut       E8C9   0410
0548: vReaderIn       E8C2   0409
1717: vReadRandom     EBAC   0440
3265: vReadSeq        F299   0427
0713: vReadString     E8FC   0416
1499: vRenameFile     EB4E   0430
1701: vResetDrive     EBAB   0444
1203: vResetSystem    EAC7   0420
1236: vSelectDisk     EAE0   0421
1593: vSetDMA         EB8A   0433
2000: vSetFileAttributes ECE1   0437
0657: vSetIOBYTE      E8EE   0414
1743: vSetRandomRecord EBBE   0443
0468: vSystemReset    E8AA   0406
1639: vWriteProtectDisk EB9A   0435
1729: vWriteRandom    EBB2   0441
1757: vWriteRandom0Fill EBC1   0447
3273: vWriteSeq       F2A0   0428
3821: waitB4boot      F514   3811 3815
0115: WarmBoot        0000   0934 1043 3806 3823
0035: WORD            0002   1174 1176
0195: WriteAllocated  0000   3349
2734: WriteBuffer     F06F   2723 3421
0197: WriteCleanBuffer 0002   3406
2716: WriteDir        F05F   1445 2301 3015
0196: WriteDirectory  0001   2722
3871: writeFlagMask   0080
3972: Z_HighestLocation F5DD   3973
3973: Z_MemoryLeft    0022
0039: ZERO            0000
