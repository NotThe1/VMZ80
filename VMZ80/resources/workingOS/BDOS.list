0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process  OpenFile (0FH)
0005: E800
0006: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0007: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0008: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0009: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0010: E800         ; 2018-03-02 Refactored the CP/M Suite
0011: E800         ; 2018-02-12 fixed allocate 16 bit problem
0012: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0013: E800         ; 2014-03-14  :  Frank Martyn
0014: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0015: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0016: E800
0017: E800                        Include ./stdHeader.Z80
0018: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0019: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0020: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0021: E800         ; stdHeader.asm
0022: E800         ; standard equates
0023: E800
0024: E800         ; 2017-03-02 Refactored the CP/M Suite
0025: E800
0026: E800
0027: E800             TRUE       EQU    -1                   ; not false
0028: E800             FALSE      EQU    0000H
0029: E800             ON         EQU    -1
0030: E800             OFF        EQU    0000H
0031: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0032: E800
0033: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0034: E800             WORD       EQU    2                    ; number of bytes for "word" type
0035: E800
0036: E800
0037: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0038: E800             ZERO       EQU    00H                  ; Zero
0039: E800             EndOfMessage EQU    00H
0040: E800
0041: E800             CTRL_C     EQU    03H                  ; ETX
0042: E800             CTRL_E     EQU    05H                  ; physical eol
0043: E800             CTRL_H     EQU    08H                  ; backspace
0044: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0045: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0046: E800             CTRL_P     EQU    10H                  ; prnt toggle
0047: E800             CTRL_R     EQU    12H                  ; repeat line
0048: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0049: E800             CTRL_U     EQU    15H                  ; line delete
0050: E800             CTRL_X     EQU    18H                  ; =ctl-u
0051: E800             CTRL_Z     EQU    1AH                  ; end of file
0052: E800
0053: E800             NULL       EQU    00H                  ; Null
0054: E800             SOH        EQU    01H                  ; Start of Heading
0055: E800             BELL       EQU    07H                  ; Bell
0056: E800             TAB        EQU    09H                  ; Tab
0057: E800             LF         EQU    0AH                  ; Line Feed
0058: E800             CR         EQU    0DH                  ; Carriage Return
0059: E800             SPACE      EQU    20H                  ; Space
0060: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0061: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0062: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0063: E800             PERCENT    EQU    25H                  ; Percent Sign
0064: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0065: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0066: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0067: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0068: E800             COMMA      EQU    2CH                  ; Comma
0069: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0070: E800             PERIOD     EQU    2EH                  ; Period
0071: E800             SLASH      EQU    2FH                  ; /
0072: E800             ASCII_ZERO EQU    30H                  ; zero
0073: E800             COLON      EQU    3AH                  ; Colon
0074: E800
0075: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0076: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0077: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0078: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0079: E800             QMARK      EQU    3FH                  ; Question Mark
0080: E800             UNDER_SCORE EQU    5FH                  ; under score _
0081: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0082: E800             RUBOUT     EQU    7FH                  ; Delete Key
0083: E800
0084: E800
0085: E800             ASCII_A    EQU    'A'
0086: E800             ASCII_C    EQU    'C'
0087: E800             ASCII_K    EQU    'K'
0088: E800             ASCII_N    EQU    'N'
0089: E800             ASCII_Q    EQU    'Q'
0090: E800             ASCII_R    EQU    'R'
0091: E800             ASCII_W    EQU    'W'
0092: E800             ASCII_Y    EQU    'Y'
0093: E800             CARET      EQU    '^'
0094: E800             ASCII_LO_A EQU    'a'
0095: E800             ASCII_LO_K EQU    'k'
0096: E800             ASCII_LO_P EQU    'p'
0097: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0098: E800
0099: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0100: E800                        Include ./osHeader.Z80
0101: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0102: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0103: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0104: E800         ; osHeader.Z80
0105: E800
0106: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0107: E800         ; 2017-03-02 Refactored the CP/M Suite
0108: E800
0109: E800         ; Contains the Equates used by the CP/M system
0110: E800
0111: E800         ;------------------------Page Zero Constants ---------------------------------
0112: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0113: E800
0114: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0115: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0116: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0117: E800
0118: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0119: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0120: E800
0121: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0122: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0123: E800
0124: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0125: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0126: E800
0127: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0128: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0129: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0130: E800         ;-----------------------------------------------------------------------
0131: E800
0132: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0133: E800         ;-----------------------------------------------------------------------
0134: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0135: E800         ;-----------------------------------------------------------------------
0136: E800             END_OF_FILE EQU    1AH                  ; end of file
0137: E800         ;-----------------------------------------------------------------------
0138: E800
0139: E800         ;--------------- CP/M Constants -----------------------------------------
0140: E800
0141: E800             CCPLength  EQU    0800H                ; Constant
0142: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0143: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0144: E800
0145: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0146: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0147: E800
0148: E800             MemorySize EQU    64
0149: E800
0150: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0151: E800
0152: E800             BDOSBase   EQU    CCPEntry + CCPLength
0153: E800             BDOSEntry  EQU    BDOSBase
0154: E800
0155: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0156: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0157: E800         ;-----------------------------------------------------------------------
0158: E800
0159: E800         ;------------------- BDOS System Call Equates --------------------------
0160: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0161: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0162: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0163: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0164: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0165: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0166: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0167: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0168: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0169: E800             fCloseFile EQU    10H                  ; closef - Close File
0170: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0171: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0172: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0173: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0174: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0175: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0176: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0177: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0178: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0179: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0180: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0181: E800         ;-----------------------------------------------------------------------
0182: E800
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800         ;*******************************************************************************
0188: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0189: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0190: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0191: E800         ; sector write) or to an allocation block that has already been allocated to a
0192: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0193: E800         ;*******************************************************************************
0194: E800             WriteAllocated EQU    00H
0195: E800             WriteDirectory EQU    01H
0196: E800             WriteCleanBuffer EQU    02H
0197: E800
0198: E800
0199: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0200: E800                        Include ./diskHeader.Z80
0201: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0202: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0203: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0204: E800         ; diskHeader.asm
0205: E800
0206: E800         ; 2017-03-02 Refactored the CP/M Suite
0207: E800
0208: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0209: E800
0210: E800         ; Contains the Equates used by the CP/M system to handle disks
0211: E800
0212: E800
0213: E800         ;*******************************************************************************
0214: E800         ;
0215: E800         ;     Disk related values
0216: E800         ;
0217: E800         ;
0218: E800         ;*******************************************************************************
0219: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0220: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0221: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0222: E800         ; for boot
0223: E800             DiskControlTable EQU    0040H
0224: E800
0225: E800             DiskReadCode EQU    01H                  ; Code for Read
0226: E800             DiskWriteCode EQU    02H                  ; Code for Write
0227: E800
0228: E800
0229: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0230: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0231: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0232: E800
0233: E800             DirEntrySize EQU    20H                  ; (32)
0234: E800             DirBuffSize EQU    cpmRecordSize
0235: E800
0236: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0237: E800
0238: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0239: E800
0240: E800
0241: E800         ;-------------------------------------------------------------------------------------
0242: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0243: E800
0244: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0245: E800             NumberOfHeads EQU    02H                  ; number of heads
0246: E800             TracksPerHead EQU    50H                  ; 80
0247: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0248: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0249: E800             DirectoryBlockCount EQU    02H                  ;
0250: E800         ;-----------------------------------------------------------------------
0251: E800
0252: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0253: E800
0254: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0255: E800
0256: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0257: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0258: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0259: E800
0260: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0261: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0262: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0263: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0264: E800
0265: E800         ;-----------------------------------------------------------------------
0266: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0267: E800         ;-----------------------------------------------------------------------
0268: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0269: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0270: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0271: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0272: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0273: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0274: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0275: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0276: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0277: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0278: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0279: E800             dpb3hdNOH  EQU    NumberOfHeads
0280: E800
0281: E800         ;*******************************************************************************
0282: E800
0283: E800             SectorMask EQU    SectorsPerBlock - 1
0284: E800
0285: E800         ;***************************************************************************
0286: E800
0287: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0288: E800
0289: E800             VERSION    EQU    20H                  ; Version 2.0
0290: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0291: E800             EOD        EQU    -1                   ; End of Directory
0292: E800
0293: E800         ;************************ BIOS Function Constants ***************************;
0294: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0295: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0296: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0297: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0298: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0299: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0300: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0301: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0302: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0303: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0304: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0305: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0306: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0307: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0308: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0309: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0310: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0311: E800         ;************************ BIOS Function Constants ***************************;
0312: E800
0313: E800         ;============================================================================;
0314: E800         ;	BDOS                                                                     ;
0315: E800         ; Calling into   :                                                           ;
0316: E800         ;					Register  C - Contains BDOS Function Code                ;
0317: E800         ;					Register  A - Holds the Byte argument if any             ;
0318: E800         ;					Register DE - Holds the Word argument if any             ;
0319: E800         ; Returning from :                                                           ;
0320: E800         ;					Register  A - The Byte return value if any               ;
0321: E800         ;					Register HL - The Word return value if any               ;
0322: E800         ;                   ( Register A=L and B=H)                                  ;
0323: E800         ;============================================================================;
0324: E800
0325: E800
0326: E800                        ORG    BDOSBase
0327: E800
0328: E800         ;===========================BDOS Entry=======================================;
0329: E800         ;BDOSEntry:                                                                  ;
0330: E800         ;
0331: E800         ;
0332: E800             BdosStart:                      ;
0333: E800         ;	LD		A,C                                                              ;
0334: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0335: E800         ;
0336: E800         ; Save Calling Arguments                                                     ;
0337: E800 ED 53 C0 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0338: E804 7B                     LD     A,E                  ;
0339: E805 32 BF EA               LD     (paramE),A           ; Save the Byte argument             ;
0340: E808         ; Save users Stack pointer                                                   ;
0341: E808 ED 73 B9 EA               LD     (usersStack),SP      ; We will use our own stack          ;
0342: E80C         ;
0343: E80C         ; initialize variables                                                       ;
0344: E80C 21 00 00               LD     HL,0000H             ;
0345: E80F 22 C2 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0346: E812 AF                     XOR    A                    ;
0347: E813 32 92 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0348: E816 32 90 F5               LD     (fResel),A           ; Clear re selection flag            ;
0349: E819         ;
0350: E819         ; Set up for return to caller when Function Completes                        ;
0351: E819 21 2F E8               LD     HL,ReturnToCaller    ;
0352: E81C E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0353: E81D         ;
0354: E81D         ; is it a valid function number ?	                                         ;
0355: E81D         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0356: E81D 79                     LD     A,C                  ;
0357: E81E FE 28                  CP     functionCount        ; make sure its a good number        ;
0358: E820 D0                     RET    NC                   ; exit if not a valid function       ;
0359: E821         ;
0360: E821         ; Calculate the index and get vector to go to	                             ;
0361: E821 4B                     LD     C,E                  ; Assume byte argument               ;
0362: E822 21 54 E8               LD     HL,functionTable     ; Get table base                     ;
0363: E825 5F                     LD     E,A                  ; Function number in E               ;
0364: E826 16 00                  LD     D,0                  ;
0365: E828 19                     ADD    HL,DE                ; Have byte location                 ;
0366: E829 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0367: E82A 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0368: E82B 23                     INC    HL                   ;
0369: E82C 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0370: E82D EB                     EX     DE,HL                ; Vector now in HL                   ;
0371: E82E         ;
0372: E82E         ; Vector to Function is in HL                                                ;
0373: E82E E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0374: E82F         ;===========================BDOS Entry=======================================;
0375: E82F         ;===========================BDOS Exit =======================================;
0376: E82F         ;arrive here at end of processing to return to user                          ;
0377: E82F             ReturnToCaller:                      ;
0378: E82F 3A 90 F5               LD     A,(fResel)           ; get re-selection flag              ;
0379: E832 B7                     OR     A                    ; is it set?                         ;
0380: E833 28 15                  JR     Z,ReturnToCaller1    ;
0381: E835         ;re-selection  may have taken place                                         ;
0382: E835 2A C0 EA               LD     HL,(paramDE)         ;
0383: E838 36 00                  LD     (HL),0               ;
0384: E83A 3A 92 F5               LD     A,(fcbDisk)          ;
0385: E83D B7                     OR     A                    ; Disk = 0?                          ;
0386: E83E 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0387: E840         ;
0388: E840 77                     LD     (HL),A               ;
0389: E841 3A 91 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0390: E844 32 BF EA               LD     (paramE),A           ; and select it                      ;
0391: E847 CD 57 EC               CALL   SelectCurrent        ;
0392: E84A         ;
0393: E84A             ReturnToCaller1:                      ;
0394: E84A 2A B9 EA               LD     HL,(usersStack)      ;
0395: E84D F9                     LD     SP,HL                ; restore callers stack              ;
0396: E84E 2A C2 EA               LD     HL,(exitParameterWord) ;
0397: E851 7D                     LD     A,L                  ;
0398: E852 44                     LD     B,H                  ; BA = exitParameterWord             ;
0399: E853 C9                     RET                         ;
0400: E854         ;===========================BDOS Exit =======================================;
0401: E854
0402: E854         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0403: E854             functionTable:                      ;
0404: E854 A7 E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0405: E856 AA E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0406: E858 BB E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0407: E85A BF E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0408: E85C C6 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0409: E85E CA E8                  DW     vListOut             ;   5 - List Output                  ;
0410: E860 CE E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0411: E862 E4 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0412: E864 EB E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0413: E866 F0 E8                  DW     vPrintString         ;   9 - Print String                 ;
0414: E868 F9 E8                  DW     vReadString          ;   A - Read Console String          ;
0415: E86A FD E8                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0416: E86C             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0417: E86C 04 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0418: E86E C4 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0419: E870 DD EA                  DW     vSelectDisk          ;   E - Select Disk                  ;
0420: E872 E0 EA                  DW     vOpenFile            ;   F - Open File                    ;
0421: E874 D3 F0                  DW     vCloseFile           ;  10 - Close File                   ;
0422: E876 D9 F0                  DW     vFindFirst           ;  11 - Search For First             ;
0423: E878 F2 F0                  DW     vFindNext            ;  12 - Search for Next              ;
0424: E87A 01 F1                  DW     vDeleteFile          ;  13 - Delete File                  ;
0425: E87C 0A F1                  DW     vReadSeq             ;  14 - Read Sequential              ;
0426: E87E 11 F1                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0427: E880 18 F1                  DW     vMakeFile            ;  16 - Make File                    ;
0428: E882 21 F1                  DW     vRenameFile          ;  17 - Rename File                  ;
0429: E884 E9 EA                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0430: E886 F0 EA                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0431: E888 F7 EA                  DW     vSetDMA              ;  1A - Set DMA address              ;
0432: E88A 00 EB                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0433: E88C 4B EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0434: E88E 07 EB                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0435: E890 4E EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0436: E892 0E EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0437: E894 0A E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0438: E896 16 EB                  DW     vReadRandom          ;  21 - Read Random                  ;
0439: E898 1C EB                  DW     vWriteRandom         ;  22 - Write Random                 ;
0440: E89A 22 EB                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0441: E89C 28 EB                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0442: E89E 15 EB                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0443: E8A0 A6 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0444: E8A2 A6 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0445: E8A4 2B EB                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0446: E8A6             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0447: E8A6         ;
0448: E8A6             DUMMY:                          ;
0449: E8A6 76                     HALT                        ;
0450: E8A7         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0451: E8A7
0452: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0453: E8A7         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0454: E8A7         ; same as the warm boot function invoked when you transfer control to the    ;
0455: E8A7         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0456: E8A7         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0457: E8A7         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0458: E8A7         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0459: E8A7         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0460: E8A7         ;																			 ;
0461: E8A7         ;			Function Code	 :	C = 00H                                      ;
0462: E8A7         ;			Entry Parameters:	None                                         ;
0463: E8A7         ;			Exit Parameters :	Does Not Return								 ;
0464: E8A7         ;																			 ;
0465: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0466: E8A7             vSystemReset:
0467: E8A7 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0468: E8AA
0469: E8AA         ;****************************************************************************;
0470: E8AA         ;								IOByte device I/O							 ;
0471: E8AA         ;****************************************************************************;
0472: E8AA
0473: E8AA
0474: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0475: E8AA         ;  This function reads the next byte of data from the console keyboard and   ;
0476: E8AA         ; puts it into register A. If the character input is a graphic character, it ;
0477: E8AA         ; will be echoed back to the console. The only control characters that are   ;
0478: E8AA         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0479: E8AA         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0480: E8AA         ; move the cursor to the next multiple of eight columns. All of the other    ;
0481: E8AA         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0482: E8AA         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0483: E8AA         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0484: E8AA         ; console output should also be sent to the list device. If CONTROL-S is     ;
0485: E8AA         ; found, further output will be suspended until you type another character.  ;
0486: E8AA         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0487: E8AA         ; pressed and disable it the second time. If there is no incoming data       ;
0488: E8AA         ; character, this function will wait until there is one.                     ;
0489: E8AA         ;                                                                            ;
0490: E8AA         ; This is a blocking function                                                ;
0491: E8AA         ;																			 ;
0492: E8AA         ;																			 ;
0493: E8AA         ;			Function Code	:	C = 01H                                      ;
0494: E8AA         ;			Entry Parameters:	None                                         ;
0495: E8AA         ;			Exit Parameters :	A = Data byte from console					 ;
0496: E8AA         ;																			 ;
0497: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0498: E8AA             vConsoleIn:
0499: E8AA CD 1E E9               CALL   ConIn                ; Don't come back without input
0500: E8AD CD 29 E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0501: E8B0 D8                     RET    C                    ; return nothing to echo
0502: E8B1
0503: E8B1 F5                     PUSH   AF                   ; Save printable character
0504: E8B2 4F                     LD     C,A
0505: E8B3 CD 55 E9               CALL   TabOut               ; Send to console. if TAB expand
0506: E8B6 F1                     POP    AF                   ; retrieve exit value
0507: E8B7
0508: E8B7 32 C2 EA               LD     (exitParameterByte),A
0509: E8BA C9                     RET
0510: E8BB
0511: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0512: E8BB         ;  This function outputs the data byte in register E to the console. As with ;
0513: E8BB         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0514: E8BB         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0515: E8BB         ; checks to see if there is an incoming character, and if there is,          ;
0516: E8BB         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0517: E8BB         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0518: E8BB         ; printer is  toggled on or off                                              ;
0519: E8BB         ;																			 ;
0520: E8BB         ;			Function Code	:	C = 02H                                      ;
0521: E8BB         ;			Entry Parameters:	E = Data byte to be output					 ;
0522: E8BB         ;			Exit Parameters :	None										 ;
0523: E8BB         ;																			 ;
0524: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0525: E8BB         ;BDOS put parameter in C before entering this routine
0526: E8BB             vConsoleOut:
0527: E8BB CD 55 E9               CALL   TabOut
0528: E8BE C9                     RET
0529: E8BF
0530: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0531: E8BF         ;   function reads the next character from the logical "reader" device into  ;
0532: E8BF         ; register A. In practice, the physical device that is accessed depends      ;
0533: E8BF         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0534: E8BF         ; reader at all; this function will return some arbitrary value such as lAH  ;
0535: E8BF         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0536: E8BF         ; Control is not returned to the calling program until a character has been  ;
0537: E8BF         ; read.                                                                      ;
0538: E8BF         ;                                                                            ;
0539: E8BF         ; This is a blocking function                                                ;
0540: E8BF         ;																			 ;
0541: E8BF         ;			Function Code	:	C = 03H                                      ;
0542: E8BF         ;			Entry Parameters:	None										 ;
0543: E8BF         ;			Exit Parameters :	A = Character Input							 ;
0544: E8BF         ;																			 ;
0545: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0546: E8BF             vReaderIn:
0547: E8BF CD 15 F6               CALL   bcReader
0548: E8C2 32 C2 EA               LD     (exitParameterWord),A
0549: E8C5 C9                     RET
0550: E8C6
0551: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0552: E8C6         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0553: E8C6         ; specified character from register E to the logical punch device. Again,    ;
0554: E8C6         ; the actual physical device used, if any, is determined by the BIOS.        ;
0555: E8C6         ; There is no set standard for this device; in some systems the punch        ;
0556: E8C6         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0557: E8C6         ; output to it.                                                              ;
0558: E8C6         ;																			 ;
0559: E8C6         ;			Function Code	:	C = 04H                                      ;
0560: E8C6         ;			Entry Parameters:	E = Data byte to be output					 ;
0561: E8C6         ;			Exit Parameters :	None										 ;
0562: E8C6         ;																			 ;
0563: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0564: E8C6         ;BDOS put parameter in C before entering this routine
0565: E8C6             vPunchOut:
0566: E8C6 CD 12 F6               CALL   bcPunch
0567: E8C9 C9                     RET
0568: E8CA
0569: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0570: E8CA         ;  This function outputs the specified byte in register E to the logical     ;
0571: E8CA         ; list device. As with the reader and the punch, the physical device used    ;
0572: E8CA         ; depends entirely on the BIOS.                                              ;
0573: E8CA         ;																			 ;
0574: E8CA         ;			Function Code	:	C = 05H                                      ;
0575: E8CA         ;			Entry Parameters:	E = Data byte to be output					 ;
0576: E8CA         ;			Exit Parameters :	None										 ;
0577: E8CA         ;																			 ;
0578: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0579: E8CA         ;BDOS put parameter in C before entering this routine
0580: E8CA             vListOut:                       ; func5 (05 - 05) List Output
0581: E8CA CD 0F F6               CALL   bcList               ; direct call to BIOS
0582: E8CD C9                     RET
0583: E8CE
0584: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0585: E8CE         ;  This function serves double duty: it both inputs and outputs characters   ;
0586: E8CE         ; from the console. However, it bypasses the normal control characters and   ;
0587: E8CE         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0588: E8CE         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0589: E8CE         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0590: E8CE         ; then E contains a valid ASCII character that is output to the console.     ;
0591: E8CE         ;  This function works well provided you never have to send a value ofOFFH   ;
0592: E8CE         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0593: E8CE         ; binary data, you cannot use this function, since these values are likely   ;
0594: E8CE         ; to be part of the data stream.                                             ;
0595: E8CE         ;                                                                            ;
0596: E8CE         ;			Function Code	:	C = 06H                                      ;
0597: E8CE         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0598: E8CE         ;								E = Other than 0FFH for Output				 ;
0599: E8CE         ;			Exit Parameters :	A = Input byte or status					 ;
0600: E8CE         ;																			 ;
0601: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0602: E8CE         ;BDOS put parameter in C before entering this routine
0603: E8CE             vDirectConIO:
0604: E8CE 79                     LD     A,C
0605: E8CF 3C                     INC    A
0606: E8D0 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0607: E8D2         ; send byte to console
0608: E8D2 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0609: E8D5 C9                     RET
0610: E8D6
0611: E8D6         ;read byte/status from console
0612: E8D6             vDirectConIO1:
0613: E8D6 CD 06 F6               CALL   bcConst              ; Check Status
0614: E8D9 B7                     OR     A                    ; 00 means not data ready
0615: E8DA CA 4A E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0616: E8DD CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0617: E8E0 32 C2 EA               LD     (exitParameterByte),A ; Save it
0618: E8E3 C9                     RET
0619: E8E4
0620: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0621: E8E4         ; This function places the current value of the IOBYTE in register A.        ;
0622: E8E4         ;                                                                            ;
0623: E8E4         ; The IOBYTE structure:                                                      ;
0624: E8E4         ;								+-------+-------+-------+-------+            ;
0625: E8E4         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0626: E8E4         ;								+-------+-------+-------+-------+            ;
0627: E8E4         ;				Logical Device     List | Punch | Reader|Console             ;
0628: E8E4         ;                                                                            ;
0629: E8E4         ;                                                                            ;
0630: E8E4         ;			Function Code	:	C = 07H                                      ;
0631: E8E4         ;			Entry Parameters:	None					  		  			 ;
0632: E8E4         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0633: E8E4         ;																			 ;
0634: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0635: E8E4             vGetIOBYTE:
0636: E8E4 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0637: E8E7 32 C2 EA               LD     (exitParameterWord),A ; Return it to caller
0638: E8EA C9                     RET
0639: E8EB         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0640: E8EB         ; This function sets the IOBYTE         									 ;
0641: E8EB         ;                                                                            ;
0642: E8EB         ; The IOBYTE structure:                                                      ;
0643: E8EB         ;								+-------+-------+-------+-------+            ;
0644: E8EB         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0645: E8EB         ;								+-------+-------+-------+-------+            ;
0646: E8EB         ;				Logical Device     List | Punch | Reader|Console             ;
0647: E8EB         ;                                                                            ;
0648: E8EB         ;                                                                            ;
0649: E8EB         ;			Function Code	:	C = 08H                                      ;
0650: E8EB         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0651: E8EB         ;			Exit Parameters :	None                                         ;
0652: E8EB         ;																			 ;
0653: E8EB         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0654: E8EB         ;BDOS put parameter in C before entering this routine
0655: E8EB             vSetIOBYTE:
0656: E8EB 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0657: E8EE 71                     LD     (HL),C               ; Place new vale in it
0658: E8EF C9                     RET
0659: E8F0
0660: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0661: E8F0         ;  This function outputs a string of characters to the console device. The   ;
0662: E8F0         ; address of this string is in registers DE. You must make sure that the last;
0663: E8F0         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0664: E8F0         ; for the end of the string.                                                 ;
0665: E8F0         ;  The "$" itself does not get output to the console.                        ;
0666: E8F0         ;                                                                            ;
0667: E8F0         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0668: E8F0         ; described, checks to see if there is an incoming character, and checks for ;
0669: E8F0         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0670: E8F0         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0671: E8F0         ; the printer).                                                              ;
0672: E8F0         ;                                                                            ;
0673: E8F0         ;			Function Code	:	C = 09H                                      ;
0674: E8F0         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0675: E8F0         ;			Exit Parameters :	None							             ;
0676: E8F0         ;																			 ;
0677: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0678: E8F0             vPrintString:
0679: E8F0 2A C0 EA               LD     HL,(paramDE)         ; Get address of the string
0680: E8F3 4D                     LD     C,L
0681: E8F4 44                     LD     B,H                  ; Put it into BC for call
0682: E8F5 CD 38 E9               CALL   Print                ; out to console
0683: E8F8 C9                     RET
0684: E8F9
0685: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0686: E8F9         ;  This function reads a string of characters from the console device        ;
0687: E8F9         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0688: E8F9         ; editing is possible: the operator can backspace, cancel the line and start ;
0689: E8F9         ; over, and use all the normal control functions. What you will ultimately   ;
0690: E8F9         ; see in the buffer is the final version of the character string entered,    ;
0691: E8F9         ; without any of the errors or control characters used to do the line editing;
0692: E8F9         ;                                                                            ;
0693: E8F9         ;  The buffer that you define has a special format. The first byte in the    ;
0694: E8F9         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0695: E8F9         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0696: E8F9         ; were actually placed in the buffer. The following bytes contain            ;
0697: E8F9         ; the characters of the string. Character input will cease either when a     ;
0698: E8F9         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0699: E8F9         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0700: E8F9         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0701: E8F9         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0702: E8F9         ; the "characters input" byte to O. If you attempt to input more than the    ;
0703: E8F9         ; maximum number of characters, the "characters input" count will be the     ;
0704: E8F9         ; same as the maximum value allowed.                                         ;
0705: E8F9         ;                                                                            ;
0706: E8F9         ;			Function Code	:	C = 0AH                                      ;
0707: E8F9         ;			Entry Parameters:	DE = Address string buffer					 ;
0708: E8F9         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0709: E8F9         ;																			 ;
0710: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0711: E8F9             vReadString:
0712: E8F9 CD DD E9               CALL   ReadString
0713: E8FC C9                     RET
0714: E8FD
0715: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0716: E8FD         ; This function tells you whether a console input character is waiting to be ;
0717: E8FD         ;processed. Unlike the Console Input functions, which will wait until there  ;
0718: E8FD         ;is input,this function simply checks and returns immediately.               ;
0719: E8FD         ;                                                                            ;
0720: E8FD         ;			Function Code	:	C = 0BH                                      ;
0721: E8FD         ;			Entry Parameters:	None										 ;
0722: E8FD         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0723: E8FD         ;								A = FFH	if incoming Data					 ;
0724: E8FD         ;																			 ;
0725: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0726: E8FD             vGetConsoleStatus:
0727: E8FD CD 89 E9               CALL   ConBreak
0728: E900 32 C2 EA               LD     (exitParameterByte),A
0729: E903 C9                     RET
0730: E904
0731: E904         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0732: E904         ;  This function tells you which version of CP/M you are currently running.  ;
0733: E904         ; A two-byte value is returned:                                              ;
0734: E904         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0735: E904         ;	L = OOH for all releases before CP/M 2.0                                 ;
0736: E904         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0737: E904         ;		and so on for any subsequent releases.                               ;
0738: E904         ;                                                                            ;
0739: E904         ; This information is of interest only if your program has some version      ;
0740: E904         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0741: E904         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0742: E904         ; Therefore, if your program uses Random I/O, put this check at the          ;
0743: E904         ; beginning to ensure that it is indeed running under the appropriate        ;
0744: E904         ; version of CP/M.                                                           ;
0745: E904         ;                                                                            ;
0746: E904         ;			Function Code	:	C = 0CH                                      ;
0747: E904         ;			Entry Parameters:	None										 ;
0748: E904         ;			Exit Parameters :	HL =Version Number Code						 ;
0749: E904         ;								A = FFH	if incoming Data					 ;
0750: E904         ;																			 ;
0751: E904         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0752: E904             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0753: E904 3E 20                  LD     A,VERSION
0754: E906 32 C2 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0755: E909 C9                     RET
0756: E90A
0757: E90A         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0758: E90A         ;  This subroutine either sets or gets the current user number. The current  ;
0759: E90A         ; user number determines which file directory entries are matched during all ;
0760: E90A         ; disk file operations. When you call this function, the contents of the     ;
0761: E90A         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0762: E90A         ; will return the current user number in the A register. If you set E to a   ;
0763: E90A         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0764: E90A         ; will set the current user number to this value.                            ;
0765: E90A         ;                                                                            ;
0766: E90A         ;			Function Code	:	C = 0CH                                      ;
0767: E90A         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0768: E90A         ;								  = 0 to 15 to set User Number				 ;
0769: E90A         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0770: E90A         ;								A = FFH	if incoming Data					 ;
0771: E90A         ;																			 ;
0772: E90A         ;                                                                            ;
0773: E90A         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0774: E90A             vGetSetUserNumber:
0775: E90A 3A BF EA               LD     A,(paramE)
0776: E90D FE FF                  CP     0FFH
0777: E90F 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0778: E911 3A 5F F5               LD     A,(currentUserNumber)
0779: E914 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0780: E917 C9                     RET
0781: E918
0782: E918             SetUserNumber:
0783: E918 E6 0F                  AND    LO_NIBBLE_MASK
0784: E91A 32 5F F5               LD     (currentUserNumber),A
0785: E91D C9                     RET
0786: E91E
0787: E91E         ;****************************************************************************;
0788: E91E         ;								Character Support Routines					 ;
0789: E91E         ;****************************************************************************;
0790: E91E
0791: E91E
0792: E91E         ;-------------------- Return a Character from the console -------------------;
0793: E91E         ;return byte from buffer or read from the console                            ;
0794: E91E             ConIn:                          ;
0795: E91E 21 BB EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0796: E921 7E                     LD     A,(HL)               ;
0797: E922 36 00                  LD     (HL),0               ;
0798: E924 B7                     OR     A                    ;
0799: E925 C0                     RET    NZ                   ;
0800: E926         ;
0801: E926 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0802: E929         ;-------------------- Return a Character from the console -------------------;
0803: E929
0804: E929         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0805: E929         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0806: E929             IsPrintableASCII:                      ;
0807: E929 FE 0D                  CP     CR                   ;
0808: E92B C8                     RET    Z                    ; carriage return?                                                  ;
0809: E92C FE 0A                  CP     LF                   ;
0810: E92E C8                     RET    Z                    ; line feed?                                                        ;
0811: E92F FE 09                  CP     TAB                  ;
0812: E931 C8                     RET    Z                    ; TAB?                                                              ;
0813: E932 FE 08                  CP     CTRL_H               ;
0814: E934 C8                     RET    Z                    ; backspace?                                                        ;
0815: E935 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0816: E937 C9                     RET                         ;
0817: E938         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0818: E938
0819: E938         ;------------------ Print character from (BC) until  $ found ----------------;
0820: E938             Print:                          ;
0821: E938 0A                     LD     A,(BC)               ; Get the next character             ;
0822: E939 FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0823: E93B C8                     RET    Z                    ;  exit if yes                       ;
0824: E93C 03                     INC    BC                   ; Update the pointer                 ;
0825: E93D C5                     PUSH   BC                   ; Save it                            ;
0826: E93E 4F                     LD     C,A                  ; Does Byte require                  ;
0827: E93F CD 55 E9               CALL   TabOut               ;  special attention - check         ;
0828: E942 C1                     POP    BC                   ; Retrieve the pointer				 ;
0829: E943 18 F3                  JR     Print                ; Loop back                          ;
0830: E945         ;------------------ Print character from (BC) until  $ found ----------------;
0831: E945
0832: E945         ;-- Send printable character to console. Precede with Caret if needed -------;
0833: E945         ; character is in Reg C                                                      ;
0834: E945             CaretOut:                       ;
0835: E945 79                     LD     A,C                  ;
0836: E946 CD 29 E9               CALL   IsPrintableASCII     ;
0837: E949 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0838: E94B         ; send preceding up arrow                                                    ;
0839: E94B F5                     PUSH   AF                   ; Save the character                 ;
0840: E94C 0E 5E                  LD     C,CARET              ;
0841: E94E CD 68 E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0842: E951 F1                     POP    AF                   ; Get the character                  ;
0843: E952 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0844: E954 4F                     LD     C,A                  ; Set up to print                    ;
0845: E955         ; fall thru to TabbOut                                                       ;
0846: E955         ;-- Send printable character to console. Precede with Caret if needed -------;
0847: E955
0848: E955         ;------------- Send printable character to console. Expand if TAB -----------;
0849: E955         ; character is in Reg C                                                      ;
0850: E955             TabOut:                         ;
0851: E955 79                     LD     A,C                  ;
0852: E956 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0853: E958 C2 68 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0854: E95B         ;
0855: E95B         ; TAB encountered                                                           ;
0856: E95B             TabOut0:                        ;
0857: E95B 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0858: E95D CD 68 E9               CALL   ConsoleOut           ; Send to Console                    ;
0859: E960 3A BE EA               LD     A,(columnPosition)   ; Get Column position                ;
0860: E963 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0861: E965 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0862: E967 C9                     RET                         ;
0863: E968         ;------------- Send printable character to console. Expand if TAB -----------;
0864: E968
0865: E968         ;-------------------------- Send character to console -----------------------;
0866: E968         ; C  = Character to be output                                                ;
0867: E968             ConsoleOut:                      ;
0868: E968         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0869: E968 C5                     PUSH   BC                   ; Save character and Count           ;
0870: E969 CD 89 E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0871: E96C C1                     POP    BC                   ;
0872: E96D C5                     PUSH   BC                   ; Get/save character                 ;
0873: E96E         ; Send character to Console	                                                 ;
0874: E96E CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0875: E971 C1                     POP    BC                   ;
0876: E972 C5                     PUSH   BC                   ; Get/save character                 ;
0877: E973         ; is the data to be output to print device?                                  ;
0878: E973 3A BC EA               LD     A,(printEchoFlag)    ;
0879: E976 B7                     OR     A                    ;
0880: E977 C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0881: E97A C1                     POP    BC                   ; Get the character                  ;
0882: E97B         ;
0883: E97B 79                     LD     A,C                  ; Put character to ACC               ;
0884: E97C 21 BE EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0885: E97F 34                     INC    M                    ; increment the ColumnPosition       ;
0886: E980         ;
0887: E980 FE 20                  CP     SPACE                ;
0888: E982 D0                     RET    NC                   ; Exit if ASCII printable            ;
0889: E983         ;
0890: E983 FE 0A                  CP     LF                   ;
0891: E985 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0892: E986         ;
0893: E986 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0894: E988 C9                     RET                         ;
0895: E989         ;-------------------------- Send character to console -----------------------;
0896: E989
0897: E989         ;--------------------  Check for Status and Control S or C ------------------;
0898: E989         ;  Returns:																	 ;
0899: E989         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0900: E989         ;			ACC = 00   No data Pending										 ;
0901: E989         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0902: E989         ;                                                                            ;
0903: E989             ConBreak:                       ;
0904: E989 3A BB EA               LD     A,(keyboardByte)     ;
0905: E98C B7                     OR     A                    ; If there is a char waiting         ;
0906: E98D 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0907: E98F         ;
0908: E98F CD 06 F6               CALL   bcConst              ; Get status                         ;
0909: E992 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0910: E994 C8                     RET    Z                    ; Return 00 No data pending          ;
0911: E995         ;
0912: E995 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0913: E998         ;
0914: E998 FE 10                  CP     CTRL_P               ;
0915: E99A 20 0D                  JR     NZ,CheckCTL_S        ;
0916: E99C         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0917: E99C 21 BC EA               LD     HL,printEchoFlag     ;
0918: E99F 3E FF                  LD     A,TRUE               ;
0919: E9A1 BE                     CP     (HL)                 ;
0920: E9A2 20 02                  JR     NZ,ToggleFlag1       ;
0921: E9A4 3E 00                  LD     A,FALSE              ;
0922: E9A6             ToggleFlag1:                      ;
0923: E9A6 77                     LD     (HL),A               ;
0924: E9A7 18 0C                  JR     NothingWaiting       ;
0925: E9A9         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0926: E9A9             CheckCTL_S:                      ;
0927: E9A9 FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0928: E9AB 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0929: E9AD         ;
0930: E9AD CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0931: E9B0 FE 03                  CP     CTRL_C               ;
0932: E9B2 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0933: E9B5             NothingWaiting:                      ;
0934: E9B5 AF                     XOR    A                    ;
0935: E9B6 C9                     RET                         ; Set ACC = 0 and return             ;
0936: E9B7             ConBreak0:                      ;
0937: E9B7 32 BB EA               LD     (keyboardByte),A     ; save the byte                      ;
0938: E9BA             ConBreak1:                      ;
0939: E9BA 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0940: E9BC C9                     RET                         ;
0941: E9BD         ;--------------------  Check for Status and Control S or C ------------------;
0942: E9BD
0943: E9BD         ;------------------------  Console Output Utilities -------------------------;
0944: E9BD             showHashCRLF:                      ;
0945: E9BD 0E 23                  LD     C,HASH_TAG           ;
0946: E9BF CD 68 E9               CALL   ConsoleOut           ; Send # to console                  ;
0947: E9C2 CD D3 E9               CALL   showCRLF             ;
0948: E9C5             showHashCRLF1:                      ;
0949: E9C5 3E BE                  LD     A,columnPosition     ;
0950: E9C7 21 BD EA               LD     HL,startingColumn    ;
0951: E9CA BF                     CP     A,M                  ;
0952: E9CB D0                     RET    NC                   ;
0953: E9CC 0E 20                  LD     C,SPACE              ;
0954: E9CE CD 68 E9               CALL   ConsoleOut           ;
0955: E9D1 18 F2                  JR     showHashCRLF1        ;
0956: E9D3         ;------------------------  Console Output Utilities -------------------------;
0957: E9D3
0958: E9D3         ;------------------------  Send Carriage Return and Line Feed ---------------;
0959: E9D3             showCRLF:                       ;
0960: E9D3 0E 0D                  LD     C,CR                 ;
0961: E9D5 CD 68 E9               CALL   ConsoleOut           ;
0962: E9D8 0E 0A                  LD     C,LF                 ;
0963: E9DA C3 68 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0964: E9DD         ;------------------------  Send Carriage Return and Line Feed ---------------;
0965: E9DD
0966: E9DD         ;------------------------- Read a $ terminated String -----------------------;
0967: E9DD         ;read to paramDE address (max length, current length, buffer)               ;
0968: E9DD             ReadString:                      ;
0969: E9DD 3A BE EA               LD     A,(columnPosition)   ;
0970: E9E0 32 BD EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0971: E9E3 2A C0 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0972: E9E6 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0973: E9E7 23                     INC    HL                   ; Point at actual bytes read         ;
0974: E9E8 06 00                  LD     B,0                  ; Initialize Current Count           ;
0975: E9EA         ;
0976: E9EA         ; B = Current Count                                                      ;
0977: E9EA         ; C = Maximum characters                                                 ;
0978: E9EA         ; HL= Insertion Pointer                                                  ;
0979: E9EA         ;
0980: E9EA         ; read next character, BC, HL active                                        ;
0981: E9EA             ReadNext:                       ;
0982: E9EA C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0983: E9EB E5                     PUSH   HL                   ; Save pointer                       ;
0984: E9EC             ReadNext0:                      ;
0985: E9EC CD 1E E9               CALL   ConIn                ; Get the next Character             ;
0986: E9EF E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0987: E9F1 E1                     POP    HL                   ; Restore Pointer					 ;
0988: E9F2 C1                     POP    BC                   ; Restore Current Index and Max Count;
0989: E9F3         ;Is It Carriage Return                                                       ;
0990: E9F3 FE 0D                  CP     CR                   ;
0991: E9F5 CA 3B EA               JP     Z,EndRead            ; End the read if yes                ;
0992: E9F8 FE 0A                  CP     LF                   ;
0993: E9FA         ;Is It Linefeed                                                              ;
0994: E9FA CA 3B EA               JP     Z,EndRead            ; End the read if yes                ;
0995: E9FD         ;Is It BackSpace                                                             ;
0996: E9FD FE 08                  CP     CTRL_H               ;
0997: E9FF CA 45 EA               JP     Z,BSspaceBS          ;
0998: EA02             IsItRubout:                      ;
0999: EA02 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
1000: EA04 CA 4F EA               JP     Z,ItIsRubout         ;
1001: EA07             IsPhysicalEOL:                      ;
1002: EA07 FE 05                  CP     CTRL_E               ;
1003: EA09 CA 5A EA               JP     Z,ItIsPhysicalEOL    ;
1004: EA0C             IsItPrintToggle:                      ;
1005: EA0C FE 10                  CP     CTRL_P               ;
1006: EA0E CA 62 EA               JP     Z,ItIsPrintToggle    ;
1007: EA11             IsItDeleteTheLineX:                      ;
1008: EA11 FE 18                  CP     CTRL_X               ;
1009: EA13 CA 8B EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1010: EA16             IsItDeleteTheLineU:                      ;
1011: EA16 FE 15                  CP     CTRL_U               ;
1012: EA18 CA A9 EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1013: EA1B         ;Retype the line                                                             ;
1014: EA1B FE 12                  CP     CTRL_R               ;
1015: EA1D CA 72 EA               JP     Z,RepeatLine         ;
1016: EA20
1017: EA20         ;....................... Echo input back to the Console  ....................;
1018: EA20         ; Full Duplex								                                 ;
1019: EA20         ; A = Character to display	                                                 ;
1020: EA20         ; B = current char count                                                     ;
1021: EA20         ; C = maximum buffer length                                                  ;
1022: EA20         ; HL= buffer pointer                                                         ;
1023: EA20         ;ReadEcho                                                                    ;
1024: EA20 04                     INC    B                    ; Increment byte count		         ;
1025: EA21 23                     INC    HL                   ; Advance the Pointer                ;
1026: EA22 77                     LD     (HL),A               ; Put char in buffer                 ;
1027: EA23         ;
1028: EA23             ReadEchoRubOut:                      ;
1029: EA23 C5                     PUSH   BC                   ; Save index and length              ;
1030: EA24 E5                     PUSH   HL                   ; Save the Pointer                   ;
1031: EA25 4F                     LD     C,A                  ; Get char                           ;
1032: EA26 CD 45 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1033: EA29 E1                     POP    HL                   ; Restore the Pointer                ;
1034: EA2A C1                     POP    BC                   ; Restore index and length           ;
1035: EA2B 7E                     LD     A,(HL)               ; Recall char                        ;
1036: EA2C         ; check for Warm Boot                                                        ;
1037: EA2C FE 03                  CP     CTRL_C               ;
1038: EA2E 78                     LD     A,B                  ; Get Line position                  ;
1039: EA2F C2 37 EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1040: EA32 FE 01                  CP     1                    ; Beginning of the Line?             ;
1041: EA34 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1042: EA37         ; Check to see if we are at the end of the buffer                            ;
1043: EA37             AreWeAtEndOfBuffer:                      ;
1044: EA37 B9                     CP     C                    ; Over Max ?					     ;
1045: EA38 DA EA E9               JP     C,ReadNext           ;  no, Go for more				     ;
1046: EA3B         ;
1047: EA3B         ; At the end of read                                  					     ;
1048: EA3B             EndRead:                        ;
1049: EA3B         ; 	POP		HL                                                               ;
1050: EA3B 2A C0 EA               LD     HL,(paramDE)         ;
1051: EA3E 23                     INC    HL                   ;
1052: EA3F         ;
1053: EA3F 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1054: EA40 0E 0D                  LD     C,CR                 ;
1055: EA42 C3 68 E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1056: EA45         ;....................... Echo input back to the Console  ....................;
1057: EA45         ;.......................... Backspace SPACE BackSpace .......................;
1058: EA45             BSspaceBS:                      ;
1059: EA45 05                     DEC    B                    ;
1060: EA46 2B                     DEC    HL                   ;
1061: EA47 C5                     PUSH   BC                   ;
1062: EA48 E5                     PUSH   HL                   ;
1063: EA49 CD 9C EA               CALL   BackUp               ;
1064: EA4C C3 EC E9               JP     ReadNext0            ;
1065: EA4F         ;.......................... Backspace SPACE BackSpace .......................;
1066: EA4F         ;.......................... It is RubOut ....................................;
1067: EA4F             ItIsRubout:                      ;
1068: EA4F         ; RUBOUT if possible                                                         ;
1069: EA4F 78                     LD     A,B                  ; Are we at the start of the line    ;
1070: EA50 B7                     OR     A                    ;
1071: EA51 CA EA E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1072: EA54         ;adjust pointers back one                                                    ;
1073: EA54 7E                     LD     A,(HL)               ; ACC = current character            ;
1074: EA55 05                     DEC    B                    ; Adjust the index			    	 ;
1075: EA56 2B                     DEC    HL                   ; Adjust the pointer                 ;
1076: EA57 C3 23 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1077: EA5A         ;.......................... It is RubOut ....................................;
1078: EA5A         ;.......................... It is PhysicalEOL ...............................;
1079: EA5A             ItIsPhysicalEOL:                      ;
1080: EA5A C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1081: EA5B E5                     PUSH   HL                   ; Save pointer                       ;
1082: EA5C CD D3 E9               CALL   showCRLF             ; Make new line                      ;
1083: EA5F C3 EC E9               JP     ReadNext0            ;   and go for next char   			 ;
1084: EA62         ;.......................... It is PhysicalEOL ...............................;
1085: EA62         ;.......................... It is PrintToggle ...............................;
1086: EA62             ItIsPrintToggle:                      ;
1087: EA62 E5                     PUSH   HL                   ; Save pointer                       ;
1088: EA63         ; Toggle the printEcho Flag                                                  ;
1089: EA63 21 BC EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1090: EA66 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1091: EA68 BE                     CP     (HL)                 ; Is the flag true?                  ;
1092: EA69 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1093: EA6B 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1094: EA6D             IsItPrintToggle1:                      ;
1095: EA6D 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1096: EA6E E1                     POP    HL                   ; Restore pointer                    ;
1097: EA6F C3 EA E9               JP     ReadNext             ;   and for another char             ;
1098: EA72         ;.......................... It is PrintToggle ...............................;
1099: EA72         ;.......................... RepeatLine ......................................;
1100: EA72             RepeatLine:                      ;
1101: EA72 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1102: EA73 E5                     PUSH   HL                   ;  for exit                          ;
1103: EA74 CD BD E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1104: EA77         ;
1105: EA77 2A C0 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1106: EA7A 23                     INC    HL                   ; Skip past character count          ;
1107: EA7B         ;
1108: EA7B             LL1:                            ;
1109: EA7B 23                     INC    HL                   ; Point at next char to display      ;
1110: EA7C C5                     PUSH   BC                   ; Save counter, in B                 ;
1111: EA7D E5                     PUSH   HL                   ; Save buffer pointer                ;
1112: EA7E 4E                     LD     C,M                  ; Get the next character             ;
1113: EA7F CD 45 E9               CALL   CaretOut             ; Display it                         ;
1114: EA82 E1                     POP    HL                   ; Restore                            ;
1115: EA83 C1                     POP    BC                   ;  the counter and pointer           ;
1116: EA84 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1117: EA86 E1                     POP    HL                   ; Restore values                     ;
1118: EA87 C1                     POP    BC                   ;  from routine entry                ;
1119: EA88 C3 EA E9               JP     ReadNext             ; Done here !                        ;
1120: EA8B         ;.......................... RepeatLine ......................................;
1121: EA8B         ;.......................... Delete The Line .................................;
1122: EA8B             DeleteTheLine:                      ;
1123: EA8B E1                     POP    HL                   ; Adjust Stack                       ;
1124: EA8C         ;                                             ;
1125: EA8C             DeleteTheLine1:                      ;
1126: EA8C 3A BD EA               LD     A,(startingColumn)   ;
1127: EA8F 21 BE EA               LD     HL,columnPosition    ;
1128: EA92 BE                     CP     M                    ; Start of line ?                    ;
1129: EA93 D2 DD E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1130: EA96 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1131: EA97 CD 9C EA               CALL   BackUp               ; Clear 1 column                     ;
1132: EA9A 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1133: EA9C         ;.......................... Delete The Line .................................;
1134: EA9C         ;------------------------ Back-up one screen position -----------------------;
1135: EA9C             BackUp:                         ;
1136: EA9C CD A4 EA               CALL   BackUp1              ; Send Backspace                     ;
1137: EA9F 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1138: EAA1 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1139: EAA4         ;does not affect column count                                                ;
1140: EAA4             BackUp1:                        ;
1141: EAA4 0E 08                  LD     C,CTRL_H             ;
1142: EAA6 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1143: EAA9         ;------------------------ Back-up one screen position -----------------------;
1144: EAA9         ;.......................... Ignore The Line .................................;
1145: EAA9             IgnoreTheLine:                      ;
1146: EAA9 CD BD E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1147: EAAC 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1148: EAAE CD 0C F6               CALL   bcConout             ;  to the console                    ;
1149: EAB1 0E 20                  LD     C,SPACE              ;
1150: EAB3 CD 0C F6               CALL   bcConout             ;
1151: EAB6 C3 DD E9               JP     ReadString           ; Start all over                     ;
1152: EAB9         ;.......................... Ignore The Line .................................;
1153: EAB9
1154: EAB9         ;------------------------- Read a $ terminated String -----------------------;
1155: EAB9
1156: EAB9         ;****************************************************************************
1157: EAB9         ;                           DATA AREA                                       *
1158: EAB9         ;****************************************************************************
1159: EAB9
1160: EAB9         ;------------------------------Non Disk Data Area ---------------------------;
1161: EAB9             usersStack: DS     2                    ; entry stack pointer                ;
1162: EABB         ;
1163: EABB 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1164: EABC         ;
1165: EABC 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1166: EABD         ;
1167: EABD         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1168: EABD 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1169: EABE 00          columnPosition: DB     0                    ; Current Column position            ;
1170: EABF         ;
1171: EABF             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1172: EAC0             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1173: EAC2             exitParameterByte:                      ; Byte returned Value                ;
1174: EAC2             exitParameterWord: DS     WORD                 ; Word                           ;
1175: EAC4         ;
1176: EAC4         ;
1177: EAC4         ;------------------------------------ Data Area -----------------------------;
1178: EAC4
1179: EAC4
1180: EAC4
1181: EAC4         ;****************************************************************************;
1182: EAC4         ;								Disk I/O									 ;
1183: EAC4         ;****************************************************************************;
1184: EAC4
1185: EAC4         ;---------------------------- Reset Disk System - D (13) --------------------;
1186: EAC4         ;  This function requests CP/M to completely reset the disk file system.     ;
1187: EAC4         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1188: EAC4         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1189: EAC4         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1190: EAC4         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1191: EAC4         ; in each logical disk as each disk is accessed. This involves reading the   ;
1192: EAC4         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1193: EAC4         ; which keep track of which allocation blocks are free and which             ;
1194: EAC4         ; are used for file storage.                                                 ;
1195: EAC4         ;                                                                            ;
1196: EAC4         ;			Function Code	:	C = 0DH                                      ;
1197: EAC4         ;			Entry Parameters:	None										 ;
1198: EAC4         ;			Exit Parameters :	None										 ;
1199: EAC4         ;																			 ;
1200: EAC4         ;---------------------------- Reset Disk System - D (13) --------------------;
1201: EAC4             vResetSystem:
1202: EAC4 21 00 00               LD     HL,0
1203: EAC7 22 62 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1204: EACA 22 64 F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1205: EACD AF                     XOR    A                    ; Clear the current disk
1206: EACE 32 60 F5               LD     (currentDisk),A
1207: EAD1         ; note that currentUserNumber remains unchanged
1208: EAD1 21 80 00               LD     HL,DMABuffer
1209: EAD4 22 66 F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1210: EAD7 CD B1 ED               CALL   SetDataDMA           ; to data DMA address
1211: EADA C3 63 EC               JP     Select
1212: EADD         ;---------------------------- Select Disk - E (14) -------------------------;
1213: EADD         ;  This function makes the logical disk named in register E the default disk;
1214: EADD         ; All subsequent references to disk files that do not specify the disk will ;
1215: EADD         ; use this default. When you reference a disk file that does have an        ;
1216: EADD         ; explicit logical disk in its name you do not have to issue another        ;
1217: EADD         ; Select Disk function; the BDOS will take care of that for you.            ;
1218: EADD         ;                                                                           ;
1219: EADD         ;  Notice the way in which the logical disk is specified in register E.     ;
1220: EADD         ; It is not the same as the disk drive specification in the first byte of   ;
1221: EADD         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1222: EADD         ; "use the current default disk" (as specified in the last Select Disk      ;
1223: EADD         ; call or by the operator on the console). With this function, a value      ;
1224: EADD         ; of OOH in register A means that A is the selected drive, a value of       ;
1225: EADD         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1226: EADD         ; 16 drives in the system.                                                  ;
1227: EADD         ;                                                                           ;
1228: EADD         ;			Function Code	:	C = 0EH                                     ;
1229: EADD         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1230: EADD         ;			Exit Parameters :	None										;
1231: EADD         ;																			;
1232: EADD         ;---------------------------- Select Disk - E (14) -------------------------;
1233: EADD
1234: EADD             vSelectDisk:
1235: EADD C3 57 EC               JP     SelectCurrent
1236: EAE0
1237: EAE0         ;---------------------------- Open File - F (15) ---------------------------;
1238: EAE0         ;  This function opens a specified file for reading or writing. The FCB,    ;
1239: EAE0         ; whose address must be in register DE, tells CP/M the user number,         ;
1240: EAE0         ; the logical disk, the file name, and the file type. All other bytes of    ;
1241: EAE0         ; the FCB will normally be set to O.                                        ;
1242: EAE0         ;  The code returned by the BDOS in register A indicates whether the file   ;
1243: EAE0         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1244: EAE0         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1245: EAE0         ; then the file has been opened.                                            ;
1246: EAE0         ;			Function Code	:	C  = 0FH                                    ;
1247: EAE0         ;			Entry Parameters:	DE = Address of File Control Block			;
1248: EAE0         ;			Exit Parameters :	A  = Directory Code							;
1249: EAE0         ;																			;
1250: EAE0         ;---------------------------- Open File - F (15) ---------------------------;
1251: EAE0             vOpenFile:
1252: EAE0 CD 5E EE               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1253: EAE3 CD DF ED               CALL   ReselectDisk         ; do we need to reselect disk?
1254: EAE6 C3 3A ED               JP     OpenFile
1255: EAE9
1256: EAE9         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1257: EAE9         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1258: EAE9         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1259: EAE9         ; This function returns a bit map, called the login vector, in register pair ;
1260: EAE9         ; HL, indicating which logical disk drives have been selected since the last ;
1261: EAE9         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1262: EAE9         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1263: EAE9         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1264: EAE9         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1265: EAE9         ;  Logical disks can be selected programmatically through any file operation ;
1266: EAE9         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1267: EAE9         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1268: EAE9         ; where "X" is equal to A, B, ... , P.                                       ;
1269: EAE9         ;                                                                            ;
1270: EAE9         ;			Function Code	:	C = 018H                                     ;
1271: EAE9         ;			Entry Parameters:	None										 ;
1272: EAE9         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1273: EAE9         ;																			 ;
1274: EAE9         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1275: EAE9             vGetLoginVector:
1276: EAE9 2A 64 F5               LD     HL,(loggedDisks)
1277: EAEC 22 C2 EA               LD     (exitParameterWord),HL
1278: EAEF C9                     RET
1279: EAF0         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1280: EAF0         ;   This function returns the current default disk set by the last Select    ;
1281: EAF0         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1282: EAF0         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1283: EAF0         ;                                                                            ;
1284: EAF0         ;  This function returns the current default disk in coded form.             ;
1285: EAF0         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1286: EAF0         ; If you need to convert this to the corresponding ASCII character, simply   ;
1287: EAF0         ; add 41H to register A. Use this function when you convert a file name and  ;
1288: EAF0         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1289: EAF0         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1290: EAF0         ; You must therefore use this function to determine the logical disk letter  ;
1291: EAF0         ; for the default drive.                                                     ;
1292: EAF0         ;                                                                            ;
1293: EAF0         ;			Function Code	:	C = 019H                                     ;
1294: EAF0         ;			Entry Parameters:	None										 ;
1295: EAF0         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1296: EAF0         ;																			 ;
1297: EAF0         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1298: EAF0             vGetCurrentDisk:
1299: EAF0 3A 60 F5               LD     A,(currentDisk)
1300: EAF3 32 C2 EA               LD     (exitParameterByte),A
1301: EAF6 C9                     RET
1302: EAF7         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1303: EAF7         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1304: EAF7         ; value. The name is an historic relic dating back to the Intel Development  ;
1305: EAF7         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1306: EAF7         ; its hardware, could read data from a diskette directly into memory or      ;
1307: EAF7         ; write data to a diskette directly from memory. The name DMA address now    ;
1308: EAF7         ; applies to the address of the buffer to and from which data is             ;
1309: EAF7         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1310: EAF7         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1311: EAF7         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1312: EAF7         ; value of 0080H.                                                            ;
1313: EAF7         ;                                                                            ;
1314: EAF7         ;			Function Code	:	C = 0A9H                                     ;
1315: EAF7         ;			Entry Parameters:	DE = DMA Address							 ;
1316: EAF7         ;			Exit Parameters :	None										 ;
1317: EAF7         ;																			 ;
1318: EAF7         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1319: EAF7             vSetDMA:
1320: EAF7 2A C0 EA               LD     HL,(paramDE)
1321: EAFA 22 66 F5               LD     (initDAMAddress),HL
1322: EAFD C3 B1 ED               JP     SetDataDMA
1323: EB00         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1324: EB00         ;  This function returns the base, or starting, address of the allocation    ;
1325: EB00         ; vector for the currently selected logical disk. This information,          ;
1326: EB00         ; indicating which parts of the disk are assigned, is used by utility        ;
1327: EB00         ; programs and the BDOS itself to determine how much unused space is on the  ;
1328: EB00         ; logical disk, to locate an unused allocation block in order to extend      ;
1329: EB00         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1330: EB00         ;                                                                            ;
1331: EB00         ;			Function Code	:	C = 01BH                                     ;
1332: EB00         ;			Entry Parameters:	None										 ;
1333: EB00         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1334: EB00         ;																			 ;
1335: EB00         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1336: EB00             vGetAllocAddr:
1337: EB00 2A 74 F5               LD     HL,(caAllocVector)
1338: EB03 22 C2 EA               LD     (exitParameterWord),HL
1339: EB06 C9                     RET
1340: EB07         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1341: EB07         ;  This function returns a bit map in registers H and L showing which logical;
1342: EB07         ; disks in the system have been set to Read-Only status, either by the       ;
1343: EB07         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1344: EB07         ; BDOS itself, because it detected that a diskette had been changed.         ;
1345: EB07         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1346: EB07         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1347: EB07         ; the specific logical disk is set to I if the disk has been set to          ;
1348: EB07         ; Read-Only status.                                                          ;
1349: EB07         ;                                                                            ;
1350: EB07         ;			Function Code	:	C = 0DBH                                     ;
1351: EB07         ;			Entry Parameters:	None										 ;
1352: EB07         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1353: EB07         ;																			 ;
1354: EB07         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1355: EB07             vGetReadOnlyMap:
1356: EB07 2A 62 F5               LD     HL,(readOnlyVector)
1357: EB0A 22 C2 EA               LD     (exitParameterWord),HL
1358: EB0D C9                     RET
1359: EB0E         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1360: EB0E         ;  This function returns the address of the disk parameter block (DPB) for   ;
1361: EB0E         ; the last selected logical disk. The DPB describes the physical             ;
1362: EB0E         ; characteristics of a specific logical disk-information mainly of interest  ;
1363: EB0E         ; for system utility programs.                                               ;
1364: EB0E         ;                                                                            ;
1365: EB0E         ;			Function Code	:	C = 1FH                                      ;
1366: EB0E         ;			Entry Parameters:	None										 ;
1367: EB0E         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1368: EB0E         ;																			 ;
1369: EB0E         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1370: EB0E             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1371: EB0E 2A 70 F5               LD     HL,(caDiskParamBlock)
1372: EB11 22 C2 EA               LD     (exitParameterWord),HL
1373: EB14 C9                     RET
1374: EB15
1375: EB15         ;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
1376: EB15         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1377: EB15         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1378: EB15         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1379: EB15
1380: EB15         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1381: EB15         ;  This function resets individual disk drives. It is a more precise version ;
1382: EB15         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1383: EB15         ; specific logical; disks rather than all of them.                           ;
1384: EB15         ;  The bit map in DE shows which disks are to be reset. The least significant;
1385: EB15         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1386: EB15         ; The bits set to I indicate the disks to be reset.                          ;
1387: EB15         ;  Note that this function returns a zero value in A in order to maintain    ;
1388: EB15         ; compatibility with MP/ M.                                                  ;
1389: EB15         ;                                                                            ;
1390: EB15         ;			Function Code	:	C = 25H                                      ;
1391: EB15         ;			Entry Parameters:	DE = Logical Drive Bit Vector					 ;
1392: EB15         ;			Exit Parameters :	A = 00H										 ;
1393: EB15         ;																			 ;
1394: EB15         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1395: EB15         ;Reset Drive
1396: EB15         ;IN  - (DE) Drive Vector
1397: EB15         ;OUT - (A) 00
1398: EB15             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1399: EB15         ; Not Yet Implemented   **************
1400: EB15 C9                     RET
1401: EB16         ;*****************************************************************
1402: EB16
1403: EB16         ;-----------------------------------------------------------------
1404: EB16
1405: EB16         ;*****************************************************************
1406: EB16         ;random disk read
1407: EB16         ;IN  - (DE) FCB address
1408: EB16         ;OUT - (A) 01 = Reading unwritten data
1409: EB16         ;	 02 = N/U
1410: EB16         ;	 03 = Cannot close current extent
1411: EB16         ;	 04 = Seek to unwriten Extent
1412: EB16         ;	 05 = N/U
1413: EB16         ;	 06 = Seek past Physical end of Disk
1414: EB16             vReadRandom:                      ; func33 (33 - 21) Read Random record
1415: EB16 CD DF ED               CALL   ReselectDisk
1416: EB19 C3 2C EB               JP     RandomDiskRead       ; to perform the disk read
1417: EB1C         ;*****************************************************************
1418: EB1C         ;write random record
1419: EB1C         ;IN  - (DE) FCB address
1420: EB1C         ;OUT - (A) 01 = Reading unwritten data
1421: EB1C         ;	 02 = N/U
1422: EB1C         ;	 03 = Cannot close current extent
1423: EB1C         ;	 04 = Seek to unwriten Extent
1424: EB1C         ;	 05 = Cannot create new Extent because of directory overflow
1425: EB1C         ;	 06 = Seek past Physical end of Disk
1426: EB1C             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1427: EB1C CD DF ED               CALL   ReselectDisk
1428: EB1F C3 35 EB               JP     RandomDiskWrite      ; to perform the disk write
1429: EB22         ;ret ;jmp goback
1430: EB22         ;*****************************************************************
1431: EB22         ;return file size (0-65536)
1432: EB22         ;IN  - (DE) FCB address
1433: EB22             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1434: EB22 CD DF ED               CALL   ReselectDisk
1435: EB25 C3 E2 EB               JP     GetFileSize
1436: EB28         ;*****************************************************************
1437: EB28         ;set random record
1438: EB28         ;IN  - (DE) FCB address
1439: EB28         ;OUT - Random Record Field is set
1440: EB28             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1441: EB28 C3 CF EB               JP     SetRandomRecord
1442: EB2B         ;? ;*****************************************************************
1443: EB2B         ;? ;Reset Drive
1444: EB2B         ;? ;IN  - (DE) Drive Vector
1445: EB2B         ;? ;OUT - (A) 00
1446: EB2B         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
1447: EB2B         ;? ; Not Yet Implemented   **************
1448: EB2B         ;?	RET
1449: EB2B         ;*****************************************************************
1450: EB2B         ;*****************************************************************
1451: EB2B         ;Write Random With Zero Fill
1452: EB2B         ;IN  - (DE) FCB address
1453: EB2B         ;OUT - (A) Return Code		see Function 34
1454: EB2B             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1455: EB2B         ; Not Yet Implemented   **************
1456: EB2B C9                     RET
1457: EB2C         ;*****************************************************************
1458: EB2C         ;******************< Random I/O Stuff ****************************
1459: EB2C         ;*****************************************************************
1460: EB2C         ;random disk read
1461: EB2C             RandomDiskRead:                      ; randiskread
1462: EB2C 0E FF                  LD     C,TRUE               ; marked as read operation
1463: EB2E CD 3E EB               CALL   RandomSeek
1464: EB31 CC 51 F1               CALL   Z,DiskRead           ; if seek successful
1465: EB34 C9                     RET
1466: EB35         ;*****************************************************************
1467: EB35         ;random disk write
1468: EB35             RandomDiskWrite:                      ; randiskwrite
1469: EB35 0E 00                  LD     C,FALSE              ; marked as read operation
1470: EB37 CD 3E EB               CALL   RandomSeek
1471: EB3A CC 94 F1               CALL   Z,DiskWrite          ; if seek successful
1472: EB3D C9                     RET
1473: EB3E         ;*****************************************************************
1474: EB3E         ;*****************************************************************
1475: EB3E         ;random access seek operation, C=0ffh if read mode
1476: EB3E         ;fcb is assumed to address an active file control block
1477: EB3E         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1478: EB3E             RandomSeek:
1479: EB3E AF                     XOR    A
1480: EB3F 32 8A F5               LD     (seqReadFlag),A      ; marked as random access operation
1481: EB42 C5                     PUSH   BC                   ; save r/w flag
1482: EB43 2A C0 EA               LD     HL,(paramDE)
1483: EB46 EB                     EX     DE,HL                ; DE will hold base of fcb
1484: EB47 21 21 00               LD     HL,RANDOM_REC_FIELD
1485: EB4A 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1486: EB4B 7E                     LD     A,(HL)
1487: EB4C E6 7F                  AND    7FH
1488: EB4E F5                     PUSH   AF                   ; record number
1489: EB4F 7E                     LD     A,(HL)
1490: EB50 17                     RLA                         ; cy=lsb of extent#
1491: EB51 23                     INC    HL
1492: EB52 7E                     LD     A,(HL)
1493: EB53 17                     RLA
1494: EB54 E6 1F                  AND    11111B               ; A=ext#
1495: EB56 4F                     LD     C,A                  ; C holds extent number, record stacked
1496: EB57 7E                     LD     A,(HL)
1497: EB58 1F                     RRA
1498: EB59 1F                     RRA
1499: EB5A 1F                     RRA
1500: EB5B 1F                     RRA
1501: EB5C E6 0F                  AND    1111B                ; mod#
1502: EB5E 47                     LD     B,A                  ; B holds module#, C holds ext#
1503: EB5F F1                     POP    AF                   ; recall sought record #
1504: EB60         ;check to insure that high byte of ran rec = 00
1505: EB60 23                     INC    HL
1506: EB61 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1507: EB62 2C                     INC    L
1508: EB63 2D                     DEC    L
1509: EB64 2E 06                  LD     L,06                 ; zero flag, l=6
1510: EB66         ; produce error 6, seek past physical eod
1511: EB66 C2 C7 EB               JP     NZ,RandomSeekError
1512: EB69         ; otherwise, high byte = 0, A = sought record
1513: EB69 21 20 00               LD     HL,NEXT_RECORD
1514: EB6C 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1515: EB6D 77                     LD     (HL),A               ; sought rec# stored away
1516: EB6E         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1517: EB6E         ; the r/w flag is still stacked.  compare fcb values
1518: EB6E 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1519: EB71 19                     ADD    HL,DE
1520: EB72 79                     LD     A,C                  ; A=seek ext#
1521: EB73 96                     SUB    M
1522: EB74 C2 82 EB               JP     NZ,RandomSeekClose   ; tests for = extents
1523: EB77         ; extents match, check mod#
1524: EB77 21 0E 00               LD     HL,fcbS2Index
1525: EB7A 19                     ADD    HL,DE
1526: EB7B 78                     LD     A,B                  ; B=seek mod#
1527: EB7C         ; could be overflow at eof, producing module#
1528: EB7C         ; of 90H or 10H, so compare all but fwf
1529: EB7C 96                     SUB    M
1530: EB7D E6 7F                  AND    7FH
1531: EB7F CA BA EB               JP     Z,RandomSeekExit     ; same?
1532: EB82             RandomSeekClose:
1533: EB82 C5                     PUSH   BC
1534: EB83 D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1535: EB84 CD 34 F3               CALL   CloseDirEntry        ; current extent closed
1536: EB87 D1                     POP    DE
1537: EB88 C1                     POP    BC                   ; recall parameters and fill
1538: EB89 2E 03                  LD     L,03                 ; cannot close error #3
1539: EB8B 3A C2 EA               LD     A,(exitParameterByte)
1540: EB8E 3C                     INC    A
1541: EB8F CA C0 EB               JP     Z,RandomSeekErrorBadSeek
1542: EB92 21 0C 00               LD     HL,fcbExtIndex
1543: EB95 19                     ADD    HL,DE
1544: EB96 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1545: EB97 21 0E 00               LD     HL,fcbS2Index
1546: EB9A 19                     ADD    HL,DE
1547: EB9B 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1548: EB9C CD 3A ED               CALL   OpenFile             ; is the file present?
1549: EB9F 3A C2 EA               LD     A,(exitParameterByte)
1550: EBA2 3C                     INC    A
1551: EBA3 C2 BA EB               JP     NZ,RandomSeekExit    ; open successful?
1552: EBA6         ; cannot open the file, read mode?
1553: EBA6 C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1554: EBA7 C5                     PUSH   BC                   ; everyone expects this item stacked
1555: EBA8 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1556: EBAA 0C                     INC    C                    ; becomes 00 if read operation
1557: EBAB CA C0 EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1558: EBAE CD DC F2               CALL   MakeNewFile          ; write operation, make new extent
1559: EBB1 2E 05                  LD     L,05                 ; cannot create new extent #5
1560: EBB3 3A C2 EA               LD     A,(exitParameterByte)
1561: EBB6 3C                     INC    A
1562: EBB7 CA C0 EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1563: EBBA         ; file make operation successful
1564: EBBA             RandomSeekExit:                      ; seekok:
1565: EBBA C1                     POP    BC                   ; discard r/w flag
1566: EBBB AF                     XOR    A
1567: EBBC 32 C2 EA               LD     (exitParameterByte),A
1568: EBBF C9                     RET                         ; with zero set
1569: EBC0
1570: EBC0             RandomSeekErrorBadSeek:
1571: EBC0         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1572: EBC0         ; appears as overflow with file write flag set
1573: EBC0 E5                     PUSH   HL                   ; save error flag
1574: EBC1 CD 64 EE               CALL   GetExtentNumberMSB   ; HL = .fcbS2Index
1575: EBC4 36 C0                  LD     (HL),11000000B
1576: EBC6 E1                     POP    HL                   ; and drop through
1577: EBC7             RandomSeekError:                      ; seekerr:
1578: EBC7 C1                     POP    BC                   ; discard r/w flag
1579: EBC8 7D                     LD     A,L
1580: EBC9 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1581: EBCC         ; SetFileWriteFlag returns non-zero accumulator for err
1582: EBCC C3 6D EE               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1583: EBCF         ;ret
1584: EBCF         ;
1585: EBCF         ;*****************************************************************
1586: EBCF             SetRandomRecord:                      ; setrandom
1587: EBCF 2A C0 EA               LD     HL,(paramDE)
1588: EBD2 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1589: EBD5 CD 1E EC               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1590: EBD8 21 21 00               LD     HL,RANDOM_REC_FIELD
1591: EBDB 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1592: EBDC 71                     LD     (HL),C
1593: EBDD 23                     INC    HL
1594: EBDE 70                     LD     (HL),B
1595: EBDF 23                     INC    HL
1596: EBE0 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1597: EBE1 C9                     RET
1598: EBE2         ;*****************************************************************
1599: EBE2         ;compute logical file size for current fcb
1600: EBE2             GetFileSize:                      ; getfilesize
1601: EBE2 0E 0C                  LD     C,fcbExtIndex
1602: EBE4 CD 85 EE               CALL   SearchForDirectoryRecord
1603: EBE7         ; zero the receiving Ramdom record field
1604: EBE7 2A C0 EA               LD     HL,(paramDE)
1605: EBEA 11 21 00               LD     DE,RANDOM_REC_FIELD
1606: EBED 19                     ADD    HL,DE
1607: EBEE E5                     PUSH   HL                   ; save position
1608: EBEF 72                     LD     (HL),D
1609: EBF0 23                     INC    HL
1610: EBF1 72                     LD     (HL),D
1611: EBF2 23                     INC    HL
1612: EBF3 72                     LD     (HL),D               ; =00 00 00
1613: EBF4             GetFileSize1:                      ; getsize:
1614: EBF4 CD 09 EF               CALL   AtEndOfDirectory
1615: EBF7 CA 1C EC               JP     Z,GetFileSizeExit
1616: EBFA         ; current fcb addressed by dptr
1617: EBFA CD 12 EF               CALL   GetCurrentDirectoryRecord
1618: EBFD 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1619: EC00 CD 1E EC               CALL   GetRandomRecordPosition
1620: EC03         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1621: EC03 E1                     POP    HL
1622: EC04 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1623: EC05 5F                     LD     E,A                  ; save cy
1624: EC06 79                     LD     A,C
1625: EC07 96                     SUB    M
1626: EC08 23                     INC    HL                   ; ls byte
1627: EC09 78                     LD     A,B
1628: EC0A 9E                     SBC    A,(HL)
1629: EC0B 23                     INC    HL                   ; middle byte
1630: EC0C 7B                     LD     A,E
1631: EC0D 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1632: EC0E DA 16 EC               JP     C,GetFileSize2       ; for another try
1633: EC11         ; fcb is less or equal, fill from directory
1634: EC11 73                     LD     (HL),E
1635: EC12 2B                     DEC    HL
1636: EC13 70                     LD     (HL),B
1637: EC14 2B                     DEC    HL
1638: EC15 71                     LD     (HL),C
1639: EC16             GetFileSize2:                      ; getnextsize:
1640: EC16 CD 9A EE               CALL   GetNextDirectoryRecord
1641: EC19 C3 F4 EB               JP     GetFileSize1
1642: EC1C             GetFileSizeExit:                      ; setsize:
1643: EC1C E1                     POP    HL                   ; discard .fcb(random record field)
1644: EC1D C9                     RET
1645: EC1E         ;-----------------------------------------------------------------
1646: EC1E         ;compute random record position
1647: EC1E             GetRandomRecordPosition:                      ; compute$rr
1648: EC1E EB                     EX     DE,HL
1649: EC1F 19                     ADD    HL,DE
1650: EC20         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1651: EC20 4E                     LD     C,(HL)
1652: EC21 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1653: EC23 21 0C 00               LD     HL,fcbExtIndex
1654: EC26 19                     ADD    HL,DE
1655: EC27 7E                     LD     A,(HL)
1656: EC28 0F                     RRCA
1657: EC29 E6 80                  AND    80H                  ; A=e000 0000
1658: EC2B 81                     ADD    A,C
1659: EC2C 4F                     LD     C,A
1660: EC2D 3E 00                  LD     A,0
1661: EC2F 88                     ADC    A,B
1662: EC30 47                     LD     B,A
1663: EC31         ; BC = 0000 000? errrr rrrr
1664: EC31 7E                     LD     A,(HL)
1665: EC32 0F                     RRCA
1666: EC33 E6 0F                  AND    LO_NIBBLE_MASK
1667: EC35 80                     ADD    A,B
1668: EC36 47                     LD     B,A
1669: EC37         ; BC = 000? eeee errrr rrrr
1670: EC37 21 0E 00               LD     HL,fcbS2Index
1671: EC3A 19                     ADD    HL,DE
1672: EC3B 7E                     LD     A,(HL)               ; A=XXX? mmmm
1673: EC3C 87                     ADD    A,A
1674: EC3D 87                     ADD    A,A
1675: EC3E 87                     ADD    A,A
1676: EC3F 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1677: EC40 F5                     PUSH   AF
1678: EC41 80                     ADD    A,B
1679: EC42 47                     LD     B,A
1680: EC43         ; cy=?, BC = mmmm eeee errr rrrr
1681: EC43 F5                     PUSH   AF                   ; possible second carry
1682: EC44 E1                     POP    HL                   ; cy = lsb of L
1683: EC45 7D                     LD     A,L                  ; cy = lsb of A
1684: EC46 E1                     POP    HL                   ; cy = lsb of L
1685: EC47 B5                     OR     L                    ; cy/cy = lsb of A
1686: EC48 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1687: EC4A C9                     RET
1688: EC4B         ;-----------------------------------------------------------------
1689: EC4B
1690: EC4B
1691: EC4B
1692: EC4B         ;*****************************************************************
1693: EC4B         ;********************** Disk  I/O ********************************
1694: EC4B         ;*****************************************************************
1695: EC4B         ;-----------------------------------------------------------------
1696: EC4B         ;;write protect current disk
1697: EC4B             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1698: EC4B C3 C7 ED               JP     SetDiskReadOnly
1699: EC4E         ;-----------------------------------------------------------------
1700: EC4E         ;;set file Attributes
1701: EC4E             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1702: EC4E CD DF ED               CALL   ReselectDisk
1703: EC51 CD BD F0               CALL   SetAttributes
1704: EC54 C3 09 F4               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1705: EC57         ;-----------------------------------------------------------------
1706: EC57         ;--------------------------- Select  Drive ---------------------------------;
1707: EC57         ; Establish the disk found in (paramE) as the current disk drive            ;
1708: EC57             SelectCurrent:                      ;
1709: EC57 3A BF EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
1710: EC5A 21 60 F5               LD     HL,currentDisk       ; Get the current disk              ;
1711: EC5D BE                     CP     M                    ; Are the the same ?                ;
1712: EC5E C8                     RET    Z                    ; Exit if yes, nothing to do        ;
1713: EC5F 77                     LD     (HL),A               ;  else update curretDisk and       ;
1714: EC60 C3 63 EC               JP     Select               ;  select it                        ;
1715: EC63         ;--------------------------- Select  Drive ---------------------------------;
1716: EC63         ;--------------------------- Select Login Drive ----------------------------;
1717: EC63         ; select Login Drive                                                       ;
1718: EC63             Select:                         ;
1719: EC63 CD 84 EC               CALL   SelectDisk           ; Select the Disk                   ;
1720: EC66 CC CF F4               CALL   Z,errSelect          ;
1721: EC69 21 60 F5               LD     HL,currentDisk       ;
1722: EC6C 46                     LD     B,(HL)               ; Get Current Disk                  ;
1723: EC6D 2A 64 F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
1724: EC70 CD A1 F4               CALL   IsBitSet             ;
1725: EC73 C0                     RET    NZ                   ; Exit if already logged in         ;
1726: EC74         ;                                                                           ;
1727: EC74 21 60 F5               LD     HL,currentDisk       ;
1728: EC77 46                     LD     B,(HL)               ; Get Current Disk                  ;
1729: EC78 2A 64 F5               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
1730: EC7B CD B1 F4               CALL   SetVectorBit         ;
1731: EC7E 22 64 F5               LD     (loggedDisks),HL     ; Update the Vector                 ;
1732: EC81         ;
1733: EC81 C3 CA EC               JP     InitDisk             ;
1734: EC84         ;--------------------------- Select Login Drive ----------------------------;
1735: EC84         ;--------------------------- Select Disk ------------------------------------;
1736: EC84         ;*****************************************************************          ;
1737: EC84         ; select the disk drive given by currentDisk, and fill the base addresses   ;
1738: EC84         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
1739: EC84             SelectDisk:                      ;
1740: EC84 3A 60 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
1741: EC87 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
1742: EC88 CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
1743: EC8B 7C                     LD     A,H                  ; Return Pointer to                  ;
1744: EC8C B5                     OR     L                    ;  Disk Parameter Header             ;
1745: EC8D C8                     RET    Z                    ; exit if error, with HL = 0000      ;
1746: EC8E         ;
1747: EC8E 5E                     LD     E,(HL)               ;
1748: EC8F 23                     INC    HL                   ;
1749: EC90 56                     LD     D,(HL)               ; Skew Table in DE                   ;
1750: EC91 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
1751: EC92 ED 53 85 F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
1752: EC96         ;
1753: EC96 22 68 F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
1754: EC99 23                     INC    HL                   ;
1755: EC9A 23                     INC    HL                   ; HL = Last Track #                  ;
1756: EC9B 22 6A F5               LD     (caTrack),HL         ; Move to Current Track #            ;
1757: EC9E 23                     INC    HL                   ;
1758: EC9F 23                     INC    HL                   ; HL = Last Sector #                 ;
1759: ECA0 22 6C F5               LD     (caSector),HL        ; Move to Current Sector #           ;
1760: ECA3 23                     INC    HL                   ;
1761: ECA4 23                     INC    HL                   ;
1762: ECA5 11 6E F5               LD     DE,caDirectoryDMA    ;
1763: ECA8 01 08 00               LD     BC,caListSize        ;
1764: ECAB ED B0                  LDIR                        ;
1765: ECAD         ;
1766: ECAD         ; finish filling in address list                                             ;
1767: ECAD 2A 70 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
1768: ECB0 11 76 F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
1769: ECB3 01 0F 00               LD     BC,dpbSize           ;
1770: ECB6 ED B0                  LDIR                        ; Move DPB to current                ;
1771: ECB8         ;
1772: ECB8         ; Determine if Byte or Word Allocation Table	                             ;
1773: ECB8 2A 7B F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
1774: ECBB 7C                     LD     A,H                  ; If  its 00 then < 255              ;
1775: ECBC 21 8F F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
1776: ECBF 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
1777: ECC1 B7                     OR     A                    ;  is the assumption confirmed ?     ;
1778: ECC2 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
1779: ECC4 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
1780: ECC6         ;
1781: ECC6         ; Set Sign, reset Carry and Zero to indicate success                         ;
1782: ECC6             SelectDisk1:                      ;
1783: ECC6 3E FF                  LD     A,TRUE               ;
1784: ECC8 B7                     OR     A                    ;
1785: ECC9 C9                     RET                         ;
1786: ECCA         ;--------------------------- Select Disk ------------------------------------;
1787: ECCA         ;--------------------------- Initialize Disk --------------------------------;
1788: ECCA             InitDisk:                       ;
1789: ECCA 2A 7B F5               LD     HL,(dpbDSM)          ; Maximum allocation value           ;
1790: ECCD CD E5 EF               CALL   DivideHLby8          ; Length of Map                      ;
1791: ECD0 E5                     PUSH   HL                   ; Save Length                        ;
1792: ECD1 E5                     PUSH   HL                   ; Save for end of MAP                ;
1793: ECD2 C1                     POP    BC                   ; BC = dpbDSM/8                      ;
1794: ECD3         ; Clear the Allocation Vector	                                             ;
1795: ECD3 2A 74 F5               LD     HL,(caAllocVector)   ; Allocation vector Start            ;
1796: ECD6 36 00                  LD     (HL),0               ; Clear location                     ;
1797: ECD8 ED 5B 74 F5               LD     DE,(caAllocVector)   ;
1798: ECDC 13                     INC    DE                   ; Allocation vector Start + 1        ;
1799: ECDD ED B0                  LDIR                        ; Cascade 00 thru Map                ;
1800: ECDF         ; Force bits at End of Map                                                   ;
1801: ECDF EB                     EX     DE,HL                ; Put last Map byte into DE          ;
1802: ECE0 E1                     POP    HL                   ;
1803: ECE1 23                     INC    HL                   ;
1804: ECE2 CD EF EF               CALL   MultiplyHLby8        ; Blocks if all bits used            ;
1805: ECE5 ED 4B 7B F5               LD     BC,(dpbDSM)          ; Actual block max                   ;
1806: ECE9 03                     INC    BC                   ; Now has size of the Map            ;
1807: ECEA AF                     XOR    A                    ; Clear CY                           ;
1808: ECEB ED 42                  SBC    HL,BC                ; Extra unused bits                  ;
1809: ECED BD                     CP     L                    ;  are there any                     ;
1810: ECEE 28 07                  JR     Z,Mark4Directory     ;
1811: ECF0 45                     LD     B,L                  ; Number of bits to set              ;
1812: ECF1 EB                     EX     DE,HL                ; Put last Map byte into HL          ;
1813: ECF2             SetBitLoop:                      ;
1814: ECF2 37                     SCF                         ;
1815: ECF3 CB 16                  RL     (HL)                 ; Set LSB                            ;
1816: ECF5 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                 ;
1817: ECF7         ;
1818: ECF7             Mark4Directory:                      ;
1819: ECF7         ; Mark the reserved space for the directory                                  ;
1820: ECF7 2A 7F F5               LD     HL,(dpbDABM)         ; Directory block reserved bits      ;
1821: ECFA EB                     EX     DE,HL                ;
1822: ECFB 2A 74 F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector      ;
1823: ECFE 73                     LD     (HL),E               ;
1824: ECFF 23                     INC    HL                   ;
1825: ED00 72                     LD     (HL),D               ; Put reserved blocks in Vector      ;
1826: ED01         ; end of Map                                                                 ;
1827: ED01         ; Home disk, and set current track and sector to 00                          ;
1828: ED01 CD 97 ED               CALL   Home                 ;
1829: ED04 2A 68 F5               LD     HL,(caDirMaxValue)   ;
1830: ED07 36 03                  LD     (HL),3               ;
1831: ED09 23                     INC    HL                   ;
1832: ED0A 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003       ;
1833: ED0C CD 02 EF               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)           ;
1834: ED0F         ;
1835: ED0F             InitDisk1:                      ;
1836: ED0F         ; Process the directory                                                      ;
1837: ED0F 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	     ;
1838: ED11 CD 02 F0               CALL   ReadDirectory        ; Get the directory Record           ;
1839: ED14 CD 09 EF               CALL   AtEndOfDirectory     ; Are we Done ?                      ;
1840: ED17 C8                     RET    Z                    ;  Exit if Yes                       ;
1841: ED18         ; Not end of directory, valid entry?                                         ;
1842: ED18 CD 12 EF               CALL   GetCurrentDirectoryRecord ; Calculate location of the element  ;
1843: ED1B 3E E5                  LD     A,emptyDir           ;
1844: ED1D BE                     CP     M                    ; Is it an Empty Dir Entry           ;
1845: ED1E 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                 ;
1846: ED20         ; Not emptyDir, user code the same?                                          ;
1847: ED20 3A 5F F5               LD     A,(currentUserNumber) ;
1848: ED23 BE                     CP     M                    ;
1849: ED24 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users   ;
1850: ED26         ; Same user, check for '$' submit                                            ;
1851: ED26 23                     INC    HL                   ;
1852: ED27 7E                     LD     A,(HL)               ;
1853: ED28 D6 24                  SUB    DOLLAR               ; Is first Char a $                  ;
1854: ED2A 20 04                  JR     NZ,InitDisk2         ;
1855: ED2C         ; dollar file found, mark in exitParameterByte                               ;
1856: ED2C 3D                     DEC    A                    ; Set A to FFH                       ;
1857: ED2D 32 C2 EA               LD     (exitParameterByte),A ; Return it the exit parameter       ;
1858: ED30             InitDisk2:                      ;
1859: ED30         ; now scan the disk map for allocated blocks                                 ;
1860: ED30 0E FF                  LD     C,TRUE               ; set to allocated                   ;
1861: ED32 CD 36 EF               CALL   ScanDiskMap          ;
1862: ED35 CD 20 EF               CALL   SetDirectoryEntry    ; Mark directory entry               ;
1863: ED38 18 D5                  JR     InitDisk1            ; Loop for another entry             ;
1864: ED3A         ;--------------------------- Initialize Disk --------------------------------;
1865: ED3A         ;----------------------------- Open File -----------------------------------;
1866: ED3A         ;search for the directory entry matching FCB at paramDE						;
1867: ED3A             OpenFile:                       ;
1868: ED3A 0E 0F                  LD     C,nameLength         ;
1869: ED3C CD 85 EE               CALL   SearchForDirectoryRecord ;
1870: ED3F CD 09 EF               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
1871: ED42 C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
1872: ED43         ;
1873: ED43             CopyDirRecordToFCB:                      ;
1874: ED43 CD 30 EE               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
1875: ED46 7E                     LD     A,(HL)               ; Get the EXT                      	;
1876: ED47 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
1877: ED48 E5                     PUSH   HL                   ;  also save FCB's pointer         	;
1878: ED49 CD 12 EF               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
1879: ED4C E5                     PUSH   HL                   ; Save Directory Record address    	;
1880: ED4D         ;
1881: ED4D ED 5B C0 EA               LD     DE,(paramDE)         ;
1882: ED51 01 20 00               LD     BC,fcbLength         ;
1883: ED54 ED B0                  LDIR                        ; Move dir record to FCB           	;
1884: ED56         ;
1885: ED56         ; note that entire fcb is copied, including indicators                    	;
1886: ED56 CD 6D EE               CALL   SetFileWriteFlag     ; Make file Read Only              	;
1887: ED59 D1                     POP    DE                   ; Get Directory Record address     	;
1888: ED5A 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
1889: ED5D 19                     ADD    HL,DE                ; Directory's EXT address          	;
1890: ED5E 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
1891: ED5F 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
1892: ED62 19                     ADD    HL,DE                ; Directory's RC address           	;
1893: ED63 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
1894: ED64 E1                     POP    HL                   ; Get FCB's Extent Address         	;
1895: ED65 F1                     POP    AF                   ; Get FCB's Extent Value           	;
1896: ED66 77                     LD     (HL),A               ; Restore Extent Value             	;
1897: ED67         ; if user ext < dir ext then user := 128 records                           	;
1898: ED67         ; if user ext = dir ext then user := dir records                           	;
1899: ED67         ; if user ext > dir ext then user := 0 records                             	;
1900: ED67 79                     LD     A,C                  ; Get the Dir's EXT                	;
1901: ED68 BE                     CP     M                    ; Does it match the FCB'd          	;
1902: ED69 78                     LD     A,B                  ; Get the Dir's  record count      	;
1903: ED6A CA 74 ED               JP     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
1904: ED6D 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
1905: ED6F DA 74 ED               JP     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
1906: ED72 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
1907: ED74             OpenSetRecordCount:                      ;
1908: ED74 2A C0 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
1909: ED77 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
1910: ED7A 19                     ADD    HL,DE                ; FCB's record count               	;
1911: ED7B 77                     LD     (HL),A               ; Set the value                    	;
1912: ED7C C9                     RET                         ;
1913: ED7D         ;----------------------------- Open File -----------------------------------;
1914: ED7D
1915: ED7D         ;  +++++ ;
1916: ED7D
1917: ED7D         ;---------------
1918: ED7D         ; set a "1" value in currentDisk position of BC
1919: ED7D         ; return in HL
1920: ED7D             SetCurrentDiskBit:
1921: ED7D C5                     PUSH   BC                   ; save input parameter
1922: ED7E 3A 60 F5               LD     A,(currentDisk)
1923: ED81 4F                     LD     C,A                  ; ready parameter for shift
1924: ED82 21 01 00               LD     HL,1                 ; number to shift
1925: ED85 CD 90 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1926: ED88 C1                     POP    BC                   ; original mask
1927: ED89 79                     LD     A,C
1928: ED8A B5                     OR     L
1929: ED8B 6F                     LD     L,A
1930: ED8C 78                     LD     A,B
1931: ED8D B4                     OR     H
1932: ED8E 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1933: ED8F C9                     RET
1934: ED90         ;--------------
1935: ED90
1936: ED90         ;--------------------------- Scan      Map ----------------------------------;
1937: ED90         ;-----------------------------------
1938: ED90         ; byte value from ALLOC is in register A, with shift count
1939: ED90         ; in register C (to place bit back into position), and
1940: ED90         ; target ALLOC position in registers HL, rotate and replace
1941: ED90             RotateAndReplace:
1942: ED90 0F                     RRCA
1943: ED91 15                     DEC    D
1944: ED92 C2 90 ED               JP     NZ,RotateAndReplace  ; back into position
1945: ED95 77                     LD     (HL),A               ; back to ALLOC
1946: ED96 C9                     RET
1947: ED97         ;-----------------------------------
1948: ED97
1949: ED97         ;*****************************************************************
1950: ED97
1951: ED97         ;*****************************************************************
1952: ED97         ;=========================== Disk Utilities ================================;
1953: ED97         ;--------------------------- Home The Current Disk ------------------------;
1954: ED97         ;move to home position, then offset to start of dir                        ;
1955: ED97             Home:                           ;
1956: ED97 CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks      ;
1957: ED9A         ; if Buffer needs to be written    ;
1958: ED9A 21 83 F5               LD     HL,dpbOFF            ; Number of tracks before directory;
1959: ED9D 4E                     LD     C,(HL)               ;
1960: ED9E 23                     INC    HL                   ;
1961: ED9F 46                     LD     B,(HL)               ;
1962: EDA0 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position  ;
1963: EDA3         ;
1964: EDA3         ; Set Current Track and Sector to 00                                       ;
1965: EDA3 AF                     XOR    A                    ; set ACC to 00                    ;
1966: EDA4 2A 6A F5               LD     HL,(caTrack)         ;
1967: EDA7 77                     LD     (HL),A               ;
1968: EDA8 23                     INC    HL                   ;
1969: EDA9 77                     LD     (HL),A               ;
1970: EDAA 2A 6C F5               LD     HL,(caSector)        ;
1971: EDAD 77                     LD     (HL),A               ;
1972: EDAE 23                     INC    HL                   ;
1973: EDAF 77                     LD     (HL),A               ;
1974: EDB0 C9                     RET                         ;
1975: EDB1         ;
1976: EDB1         ;--------------------------- Home The Current Disk ------------------------;
1977: EDB1         ;--------------------------- Set DMAs -------------------------------------;
1978: EDB1             SetDataDMA:                      ;
1979: EDB1 21 66 F5               LD     HL,initDAMAddress    ;
1980: EDB4 18 03                  JR     SetDMA               ; Skip to complete the call        ;
1981: EDB6         ;	LD		BC,initDAMAddress                                              ;
1982: EDB6         ;	JP		bcSetdma					; Call BIOS to set                 ;
1983: EDB6         ;
1984: EDB6             SetDirDMA:                      ;
1985: EDB6 21 6E F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
1986: EDB9         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
1987: EDB9         ;	JP		bcSetdma					; Call BIOS to set                 ;
1988: EDB9         ;
1989: EDB9             SetDMA:                         ;
1990: EDB9 4E                     LD     C,(HL)               ;
1991: EDBA 23                     INC    HL                   ;
1992: EDBB 46                     LD     B,(HL)               ; parameter ready              ;
1993: EDBC C3 24 F6               JP     bcSetdma             ; call bios to set             ;
1994: EDBF         ;--------------------------- Set DMAs -------------------------------------;
1995: EDBF         ;--------------------------- Read Buffer ----------------------------------;
1996: EDBF         ;reads into current DMA, using current Disk,Track and Sector               ;
1997: EDBF             ReadBuffer:                      ;
1998: EDBF CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
1999: EDC2 B7                     OR     A                    ; Check status                     ;
2000: EDC3 C2 F4 F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2001: EDC6 C9                     RET                         ;
2002: EDC7         ;--------------------------- Read Buffer ----------------------------------;
2003: EDC7         ;--------------------------- Set Current Disk Read Only --------------------;
2004: EDC7         ;set current disk to read only                                              ;
2005: EDC7             SetDiskReadOnly:                      ;
2006: EDC7 2A 62 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2007: EDCA         ;
2008: EDCA 3A 60 F5               LD     A,(currentDisk)      ; Get the current disk              ;
2009: EDCD 47                     LD     B,A                  ; Move into B                       ;
2010: EDCE CD B1 F4               CALL   SetVectorBit         ; Set the bit                   ;
2011: EDD1 22 62 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2012: EDD4         ;
2013: EDD4 2A 7D F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2014: EDD7 EB                     EX     DE,HL                ;
2015: EDD8 2A 68 F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2016: EDDB 73                     LD     (HL),E               ;
2017: EDDC 23                     INC    HL                   ;
2018: EDDD 72                     LD     (HL),D               ;
2019: EDDE C9                     RET                         ;
2020: EDDF         ;--------------------------- Set disk Read Only ----------------------------;
2021: EDDF         ;------------------------- Reselect Disk if Necessary ----------------------;
2022: EDDF         ;check current fcb to see if reselection necessary                         ;
2023: EDDF             ReselectDisk:                      ;
2024: EDDF 3E FF                  LD     A,TRUE               ;
2025: EDE1 32 90 F5               LD     (fResel),A           ; Mark as possible reselect         ;
2026: EDE4 2A C0 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2027: EDE7 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2028: EDE8 E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2029: EDEA 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2030: EDEB 32 BF EA               LD     (paramE),A           ; Save drive code                   ;
2031: EDEE FE 1E                  CP     30                   ;
2032: EDF0 D2 03 EE               JP     NC,NoSelect          ; Skip drive >= 30                  ;
2033: EDF3         ;
2034: EDF3 3A 60 F5               LD     A,(currentDisk)      ; Determine the current drive       ;
2035: EDF6 32 91 F5               LD     (entryDisk),A        ; Save it                           ;
2036: EDF9 7E                     LD     A,(HL)               ;
2037: EDFA 32 92 F5               LD     (fcbDisk),A          ; Get calling disk                  ;
2038: EDFD E6 E0                  AND    11100000B            ;
2039: EDFF 77                     LD     (HL),A               ; Preserve User Number              ;
2040: EE00 CD 57 EC               CALL   SelectCurrent        ; Select the new disk               ;
2041: EE03         ;
2042: EE03             NoSelect:                       ;
2043: EE03 3A 5F F5               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2044: EE06 2A C0 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2045: EE09 B6                     OR     M                    ; Combine                           ;
2046: EE0A 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2047: EE0B C9                     RET                         ;
2048: EE0C         ;------------------------- Reselect Disk if Necessary ----------------------;
2049: EE0C
2050: EE0C
2051: EE0C         ;=========================== Disk Utilities ================================;
2052: EE0C
2053: EE0C         ;=========================== File Utilities ================================;
2054: EE0C         ;--------------------------- Set Record Variables -------------------------;
2055: EE0C         ;set variables from currently FCB - Current Record, RC, EXM                ;
2056: EE0C             SetRecordVars:                      ;
2057: EE0C CD 23 EE               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2058: EE0F         ;  and HL => .CurrentRecord        ;
2059: EE0F 7E                     LD     A,(HL)               ;
2060: EE10 32 95 F5               LD     (currentFileRecord),A ; Save current record              ;
2061: EE13 EB                     EX     DE,HL                ;
2062: EE14 7E                     LD     A,(HL)               ;
2063: EE15 32 93 F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2064: EE18 CD 30 EE               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2065: EE1B 3A 7A F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2066: EE1E A6                     AND    M                    ; Remove unwanted bits             ;
2067: EE1F 32 94 F5               LD     (extentValue),A      ; Store the value                  ;
2068: EE22 C9                     RET                         ;
2069: EE23         ;--------------------------- Set Record Variables -------------------------;
2070: EE23         ;----------------------Get File Record Count and Current Record------------;
2071: EE23         ; returns with DE pointing at RC from FCB                                  ;
2072: EE23         ;         with HL pointing at Current Record                               ;
2073: EE23             GetFcbRecordDetails:                      ;
2074: EE23 2A C0 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2075: EE26 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2076: EE29 19                     ADD    HL,DE                ;
2077: EE2A EB                     EX     DE,HL                ; DE Points to Record Count        ;
2078: EE2B 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;
2079: EE2E 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2080: EE2F C9                     RET                         ;
2081: EE30         ;----------------------Get File Record Count and Current Record------------;
2082: EE30         ;----------------------Get FileExtent--------------------------------------;
2083: EE30         ;get current extent field address to (HL)                                 ;
2084: EE30             GetExtentAddress:                      ;
2085: EE30 2A C0 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2086: EE33 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2087: EE36 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2088: EE37 C9                     RET                         ;
2089: EE38         ;----------------------Get FileExtent--------------------------------------;
2090: EE38         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2091: EE38         ; At Entry:	BC Contains to the Block to be modified                        ;
2092: EE38         ;			E  = TRUE if bit is to be set                                  ;
2093: EE38         ;			E  <> TRUE if bit is to be reset                               ;
2094: EE38         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2095: EE38             SetResetMapBit:                      ;
2096: EE38         ;
2097: EE38 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2098: EE3B 09                     ADD    HL,BC                ;  to HL                           ;
2099: EE3C 4B                     LD     C,E                  ; Move the flag to E               ;
2100: EE3D         ;
2101: EE3D 7D                     LD     A,L                  ; LSB of the Block Number          ;
2102: EE3E E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2103: EE40 F5                     PUSH   AF                   ; Save the OctetBit                ;
2104: EE41 06 03                  LD     B,3                  ;
2105: EE43 CD E7 EF               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2106: EE46 ED 5B 74 F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2107: EE4A 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2108: EE4B F1                     POP    AF                   ;
2109: EE4C 47                     LD     B,A                  ; Get the bit                      ;
2110: EE4D         ;
2111: EE4D 04                     INC    B                    ; Adjust for looping               ;
2112: EE4E C5                     PUSH   BC                   ; Will need this later             ;
2113: EE4F             Left:                           ;
2114: EE4F CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2115: EE51 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2116: EE53 C1                     POP    BC                   ; Restore loop limit and           ;
2117: EE54 37                     SCF                         ;  set/reset flag                  ;
2118: EE55 0C                     INC    C                    ; was C = TRUE                     ;
2119: EE56 28 01                  JR     Z,Right              ; Skip if Set                      ;
2120: EE58 3F                     CCF                         ; Set for Reset                    ;
2121: EE59             Right:                          ;
2122: EE59 CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2123: EE5B 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2124: EE5D C9                     RET                         ;
2125: EE5E         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2126: EE5E         ;--------------------- Initialize Extent Number MSB -----------------------;
2127: EE5E         ;clear the Extent number field for user open/make (S2)                    ;
2128: EE5E             InitializeExtentNumberMSB:                      ;
2129: EE5E CD 64 EE               CALL   GetExtentNumberMSB   ;
2130: EE61 36 00                  LD     (HL),0               ; Set it to = 0            ;
2131: EE63 C9                     RET                         ;
2132: EE64         ;--------------------- Initialize Extent Number MSB -----------------------;
2133: EE64         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2134: EE64         ; Get S2 value                                                             ;
2135: EE64         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
2136: EE64         ;			HL = Address of S2 for the FCB pointed to by paramDE           ;
2137: EE64             GetWriteProtectValue:                      ; S2 bit 7                 ;
2138: EE64             GetExtentNumberMSB:                      ; S2 bits 0-6              ;
2139: EE64 2A C0 EA               LD     HL,(paramDE)         ; FCB address              ;
2140: EE67 11 0E 00               LD     DE,fcbS2Index        ; Index to value           ;
2141: EE6A 19                     ADD    HL,DE                ; Address of value         ;
2142: EE6B 7E                     LD     A,(HL)               ; load into ACC            ;
2143: EE6C C9                     RET                         ;
2144: EE6D         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2145: EE6D         ;--------------------------- Set File Write Flag----------------------------;
2146: EE6D         ;Set file write flag in FCB in (paramDE)									;
2147: EE6D             SetFileWriteFlag:                      ;
2148: EE6D CD 64 EE               CALL   GetWriteProtectValue ; A= Value, HL = Address of fcbS2   ;
2149: EE70 F6 80                  OR     writeFlagMask        ; Set the flag , bit 7 of S2        ;
2150: EE72 77                     LD     (HL),A               ; Put into FCB                      ;
2151: EE73 C9                     RET                         ;
2152: EE74         ;--------------------------- Set File Write Flag----------------------------;
2153: EE74         ;-------------------------- Compare FCB Extents ----------------------------;
2154: EE74         ; Enters:	A containing Target FCB EXT value								;
2155: EE74         ;			HL Points at Possible FCB EXT value								;
2156: EE74         ;compare extent# in A with that in C, return nonzero if they do not match	;
2157: EE74             CompareExtents:                      ;
2158: EE74 C5                     PUSH   BC                   ; Save Callers Registers			;
2159: EE75 F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2160: EE76 3A 7A F5               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2161: EE79 2F                     CPL                         ; Complement for And           		;
2162: EE7A 47                     LD     B,A                  ; Put negated Mask into B      		;
2163: EE7B 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2164: EE7C A0                     AND    B                    ; Apply the Mask               		;
2165: EE7D 4F                     LD     C,A                  ; Low bits removed from C      		;
2166: EE7E F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2167: EE7F A0                     AND    B                    ; Apply the Mask               		;
2168: EE80 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2169: EE81 E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2170: EE83 C1                     POP    BC                   ; Restore Callers Registers    		;
2171: EE84 C9                     RET                         ;
2172: EE85         ;-------------------------- Compare FCB Extents ----------------------------;
2173: EE85         ;---------------------Search for Directory Record --------------------------;
2174: EE85         ;        directoryFlag  ????????											;
2175: EE85         ;  Search for directory record of length C.									;
2176: EE85         ; Target is pointed to by paramDE. The whole directory is searched.			;
2177: EE85         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2178: EE85         ; matched directory record													;
2179: EE85         ; Entry:	C = Search Length                                               ;
2180: EE85         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2181: EE85         ;								-1 (EOD) if there is no match				;
2182: EE85             SearchForDirectoryRecord:                      ;
2183: EE85 3E FF                  LD     A,0FFH               ;
2184: EE87 32 89 F5               LD     (directoryFlag),A    ; Initialize directory Flag         ;
2185: EE8A 21 8C F5               LD     HL,searchLength      ;
2186: EE8D 71                     LD     (HL),C               ; Save Search Length                ;
2187: EE8E 2A C0 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2188: EE91 22 8D F5               LD     (searchAddress),HL   ; Start of search                   ;
2189: EE94 CD 02 EF               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2190: EE97 CD 97 ED               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2191: EE9A         ;
2192: EE9A             GetNextDirectoryRecord:                      ;
2193: EE9A 0E 00                  LD     C,FALSE              ;
2194: EE9C CD 02 F0               CALL   ReadDirectory        ; Read next Dir Record              ;
2195: EE9F CD 09 EF               CALL   AtEndOfDirectory     ;
2196: EEA2 CA F9 EE               JP     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2197: EEA5         ;
2198: EEA5 2A 8D F5               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2199: EEA8 EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2200: EEA9 1A                     LD     A,(DE)               ; User Number                       ;
2201: EEAA FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2202: EEAC CA B7 EE               JP     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2203: EEAF         ;
2204: EEAF         ; Check to be sure we are sill in the Directory                             ;
2205: EEAF D5                     PUSH   DE                   ; Save search address               ;
2206: EEB0 CD 29 EF               CALL   StillInDirectory     ; Still in the directorY            ;
2207: EEB3 D1                     POP    DE                   ; Recall address                    ;
2208: EEB4 D2 F9 EE               JP     NC,NoDirRecordsMatch ; Get out if past directory			;
2209: EEB7         ;
2210: EEB7             GetNextDirectoryRecord1:                      ;
2211: EEB7 CD 12 EF               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2212: EEBA 3A 8C F5               LD     A,(searchLength)     ;
2213: EEBD 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2214: EEBE 06 00                  LD     B,0                  ; Character Index (up)              ;
2215: EEC0         ;
2216: EEC0             TestNextPosition:                      ;
2217: EEC0 1A                     LD     A,(DE)               ;
2218: EEC1 FE 3F                  CP     QMARK                ; ? is always a char match          ;
2219: EEC3 CA E1 EE               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2220: EEC6         ;
2221: EEC6 78                     LD     A,B                  ;
2222: EEC7 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2223: EEC9 CA E1 EE               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2224: EECC         ; not the fcbS1Index field, extent field?                                  ;
2225: EECC FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2226: EECE 1A                     LD     A,(DE)               ; Get next character                ;
2227: EECF CA DB EE               JP     Z,CheckExtents       ; Skip to search extent             ;
2228: EED2 96                     SUB    M                    ; Do they match ?                   ;
2229: EED3 E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2230: EED5 C2 9A EE               JP     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2231: EED8 C3 E1 EE               JP     SetNextPosition      ; Matched the character             ;
2232: EEDB         ;                                                                           ;
2233: EEDB             CheckExtents:                      ;
2234: EEDB CD 74 EE               CALL   CompareExtents       ; Matching EXTs is work             ;
2235: EEDE C2 9A EE               JP     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2236: EEE1         ;
2237: EEE1             SetNextPosition:                      ;
2238: EEE1 13                     INC    DE                   ; Pointer to Looking FOR            ;
2239: EEE2 23                     INC    HL                   ; Pointer to Looking IN             ;
2240: EEE3 04                     INC    B                    ; Character Index in FCB            ;
2241: EEE4 0D                     DEC    C                    ; Length of search                  ;
2242: EEE5 C2 C0 EE               JP     NZ,TestNextPosition  ;
2243: EEE8         ; Match Found, entire name matches                                          ;
2244: EEE8 3A 9A F5               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2245: EEEB E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2246: EEED 32 C2 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2247: EEF0         ;
2248: EEF0 21 89 F5               LD     HL,directoryFlag     ; Point at Directory Flag           ;
2249: EEF3 7E                     LD     A,(HL)               ; Get value                         ;
2250: EEF4 17                     RLA                         ; Set Carry if Flag = -1            ;
2251: EEF5 D0                     RET    NC                   ; Return with flag still -1         ;
2252: EEF6         ;
2253: EEF6 AF                     XOR    A                    ; Else Clear the flag               ;
2254: EEF7 77                     LD     (HL),A               ;
2255: EEF8 C9                     RET                         ;  and exit                         ;
2256: EEF9         ;------                                                                     ;
2257: EEF9             NoDirRecordsMatch:                      ;
2258: EEF9 CD 02 EF               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2259: EEFC 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2260: EEFE 32 C2 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2261: EF01 C9                     RET                         ;
2262: EF02         ;---------------------Search for Directory Record --------------------------;
2263: EF02
2264: EF02         ;=========================== File Utilities ================================;
2265: EF02
2266: EF02         ;=========================== Directory Utilities ===========================;
2267: EF02         ;--------------------------- Set End of Directory indicator ----------------;
2268: EF02             SetEndDirectory:                      ;
2269: EF02 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
2270: EF05 22 9A F5               LD     (dirEntryIndex),HL   ;
2271: EF08 C9                     RET                         ;
2272: EF09         ;--------------------------- Set End of Directory indicator ----------------;
2273: EF09         ;--------------------------- Are we at End Of Directory --------------------;
2274: EF09         ; Tests to see if we are at the End Of the Directory                        ;
2275: EF09         ;                                                                           ;
2276: EF09         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
2277: EF09         ;			 Z Flag reset if still in directory                             ;
2278: EF09         ;
2279: EF09             AtEndOfDirectory:                      ;
2280: EF09 21 9A F5               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
2281: EF0C 7E                     LD     A,(HL)               ; Get it                            ;
2282: EF0D 23                     INC    HL                   ; Point at MSB	of Dir Index		;
2283: EF0E BE                     CP     M                    ; LSB = MSB ?                       ;
2284: EF0F C0                     RET    NZ                   ;  exit if not if different         ;
2285: EF10         ; Same.  are they = 0ffh?           ;
2286: EF10 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
2287: EF11 C9                     RET                         ;
2288: EF12         ;--------------------------- Are we at End Of Directory --------------------;
2289: EF12         ;--------------------------- Get Directory Element -------------------------;
2290: EF12         ; compute the address of a directory element in Directory Buffer            ;
2291: EF12         ; Returns:  HL = Address of the specific directory Record                   ;
2292: EF12             GetCurrentDirectoryRecord:                      ;
2293: EF12 C5                     PUSH   BC                   ; Save BC                           ;
2294: EF13 2A 6E F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
2295: EF16 3A 99 F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
2296: EF19 4F                     LD     C,A                  ;
2297: EF1A AF                     XOR    A                    ; Set to Zero and reset CY          ;
2298: EF1B 47                     LD     B,A                  ;
2299: EF1C ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
2300: EF1E C1                     POP    BC                   ; Restore	                        ;
2301: EF1F C9                     RET                         ;
2302: EF20         ;--------------------------- Get Directory Element -------------------------;
2303: EF20         ;--------------------------- Set Directory Entry ---------------------------;
2304: EF20         ; Will update directory if not in the directory                             ;
2305: EF20         ;
2306: EF20             SetDirectoryEntry:                      ;
2307: EF20 CD 29 EF               CALL   StillInDirectory     ;
2308: EF23 D8                     RET    C                    ; Exit if still in the Directory  	;
2309: EF24         ;
2310: EF24         ; StillInDirectory will return with:                                        ;
2311: EF24         ;									DE = Directory entry number             ;
2312: EF24         ;									HL = Address of entry number + 1        ;
2313: EF24 13                     INC    DE                   ;
2314: EF25 72                     LD     (HL),D               ;
2315: EF26 2B                     DEC    HL                   ;
2316: EF27 73                     LD     (HL),E               ;
2317: EF28 C9                     RET                         ;
2318: EF29         ;--------------------------- Set Directory Entry ---------------------------;
2319: EF29
2320: EF29         ;--------------------------- Are we sill in the Directory ------------------;
2321: EF29         ;Returns	:                                                               ;
2322: EF29         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
2323: EF29         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
2324: EF29         ;			HL = (address of Index Value) + 1                               ;
2325: EF29         ;			DE = Directory Index Value                                      ;
2326: EF29             StillInDirectory:                      ;
2327: EF29 2A 9A F5               LD     HL,(dirEntryIndex)   ;
2328: EF2C EB                     EX     DE,HL                ; DE = directory counter            ;
2329: EF2D 2A 68 F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
2330: EF30 7B                     LD     A,E                  ;
2331: EF31 96                     SUB    M                    ;
2332: EF32 23                     INC    HL                   ;
2333: EF33 7A                     LD     A,D                  ;
2334: EF34 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
2335: EF35 C9                     RET                         ;  <= Directory Max Value       ;
2336: EF36         ;--------------------------- Are we sill in the Directory ------------------;
2337: EF36         ;--------------------------- Scan Disk Map ---------------------------------;
2338: EF36         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
2339: EF36         ;                                                                           ;
2340: EF36         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
2341: EF36         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
2342: EF36         ;
2343: EF36             ScanDiskMap:                      ;
2344: EF36 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
2345: EF37 CD 12 EF               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
2346: EF3A 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
2347: EF3D 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
2348: EF3E 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
2349: EF40         ;                                                                            ;
2350: EF40             ScanDiskMap0:                      ;
2351: EF40 D1                     POP    DE                   ; Recall the set/reset Info         ;
2352: EF41 0D                     DEC    C                    ;
2353: EF42 C8                     RET    Z                    ; Loop once for each disk map entry ;
2354: EF43         ;
2355: EF43 D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
2356: EF44 3A 8F F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
2357: EF47 B7                     OR     A                    ;
2358: EF48 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
2359: EF4A         ;  Byte Allocation scan operation                                           ;
2360: EF4A C5                     PUSH   BC                   ; Save counter                      ;
2361: EF4B E5                     PUSH   HL                   ; Save map address                  ;
2362: EF4C 4E                     LD     C,(HL)               ;
2363: EF4D 06 00                  LD     B,0                  ; BC=block# for Byte                ;
2364: EF4F 18 06                  JR     ScanDiskMap2         ;
2365: EF51         ; Word scan operation                                                       ;
2366: EF51             ScanDiskMapWord:                      ;
2367: EF51 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
2368: EF52 C5                     PUSH   BC                   ; Save counter                      ;
2369: EF53 46                     LD     B,(HL)               ;
2370: EF54 23                     INC    HL                   ;
2371: EF55 4E                     LD     C,(HL)               ; BC=block# for Word                ;
2372: EF56 E5                     PUSH   HL                   ; Save map address                  ;
2373: EF57         ;
2374: EF57         ; Arrive here with BC=block#, E=0/1	                                        ;
2375: EF57             ScanDiskMap2:                      ;
2376: EF57 79                     LD     A,C                  ;
2377: EF58 B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
2378: EF59 C4 38 EE               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
2379: EF5C E1                     POP    HL                   ;
2380: EF5D 23                     INC    HL                   ; to next bit position              ;
2381: EF5E C1                     POP    BC                   ; recall counter                    ;
2382: EF5F C3 40 EF               JP     ScanDiskMap0         ; for another item                  ;
2383: EF62         ;
2384: EF62         ;--------------------------- Scan Disk Map ---------------------------------;
2385: EF62         ;--------------------------- Get Closest Disk Block ------------------------;
2386: EF62         ; Find the closest available disk block, and mark in Map as allocated       ;
2387: EF62         ; Enter	BC	= Block number to base the search on                            ;
2388: EF62         ; Exit	HL	= 0000 if There are no available open blocks                    ;
2389: EF62         ;			= block number of available and marked block                    ;
2390: EF62         ;
2391: EF62             GetClosestBlock:                      ;
2392: EF62 C5                     PUSH   BC                   ; save the starting Block #         ;
2393: EF63         ;
2394: EF63 2A 7B F5               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
2395: EF66 CD E5 EF               CALL   DivideHLby8          ; Length of Map	                    ;
2396: EF69 EB                     EX     DE,HL                ; put size into DE			        ;
2397: EF6A E1                     POP    HL                   ; Block number into HL              ;
2398: EF6B CD E5 EF               CALL   DivideHLby8          ; Length of Map                     ;
2399: EF6E EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
2400: EF6F AF                     XOR    A                    ; Reset CY                          ;
2401: EF70 ED 52                  SBC    HL,DE                ; Size for right                    ;
2402: EF72         ; DE = Start Index                                                          ;
2403: EF72         ; DE = Left Size                                                            ;
2404: EF72         ; HL	= Right Size                                                        ;
2405: EF72 E5                     PUSH   HL                   ; Save right size                   ;
2406: EF73 D5                     PUSH   DE                   ; Save left size & Start Index      ;
2407: EF74 3E FF                  LD     A,0FFH               ; Full Octet                        ;
2408: EF76         ;
2409: EF76 2A 74 F5               LD     HL,(caAllocVector)   ; Start of Map                      ;
2410: EF79 19                     ADD    HL,DE                ; Determine initial Octet			;
2411: EF7A         ; Set up Left side                                                          ;
2412: EF7A C1                     POP    BC                   ; Left size                         ;
2413: EF7B 03                     INC    BC                   ; adjust                            ;
2414: EF7C E5                     PUSH   HL                   ; Save initial Octet                ;
2415: EF7D 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
2416: EF80         ; HL = Initial Octet                                                        ;
2417: EF80         ; BC = Left Size                                                            ;
2418: EF80 D9                     EXX                         ; Use alternate registers           ;
2419: EF81 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
2420: EF84 E1                     POP    HL                   ; Get Initial Octet                 ;
2421: EF85 C1                     POP    BC                   ; Get Right Size                    ;
2422: EF86 03                     INC    BC                   ; adjust                            ;
2423: EF87             LookRight:                      ;
2424: EF87 ED A1                  CPI                         ; UnSet Bit?                        ;
2425: EF89 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2426: EF8B E2 A4 EF               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
2427: EF8E         ;
2428: EF8E D9                     EXX                         ; Switch to the Left                ;
2429: EF8F ED A9                  CPD                         ; UnSet Bit?                        ;
2430: EF91 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2431: EF93 E2 99 EF               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
2432: EF96 D9                     EXX                         ; switch to right                   ;
2433: EF97 18 EE                  JR     LookRight            ; Keep on looking                   ;
2434: EF99         ;			----------------			                                    ;
2435: EF99             NoMoreLeft:                      ;
2436: EF99 D9                     EXX                         ; Switch to Right                   ;
2437: EF9A             NoMoreLeftLoop:                      ;
2438: EF9A ED A1                  CPI                         ;
2439: EF9C 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2440: EF9E E2 AF EF               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
2441: EFA1 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
2442: EFA3 76                     HALT                        ;
2443: EFA4             NoMoreRight:                      ;
2444: EFA4 D9                     EXX                         ; Switch to Left                    ;
2445: EFA5             NoMoreRightLoop:                      ;
2446: EFA5 ED A9                  CPD                         ;
2447: EFA7 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2448: EFA9 E2 AF EF               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
2449: EFAC 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
2450: EFAE 76                     HALT                        ;
2451: EFAF             NoFreeBlocks:                      ;
2452: EFAF 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
2453: EFB2 C9                     RET                         ;
2454: EFB3         ;			----------------			                                    ;
2455: EFB3             FoundFreeOctet:                      ;
2456: EFB3 BB                     CP     E                    ; Left or Right                     ;
2457: EFB4 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
2458: EFB6 2B                     DEC    HL                   ; Adjust for direction              ;
2459: EFB7 18 01                  JR     FoundFreeOctet2      ;
2460: EFB9         ;
2461: EFB9             FoundFreeOctet1:                      ;
2462: EFB9 23                     INC    HL                   ; Adjust for direction              ;
2463: EFBA             FoundFreeOctet2:                      ;
2464: EFBA 01 00 00               LD     BC,00                ; need to keep track of bit         ;
2465: EFBD             FoundFreeOctet3:                      ;
2466: EFBD CB 06                  RLC    (HL)                 ;
2467: EFBF 03                     INC    BC                   ;
2468: EFC0 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
2469: EFC2 CB C6                  SET    0,(HL)               ; Make map bit set                  ;
2470: EFC4 41                     LD     B,C                  ; Put count in B                    ;
2471: EFC5             FoundFreeOctet4:                      ;
2472: EFC5 CB 0E                  RRC    (HL)                 ;
2473: EFC7 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
2474: EFC9 0B                     DEC    BC                   ; adjust for Zero based value       ;
2475: EFCA C5                     PUSH   BC                   ; Save the bit index                ;
2476: EFCB ED 4B 74 F5               LD     BC,(caAllocVector)   ; Get Map start                     ;
2477: EFCF AF                     XOR    A                    ; Clear CY                          ;
2478: EFD0 ED 42                  SBC    HL,BC                ; Get how far in the map            ;
2479: EFD2 CD EF EF               CALL   MultiplyHLby8        ; Calculate the Octet           ;
2480: EFD5 C1                     POP    BC                   ; Restore index into Octet          ;
2481: EFD6 09                     ADD    HL,BC                ; This is the Block Number          ;
2482: EFD7 C9                     RET                         ;
2483: EFD8         ;--------------------------- Get Closest Disk Block ------------------------;
2484: EFD8
2485: EFD8         ;=========================== Directory Utilities ===========================;
2486: EFD8
2487: EFD8         ;=========================== General   Utilities ===========================;
2488: EFD8         ;--------------------------- Rotate HL right by value in C ----------------;
2489: EFD8         ;
2490: EFD8         ; HL = Value to be rotated Right                                           ;
2491: EFD8         ;  B = Amount to shift                                                     ;
2492: EFD8             RotateRightHLbyB:                      ;
2493: EFD8 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
2494: EFD9 CB 45                  BIT    0,L                  ; is LSB set?                      ;
2495: EFDB 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
2496: EFDD 3F                     CCF                         ; else Clear Carry flag            ;
2497: EFDE             RotateRightHLbyB1:                      ;
2498: EFDE CB 1C                  RR     H                    ; Shift thru CY                    ;
2499: EFE0 CB 1D                  RR     L                    ; ditto                            ;
2500: EFE2 10 F4                  DJNZ   RotateRightHLbyB     ;
2501: EFE4 C9                     RET                         ;
2502: EFE5         ;
2503: EFE5         ;--------------------------- Rotate HL right by value in C ----------------;
2504: EFE5         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2505: EFE5         ; HL = Value to be shifted Right                                           ;
2506: EFE5             DivideHLby8:                      ;
2507: EFE5 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2508: EFE7         ;  B = Amount to shift                                                     ;
2509: EFE7             ShiftRightHLbyB:                      ;
2510: EFE7 AF                     XOR    A                    ; else Clear Carry flag            ;
2511: EFE8 CB 1C                  RR     H                    ; Shift thru CY                    ;
2512: EFEA CB 1D                  RR     L                    ; ditto                            ;
2513: EFEC 10 F9                  DJNZ   ShiftRightHLbyB      ;
2514: EFEE C9                     RET                         ;
2515: EFEF         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2516: EFEF         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2517: EFEF         ; HL = Value to be shifted Left                                            ;
2518: EFEF             MultiplyHLby8:                      ;
2519: EFEF 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2520: EFF1         ;  B = Amount to shift                                                     ;
2521: EFF1             ShiftLeftHLbyB:                      ;
2522: EFF1 AF                     XOR    A                    ; else Clear Carry flag            ;
2523: EFF2 CB 15                  RL     L                    ; Shift thru CY                    ;
2524: EFF4 CB 14                  RL     H                    ; ditto                            ;
2525: EFF6 10 F9                  DJNZ   ShiftLeftHLbyB       ;
2526: EFF8 C9                     RET                         ;
2527: EFF9         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2528: EFF9
2529: EFF9         ;=========================== General   Utilities ===========================;
2530: EFF9
2531: EFF9         ;--------------------------- Read Directory Record -------------------------;
2532: EFF9         ; read a directory entry into the directory buffer                          ;
2533: EFF9             ReadDirRecord:                      ;
2534: EFF9 CD B6 ED               CALL   SetDirDMA            ; System Assigned Buffer            ;
2535: EFFC CD BF ED               CALL   ReadBuffer           ; Go to BIOS for the read           ;
2536: EFFF C3 B1 ED               JP     SetDataDMA           ; Restore DMA                       ;
2537: F002         ;--------------------------- Read Directory Record -------------------------;
2538: F002
2539: F002         ;--------------------------- Read Directory --------------------------------;
2540: F002         ; Read next directory entry                                                 ;
2541: F002         ; Enter :                                                                   ;
2542: F002         ;		C =  TRUE initializing and setting CheckSum                         ;
2543: F002         ;		  <> TRUE Checking existing CheckSum                                ;
2544: F002             ReadDirectory:                      ;
2545: F002 ED 5B 7D F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
2546: F006 2A 9A F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
2547: F009 23                     INC    HL                   ; Increment the Index               ;
2548: F00A 22 9A F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
2549: F00D AF                     XOR    A                    ; Clear the CY flag                 ;
2550: F00E ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
2551: F010 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
2552: F012 CD 02 EF               CALL   SetEndDirectory      ;  else we are done                 ;
2553: F015 C9                     RET                         ;
2554: F016         ;
2555: F016         ; Calculate the entry index Position in Buffer                              ;
2556: F016             ReadDirectory0:                      ;
2557: F016 3A 9A F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
2558: F019 E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
2559: F01B 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
2560: F01D             ReadDirectory1:                      ;
2561: F01D 87                     ADD    A,A                  ;
2562: F01E 10 FD                  DJNZ   ReadDirectory1       ;
2563: F020 32 99 F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
2564: F023 B7                     OR     A                    ; Is this the 1st entry?            ;
2565: F024 C0                     RET    NZ                   ;  return if not.                   ;
2566: F025         ;
2567: F025 C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
2568: F026 CD 30 F0               CALL   SeekDir              ; Set up for Directory Read         ;
2569: F029 CD F9 EF               CALL   ReadDirRecord        ; Read the directory record         ;
2570: F02C C1                     POP    BC                   ; Recall initialization flag        ;
2571: F02D C3 7B F0               JP     CheckSumUtility      ; Checksum the directory            ;
2572: F030         ;--------------------------- Read Directory --------------------------------;
2573: F030         ;--------------------------- Seek Directory --------------------------------;
2574: F030         ;seek the record containing the current directory entry					;
2575: F030             SeekDir:                        ;
2576: F030 2A 9A F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
2577: F033 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
2578: F035 CD E7 EF               CALL   ShiftRightHLbyB      ;
2579: F038 22 97 F5               LD     (absoluteCPMRecord),HL ;
2580: F03B 22 9C F5               LD     (dirRecord),HL       ; Save                              ;
2581: F03E C3 41 F0               JP     Seek                 ;
2582: F041         ;--------------------------- Seek Directory --------------------------------;
2583: F041         ;--------------------------- Seek ------------------------------------------;
2584: F041             Seek:                           ;
2585: F041 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
2586: F044 2A 97 F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
2587: F047 ED 5B 76 F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
2588: F04B         ;
2589: F04B             Seek0:                          ;
2590: F04B 03                     INC    BC                   ; Divide the record                 ;
2591: F04C AF                     XOR    A                    ;  by the sectors per track         ;
2592: F04D ED 52                  SBC    HL,DE                ;
2593: F04F 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
2594: F051         ;
2595: F051         ;
2596: F051 19                     ADD    HL,DE                ; Gets the sector in the track      ;
2597: F052 E5                     PUSH   HL                   ; Save Index Sector                 ;
2598: F053         ;
2599: F053 DD 2A 6A F5               LD     IX,(caTrack)         ;
2600: F057 DD 71 00               LD     (IX+0),C             ;
2601: F05A DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
2602: F05D         ;
2603: F05D EB                     EX     DE,HL                ; Take the index from the record    ;
2604: F05E 2A 97 F5               LD     HL,(absoluteCPMRecord) ;
2605: F061 AF                     XOR    A                    ;
2606: F062 ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
2607: F064         ;
2608: F064 DD 2A 6C F5               LD     IX,(caSector)        ;
2609: F068 DD 75 00               LD     (IX+0),L             ;
2610: F06B DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
2611: F06E         ;
2612: F06E 2A 83 F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
2613: F071 09                     ADD    HL,BC                ;  to add to the gross Track        ;
2614: F072 E5                     PUSH   HL                   ;  which yields the net or          ;
2615: F073 C1                     POP    BC                   ;  actual track for the record      ;
2616: F074 CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
2617: F077         ;
2618: F077 C1                     POP    BC                   ; Get the sector within the track   ;
2619: F078 C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
2620: F07B         ;
2621: F07B         ;--------------------------- Seek ------------------------------------------;
2622: F07B         ;--------------------------- Check Sum Utility -----------------------------;
2623: F07B         ; At entry                                                                  ;
2624: F07B         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
2625: F07B         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
2626: F07B         ;
2627: F07B             CheckSumUtility:                      ;
2628: F07B 2A 81 F5               LD     HL,(dpbCKS)          ;
2629: F07E ED 5B 9C F5               LD     DE,(dirRecord)       ;
2630: F082 AF                     XOR    A                    ;
2631: F083 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
2632: F085 D8                     RET    C                    ;  Entries                      ;
2633: F086         ;
2634: F086 C5                     PUSH   BC                   ; Save New/Validate Flag        ;
2635: F087         ;
2636: F087         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
2637: F087             ComputeCheckSum:                      ;
2638: F087 06 80                  LD     B,cpmRecordSize      ;
2639: F089 2A 6E F5               LD     HL,(caDirectoryDMA)  ;
2640: F08C EE 00                  XOR                         ;
2641: F08E             ComputeCheckSum1:                      ;
2642: F08E 86                     ADD    A,(HL)               ;
2643: F08F 23                     INC    HL                   ;
2644: F090 10 FC                  DJNZ   ComputeCheckSum1     ;
2645: F092         ; Checksum is in ACC	                                                    ;
2646: F092         ;
2647: F092 2A 72 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
2648: F095 ED 5B 9C F5               LD     DE,(dirRecord)       ; Index to this record              ;
2649: F099 19                     ADD    HL,DE                ; Address of this record in vector  ;
2650: F09A C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
2651: F09B 0C                     INC    C                    ;
2652: F09C CA A9 F0               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
2653: F09F         ;
2654: F09F BE                     CP     M                    ; Else we are checking the value    ;
2655: F0A0 C8                     RET    Z                    ; Exit if OK                        ;
2656: F0A1         ; possible checksum error, are we beyond the end of the disk?               ;
2657: F0A1 CD 29 EF               CALL   StillInDirectory     ;
2658: F0A4 D0                     RET    NC                   ; OK, if not in the directory       ;
2659: F0A5 CD C7 ED               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
2660: F0A8 C9                     RET                         ;  Set disk RO before returning     ;
2661: F0A9         ;
2662: F0A9         ;initializing the checksum                                                 ;
2663: F0A9             SetNewCheckSum:                      ;
2664: F0A9 77                     LD     (HL),A               ;
2665: F0AA C9                     RET                         ;
2666: F0AB         ;--------------------------- Check Sum Utility -----------------------------;
2667: F0AB
2668: F0AB
2669: F0AB         ;---------------------
2670: F0AB         ;update variables from I/O in  fcb
2671: F0AB             UpdateRecordVars:
2672: F0AB CD 23 EE               CALL   GetFcbRecordDetails  ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2673: F0AE 3A 8A F5               LD     A,(seqReadFlag)
2674: F0B1 4F                     LD     C,A                  ; =1 if sequential i/o
2675: F0B2 3A 95 F5               LD     A,(currentFileRecord) ; get NEXT_RECORD
2676: F0B5 81                     ADD    A,C
2677: F0B6 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=current File Record+seqReadFlag
2678: F0B7 EB                     EX     DE,HL
2679: F0B8 3A 93 F5               LD     A,(fcbRecordCount)
2680: F0BB 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2681: F0BC C9                     RET
2682: F0BD         ;---------------------
2683: F0BD         ;set file Attributes for current fcb
2684: F0BD             SetAttributes:
2685: F0BD 0E 0C                  LD     C,fcbExtIndex
2686: F0BF CD 85 EE               CALL   SearchForDirectoryRecord ; through file type
2687: F0C2             SetAttributes1:
2688: F0C2 CD 09 EF               CALL   AtEndOfDirectory
2689: F0C5 C8                     RET    Z                    ; exit at end of dir
2690: F0C6 0E 00                  LD     C,0
2691: F0C8 1E 0C                  LD     E,fcbExtIndex        ;copy name
2692: F0CA CD 29 F4               CALL   CopyDir
2693: F0CD CD 9A EE               CALL   GetNextDirectoryRecord
2694: F0D0 C3 C2 F0               JP     SetAttributes1
2695: F0D3         ;
2696: F0D3         ;*****************************************************************
2697: F0D3
2698: F0D3         ;*****************************************************************
2699: F0D3         ;********************** File  Routines ***************************
2700: F0D3         ;*****************************************************************
2701: F0D3         ;-----------------------------------------------------------------
2702: F0D3         ;close file
2703: F0D3             vCloseFile:                      ; func16: (16 - 10) Close File
2704: F0D3 CD DF ED               CALL   ReselectDisk
2705: F0D6 C3 34 F3               JP     CloseDirEntry
2706: F0D9         ;-----------------------------------------------------------------
2707: F0D9         ;search for first occurrence of a file
2708: F0D9         ; In - (DE)	FCB Address
2709: F0D9         ; OUT - (A)	Directory Code
2710: F0D9         ;	0-3 = success ; 0FFH = File Not Found
2711: F0D9             vFindFirst:                      ; func17: (17 - 11) Search for first
2712: F0D9 0E 00                  LD     C,0                  ; length assuming '?' true
2713: F0DB 2A C0 EA               LD     HL,(paramDE)
2714: F0DE 7E                     LD     A,(HL)
2715: F0DF FE 3F                  CP     QMARK                ; no reselect if ?
2716: F0E1 CA EC F0               JP     Z,QMarkSelect        ; skip reselect if so
2717: F0E4
2718: F0E4 CD 5E EE               CALL   InitializeExtentNumberMSB ; module number zeroed
2719: F0E7 CD DF ED               CALL   ReselectDisk
2720: F0EA 0E 0F                  LD     C,nameLength
2721: F0EC             QMarkSelect:                      ; qselect:
2722: F0EC CD 85 EE               CALL   SearchForDirectoryRecord
2723: F0EF C3 16 F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2724: F0F2         ;-----------------------------------------------------------------
2725: F0F2         ;search for next occurrence of a file name
2726: F0F2         ; OUT - (A)	Directory Code
2727: F0F2         ;	0-3 = success ; 0FFH = File Not Found
2728: F0F2             vFindNext:                      ; func18: (18 - 12) Search for next
2729: F0F2 2A 8D F5               LD     HL,(searchAddress)
2730: F0F5 22 C0 EA               LD     (paramDE),HL
2731: F0F8 CD DF ED               CALL   ReselectDisk
2732: F0FB CD 9A EE               CALL   GetNextDirectoryRecord
2733: F0FE C3 16 F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2734: F101         ;-----------------------------------------------------------------
2735: F101         ;search for next occurrence of a file name
2736: F101         ; OUT - (A)	Directory Code
2737: F101         ;delete a file
2738: F101             vDeleteFile:                      ; func18: (19 - 13) Delete File
2739: F101 CD DF ED               CALL   ReselectDisk
2740: F104 CD 12 F3               CALL   DeleteFile
2741: F107 C3 09 F4               JP     DirLocationToReturnLoc
2742: F10A         ;-----------------------------------------------------------------
2743: F10A         ;read sequential
2744: F10A         ;IN  - (DE) FCB address
2745: F10A         ;OUT - (A) 00 = success and data available. else no read and no data
2746: F10A             vReadSeq:                       ; func20: (20 - 14) read sequential
2747: F10A CD DF ED               CALL   ReselectDisk
2748: F10D CD 4C F1               CALL   ReadSeq
2749: F110 C9                     RET
2750: F111         ;-----------------------------------------------------------------
2751: F111         ;write sequential
2752: F111         ;IN  - (DE) FCB address
2753: F111         ;OUT - (A) 00 = success and data available. else no read and no data
2754: F111             vWriteSeq:                      ; func21 (21 - 15) write sequention
2755: F111 CD DF ED               CALL   ReselectDisk
2756: F114 CD 8F F1               CALL   DiskWriteSeq
2757: F117 C9                     RET
2758: F118         ;-----------------------------------------------------------------
2759: F118         ; Make file
2760: F118         ; In - (DE)	FCB Address
2761: F118         ; OUT - (A)	Directory Code
2762: F118         ;	0-3 = success ; 0FFH = File Not Found
2763: F118             vMakeFile:                      ; func22 (22 - 16) Make file
2764: F118 CD 5E EE               CALL   InitializeExtentNumberMSB ; set S2 to Zero
2765: F11B CD DF ED               CALL   ReselectDisk
2766: F11E C3 DC F2               JP     MakeNewFile
2767: F121         ;-----------------------------------------------------------------
2768: F121         ; Rename file
2769: F121         ; In - (DE)	FCB Address
2770: F121         ; OUT - (A)	Directory Code
2771: F121         ;	0-3 = success ; 0FFH = File Not Found
2772: F121             vRenameFile:                      ; func23 (23 - 17) Rename File
2773: F121 CD DF ED               CALL   ReselectDisk
2774: F124 CD B7 F2               CALL   Rename
2775: F127 C3 09 F4               JP     DirLocationToReturnLoc
2776: F12A         ;-----------------------------------------------------------------
2777: F12A         ;-----------------------------------------------------------------
2778: F12A         ;*****************************************************************
2779: F12A         ;-----------------------------------------------------------------
2780: F12A         ;check current directory element for read/only status
2781: F12A             CheckRODirectory:
2782: F12A CD 12 EF               CALL   GetCurrentDirectoryRecord ; address of element
2783: F12D         ;	JMP	CheckROFile
2784: F12D         ;------------
2785: F12D         ;check current buff(dptr) or fcb(0) for r/o status
2786: F12D             CheckROFile:
2787: F12D 11 09 00               LD     DE,fcbROfileIndex
2788: F130 19                     ADD    HL,DE                ; offset to ro bit
2789: F131 7E                     LD     A,(HL)
2790: F132 17                     RLA
2791: F133 D0                     RET    NC                   ; return if not set
2792: F134 C3 DB F4               JP     errReadOnlyFile      ; exit to read only disk message
2793: F137         ;-----------------------------------------------------------------
2794: F137         ;check for write protected disk
2795: F137             CheckWrite:
2796: F137 CD 3E F1               CALL   IsDiskWriteProtected
2797: F13A C8                     RET    Z                    ; OK to write
2798: F13B C3 D5 F4               JP     errReadOnlyDisk      ; read only disk error
2799: F13E         ;-----------------------------------------------------------------
2800: F13E         ;return 0 if OK to write (NO)
2801: F13E             IsDiskWriteProtected:
2802: F13E 2A 62 F5               LD     HL,(readOnlyVector)
2803: F141 3A 60 F5               LD     A,(currentDisk)
2804: F144 4F                     LD     C,A
2805: F145 CD 83 F4               CALL   ShiftRightHLbyC
2806: F148 7D                     LD     A,L
2807: F149 E6 1B                  AND    1BH                  ; 01BH
2808: F14B C9                     RET                         ; non zero if nowrite
2809: F14C         ;-----------------------------------------------------------------
2810: F14C         ;sequential disk read operation
2811: F14C             ReadSeq:
2812: F14C 3E 01                  LD     A,1
2813: F14E 32 8A F5               LD     (seqReadFlag),A      ; set flag for seqential read
2814: F151         ;---
2815: F151         ; read the disk
2816: F151         ; read the next record from the current fcb
2817: F151             DiskRead:
2818: F151 3E FF                  LD     A,TRUE
2819: F153 32 88 F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
2820: F156
2821: F156 CD 0C EE               CALL   SetRecordVars        ; sets current File Record, fcbRecordCount and EXM
2822: F159 3A 95 F5               LD     A,(currentFileRecord)
2823: F15C 21 93 F5               LD     HL,fcbRecordCount
2824: F15F BE                     CP     M                    ; current File Record-fcbRecordCount
2825: F160         ; skip if  current File Record < fcbRecordCount
2826: F160 DA 76 F1               JP     C,RecordOK
2827: F163         ; not enough records in the extent
2828: F163 FE 80                  CP     RecordsPerExtent     ; current File Record = 128?   *** Records in an Extent
2829: F165 C2 8C F1               JP     NZ,DiskEOF           ; skip if current File Record<>128
2830: F168 CD 54 F2               CALL   OpenNextExt          ; go to next extent if so
2831: F16B AF                     XOR    A
2832: F16C 32 95 F5               LD     (currentFileRecord),A ; current File Record=00
2833: F16F         ; now check for open ok
2834: F16F 3A C2 EA               LD     A,(exitParameterByte)
2835: F172 B7                     OR     A
2836: F173 C2 8C F1               JP     NZ,DiskEOF
2837: F176         ; stop at eof
2838: F176         ; arrive with fcb addressing a record to read
2839: F176             RecordOK:                       ; recordok:
2840: F176 CD DD F3               CALL   GetBlockNumber       ; save it in Absolute CPM Record
2841: F179 CD EA F3               CALL   IsAllocated          ; Absolute CPM Record=0000?
2842: F17C CA 8C F1               JP     Z,DiskEOF            ; get out if not allocated already
2843: F17F
2844: F17F CD F0 F3               CALL   SetActualRecordAdd   ; Absolute CPM Record now a record value
2845: F182 CD 41 F0               CALL   Seek                 ; to proper track,sector
2846: F185 CD BF ED               CALL   ReadBuffer           ; to dma address
2847: F188 CD AB F0               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
2848: F18B C9                     RET
2849: F18C             DiskEOF:                        ; diskeof:
2850: F18C C3 10 F4               JP     SetLowReturnTo1      ; exitParameterByte = 1
2851: F18F         ;ret
2852: F18F         ;-----------------------------------------------------------------
2853: F18F         ;sequential disk write
2854: F18F             DiskWriteSeq:
2855: F18F 3E 01                  LD     A,1
2856: F191 32 8A F5               LD     (seqReadFlag),A
2857: F194         ;--------
2858: F194         ;disk write
2859: F194             DiskWrite:
2860: F194 3E 00                  LD     A,FALSE
2861: F196 32 88 F5               LD     (readModeFlag),A
2862: F199         ; write record to currently selected file
2863: F199 CD 37 F1               CALL   CheckWrite           ; in case write protected
2864: F19C 2A C0 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
2865: F19F CD 2D F1               CALL   CheckROFile          ; may be a read-only file
2866: F1A2 CD 0C EE               CALL   SetRecordVars        ; set local Record parameters
2867: F1A5 3A 95 F5               LD     A,(currentFileRecord)
2868: F1A8 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
2869: F1AA DA B1 F1               JP     C,DiskWrite1         ; skip if in the same Extent
2870: F1AD CD 10 F4               CALL   SetLowReturnTo1
2871: F1B0 C9                     RET                         ; Exit ???????????
2872: F1B1
2873: F1B1         ; can write the next record, so continue
2874: F1B1             DiskWrite1:
2875: F1B1 CD DD F3               CALL   GetBlockNumber       ; sets up actual block number
2876: F1B4 CD EA F3               CALL   IsAllocated
2877: F1B7 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
2878: F1B9 C2 04 F2               JP     NZ,DiskWrite3
2879: F1BC         ; not allocated -
2880: F1BC         ; the argument to getblock is the starting position for the disk search
2881: F1BC         ; and should be the last allocated block for this file,
2882: F1BC         ; or the value 0 if no space has been allocated
2883: F1BC
2884: F1BC CD 3E F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
2885: F1BF 32 8B F5               LD     (diskMapIndex),A     ; save for later
2886: F1C2 01 00 00               LD     BC,0000h             ; may use block zero
2887: F1C5 B7                     OR     A
2888: F1C6 CA D0 F1               JP     Z,FirstBlock         ; skip if no previous block
2889: F1C9         ; previous block exists
2890: F1C9 4F                     LD     C,A
2891: F1CA 0B                     DEC    BC                   ; previous block # in BC
2892: F1CB CD 5E F4               CALL   GetDiskMapValue      ; previous block # to HL
2893: F1CE 44                     LD     B,H
2894: F1CF 4D                     LD     C,L                  ; BC=prev block#
2895: F1D0         ; BC = 0000, or previous block #
2896: F1D0             FirstBlock:
2897: F1D0         ;	CALL	GetClosestBlockXX					; block # to HL
2898: F1D0 CD 62 EF               CALL   GetClosestBlock
2899: F1D3         ; arrive here with block# or zero
2900: F1D3 7D                     LD     A,L
2901: F1D4 B4                     OR     H
2902: F1D5 C2 DE F1               JP     NZ,BlockOK
2903: F1D8         ; cannot find a block to allocate
2904: F1D8 3E 02                  LD     A,2
2905: F1DA 32 C2 EA               LD     (exitParameterByte),A
2906: F1DD C9                     RET                         ; exitParameterByte=2
2907: F1DE
2908: F1DE             BlockOK:
2909: F1DE 22 97 F5               LD     (absoluteCPMRecord),HL ; allocated block number is in HL
2910: F1E1 EB                     EX     DE,HL                ; block number to DE
2911: F1E2 2A C0 EA               LD     HL,(paramDE)
2912: F1E5 01 10 00               LD     BC,fcbDiskMapIndex
2913: F1E8 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
2914: F1E9 3A 8F F5               LD     A,(byteAllocationFlag)
2915: F1EC B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
2916: F1ED 3A 8B F5               LD     A,(diskMapIndex)     ; recall dm index
2917: F1F0 CA FA F1               JP     Z,Allocate16Bit      ; skip if allocating word
2918: F1F3         ; else allocate using a byte value
2919: F1F3 CD 77 F4               CALL   AddAtoHL
2920: F1F6 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
2921: F1F7 C3 02 F2               JP     DiskWrite2           ; to continue
2922: F1FA
2923: F1FA             Allocate16Bit:                      ; allocate a word value
2924: F1FA
2925: F1FA 4F                     LD     C,A
2926: F1FB 06 00                  LD     B,0                  ; double(diskMapIndex)
2927: F1FD 09                     ADD    HL,BC
2928: F1FE 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
2929: F1FF 72                     LD     (HL),D
2930: F200 23                     INC    HL
2931: F201 73                     LD     (HL),E               ; double wd
2932: F202         ; disk write to previously unallocated block
2933: F202             DiskWrite2:
2934: F202 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
2935: F204
2936: F204         ; continue the write operation of no allocation error
2937: F204         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
2938: F204
2939: F204             DiskWrite3:
2940: F204 3A C2 EA               LD     A,(exitParameterByte)
2941: F207 B7                     OR     A
2942: F208 C0                     RET    NZ                   ; stop if non zero returned value
2943: F209
2944: F209 C5                     PUSH   BC                   ; save write flag ( in C see above)
2945: F20A CD F0 F3               CALL   SetActualRecordAdd   ; Absolute CPM Record set to actual record number
2946: F20D CD 41 F0               CALL   Seek                 ; to proper file position
2947: F210 C1                     POP    BC                   ; get write flag
2948: F211 C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
2949: F212 CD C7 F3               CALL   WriteBuffer          ; written to disk
2950: F215 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
2951: F216         ; increment record count if fcbRecordCount<=current File Record
2952: F216 3A 95 F5               LD     A,(currentFileRecord)
2953: F219 21 93 F5               LD     HL,fcbRecordCount
2954: F21C BE                     CP     M                    ; current File Record-fcbRecordCount
2955: F21D DA 24 F2               JP     C,DiskWrite4
2956: F220         ; fcbRecordCount <= current File Record
2957: F220 77                     LD     (HL),A
2958: F221 34                     INC    M                    ; fcbRecordCount = current File Record+1
2959: F222 0E 02                  LD     C,2                  ; mark as record count incremented
2960: F224             DiskWrite4:
2961: F224         ; A has current File Record, C=2 if new block or new record#
2962: F224 0D                     DEC    C
2963: F225 0D                     DEC    C
2964: F226 C2 31 F2               JP     NZ,DiskWrite5
2965: F229 F5                     PUSH   AF                   ; save current File Record value
2966: F22A CD 64 EE               CALL   GetExtentNumberMSB   ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2967: F22D         ; reset the file write flag to mark as written fcb
2968: F22D E6 7F                  AND    7FH                  ; not writeFlagMask
2969: F22F 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2970: F230 F1                     POP    AF                   ; restore current File Record
2971: F231             DiskWrite5:
2972: F231         ; check for end of extent, if found attempt to open next extent in preparation for next write
2973: F231 FE 7F                  CP     highestRecordNumber  ; current File Record=highestRecordNumber?
2974: F233 C2 51 F2               JP     NZ,DiskWrite7        ; skip if not
2975: F236         ; may be random access write, if so we are done
2976: F236 3A 8A F5               LD     A,(seqReadFlag)
2977: F239 B7                     OR     A
2978: F23A CA 51 F2               JP     Z,DiskWrite7         ; skip next extent open op
2979: F23D         ; update current fcb before going to next extent
2980: F23D CD AB F0               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2981: F240 CD 54 F2               CALL   OpenNextExt          ; readModeFlag=false
2982: F243         ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
2983: F243 21 C2 EA               LD     HL,exitParameterByte
2984: F246 7E                     LD     A,(HL)
2985: F247 B7                     OR     A
2986: F248 C2 4F F2               JP     NZ,DiskWrite6        ; no space
2987: F24B         ; space available, set current File Record=255
2988: F24B 3D                     DEC    A
2989: F24C 32 95 F5               LD     (currentFileRecord),A ; goes to 00 next time
2990: F24F             DiskWrite6:
2991: F24F 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
2992: F251             DiskWrite7:
2993: F251 C3 AB F0               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2994: F254         ;ret
2995: F254         ;-----------------------------------------------------------------
2996: F254         ;close the current extent  and open the next one if possible.
2997: F254         ;readModeFlag is true if in read mode
2998: F254             OpenNextExt:                      ; open$reel
2999: F254 AF                     XOR    A
3000: F255 32 87 F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
3001: F258 CD 34 F3               CALL   CloseDirEntry        ; close current extent
3002: F25B         ; exitParameterByte remains at enddir if we cannot open the next ext
3003: F25B CD 09 EF               CALL   AtEndOfDirectory
3004: F25E C8                     RET    Z                    ; return if end
3005: F25F 2A C0 EA               LD     HL,(paramDE)         ; increment extent number
3006: F262 01 0C 00               LD     BC,fcbExtIndex
3007: F265 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
3008: F266 7E                     LD     A,(HL)
3009: F267 3C                     INC    A
3010: F268 E6 1F                  AND    maxExtValue
3011: F26A 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
3012: F26B CA 7D F2               JP     Z,OpenNextModule     ; move to next module if zero
3013: F26E         ; may be in the same extent group
3014: F26E 47                     LD     B,A
3015: F26F 3A 7A F5               LD     A,(dpbEXM)
3016: F272 A0                     AND    B
3017: F273         ; if result is zero, then not in the same group
3018: F273 21 87 F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
3019: F276 A6                     AND    M                    ; produces a 00 in accumulator if not written
3020: F277 CA 88 F2               JP     Z,OpenNextExt1       ; go to next physical extent
3021: F27A         ; result is non zero, so we must be in same logical ext
3022: F27A C3 A6 F2               JP     OpenNextExt2         ; to copy fcb information
3023: F27D         ; extent number overflow, go to next module
3024: F27D
3025: F27D             OpenNextModule:
3026: F27D 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
3027: F280 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
3028: F281 34                     INC    M                    ; fcb(fcbS2Index)=++1
3029: F282         ; module number incremented, check for overflow
3030: F282 7E                     LD     A,(HL)
3031: F283 E6 0F                  AND    moduleMask           ; mask high order bits
3032: F285 CA B1 F2               JP     Z,OpenNextExtError   ; cannot overflow to zero
3033: F288         ; otherwise, ok to continue with new module
3034: F288
3035: F288             OpenNextExt1:
3036: F288 0E 0F                  LD     C,nameLength
3037: F28A CD 85 EE               CALL   SearchForDirectoryRecord ; next extent found?
3038: F28D CD 09 EF               CALL   AtEndOfDirectory
3039: F290 C2 A6 F2               JP     NZ,OpenNextExt2
3040: F293         ; end of file encountered
3041: F293 3A 88 F5               LD     A,(readModeFlag)
3042: F296 3C                     INC    A                    ; 0ffh becomes 00 if read
3043: F297 CA B1 F2               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
3044: F29A         ; try to extend the current file
3045: F29A CD DC F2               CALL   MakeNewFile
3046: F29D         ; cannot be end of directory
3047: F29D CD 09 EF               CALL   AtEndOfDirectory
3048: F2A0 CA B1 F2               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
3049: F2A3 C3 A9 F2               JP     OpenNextExt3
3050: F2A6
3051: F2A6         ; not end of file, open
3052: F2A6             OpenNextExt2:
3053: F2A6 CD 43 ED               CALL   CopyDirRecordToFCB
3054: F2A9             OpenNextExt3:
3055: F2A9 CD 0C EE               CALL   SetRecordVars        ; Set Record parameters
3056: F2AC AF                     XOR    A
3057: F2AD 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
3058: F2B0 C9                     RET                         ; with exitParameterByte = 0
3059: F2B1
3060: F2B1         ; cannot move to next extent of this file
3061: F2B1             OpenNextExtError:
3062: F2B1 CD 10 F4               CALL   SetLowReturnTo1      ; exitParameterByte = 1
3063: F2B4 C3 6D EE               JP     SetFileWriteFlag     ; ensure that it will not be closed
3064: F2B7         ;-----------------------------------------------------------------
3065: F2B7         ;rename the file described by the first half of the currently addressed FCB.
3066: F2B7         ;the new name is contained in the last half of the FCB. The file name and type
3067: F2B7         ;are changed, but the reel number is ignored.  the user number is identical
3068: F2B7             Rename:
3069: F2B7 CD 37 F1               CALL   CheckWrite           ; may be write protected
3070: F2BA         ; search up to the extent field
3071: F2BA 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
3072: F2BC CD 85 EE               CALL   SearchForDirectoryRecord
3073: F2BF         ; copy position 0
3074: F2BF 2A C0 EA               LD     HL,(paramDE)
3075: F2C2 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
3076: F2C3 11 10 00               LD     DE,fcbDiskMapIndex
3077: F2C6 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
3078: F2C7 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
3079: F2C8         ; assume the same disk drive for new named file
3080: F2C8             Rename1:
3081: F2C8 CD 09 EF               CALL   AtEndOfDirectory
3082: F2CB C8                     RET    Z                    ; stop at end of dir
3083: F2CC         ; not end of directory, rename next element
3084: F2CC CD 2A F1               CALL   CheckRODirectory     ; may be read-only file
3085: F2CF 0E 10                  LD     C,fcbDiskMapIndex
3086: F2D1 1E 0C                  LD     E,fcbExtIndex
3087: F2D3 CD 29 F4               CALL   CopyDir
3088: F2D6         ; element renamed, move to next
3089: F2D6 CD 9A EE               CALL   GetNextDirectoryRecord
3090: F2D9 C3 C8 F2               JP     Rename1
3091: F2DC         ;-----------------------------------------------------------------
3092: F2DC         ;create a new file by creating a directory entry then opening the file
3093: F2DC             MakeNewFile:
3094: F2DC CD 37 F1               CALL   CheckWrite           ; may be write protected
3095: F2DF 2A C0 EA               LD     HL,(paramDE)
3096: F2E2 E5                     PUSH   HL                   ; save fcb address, look for e5
3097: F2E3 21 61 F5               LD     HL,emptyFCB
3098: F2E6 22 C0 EA               LD     (paramDE),HL         ; paramDE = .empty
3099: F2E9 0E 01                  LD     C,1
3100: F2EB CD 85 EE               CALL   SearchForDirectoryRecord ; length 1 match on empty entry
3101: F2EE CD 09 EF               CALL   AtEndOfDirectory     ; zero flag set if no space
3102: F2F1 E1                     POP    HL                   ; recall paramDE address
3103: F2F2 22 C0 EA               LD     (paramDE),HL         ; in case we return here
3104: F2F5 C8                     RET    Z                    ; return with error condition 255 if not found
3105: F2F6 EB                     EX     DE,HL                ; DE = paramDE address
3106: F2F7         ; clear the remainder of the fcb
3107: F2F7 21 0F 00               LD     HL,nameLength
3108: F2FA 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
3109: F2FB 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
3110: F2FD AF                     XOR    A                    ; clear accumulator to 00 for fill
3111: F2FE             MakeNewFile1:
3112: F2FE 77                     LD     (HL),A
3113: F2FF 23                     INC    HL
3114: F300 0D                     DEC    C
3115: F301 C2 FE F2               JP     NZ,MakeNewFile1
3116: F304 21 0D 00               LD     HL,fcbS1Index
3117: F307 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
3118: F308 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
3119: F309 CD 20 EF               CALL   SetDirectoryEntry    ; may have extended the directory
3120: F30C         ; now copy entry to the directory
3121: F30C CD 22 F4               CALL   CopyFCB
3122: F30F         ; and set the file write flag to "1"
3123: F30F C3 6D EE               JP     SetFileWriteFlag
3124: F312         ;-----------------------------------------------------------------
3125: F312         ;delete the currently addressed file
3126: F312             DeleteFile:
3127: F312 CD 37 F1               CALL   CheckWrite           ; write protected ?
3128: F315 0E 0C                  LD     C,fcbExtIndex        ; extent number field
3129: F317 CD 85 EE               CALL   SearchForDirectoryRecord ; search through file type
3130: F31A             DeleteFile1:
3131: F31A         ; loop while directory matches
3132: F31A CD 09 EF               CALL   AtEndOfDirectory
3133: F31D C8                     RET    Z                    ; exit if end
3134: F31E         ; set each non zero disk map entry to 0 in the allocation vector
3135: F31E CD 2A F1               CALL   CheckRODirectory     ; ro disk error if found
3136: F321 CD 12 EF               CALL   GetCurrentDirectoryRecord ; HL=.buff(dptr)
3137: F324 36 E5                  LD     (HL),emptyDir
3138: F326 0E 00                  LD     C,FALSE
3139: F328 CD 36 EF               CALL   ScanDiskMap          ; alloc elts set to 0
3140: F32B CD B7 F3               CALL   WriteDir             ; write the directory
3141: F32E CD 9A EE               CALL   GetNextDirectoryRecord ; to next element
3142: F331 C3 1A F3               JP     DeleteFile1          ; for another record
3143: F334         ;-----------------------------------------------------------------
3144: F334         ;locate the directory element and re-write it
3145: F334             CloseDirEntry:
3146: F334 AF                     XOR    A
3147: F335 32 C2 EA               LD     (exitParameterByte),A
3148: F338 CD 3E F1               CALL   IsDiskWriteProtected ; return TRUE (0) if checksum change
3149: F33B C0                     RET    NZ                   ; skip close if r/o disk
3150: F33C         ; check file write flag - 0 indicates written
3151: F33C CD 64 EE               CALL   GetWriteProtectValue ; fcb(fcbS2Index) in A
3152: F33F E6 80                  AND    writeFlagMask
3153: F341 C0                     RET    NZ                   ; return if bit remains set
3154: F342 0E 0F                  LD     C,nameLength
3155: F344 CD 85 EE               CALL   SearchForDirectoryRecord ; locate file
3156: F347 CD 09 EF               CALL   AtEndOfDirectory
3157: F34A C8                     RET    Z                    ; return if not found
3158: F34B         ; merge the disk map at paramDE with that at buff(dptr)
3159: F34B CD 12 EF               CALL   GetCurrentDirectoryRecord
3160: F34E 01 10 00               LD     BC,fcbDiskMapIndex
3161: F351 09                     ADD    HL,BC
3162: F352 EB                     EX     DE,HL                ; DE is .buff(dptr+16)
3163: F353 2A C0 EA               LD     HL,(paramDE)
3164: F356 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
3165: F357 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of  byte Allocation Map
3166: F359             CloseDirEntry1:
3167: F359 3A 8F F5               LD     A,(byteAllocationFlag)
3168: F35C B7                     OR     A
3169: F35D CA 74 F3               JP     Z,CloseDirEntry4     ; skip to double
3170: F360         ; this is a  byte map
3171: F360         ; if fcb(i) = 0 then fcb(i) = buff(i)
3172: F360         ; if buff(i) = 0 then buff(i) = fcb(i)
3173: F360         ; if fcb(i) <> buff(i) then error
3174: F360 7E                     LD     A,(HL)
3175: F361 B7                     OR     A
3176: F362 1A                     LD     A,(DE)
3177: F363 C2 67 F3               JP     NZ,CloseDirEntry2
3178: F366         ; fcb(i) = 0
3179: F366 77                     LD     (HL),A               ; fcb(i) = buff(i)
3180: F367             CloseDirEntry2:
3181: F367 B7                     OR     A
3182: F368 C2 6D F3               JP     NZ,CloseDirEntry3
3183: F36B         ; buff(i) = 0
3184: F36B 7E                     LD     A,(HL)
3185: F36C 12                     LD     (DE),AE              ; buff(i)=fcb(i)
3186: F36D             CloseDirEntry3:
3187: F36D BE                     CP     M
3188: F36E C2 AC F3               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
3189: F371 C3 89 F3               JP     CloseDirEntry5       ; if merge ok
3190: F374
3191: F374         ; this is a double byte merge operation
3192: F374             CloseDirEntry4:
3193: F374 CD CF F3               CALL   Merge                ; buff = fcb if buff 0000
3194: F377 EB                     EX     DE,HL
3195: F378 CD CF F3               CALL   Merge
3196: F37B EB                     EX     DE,HL                ; fcb = buff if fcb 0000
3197: F37C         ; they should be identical at this point
3198: F37C 1A                     LD     A,(DE)
3199: F37D BE                     CP     M
3200: F37E C2 AC F3               JP     NZ,CloseDirEntryError ; low same?
3201: F381 13                     INC    DE
3202: F382 23                     INC    HL                   ; to high byte
3203: F383 1A                     LD     A,(DE)
3204: F384 BE                     CP     M
3205: F385 C2 AC F3               JP     NZ,CloseDirEntryError ; high same?
3206: F388         ;	merge operation ok for this pair
3207: F388 0D                     DEC    C                    ; extra count for double byte
3208: F389             CloseDirEntry5:
3209: F389 13                     INC    DE
3210: F38A 23                     INC    HL                   ; to next byte position
3211: F38B 0D                     DEC    C
3212: F38C C2 59 F3               JP     NZ,CloseDirEntry1    ; for more
3213: F38F         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
3214: F38F 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
3215: F392 09                     ADD    HL,BC
3216: F393 EB                     EX     DE,HL
3217: F394 09                     ADD    HL,BC
3218: F395         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
3219: F395 1A                     LD     A,(DE)               ; current user extent number
3220: F396         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
3221: F396 BE                     CP     M
3222: F397 DA A3 F3               JP     C,CloseDirEntryEnd
3223: F39A         ; fcb extent number >= dir extent number
3224: F39A 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
3225: F39B         ; update directory record count field
3226: F39B 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
3227: F39E 09                     ADD    HL,BC
3228: F39F EB                     EX     DE,HL
3229: F3A0 09                     ADD    HL,BC
3230: F3A1         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
3231: F3A1 7E                     LD     A,(HL)
3232: F3A2 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
3233: F3A3             CloseDirEntryEnd:
3234: F3A3 3E FF                  LD     A,TRUE
3235: F3A5 32 87 F5               LD     (fcbCopiedFlag),A    ; mark as copied
3236: F3A8 CD B1 F3               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
3237: F3AB C9                     RET
3238: F3AC
3239: F3AC         ; elements did not merge correctly
3240: F3AC             CloseDirEntryError:
3241: F3AC 21 C2 EA               LD     HL,exitParameterByte
3242: F3AF 35                     DEC    M                    ; =255 non zero flag set
3243: F3B0 C9                     RET
3244: F3B1         ;-----------------------------------------------------------------
3245: F3B1         ;enter from CloseDirEntry to seek and copy current element
3246: F3B1             SeekCopy:
3247: F3B1 CD 30 F0               CALL   SeekDir              ; to the directory element
3248: F3B4 C3 B7 F3               JP     WriteDir             ; write the directory element
3249: F3B7         ;ret
3250: F3B7         ;-----------------------------------------------------------------
3251: F3B7         ;write the current directory entry, set checksum
3252: F3B7             WriteDir:
3253: F3B7         ;	CALL	NewCheckSum						; initialize entry
3254: F3B7 0E FF                  LD     C,TRUE
3255: F3B9 CD 7B F0               CALL   CheckSumUtility
3256: F3BC
3257: F3BC CD B6 ED               CALL   SetDirDMA            ; directory dma
3258: F3BF 0E 01                  LD     C,1                  ; indicates a write directory operation
3259: F3C1 CD C7 F3               CALL   WriteBuffer          ; write the buffer
3260: F3C4 C3 B1 ED               JP     SetDataDMA           ; to data dma address
3261: F3C7         ;ret
3262: F3C7         ;-----------------------------------------------------------------
3263: F3C7         ;write buffer and check condition
3264: F3C7         ;write type (wrtype) is in register C
3265: F3C7         ;wrtype = 0 => normal write operation		WriteAllocated
3266: F3C7         ;wrtype = 1 => directory write operation	WriteDirectory
3267: F3C7         ;wrtype = 2 => start of new block			WriteCleanBuffer
3268: F3C7             WriteBuffer:
3269: F3C7 CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
3270: F3CA B7                     OR     A
3271: F3CB C2 F4 F4               JP     NZ,erPermanentNoWait ; error if not 00
3272: F3CE C9                     RET
3273: F3CF         ;-----------------------------------------------------------------
3274: F3CF
3275: F3CF         ;HL = .fcb1(i), DE = .fcb2(i),
3276: F3CF         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
3277: F3CF             Merge:
3278: F3CF 7E                     LD     A,(HL)
3279: F3D0 23                     INC    HL
3280: F3D1 B6                     OR     M
3281: F3D2 2B                     DEC    HL
3282: F3D3 C0                     RET    NZ                   ; return if = 0000
3283: F3D4 1A                     LD     A,(DE)
3284: F3D5 77                     LD     (HL),A
3285: F3D6 13                     INC    DE
3286: F3D7 23                     INC    HL                   ; low byte copied
3287: F3D8 1A                     LD     A,(DE)
3288: F3D9 77                     LD     (HL),A
3289: F3DA 1B                     DEC    DE
3290: F3DB 2B                     DEC    HL                   ; back to input form
3291: F3DC C9                     RET
3292: F3DD         ;-----------------------------------------------------------------
3293: F3DD
3294: F3DD         ;-----------------------------------------------------------------
3295: F3DD         ;compute disk block number from current fcb
3296: F3DD             GetBlockNumber:
3297: F3DD CD 3E F4               CALL   GetDiskMapIndex      ; 0...15 in register A
3298: F3E0 4F                     LD     C,A
3299: F3E1 06 00                  LD     B,0
3300: F3E3 CD 5E F4               CALL   GetDiskMapValue      ; return value in HL
3301: F3E6 22 97 F5               LD     (absoluteCPMRecord),HL ; save for later
3302: F3E9 C9                     RET
3303: F3EA         ;-----------------------------------------------------------------
3304: F3EA         ;is  block allocated
3305: F3EA             IsAllocated:
3306: F3EA 2A 97 F5               LD     HL,(absoluteCPMRecord)
3307: F3ED 7D                     LD     A,L
3308: F3EE B4                     OR     H
3309: F3EF C9                     RET
3310: F3F0         ;-----------------------------------------------------------------
3311: F3F0         ;compute actual record address
3312: F3F0         ; result = absolute CPMRecord * ( 2**BSH)
3313: F3F0             SetActualRecordAdd:
3314: F3F0 3A 78 F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
3315: F3F3 2A 97 F5               LD     HL,(absoluteCPMRecord)
3316: F3F6
3317: F3F6             SetActualRecordAdd1:
3318: F3F6 29                     ADD    HL,HL
3319: F3F7 3D                     DEC    A                    ; shl(absolute CPMRecord,dpbBSH)
3320: F3F8 C2 F6 F3               JP     NZ,SetActualRecordAdd1
3321: F3FB         ; HL has Record number for start of the block;
3322: F3FB 3A 79 F5               LD     A,(dpbBLM)           ; get block mask
3323: F3FE 4F                     LD     C,A                  ; to get current File Record mod Block
3324: F3FF 3A 95 F5               LD     A,(currentFileRecord) ; get index into block
3325: F402 A1                     AND    C                    ; masked value in A
3326: F403 B5                     OR     L
3327: F404 6F                     LD     L,A                  ; to HL
3328: F405 22 97 F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL or (current File Record and dpbBLM)
3329: F408         ; *** Absolute CPM Record now has current record number - Starting record number + index into block
3330: F408 C9                     RET
3331: F409         ;-----------------------------------------------------------------
3332: F409         ;---------------------
3333: F409         ;copy directory location to exitParameterByte
3334: F409             DirLocationToReturnLoc:
3335: F409 3A 89 F5               LD     A,(directoryFlag)
3336: F40C 32 C2 EA               LD     (exitParameterByte),A
3337: F40F C9                     RET
3338: F410         ;---------------------
3339: F410
3340: F410
3341: F410         ;---------------------
3342: F410         ;set exitParameterByte to 1
3343: F410             SetLowReturnTo1:
3344: F410 3E 01                  LD     A,1
3345: F412 32 C2 EA               LD     (exitParameterByte),A
3346: F415 C9                     RET
3347: F416         ;---------------------
3348: F416         ;---------------------
3349: F416         ;copy the directory entry to the user buffer
3350: F416             CopyDirEntryToUser:
3351: F416 2A 6E F5               LD     HL,(caDirectoryDMA)
3352: F419 EB                     EX     DE,HL                ; source is directory buffer
3353: F41A 2A 66 F5               LD     HL,(initDAMAddress)  ; destination is user dma address
3354: F41D 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3355: F41F C3 97 F4               JP     MoveX
3356: F422         ;---------------------
3357: F422         ;copy the whole file control block
3358: F422             CopyFCB:
3359: F422 0E 00                  LD     C,0
3360: F424 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3361: F426 C3 29 F4               JP     CopyDir
3362: F429         ;---------------------
3363: F429         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3364: F429             CopyDir:
3365: F429 D5                     PUSH   DE                   ; save length for later
3366: F42A 06 00                  LD     B,0                  ; double index to BC
3367: F42C 2A C0 EA               LD     HL,(paramDE)         ; HL = source for data
3368: F42F 09                     ADD    HL,BC
3369: F430 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3370: F431 CD 12 EF               CALL   GetCurrentDirectoryRecord ; HL=.buff(dptr), destination
3371: F434 C1                     POP    BC                   ; DE=source, HL=dest, C=length
3372: F435 CD 97 F4               CALL   MoveX                ; data moved
3373: F438         ;enter from close to seek and copy current element
3374: F438             SeekAndCopy:                      ; seek$copy:
3375: F438 CD 30 F0               CALL   SeekDir              ; seek$dir ;to the directory element
3376: F43B C3 B7 F3               JP     WriteDir             ; write the directory element
3377: F43E         ;---------------------
3378: F43E         ;Return the  disk map Index for current File Record in the ACC
3379: F43E         ;  account for multiple extents in 1 physical Directory entry
3380: F43E             GetDiskMapIndex:                      ; dm$position
3381: F43E 21 78 F5               LD     HL,dpbBSH            ; get block shift value
3382: F441 4E                     LD     C,(HL)               ; shift count to C
3383: F442 3A 95 F5               LD     A,(currentFileRecord) ; current virtual record to A
3384: F445             GetDiskMapIndex1:
3385: F445 B7                     OR     A                    ; reset the carry flag
3386: F446 1F                     RRA
3387: F447 0D                     DEC    C
3388: F448 C2 45 F4               JP     NZ,GetDiskMapIndex1
3389: F44B         ; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
3390: F44B         ; A has the relative position in the block.
3391: F44B 47                     LD     B,A                  ; save it for later addition
3392: F44C 3E 08                  LD     A,8
3393: F44E 96                     SUB    M                    ; 8-dpbBSH to accumulator
3394: F44F 4F                     LD     C,A                  ; extent shift count in register c
3395: F450 3A 94 F5               LD     A,(extentValue)      ; extent value ani extmsk
3396: F453             GetDiskMapIndex2:                      ; dmpos1:
3397: F453         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3398: F453         ; shift is 4,3,2,1,0
3399: F453 0D                     DEC    C
3400: F454 CA 5C F4               JP     Z,GetDiskMapIndex3
3401: F457 B7                     OR     A                    ; clear the carry flag
3402: F458 17                     RLA
3403: F459 C3 53 F4               JP     GetDiskMapIndex2
3404: F45C
3405: F45C         ; The ACC has the Block Number for this record
3406: F45C             GetDiskMapIndex3:
3407: F45C         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3408: F45C 80                     ADD    A,B                  ; add the previous shr(current File Record,dpbBSH) value
3409: F45D         ; A is one of the following values, depending upon alloc
3410: F45D         ; bks dpbBSH
3411: F45D         ; 1k   3     v/8 + extentValue * 16
3412: F45D         ; 2k   4     v/16+ extentValue * 8
3413: F45D         ; 4k   5     v/32+ extentValue * 4
3414: F45D         ; 8k   6     v/64+ extentValue * 2
3415: F45D         ; 16k  7     v/128+extentValue * 1
3416: F45D C9                     RET                         ; with disk map position in A
3417: F45E         ;---------------------
3418: F45E         ; Enter with Disk Map Index in BG
3419: F45E         ; Return disk map value  in HL
3420: F45E             GetDiskMapValue:
3421: F45E 2A C0 EA               LD     HL,(paramDE)         ; base address of file control block
3422: F461 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3423: F464 19                     ADD    HL,DE                ; HL =.diskmap
3424: F465 09                     ADD    HL,BC                ; index by a  byte value
3425: F466 3A 8F F5               LD     A,(byteAllocationFlag) ;  byte map entry?
3426: F469 B7                     OR     A
3427: F46A CA 71 F4               JP     Z,GetDiskMap16Bit    ; get disk map  byte
3428: F46D 6E                     LD     L,(HL)
3429: F46E 26 00                  LD     H,0
3430: F470 C9                     RET                         ; with HL=00bb
3431: F471             GetDiskMap16Bit:                      ; getdmd:
3432: F471 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3433: F472         ; double precision value returned
3434: F472 56                     LD     D,(HL)
3435: F473 23                     INC    HL
3436: F474 5E                     LD     E,(HL)
3437: F475 EB                     EX     DE,HL
3438: F476 C9                     RET
3439: F477         ;---------------------
3440: F477         ;---------------------
3441: F477         ;*****************************************************************
3442: F477         ;************************ Utilities ******************************
3443: F477         ;*****************************************************************
3444: F477             AddAtoHL:
3445: F477 85                     ADD    A,L
3446: F478 6F                     LD     L,A
3447: F479 D0                     RET    NC
3448: F47A 24                     INC    H
3449: F47B C9                     RET
3450: F47C         ;----------
3451: F47C             DEminusHL2HL:
3452: F47C 7B                     LD     A,E
3453: F47D 95                     SUB    L
3454: F47E 6F                     LD     L,A
3455: F47F 7A                     LD     A,D
3456: F480 9C                     SBC    A,H
3457: F481 67                     LD     H,A
3458: F482 C9                     RET
3459: F483         ;-------------
3460: F483             ShiftRightHLbyC:
3461: F483 0C                     INC    C
3462: F484             ShiftRightHLbyC0:
3463: F484 0D                     DEC    C
3464: F485 C8                     RET    Z
3465: F486 7C                     LD     A,H
3466: F487 B7                     OR     A
3467: F488 1F                     RRA
3468: F489 67                     LD     H,A
3469: F48A 7D                     LD     A,L
3470: F48B 1F                     RRA
3471: F48C 6F                     LD     L,A
3472: F48D C3 84 F4               JP     ShiftRightHLbyC0
3473: F490         ;-------
3474: F490             ShiftLeftHLbyC:
3475: F490 0C                     INC    C
3476: F491             ShiftLeftHLbyC0:
3477: F491 0D                     DEC    C
3478: F492 C8                     RET    Z                    ; exit when done
3479: F493 29                     ADD    HL,HL
3480: F494 C3 91 F4               JP     ShiftLeftHLbyC0
3481: F497         ;*****************************************************************
3482: F497         ;move data length of length C from source DE to HL
3483: F497             MoveX:
3484: F497 0C                     INC    C
3485: F498             MoveX0:
3486: F498 0D                     DEC    C
3487: F499 C8                     RET    Z
3488: F49A 1A                     LD     A,(DE)
3489: F49B 77                     LD     (HL),A
3490: F49C 13                     INC    DE
3491: F49D 23                     INC    HL
3492: F49E C3 98 F4               JP     MoveX0
3493: F4A1
3494: F4A1         ;********** Console OUT Routines*******************??????
3495: F4A1
3496: F4A1         ;---------------------------------- Is Bit Set ------------------------------;
3497: F4A1         ; Enter HL  contains the bit map                                             ;
3498: F4A1         ;       B   Has the bit number (0...F)                                       ;
3499: F4A1         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3500: F4A1         ;              = 0 if bit is set (1)                                         ;
3501: F4A1             IsBitSet:                       ;
3502: F4A1 04                     INC    B                    ;
3503: F4A2             IsBitSetLoop:                      ;
3504: F4A2 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3505: F4A3 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3506: F4A5 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3507: F4A7 3F                     CCF                         ; else Clear Carry flag              ;
3508: F4A8             IsBitSet1:                      ;
3509: F4A8 CB 1C                  RR     H                    ; Shift thru CY                      ;
3510: F4AA CB 1D                  RR     L                    ; ditto                              ;
3511: F4AC 10 F4                  DJNZ   IsBitSetLoop         ;
3512: F4AE CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3513: F4B0 C9                     RET                         ;
3514: F4B1         ;---------------------------------- Is Bit Set ------------------------------;
3515: F4B1
3516: F4B1         ;============================ Set/Reset Vector Bit ==========================;
3517: F4B1         ;---------------------------------- Set Vector Bit -------------------------;;
3518: F4B1         ; Enter  HL  contains the bit map vector                                    ;;
3519: F4B1         ;        B   Has the bit number (0...F)                                     ;;
3520: F4B1         ; Return HL  Contains the modified bit map vector                                  ;;
3521: F4B1             SetVectorBit:                      ;;
3522: F4B1 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3523: F4B2 CD A1 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3524: F4B5         ;;
3525: F4B5 C1                     POP    BC                   ; Get the bit position              ;;
3526: F4B6 CB FC                  SET    7,H                  ;;
3527: F4B8 18 07                  JR     ReAlignVector        ;                                    ;
3528: F4BA         ;---------------------------------- Set Vector Bit -------------------------;;
3529: F4BA         ;---------------------------------- Reset Vector Bit -----------------------;;
3530: F4BA         ; Enter  HL  contains the bit map vector                                    ;;
3531: F4BA         ;        B   Has the bit number (0...F)                                     ;;
3532: F4BA         ; Return HL  Contains the modified bit map vector                           ;;
3533: F4BA             ResetVectorBit:                      ;;
3534: F4BA C5                     PUSH   BC                   ; Save the Bit Number               ;;
3535: F4BB CD A1 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3536: F4BE         ;;
3537: F4BE C1                     POP    BC                   ; Get the bit position              ;;
3538: F4BF CB BC                  RES    7,H                  ;;
3539: F4C1         ; Fall thru to ReAlignVector                                                 ;
3540: F4C1         ;---------------------------------- Reset Vector Bit -----------------------;;
3541: F4C1         ;---------------------------------- Set VectorBit --------------------------;;
3542: F4C1         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3543: F4C1         ;
3544: F4C1             ReAlignVector:                      ;
3545: F4C1 04                     INC    B                    ;
3546: F4C2             ReAlignMapLoop:                      ;
3547: F4C2 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3548: F4C3 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3549: F4C5 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3550: F4C7 3F                     CCF                         ; else Clear Carry flag              ;
3551: F4C8             ReAlignMap1:                      ;
3552: F4C8 CB 15                  RL     L                    ; Shift thru CY                      ;
3553: F4CA CB 14                  RL     H                    ; ditto                              ;
3554: F4CC 10 F4                  DJNZ   ReAlignMapLoop       ;
3555: F4CE C9                     RET                         ;
3556: F4CF         ;============================ Set/Reset Vector Bit ==========================;
3557: F4CF         ;************Error message World*************************
3558: F4CF             errSelect:
3559: F4CF 21 EE F4               LD     HL,evSelection
3560: F4D2 C3 E7 F4               JP     GoToError
3561: F4D5             errReadOnlyDisk:
3562: F4D5 21 F0 F4               LD     HL,evReadOnlyDisk
3563: F4D8 C3 E7 F4               JP     GoToError
3564: F4DB             errReadOnlyFile:
3565: F4DB 21 F2 F4               LD     HL,evReadOnlyFile
3566: F4DE C3 E7 F4               JP     GoToError
3567: F4E1             errPermanent:
3568: F4E1 21 EC F4               LD     HL,evPermanent
3569: F4E4 C3 E7 F4               JP     GoToError
3570: F4E7         ;************Error message handler **********************
3571: F4E7             GoToError:
3572: F4E7         ;HL = .errorhandler, call subroutine
3573: F4E7 5E                     LD     E,(HL)
3574: F4E8 23                     INC    HL
3575: F4E9 56                     LD     D,(HL)               ; address of routine in DE
3576: F4EA EB                     EX     DE,HL
3577: F4EB E9                     JP     (HL)                 ; vector to subroutine
3578: F4EC         ;************ Error Vectors *****************************
3579: F4EC FA F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3580: F4EE 06 F5       evSelection: DW     erSelection          ; selerr select error subroutine
3581: F4F0 0C F5       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3582: F4F2 12 F5       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3583: F4F4         ;************Error Routines ******************************
3584: F4F4             erPermanentNoWait:
3585: F4F4 21 44 F5               LD     HL,emPermanent
3586: F4F7 C3 E7 F4               JP     GoToError
3587: F4FA             erPermanent:
3588: F4FA 21 44 F5               LD     HL,emPermanent
3589: F4FD CD 1B F5               CALL   displayAndWait       ; to report the error
3590: F500 FE 03                  CP     CTRL_C
3591: F502 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3592: F505 C9                     RET                         ; and ignore the error
3593: F506         ;
3594: F506             erSelection:
3595: F506 21 4F F5               LD     HL,emSelection
3596: F509 C3 15 F5               JP     waitB4boot           ; wait console before boot
3597: F50C         ;
3598: F50C             erReadOnlyDisk:
3599: F50C 21 5B F5               LD     HL,emReadOnlyDisk
3600: F50F C3 15 F5               JP     waitB4boot           ; wait console before boot
3601: F512         ;
3602: F512             erReadOnlyFile:
3603: F512 21 56 F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3604: F515         ;
3605: F515         ; wait for response before boot
3606: F515             waitB4boot:
3607: F515 CD 1B F5               CALL   displayAndWait
3608: F518 C3 00 00               JP     WarmBoot
3609: F51B
3610: F51B         ;report error to console, message address in HL
3611: F51B             displayAndWait:
3612: F51B E5                     PUSH   HL                   ; save message pointer
3613: F51C CD D3 E9               CALL   showCRLF             ; stack mssg address, new line
3614: F51F 3A 60 F5               LD     A,(currentDisk)
3615: F522 C6 41                  ADD    A,ASCII_A
3616: F524 32 40 F5               LD     (emDisk),A           ; Problem disk name
3617: F527 01 34 F5               LD     BC,emDisk0
3618: F52A CD 38 E9               CALL   Print                ; the error message
3619: F52D C1                     POP    BC
3620: F52E CD 38 E9               CALL   Print                ; error mssage tail
3621: F531 C3 1E E9               JP     ConIn                ; to get the input character
3622: F534         ;ret
3623: F534         ;**************Error Messages*******************************
3624: F534 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3625: F540 20 3A 20 24     emDisk:    DB     ' : $'
3626: F544 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3627: F54F 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3628: F556 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3629: F55B 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3630: F55F         ;*****************************************************************
3631: F55F
3632: F55F         ;********* file control block (fcb) constants ********************
3633: F55F             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3634: F55F             fcbROfileIndex EQU    09H                  ; high order of first type char
3635: F55F             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3636: F55F             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3637: F55F             fcbS1Index EQU    0DH                  ;13				; S1 index
3638: F55F             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3639: F55F             fcbRCIndex EQU    0FH                  ;15				; record count field index
3640: F55F             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3641: F55F
3642: F55F             fcbCurrentRecord EQU    21H                  ;33
3643: F55F
3644: F55F             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3645: F55F
3646: F55F             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3647: F55F             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3648: F55F             dirEntryMask EQU    dirEntriesPerRecord-1
3649: F55F             fcbShift   EQU    5                    ; log2(fcbLength)
3650: F55F         ;
3651: F55F
3652: F55F
3653: F55F
3654: F55F             maxExtValue EQU    31                   ; largest extent number
3655: F55F             moduleMask EQU    15                   ; limits module number value
3656: F55F             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3657: F55F             nameLength EQU    15                   ; namlen name length
3658: F55F
3659: F55F             emptyDir   EQU    0E5H                 ; empty empty directory entry
3660: F55F             NEXT_RECORD EQU    fcbLength            ; nxtrec
3661: F55F             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3662: F55F         ;
3663: F55F         ;	reserved file indicators
3664: F55F         ;	equ	11				; reserved
3665: F55F         ;*****************************************************************
3666: F55F         ;*****************************************************************
3667: F55F
3668: F55F         ;***common values shared between bdosi and bdos******************
3669: F55F 00          currentUserNumber: DB     0                    ; usrcode current user number
3670: F560         ; paramDE:			DS	2					; ParamsDE information address
3671: F560         ; exitParameterByte:
3672: F560         ; exitParameterWord:	DS	2					; address value to return
3673: F560 FF          currentDisk: DB     -1                   ; curdsk current disk number
3674: F561         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3675: F561
3676: F561         ;********************* Local Variables ***************************
3677: F561         ;     ************************
3678: F561         ;     *** Initialized Data ***
3679: F561
3680: F561 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3681: F562 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
3682: F564 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3683: F566 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3684: F568
3685: F568         ;     *** Current Disk attributes ****
3686: F568         ; These are set upon disk select
3687: F568         ; data must be adjacent, do not insert variables
3688: F568         ; address of translate vector, not used
3689: F568         ; ca - currentAddress
3690: F568
3691: F568 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3692: F56A 00 00       caTrack:   DW     0000H                ; curtrka current track address
3693: F56C 00 00       caSector:  DW     0000H                ; current Sector
3694: F56E             caListSizeStart:
3695: F56E 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3696: F570 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3697: F572 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3698: F574 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3699: F576             caListSizeEnd:
3700: F576             caListSize EQU    caListSizeEnd - caListSizeStart
3701: F576
3702: F576         ;     ***** Disk Parameter Block *******
3703: F576         ; data must be adjacent, do not insert variables
3704: F576         ; dpb - Disk Parameter Block
3705: F576             dpbStart:
3706: F576 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3707: F578 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3708: F579 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3709: F57A 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3710: F57B 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3711: F57D 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3712: F57F 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3713: F581 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3714: F583 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3715: F585             dpbEnd:
3716: F585             dpbSize    EQU    dpbEnd - dpbStart
3717: F585         ;
3718: F585
3719: F585         ;     ************************
3720: F585
3721: F585 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3722: F587 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3723: F588 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3724: F589 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3725: F58A 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3726: F58B 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3727: F58C 00          searchLength: DB     00H                  ; searchl search length
3728: F58D 00 00       searchAddress: DW     0000H                ; searcha search address
3729: F58F         ;tinfo:	ds	word							; temp for info in "make"
3730: F58F 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3731: F590 00          fResel:    DB     00H                  ; resel reselection flag
3732: F591 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3733: F592 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3734: F593 00          fcbRecordCount: DB     00H                  ; record count from current FCB
3735: F594 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3736: F595 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3737: F597 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3738: F599         ;
3739: F599         ;	local variables for directory access
3740: F599 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3741: F59A 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3742: F59C 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3743: F59E
3744: F59E         ;********************** data areas ******************************
3745: F59E
3746: F59E
3747: F59E         ;---------------------------------- Stack Area--------------------------------;
3748: F59E             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3749: F5DE             bdosStack:
3750: F5DE         ;
3751: F5DE         ;---------------------------------- Stack Area--------------------------------;
3752: F5DE         ;	end of Basic I/O System
3753: F5DE         ;-----------------------------------------------------------------;
3754: F5DE
3755: F5DE
3756: F5DE         ;
3757: F5DE             Z_HighestLocation:
3758: F5DE             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3759: F5DE
3760: F5DE
           ************************   Xref   ************************
0000: $               F5DE   0416 0446
3737: absoluteCPMRecord F597   2579 2586 2604 2909 3301 3306 3315 3328
3444: AddAtoHL        F477   2919
2923: Allocate16Bit   F1FA   2917
1043: AreWeAtEndOfBuffer EA37   1039
0085: ASCII_A         0041   3615
0086: ASCII_C         0043
0087: ASCII_K         004B
0094: ASCII_LO_A      0061
0095: ASCII_LO_K      006B
0096: ASCII_LO_P      0070
0037: ASCII_MASK      007F   0986
0088: ASCII_N         004E
0089: ASCII_Q         0051
0090: ASCII_R         0052
0091: ASCII_W         0057
0092: ASCII_Y         0059
0072: ASCII_ZERO      0030
0066: ASTERISK        002A
2279: AtEndOfDirectory EF09   1614 1839 1870 2195 2688 3003 3038 3047 3081 3101 3132 3156
1135: BackUp          EA9C   1063 1131
1140: BackUp1         EAA4   1136
0294: bcBoot          F600
0297: bcConin         F609   0616 0801 0912 0930
0298: bcConout        F60C   0608 0874 1138 1142 1148 1150
0296: bcConst         F606   0613 0908
0302: bcHome          F618   1956
0299: bcList          F60F   0581 0880
0309: bcListst        F62D
0300: bcPunch         F612   0566
0307: bcRead          F627   1998
0301: bcReader        F615   0547
0310: bcSectran       F630
0303: bcSeldsk        F61B   1742
0306: bcSetdma        F624   1993
0305: bcSetsec        F621   2619
0304: bcSettrk        F61E   1962 2616
0295: bcWboot         F603   0467
0308: bcWrite         F62A   3269
0152: BDOSBase        E800   0153 0155 0326
0121: BDOSE           0005   0122
0153: BDOSEntry       E800
0142: BDOSLength      0E00   0145 0155 0156
3749: bdosStack       F5DE
0332: BdosStart       E800
0055: BELL            0007
0155: BIOSBase        F600
0143: BIOSLength      0A00   0145
0115: BIOSPAGE        0002
0156: BIOSStart       F600   0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 3758
2908: BlockOK         F1DE   2902
0252: BlockSize       0800   0274
1058: BSspaceBS       EA45   0997
0033: BYTE            0001   1171
3730: byteAllocationFlag F58F   1775 2356 2914 3167 3425
3698: caAllocVector   F574   1337 1795 1797 1822 2106 2409 2476
3697: caCheckSum      F572   2647
3695: caDirectoryDMA  F56E   1762 1985 2294 2639 3351
3691: caDirMaxValue   F568   1753 1829 2015 2329
3696: caDiskParamBlock F570   1371 1767
3700: caListSize      0008   1763
3699: caListSizeEnd   F576   3700
3694: caListSizeStart F56E   3700
0093: CARET           005E   0840
0834: CaretOut        E945   1032 1113
3693: caSector        F56C   1759 1970 2608
3721: caSkewTable     F585   1751
3692: caTrack         F56A   1756 1966 2599
0150: CCPEntry        E000   0152 0156
0141: CCPLength       0800   0145 0152 0156
0926: CheckCTL_S      E9A9   0915
2233: CheckExtents    EEDB   2227
2781: CheckRODirectory F12A   3084 3135
2786: CheckROFile     F12D   2865
2627: CheckSumUtility F07B   2571 3255
2795: CheckWrite      F137   2863 3069 3094 3127
3145: CloseDirEntry   F334   1535 2705 3001
3166: CloseDirEntry1  F359   3212
3180: CloseDirEntry2  F367   3177
3186: CloseDirEntry3  F36D   3182
3192: CloseDirEntry4  F374   3169
3208: CloseDirEntry5  F389   3189
3233: CloseDirEntryEnd F3A3   3222
3240: CloseDirEntryError F3AC   3188 3200 3205
0073: COLON           003A
1169: columnPosition  EABE   0859 0884 0949 0969 1127
0068: COMMA           002C
2157: CompareExtents  EE74   2234
2637: ComputeCheckSum F087
2641: ComputeCheckSum1 F08E   2644
0127: ComTail         0080   0128
0129: ComTailChars    0082
0128: ComTailCount    0081   0129
0903: ConBreak        E989   0727 0870
0936: ConBreak0       E9B7   0928
0938: ConBreak1       E9BA   0906
0794: ConIn           E91E   0499 0985 3621
0867: ConsoleOut      E968   0841 0853 0858 0946 0954 0961 0963 1055
3364: CopyDir         F429   2692 3087 3361
3350: CopyDirEntryToUser F416   2723 2733
1873: CopyDirRecordToFCB ED43   3053
3358: CopyFCB         F422   3121
0229: cpmRecordSize   0080   0231 0234 0236 2638 3354 3646
0058: CR              000D   0807 0960 0990 1054
0041: CTRL_C          0003   0931 1037 3590
0042: CTRL_E          0005   1002
0043: CTRL_H          0008   0813 0996 1141
0044: CTRL_K          000B
0045: CTRL_L          000C
0046: CTRL_P          0010   0914 1005
0047: CTRL_R          0012   1014
0048: CTRL_S          0013   0927
0049: CTRL_U          0015   1011
0050: CTRL_X          0018   1008
0051: CTRL_Z          001A
3673: currentDisk     F560   1206 1299 1710 1721 1727 1740 1922 2008 2034 2803 3614
3736: currentFileRecord F595   2060 2675 2822 2832 2867 2952 2989 3324 3383
3669: currentUserNumber F55F   0778 0784 1847 2043
0069: DASH            002D
0263: DataBlocks      02C7   0273
0262: DataSectors     0B1C   0263
3126: DeleteFile      F312   2740
3130: DeleteFile1     F31A   3142
1122: DeleteTheLine   EA8B   1009
1125: DeleteTheLine1  EA8C   1132
3451: DEminusHL2HL    F47C
3740: dirBlockIndex   F599   2295 2563
0234: DirBuffSize     0080
0249: DirectoryBlockCount 0002   0274
0236: DirectoryEntryPerRecord 0004   0277
3724: directoryFlag   F589   2184 2248 3335
3646: dirEntriesPerRecord 0004   3648
3741: dirEntryIndex   F59A   2244 2270 2280 2327 2546 2548 2557 2576
3648: dirEntryMask    0003   2245 2558
3647: dirEntryShift   0002   2577
0233: DirEntrySize    0020   0236 0274
3334: DirLocationToReturnLoc F409   1704 2741 2775
3742: dirRecord       F59C   2580 2629 2648
0221: DiskCommandBlock 0046
0220: DiskControlByte 0045
0223: DiskControlTable 0040
2849: DiskEOF         F18C   2829 2836 2842
0416: diskf           000B
3726: diskMapIndex    F58B   2885 2916
2817: DiskRead        F151   1464
0225: DiskReadCode    0001
0230: diskSectorSize  0200   0231 0252 0260
0219: DiskStatusLocation 0043
2859: DiskWrite       F194   1471
2874: DiskWrite1      F1B1   2869
2933: DiskWrite2      F202   2921
2939: DiskWrite3      F204   2878
2960: DiskWrite4      F224   2955
2971: DiskWrite5      F231   2964
2990: DiskWrite6      F24F   2986
2992: DiskWrite7      F251   2974 2978
0226: DiskWriteCode   0002
2854: DiskWriteSeq    F18F   2756
3611: displayAndWait  F51B   3589 3607
2506: DivideHLby8     EFE5   1790 2395 2398
0132: DMABuffer       0080   1208 3683
0062: DOLLAR          0024   0822 1853
0275: dpb3hdAL0       00C0
0276: dpb3hdAL1       0000
0271: dpb3hdBLM       000F
0270: dpb3hdBSH       0004
0277: dpb3hdCKS       0020
0274: dpb3hdDRM       007F   0277
0273: dpb3hdDSM       02C6
0272: dpb3hdEXM       0000
0279: dpb3hdNOH       0002
0278: dpb3hdOFF       0001
0269: dpb3hdSPT       0090
3708: dpbBLM          F579   3322
3707: dpbBSH          F578   3314 3381
3713: dpbCKS          F581   2628
3712: dpbDABM         F57F   1820
3711: dpbDRM          F57D   2013 2545
3710: dpbDSM          F57B   1773 1789 1805 2394
3715: dpbEnd          F585   3716
3709: dpbEXM          F57A   2065 2160 3015
3714: dpbOFF          F583   1958 2612
3716: dpbSize         000F   1769
3706: dpbSPT          F576   2587
3705: dpbStart        F576   1768 3716
0448: DUMMY           E8A6   0443 0444
3625: emDisk          F540   3616
3624: emDisk0         F534   3617
3626: emPermanent     F544   3585 3588
3659: emptyDir        00E5   1843 2201 3137 3680
3680: emptyFCB        F561   3097
3629: emReadOnlyDisk  F55B   3599
3628: emReadOnlyFile  F556   3603
3627: emSelection     F54F   3595
0136: END_OF_FILE     001A
0039: EndOfMessage    0000
1048: EndRead         EA3B   0991 0994
3732: entryDisk       F591   0389 2035
0291: EOD             FFFF   2269
0077: EQUAL_SIGN      003D
3587: erPermanent     F4FA   3579
3584: erPermanentNoWait F4F4   2000 3271
3598: erReadOnlyDisk  F50C   3581
3602: erReadOnlyFile  F512   3582
3567: errPermanent    F4E1
3561: errReadOnlyDisk F4D5   2798
3564: errReadOnlyFile F4DB   2792
3558: errSelect       F4CF   1720
3594: erSelection     F506   3580
3579: evPermanent     F4EC   3568
3581: evReadOnlyDisk  F4F0   3562
3582: evReadOnlyFile  F4F2   3565
3580: evSelection     F4EE   3559
0060: EXCLAIM_POINT   0021
1173: exitParameterByte EAC2   0508 0617 0728 0754 0779 1300 1539 1549 1560 1567 1580 1857 2246 2260 2834 2905 2940 2983 3057 3147 3241 3336 3345
1174: exitParameterWord EAC2   0345 0396 0548 0637 1277 1338 1357 1372
3735: extentValue     F594   2067 3395
0028: FALSE           0000   0921 1093 1469 1779 2193 2860 3138
0124: FCB1            005C   0125
0125: FCB2            006C
3722: fcbCopiedFlag   F587   3000 3018 3235
3642: fcbCurrentRecord 0021
3733: fcbDisk         F592   0347 0384 2037
3640: fcbDiskMapIndex 0010   2346 2348 2912 3076 3085 3160 3165 3422
3636: fcbExtIndex     000C   1518 1542 1601 1653 1888 2086 2225 2685 2691 3006 3026 3071 3086 3128 3214 3226
0014: fcbExtIndexLSB  000C
0015: fcbExtIndexMSB  000E
3635: fcbHiddenfileIndex 000A
3633: fcbLength       0020   1882 2348 3109 3165 3214 3360 3646 3660
3639: fcbRCIndex      000F   1618 1891 1909 2075 2078 3226
3734: fcbRecordCount  F593   2063 2679 2823 2953
3634: fcbROfileIndex  0009   2787
3637: fcbS1Index      000D   2222 3116
3638: fcbS2Index      000E   1524 1545 1670 2140 3026
3649: fcbShift        0005   2559
0169: fCloseFile      0010
0160: fConsoleIn      0001
0161: fConsoleOut     0002
0172: fDeleteFile     0013
0164: fGetConsoleStatus 000B
0178: fGetCurrentDisk 0019
0177: fGetLoginVector 0018
0180: fGetSetUserNumber 0020
0165: fGetVersion     000C
2896: FirstBlock      F1D0   2888
0175: fMakeFile       0016
0168: fOpenFile       000F
2455: FoundFreeOctet  EFB3   2425 2430 2439 2447
2461: FoundFreeOctet1 EFB9   2457
2463: FoundFreeOctet2 EFBA   2459
2465: FoundFreeOctet3 EFBD   2468
2471: FoundFreeOctet4 EFC5   2473
0162: fPrintString    0009
0173: fReadSeq        0014
0163: fReadString     000A
0176: fRenameFile     0017
3731: fResel          F590   0348 0378 2025
0166: fResetSystem    000D
0170: fSearchFirst    0011
0171: fSearchNext     0012
0167: fSelectDisk     000E
0179: fSetDMA         001A
0446: functionCount   0028   0357
0403: functionTable   E854   0362 0416 0446
0174: fWriteSeq       0015
3296: GetBlockNumber  F3DD   2840 2875
2391: GetClosestBlock EF62   2898
2292: GetCurrentDirectoryRecord EF12   1617 1842 1878 2211 2345 2782 3136 3159 3370
3431: GetDiskMap16Bit F471   3427
3380: GetDiskMapIndex F43E   2884 3297
3384: GetDiskMapIndex1 F445   3388
3396: GetDiskMapIndex2 F453   3403
3406: GetDiskMapIndex3 F45C   3400
3420: GetDiskMapValue F45E   2892 3300
2084: GetExtentAddress EE30   1874 2064
2138: GetExtentNumberMSB EE64   1574 2129 2966
2073: GetFcbRecordDetails EE23   2057 2672
1600: GetFileSize     EBE2   1435
1613: GetFileSize1    EBF4   1641
1639: GetFileSize2    EC16   1632
1642: GetFileSizeExit EC1C   1615
2192: GetNextDirectoryRecord EE9A   1640 2230 2235 2693 2732 3089 3141
2210: GetNextDirectoryRecord1 EEB7   2202
1647: GetRandomRecordPosition EC1E   1589 1619
2137: GetWriteProtectValue EE64   2148 3151
3571: GoToError       F4E7   3560 3563 3566 3569 3586
0078: GREATER_THAN    003E
0061: HASH_TAG        0023   0945
3644: highestRecordNumber 007F   2868 2973
1955: Home            ED97   1828 2190
1145: IgnoreTheLine   EAA9   1012
3683: initDAMAddress  F566   1209 1321 1979 3353
1788: InitDisk        ECCA   1733
1835: InitDisk1       ED0F   1845 1863
1858: InitDisk2       ED30   1849 1854
2128: InitializeExtentNumberMSB EE5E   1252 2718 2764
0116: IOBYTE          0003   0636 0656
3305: IsAllocated     F3EA   2841 2876
3501: IsBitSet        F4A1   1724 3523 3535
3508: IsBitSet1       F4A8   3506
3503: IsBitSetLoop    F4A2   3511
2801: IsDiskWriteProtected F13E   2796 3148
1010: IsItDeleteTheLineU EA16
1007: IsItDeleteTheLineX EA11
1004: IsItPrintToggle EA0C
1094: IsItPrintToggle1 EA6D   1092
0998: IsItRubout      EA02
1001: IsPhysicalEOL   EA07
0806: IsPrintableASCII E929   0500 0836
1079: ItIsPhysicalEOL EA5A   1003
1086: ItIsPrintToggle EA62   1006
1067: ItIsRubout      EA4F   1000
1163: keyboardByte    EABB   0795 0904 0937
0064: L_PAREN         0028
2113: Left            EE4F   2115
0081: LEFT_ARROW      005F
0097: LEFT_CURLY      007B
0145: LengthInBytes   2000   0146 0150 0260
0146: LengthInK       0009
0076: LESS_THAN       003C
0057: LF              000A   0809 0890 0962 0992
1108: LL1             EA7B   1116
0031: LO_NIBBLE_MASK  000F   0783 1666
3682: loggedDisks     F564   1204 1276 1723 1729 1731
2423: LookRight       EF87   2433
3093: MakeNewFile     F2DC   1558 2766 3045
3111: MakeNewFile1    F2FE   3115
1818: Mark4Directory  ECF7   1810
3654: maxExtValue     001F   2169 3010
0148: MemorySize      0040   0150
3277: Merge           F3CF   3193 3195
3655: moduleMask      000F   3031
3483: MoveX           F497   3355 3372
3485: MoveX0          F498   3492
2518: MultiplyHLby8   EFEF   1804 2479
0261: myOffset        0001   0262 0278
3657: nameLength      000F   1868 2720 3036 3107 3109 3154
3660: NEXT_RECORD     0020   1513 1588 2078 3661
2257: NoDirRecordsMatch EEF9   2196 2208
2451: NoFreeBlocks    EFAF   2440 2448
2435: NoMoreLeft      EF99   2431
2437: NoMoreLeftLoop  EF9A   2441
2443: NoMoreRight     EFA4   2426
2445: NoMoreRightLoop EFA5   2449
2042: NoSelect        EE03   2032
0933: NothingWaiting  E9B5   0924
0053: NULL            0000
0245: NumberOfHeads   0002   0256 0258 0269 0279
0242: NumberOfLogicalDisks 0004
0030: OFF             0000
0029: ON              FFFF
1867: OpenFile        ED3A   1254 1548
2998: OpenNextExt     F254   2830 2981
3035: OpenNextExt1    F288   3020
3052: OpenNextExt2    F2A6   3022 3039
3054: OpenNextExt3    F2A9   3049
3061: OpenNextExtError F2B1   3032 3043 3048
3025: OpenNextModule  F27D   3012
1907: OpenSetRecordCount ED74   1903 1905
1172: paramDE         EAC0   0337 0382 0679 0971 1050 1105 1320 1482 1587 1604 1881 1908 2026 2044 2074 2085 2139 2187 2713 2730 2864 2911 3005 3074 3095 3098 3103 3163 3367 3421
1171: paramE          EABF   0339 0390 0775 1709 2030
0063: PERCENT         0025
0070: PERIOD          002E
0119: Pg0CurentDisk   0004
0118: Pg0CurentUser   0004   0119
0067: PLUS_SIGN       002B
0820: Print           E938   0682 0829 3618 3620
1165: printEchoFlag   EABC   0878 0917 1089
0079: QMARK           003F   2218 2715
2721: QMarkSelect     F0EC   2716
0065: R_PAREN         0029
0112: RAM             0000   0114 0115 0116 0118 0121 0124 0127 0132 0134
3661: RANDOM_REC_FIELD 0021   1484 1590 1605
1461: RandomDiskRead  EB2C   1416
1468: RandomDiskWrite EB35   1428
1478: RandomSeek      EB3E   1463 1470
1532: RandomSeekClose EB82   1522
1577: RandomSeekError EBC7   1511
1570: RandomSeekErrorBadSeek EBC0   1541 1557 1562
1564: RandomSeekExit  EBBA   1531 1551
1997: ReadBuffer      EDBF   2535 2846
2544: ReadDirectory   F002   1838 2194
2556: ReadDirectory0  F016   2551
2560: ReadDirectory1  F01D   2562
2533: ReadDirRecord   EFF9   2569
1028: ReadEchoRubOut  EA23   1076
3723: readModeFlag    F588   2819 2861 3041
0981: ReadNext        E9EA   1045 1071 1097 1119
0984: ReadNext0       E9EC   1064 1083
3681: readOnlyVector  F562   1203 1356 2006 2011 2802
2811: ReadSeq         F14C   2748
0968: ReadString      E9DD   0712 1129 1151
3551: ReAlignMap1     F4C8   3549
3546: ReAlignMapLoop  F4C2   3554
3544: ReAlignVector   F4C1   3527
2839: RecordOK        F176   2826
0254: RecordsPerBlock 0010
0238: RecordsPerExtent 0080   1906 2828 3644
0231: recordsPerSector 0004   0254 0269
3068: Rename          F2B7   2774
3080: Rename1         F2C8   3090
1100: RepeatLine      EA72   1015
2023: ReselectDisk    EDDF   1253 1415 1427 1434 1702 2704 2719 2731 2739 2747 2755 2765 2773
3533: ResetVectorBit  F4BA
0377: ReturnToCaller  E82F   0351
0393: ReturnToCaller1 E84A   0380 0386 0615
2121: Right           EE59   2119 2123
1941: RotateAndReplace ED90   1944
2492: RotateRightHLbyB EFD8   2500
2497: RotateRightHLbyB1 EFDE   2495
0082: RUBOUT          007F   0999
2343: ScanDiskMap     EF36   1861 3139
2350: ScanDiskMap0    EF40   2382
2375: ScanDiskMap2    EF57   2364
2366: ScanDiskMapWord EF51   2358
3728: searchAddress   F58D   2188 2198 2729
2182: SearchForDirectoryRecord EE85   1602 1869 2686 2722 3037 3072 3100 3129 3155
3727: searchLength    F58C   2185 2212
0283: SectorMask      0003
0248: SectorsPerBlock 0004   0252 0254 0257 0263 0283
0258: SectorsPerCylinder 0024   0261 0262
0247: SectorsPerTrack 0012   0256 0258 0269
2584: Seek            F041   2581 2845 2946
2589: Seek0           F04B   2593
3374: SeekAndCopy     F438
3246: SeekCopy        F3B1   3236
2575: SeekDir         F030   2568 3247 3375
1718: Select          EC63   1211 1714
1708: SelectCurrent   EC57   0391 1235 2040
1739: SelectDisk      EC84   1719
1782: SelectDisk1     ECC6   1778
0075: SEMICOLON       003B
3725: seqReadFlag     F58A   1480 2673 2813 2856 2976
3313: SetActualRecordAdd F3F0   2844 2945
3317: SetActualRecordAdd1 F3F6   3320
2684: SetAttributes   F0BD   1703
2687: SetAttributes1  F0C2   2694
1813: SetBitLoop      ECF2   1816
1920: SetCurrentDiskBit ED7D
1978: SetDataDMA      EDB1   1210 1322 2536 3260
1984: SetDirDMA       EDB6   2534 3257
2306: SetDirectoryEntry EF20   1862 3119
2005: SetDiskReadOnly EDC7   1698 2659
1989: SetDMA          EDB9   1980
2268: SetEndDirectory EF02   1833 2189 2258 2552
2147: SetFileWriteFlag EE6D   1582 1886 3063 3123
3343: SetLowReturnTo1 F410   2850 2870 3062
2663: SetNewCheckSum  F0A9   2652
2237: SetNextPosition EEE1   2219 2223 2231
1586: SetRandomRecord EBCF   1441
2056: SetRecordVars   EE0C   2821 2866 3055
2095: SetResetMapBit  EE38   2378
0782: SetUserNumber   E918   0777
3521: SetVectorBit    F4B1   1730 2010
2521: ShiftLeftHLbyB  EFF1   2525
3474: ShiftLeftHLbyC  F490   1925
3476: ShiftLeftHLbyC0 F491   3480
2509: ShiftRightHLbyB EFE7   2105 2513 2578
3460: ShiftRightHLbyC F483   2805
3462: ShiftRightHLbyC0 F484   3472
0959: showCRLF        E9D3   0947 1082 3613
0944: showHashCRLF    E9BD   1103 1146
0948: showHashCRLF1   E9C5   0955
0071: SLASH           002F
0054: SOH             0001
0059: SPACE           0020   0815 0857 0887 0953 1137 1147 1149
0290: STACK_SIZE      0020   3748
3748: stackBottom     F59E
1168: startingColumn  EABD   0950 0970 1126
2326: StillInDirectory EF29   2206 2307 2657
0260: SystemSectors   0011   0261
0056: TAB             0009   0811 0852
0850: TabOut          E955   0505 0527 0827 0837
0856: TabOut0         E95B   0861
2216: TestNextPosition EEC0   2242
0922: ToggleFlag1     E9A6   0920
0122: TopRAM          0007
0257: TotalNumberOfBlocks 02D0
0256: TotalNumberOfSectors 0B40   0257 0262
0134: TPA             0100
0246: TracksPerHead   0050   0256
0027: TRUE            FFFF   0918 0939 1090 1462 1776 1783 1837 1860 2024 2818 3234 3254
0080: UNDER_SCORE     005F
2671: UpdateRecordVars F0AB   2847 2980 2993
1161: usersStack      EAB9   0341 0394
2703: vCloseFile      F0D3   0421
1433: vComputeFileSize EB22   0440
0498: vConsoleIn      E8AA   0405
0526: vConsoleOut     E8BB   0406
2738: vDeleteFile     F101   0424
0603: vDirectConIO    E8CE   0410
0612: vDirectConIO1   E8D6   0606
0289: VERSION         0020   0753
2711: vFindFirst      F0D9   0422
2728: vFindNext       F0F2   0423
1336: vGetAllocAddr   EB00   0432
0726: vGetConsoleStatus E8FD   0415
1298: vGetCurrentDisk EAF0   0430
1370: vGetDiskParamBlock EB0E   0436
0635: vGetIOBYTE      E8E4   0411
1275: vGetLoginVector EAE9   0429
1355: vGetReadOnlyMap EB07   0434
0774: vGetSetUserNumber E90A   0437
0752: vGetVersion     E904   0417
0580: vListOut        E8CA   0409
2763: vMakeFile       F118   0427
1251: vOpenFile       EAE0   0420
0678: vPrintString    E8F0   0413
0565: vPunchOut       E8C6   0408
0546: vReaderIn       E8BF   0407
1414: vReadRandom     EB16   0438
2746: vReadSeq        F10A   0425
0711: vReadString     E8F9   0414
2772: vRenameFile     F121   0428
1398: vResetDrive     EB15   0442
1201: vResetSystem    EAC4   0418
1234: vSelectDisk     EADD   0419
1319: vSetDMA         EAF7   0431
1701: vSetFileAttributes EC4E   0435
0655: vSetIOBYTE      E8EB   0412
1440: vSetRandomRecord EB28   0441
0466: vSystemReset    E8A7   0404
1697: vWriteProtectDisk EC4B   0433
1426: vWriteRandom    EB1C   0439
1454: vWriteRandom0Fill EB2B   0445
2754: vWriteSeq       F111   0426
3606: waitB4boot      F515   3596 3600
0114: WarmBoot        0000   0932 1041 3591 3608
0034: WORD            0002   1172 1174
0194: WriteAllocated  0000   2877
3268: WriteBuffer     F3C7   2949 3259
0196: WriteCleanBuffer 0002   2934
3252: WriteDir        F3B7   3140 3248 3376
0195: WriteDirectory  0001
3656: writeFlagMask   0080   2149 3152
3757: Z_HighestLocation F5DE   3758
3758: Z_MemoryLeft    0021
0038: ZERO            0000
