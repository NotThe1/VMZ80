0001: E800         ;		File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;		C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800         ; 2019-03-03 Preserved the IX and IY registers for the Caller
0006: E800         ; 2019-03-02 Refactored constants and removed header files
0007: E800         ; 2019-02-29 Version 1.0
0008: E800         ; 2019-02-04 Fixed bdosStack problem
0009: E800         ; 2019-01-10	Last rev before remaking Find nearest Block
0010: E800         ; 2019-01-11 - BDOS 0.B	- Function 0-A Refactored to Z80 idiom
0011: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0012: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0013: E800         ; 2018-03-02 Refactored the CP/M Suite
0014: E800         ; 2018-02-12 fixed allocate 16 bit problem
0015: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0016: E800         ; 2014-03-14	:	Frank Martyn
0017: E800                        Include ./stdHeader.Z80
0018: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0019: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0020: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0021: E800         ; stdHeader.Z80
0022: E800         ; standard equates for use by CP/M
0023: E800
0024: E800         ; 2019-03-02 Removed any unused constants
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; Not false
0029: E800             FALSE      EQU    0000H
0030: E800             LO_NIBBLE_MASK EQU    0FH                  ; Mask used to obtain the bytes low four bits
0031: E800
0032: E800             BYTE       EQU    1                    ; Number of bytes for "byte" type
0033: E800             WORD       EQU    2                    ; Number of bytes for "word" type
0034: E800
0035: E800
0036: E800             ASCII_MASK EQU    7FH                  ; ASCII mask 7 bits
0037: E800             EndOfMessage EQU    00H
0038: E800
0039: E800             CTRL_C     EQU    03H                  ; ETX
0040: E800             CTRL_E     EQU    05H                  ; Physical EOL
0041: E800             CTRL_H     EQU    08H                  ; Backspace
0042: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0043: E800             CTRL_P     EQU    10H                  ; Print toggle
0044: E800             CTRL_R     EQU    12H                  ; Repeat line
0045: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0046: E800             CTRL_U     EQU    15H                  ; Line delete
0047: E800             CTRL_X     EQU    18H                  ; Logical line delete
0048: E800             CTRL_Z     EQU    1AH                  ; End of file
0049: E800
0050: E800             TAB        EQU    09H                  ; Tab
0051: E800             LF         EQU    0AH                  ; Line Feed
0052: E800             CR         EQU    0DH                  ; Carriage Return
0053: E800             SPACE      EQU    20H                  ; Space
0054: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0055: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0056: E800             PERCENT    EQU    25H                  ; Percent Sign
0057: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0058: E800             PERIOD     EQU    2EH                  ; Period
0059: E800             ASCII_ZERO EQU    30H                  ; zero
0060: E800             COLON      EQU    3AH                  ; Colon
0061: E800
0062: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0063: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0064: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0065: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0066: E800             QMARK      EQU    3FH                  ; Question Mark
0067: E800             UNDER_SCORE EQU    5FH                  ; under score _
0068: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0069: E800             RUBOUT     EQU    7FH                  ; Delete Key
0070: E800
0071: E800
0072: E800             ASCII_A    EQU    'A'
0073: E800             ASCII_C    EQU    'C'
0074: E800             ASCII_M    EQU    'M'
0075: E800             ASCII_O    EQU    'O'
0076: E800             ASCII_Y    EQU    'Y'
0077: E800             CARET      EQU    '^'
0078: E800
0079: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0080: E800                        Include ./osHeader.Z80
0081: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0082: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0083: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0084: E800         ; osHeader.Z80
0085: E800
0086: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0087: E800         ; 2017-03-02 Refactored the CP/M Suite
0088: E800
0089: E800         ; Contains the Equates used by the CP/M system
0090: E800
0091: E800         ;------------------------Page Zero Constants ---------------------------------
0092: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0093: E800
0094: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0095: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0096: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0097: E800
0098: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0099: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0100: E800
0101: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0102: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0103: E800
0104: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0105: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0106: E800
0107: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0108: E800             ComTailCount EQU    ComTail              ; Count of the number of char in tail
0109: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0110: E800         ;-----------------------------------------------------------------------
0111: E800
0112: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0113: E800         ;-----------------------------------------------------------------------
0114: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0115: E800         ;-----------------------------------------------------------------------
0116: E800             END_OF_FILE EQU    1AH                  ; end of file
0117: E800         ;-----------------------------------------------------------------------
0118: E800
0119: E800         ;--------------- CP/M Constants -----------------------------------------
0120: E800
0121: E800             CCPLength  EQU    0800H                ; Constant
0122: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0123: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0124: E800
0125: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0126: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0127: E800
0128: E800             MemorySize EQU    64
0129: E800
0130: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0131: E800
0132: E800             BDOSBase   EQU    CCPEntry + CCPLength
0133: E800             BDOSEntry  EQU    BDOSBase
0134: E800
0135: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0136: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0137: E800         ;-----------------------------------------------------------------------
0138: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0139: E800                        Include ./diskHeader.Z80
0140: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0141: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0142: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0143: E800         ; diskHeader.asm
0144: E800
0145: E800         ; 2017-03-02 Refactored the CP/M Suite
0146: E800
0147: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0148: E800
0149: E800         ; Contains the Equates used by the CP/M system to handle disks
0150: E800
0151: E800
0152: E800         ;*******************************************************************************
0153: E800         ;
0154: E800         ;     Disk related values
0155: E800         ;
0156: E800         ;
0157: E800         ;*******************************************************************************
0158: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0159: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0160: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0161: E800         ; for boot
0162: E800             DiskControlTable EQU    0040H
0163: E800
0164: E800             DiskReadCode EQU    01H                  ; Code for Read
0165: E800             DiskWriteCode EQU    02H                  ; Code for Write
0166: E800
0167: E800
0168: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0169: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0170: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0171: E800
0172: E800             DirEntrySize EQU    20H                  ; (32)
0173: E800             DirBuffSize EQU    cpmRecordSize
0174: E800
0175: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0176: E800
0177: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0178: E800
0179: E800
0180: E800         ;-------------------------------------------------------------------------------------
0181: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0182: E800
0183: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0184: E800             NumberOfHeads EQU    02H                  ; number of heads
0185: E800             TracksPerHead EQU    50H                  ; 80
0186: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0187: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0188: E800             DirectoryBlockCount EQU    02H                  ;
0189: E800         ;-----------------------------------------------------------------------
0190: E800
0191: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0192: E800
0193: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0194: E800
0195: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0196: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0197: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0198: E800
0199: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0200: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0201: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0202: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0203: E800
0204: E800         ;-----------------------------------------------------------------------
0205: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0206: E800         ;-----------------------------------------------------------------------
0207: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0208: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0209: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0210: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0211: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0212: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0213: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0214: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0215: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0216: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0217: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0218: E800             dpb3hdNOH  EQU    NumberOfHeads
0219: E800
0220: E800         ;*******************************************************************************
0221: E800
0222: E800             SectorMask EQU    SectorsPerBlock - 1
0223: E800
0224: E800         ;***************************************************************************
0225: E800
0226: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0227: E800             VERSION    EQU    20H                  ; Version 2.0
0228: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0229: E800             EOD        EQU    -1                   ; End of Directory
0230: E800         ;*******************************************************************************
0231: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0232: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0233: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0234: E800         ; sector write) or to an allocation block that has already been allocated to a
0235: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0236: E800         ;*******************************************************************************
0237: E800             WriteAllocated EQU    00H
0238: E800             WriteDirectory EQU    01H
0239: E800             WriteCleanBuffer EQU    02H
0240: E800         ;************************ BIOS Function Constants **************************;
0241: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function				;
0242: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function				;
0243: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function			;
0244: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function			;
0245: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function			;
0246: E800             bcList     EQU    BIOSStart+3*5        ; List Output function				;
0247: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function				;
0248: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function				;
0249: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function				;
0250: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function				;
0251: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function				;
0252: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function				;
0253: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function					;
0254: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function				;
0255: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function				;
0256: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function				;
0257: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate					;
0258: E800         ;************************ BIOS Function Constants **************************;
0259: E800         ;===========================================================================;
0260: E800         ;	BDOS																	;
0261: E800         ; Calling into	:															;
0262: E800         ;					Register	C - Contains BDOS Function Code				;
0263: E800         ;					Register	A - Holds the Byte argument if any			;
0264: E800         ;					Register DE - Holds the Word argument if any			;
0265: E800         ; Returning from :															;
0266: E800         ;					Register	A - The Byte return value if any			;
0267: E800         ;					Register HL - The Word return value if any				;
0268: E800         ;					( Register A=L and B=H)									;
0269: E800         ;===========================================================================;
0270: E800                        ORG    BDOSBase
0271: E800         ;===========================BDOS Entry======================================;
0272: E800         ;BDOSEntry:																	;
0273: E800         ;
0274: E800         ;
0275: E800             BdosStart:                      ;
0276: E800         ;	LD		A,C																;
0277: E800         ; 	LD		(FunctionValue),A			; Save the function number			;
0278: E800         ;
0279: E800         ; Save Calling Arguments													;
0280: E800 ED 53 BF EA               LD     (paramDE),DE         ; Save the Word Argument			;
0281: E804 7B                     LD     A,E                  ;
0282: E805 32 BE EA               LD     (paramE),A           ; Save the Byte argument			;
0283: E808         ; Save users Stack pointer													;
0284: E808 ED 73 B8 EA               LD     (usersStack),SP      ; Save the User's stack					;
0285: E80C 31 12 F5               LD     SP,bdosStack         ; We will use our own stack			;
0286: E80F DD E5                  PUSH   IX                   ; Save users IX register			;
0287: E811 FD E5                  PUSH   IY                   ; Save users IY register			;
0288: E813         ;
0289: E813         ; initialize variables														;
0290: E813 21 00 00               LD     HL,0000H             ;
0291: E816 22 C1 EA               LD     (exitParameterWord),HL ; Assume all is well for return		;
0292: E819 AF                     XOR    A                    ;
0293: E81A 32 C6 F4               LD     (fcbDisk),A          ; Initialize to 00					;
0294: E81D 32 C4 F4               LD     (fResel),A           ; Clear re selection flag			;
0295: E820         ;
0296: E820         ; Set up for return to caller when Function Completes						;
0297: E820 21 36 E8               LD     HL,ReturnToCaller    ;
0298: E823 E5                     PUSH   HL                   ;Set up to ReturnToCaller			;
0299: E824         ;
0300: E824         ; is it a valid function number ?											;
0301: E824         ;	LD		A,(FunctionValue)			; Get the Function Number			;
0302: E824 79                     LD     A,C                  ;
0303: E825 FE 28                  CP     functionCount        ; make sure its a good number		;
0304: E827 D0                     RET    NC                   ; exit if not a valid function		;
0305: E828         ;
0306: E828         ; Calculate the index and get vector to go to								;
0307: E828 4B                     LD     C,E                  ; Assume byte argument				;
0308: E829 21 5F E8               LD     HL,functionTable     ; Get table base					;
0309: E82C 5F                     LD     E,A                  ; Function number in E				;
0310: E82D 16 00                  LD     D,0                  ;
0311: E82F 19                     ADD    HL,DE                ; Have byte location				;
0312: E830 19                     ADD    HL,DE                ;	but we want a Word offset		;
0313: E831 5E                     LD     E,(HL)               ; Get LSB of vector					;
0314: E832 23                     INC    HL                   ;
0315: E833 56                     LD     D,(HL)               ; Get MSB of vector					;
0316: E834 EB                     EX     DE,HL                ; Vector now in HL					;
0317: E835         ;
0318: E835         ; Vector to Function is in HL												;
0319: E835 E9                     JP     (HL)                 ; Put it into the Program Counter	;
0320: E836         ;===========================BDOS Entry======================================;
0321: E836         ;===========================BDOS Exit ======================================;
0322: E836         ;arrive here at end of processing to return to user							;
0323: E836             ReturnToCaller:                      ;
0324: E836 3A C4 F4               LD     A,(fResel)           ; get re-selection flag				;
0325: E839 B7                     OR     A                    ; is it set?						;
0326: E83A 28 15                  JR     Z,ReturnToCaller1    ;
0327: E83C         ;re-selection	may have taken place										;
0328: E83C 2A BF EA               LD     HL,(paramDE)         ;
0329: E83F 36 00                  LD     (HL),0               ;
0330: E841 3A C6 F4               LD     A,(fcbDisk)          ;
0331: E844 B7                     OR     A                    ; Disk = 0?							;
0332: E845 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes						;
0333: E847         ;
0334: E847 77                     LD     (HL),A               ;
0335: E848 3A C5 F4               LD     A,(entryDisk)        ; get back original Disk			;
0336: E84B 32 BE EA               LD     (paramE),A           ; and select it						;
0337: E84E CD 1D ED               CALL   SelectCurrent        ;
0338: E851         ;
0339: E851             ReturnToCaller1:
0340: E851 FD E1                  POP    IY                   ; Restore IY
0341: E853 DD E1                  POP    IX                   ; Restore IX
0342: E855 2A B8 EA               LD     HL,(usersStack)      ;
0343: E858 F9                     LD     SP,HL                ; restore callers stack				;
0344: E859 2A C1 EA               LD     HL,(exitParameterWord) ;
0345: E85C 7D                     LD     A,L                  ;
0346: E85D 44                     LD     B,H                  ; BA = exitParameterWord			;
0347: E85E C9                     RET                         ;
0348: E85F         ;===========================BDOS Exit ======================================;
0349: E85F         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++;
0350: E85F             functionTable:                      ;
0351: E85F B2 E8                  DW     vSystemReset         ;	0 - System Reset				;
0352: E861 B5 E8                  DW     vConsoleIn           ;	1 - Console Input				;
0353: E863 C9 E8                  DW     vConsoleOut          ;	2 - Console Output				;
0354: E865 CD E8                  DW     vReaderIn            ;	3 - Reader Input				;
0355: E867 D4 E8                  DW     vPunchOut            ;	4 - Punch Output				;
0356: E869 D8 E8                  DW     vListOut             ;	5 - List Output					;
0357: E86B DC E8                  DW     vDirectConIO         ;	6 - Direct Console I/O			;
0358: E86D F2 E8                  DW     vGetIOBYTE           ;	7 - Get I/O Byte				;
0359: E86F F9 E8                  DW     vSetIOBYTE           ;	8 - Set I/O Byte				;
0360: E871 FE E8                  DW     vPrintString         ;	9 - Print String				;
0361: E873 07 E9                  DW     vReadString          ;	A - Read Console String			;
0362: E875 0B E9                  DW     vGetConsoleStatus    ;	B - Get Console Status			;
0363: E877             diskf      EQU    ($-functionTable)/2  ; disk functions					;
0364: E877 12 E9                  DW     vGetVersion          ;	C - Return Version Number		;
0365: E879 C3 EA                  DW     vResetSystem         ;	D - Reset Disk System			;
0366: E87B DC EA                  DW     vSelectDisk          ;	E - Select Disk					;
0367: E87D DF EA                  DW     vOpenFile            ;	F - Open File					;
0368: E87F E8 EA                  DW     vCloseFile           ;	10 - Close File					;
0369: E881 EE EA                  DW     vFindFirst           ;	11 - Search For First			;
0370: E883 06 EB                  DW     vFindNext            ;	12 - Search for Next			;
0371: E885 15 EB                  DW     vDeleteFile          ;	13 - Delete File				;
0372: E887 3C EB                  DW     vReadSeq             ;	14 - Read Sequential			;
0373: E889 7F EB                  DW     vWriteSeq            ;	15 - Write Sequential			;
0374: E88B 37 EC                  DW     vMakeFile            ;	16 - Make File					;
0375: E88D 40 EC                  DW     vRenameFile          ;	17 - Rename File				;
0376: E88F 69 EC                  DW     vGetLoginVector      ;	18 - Return Login Vector		;
0377: E891 70 EC                  DW     vGetCurrentDisk      ;	19 - Return Current Disk		;
0378: E893 77 EC                  DW     vSetDMA              ;	1A - Set DMA address			;
0379: E895 80 EC                  DW     vGetAllocAddr        ;	1B - Get ADDR (ALLOC)			;
0380: E897 87 EC                  DW     vWriteProtectDisk    ;	1C - Write Protect Disk			;
0381: E899 8A EC                  DW     vGetReadOnlyMap      ;	1D - Get Read/Only MAP			;
0382: E89B 91 EC                  DW     vSetFileAttributes   ;	1E - Set File Attributes ??		;
0383: E89D AB EC                  DW     vGetDiskParamBlock   ;	1F - Get ADDR (Disk Parameters)	;
0384: E89F 18 E9                  DW     vGetSetUserNumber    ;	20 - Set/Get User Code			;
0385: E8A1 B2 EC                  DW     vReadRandom          ;	21 - Read Random				;
0386: E8A3 BE EC                  DW     vWriteRandom         ;	22 - Write Random				;
0387: E8A5 CA EC                  DW     vComputeFileSize     ;	23 - Compute File Size			;
0388: E8A7 06 ED                  DW     vSetRandomRecord     ;	24 - Set Random Record			;
0389: E8A9 19 ED                  DW     vResetDrive          ;	25 - Reset Drive				;
0390: E8AB B1 E8                  DW     DUMMY                ;	26 - Access Drive (not supported);
0391: E8AD B1 E8                  DW     DUMMY                ;	27 - Free Drive (not supported)	;
0392: E8AF 1C ED                  DW     vWriteRandom0Fill    ;	28 - Write random w/Fill		;
0393: E8B1             functionCount EQU    ($-functionTable)/2  ; Number of	functions				;
0394: E8B1         ;
0395: E8B1             DUMMY:                          ;
0396: E8B1 76                     HALT                        ;
0397: E8B2         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++;
0398: E8B2         ;-------------------------- System Reset - 0 (0) ---------------------------;
0399: E8B2         ;	The system reset function makes CP/M do a complete reset, exactly the	;
0400: E8B2         ; same as the warm boot function invoked when you transfer control to the	;
0401: E8B2         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads	;
0402: E8B2         ; the CCP, rebuilds the allocation vectors for the currently logged disks,	;
0403: E8B2         ; sets the DMA address (used byCP/M to address the disk read/write buffer)	;
0404: E8B2         ; to 80H, marks all disks as being Read/Write status, and transfers control	;
0405: E8B2         ; to the	CCP. The CCP then outputs its prompt to the console.			;
0406: E8B2         ;																			;
0407: E8B2         ;			Function Code	:	C = 00H										;
0408: E8B2         ;			Entry Parameters:	None										;
0409: E8B2         ;			Exit Parameters :	Does Not Return								;
0410: E8B2         ;																			;
0411: E8B2         ;-------------------------- System Reset - 0 (0) ---------------------------;
0412: E8B2             vSystemReset:
0413: E8B2 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0414: E8B5         ;***************************************************************************;
0415: E8B5         ;								IOByte device I/O							;
0416: E8B5         ;***************************************************************************;
0417: E8B5         ;-------------------------- Read Console Byte - 1 (1) ----------------------;
0418: E8B5         ;	This function reads the next byte of data from the console keyboard and	;
0419: E8B5         ; puts it into register A. If the character input is a graphic character, it;
0420: E8B5         ; will be echoed back to the console. The only control characters that are	;
0421: E8B5         ; echoed are	CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case	;
0422: E8B5         ; of a TAB character, the BDOS outputs as many spaces as are required to	;
0423: E8B5         ; move the cursor to the next multiple of eight columns. All of the other	;
0424: E8B5         ; control characters, including CONTROL-C, are input but are not echoed.	;
0425: E8B5         ;	This function also checks for CONTROL-S (XOFF) to see if console output	;
0426: E8B5         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if	;
0427: E8B5         ; console output should also be sent to the list device. If CONTROL-S is	;
0428: E8B5         ; found, further output will be suspended until you type another character. ;
0429: E8B5         ; CONTROL-P will enable the echoing of console output the first time it is	;
0430: E8B5         ; pressed and disable it the second time. If there is no incoming data		;
0431: E8B5         ; character, this function will wait until there is one.					;
0432: E8B5         ;																			;
0433: E8B5         ; This is a blocking function												;
0434: E8B5         ;																			;
0435: E8B5         ;																			;
0436: E8B5         ;			Function Code	:	C = 01H										;
0437: E8B5         ;			Entry Parameters:	None										;
0438: E8B5         ;			Exit Parameters :	A = Data byte from console					;
0439: E8B5         ;																			;
0440: E8B5         ;-------------------------- Read Console Byte - 1 (1) ----------------------;
0441: E8B5             vConsoleIn:
0442: E8B5 CD 2C E9               CALL   ConIn                ; Don't come back without input
0443: E8B8 CD 37 E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0444: E8BB 32 C1 EA               LD     (exitParameterByte),A
0445: E8BE D8                     RET    C                    ; return nothing to echo
0446: E8BF F5                     PUSH   AF                   ; Save printable character
0447: E8C0 4F                     LD     C,A
0448: E8C1 CD 63 E9               CALL   TabOut               ; Send to console. if TAB expand
0449: E8C4 F1                     POP    AF                   ; retrieve exit value
0450: E8C5 32 C1 EA               LD     (exitParameterByte),A
0451: E8C8 C9                     RET
0452: E8C9         ;------------------------- Write Console Byte - 2 (2) ----------------------;
0453: E8C9         ;	This function outputs the data byte in register E to the console. As	;
0454: E8C9         ; with function 1, if the data byte is a TAB character, it will be expanded	;
0455: E8C9         ; by the BDOS to the next column that is a multiple of eight. The BDOS also	;
0456: E8C9         ; checks to see if there is an incoming character, and if there is,			;
0457: E8C9         ; checks to see if it is a CONTROL-S ,in which case console output is		;
0458: E8C9         ; suspended or CONTROL-P, in which case echoing of console output to the	;
0459: E8C9         ; printer is	toggled on or off											;
0460: E8C9         ;																			;
0461: E8C9         ;			Function Code	:	C = 02H										;
0462: E8C9         ;			Entry Parameters:	E = Data byte to be output					;
0463: E8C9         ;			Exit Parameters :	None										;
0464: E8C9         ;																			;
0465: E8C9         ;------------------------- Write Console Byte - 2 (2) ----------------------;
0466: E8C9         ;BDOS put parameter in C before entering this routine
0467: E8C9             vConsoleOut:
0468: E8C9 CD 63 E9               CALL   TabOut
0469: E8CC C9                     RET
0470: E8CD         ;--------------------------- Read Reader Byte - 3 (3) ----------------------;
0471: E8CD         ;	function reads the next character from the logical "reader" device into ;
0472: E8CD         ; register A. In practice, the physical device that is accessed depends		;
0473: E8CD         ; entirely on how your BIOS is configured. In some systems, there is no		;
0474: E8CD         ; reader at all; this function will return some arbitrary value such as lAH ;
0475: E8CD         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').	;
0476: E8CD         ; Control is not returned to the calling program until a character has been ;
0477: E8CD         ; read.																		;
0478: E8CD         ;																			;
0479: E8CD         ; This is a blocking function												;
0480: E8CD         ;																			;
0481: E8CD         ;			Function Code	:	C = 03H										;
0482: E8CD         ;			Entry Parameters:	None										;
0483: E8CD         ;			Exit Parameters :	A = Character Input							;
0484: E8CD         ;																			;
0485: E8CD         ;--------------------------- Read Reader Byte - 3 (3) ----------------------;
0486: E8CD             vReaderIn:
0487: E8CD CD 15 F6               CALL   bcReader
0488: E8D0 32 C1 EA               LD     (exitParameterWord),A
0489: E8D3 C9                     RET
0490: E8D4         ;--------------------------- Write Punch Byte - 4 (4) ----------------------;
0491: E8D4         ;	This function is a counterpart to the Read "Reader" Byte It outputs the	;
0492: E8D4         ; specified character from register E to the logical punch device. Again,	;
0493: E8D4         ; the actual physical device used, if any, is determined by the BIOS.		;
0494: E8D4         ; There is no set standard for this device; in some systems the punch		;
0495: E8D4         ; device is a "bit bucket," so called because it absorbs all data that you	;
0496: E8D4         ; output to it.																;
0497: E8D4         ;																			;
0498: E8D4         ;			Function Code	:	C = 04H										;
0499: E8D4         ;			Entry Parameters:	E = Data byte to be output					;
0500: E8D4         ;			Exit Parameters :	None										;
0501: E8D4         ;																			;
0502: E8D4         ;--------------------------- Write Punch Byte - 4 (4) ----------------------;
0503: E8D4         ;BDOS put parameter in C before entering this routine
0504: E8D4             vPunchOut:
0505: E8D4 CD 12 F6               CALL   bcPunch
0506: E8D7 C9                     RET
0507: E8D8         ;---------------------------- Write List Byte - 5 (5) ----------------------;
0508: E8D8         ;	This function outputs the specified byte in register E to the logical	;
0509: E8D8         ; list device. As with the reader and the punch, the physical device used	;
0510: E8D8         ; depends entirely on the BIOS.												;
0511: E8D8         ;																			;
0512: E8D8         ;			Function Code	:	C = 05H										;
0513: E8D8         ;			Entry Parameters:	E = Data byte to be output					;
0514: E8D8         ;			Exit Parameters :	None										;
0515: E8D8         ;																			;
0516: E8D8         ;---------------------------- Write List Byte - 5 (5) ----------------------;
0517: E8D8         ;BDOS put parameter in C before entering this routine
0518: E8D8             vListOut:                       ; func5 (05 - 05) List Output
0519: E8D8 CD 0F F6               CALL   bcList               ; direct call to BIOS
0520: E8DB C9                     RET
0521: E8DC         ;--------------------------- Direct Console I/O - 6 (6) --------------------;
0522: E8DC         ;	This function serves double duty: it both inputs and outputs characters	;
0523: E8DC         ; from the console. However, it bypasses the normal control characters and	;
0524: E8DC         ; line editing features (such as CONTROL-P and CONTROL-S) normally			;
0525: E8DC         ; associated with console I( O. Hence the name "direct" (or "unadorned" as	;
0526: E8DC         ; Digital Research describes it). If the value in register E is not OFFH,	;
0527: E8DC         ; then E contains a valid ASCII character that is output to the console.	;
0528: E8DC         ;	This function works well provided you never have to send a value ofOFFH	;
0529: E8DC         ; or expect to receive a value ofOOH. If you do need to send or receive		;
0530: E8DC         ;	pure binary data, you cannot use this function, since these values are	;
0531: E8DC         ;	likely to be part of the data stream.									;
0532: E8DC         ;																			;
0533: E8DC         ;			Function Code	:	C = 06H										;
0534: E8DC         ;			Entry Parameters:	E = 0FFH for Input							;
0535: E8DC         ;								E = Other than 0FFH for Output				;
0536: E8DC         ;			Exit Parameters :	A = Input byte or status					;
0537: E8DC         ;																			;
0538: E8DC         ;--------------------------- Direct Console I/O - 6 (6) --------------------;
0539: E8DC         ;BDOS put parameter in C before entering this routine
0540: E8DC             vDirectConIO:
0541: E8DC 79                     LD     A,C
0542: E8DD 3C                     INC    A
0543: E8DE 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0544: E8E0         ; send byte to console
0545: E8E0 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0546: E8E3 C9                     RET
0547: E8E4         ;read byte/status from console
0548: E8E4             vDirectConIO1:
0549: E8E4 CD 06 F6               CALL   bcConst              ; Check Status
0550: E8E7 B7                     OR     A                    ; 00 means not data ready
0551: E8E8 CA 51 E8               JP     Z,ReturnToCaller1    ; If no data return	00 to caller
0552: E8EB CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0553: E8EE 32 C1 EA               LD     (exitParameterByte),A ; Save it
0554: E8F1 C9                     RET
0555: E8F2         ;--------------------------- Get IOBYTE Setting - 7 (7) --------------------;
0556: E8F2         ; This function places the current value of the IOBYTE in register A.		;
0557: E8F2         ;																			;
0558: E8F2         ; The IOBYTE structure:														;
0559: E8F2         ;								+-------+-------+-------+-------+			;
0560: E8F2         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |			;
0561: E8F2         ;								+-------+-------+-------+-------+			;
0562: E8F2         ;				Logical Device	List | Punch | Reader|Console				;
0563: E8F2         ;																			;
0564: E8F2         ;																			;
0565: E8F2         ;			Function Code	:	C = 07H										;
0566: E8F2         ;			Entry Parameters:	None										;
0567: E8F2         ;			Exit Parameters :	A = Current IOBYTE value					;
0568: E8F2         ;																			;
0569: E8F2         ;--------------------------- Get IOBYTE Setting - 7 (7) --------------------;
0570: E8F2             vGetIOBYTE:
0571: E8F2 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0572: E8F5 32 C1 EA               LD     (exitParameterWord),A ; Return it to caller
0573: E8F8 C9                     RET
0574: E8F9         ;--------------------------- Set IOBYTE Setting - 8 (8) --------------------;
0575: E8F9         ; This function sets the IOBYTE												;
0576: E8F9         ;																			;
0577: E8F9         ; The IOBYTE structure:														;
0578: E8F9         ;								+-------+-------+-------+-------+			;
0579: E8F9         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |			;
0580: E8F9         ;								+-------+-------+-------+-------+			;
0581: E8F9         ;				Logical Device	List | Punch | Reader|Console				;
0582: E8F9         ;																			;
0583: E8F9         ;																			;
0584: E8F9         ;			Function Code	:	C = 08H										;
0585: E8F9         ;			Entry Parameters:	E = New IOBYTE value						;
0586: E8F9         ;			Exit Parameters :	None										;
0587: E8F9         ;																			;
0588: E8F9         ;--------------------------- Get IOBYTE Setting - 8 (8) --------------------;
0589: E8F9         ;BDOS put parameter in C before entering this routine
0590: E8F9             vSetIOBYTE:
0591: E8F9 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0592: E8FC 71                     LD     (HL),C               ; Place new vale in it
0593: E8FD C9                     RET
0594: E8FE         ;---------------------- Display $ terminated String - 9 (9) ----------------;
0595: E8FE         ;	This function outputs a string of characters to the console device. The	;
0596: E8FE         ; address of this string is in registers DE. You must make sure that the	;
0597: E8FE         ; last character of the string is "$"; the BDOS uses this character as a	;
0598: E8FE         ; marker for the end of the string. The "$" itself does not get output to	;
0599: E8FE         ; the console.																;
0600: E8FE         ;																			;
0601: E8FE         ; While the BDOS is outputting the string, it expands tabs as previously	;
0602: E8FE         ; described, checks to see if there is an incoming character, and checks	;
0603: E8FE         ; for	CONTROL-S (XOFF, which stops the output until another character is	;
0604: E8FE         ; entered) or CONTROL-P (which turns on or off echoing of console characters;
0605: E8FE         ; to	the printer).														;
0606: E8FE         ;																			;
0607: E8FE         ;			Function Code	:	C = 09H										;
0608: E8FE         ;			Entry Parameters:	DE = Address of the first byte of the string;
0609: E8FE         ;			Exit Parameters :	None										;
0610: E8FE         ;																			;
0611: E8FE         ;---------------------- Display $ terminated String - 9 (9) ----------------;
0612: E8FE             vPrintString:
0613: E8FE 2A BF EA               LD     HL,(paramDE)         ; Get address of the string
0614: E901 4D                     LD     C,L
0615: E902 44                     LD     B,H                  ; Put it into BC for call
0616: E903 CD 46 E9               CALL   Print                ; out to console
0617: E906 C9                     RET
0618: E907         ;-------------------------- Read Console String - A (10) -------------------;
0619: E907         ;	This function reads a string of characters from the console device		;
0620: E907         ; and stores them in a buffer (address in DE) that you define. Full line	;
0621: E907         ; editing is possible: the operator can backspace, cancel the line and		;
0622: E907         ; start over, and use all the normal control functions. What you will		;
0623: E907         ; ultimately see in the buffer is the final version of the character string ;
0624: E907         ; entered, without any of the errors or control characters used to do the	;
0625: E907         ; line editing;																;
0626: E907         ;																			;
0627: E907         ;	The buffer that you define has a special format. The first byte in the	;
0628: E907         ; buffer tells the BDOS the maximum number of characters to be accepted.	;
0629: E907         ; The second byte is reserved for the BDOS to tell you how many characters	;
0630: E907         ; were actually placed in the buffer. The following bytes contain			;
0631: E907         ; the characters of the string. Character input will cease either when a	;
0632: E907         ; CARRIAGE RETURN is entered or when the maximum number of characters,		;
0633: E907         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not ;
0634: E907         ; stored in the buffer as a character-it just serves as a terminator. If	;
0635: E907         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets		;
0636: E907         ; the "characters input" byte to O. If you attempt to input more than the	;
0637: E907         ; maximum number of characters, the "characters input" count will be the	;
0638: E907         ; same as the maximum value allowed.										;
0639: E907         ;																			;
0640: E907         ;			Function Code	:	C = 0AH										;
0641: E907         ;			Entry Parameters:	DE = Address string buffer					;
0642: E907         ;			Exit Parameters :	String Buffer with console bytes in it		;
0643: E907         ;																			;
0644: E907         ;-------------------------- Read Console String - A (10) -------------------;
0645: E907             vReadString:
0646: E907 CD EB E9               CALL   ReadString
0647: E90A C9                     RET
0648: E90B         ;------------------------- Read Console Status - B (11) --------------------;
0649: E90B         ; This function tells you whether a console input character is waiting to	;
0650: E90B         ; be processed. Unlike the Console Input functions, which will wait until	;
0651: E90B         ; there is input,this function simply checks and returns immediately.		;
0652: E90B         ;																			;
0653: E90B         ;			Function Code	:	C = 0BH										;
0654: E90B         ;			Entry Parameters:	None										;
0655: E90B         ;			Exit Parameters :	A = 00H if no incoming Data					;
0656: E90B         ;								A = FFH	if incoming Data					;
0657: E90B         ;																			;
0658: E90B         ;------------------------- Read Console Status - B (11) --------------------;
0659: E90B             vGetConsoleStatus:
0660: E90B CD 97 E9               CALL   ConBreak
0661: E90E 32 C1 EA               LD     (exitParameterByte),A
0662: E911 C9                     RET
0663: E912         ;--------------------------- Get CP/M Version - C (12) ---------------------;
0664: E912         ;	This function tells you which version of CP/M you are currently running.;
0665: E912         ; A two-byte value is returned:												;
0666: E912         ;	H = OOH for CP/M, H = OlH for MP/M										;
0667: E912         ;	L = OOH for all releases before CP/M 2.0								;
0668: E912         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,							;
0669: E912         ;		and so on for any subsequent releases.								;
0670: E912         ;																			;
0671: E912         ; This information is of interest only if your program has some version		;
0672: E912         ; specific logic built into it. For example, CP/M version 1.4 does not		;
0673: E912         ; support the same Random File Input/ Output operations that CP/M 2.2 does.	;
0674: E912         ; Therefore, if your program uses Random I/O, put this check at the			;
0675: E912         ; beginning to ensure that it is indeed running under the appropriate		;
0676: E912         ; version of CP/M.															;
0677: E912         ;																			;
0678: E912         ;			Function Code	:	C = 0CH										;
0679: E912         ;			Entry Parameters:	None										;
0680: E912         ;			Exit Parameters :	HL =Version Number Code						;
0681: E912         ;								A = FFH	if incoming Data					;
0682: E912         ;																			;
0683: E912         ;--------------------------- Get CP/M Version - C (12) ---------------------;
0684: E912             vGetVersion:                      ; func12 (12 - 0C)	Get Version
0685: E912 3E 20                  LD     A,VERSION
0686: E914 32 C1 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0687: E917 C9                     RET
0688: E918         ;--------------------------- Get/Set User Number - 20 (32) -----------------;
0689: E918         ;	This subroutine either sets or gets the current user number. The current;
0690: E918         ; user number determines which file directory entries are matched during all;
0691: E918         ; disk file operations. When you call this function, the contents of the	;
0692: E918         ; E register specify what action is to be taken. IfE=OFFH, then the function;
0693: E918         ; will return the current user number in the A register. If you set E to a	;
0694: E918         ; number in the range 0 to 15 (that is, a valid user number), the function	;
0695: E918         ; will set the current user number to this value.							;
0696: E918         ;																			;
0697: E918         ;			Function Code	:	C = 0CH										;
0698: E918         ;			Entry Parameters:	E = 0FFH to get User Number					;
0699: E918         ;									= 0 to 15 to set User Number			;
0700: E918         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH;
0701: E918         ;								A = FFH	if incoming Data					;
0702: E918         ;																			;
0703: E918         ;																			;
0704: E918         ;--------------------------- Get/Set User Number - 20 (32) -----------------;
0705: E918             vGetSetUserNumber:
0706: E918 3A BE EA               LD     A,(paramE)
0707: E91B FE FF                  CP     0FFH
0708: E91D 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0709: E91F 3A 93 F4               LD     A,(currentUserNumber)
0710: E922 32 C1 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0711: E925 C9                     RET
0712: E926             SetUserNumber:
0713: E926 E6 0F                  AND    LO_NIBBLE_MASK
0714: E928 32 93 F4               LD     (currentUserNumber),A
0715: E92B C9                     RET
0716: E92C         ;***************************************************************************;
0717: E92C         ;								Character Support Routines					;
0718: E92C         ;***************************************************************************;
0719: E92C         ;-------------------- Return a Character from the console ------------------;
0720: E92C         ;return byte from buffer or read from the console							;
0721: E92C             ConIn:                          ;
0722: E92C 21 BA EA               LD     HL,keyboardByte      ; is there a Byte waiting?			;
0723: E92F 7E                     LD     A,(HL)               ;
0724: E930 36 00                  LD     (HL),0               ;
0725: E932 B7                     OR     A                    ;
0726: E933 C0                     RET    NZ                   ;
0727: E934         ;
0728: E934 C3 09 F6               JP     bcConin              ; Go get byte from Console			;
0729: E937         ;-------------------- Return a Character from the console ------------------;
0730: E937         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ---------;
0731: E937         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE	;
0732: E937             IsPrintableASCII:                      ;
0733: E937 FE 0D                  CP     CR                   ;
0734: E939 C8                     RET    Z                    ; carriage return?													;
0735: E93A FE 0A                  CP     LF                   ;
0736: E93C C8                     RET    Z                    ; line feed?														;
0737: E93D FE 09                  CP     TAB                  ;
0738: E93F C8                     RET    Z                    ; TAB?																;
0739: E940 FE 08                  CP     CTRL_H               ;
0740: E942 C8                     RET    Z                    ; backspace?														;
0741: E943 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable		;
0742: E945 C9                     RET                         ;
0743: E946         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ---------;
0744: E946         ;------------------ Print character from (BC) until	$ found ----------------;
0745: E946             Print:                          ;
0746: E946 0A                     LD     A,(BC)               ; Get the next character			;
0747: E947 FE 24                  CP     DOLLAR               ; Is it the end ?					;
0748: E949 C8                     RET    Z                    ;	exit if yes						;
0749: E94A 03                     INC    BC                   ; Update the pointer				;
0750: E94B C5                     PUSH   BC                   ; Save it							;
0751: E94C 4F                     LD     C,A                  ; Does Byte require					;
0752: E94D CD 63 E9               CALL   TabOut               ;	special attention - check		;
0753: E950 C1                     POP    BC                   ; Retrieve the pointer				;
0754: E951 18 F3                  JR     Print                ; Loop back							;
0755: E953         ;------------------ Print character from (BC) until	$ found ----------------;
0756: E953         ;-- Send printable character to console. Precede with Caret if needed ------;
0757: E953         ; character is in Reg C														;
0758: E953             CaretOut:                       ;
0759: E953 79                     LD     A,C                  ;
0760: E954 CD 37 E9               CALL   IsPrintableASCII     ;
0761: E957 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed			;
0762: E959         ; send preceding up arrow													;
0763: E959 F5                     PUSH   AF                   ; Save the character				;
0764: E95A 0E 5E                  LD     C,CARET              ;
0765: E95C CD 76 E9               CALL   ConsoleOut           ; Send Caret to Console				;
0766: E95F F1                     POP    AF                   ; Get the character					;
0767: E960 F6 40                  OR     40H                  ; Make the graphic a letter			;
0768: E962 4F                     LD     C,A                  ; Set up to print					;
0769: E963         ; fall thru to TabbOut														;
0770: E963         ;-- Send printable character to console. Precede with Caret if needed ------;
0771: E963         ;------------- Send printable character to console. Expand if TAB ----------;
0772: E963         ; character is in Reg C														;
0773: E963             TabOut:                         ;
0774: E963 79                     LD     A,C                  ;
0775: E964 FE 09                  CP     TAB                  ; Is it a TAB						;
0776: E966 C2 76 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not	;
0777: E969         ;
0778: E969         ; TAB encountered															;
0779: E969             TabOut0:                        ;
0780: E969 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs			;
0781: E96B CD 76 E9               CALL   ConsoleOut           ; Send to Console					;
0782: E96E 3A BD EA               LD     A,(columnPosition)   ; Get Column position				;
0783: E971 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?		;
0784: E973 20 F4                  JR     NZ,TabOut0           ; Do again if not					;
0785: E975 C9                     RET                         ;
0786: E976         ;------------- Send printable character to console. Expand if TAB ----------;
0787: E976         ;-------------------------- Send character to console ----------------------;
0788: E976         ; C	= Character to be output												;
0789: E976             ConsoleOut:                      ;
0790: E976         ; Look for CNTL_S from keyboard and save it in keyboardByte					;
0791: E976 C5                     PUSH   BC                   ; Save character and Count			;
0792: E977 CD 97 E9               CALL   ConBreak             ; Check for screen stop key stroke	;
0793: E97A C1                     POP    BC                   ;
0794: E97B C5                     PUSH   BC                   ; Get/save character				;
0795: E97C         ; Send character to Console													;
0796: E97C CD 0C F6               CALL   bcConout             ; Send character to the console		;
0797: E97F C1                     POP    BC                   ;
0798: E980 C5                     PUSH   BC                   ; Get/save character				;
0799: E981         ; is the data to be output to print device?									;
0800: E981 3A BB EA               LD     A,(printEchoFlag)    ;
0801: E984 B7                     OR     A                    ;
0802: E985 C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so			;
0803: E988 C1                     POP    BC                   ; Get the character					;
0804: E989         ;
0805: E989 79                     LD     A,C                  ; Put character to ACC				;
0806: E98A 21 BD EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition	;
0807: E98D 34                     INC    M                    ; increment the ColumnPosition		;
0808: E98E         ;
0809: E98E FE 20                  CP     SPACE                ;
0810: E990 D0                     RET    NC                   ; Exit if ASCII printable			;
0811: E991         ;
0812: E991 FE 0A                  CP     LF                   ;
0813: E993 C0                     RET    NZ                   ; Exit if not a Line Feed			;
0814: E994         ;
0815: E994 36 00                  LD     (HL),0               ;	else force columnPosition = 0	;
0816: E996 C9                     RET                         ;
0817: E997         ;-------------------------- Send character to console ----------------------;
0818: E997         ;--------------------	Check for Status and Control S or C ----------------;
0819: E997         ;	Returns:																;
0820: E997         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console;
0821: E997         ;			ACC = 00	No data Pending										;
0822: E997         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard			;
0823: E997         ;																			;
0824: E997             ConBreak:                       ;
0825: E997 3A BA EA               LD     A,(keyboardByte)     ;
0826: E99A B7                     OR     A                    ; If there is a char waiting		;
0827: E99B 20 2B                  JR     NZ,ConBreak1         ;	return with FF in ACC			;
0828: E99D         ;
0829: E99D CD 06 F6               CALL   bcConst              ; Get status						;
0830: E9A0 FE 00                  CP     00H                  ; If 00 => No data pending			;
0831: E9A2 C8                     RET    Z                    ; Return 00 No data pending			;
0832: E9A3         ;
0833: E9A3 CD 09 F6               CALL   bcConin              ; Read the byte						;
0834: E9A6         ;
0835: E9A6 FE 10                  CP     CTRL_P               ;
0836: E9A8 20 0D                  JR     NZ,CheckCTL_S        ;
0837: E9AA         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>			;
0838: E9AA 21 BB EA               LD     HL,printEchoFlag     ;
0839: E9AD 3E FF                  LD     A,TRUE               ;
0840: E9AF BE                     CP     (HL)                 ;
0841: E9B0 20 02                  JR     NZ,ToggleFlag1       ;
0842: E9B2 3E 00                  LD     A,FALSE              ;
0843: E9B4             ToggleFlag1:                      ;
0844: E9B4 77                     LD     (HL),A               ;
0845: E9B5 18 0C                  JR     NothingWaiting       ;
0846: E9B7         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>			;
0847: E9B7             CheckCTL_S:                      ;
0848: E9B7 FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save	;
0849: E9B9 20 0A                  JR     NZ,ConBreak0         ;	and and return 0FFH				;
0850: E9BB         ;
0851: E9BB CD 09 F6               CALL   bcConin              ; Else Read next byte				;
0852: E9BE FE 03                  CP     CTRL_C               ;
0853: E9C0 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if	CTRL_C			;
0854: E9C3             NothingWaiting:                      ;
0855: E9C3 AF                     XOR    A                    ;
0856: E9C4 C9                     RET                         ; Set ACC = 0 and return			;
0857: E9C5             ConBreak0:                      ;
0858: E9C5 32 BA EA               LD     (keyboardByte),A     ; save the byte						;
0859: E9C8             ConBreak1:                      ;
0860: E9C8 3E FF                  LD     A,TRUE               ; return with true set in ACC		;
0861: E9CA C9                     RET                         ;
0862: E9CB         ;--------------------	Check for Status and Control S or C ----------------;
0863: E9CB         ;------------------------	Console Output Utilities -----------------------;
0864: E9CB             showHashCRLF:                      ;
0865: E9CB 0E 23                  LD     C,HASH_TAG           ;
0866: E9CD CD 76 E9               CALL   ConsoleOut           ; Send # to console					;
0867: E9D0 CD E1 E9               CALL   showCRLF             ;
0868: E9D3             showHashCRLF1:                      ;
0869: E9D3 3E BD                  LD     A,columnPosition     ;
0870: E9D5 21 BC EA               LD     HL,startingColumn    ;
0871: E9D8 BF                     CP     A,M                  ;
0872: E9D9 D0                     RET    NC                   ;
0873: E9DA 0E 20                  LD     C,SPACE              ;
0874: E9DC CD 76 E9               CALL   ConsoleOut           ;
0875: E9DF 18 F2                  JR     showHashCRLF1        ;
0876: E9E1         ;------------------------	Console Output Utilities -----------------------;
0877: E9E1         ;------------------------	Send Carriage Return and Line Feed -------------;
0878: E9E1             showCRLF:                       ;
0879: E9E1 0E 0D                  LD     C,CR                 ;
0880: E9E3 CD 76 E9               CALL   ConsoleOut           ;
0881: E9E6 0E 0A                  LD     C,LF                 ;
0882: E9E8 C3 76 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET		;
0883: E9EB         ;------------------------	Send Carriage Return and Line Feed -------------;
0884: E9EB         ;------------------------- Read a $ terminated String ----------------------;
0885: E9EB         ;read to paramDE address (max length, current length, buffer)			;
0886: E9EB             ReadString:                      ;
0887: E9EB 3A BD EA               LD     A,(columnPosition)   ;
0888: E9EE 32 BC EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R	;
0889: E9F1 2A BF EA               LD     HL,(paramDE)         ; Get the start of the String		;
0890: E9F4 4E                     LD     C,(HL)               ; Get Max Count						;
0891: E9F5 23                     INC    HL                   ; Point at actual bytes read		;
0892: E9F6 06 00                  LD     B,0                  ; Initialize Current Count			;
0893: E9F8         ;
0894: E9F8         ; B = Current Count														;
0895: E9F8         ; C = Maximum characters												;
0896: E9F8         ; HL= Insertion Pointer													;
0897: E9F8         ;
0898: E9F8         ; read next character, BC, HL active										;
0899: E9F8             ReadNext:                       ;
0900: E9F8 C5                     PUSH   BC                   ; Save Current Index and Max Count	;
0901: E9F9 E5                     PUSH   HL                   ; Save pointer						;
0902: E9FA             ReadNext0:                      ;
0903: E9FA CD 2C E9               CALL   ConIn                ; Get the next Character			;
0904: E9FD E6 7F                  AND    ASCII_MASK           ; Mask parity bit					;
0905: E9FF E1                     POP    HL                   ; Restore Pointer					;
0906: EA00 C1                     POP    BC                   ; Current Index and Max Count		;
0907: EA01         ;Is It Carriage Return														;
0908: EA01 FE 0D                  CP     CR                   ;
0909: EA03 28 3A                  JR     Z,EndRead            ; End the read if yes				;
0910: EA05 FE 0A                  CP     LF                   ;
0911: EA07         ;Is It Linefeed																;
0912: EA07 28 36                  JR     Z,EndRead            ; End the read if yes				;
0913: EA09         ;Is It BackSpace															;
0914: EA09 FE 08                  CP     CTRL_H               ;
0915: EA0B 28 3C                  JR     Z,BSspaceBS          ;
0916: EA0D             IsItRubout:                      ;
0917: EA0D FE 7F                  CP     RUBOUT               ; Non destructive delete			;
0918: EA0F 28 41                  JR     Z,ItIsRubout         ;
0919: EA11             IsPhysicalEOL:                      ;
0920: EA11 FE 05                  CP     CTRL_E               ;
0921: EA13 28 46                  JR     Z,ItIsPhysicalEOL    ;
0922: EA15             IsItPrintToggle:                      ;
0923: EA15 FE 10                  CP     CTRL_P               ;
0924: EA17 28 49                  JR     Z,ItIsPrintToggle    ;
0925: EA19             IsItDeleteTheLineX:                      ;
0926: EA19 FE 18                  CP     CTRL_X               ;
0927: EA1B 28 6D                  JR     Z,DeleteTheLine      ; If CTRL_X go delete the line		;
0928: EA1D             IsItDeleteTheLineU:                      ;
0929: EA1D FE 15                  CP     CTRL_U               ;
0930: EA1F CA A8 EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line			;
0931: EA22         ;Retype the line															;
0932: EA22 FE 12                  CP     CTRL_R               ;
0933: EA24 28 4B                  JR     Z,RepeatLine         ;
0934: EA26         ;
0935: EA26         ;....................... Echo input back to the Console	....................;
0936: EA26         ; Full Duplex																;
0937: EA26         ; A = Character to display													;
0938: EA26         ; B = current char count													;
0939: EA26         ; C = maximum buffer length													;
0940: EA26         ; HL= buffer pointer														;
0941: EA26         ;ReadEcho																	;
0942: EA26 04                     INC    B                    ; Increment byte count				;
0943: EA27 23                     INC    HL                   ; Advance the Pointer				;
0944: EA28 77                     LD     (HL),A               ; Put char in buffer				;
0945: EA29         ;
0946: EA29             ReadEchoRubOut:                      ;
0947: EA29 C5                     PUSH   BC                   ; Save index and length			;
0948: EA2A E5                     PUSH   HL                   ; Save the Pointer					;
0949: EA2B 4F                     LD     C,A                  ; Get char							;
0950: EA2C CD 53 E9               CALL   CaretOut             ; Output to Console (^ if needed)	;
0951: EA2F E1                     POP    HL                   ; Restore the Pointer				;
0952: EA30 C1                     POP    BC                   ; Restore index and length			;
0953: EA31 7E                     LD     A,(HL)               ; Recall char						;
0954: EA32         ; check for Warm Boot														;
0955: EA32 FE 03                  CP     CTRL_C               ;
0956: EA34 78                     LD     A,B                  ; Get Line position					;
0957: EA35 20 05                  JR     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C				;
0958: EA37 FE 01                  CP     1                    ; Beginning of the Line?			;
0959: EA39 CA 00 00               JP     Z,WarmBoot           ;	if yes do the Boot				;
0960: EA3C         ; Check to see if we are at the end of the buffer							;
0961: EA3C             AreWeAtEndOfBuffer:                      ;
0962: EA3C B9                     CP     C                    ; Over Max ?						;
0963: EA3D 38 B9                  JR     C,ReadNext           ;	no, Go for more					;
0964: EA3F         ;
0965: EA3F         ; At the end of read														;
0966: EA3F             EndRead:                        ;
0967: EA3F         ; 	POP		HL																;
0968: EA3F 2A BF EA               LD     HL,(paramDE)         ;
0969: EA42 23                     INC    HL                   ;
0970: EA43         ;
0971: EA43 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer	;
0972: EA44 0E 0D                  LD     C,CR                 ;
0973: EA46 C3 76 E9               JP     ConsoleOut           ; Send CR to the Console			;
0974: EA49         ;....................... Echo input back to the Console	....................;
0975: EA49         ;.......................... Backspace SPACE BackSpace ......................;
0976: EA49             BSspaceBS:                      ;
0977: EA49 05                     DEC    B                    ;
0978: EA4A 2B                     DEC    HL                   ;
0979: EA4B C5                     PUSH   BC                   ;
0980: EA4C E5                     PUSH   HL                   ;
0981: EA4D CD 9B EA               CALL   BackUp               ;
0982: EA50 18 A8                  JR     ReadNext0            ;
0983: EA52         ;.......................... Backspace SPACE BackSpace ......................;
0984: EA52         ;.......................... It is RubOut ...................................;
0985: EA52             ItIsRubout:                      ;
0986: EA52         ; RUBOUT if possible														;
0987: EA52 78                     LD     A,B                  ; Are we at the start of the line	;
0988: EA53 B7                     OR     A                    ;
0989: EA54 28 A2                  JR     Z,ReadNext           ; then ignore and go for next char	;
0990: EA56         ;adjust pointers back one													;
0991: EA56 7E                     LD     A,(HL)               ; ACC = current character			;
0992: EA57 05                     DEC    B                    ; Adjust the index					;
0993: EA58 2B                     DEC    HL                   ; Adjust the pointer				;
0994: EA59 18 CE                  JR     ReadEchoRubOut       ; Echo back - Full Duplex			;
0995: EA5B         ;.......................... It is RubOut ...................................;
0996: EA5B         ;.......................... It is PhysicalEOL ..............................;
0997: EA5B             ItIsPhysicalEOL:                      ;
0998: EA5B C5                     PUSH   BC                   ; Save Current Index and Max Count	;
0999: EA5C E5                     PUSH   HL                   ; Save pointer						;
1000: EA5D CD E1 E9               CALL   showCRLF             ; Make new line						;
1001: EA60 18 98                  JR     ReadNext0            ;	and go for next char			;
1002: EA62         ;.......................... It is PhysicalEOL ..............................;
1003: EA62         ;.......................... It is PrintToggle ..............................;
1004: EA62             ItIsPrintToggle:                      ;
1005: EA62 E5                     PUSH   HL                   ; Save pointer						;
1006: EA63         ; Toggle the printEcho Flag													;
1007: EA63 21 BB EA               LD     HL,printEchoFlag     ; Point at the flag					;
1008: EA66 3E FF                  LD     A,TRUE               ; Load ACC with TRUE				;
1009: EA68 BE                     CP     (HL)                 ; Is the flag true?					;
1010: EA69 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not						;
1011: EA6B 3E 00                  LD     A,FALSE              ;	else. load ACC with FALSE		;
1012: EA6D             IsItPrintToggle1:                      ;
1013: EA6D 77                     LD     (HL),A               ; Set the Flags new Value			;
1014: EA6E E1                     POP    HL                   ; Restore pointer					;
1015: EA6F 18 87                  JR     ReadNext             ;	and for another char			;
1016: EA71         ;.......................... It is PrintToggle ..............................;
1017: EA71         ;.......................... RepeatLine .....................................;
1018: EA71             RepeatLine:                      ;
1019: EA71 C5                     PUSH   BC                   ; Save Current Index and Max Count	;
1020: EA72 E5                     PUSH   HL                   ;	for exit						;
1021: EA73 CD CB E9               CALL   showHashCRLF         ; Display Hash, new Line			;
1022: EA76         ;
1023: EA76 2A BF EA               LD     HL,(paramDE)         ; Get start of Buffer				;
1024: EA79 23                     INC    HL                   ; Skip past character count			;
1025: EA7A         ;
1026: EA7A             LL1:                            ;
1027: EA7A 23                     INC    HL                   ; Point at next char to display		;
1028: EA7B C5                     PUSH   BC                   ; Save counter, in B				;
1029: EA7C E5                     PUSH   HL                   ; Save buffer pointer				;
1030: EA7D 4E                     LD     C,M                  ; Get the next character			;
1031: EA7E CD 53 E9               CALL   CaretOut             ; Display it						;
1032: EA81 E1                     POP    HL                   ; Restore							;
1033: EA82 C1                     POP    BC                   ;	the counter and pointer			;
1034: EA83 10 F5                  DJNZ   LL1                  ; loop if still more to show		;
1035: EA85 E1                     POP    HL                   ; Restore values					;
1036: EA86 C1                     POP    BC                   ;	from routine entry				;
1037: EA87 C3 F8 E9               JP     ReadNext             ; Done here !						;
1038: EA8A         ;.......................... RepeatLine .....................................;
1039: EA8A         ;.......................... Delete The Line ................................;
1040: EA8A             DeleteTheLine:                      ;
1041: EA8A E1                     POP    HL                   ; Adjust Stack						;
1042: EA8B         ;											;
1043: EA8B             DeleteTheLine1:                      ;
1044: EA8B 3A BC EA               LD     A,(startingColumn)   ;
1045: EA8E 21 BD EA               LD     HL,columnPosition    ;
1046: EA91 BE                     CP     M                    ; Start of line ?					;
1047: EA92 D2 EB E9               JP     NC,ReadString        ;	If yes get out and go for more	;
1048: EA95 35                     DEC    M                    ; Adjust the ColumnPosition			;
1049: EA96 CD 9B EA               CALL   BackUp               ; Clear 1 column					;
1050: EA99 18 F0                  JR     DeleteTheLine1       ; Loop for more						;
1051: EA9B         ;.......................... Delete The Line ................................;
1052: EA9B         ;------------------------ Back-up one screen position ----------------------;
1053: EA9B             BackUp:                         ;
1054: EA9B CD A3 EA               CALL   BackUp1              ; Send Backspace				;
1055: EA9E 0E 20                  LD     C,SPACE              ; Overwrite with SPACE				;
1056: EAA0 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				;
1057: EAA3         ;does not affect column count												;
1058: EAA3             BackUp1:                        ;
1059: EAA3 0E 08                  LD     C,CTRL_H             ;
1060: EAA5 C3 0C F6               JP     bcConout             ; Send Backspace					;
1061: EAA8         ;------------------------ Back-up one screen position ----------------------;
1062: EAA8         ;.......................... Ignore The Line ................................;
1063: EAA8             IgnoreTheLine:                      ;
1064: EAA8 CD CB E9               CALL   showHashCRLF         ; Display Hash, new Line			;
1065: EAAB 0E 20                  LD     C,SPACE              ; We want to add a few spaces		;
1066: EAAD CD 0C F6               CALL   bcConout             ;	to the console					;
1067: EAB0 0E 20                  LD     C,SPACE              ;
1068: EAB2 CD 0C F6               CALL   bcConout             ;
1069: EAB5 C3 EB E9               JP     ReadString           ; Start all over					;
1070: EAB8         ;.......................... Ignore The Line ................................;
1071: EAB8         ;------------------------- Read a $ terminated String ----------------------;
1072: EAB8         ;****************************************************************************
1073: EAB8         ;							DATA AREA										*
1074: EAB8         ;****************************************************************************
1075: EAB8         ;------------------------------Non Disk Data Area --------------------------;
1076: EAB8             usersStack: DS     2                    ; entry stack pointer				;
1077: EABA         ;
1078: EABA 00          keyboardByte: DB     00                   ; Saved keyboard character			;
1079: EABB         ;
1080: EABB 00          printEchoFlag: DB     00                   ; Controlled by ^P					;
1081: EABC         ;
1082: EABC         ; FunctionValue:DB	00H					; Reg C on BDOS Entry				;
1083: EABC 00          startingColumn: DB     0                    ; Starting col pos after read		;
1084: EABD 00          columnPosition: DB     0                    ; Current Column position			;
1085: EABE         ;
1086: EABE             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call		;
1087: EABF             paramDE:   DS     WORD                 ; Word Argument for BDOS Call		;
1088: EAC1             exitParameterByte:                      ; Byte returned Value				;
1089: EAC1             exitParameterWord: DS     WORD                 ; Word							;
1090: EAC3         ;
1091: EAC3         ;
1092: EAC3         ;------------------------------------ Data Area ----------------------------;
1093: EAC3         ;***************************************************************************;
1094: EAC3         ;								Disk I/O									;
1095: EAC3         ;***************************************************************************;
1096: EAC3         ;---------------------------- Reset Disk System - D (13) -------------------;
1097: EAC3         ;	This function requests CP/M to completely reset the disk file system.	;
1098: EAC3         ; CP/M then resets its internal tables, selects logical disk A as the		;
1099: EAC3         ; default disk, resets the DMAaddress back to 0080H (the address of the		;
1100: EAC3         ; buffer used by the BDOS to read and write to the disk), and marks all		;
1101: EAC3         ; logical disks as having Read/Write status. The BDOS will then have to log	;
1102: EAC3         ; in each logical disk as each disk is accessed. This involves reading the	;
1103: EAC3         ; entire file directory for the disk and rebuilding the allocation vectors	;
1104: EAC3         ; which keep track of which allocation blocks are free and which			;
1105: EAC3         ; are used for file storage.												;
1106: EAC3         ;	Submit file is created by external command Submit. The file is			;
1107: EAC3         ; identified as $$$.SUB														;
1108: EAC3         ;																			;
1109: EAC3         ;			Function Code	:	C = 0DH										;
1110: EAC3         ;			Entry Parameters:	None										;
1111: EAC3         ;			Exit Parameters :	A = 00H if no Submit File found				;
1112: EAC3         ;									= 0FFH if Submit file found				;
1113: EAC3         ;																			;
1114: EAC3         ;---------------------------- Reset Disk System - D (13) -------------------;
1115: EAC3             vResetSystem:
1116: EAC3 21 00 00               LD     HL,0
1117: EAC6 22 96 F4               LD     (readOnlyVector),HL  ; Clear the vectors for
1118: EAC9 22 98 F4               LD     (loggedDisks),HL     ;	R/O and Logged Disks
1119: EACC AF                     XOR    A                    ; Clear the current disk
1120: EACD 32 94 F4               LD     (currentDisk),A
1121: EAD0         ; note that currentUserNumber remains unchanged
1122: EAD0 21 80 00               LD     HL,DMABuffer
1123: EAD3 22 9A F4               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1124: EAD6 CD 12 EF               CALL   SetDataDMA           ; to data DMA address
1125: EAD9 C3 28 ED               JP     Select
1126: EADC         ;---------------------------- Select Disk - E (14) -------------------------;
1127: EADC         ;	This function makes the logical disk named in register E the default	;
1128: EADC         ; disk All subsequent references to disk files that do not specify the disk	;
1129: EADC         ; will use this default. When you reference a disk file that does have an	;
1130: EADC         ; explicit logical disk in its name you do not have to issue another		;
1131: EADC         ; Select Disk function; the BDOS will take care of that for you.			;
1132: EADC         ;																			;
1133: EADC         ;	Notice the way in which the logical disk is specified in register E.	;
1134: EADC         ; It is not the same as the disk drive specification in the first byte of	;
1135: EADC         ; the file control block. In the FeB, a value ofOOH is used to mean			;
1136: EADC         ; "use the current default disk" (as specified in the last Select Disk		;
1137: EADC         ; call or by the operator on the console). With this function, a value		;
1138: EADC         ; of OOH in register A means that A is the selected drive, a value of		;
1139: EADC         ; 01H means drive B, and so on to OFR for drive P, allowing					;
1140: EADC         ; 16 drives in the system.													;
1141: EADC         ;																			;
1142: EADC         ;			Function Code	:	C = 0EH									;
1143: EADC         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1144: EADC         ;			Exit Parameters :	None										;
1145: EADC         ;																			;
1146: EADC         ;---------------------------- Select Disk - E (14) -------------------------;
1147: EADC             vSelectDisk:
1148: EADC C3 1D ED               JP     SelectCurrent
1149: EADF         ;---------------------------- Open File - F (15) ---------------------------;
1150: EADF         ;	This function opens a specified file for reading or writing. The FCB,	;
1151: EADF         ; whose address must be in register DE, tells CP/M the user number,			;
1152: EADF         ; the logical disk, the file name, and the file type. All other bytes of	;
1153: EADF         ; the FCB will normally be set to O.										;
1154: EADF         ;	The code returned by the BDOS in register A indicates whether the file	;
1155: EADF         ; has been opened successfully. If A contains OFFH, then the BOOS was		;
1156: EADF         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,		;
1157: EADF         ; then the file has been opened.											;
1158: EADF         ;			Function Code	:	C	= 0FH									;
1159: EADF         ;			Entry Parameters:	DE = Address of File Control Block			;
1160: EADF         ;			Exit Parameters :	A	= Directory Code						;
1161: EADF         ;																			;
1162: EADF         ;---------------------------- Open File - F (15) ---------------------------;
1163: EADF             vOpenFile:
1164: EADF CD C9 EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1165: EAE2 CD 4B EF               CALL   ReselectDisk         ; do we need to reselect disk?
1166: EAE5 C3 FF ED               JP     OpenFile
1167: EAE8         ;---------------------------- Close File - 10 (16) -------------------------;
1168: EAE8         ;	This function terminates the processing of a file to which you have		;
1169: EAE8         ; written information. Under CP/M you do not need to close a file that you	;
1170: EAE8         ; have been reading. However, if you ever intend for your program to		;
1171: EAE8         ; function correctly under MP/M (the multi-user version of CP/M) you		;
1172: EAE8         ; should close all files regardless of their use.							;
1173: EAE8         ;	The Close File function, like Open File, returns a directory code in	;
1174: EAE8         ; the A register. Register A will contain OFFH if the BOOS could not		;
1175: EAE8         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has	;
1176: EAE8         ; been closed.																;
1177: EAE8         ;																			;
1178: EAE8         ;	When the BDOS closes a file to which data has been written, it writes	;
1179: EAE8         ; the current contents of the FCB out to the disk directory, updating		;
1180: EAE8         ; an existing directory entry by matching the disk, name, type, and		;
1181: EAE8         ; extent number in the same manner that the Open File function does.		;
1182: EAE8         ; Note that the BDOS does not transfer the last record of the file to the	;
1183: EAE8         ; disk during the close operation. It merely updates the file directory.	;
1184: EAE8         ; You must arrange to flush any partly filled record to the disk. If the	;
1185: EAE8         ; file that you have created is a standard CP/M ASCII text file, you must	;
1186: EAE8         ; arrange to fill the unused portion of the record with the standard lAH	;
1187: EAE8         ; end-of-file characters as CP/M expects.									;
1188: EAE8         ;																			;
1189: EAE8         ;			Function Code	:	C	= 10H									;
1190: EAE8         ;			Entry Parameters:	DE = Address of File Control Block			;
1191: EAE8         ;			Exit Parameters :	A	= Directory Code						;
1192: EAE8         ;																			;
1193: EAE8         ;---------------------------- Close File - 10 (16) -------------------------;
1194: EAE8             vCloseFile:
1195: EAE8 CD 4B EF               CALL   ReselectDisk
1196: EAEB C3 40 EE               JP     CloseDirEntry
1197: EAEE         ;---------------------Search for First Name Match - 11 (17) ----------------;
1198: EAEE         ;	This function scans down the file directory for the first entry that	;
1199: EAEE         ; matches the file name, type, and extent in the FCB addressed by DE.		;
1200: EAEE         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or	;
1201: EAEE         ; more character positions. Where a "?" occurs, the BDOS will match any		;
1202: EAEE         ; character in the corresponding position in the file directory. This is	;
1203: EAEE         ; known as ambiguous file name matching.									;
1204: EAEE         ;	The first byte of an FCB normally contains the logical disk number code.;
1205: EAEE         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,	;
1206: EAEE         ; and so on up to a possible maximum of 16 for disk P. However, if this		;
1207: EAEE         ; byte contains a "?", the BDOS will search the default logical disk and	;
1208: EAEE         ; will match the file name and type regardless of the user number. This		;
1209: EAEE         ; function is normally used in conjunction with the Search Next function.	;
1210: EAEE         ; Search First, in the process of matching a file, leaves certain			;
1211: EAEE         ; variables in the BDOS set, ready for a subsequent Search Next.			;
1212: EAEE         ;	Both Search First and Search Next return a directory code in the		;
1213: EAEE         ; A register. With Search First, A = OFFH when no files match the FCB,		;
1214: EAEE         ; if a file match is found, A will have a value of 0, I, 2, or 3.			;
1215: EAEE         ;																			;
1216: EAEE         ;	To locate the particular directory entry that either the Search First	;
1217: EAEE         ; or Search Next function matched, multiply the directory code returned		;
1218: EAEE         ; in A by the length of a directory entry (32 bytes). This is easily done	;
1219: EAEE         ; by adding the A register to itself five times. Then add the DMA address	;
1220: EAEE         ; to get the actual address where the matched directory entry is stored.	;
1221: EAEE         ;	There are many occasions when you may need to write a program that will	;
1222: EAEE         ; accept an ambiguous file name and operate on all of the file names that	;
1223: EAEE         ; match it. (The DIR and ERA commands built into the CCP are examples that	;
1224: EAEE         ; use ambiguous file names.) To do this, you must use several BDOS			;
1225: EAEE         ; functions: the Set DMA Address function (code 26), this function			;
1226: EAEE         ; (Search First), and Search Next (code 18). All of this is shown in the	;
1227: EAEE         ; subroutine given in Figure 5-17.											;
1228: EAEE         ;																			;
1229: EAEE         ;																			;
1230: EAEE         ;			Function Code	:	C	= 11H									;
1231: EAEE         ;			Entry Parameters:	DE = Address of File Control Block			;
1232: EAEE         ;			Exit Parameters :	A	= Directory Code						;
1233: EAEE         ;																			;
1234: EAEE         ;---------------------Search for First Name Match - 11 (17) ----------------;
1235: EAEE             vFindFirst:
1236: EAEE 0E 00                  LD     C,0                  ; Length assuming '?' true
1237: EAF0 2A BF EA               LD     HL,(paramDE)         ; Get the FCB
1238: EAF3 7E                     LD     A,(HL)               ; DIsk/User No
1239: EAF4 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1240: EAF6 28 08                  JR     Z,QMarkFind          ;	if Yes, skip disk reselect
1241: EAF8         ;	and reset of EXT
1242: EAF8
1243: EAF8 CD C9 EF               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1244: EAFB CD 4B EF               CALL   ReselectDisk         ; Use FCB to set currentDisk
1245: EAFE 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1246: EB00             QMarkFind:
1247: EB00 CD 01 F0               CALL   SearchForDirectoryRecord ; Find the directory record
1248: EB03 C3 20 F2               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1249: EB06         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1250: EB06         ;	This function searches down the file directory for the next file name,	;
1251: EB06         ; type, and extent that match the FCB specified in a previous Search First	;
1252: EB06         ; function call. Search First and Search Next are the only BDOS functions	;
1253: EB06         ; that must be used together. As you can see, the Search Next function		;
1254: EB06         ; does not require an FCB address as an input parameter-all the necessary	;
1255: EB06         ; information will have been left in the BDOS on the Search First call.		;
1256: EB06         ; Like Search First, Search Next returns a directory code in the A register,;
1257: EB06         ; in this case, if A = OFFH, it means that there are no more files that		;
1258: EB06         ; match the file control block. If A is not OFFH, it will be a value of		;
1259: EB06         ; 0, 1, 2, or 3, indicating the relative directory entry number.			;
1260: EB06         ;																			;
1261: EB06         ;	There are two ways of using the Search First/ Next calls. Consider a	;
1262: EB06         ; simple file copying program that takes as input an ambiguous file name.	;
1263: EB06         ; You could scan the file directory, matching all of the possible file		;
1264: EB06         ; names, possibly displaying them on the console, and storing the names of	;
1265: EB06         ; the files to be copied in a table inside your program. This would have	;
1266: EB06         ; the advantage of enabling you to present the file names to the operator	;
1267: EB06         ; before any copying occurred. You could even arrange for the operator to	;
1268: EB06         ; select which files to copy on a file-by-file basis. One disadvantage		;
1269: EB06         ; would be that you could not accurately predict how many files might be	;
1270: EB06         ; selected. On some hard disk systems you might have to accommodate several ;
1271: EB06         ; thousand file names.														;
1272: EB06         ;	The alternative way of handling the problem would be to match one file	;
1273: EB06         ; name, copy it, then match the next file name, copy it, and so on. If you	;
1274: EB06         ; gave the operator the choice of selecting which files to copy, this person;
1275: EB06         ; would have to wait at the terminal as each file was being copied, but the ;
1276: EB06         ; program would not need to have large table areas set aside to hold file	;
1277: EB06         ; names. This solution to the problem is slightly more complicated, as you	;
1278: EB06         ; can see from the logic in Figure 5-17.									;
1279: EB06         ;	The subroutine in Figure 5-17, Get Next File (GNF), contains all of the	;
1280: EB06         ; necessary logic to search down a directory for both alternatives described;
1281: EB06         ; It does require that you indicate on entry whether it should search for	;
1282: EB06         ; the first or next file match, by setting A to zero or some nonzero value	;
1283: EB06         ; respectively.															;
1284: EB06         ;	You can see from Figure 5-17 that whenever the subroutine is called to	;
1285: EB06         ; get the next file, you must execute a Search First function to re-find	;
1286: EB06         ; the	previous file. Only then can a Search Next be issued. As with all	;
1287: EB06         ; functions that return a directory code in A, if this value is not OFFH, it;
1288: EB06         ; will be the relative directory entry number in the directory record		;
1289: EB06         ; currently in memory. This directory record will have been read into memory;
1290: EB06         ; at whatever address was specified at the last Set DMA Address function	;
1291: EB06         ; call. Notwithstanding its odd name, the DMA Address is simply the address ;
1292: EB06         ; into which any record input from disk will be placed. If the Set DMA		;
1293: EB06         ; Address function has not been used to change the value, then the CP/M	;
1294: EB06         ; default DMA address, location 0080H, will be used to hold the directory	;
1295: EB06         ; record.																	;
1296: EB06         ;	The actual code for locating the address of the particular directory	;
1297: EB06         ;	entry matched by the Search First/ Next functions is shown in Figure 5-17;
1298: EB06         ;	near the label GNFC. The method involves multiplying the directory code	;
1299: EB06         ;	by 32 and then adding this product to the current DMA address.			;
1300: EB06         ;																			;
1301: EB06         ;																			;
1302: EB06         ;			Function Code	:	C	= 12H									;
1303: EB06         ;			Entry Parameters:	None , Assume previous Search First Call	;
1304: EB06         ;			Exit Parameters :	A	= Directory Code						;
1305: EB06         ;																			;
1306: EB06         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1307: EB06             vFindNext:
1308: EB06 2A C1 F4               LD     HL,(searchAddress)   ; Get Current Dir Entry
1309: EB09 22 BF EA               LD     (paramDE),HL         ; Get the user's FCB
1310: EB0C CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1311: EB0F CD 16 F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1312: EB12 C3 20 F2               JP     CopyDirEntryToUserDMA ; Copy directory entry to user
1313: EB15         ;--------------------------------Delete File - 13 (19) ---------------------;
1314: EB15         ; This function logically deletes from the file directory files that match	;
1315: EB15         ; the FCB addressed by DE. It does so by replacing the first byte of each	;
1316: EB15         ; relevant directory entry (remember, a single file can have several		;
1317: EB15         ; entries, one for each extent) by the value OE5H. This flags the directory ;
1318: EB15         ; entry as being available for use.											;
1319: EB15         ;																			;
1320: EB15         ;	Like the previous two functions, Search First and Search Next, this		;
1321: EB15         ; function can take an ambiguous file name and type as part of the			;
1322: EB15         ; File Control Block, but unlike those functions, the logical disk select	;
1323: EB15         ; code cannot be a"?". This function returns a directory code in A in the	;
1324: EB15         ; same way as the previous file operations.									;
1325: EB15         ;																			;
1326: EB15         ;																			;
1327: EB15         ;			Function Code	:	C	= 13H									;
1328: EB15         ;			Entry Parameters:	DE = Address of File Control Block			;
1329: EB15         ;			Exit Parameters :	A	= Directory Code						;
1330: EB15         ;																			;
1331: EB15         ;--------------------------------Delete File - 13 (19) ---------------------;
1332: EB15             vDeleteFile:
1333: EB15 CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1334: EB18 CD 34 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1335: EB1B 0E 0C                  LD     C,fcbExtIndex        ; Load the extent number field
1336: EB1D CD 01 F0               CALL   SearchForDirectoryRecord ; Look for directory entry
1337: EB20             DeleteFileLoop:
1338: EB20 CD 52 F1               CALL   AtEndOfDirectory     ; Have we worked thru all entries
1339: EB23 CA 2D F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1340: EB26         ; set each non zero disk map entry to 0 in the allocation vector
1341: EB26 CD 3B F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1342: EB29 CD 5B F1               CALL   GetCurrentDirectoryRecord ; Point to Directory Entry
1343: EB2C 36 E5                  LD     (HL),emptyDir        ; Mark as Empty
1344: EB2E 0E 00                  LD     C,FALSE              ; Set flag for remove
1345: EB30 CD 7F F1               CALL   ScanDiskMap          ; Reclaim Bisk Blocks, set to 0
1346: EB33 CD 74 F0               CALL   WriteDir             ; Update the directory
1347: EB36 CD 16 F0               CALL   GetNextDirectoryRecord ; Look for more
1348: EB39 C3 20 EB               JP     DeleteFileLoop       ; Loop
1349: EB3C         ;----------------------------Read Sequential - 14 (20) ---------------------;
1350: EB3C         ;	This function reads the next record (l28-byte sector) from the 			;
1351: EB3C         ; designated file into memory at the address set by the last Set DMA		;
1352: EB3C         ; function call(code 26, lAH). The record read is specified by the FCB's	;
1353: EB3C         ; sequential record field. This field is incremented by 1 so that a			;
1354: EB3C         ; subsequent call to Read Sequential will get the next record from the		;
1355: EB3C         ; file. If the end of the current extent is reached, then the BDOS will		;
1356: EB3C         ; automatically open the next extent and reset the sequential record field	;
1357: EB3C         ; to 0, ready for the next Read function call.								;
1358: EB3C         ;	The file specified in the FCB must have been readied for input by		;
1359: EB3C         ; issuing an Open File (code 15, OFH) or a Create File (code 22, 16H)		;
1360: EB3C         ; BDOS call. The value OOH is returned in A to indicate a successful Read	;
1361: EB3C         ; Sequential operation, while a nonzero value shows that the Read could	;
1362: EB3C         ; not be completed because there was no data in the next record, as at the	;
1363: EB3C         ; end of file.																;
1364: EB3C         ;																			;
1365: EB3C         ;	Although it is not immediately obvious, you can change the sequential	;
1366: EB3C         ; record number, FCB$SEQREC, and within a given extent, read a record at	;
1367: EB3C         ; random. If you want to access any given record within a file, you must	;
1368: EB3C         ; compute which extent that record would be in and set the extent field in	;
1369: EB3C         ; the file control block (FCB$EXTENT) before you open the file. Thus,		;
1370: EB3C         ; although the function name implies sequential access, in practice you can ;
1371: EB3C         ; use it to perform a simple type of random access. If you need to do true	;
1372: EB3C         ; random access, look ahead to the Random Read function (code 33), which	;
1373: EB3C         ; takes care of opening the correct extent automatically.					;
1374: EB3C         ;	When you read data from a CP/M text file, the normal convention is to	;
1375: EB3C         ; fill the last record of the file with lAH characters (CONTROL-Z).			;
1376: EB3C         ; Therefore, two possible conditions can indicate end-of-file: either		;
1377: EB3C         ; encountering a IAH, or receiving a return code from the BDOS function		;
1378: EB3C         ; (in the A register) of OFFH. However, if the file that you are reading	;
1379: EB3C         ; is not an ASCII text file, then a IAH character has no special meaning,	;
1380: EB3C         ; it is just a normal data byte in the body of the file.					;
1381: EB3C         ;																			;
1382: EB3C         ;			Function Code	:	C	= 14H									;
1383: EB3C         ;			Entry Parameters:	DE = Address of File Control Block			;
1384: EB3C         ;			Exit Parameters :	A	= 0	=> Success							;
1385: EB3C         ;									<> 0	=> No data read, Probably EOF	;
1386: EB3C         ;																			;
1387: EB3C         ;----------------------------Read Sequential - 14 (20) ---------------------;
1388: EB3C             vReadSeq:
1389: EB3C CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1390: EB3F         ;ReadSeq:
1391: EB3F 3E 01                  LD     A,SEQ_ACCESS
1392: EB41 32 B9 F4               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1393: EB44             DiskRead:
1394: EB44 3E FF                  LD     A,TRUE
1395: EB46 32 BD F4               LD     (readModeFlag),A     ; Set Flag for read
1396: EB49 CD 77 EF               CALL   SetRecordVars        ; Set variables for current FCB
1397: EB4C 3A C9 F4               LD     A,(currentFileRecord)
1398: EB4F 21 C7 F4               LD     HL,fcbRecordCount
1399: EB52 BE                     CP     M                    ; is File Record < fcbRecordCount
1400: EB53 DA 67 EB               JP     C,RecordOK           ; skip if	yes
1401: EB56         ; not enough records in the extent
1402: EB56 FE 80                  CP     RecordsPerExtent     ; Is record count the Max ?
1403: EB58 20 22                  JR     NZ,NothingRead       ;	No, Exit with EOF
1404: EB5A CD B3 F2               CALL   OpenNextExt          ; Need to open the next extent
1405: EB5D AF                     XOR    A
1406: EB5E 32 C9 F4               LD     (currentFileRecord),A ; Reset the record count
1407: EB61 3A C1 EA               LD     A,(exitParameterByte) ; Was it a good Open
1408: EB64 B7                     OR     A
1409: EB65 20 15                  JR     NZ,NothingRead       ;	exit if No
1410: EB67             RecordOK:
1411: EB67 CD 63 F2               CALL   GetBlockNumber       ; Put it in absoluteCPMRecord
1412: EB6A CD 95 F2               CALL   WasBlockAllocated    ; Was it a good Allocation ?
1413: EB6D 28 0D                  JR     Z,NothingRead        ; get out if not allocated
1414: EB6F CD 9B F2               CALL   SetActualRecordAdd   ; Absolute CPM Record
1415: EB72 CD 87 F3               CALL   Seek                 ; Go to proper track,sector
1416: EB75 CD 20 EF               CALL   ReadBuffer           ; Read into DMA address
1417: EB78 CD 8C F0               CALL   UpdateRecordVariables ; update Record info
1418: EB7B C9                     RET
1419: EB7C             NothingRead:
1420: EB7C C3 39 F3               JP     SetExitParamTo1      ; No Data read
1421: EB7F         ;----------------------------Write Sequential - 15 (21) --------------------;
1422: EB7F         ;	This function writes a record from the address specified in the last Set;
1423: EB7F         ; DMA (code 26, lAH) function call to the file defined in the FCB. The		;
1424: EB7F         ; sequential record number in the FCB (RC) is updated by 1 so that			;
1425: EB7F         ; the next call to Write Sequential will write to the next record position	;
1426: EB7F         ; in the file. If necessary, a new extent will be opened to receive the new ;
1427: EB7F         ; record.																	;
1428: EB7F         ;	This function is directly analogous to the Read Sequential function,	;
1429: EB7F         ; writing instead of reading. The file specified in the FCB must first be	;
1430: EB7F         ; activated by an Open File (code 15,OFH) or create File call (code 22,16H).;
1431: EB7F         ;	A directory code of OOH is returned in A to indicate that the Write was	;
1432: EB7F         ; successful, a nonzero value is returned if the Write could not be			;
1433: EB7F         ; completed because the disk was full.										;
1434: EB7F         ;																			;
1435: EB7F         ;	As with the Read Sequential function (code 20, 14H), you can achieve	;
1436: EB7F         ; a simple form of random writing to the file by manipulating the			;
1437: EB7F         ; sequential record number (RC). However, you can only overwrite existing	;
1438: EB7F         ; records in the file, and if you want to move to another extent, you		;
1439: EB7F         ; must close the file and reopen it with the FCB$EXTENT field set to the	;
1440: EB7F         ; correct value.															;
1441: EB7F         ;	The only logical error condition that can occur when writing to a file	;
1442: EB7F         ; is insufficient room on the disk to accommodate the next extent of the	;
1443: EB7F         ; file. Any hardware errors detected will be handled by the disk driver		;
1444: EB7F         ; built into the BIOS or BDOS.												;
1445: EB7F         ;																			;
1446: EB7F         ;																			;
1447: EB7F         ;			Function Code	:	C	= 15H									;
1448: EB7F         ;			Entry Parameters:	DE = Address of File Control Block			;
1449: EB7F         ;			Exit Parameters :	A	= 0	=> Success							;
1450: EB7F         ;									<> 0	=> No data read, Probably EOF	;
1451: EB7F         ;																			;
1452: EB7F         ;----------------------------Write Sequential - 15 (21) --------------------;
1453: EB7F             vWriteSeq:
1454: EB7F CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1455: EB82             DiskWriteSeq:
1456: EB82 3E 01                  LD     A,SEQ_ACCESS
1457: EB84 32 B9 F4               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1458: EB87             DiskWrite:
1459: EB87 3E 00                  LD     A,FALSE
1460: EB89 32 BD F4               LD     (readModeFlag),A     ; Set Flag for Write
1461: EB8C CD 34 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1462: EB8F 2A BF EA               LD     HL,(paramDE)         ; Put FCB in HL
1463: EB92 CD 3E F2               CALL   CheckROFile          ; Terminate with error if File R/O
1464: EB95 CD 77 EF               CALL   SetRecordVars        ; Set variables for current FCB
1465: EB98 3A C9 F4               LD     A,(currentFileRecord) ; Get current record number
1466: EB9B FE 80                  CP     highestRecordNumber+1 ; Is it still in the same extent?
1467: EB9D D2 39 F3               JP     NC,SetExitParamTo1   ; Exit with NO WRITE set
1468: EBA0 CD 63 F2               CALL   GetBlockNumber       ; Compute disk block number
1469: EBA3 CD 95 F2               CALL   WasBlockAllocated    ; Is it really allocated ?
1470: EBA6 0E 00                  LD     C,WriteAllocated     ; Assume a normal write operation
1471: EBA8 C2 EF EB               JP     NZ,HaveWriteBlock    ;	Skip if block already allocated
1472: EBAB CD 70 F2               CALL   GetDiskMapIndex      ; Disk Map Index in ACC
1473: EBAE 32 BF F4               LD     (diskMapIndex),A     ; Save it
1474: EBB1 01 00 00               LD     BC,0000h             ; Anticipate using 0000
1475: EBB4 B7                     OR     A                    ; Is it block 0?
1476: EBB5 28 07                  JR     Z,FindAvailableBlock ;	skip if yes
1477: EBB7 4F                     LD     C,A                  ;	else a previous block exists
1478: EBB8 0B                     DEC    BC                   ; Adjust the index
1479: EBB9 CD 7D F2               CALL   GetDiskMapValue      ; Put previous block # into HL
1480: EBBC 44                     LD     B,H                  ; Move previous block
1481: EBBD 4D                     LD     C,L                  ;	number into BC
1482: EBBE             FindAvailableBlock:
1483: EBBE CD AA F1               CALL   GetClosestBlock      ; Block number in HL
1484: EBC1 7D                     LD     A,L                  ; If no available blocks HL
1485: EBC2 B4                     OR     H                    ;	HL set to 0000H
1486: EBC3 20 06                  JR     NZ,FoundAvailableBlock ; Skip if found
1487: EBC5 3E 02                  LD     A,2                  ; Load return value
1488: EBC7 32 C1 EA               LD     (exitParameterByte),A ; Save for caller
1489: EBCA C9                     RET                         ; Exit with exitParameterByte=2
1490: EBCB             FoundAvailableBlock:
1491: EBCB 22 CB F4               LD     (absoluteCPMRecord),HL ; Save the block number
1492: EBCE EB                     EX     DE,HL                ; block number to DE (E)
1493: EBCF 2A BF EA               LD     HL,(paramDE)         ; HL at FCB
1494: EBD2 01 10 00               LD     BC,fcbDiskMapIndex   ; Index to start of FCB Map
1495: EBD5 09                     ADD    HL,BC                ; HL=.start of FCB Map
1496: EBD6 3A BF F4               LD     A,(diskMapIndex)     ; Get target block index
1497: EBD9 4F                     LD     C,A                  ; Map index to C
1498: EBDA 06 00                  LD     B,0                  ; Set MSB to 00
1499: EBDC 09                     ADD    HL,BC                ; Calculate 8 bit block's location
1500: EBDD 3A C3 F4               LD     A,(byteAllocationFlag) ; Get allocation size flag
1501: EBE0 B7                     OR     A                    ; Test it
1502: EBE1 28 03                  JR     Z,Allocate16Bit      ; Skip if allocating word
1503: EBE3 73                     LD     (HL),E               ; Update the Map
1504: EBE4 18 04                  JR     MarkNewBlock         ; Skip 16 bit calculations
1505: EBE6             Allocate16Bit:
1506: EBE6 09                     ADD    HL,BC                ; Adjust for 16 bit value
1507: EBE7 72                     LD     (HL),D               ; Save MSB
1508: EBE8 23                     INC    HL
1509: EBE9 73                     LD     (HL),E               ; SAVE LSB
1510: EBEA             MarkNewBlock:
1511: EBEA CD E3 EF               CALL   ResetFileWriteFlag
1512: EBED 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1513: EBEF             HaveWriteBlock:
1514: EBEF 3A C1 EA               LD     A,(exitParameterByte)
1515: EBF2 B7                     OR     A
1516: EBF3 C0                     RET    NZ                   ; Exit if non zero returned value ??
1517: EBF4 C5                     PUSH   BC                   ; Write flag (in C)
1518: EBF5 CD 9B F2               CALL   SetActualRecordAdd   ; Set absoluteCPMRecord
1519: EBF8 CD 87 F3               CALL   Seek                 ; Seek to o proper file position
1520: EBFB C1                     POP    BC                   ; Write flag (in C)
1521: EBFC C5                     PUSH   BC                   ; Write flag (in C)
1522: EBFD CD 84 F0               CALL   WriteBuffer          ; Write buffer and check result
1523: EC00 C1                     POP    BC                   ; Write flag (in C)
1524: EC01 3A C9 F4               LD     A,(currentFileRecord) ; Get the current record
1525: EC04 21 C7 F4               LD     HL,fcbRecordCount    ; Get the starting FCB record count
1526: EC07 BE                     CP     M                    ; Current File Record > fcbRecordCount
1527: EC08 38 04                  JR     C,DiskWrite1         ;	skip if yes
1528: EC0A 77                     LD     (HL),A               ; update the FCB RC
1529: EC0B 34                     INC    M                    ; fcbRecordCount = current File Record+1
1530: EC0C 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1531: EC0E             DiskWrite1:
1532: EC0E         ; A has current File Record, C=2 if new block or new record#
1533: EC0E 0D                     DEC    C
1534: EC0F 0D                     DEC    C                    ; Check if C = unallocated write
1535: EC10 20 05                  JR     NZ,DiskWrite2        ; Skip if C not unallocated write
1536: EC12 F5                     PUSH   AF                   ; currentFileRecord
1537: EC13 CD E3 EF               CALL   ResetFileWriteFlag
1538: EC16         ;	CALL	GetWriteFileFlagValue		; HL points to FCB s2
1539: EC16         ;	RES		7,(HL)						; Reset WriteFileFlag
1540: EC16 F1                     POP    AF                   ; currentFileRecord
1541: EC17             DiskWrite2:
1542: EC17         ; check for end of extent, if found attempt
1543: EC17         ; to open next extent in preparation for next write
1544: EC17 FE 7F                  CP     highestRecordNumber  ; Space for more records ?
1545: EC19 20 19                  JR     NZ,DiskWriteCleanup  ;	finish up if Yes
1546: EC1B 3A B9 F4               LD     A,(diskAccessType)   ; Is this using Random Access
1547: EC1E B7                     OR     A
1548: EC1F 28 13                  JR     Z,DiskWriteCleanup   ;	finish up if Yes
1549: EC21 CD 8C F0               CALL   UpdateRecordVariables ; Update variables from I/O in	FCB
1550: EC24 CD B3 F2               CALL   OpenNextExt          ; Acc = 0 OK, Acc = 1 Failed
1551: EC27 21 C1 EA               LD     HL,exitParameterByte
1552: EC2A 7E                     LD     A,(HL)               ; Put Open	result in parameter
1553: EC2B B7                     OR     A                    ; Is it 00
1554: EC2C 20 04                  JR     NZ,DiskWriteCleanup0 ;	no, skip currentRecord update
1555: EC2E 3D                     DEC    A                    ; A gets FF
1556: EC2F 32 C9 F4               LD     (currentFileRecord),A ; Update currentFileRecord
1557: EC32             DiskWriteCleanup0:
1558: EC32 36 00                  LD     (HL),0               ; Set exitParameterByte
1559: EC34             DiskWriteCleanup:
1560: EC34 C3 8C F0               JP     UpdateRecordVariables ; update variables from I/O in	FCB
1561: EC37         ;--------------------------------- Make File - 16 (22) ---------------------;
1562: EC37         ;	This function creates a new file of the specified name and type. You	;
1563: EC37         ; must first ensure that no file of the same name and type already exists	;
1564: EC37         ; on the same logical disk, either by trying to open the file (if this		;
1565: EC37         ; succeeds, the file already exists) or by unconditionally erasing the file.;
1566: EC37         ;	In addition to creating the file and its associated file directory entry;
1567: EC37         ; this function also effectively opens the file so that it is ready for	;	;
1568: EC37         ; records to be written to it.												;
1569: EC37         ;	This function returns a normal directory code if the file creation has	;
1570: EC37         ; completed successfully or a value of OFFH if there is insufficient		;
1571: EC37         ; disk or directory space.													;
1572: EC37         ;	Note that this function cannot accept an ambiguous file name in the FCB. ;
1573: EC37         ;																			;
1574: EC37         ;																			;
1575: EC37         ;			Function Code	:	C	= 16H									;
1576: EC37         ;			Entry Parameters:	DE = Address of File Control Block			;
1577: EC37         ;			Exit Parameters :	A	= Directory Code						;
1578: EC37         ;---------------------------- Make File - 16 (22) --------------------------;
1579: EC37             vMakeFile:
1580: EC37 CD C9 EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1581: EC3A CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1582: EC3D C3 BE EE               JP     MakeNewFile          ; Go Make it
1583: EC40         ;-------------------------- Rename File - 17 (23) --------------------------;
1584: EC40         ;	This function renames an existing file name and type to a new name and	;
1585: EC40         ; type. It is unusual in that it uses a single FCB to store both the old	;
1586: EC40         ; file name and type (in the first 16 bytes) and the new file name and type ;
1587: EC40         ; (in the second 16 bytes).													;
1588: EC40         ;	This function returns a normal directory code if the file rename was	;
1589: EC40         ; completed successfully or a value of OFFH if the old file name could not	;
1590: EC40         ; be found.																	;
1591: EC40         ;																			;
1592: EC40         ;	The Rename File function only checks that the old file name and type	;
1593: EC40         ; exist; it makes no check to ensure that the new name and type combination ;
1594: EC40         ; does not already exist. Therefore, you should try to open the new file	;
1595: EC40         ; name and type. If you succeed, do not attempt the rename operation.		;
1596: EC40         ; CP/M will create more than one file of the same name and type, and you	;
1597: EC40         ; stand to lose the information in both files as you attempt to sort out	;
1598: EC40         ; the problem.																;
1599: EC40         ;	Never use ambiguous file names in a rename operation; it produces strange;
1600: EC40         ; effects and may result in files being irreparably damaged. This function	;
1601: EC40         ; will change all occurrences of the old file name to the new name.			;
1602: EC40         ;																			;
1603: EC40         ;																			;
1604: EC40         ;			Function Code	:	C	= 17H									;
1605: EC40         ;			Entry Parameters:	DE = Address of File Control Block			;
1606: EC40         ;			Exit Parameters :	A	= Directory Code						;
1607: EC40         ;																			;
1608: EC40         ;-------------------------- Rename File - 17 (23) --------------------------;
1609: EC40             vRenameFile:
1610: EC40 CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1611: EC43 CD 34 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1612: EC46 0E 0C                  LD     C,fcbExtIndex        ; Match user#, Name & Type only
1613: EC48 CD 01 F0               CALL   SearchForDirectoryRecord
1614: EC4B         ; Move the old use number to the new entry (2nd half of FCB)
1615: EC4B 2A BF EA               LD     HL,(paramDE)         ; FCB pointer
1616: EC4E 7E                     LD     A,(HL)               ; First byte of Dir entry
1617: EC4F 11 10 00               LD     DE,fcbDiskMapIndex   ; Use second half of FCB
1618: EC52 19                     ADD    HL,DE                ; Point at the second half of FCB
1619: EC53 77                     LD     (HL),A               ; Put into new name user position
1620: EC54             RenameLoop:
1621: EC54 CD 52 F1               CALL   AtEndOfDirectory     ; If have we checked the whole dir
1622: EC57 CA 2D F2               JP     Z,DirLocationToReturnLoc ;	return directory Index to caller
1623: EC5A         ; process this match
1624: EC5A CD 3B F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1625: EC5D 0E 10                  LD     C,fcbDiskMapIndex    ; Set starting position
1626: EC5F 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1627: EC61 CD 4C F2               CALL   CopyDir              ; copy from FCB to dir entry
1628: EC64         ; element renamed, look for more
1629: EC64 CD 16 F0               CALL   GetNextDirectoryRecord ; Look for more dir entries
1630: EC67 18 EB                  JR     RenameLoop           ; Loop
1631: EC69         ;---------------------------- Get Active Disks - 18 (24) -------------------;
1632: EC69         ; This function returns a bit map, called the login vector, in register		;
1633: EC69         ; pair	HL, indicating which logical disk drives have been selected since	;
1634: EC69         ; the last	warm boot or Reset Disk function (code 13, ODH). The least		;
1635: EC69         ; significant bit of L corresponds to disk A, while the highest order bit	;
1636: EC69         ; in H maps disk P. The bit corresponding to the specific logical disk is	;
1637: EC69         ; set to 1 if the disk has been selected or to 0 if the disk is not			;
1638: EC69         ; currently on-line.														;
1639: EC69         ;	Logical disks can be selected programmatically through any file			;
1640: EC69         ; operation	that sets the drive field to a nonzero value, through the		;
1641: EC69         ; Select Disk function (code 14, OEH), or by the operator entering an		;
1642: EC69         ; "X:" command where "X" is equal to A, B, ... , P.							;
1643: EC69         ;																			;
1644: EC69         ;			Function Code	:	C = 018H									;
1645: EC69         ;			Entry Parameters:	None										;
1646: EC69         ;			Exit Parameters :	HL = Active disk map (login vector)			;
1647: EC69         ;																			;
1648: EC69         ;---------------------------- Get Active Disks - 18 (24) -------------------;
1649: EC69             vGetLoginVector:
1650: EC69 2A 98 F4               LD     HL,(loggedDisks)
1651: EC6C 22 C1 EA               LD     (exitParameterWord),HL
1652: EC6F C9                     RET
1653: EC70         ;---------------------------- Get Current Disk- 19 (25) --------------------;
1654: EC70         ;	This function returns the current default disk set by the last Select	;
1655: EC70         ; Disk function call (code 14, OEH) or by the operator entering the			;
1656: EC70         ; "X:"command (where "X" is A, B, ..., P) to the CCP.						;
1657: EC70         ;																			;
1658: EC70         ;	This function returns the current default disk in coded form.			;
1659: EC70         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.	;
1660: EC70         ; If you need to convert this to the corresponding ASCII character, simply	;
1661: EC70         ; add 41H to register A. Use this function when you convert a file name and ;
1662: EC70         ; type in an FCB to an ASCII string in order to display it. If the first	;
1663: EC70         ; byte of the FCB is OOH, the current default drive is to be used.			;
1664: EC70         ; You must therefore use this function to determine the logical disk letter ;
1665: EC70         ; for the default drive.													;
1666: EC70         ;																			;
1667: EC70         ;			Function Code	:	C = 019H									;
1668: EC70         ;			Entry Parameters:	None										;
1669: EC70         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			;
1670: EC70         ;																			;
1671: EC70         ;---------------------------- Get Current Disk- 19 (25) --------------------;
1672: EC70             vGetCurrentDisk:
1673: EC70 3A 94 F4               LD     A,(currentDisk)
1674: EC73 32 C1 EA               LD     (exitParameterByte),A
1675: EC76 C9                     RET
1676: EC77         ;---------------------------- Set DMA Address - 1A (26) --------------------;
1677: EC77         ;	This function sets the BDOS's direct memory access (DMA) address to a new;
1678: EC77         ; value. The name is an historic relic dating back to the Intel Development ;
1679: EC77         ; System on which CP/M was originally developed. This machine, by virtue of ;
1680: EC77         ; its hardware, could read data from a diskette directly into memory or		;
1681: EC77         ; write data to a diskette directly from memory. The name DMA address now	;
1682: EC77         ; applies to the address of the buffer to and from which data is			;
1683: EC77         ; transferred whenever a diskette Read, Write, or directory operation is	;
1684: EC77         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or		;
1685: EC77         ; Reset Disk operation occurs, the DMA address is reset to its default		;
1686: EC77         ; value of 0080H.															;
1687: EC77         ;																			;
1688: EC77         ;			Function Code	:	C = 0A9H									;
1689: EC77         ;			Entry Parameters:	DE = DMA Address							;
1690: EC77         ;			Exit Parameters :	None										;
1691: EC77         ;																			;
1692: EC77         ;---------------------------- Set DMA Address - 1A (26) --------------------;
1693: EC77             vSetDMA:
1694: EC77 2A BF EA               LD     HL,(paramDE)
1695: EC7A 22 9A F4               LD     (initDAMAddress),HL
1696: EC7D C3 12 EF               JP     SetDataDMA
1697: EC80         ;---------------------------- Get Allocation Vector - 1B (27) --------------;
1698: EC80         ;	This function returns the base, or starting, address of the allocation	;
1699: EC80         ; vector for the currently selected logical disk. This information,			;
1700: EC80         ; indicating which parts of the disk are assigned, is used by utility		;
1701: EC80         ; programs and the BDOS itself to determine how much unused space is on the ;
1702: EC80         ; logical disk, to locate an unused allocation block in order to extend		;
1703: EC80         ; a file, or to relinquish an allocation block when a file is deleted.		;
1704: EC80         ;																			;
1705: EC80         ;			Function Code	:	C = 01BH									;
1706: EC80         ;			Entry Parameters:	None										;
1707: EC80         ;			Exit Parameters :	HL = Address of allocation vector			;
1708: EC80         ;																			;
1709: EC80         ;---------------------------- Get Allocation Vector - 1B (27) --------------;
1710: EC80             vGetAllocAddr:
1711: EC80 2A A8 F4               LD     HL,(caAllocVector)
1712: EC83 22 C1 EA               LD     (exitParameterWord),HL
1713: EC86 C9                     RET
1714: EC87         ;---------------------------- Write Protect Disk - 1C (28) -----------------;
1715: EC87         ;	This function logically sets the currently selected disk to a Read-Only	;
1716: EC87         ; state. Any attempts to execute a Write Sequential or Write Random function;
1717: EC87         ; to the selected disk will be intercepted by the BDOS, and the following	;
1718: EC87         ; message will appear on the console:										;
1719: EC87         ;	BDOS Err on X: R/O														;
1720: EC87         ;	where X: is the selected disk.											;
1721: EC87         ;																			;
1722: EC87         ;	Once you have requested Read-Only status for the currently selected		;
1723: EC87         ; logical disk, this status will persist even if you proceed to select		;
1724: EC87         ; other logical disks. In fact, it will remain in force until the next warm ;
1725: EC87         ; boot or Reset Disk System function call.									;
1726: EC87         ;	Digital Research documentation refers to this function code as Disk Write;
1727: EC87         ; Protect. The Read-Only description is used here because it corresponds	;
1728: EC87         ; to the error message produced if your program attempts to write on		;
1729: EC87         ; the disk.																	;
1730: EC87         ;																			;
1731: EC87         ;			Function Code	:	C = 01CH									;
1732: EC87         ;			Entry Parameters:	None										;
1733: EC87         ;			Exit Parameters :	None										;
1734: EC87         ;																			;
1735: EC87         ;---------------------------- Write Protect Disk - 1C (28) -----------------;
1736: EC87         ;;write protect current disk
1737: EC87             vWriteProtectDisk:
1738: EC87 C3 28 EF               JP     SetDiskReadOnly
1739: EC8A         ;---------------------------- Get Read-Only Map - 1D (29) ------------------;
1740: EC8A         ;	This function returns a bit map in registers H and L showing which		;
1741: EC8A         ; logical disks in the system have been set to Read-Only status, either by	;
1742: EC8A         ; the Set Logical Disk to Read-Only function call (code 28, ICH), or by		;
1743: EC8A         ; the BDOS itself, because it detected that a diskette had been changed.	;
1744: EC8A         ;	The least significant bit of L corresponds to logical disk A, while the	;
1745: EC8A         ; most significant bit of H corresponds to disk P. The bit corresponding to ;
1746: EC8A         ; the specific logical disk is set to I if the disk has been set to			;
1747: EC8A         ; Read-Only status.															;
1748: EC8A         ;																			;
1749: EC8A         ;			Function Code	:	C = 01DH									;
1750: EC8A         ;			Entry Parameters:	None										;
1751: EC8A         ;			Exit Parameters :	HL = Read-Only Vector						;
1752: EC8A         ;																			;
1753: EC8A         ;---------------------------- Get Read-Only Map - 1D (29) ------------------;
1754: EC8A             vGetReadOnlyMap:
1755: EC8A 2A 96 F4               LD     HL,(readOnlyVector)
1756: EC8D 22 C1 EA               LD     (exitParameterWord),HL
1757: EC90 C9                     RET
1758: EC91         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1759: EC91         ;	This function sets the bits that describe attributes of a file in the	;
1760: EC91         ; relevant directory entries for the specified file. Each file can be		;
1761: EC91         ; assigned up to 11 file attributes. Of these 11, two have predefined		;
1762: EC91         ; meanings, four others are available for you to use, and the remaining		;
1763: EC91         ; five are reserved for future use by CP/M.									;
1764: EC91         ;	Each attribute consists of a single bit. The most significant bit of	;
1765: EC91         ; each byte of the file name and type is used to store the attributes.		;
1766: EC91         ; The file attributes are known by a code consisting of the letter "f"		;
1767: EC91         ; (for file name) or "t" (for file type), followed by the number of the		;
1768: EC91         ; character position and a single quotation mark. For example, the Read-Only;
1769: EC91         ; attribute is tl'.															;
1770: EC91         ;	The significance of the attributes is as follows:						;
1771: EC91         ;			fl' to f4' Available for you to use								;
1772: EC91         ;			f5' to fS' Reserved for future CP/M use							;
1773: EC91         ;			tl' Read-Only File attribute									;
1774: EC91         ;			t2' System File attribute										;
1775: EC91         ;			t3' Reserved for future CP/M use								;
1776: EC91         ;																			;
1777: EC91         ;	Attributes are set by presenting this function with an FCB in which the	;
1778: EC91         ; unambiguous file name has been preset with the most significant bits		;
1779: EC91         ; set appropriately. This function then searches the directory for a match	;
1780: EC91         ; and changes the matched entries to contain the attributes which have been ;
1781: EC91         ; set in the FCB.															;
1782: EC91         ;	The BDOS will intercept any attempt to write on a file that has the		;
1783: EC91         ; Read-Only attribute set. The DIR command in the CCP does not display any	;
1784: EC91         ; file with System status.													;
1785: EC91         ;																			;
1786: EC91         ;	You can use the four attributes available to you to set up a file		;
1787: EC91         ; security system, or perhaps to flag certain files that must be backed up	;
1788: EC91         ; to other disks. The Search First and Search Next functions allow you to	;
1789: EC91         ; view the complete file directory entry, so your programs can test the		;
1790: EC91         ; attributes easily.														;
1791: EC91         ;																			;
1792: EC91         ;																			;
1793: EC91         ;			Function Code	:	C	= 1EH									;
1794: EC91         ;			Entry Parameters:	DE = Address of File Control Block			;
1795: EC91         ;			Exit Parameters :	A	= Directory Code						;
1796: EC91         ;																			;
1797: EC91         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1798: EC91             vSetFileAttributes:
1799: EC91 CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1800: EC94 0E 0C                  LD     C,fcbExtIndex        ; Size of search/match
1801: EC96 CD 01 F0               CALL   SearchForDirectoryRecord ; Find a match
1802: EC99             SetAttributesLoop:
1803: EC99 CD 52 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
1804: EC9C CA 2D F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1805: EC9F         ; Directory entry found
1806: EC9F 0E 00                  LD     C,0                  ; Set starting position
1807: ECA1 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1808: ECA3 CD 4C F2               CALL   CopyDir              ; copy from FCB to dir entry
1809: ECA6 CD 16 F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1810: ECA9 18 EE                  JR     SetAttributesLoop    ; Loop
1811: ECAB         ;------------------ Get Disk Parameter Block Address - 1F (31) -------------;
1812: ECAB         ;	This function returns the address of the disk parameter block (DPB) for	;
1813: ECAB         ; the last selected logical disk. The DPB describes the physical			;
1814: ECAB         ; characteristics of a specific logical disk-information mainly of interest ;
1815: ECAB         ; for system utility programs.												;
1816: ECAB         ;																			;
1817: ECAB         ;			Function Code	:	C = 1FH										;
1818: ECAB         ;			Entry Parameters:	None										;
1819: ECAB         ;			Exit Parameters :	HL = Address of Disk Parameter Block		;
1820: ECAB         ;																			;
1821: ECAB         ;------------------ Get Disk Parameter Block Address - 1F (31) -------------;
1822: ECAB             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1823: ECAB 2A A4 F4               LD     HL,(caDiskParamBlock)
1824: ECAE 22 C1 EA               LD     (exitParameterWord),HL
1825: ECB1 C9                     RET
1826: ECB2         ;------------------------- Read Random - 21 (33) ---------------------------;
1827: ECB2         ; This function reads a specific CP/M record (128 bytes) from a random file ;
1828: ECB2         ; that is, a file in which records can be accessed directly. It assumes that;
1829: ECB2         ; you have already opened the file, set the DMA address using the BDOS		;
1830: ECB2         ; Set DMA function, and set the specific record to be read into the random	;
1831: ECB2         ; record number in the FCB. This function computes the extent of the		;
1832: ECB2         ; specified record number and attempts to open it and read the correct CP/M ;
1833: ECB2         ; record into the DMA address.												;
1834: ECB2         ;	The random record number in the FCB is three bytes long (at relative	;
1835: ECB2         ; bytes 33, 34, and 35). Byte 33 is the least significant byte, 34 is the	;
1836: ECB2         ; middle byte, and 35 the most significant. CP/M uses only the most			;
1837: ECB2         ; significant byte (35) for computing the overall file size (function 35).	;
1838: ECB2         ; You must set this byte to 0 when setting up the FCB. Bytes 33 and 34		;
1839: ECB2         ; are used together for the Read Random, so you can access from record		;
1840: ECB2         ; 0 to 65535 (a maximum file size of 8,388,480 bytes).						;
1841: ECB2         ;	This function returns with A set to 0 to indicate that the operation has;
1842: ECB2         ; been completed successfully, or A set to a nonzero value if an error has	;
1843: ECB2         ; occurred. The error codes are as follows:									;
1844: ECB2         ;		A = 01 (attempt to read unwritten record)							;
1845: ECB2         ;		A = 03 (CP/M could not close current extent)						;
1846: ECB2         ;		A = 04 (attempt to read unwritten extent)							;
1847: ECB2         ;		A = 06 (attempt to read beyond end of disk)							;
1848: ECB2         ;																			;
1849: ECB2         ;	Unlike the Read Sequential BOOS function (code 20, l4H), which updates	;
1850: ECB2         ; the current (sequential) record number in the FCB, the Read Random		;
1851: ECB2         ; function leaves the record number unchanged, so that a subsequent Write	;
1852: ECB2         ; Random will replace the record just read.									;
1853: ECB2         ;	You can follow a Read Random with a Write Sequential (code 21, l5H).	;
1854: ECB2         ; This will rewrite the record just read, but will then update the			;
1855: ECB2         ; sequential record number. Or you may choose to use a Read Sequential after;
1856: ECB2         ; the Read Random. In this case, the same record will be reread and the		;
1857: ECB2         ; sequential record number will be incremented. In short, the file can be	;
1858: ECB2         ; sequentially read or written once the Read Random has been used to		;
1859: ECB2         ; position to the required place in the file.								;
1860: ECB2         ;																			;
1861: ECB2         ; To use the Read Random function, you must first open the base extent of	;
1862: ECB2         ; the file, that is, extent O. Even though there may be no actual data		;
1863: ECB2         ; records in this extent, opening permits the file to be processed			;
1864: ECB2         ; correctly.																;
1865: ECB2         ;	One problem that is not immediately obvious with random files is that	;
1866: ECB2         ; they can easily be created with gaps in the file. If you were to create	;
1867: ECB2         ; the file with record number 0 and record number 5000, there would be no	;
1868: ECB2         ; intervening file extents. Should you attempt to read or copy the file		;
1869: ECB2         ; sequentially, even using CP/M's file copy utility, only the first extent	;
1870: ECB2         ; (and in this case, record 0) would get copied. A Read Sequential function ;
1871: ECB2         ; would return an "end of file" error after reading record O. You must		;
1872: ECB2         ; therefore be conscious of the type of the file that you try and read	.	;
1873: ECB2         ;																			;
1874: ECB2         ;																			;
1875: ECB2         ;																			;
1876: ECB2         ;			Function Code	:	C	= 21H									;
1877: ECB2         ;			Entry Parameters:	DE = Address of File Control Block			;
1878: ECB2         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)	;
1879: ECB2         ;								A = 03 (CP/M could not close current extent);
1880: ECB2         ;								A = 04 (attempt to read unwritten extent)	;
1881: ECB2         ;								A = 06 (attempt to read beyond end of disk) ;
1882: ECB2         ;																			;
1883: ECB2         ;------------------------- Read Random - 21 (33) ---------------------------;
1884: ECB2             vReadRandom:
1885: ECB2 CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1886: ECB5 0E FF                  LD     C,TRUE               ; Identify as a Read
1887: ECB7 CD 9E F0               CALL   RandomSeek           ; Set up correct Dir entry etc.
1888: ECBA CC 44 EB               CALL   Z,DiskRead           ; Go Read
1889: ECBD C9                     RET
1890: ECBE         ;------------------------- Write Random - 22 (34) --------------------------;
1891: ECBE         ; This function writes a specific CP/M record (128 bytes) into a random		;
1892: ECBE         ; file. It is initiated in much the same way as the companion function,		;
1893: ECBE         ; Read Random (code 33,21H). It assumes that you have already opened the	;
1894: ECBE         ; file, set the DMAaddress to the address in memory containing the record to;
1895: ECBE         ; be written to disk, and set the random record number in the FCB to the	;
1896: ECBE         ; specified record being written. This function also computes the extent in ;
1897: ECBE         ; which the specified record number lies and opens the extent (creating it	;
1898: ECBE         ; if it does not already exist). The error codes returned in A by this call ;
1899: ECBE         ; are the same as those for Read Random, with the addition of error			;
1900: ECBE         ; code 05, which indicates a full directory.								;
1901: ECBE         ;	Like the Read Random (but unlike the Write Sequential), this function	;
1902: ECBE         ; does not update the logical extent and sequential (current) record number ;
1903: ECBE         ; in the FCB. Therefore, any subsequent sequential operation will access	;
1904: ECBE         ; the record just written by the Read Random call, but these functions will ;
1905: ECBE         ; update the sequential record number. The Write Random can therefore be	;
1906: ECBE         ; used to position to the required place in the file, which can then be		;
1907: ECBE         ; accessed sequentially.													;
1908: ECBE         ;																			;
1909: ECBE         ;	In order to use the Write Random, you must first open the base extent	;
1910: ECBE         ; (extent 0) of the file. Even though there may be no data records in this	;
1911: ECBE         ; extent, opening permits the file to be processed correctly.				;
1912: ECBE         ;	As explained in the notes for the Read Random function, you can easily	;
1913: ECBE         ; create a random file with gaps in it. If you were to create a file with	;
1914: ECBE         ; record number 0 and record number 5000, there would be no intervening		;
1915: ECBE         ; file extents.																;
1916: ECBE         ;																			;
1917: ECBE         ;			Function Code	:	C	= 24H									;
1918: ECBE         ;			Entry Parameters:	DE = Address of File Control Block			;
1919: ECBE         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)	;
1920: ECBE         ;								A = 03 (CP/M could not close current extent);
1921: ECBE         ;								A = 04 (attempt to read unwritten extent)	;
1922: ECBE         ;								A = 05 (CP/M cannot create new extent)		;
1923: ECBE         ;								A = 06 (attempt to read beyond end of disk) ;
1924: ECBE         ;																			;
1925: ECBE         ;------------------------- Write Random - 22 (34) --------------------------;
1926: ECBE             vWriteRandom:
1927: ECBE CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1928: ECC1 0E 00                  LD     C,FALSE              ; Identify as a Write
1929: ECC3 CD 9E F0               CALL   RandomSeek
1930: ECC6 CC 87 EB               CALL   Z,DiskWrite          ; Go Write
1931: ECC9 C9                     RET
1932: ECCA         ;------------------------- Get File Size - 23 (35) -------------------------;
1933: ECCA         ;	This function returns the virtual size of the specified file. It does so;
1934: ECCA         ; by setting the random record number (bytes 33-35) in the specified FCB to ;
1935: ECCA         ; the maximum 128-byte record number in the file. The virtual file size is	;
1936: ECCA         ; calculated from the record address of the record following the end of the ;
1937: ECCA         ; file. Bytes 33 and 34 form a 16-bit value that contains the record number,;
1938: ECCA         ; with overflow indicated in byte 35. If byte 35 is 01, this means that the ;
1939: ECCA         ; file has the maximum record count of 65,536.								;
1940: ECCA         ;	If the function cannot find the file specified by the FCB, it returns	;
1941: ECCA         ; with the random record field set to O.									;
1942: ECCA         ;	You can use this function when you want to add data to the end of an	;
1943: ECCA         ; existing file. By calling this function first, the random record bytes	;
1944: ECCA         ; will be set to the end of file. Subsequent Write Random calls will write	;
1945: ECCA         ; out records to this preset address.										;
1946: ECCA         ;																			;
1947: ECCA         ;	Do not confuse the virtual file size with the actual file size. In a	;
1948: ECCA         ; random file, if you write just a single CP/M record to record number		;
1949: ECCA         ; 1000 and then call this function, it will return with the random record	;
1950: ECCA         ; number field set in the FCB to 1000, even though only a single record		;
1951: ECCA         ; exists in the file. For sequential files, this function returns the		;
1952: ECCA         ; number of records in the file. In this case, the virtual and actual file	;
1953: ECCA         ; sizes coincide.															;
1954: ECCA         ;																			;
1955: ECCA         ;																			;
1956: ECCA         ;			Function Code	:	C	= 23H									;
1957: ECCA         ;			Entry Parameters:	DE = Address of File Control Block			;
1958: ECCA         ;			Exit Parameters :	Random record field set in FCB				;
1959: ECCA         ;																			;
1960: ECCA         ;------------------------- Get File Size - 23 (35) -------------------------;
1961: ECCA             vComputeFileSize:
1962: ECCA CD 4B EF               CALL   ReselectDisk         ; Reselect if needed
1963: ECCD 0E 0C                  LD     C,fcbExtIndex        ; Set search/match length
1964: ECCF CD 01 F0               CALL   SearchForDirectoryRecord ; Set directoryIndex
1965: ECD2         ; zero the receiving FCB Random Record field
1966: ECD2 2A BF EA               LD     HL,(paramDE)         ; Point at FCB
1967: ECD5 11 21 00               LD     DE,recordRandom      ; Random Record index
1968: ECD8 19                     ADD    HL,DE                ; Point at Random Record
1969: ECD9 E5                     PUSH   HL                   ; Random Record LSB pointer
1970: ECDA 72                     LD     (HL),D               ; Set Random Record LSB = 0
1971: ECDB 23                     INC    HL                   ; Random Record MSB pointer
1972: ECDC 72                     LD     (HL),D               ; Set Random Record MSB = 0
1973: ECDD 23                     INC    HL                   ; Random Record overflow pointer
1974: ECDE 72                     LD     (HL),D               ; Set Random Record overflow = 0
1975: ECDF             GetFileSize1:
1976: ECDF CD 52 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
1977: ECE2 28 20                  JR     Z,GetFileSizeExit    ;	exit if no
1978: ECE4 CD 5B F1               CALL   GetCurrentDirectoryRecord ; HL points at Directory entry
1979: ECE7 11 0F 00               LD     DE,fcbRCIndex        ; FCB Record Count index
1980: ECEA CD 1E F1               CALL   GetRandomRecordPosition
1981: ECED         ; ???????
1982: ECED E1                     POP    HL
1983: ECEE E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1984: ECEF 5F                     LD     E,A                  ; save cy
1985: ECF0 79                     LD     A,C
1986: ECF1 96                     SUB    M
1987: ECF2 23                     INC    HL                   ; ls byte
1988: ECF3 78                     LD     A,B
1989: ECF4 9E                     SBC    A,(HL)
1990: ECF5 23                     INC    HL                   ; middle byte
1991: ECF6 7B                     LD     A,E
1992: ECF7 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1993: ECF8 38 05                  JR     C,GetFileSize2       ; for another try
1994: ECFA         ; fcb is less or equal, fill from directory
1995: ECFA 73                     LD     (HL),E
1996: ECFB 2B                     DEC    HL
1997: ECFC 70                     LD     (HL),B
1998: ECFD 2B                     DEC    HL
1999: ECFE 71                     LD     (HL),C
2000: ECFF             GetFileSize2:                      ; getnextsize:
2001: ECFF CD 16 F0               CALL   GetNextDirectoryRecord
2002: ED02 18 DB                  JR     GetFileSize1
2003: ED04             GetFileSizeExit:                      ; setsize:
2004: ED04 E1                     POP    HL                   ; discard .fcb(random record field)
2005: ED05 C9                     RET
2006: ED06         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2007: ED06         ;	This function sets the random record number in the FCB to the correct	;
2008: ED06         ; value for the last record read or written sequentially to the file.		;
2009: ED06         ;																			;
2010: ED06         ;	This function provides you with a convenient way to build an index file	;
2011: ED06         ; so that you can randomly access a sequential file. Open the sequential	;
2012: ED06         ; file, and as you read each record, extract the appropriate key field from ;
2013: ED06         ; the data record. Make the BDOS Set Random Record request and create a new ;
2014: ED06         ; data record with just the key field and the random record number. Write	;
2015: ED06         ; the new data record out to the index file.								;
2016: ED06         ;	Once you have done this for each record in the file, your index file	;
2017: ED06         ; provides a convenient method, given a search key value, of finding the	;
2018: ED06         ; appropriate CP/M record in which the data lies.							;
2019: ED06         ;	You can also use this function as a means of finding out where you are	;
2020: ED06         ; currently positioned in a sequential file-either to relate a CP/M record	;
2021: ED06         ; number to the position, or simply as a place-marker to allow a			;
2022: ED06         ; repositioning to the same place later.									;
2023: ED06         ;																			;
2024: ED06         ;																			;
2025: ED06         ;			Function Code	:	C	= 24H									;
2026: ED06         ;			Entry Parameters:	DE = Address of File Control Block			;
2027: ED06         ;			Exit Parameters :	Random record field set in FCB				;
2028: ED06         ;																			;
2029: ED06         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2030: ED06             vSetRandomRecord:
2031: ED06 2A BF EA               LD     HL,(paramDE)         ; FCB
2032: ED09 11 20 00               LD     DE,recordSeq         ; Sequential record index
2033: ED0C CD 1E F1               CALL   GetRandomRecordPosition
2034: ED0F         ; A = Overflow, B = randomRecord MSB, C = randomRecord LSB
2035: ED0F 21 21 00               LD     HL,recordRandom
2036: ED12 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
2037: ED13 71                     LD     (HL),C
2038: ED14 23                     INC    HL
2039: ED15 70                     LD     (HL),B
2040: ED16 23                     INC    HL
2041: ED17 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
2042: ED18 C9                     RET
2043: ED19         ;------------------------ Reset Logical Disk Drive - 25 (37) ---------------;
2044: ED19         ;	This function resets individual disk drives. It is a more precise		;
2045: ED19         ; version of the Reset Disk System function (code 13,ODH), in that you		;
2046: ED19         ; can set specific logical; disks rather than all of them.					;
2047: ED19         ;	The bit map in DE shows which disks are to be reset. The least			;
2048: ED19         ; significant bit of E represents disk A, and the most significant bit of	;
2049: ED19         ; D, disk P. The bits set to 1 indicate the disks to be reset.				;
2050: ED19         ;	Note that this function returns a zero value in A in order to maintain	;
2051: ED19         ; compatibility with MP/ M.													;
2052: ED19         ;													;						;
2053: ED19         ;	Use this function when only specific diskettes need to be changed.		;
2054: ED19         ; Changing a diskette without requesting CP/M to log it in will cause the	;
2055: ED19         ; BDOS to assume that an error has occurred and to set the new diskette to	;
2056: ED19         ; Read-Only status as a protective measure									;
2057: ED19         ;																			;
2058: ED19         ;			Function Code	:	C = 25H										;
2059: ED19         ;			Entry Parameters:	DE = Logical Drive Bit Vector				;
2060: ED19         ;			Exit Parameters :	A = 00H										;
2061: ED19         ;																			;
2062: ED19         ;------------------------ Reset Logical Disk Drive - 25 (37) ---------------;
2063: ED19         ;	**************	Not Yet Implemented	**************
2064: ED19             vResetDrive:
2065: ED19 3E FF                  LD     A,-1                 ; Error return
2066: ED1B C9                     RET
2067: ED1C         ;------------------------------ Access Drive - 26 (38) ---------------------;
2068: ED1C         ;								NOT SUPPORTED								;
2069: ED1C         ;------------------------------ Access Drive - 26 (38) ---------------------;
2070: ED1C         ;------------------------------ Free	Drive - 27 (39) --------------------;
2071: ED1C         ;								NOT SUPPORTED								;
2072: ED1C         ;------------------------------ Free	Drive - 27 (39) --------------------;
2073: ED1C         ;---------------- Write Random with Zero Fill - 28 (40) --------------------;
2074: ED1C         ;	This function is an extension to the Write Random function described	;
2075: ED1C         ; previously. In addition to performing the Write Random, it will also fill ;
2076: ED1C         ; each new allocation block with OOH's. Digital Research added this function;
2077: ED1C         ; to assist Microsoft with the production of its COBOL compiler-it makes the;
2078: ED1C         ; logic of the file handling code easier. It also is an economical way to	;
2079: ED1C         ; completely fill a random file with OOH's. You need only write one record	;
2080: ED1C         ; per allocation block, the BDOS will clear the rest of the block for you.	;
2081: ED1C         ;																			;
2082: ED1C         ;																			;
2083: ED1C         ;			Function Code	:	C	= 24H									;
2084: ED1C         ;			Entry Parameters:	DE = Address of File Control Block			;
2085: ED1C         ;			Exit Parameters :	A = Return Code								;
2086: ED1C         ;																			;
2087: ED1C         ;---------------- Write Random with Zero Fill - 28 (40) --------------------;
2088: ED1C             vWriteRandom0Fill:
2089: ED1C         ; Not Yet Implemented	**************
2090: ED1C C9                     RET
2091: ED1D         ;--------------------------- Select	Drive ----------------------------------;
2092: ED1D         ; Establish the disk found in (paramE) as the current disk drive			;
2093: ED1D             SelectCurrent:                      ;
2094: ED1D 3A BE EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)		;
2095: ED20 21 94 F4               LD     HL,currentDisk       ; Get the current disk				;
2096: ED23 BE                     CP     M                    ; Are the the same ?				;
2097: ED24 C8                     RET    Z                    ; Exit if yes, nothing to do		;
2098: ED25 77                     LD     (HL),A               ;	else update curretDisk and		;
2099: ED26 18 00                  JR     Select               ;	select it						;
2100: ED28         ;--------------------------- Select	Drive ----------------------------------;
2101: ED28         ;--------------------------- Select Login Drive ----------------------------;
2102: ED28         ; select Login Drive														;
2103: ED28             Select:                         ;
2104: ED28 CD 49 ED               CALL   SelectDisk           ; Select the Disk					;
2105: ED2B CC 22 F4               CALL   Z,Error_Select       ;
2106: ED2E 21 94 F4               LD     HL,currentDisk       ;
2107: ED31 46                     LD     B,(HL)               ; Get Current Disk					;
2108: ED32 2A 98 F4               LD     HL,(loggedDisks)     ; Load Logged Disk MAP				;
2109: ED35 CD F4 F3               CALL   IsBitSet             ;
2110: ED38 C0                     RET    NZ                   ; Exit if already logged in			;
2111: ED39         ;																			;
2112: ED39 21 94 F4               LD     HL,currentDisk       ;
2113: ED3C 46                     LD     B,(HL)               ; Get Current Disk					;
2114: ED3D 2A 98 F4               LD     HL,(loggedDisks)     ; else log in a different disk		;
2115: ED40 CD 04 F4               CALL   SetVectorBit         ;
2116: ED43 22 98 F4               LD     (loggedDisks),HL     ; Update the Vector					;
2117: ED46         ;
2118: ED46 C3 8F ED               JP     InitDisk             ;
2119: ED49         ;--------------------------- Select Login Drive ----------------------------;
2120: ED49         ;--------------------------- Select Disk -----------------------------------;
2121: ED49         ; select the disk drive given by currentDisk, and fill the base addresses	;
2122: ED49         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
2123: ED49             SelectDisk:                      ;
2124: ED49 3A 94 F4               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)		;
2125: ED4C 4F                     LD     C,A                  ; Prepare for BIOS Call				;
2126: ED4D CD 1B F6               CALL   bcSeldsk             ; Select the disk					;
2127: ED50 7C                     LD     A,H                  ; Return Pointer to					;
2128: ED51 B5                     OR     L                    ;	Disk Parameter Header			;
2129: ED52 C8                     RET    Z                    ; exit if error, with HL = 0000		;
2130: ED53         ;
2131: ED53 5E                     LD     E,(HL)               ;
2132: ED54 23                     INC    HL                   ;
2133: ED55 56                     LD     D,(HL)               ; Skew Table in DE					;
2134: ED56 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File	;
2135: ED57 ED 53 BA F4               LD     (caSkewTable),DE     ; Move to Current Skew Table		;
2136: ED5B         ;
2137: ED5B 22 9C F4               LD     (caDirMaxValue),HL   ; Move to Current Dir max			;
2138: ED5E 23                     INC    HL                   ;
2139: ED5F 23                     INC    HL                   ; HL = Last Track #					;
2140: ED60 22 9E F4               LD     (caTrack),HL         ; Move to Current Track #			;
2141: ED63 23                     INC    HL                   ;
2142: ED64 23                     INC    HL                   ; HL = Last Sector #				;
2143: ED65 22 A0 F4               LD     (caSector),HL        ; Move to Current Sector #			;
2144: ED68 23                     INC    HL                   ;
2145: ED69 23                     INC    HL                   ;
2146: ED6A 11 A2 F4               LD     DE,caDirectoryDMA    ;
2147: ED6D 01 08 00               LD     BC,caListSize        ;
2148: ED70 ED B0                  LDIR                        ;
2149: ED72         ;
2150: ED72         ; finish filling in address list											;
2151: ED72 2A A4 F4               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block		;
2152: ED75 11 AA F4               LD     DE,dpbStart          ; Point at BIOS DPB					;
2153: ED78 01 0F 00               LD     BC,dpbSize           ;
2154: ED7B ED B0                  LDIR                        ; Move DPB to current				;
2155: ED7D         ;
2156: ED7D         ; Determine if Byte or Word Allocation Table								;
2157: ED7D 2A AF F4               LD     HL,(dpbDSM)          ; Get max entry number				;
2158: ED80 7C                     LD     A,H                  ; If	its 00 then < 255			;
2159: ED81 21 C3 F4               LD     HL,byteAllocationFlag ; Point at the	flag				;
2160: ED84 36 FF                  LD     (HL),TRUE            ; Assume its less than 255			;
2161: ED86 B7                     OR     A                    ;	is the assumption confirmed ?	;
2162: ED87 28 02                  JR     Z,SelectDisk1        ;	skip if yes						;
2163: ED89 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false	;
2164: ED8B         ;
2165: ED8B         ; Set Sign, reset Carry and Zero to indicate success						;
2166: ED8B             SelectDisk1:                      ;
2167: ED8B 3E FF                  LD     A,TRUE               ;
2168: ED8D B7                     OR     A                    ;
2169: ED8E C9                     RET                         ;
2170: ED8F         ;--------------------------- Select Disk -----------------------------------;
2171: ED8F         ;--------------------------- Initialize Disk -------------------------------;
2172: ED8F             InitDisk:                       ;
2173: ED8F 2A AF F4               LD     HL,(dpbDSM)          ; Maximum allocation value			;
2174: ED92 CD 17 F3               CALL   DivideHLby8          ; Length of Map						;
2175: ED95 E5                     PUSH   HL                   ; Save Length						;
2176: ED96 E5                     PUSH   HL                   ; Save for end of MAP				;
2177: ED97 C1                     POP    BC                   ; BC = dpbDSM/8						;
2178: ED98         ; Clear the Allocation Vector												;
2179: ED98 2A A8 F4               LD     HL,(caAllocVector)   ; Allocation vector Start			;
2180: ED9B 36 00                  LD     (HL),0               ; Clear location					;
2181: ED9D ED 5B A8 F4               LD     DE,(caAllocVector)   ;
2182: EDA1 13                     INC    DE                   ; Allocation vector Start + 1		;
2183: EDA2 ED B0                  LDIR                        ; Cascade 00 thru Map				;
2184: EDA4         ; Force bits at End of Map													;
2185: EDA4 EB                     EX     DE,HL                ; Put last Map byte into DE			;
2186: EDA5 E1                     POP    HL                   ;
2187: EDA6 23                     INC    HL                   ;
2188: EDA7 CD 21 F3               CALL   MultiplyHLby8        ; Blocks if all bits used			;
2189: EDAA ED 4B AF F4               LD     BC,(dpbDSM)          ; Actual block max					;
2190: EDAE 03                     INC    BC                   ; Now has size of the Map			;
2191: EDAF AF                     XOR    A                    ; Clear CY							;
2192: EDB0 ED 42                  SBC    HL,BC                ; Extra unused bits					;
2193: EDB2 BD                     CP     L                    ;	are there any					;
2194: EDB3 28 07                  JR     Z,Mark4Directory     ;
2195: EDB5 45                     LD     B,L                  ; Number of bits to set				;
2196: EDB6 EB                     EX     DE,HL                ; Put last Map byte into HL			;
2197: EDB7             SetBitLoop:                      ;
2198: EDB7 37                     SCF                         ;
2199: EDB8 CB 16                  RL     (HL)                 ; Set LSB							;
2200: EDBA 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits				;
2201: EDBC         ;
2202: EDBC             Mark4Directory:                      ;
2203: EDBC         ; Mark the reserved space for the directory									;
2204: EDBC 2A B3 F4               LD     HL,(dpbDABM)         ; Directory block reserved bits		;
2205: EDBF EB                     EX     DE,HL                ;
2206: EDC0 2A A8 F4               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector		;
2207: EDC3 73                     LD     (HL),E               ;
2208: EDC4 23                     INC    HL                   ;
2209: EDC5 72                     LD     (HL),D               ; Put reserved blocks in Vector		;
2210: EDC6         ; end of Map																;
2211: EDC6         ; Home disk, and set current track and sector to 00							;
2212: EDC6 CD F8 EE               CALL   Home                 ;
2213: EDC9 2A 9C F4               LD     HL,(caDirMaxValue)   ;
2214: EDCC 36 03                  LD     (HL),3               ;
2215: EDCE 23                     INC    HL                   ;
2216: EDCF 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003		;
2217: EDD1 CD 4B F1               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)			;
2218: EDD4         ;
2219: EDD4             InitDisk1:                      ;
2220: EDD4         ; Process the directory														;
2221: EDD4 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum		;
2222: EDD6 CD 48 F3               CALL   ReadDirectory        ; Get the directory Record			;
2223: EDD9 CD 52 F1               CALL   AtEndOfDirectory     ; Are we Done ?						;
2224: EDDC C8                     RET    Z                    ;	Exit if Yes						;
2225: EDDD         ; Not end of directory, valid entry?										;
2226: EDDD CD 5B F1               CALL   GetCurrentDirectoryRecord ; Calculate location of the element ;
2227: EDE0 3E E5                  LD     A,emptyDir           ;
2228: EDE2 BE                     CP     M                    ; Is it an Empty Dir Entry			;
2229: EDE3 28 EF                  JR     Z,InitDisk1          ;	Loop back if yes				;
2230: EDE5         ; Not emptyDir, user code the same?											;
2231: EDE5 3A 93 F4               LD     A,(currentUserNumber) ;
2232: EDE8 BE                     CP     M                    ;
2233: EDE9 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users	;
2234: EDEB         ; Same user, check for '$' submit											;
2235: EDEB 23                     INC    HL                   ;
2236: EDEC 7E                     LD     A,(HL)               ;
2237: EDED D6 24                  SUB    DOLLAR               ; Is first Char a $					;
2238: EDEF 20 04                  JR     NZ,InitDisk2         ;
2239: EDF1         ; dollar file found, mark in exitParameterByte								;
2240: EDF1 3D                     DEC    A                    ; Set A to FFH						;
2241: EDF2 32 C1 EA               LD     (exitParameterByte),A ; Return it the exit parameter		;
2242: EDF5             InitDisk2:                      ;
2243: EDF5         ; now scan the disk map for allocated blocks								;
2244: EDF5 0E FF                  LD     C,TRUE               ; set to allocated					;
2245: EDF7 CD 7F F1               CALL   ScanDiskMap          ;
2246: EDFA CD 69 F1               CALL   SetDirectoryEntry    ; Mark directory entry				;
2247: EDFD 18 D5                  JR     InitDisk1            ; Loop for another entry			;
2248: EDFF         ;--------------------------- Initialize Disk -------------------------------;
2249: EDFF         ;----------------------------- Open File -----------------------------------;
2250: EDFF         ;search for the directory entry matching FCB at paramDE						;
2251: EDFF             OpenFile:                       ;
2252: EDFF 0E 0F                  LD     C,nameLength         ;
2253: EE01 CD 01 F0               CALL   SearchForDirectoryRecord ;
2254: EE04 CD 52 F1               CALL   AtEndOfDirectory     ; Have we gone thru all the dir		;
2255: EE07 C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
2256: EE08         ;
2257: EE08             CopyDirRecordToFCB:                      ;
2258: EE08 CD 9B EF               CALL   GetExtentAddress     ; HL points to FCB's EXT			;
2259: EE0B 7E                     LD     A,(HL)               ; Get the EXT						;
2260: EE0C F5                     PUSH   AF                   ; Save the FCB's EXT value			;
2261: EE0D E5                     PUSH   HL                   ;	also save FCB's pointer			;
2262: EE0E CD 5B F1               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL	;
2263: EE11 E5                     PUSH   HL                   ; Save Directory Record address		;
2264: EE12         ;
2265: EE12 ED 5B BF EA               LD     DE,(paramDE)         ;
2266: EE16 01 20 00               LD     BC,fcbLength         ;
2267: EE19 ED B0                  LDIR                        ; Move dir record to FCB			;
2268: EE1B         ;
2269: EE1B         ; note that entire fcb is copied, including indicators						;
2270: EE1B CD D6 EF               CALL   SetFileWriteFlag     ; Set clean file flag				;
2271: EE1E D1                     POP    DE                   ; Get Directory Record address		;
2272: EE1F 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index						;
2273: EE22 19                     ADD    HL,DE                ; Directory's EXT address			;
2274: EE23 4E                     LD     C,(HL)               ; Dir's EXT is in B					;
2275: EE24 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index			;
2276: EE27 19                     ADD    HL,DE                ; Directory's RC address			;
2277: EE28 46                     LD     B,(HL)               ; B holds Dir's	record count		;
2278: EE29 E1                     POP    HL                   ; Get FCB's Extent Address			;
2279: EE2A F1                     POP    AF                   ; Get FCB's Extent Value			;
2280: EE2B 77                     LD     (HL),A               ; Restore Extent Value				;
2281: EE2C         ; if user ext < dir ext then user := 128 records							;
2282: EE2C         ; if user ext = dir ext then user := dir records							;
2283: EE2C         ; if user ext > dir ext then user := 0 records								;
2284: EE2C 79                     LD     A,C                  ; Get the Dir's EXT					;
2285: EE2D BE                     CP     M                    ; Does it match the FCB'd			;
2286: EE2E 78                     LD     A,B                  ; Get the Dir's	record count		;
2287: EE2F 28 06                  JR     Z,OpenSetRecordCount ; If same EXT value, use it.		;
2288: EE31 3E 00                  LD     A,0                  ;	else prepare for RC = 0			;
2289: EE33 38 02                  JR     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr				;
2290: EE35 3E 80                  LD     A,RecordsPerExtent   ;	else max record count out		;
2291: EE37             OpenSetRecordCount:                      ;
2292: EE37 2A BF EA               LD     HL,(paramDE)         ; Get FCB's address					;
2293: EE3A 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index			;
2294: EE3D 19                     ADD    HL,DE                ; FCB's record count				;
2295: EE3E 77                     LD     (HL),A               ; Set the value						;
2296: EE3F C9                     RET                         ;
2297: EE40         ;----------------------------- Open File -----------------------------------;
2298: EE40         ;---------------------------- Close Directory Entry ------------------------;
2299: EE40             CloseDirEntry:                      ;
2300: EE40 AF                     XOR    A                    ;
2301: EE41 32 C1 EA               LD     (exitParameterByte),A ; Clear exit parameter				;
2302: EE44 CD 40 EF               CALL   IsDiskWriteProtected ; Return Z set if writable			;
2303: EE47 C0                     RET    NZ                   ; Skip close if r/o disk			;
2304: EE48         ; check file write flag - 0 indicates written								;
2305: EE48         ;
2306: EE48 DD E5                  PUSH   IX                   ;
2307: EE4A DD 2A BF EA               LD     IX,(paramDE)         ; FCB address						;
2308: EE4E DD CB 0E 7E               BIT    7,(IX+fcbS2Index)    ; Has WFF changed ?					;
2309: EE52 DD E1                  POP    IX                   ;
2310: EE54 C0                     RET    NZ                   ; Skip close if clean file			;
2311: EE55         ;
2312: EE55         ;	CALL	GetWriteFileFlagValue		; Get file's WriteFileFlag			;
2313: EE55         ;	BIT		7,A							;	Has it changed ?				;
2314: EE55         ;	RET		NZ							; Skip close if clean file			;
2315: EE55         ;
2316: EE55 0E 0F                  LD     C,nameLength         ;
2317: EE57 CD 01 F0               CALL   SearchForDirectoryRecord ; Find the file's directory record	;
2318: EE5A CD 52 F1               CALL   AtEndOfDirectory     ; If EOD then there is no more		;
2319: EE5D C8                     RET    Z                    ;	exit if at EOD					;
2320: EE5E         ;
2321: EE5E         ; merge the FCB's Disk Map with the Directory record Disk Map				;
2322: EE5E CD 5B F1               CALL   GetCurrentDirectoryRecord ; HL points to directory record		;
2323: EE61 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index		;
2324: EE64 09                     ADD    HL,BC                ;
2325: EE65 EB                     EX     DE,HL                ; DE = Directory Entry Map pointer	;
2326: EE66 2A BF EA               LD     HL,(paramDE)         ;
2327: EE69 09                     ADD    HL,BC                ; HL = FCB Map Pointer				;
2328: EE6A 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map				;
2329: EE6C         ;
2330: EE6C             MergeAllocationMaps:                      ;
2331: EE6C 3A C3 F4               LD     A,(byteAllocationFlag) ;
2332: EE6F B7                     OR     A                    ;
2333: EE70 28 10                  JR     Z,MergeWordMaps      ; Process Word size Block Numbers	;
2334: EE72         ; process byte size Map														;
2335: EE72 7E                     LD     A,(HL)               ; FCB Block number					;
2336: EE73 B7                     OR     A                    ; Is it 0 ?							;
2337: EE74 1A                     LD     A,(DE)               ;	anticipate yes					;
2338: EE75 20 01                  JR     NZ,MergeFCBisNot0    ;	Skip if no						;
2339: EE77 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2340: EE78             MergeFCBisNot0:                      ;
2341: EE78 B7                     OR     A                    ; Is Dir Entry Value = 0 ?			;
2342: EE79 20 02                  JR     NZ,MergeDirEntryNot0 ; Skip if no						;
2343: EE7B 7E                     LD     A,(HL)               ;	else move FCB map value			;
2344: EE7C 12                     LD     (DE),A               ;	to Dir Entry Value 				;
2345: EE7D             MergeDirEntryNot0:                      ;
2346: EE7D BE                     CP     M                    ; Do FCB and Dir match values		;
2347: EE7E 20 39                  JR     NZ,CloseDirEntryError ;	If not then report error		;
2348: EE80 18 13                  JR     MergeMapLoop         ; Go see if there is more			;
2349: EE82         ;
2350: EE82             MergeWordMaps:                      ;
2351: EE82 CD 2B F3               CALL   Merge                ; If FCB map value = 0 move Dir's	;
2352: EE85 EB                     EX     DE,HL                ;
2353: EE86 CD 2B F3               CALL   Merge                ; IF Dir Map value = 0 move FCB's	;
2354: EE89 EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's	;
2355: EE8A 1A                     LD     A,(DE)               ; Does the FCB Map value			;
2356: EE8B BE                     CP     M                    ;	= Dir record Map pointer ?		;
2357: EE8C 20 2B                  JR     NZ,CloseDirEntryError ;	If not then report error		;
2358: EE8E 13                     INC    DE                   ;
2359: EE8F 23                     INC    HL                   ; move on to the MSB				;
2360: EE90 1A                     LD     A,(DE)               ;
2361: EE91 BE                     CP     M                    ; do the check for equality			;
2362: EE92 20 25                  JR     NZ,CloseDirEntryError ;	If not then report error		;
2363: EE94 0D                     DEC    C                    ; Extra count for 2 bytes			;
2364: EE95             MergeMapLoop:                      ;
2365: EE95 13                     INC    DE                   ; Advance to the next positions		;
2366: EE96 23                     INC    HL                   ; in The Maps						;
2367: EE97 0D                     DEC    C                    ; Are we done ?						;
2368: EE98 20 D2                  JR     NZ,MergeAllocationMaps ;	No, do it again					;
2369: EE9A         ;
2370: EE9A         ; Check the EXT																	;
2371: EE9A 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer			;
2372: EE9D 09                     ADD    HL,BC                ;
2373: EE9E EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer	;
2374: EE9F 09                     ADD    HL,BC                ; DE = FCB EXT Pointer				;
2375: EEA0 1A                     LD     A,(DE)               ; FCB's extent number				;
2376: EEA1 BE                     CP     M                    ; Is it < Dir Record EXT ?			;
2377: EEA2 38 09                  JR     C,CloseDirEntryEnd   ;	we are done if yes				;
2378: EEA4 77                     LD     (HL),A               ; Else replace the Dir Record EXT	;
2379: EEA5         ; Update directory record count field										;
2380: EEA5 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2381: EEA8 09                     ADD    HL,BC                ;
2382: EEA9 EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2383: EEAA 09                     ADD    HL,BC                ; HL = FCB EXT Pointer				;
2384: EEAB 7E                     LD     A,(HL)               ; Copy the FCB RC to				;
2385: EEAC 12                     LD     (DE),A               ;	the Directory Record RC			;
2386: EEAD         ;
2387: EEAD             CloseDirEntryEnd:                      ;
2388: EEAD 3E FF                  LD     A,TRUE               ;
2389: EEAF 32 BC F4               LD     (fcbCopiedFlag),A    ; Set copied flag as true			;
2390: EEB2         ;/	CALL	SeekCopy					; ok to "Write Dir" here			;
2391: EEB2 CD 76 F3               CALL   SeekDir              ; Set up parameters for a Disk I/O	;
2392: EEB5 C3 74 F0               JP     WriteDir             ; Write the directory element		;
2393: EEB8 C9                     RET                         ;
2394: EEB9         ;
2395: EEB9             CloseDirEntryError:                      ;
2396: EEB9 21 C1 EA               LD     HL,exitParameterByte ;
2397: EEBC 35                     DEC    M                    ; Set Exit value to 0FFH			;
2398: EEBD C9                     RET                         ;
2399: EEBE         ;---------------------------- Close Directory Entry ------------------------;
2400: EEBE         ;----------------------------------- Make new File -------------------------;
2401: EEBE         ;create a new file by creating a directory entry then opening the file		;
2402: EEBE             MakeNewFile:                      ;
2403: EEBE CD 34 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O	;
2404: EEC1 2A BF EA               LD     HL,(paramDE)         ; Get the FCB						;
2405: EEC4 E5                     PUSH   HL                   ; FCB								;
2406: EEC5 21 95 F4               LD     HL,emptyFCB          ;
2407: EEC8 22 BF EA               LD     (paramDE),HL         ; Find the first empty dir record	;
2408: EECB 0E 01                  LD     C,1                  ;
2409: EECD CD 01 F0               CALL   SearchForDirectoryRecord ; 0F5H in first position			;
2410: EED0 CD 52 F1               CALL   AtEndOfDirectory     ; Check if at end of directory		;
2411: EED3 E1                     POP    HL                   ; Recall the FCB pointer			;
2412: EED4 22 BF EA               LD     (paramDE),HL         ;	in case we return here			;
2413: EED7 C8                     RET    Z                    ; Exit with No Dir space error		;
2414: EED8         ; fill Allocation Map with Zeros											;
2415: EED8 11 0F 00               LD     DE,nameLength        ;
2416: EEDB 19                     ADD    HL,DE                ; Start of fill						;
2417: EEDC 36 00                  LD     (HL),00              ; Prime the values					;
2418: EEDE E5                     PUSH   HL                   ;
2419: EEDF D1                     POP    DE                   ; Copy to DE						;
2420: EEE0 13                     INC    DE                   ; adjust the to pointer				;
2421: EEE1 01 10 00               LD     BC,fcbLength-nameLength-1 ; number of bytes to fill			;
2422: EEE4 ED B0                  LDIR                        ;
2423: EEE6         ;
2424: EEE6 2A BF EA               LD     HL,(paramDE)         ; get FCB							;
2425: EEE9 11 0D 00               LD     DE,fcbS1Index        ; Get the S1 index					;
2426: EEEC 19                     ADD    HL,DE                ; Point to S1						;
2427: EEED 36 00                  LD     (HL),0               ; Set to 0							;
2428: EEEF CD 69 F1               CALL   SetDirectoryEntry    ; Update directory entry			;
2429: EEF2 CD 48 F2               CALL   CopyFCB              ; Update dir entry to Disk			;
2430: EEF5         ; and set the file write flag to "1"										;
2431: EEF5 C3 D6 EF               JP     SetFileWriteFlag     ; Set the clean entry flag			;
2432: EEF8         ;----------------------------------- Make new File -------------------------;
2433: EEF8         ;=========================== Disk Utilities ================================;
2434: EEF8         ;--------------------------- Home The Current Disk -------------------------;
2435: EEF8         ;move to home position, then offset to start of dir							;
2436: EEF8             Home:                           ;
2437: EEF8 CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks		;
2438: EEFB         ; if Buffer needs to be written		;
2439: EEFB 21 B7 F4               LD     HL,dpbOFF            ; Number of tracks before directory ;
2440: EEFE 4E                     LD     C,(HL)               ;
2441: EEFF 23                     INC    HL                   ;
2442: EF00 46                     LD     B,(HL)               ;
2443: EF01 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position	;
2444: EF04         ;
2445: EF04         ; Set Current Track and Sector to 00										;
2446: EF04 AF                     XOR    A                    ; set ACC to 00						;
2447: EF05 2A 9E F4               LD     HL,(caTrack)         ;
2448: EF08 77                     LD     (HL),A               ;
2449: EF09 23                     INC    HL                   ;
2450: EF0A 77                     LD     (HL),A               ;
2451: EF0B 2A A0 F4               LD     HL,(caSector)        ;
2452: EF0E 77                     LD     (HL),A               ;
2453: EF0F 23                     INC    HL                   ;
2454: EF10 77                     LD     (HL),A               ;
2455: EF11 C9                     RET                         ;
2456: EF12         ;
2457: EF12         ;--------------------------- Home The Current Disk -------------------------;
2458: EF12         ;--------------------------- Set DMAs --------------------------------------;
2459: EF12             SetDataDMA:                      ;
2460: EF12 21 9A F4               LD     HL,initDAMAddress    ;
2461: EF15 18 03                  JR     SetDMA               ; Skip to complete the call			;
2462: EF17         ;
2463: EF17             SetDirDMA:                      ;
2464: EF17 21 A2 F4               LD     HL,caDirectoryDMA    ; Load current directory Buffer		;
2465: EF1A         ;
2466: EF1A             SetDMA:                         ;
2467: EF1A 4E                     LD     C,(HL)               ;
2468: EF1B 23                     INC    HL                   ;
2469: EF1C 46                     LD     B,(HL)               ; parameter ready				;
2470: EF1D C3 24 F6               JP     bcSetdma             ; call bios to set				;
2471: EF20         ;--------------------------- Set DMAs --------------------------------------;
2472: EF20         ;--------------------------- Read Buffer -----------------------------------;
2473: EF20         ;reads into current DMA, using current Disk,Track and Sector				;
2474: EF20             ReadBuffer:                      ;
2475: EF20 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level		;
2476: EF23 B7                     OR     A                    ; Check status						;
2477: EF24 C2 34 F4               JP     NZ,Error_BadSector   ; Report if Status not OK		;
2478: EF27 C9                     RET                         ;
2479: EF28         ;--------------------------- Read Buffer -----------------------------------;
2480: EF28         ;--------------------------- Set Current Disk Read Only --------------------;
2481: EF28         ;set current disk to read only												;
2482: EF28             SetDiskReadOnly:                      ;
2483: EF28 2A 96 F4               LD     HL,(readOnlyVector)  ; Get the Vector					;
2484: EF2B         ;
2485: EF2B 3A 94 F4               LD     A,(currentDisk)      ; Get the current disk				;
2486: EF2E 47                     LD     B,A                  ; Move into B						;
2487: EF2F CD 04 F4               CALL   SetVectorBit         ; Set the bit						;
2488: EF32 22 96 F4               LD     (readOnlyVector),HL  ; Update the Vector					;
2489: EF35         ;
2490: EF35 2A B1 F4               LD     HL,(dpbDRM)          ; Directory Max Value				;
2491: EF38 EB                     EX     DE,HL                ;
2492: EF39 2A 9C F4               LD     HL,(caDirMaxValue)   ; HL = .Directory max value			;
2493: EF3C 73                     LD     (HL),E               ;
2494: EF3D 23                     INC    HL                   ;
2495: EF3E 72                     LD     (HL),D               ;
2496: EF3F C9                     RET                         ;
2497: EF40         ;--------------------------- Set disk Read Only ----------------------------;
2498: EF40         ;--------------------------- Is Disk Write Protected -----------------------;
2499: EF40         ;Returns:	Z flag	= Set if not Write Protected	(Z)						;
2500: EF40         ;					= reset if Write Protected		(NZ)					;
2501: EF40             IsDiskWriteProtected:                      ;
2502: EF40 2A 96 F4               LD     HL,(readOnlyVector)  ; Get Read Only Vector				;
2503: EF43 3A 94 F4               LD     A,(currentDisk)      ; Get current disk					;
2504: EF46 47                     LD     B,A                  ;
2505: EF47 CD F4 F3               CALL   IsBitSet             ; Check the bit						;
2506: EF4A C9                     RET                         ; NZ if Disk is RO					;
2507: EF4B         ;--------------------------- Is Disk Write Protected -----------------------;
2508: EF4B         ;------------------------- Reselect Disk if Necessary ----------------------;
2509: EF4B         ;check current fcb to see if reselection necessary							;
2510: EF4B             ReselectDisk:                      ;
2511: EF4B 3E FF                  LD     A,TRUE               ;
2512: EF4D 32 C4 F4               LD     (fResel),A           ; Mark as possible reselect			;
2513: EF50 2A BF EA               LD     HL,(paramDE)         ; Point at current FCB				;
2514: EF53 7E                     LD     A,(HL)               ; Load disk drive (0 = current)		;
2515: EF54 E6 1F                  AND    01FH                 ; Mask out user Number ??			;
2516: EF56 3D                     DEC    A                    ; Normalized to 0..29, or 255		;
2517: EF57 32 BE EA               LD     (paramE),A           ; Save drive code					;
2518: EF5A FE 1E                  CP     30                   ;
2519: EF5C 30 10                  JR     NC,NoSelect          ; Skip drive >= 30					;
2520: EF5E         ;
2521: EF5E 3A 94 F4               LD     A,(currentDisk)      ; Determine the current drive		;
2522: EF61 32 C5 F4               LD     (entryDisk),A        ; Save it							;
2523: EF64 7E                     LD     A,(HL)               ;
2524: EF65 32 C6 F4               LD     (fcbDisk),A          ; Get calling disk					;
2525: EF68 E6 E0                  AND    11100000B            ;
2526: EF6A 77                     LD     (HL),A               ; Preserve User Number				;
2527: EF6B CD 1D ED               CALL   SelectCurrent        ; Select the new disk				;
2528: EF6E         ;
2529: EF6E             NoSelect:                       ;
2530: EF6E 3A 93 F4               LD     A,(currentUserNumber) ; Get user code 0...31				;
2531: EF71 2A BF EA               LD     HL,(paramDE)         ; Point at disk number				;
2532: EF74 B6                     OR     M                    ; Combine							;
2533: EF75 77                     LD     (HL),A               ; FCB[0] = user number & disk		;
2534: EF76 C9                     RET                         ;
2535: EF77         ;------------------------- Reselect Disk if Necessary ----------------------;
2536: EF77         ;=========================== Disk Utilities ================================;
2537: EF77         ;=========================== File Utilities ================================;
2538: EF77         ;--------------------------- Set Record Variables --------------------------;
2539: EF77         ;set variables from currently FCB - Current Record, RC, EXM					;
2540: EF77             SetRecordVars:                      ;
2541: EF77 CD 8E EF               CALL   GetFcbRecordDetails  ; DE = .RecordCount					;
2542: EF7A         ;	and HL => .CurrentRecord		;
2543: EF7A 7E                     LD     A,(HL)               ;
2544: EF7B 32 C9 F4               LD     (currentFileRecord),A ; Save current record				;
2545: EF7E EB                     EX     DE,HL                ;
2546: EF7F 7E                     LD     A,(HL)               ;
2547: EF80 32 C7 F4               LD     (fcbRecordCount),A   ; Save the FCBs RC					;
2548: EF83 CD 9B EF               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)				;
2549: EF86 3A AE F4               LD     A,(dpbEXM)           ; Extent mask						;
2550: EF89 A6                     AND    M                    ; Remove unwanted bits				;
2551: EF8A 32 C8 F4               LD     (extentValue),A      ; Store the value					;
2552: EF8D C9                     RET                         ;
2553: EF8E         ;--------------------------- Set Record Variables --------------------------;
2554: EF8E         ;----------------------Get File Record Count and Current Record-------------;
2555: EF8E         ; returns with DE pointing at RC from FCB									;
2556: EF8E         ;		with HL pointing at Current Record									;
2557: EF8E             GetFcbRecordDetails:                      ;
2558: EF8E 2A BF EA               LD     HL,(paramDE)         ; Get FCB start						;
2559: EF91 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count			;
2560: EF94 19                     ADD    HL,DE                ;
2561: EF95 EB                     EX     DE,HL                ; DE Points to Record Count			;
2562: EF96 21 11 00               LD     HL,recordSeq-fcbRCIndex ;
2563: EF99 19                     ADD    HL,DE                ; HL Points to Current Record		;
2564: EF9A C9                     RET                         ;
2565: EF9B         ;----------------------Get File Record Count and Current Record-------------;
2566: EF9B         ;----------------------Get FileExtent---------------------------------------;
2567: EF9B         ;get current extent field address to (HL)									;
2568: EF9B             GetExtentAddress:                      ;
2569: EF9B 2A BF EA               LD     HL,(paramDE)         ; Get FCB							;
2570: EF9E 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset					;
2571: EFA1 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)				;
2572: EFA2 C9                     RET                         ;
2573: EFA3         ;----------------------Get FileExtent---------------------------------------;
2574: EFA3         ;--------------------- Set/Reset Disk Map Allocation Bit -------------------;
2575: EFA3         ; At Entry:	BC Contains to the Block to be modified							;
2576: EFA3         ;			E	= TRUE if bit is to be set									;
2577: EFA3         ;			E	<> TRUE if bit is to be reset								;
2578: EFA3         ; At Exit:	The target bit in the target Octet will be set/reset			;
2579: EFA3             SetResetMapBit:                      ;
2580: EFA3         ;
2581: EFA3 21 00 00               LD     HL,0000H             ; Move the block number from BC		;
2582: EFA6 09                     ADD    HL,BC                ;	to HL							;
2583: EFA7 4B                     LD     C,E                  ; Move the flag to E				;
2584: EFA8         ;
2585: EFA8 7D                     LD     A,L                  ; LSB of the Block Number			;
2586: EFA9 E6 07                  AND    07H                  ; Calculate Mod(Block,8)			;
2587: EFAB F5                     PUSH   AF                   ; Save the OctetBit					;
2588: EFAC 06 03                  LD     B,3                  ;
2589: EFAE CD 19 F3               CALL   ShiftRightHLbyB      ; Calculate Block / 8				;
2590: EFB1 ED 5B A8 F4               LD     DE,(caAllocVector)   ; Start Of Map						;
2591: EFB5 19                     ADD    HL,DE                ; Address of targeted Octet			;
2592: EFB6 F1                     POP    AF                   ;
2593: EFB7 47                     LD     B,A                  ; Get the bit						;
2594: EFB8         ;
2595: EFB8 04                     INC    B                    ; Adjust for looping				;
2596: EFB9 C5                     PUSH   BC                   ; Will need this later				;
2597: EFBA             Left:                           ;
2598: EFBA CB 16                  RL     (HL)                 ; Rotate the Octet					;
2599: EFBC 10 FC                  DJNZ   Left                 ;	to move target bit to bit 0		;
2600: EFBE C1                     POP    BC                   ; Restore loop limit and			;
2601: EFBF 37                     SCF                         ;	set/reset flag					;
2602: EFC0 0C                     INC    C                    ; was C = TRUE						;
2603: EFC1 28 01                  JR     Z,Right              ; Skip if Set						;
2604: EFC3 3F                     CCF                         ; Set for Reset						;
2605: EFC4             Right:                          ;
2606: EFC4 CB 1E                  RR     (HL)                 ; Move the Octet back				;
2607: EFC6 10 FC                  DJNZ   Right                ;	to its original alignment		;
2608: EFC8 C9                     RET                         ;
2609: EFC9         ;--------------------- Set/Reset Disk Map Allocation Bit -------------------;
2610: EFC9         ;--------------------- Initialize Extent Number MSB ------------------------;
2611: EFC9         ;clear the Extent number field for user open/make (S2)						;
2612: EFC9             InitializeExtentNumberMSB:                      ;
2613: EFC9 DD E5                  PUSH   IX                   ;
2614: EFCB DD 2A BF EA               LD     IX,(paramDE)         ; FCB address						;
2615: EFCF DD 36 0E 00               LD     (IX+fcbS2Index),0    ; Clear value						;
2616: EFD3 DD E1                  POP    IX                   ;
2617: EFD5 C9                     RET                         ;
2618: EFD6         ;
2619: EFD6         ;--------------------- Initialize Extent Number MSB ------------------------;
2620: EFD6         ;--------------------------- Set File Write Flag----------------------------;
2621: EFD6         ;Set file write flag in FCB in (paramDE)									;
2622: EFD6         ; Used to indicate the FCB is clean. No need to write on close				;
2623: EFD6             SetFileWriteFlag:                      ;
2624: EFD6 DD E5                  PUSH   IX                   ;
2625: EFD8 DD 2A BF EA               LD     IX,(paramDE)         ; FCB address						;
2626: EFDC DD CB 0E FE               SET    7,(IX+fcbS2Index)    ; Set Flag							;
2627: EFE0 DD E1                  POP    IX                   ;
2628: EFE2 C9                     RET                         ;
2629: EFE3         ;
2630: EFE3         ;--------------------------- Set File Write Flag----------------------------;
2631: EFE3         ;--------------------------- Reset File Write Flag--------------------------;
2632: EFE3         ;Reset file write flag in FCB in (paramDE)									;
2633: EFE3         ; Used to indicate the FCB is dirty. Need to write on close					;
2634: EFE3             ResetFileWriteFlag:                      ;
2635: EFE3 DD E5                  PUSH   IX                   ;
2636: EFE5 DD 2A BF EA               LD     IX,(paramDE)         ; FCB address						;
2637: EFE9 DD CB 0E BE               RES    7,(IX+fcbS2Index)    ; Reset Flag						;
2638: EFED DD E1                  POP    IX                   ;
2639: EFEF C9                     RET                         ;
2640: EFF0         ;--------------------------- Reset File Write Flag--------------------------;
2641: EFF0         ;-------------------------- Compare FCB Extents ----------------------------;
2642: EFF0         ; Enters:	A containing Target FCB EXT value								;
2643: EFF0         ;			HL Points at Possible FCB EXT value								;
2644: EFF0         ;compare extent# in A with that in C, return nonzero if they do not match	;
2645: EFF0             CompareExtents:                      ;
2646: EFF0 C5                     PUSH   BC                   ; Save Callers Registers			;
2647: EFF1 F5                     PUSH   AF                   ; Save Target FCB EXT value			;
2648: EFF2 3A AE F4               LD     A,(dpbEXM)           ; Load the Extent Mask				;
2649: EFF5 2F                     CPL                         ; Complement for And				;
2650: EFF6 47                     LD     B,A                  ; Put negated Mask into B			;
2651: EFF7 7E                     LD     A,(HL)               ; Get Possible FCBs EXT				;
2652: EFF8 A0                     AND    B                    ; Apply the Mask					;
2653: EFF9 4F                     LD     C,A                  ; Low bits removed from C			;
2654: EFFA F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2655: EFFB A0                     AND    B                    ; Apply the Mask					;
2656: EFFC 91                     SUB    C                    ; Test if Equal ( Z Flag)			;
2657: EFFD E6 1F                  AND    maxExtValue          ; Limit Size ?						;
2658: EFFF C1                     POP    BC                   ; Restore Callers Registers			;
2659: F000 C9                     RET                         ;
2660: F001         ;-------------------------- Compare FCB Extents ----------------------------;
2661: F001         ;---------------------Search for Directory Record --------------------------;
2662: F001         ;	Search for directory record of length C.								;
2663: F001         ; Target is pointed to by paramDE. The whole directory is searched.			;
2664: F001         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2665: F001         ; matched directory record													;
2666: F001         ; Entry:	C = Search Length												;
2667: F001         ; Exit		dirEntryIndex	=	Matched directory index, if found			;
2668: F001         ;								-1 (EOD) if there is no match				;
2669: F001             SearchForDirectoryRecord:                      ;
2670: F001 3E FF                  LD     A,0FFH               ;
2671: F003 32 BE F4               LD     (directoryIndex),A   ; Initialize directory Index		;
2672: F006 21 C0 F4               LD     HL,searchLength      ;
2673: F009 71                     LD     (HL),C               ; Save Search Length				;
2674: F00A 2A BF EA               LD     HL,(paramDE)         ; Active FCB						;
2675: F00D 22 C1 F4               LD     (searchAddress),HL   ; Start of search					;
2676: F010 CD 4B F1               CALL   SetEndDirectory      ; DirEntryIndex = -1				;
2677: F013 CD F8 EE               CALL   Home                 ; Reset Disk,Track, & Sector		;
2678: F016         ;
2679: F016             GetNextDirectoryRecord:                      ;
2680: F016 0E 00                  LD     C,FALSE              ;
2681: F018 CD 48 F3               CALL   ReadDirectory        ; Read next Dir Record				;
2682: F01B CD 52 F1               CALL   AtEndOfDirectory     ;
2683: F01E 28 4B                  JR     Z,NoDirRecordsMatch  ; Done if at EOD				;
2684: F020         ;
2685: F020 2A C1 F4               LD     HL,(searchAddress)   ; Get Current Dir Entry				;
2686: F023 EB                     EX     DE,HL                ; DE=beginning of Directory Entry	;
2687: F024 1A                     LD     A,(DE)               ; User Number						;
2688: F025 FE E5                  CP     emptyDir             ; Is Dir entry is empty				;
2689: F027 28 07                  JR     Z,GetNextDirectoryRecord1 ; Skip if empty						;
2690: F029         ;
2691: F029         ; Check to be sure we are sill in the Directory								;
2692: F029 D5                     PUSH   DE                   ; Save search address				;
2693: F02A CD 72 F1               CALL   StillInDirectory     ; Still in the directorY			;
2694: F02D D1                     POP    DE                   ; Recall address					;
2695: F02E 30 3B                  JR     NC,NoDirRecordsMatch ; Get out if past directory			;
2696: F030         ;
2697: F030             GetNextDirectoryRecord1:                      ;
2698: F030 CD 5B F1               CALL   GetCurrentDirectoryRecord ; Point at next directory record	;
2699: F033 3A C0 F4               LD     A,(searchLength)     ;
2700: F036 4F                     LD     C,A                  ; SearchLength to c (down)			;
2701: F037 06 00                  LD     B,0                  ; Character Index (up)				;
2702: F039         ;
2703: F039             TestNextPosition:                      ;
2704: F039 1A                     LD     A,(DE)               ;
2705: F03A FE 3F                  CP     QMARK                ; ? is always a char match			;
2706: F03C 28 16                  JR     Z,SetNextPosition    ; Done with this if it is ?		;
2707: F03E         ;
2708: F03E 78                     LD     A,B                  ;
2709: F03F FE 0D                  CP     fcbS1Index           ; At File S1 position ?				;
2710: F041 28 11                  JR     Z,SetNextPosition    ; Done with this if it is ?		;
2711: F043         ; not the fcbS1Index field, extent field?									;
2712: F043 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?			;
2713: F045 1A                     LD     A,(DE)               ; Get next character				;
2714: F046 28 07                  JR     Z,CheckExtents       ; Skip to search extent				;
2715: F048 96                     SUB    M                    ; Do they match ?					;
2716: F049 E6 7F                  AND    07FH                 ; Strip MSBit						;
2717: F04B 20 C9                  JR     NZ,GetNextDirectoryRecord ; Skip if not matched				;
2718: F04D 18 05                  JR     SetNextPosition      ; Matched the character				;
2719: F04F         ;																			;
2720: F04F             CheckExtents:                      ;
2721: F04F CD F0 EF               CALL   CompareExtents       ; Matching EXTs is work				;
2722: F052 20 C2                  JR     NZ,GetNextDirectoryRecord ; Get out if not matched			;
2723: F054         ;
2724: F054             SetNextPosition:                      ;
2725: F054 13                     INC    DE                   ; Pointer to Looking FOR			;
2726: F055 23                     INC    HL                   ; Pointer to Looking IN				;
2727: F056 04                     INC    B                    ; Character Index in FCB			;
2728: F057 0D                     DEC    C                    ; Length of search					;
2729: F058 20 DF                  JR     NZ,TestNextPosition  ;
2730: F05A         ; Match Found, entire name matches											;
2731: F05A 3A CE F4               LD     A,(dirEntryIndex)    ; Get current Directory Index		;
2732: F05D E6 03                  AND    dirEntryMask         ; Apply the mask					;
2733: F05F 32 C1 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund			;
2734: F062         ;
2735: F062 21 BE F4               LD     HL,directoryIndex    ; Point at Directory Flag			;
2736: F065 7E                     LD     A,(HL)               ; Get value							;
2737: F066 17                     RLA                         ; Set Carry if Flag = -1			;
2738: F067 D0                     RET    NC                   ; Return with flag still -1			;
2739: F068         ;
2740: F068 AF                     XOR    A                    ; Else Clear the flag				;
2741: F069 77                     LD     (HL),A               ;
2742: F06A C9                     RET                         ;	and exit						;
2743: F06B         ;------																		;
2744: F06B             NoDirRecordsMatch:                      ;
2745: F06B CD 4B F1               CALL   SetEndDirectory      ; Set End of Directory -1			;
2746: F06E 3E FF                  LD     A,-1                 ; Put Failure Code					;
2747: F070 32 C1 EA               LD     (exitParameterByte),A ;	into return parameter			;
2748: F073 C9                     RET                         ;
2749: F074         ;---------------------Search for Directory Record --------------------------;
2750: F074         ;---------------------------- Write Current Directory Entry ----------------;
2751: F074             WriteDir:                       ;
2752: F074         ;	CALL	NewCheckSum						; initialize entry				;
2753: F074 0E FF                  LD     C,TRUE               ;
2754: F076 CD C5 F3               CALL   CheckSumUtility      ; Set New CheckSum				;
2755: F079         ;
2756: F079 CD 17 EF               CALL   SetDirDMA            ; Directory DMA					;
2757: F07C 0E 01                  LD     C,WriteDirectory     ; Write type					;
2758: F07E CD 84 F0               CALL   WriteBuffer          ; Write the buffer				;
2759: F081 C3 12 EF               JP     SetDataDMA           ; Reset DMA to default			;
2760: F084         ;
2761: F084         ;---------------------------- Write Current Directory Entry ----------------;
2762: F084         ;----------------------------------- Write Buffer --------------------------;
2763: F084         ; Write buffer and check result. Current drive,Track, Sector and DMA		;
2764: F084         ; Are set up prior to calling this routine									;
2765: F084         ;																			;
2766: F084         ; On Entry: C = 0 => normal write operation		WriteAllocated				;
2767: F084         ;				1 => directory write operation	WriteDirectory				;
2768: F084         ;				2 => start of new block			WriteCleanBuffer			;
2769: F084             WriteBuffer:                      ;
2770: F084 CD 2A F6               CALL   bcWrite              ; Call into BIOS					;
2771: F087 B7                     OR     A                    ; Get return code					;
2772: F088 C2 34 F4               JP     NZ,Error_BadSector   ; Error if not 00						;
2773: F08B C9                     RET                         ;
2774: F08C         ;----------------------------------- Write Buffer --------------------------;
2775: F08C         ;---------------------------- Update Record Vars ---------------------------;
2776: F08C         ;update variables from I/O in	FCB											;
2777: F08C             UpdateRecordVariables:                      ;
2778: F08C CD 8E EF               CALL   GetFcbRecordDetails  ; DE => FCB RC, HL => CurrentRecord ;
2779: F08F 3A B9 F4               LD     A,(diskAccessType)   ; If Seq IO it is set to 1			;
2780: F092 4F                     LD     C,A                  ;	and move it to C				;
2781: F093 3A C9 F4               LD     A,(currentFileRecord) ; Get NEXT_RECORD					;
2782: F096 81                     ADD    A,C                  ; Update record count				;
2783: F097 77                     LD     (HL),A               ;	for CurrentRecord				;
2784: F098 EB                     EX     DE,HL                ;
2785: F099 3A C7 F4               LD     A,(fcbRecordCount)   ;
2786: F09C 77                     LD     (HL),A               ;	and FCB RC						;
2787: F09D C9                     RET                         ;
2788: F09E         ;---------------------------- Update Record Vars ---------------------------;
2789: F09E         ;-------------------------------- Random Seek ------------------------------;
2790: F09E         ;	Record # = |000M EEEE| |ERRR RRRR|										;
2791: F09E         ;		M => Module															;
2792: F09E         ;		E => Extent															;
2793: F09E         ;		R => Record in Extent												;
2794: F09E             RandomSeek:                      ;
2795: F09E AF                     XOR    A                    ;
2796: F09F 32 B9 F4               LD     (diskAccessType),A   ; Set random access					;
2797: F0A2 C5                     PUSH   BC                   ; Save Read(TRUE) / Write (FALSE)	;
2798: F0A3 DD 2A BF EA               LD     IX,(paramDE)         ; Get the FCB						;
2799: F0A7 DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record		;
2800: F0AA E6 7F                  AND    7FH                  ; Strip E , left with |0RRR RRRR|	;
2801: F0AC F5                     PUSH   AF                   ; recordSEQ							;
2802: F0AD DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record		;
2803: F0B0 17                     RLA                         ; CY = bit 7 from LSB (M's LSBit)	;
2804: F0B1 DD 7E 22               LD     A,(IX+recordRandomMSB) ; Get MSB from Random Record		;
2805: F0B4 F5                     PUSH   AF                   ; Random record's MSB				;
2806: F0B5 17                     RLA                         ; Shift LSBit into E |00ME EEEE|	;
2807: F0B6 E6 1F                  AND    01FH                 ; Extent mask						;
2808: F0B8 4F                     LD     C,A                  ; Extent is in C					;
2809: F0B9 F1                     POP    AF                   ; Random record's MSB				;
2810: F0BA 1F                     RRA                         ;
2811: F0BB 1F                     RRA                         ;
2812: F0BC 1F                     RRA                         ;
2813: F0BD 1F                     RRA                         ; MSB's Hi Nibble					;
2814: F0BE E6 0F                  AND    00FH                 ;	moved to Lo Nibble				;
2815: F0C0 47                     LD     B,A                  ; S2' value in B					;
2816: F0C1 F1                     POP    AF                   ; recordSEQ							;
2817: F0C2         ;
2818: F0C2 DD 6E 23               LD     L,(IX+recordRandomOVF) ;
2819: F0C5 2C                     INC    L                    ; Insure that high byte				;
2820: F0C6 2D                     DEC    L                    ;	of ran rec = 00					;
2821: F0C7 2E 06                  LD     L,06                 ; "attempt to read beyond end of disk"	;
2822: F0C9 20 4B                  JR     NZ,RandomSeekError   ;
2823: F0CB         ;
2824: F0CB DD 77 20               LD     (IX+recordSeq),A     ; Put target record # in FCB		;
2825: F0CE DD 7E 0C               LD     A,(IX+fcbExtIndex)   ; Target EXT in A, FCB EXT in C		;
2826: F0D1 B9                     CP     C                    ; Are we in the right directory ?	;
2827: F0D2 20 08                  JR     NZ,RandomSeekClose   ;	Skip if not						;
2828: F0D4         ;
2829: F0D4 DD 7E 0E               LD     A,(IX+fcbS2Index)    ; Target S2 in A, FCB S2 in C		;
2830: F0D7 B8                     CP     B                    ; Still in the right directory ?	;
2831: F0D8 E6 7F                  AND    7FH                  ; Mask out MSBit					;
2832: F0DA 28 30                  JR     Z,RandomSeekExit     ;	Exit if yes						;
2833: F0DC         ;
2834: F0DC             RandomSeekClose:                      ;
2835: F0DC C5                     PUSH   BC                   ; Save EXT							;
2836: F0DD D5                     PUSH   DE                   ; Save FCB							;
2837: F0DE CD 40 EE               CALL   CloseDirEntry        ; Close this directory entry		;
2838: F0E1 D1                     POP    DE                   ; FCB								;
2839: F0E2 C1                     POP    BC                   ; EXT								;
2840: F0E3 2E 03                  LD     L,03                 ; "CP/M could not close current extent" ;
2841: F0E5 3A C1 EA               LD     A,(exitParameterByte) ; Get result from Close				;
2842: F0E8 3C                     INC    A                    ;
2843: F0E9 28 27                  JR     Z,RandomSeekErrorBadSeek ; Error exit if 0FFH				;
2844: F0EB         ;
2845: F0EB DD 71 0C               LD     (IX+fcbExtIndex),C   ; Update FCB Ext value				;
2846: F0EE DD 70 0E               LD     (IX+fcbS2Index),B    ; Update FCB S2 value				;
2847: F0F1 CD FF ED               CALL   OpenFile             ; Open the targeted Dir entry		;
2848: F0F4 3A C1 EA               LD     A,(exitParameterByte) ; is the file present?				;
2849: F0F7 3C                     INC    A                    ;
2850: F0F8 20 12                  JR     NZ,RandomSeekExit    ; Exit if open successful			;
2851: F0FA         ; cannot open the file, read mode?											;
2852: F0FA C1                     POP    BC                   ; Get Read/Write flag				;
2853: F0FB C5                     PUSH   BC                   ; Read/Write flag					;
2854: F0FC 2E 04                  LD     L,04                 ; "attempt to read unwritten extent"	;
2855: F0FE 0C                     INC    C                    ; Becomes 00 if read operation		;
2856: F0FF 28 11                  JR     Z,RandomSeekErrorBadSeek ; Error exit if read operation		;
2857: F101         ;
2858: F101 CD BE EE               CALL   MakeNewFile          ; Make Directory Entry				;
2859: F104 2E 05                  LD     L,05                 ; "cannot create new extent"		;
2860: F106 3A C1 EA               LD     A,(exitParameterByte) ; Get result from Make				;
2861: F109 3C                     INC    A                    ;
2862: F10A 28 06                  JR     Z,RandomSeekErrorBadSeek ;	Exit if failed on Make			;
2863: F10C         ;
2864: F10C             RandomSeekExit:                      ;
2865: F10C C1                     POP    BC                   ; Balance Stack						;
2866: F10D AF                     XOR    A                    ; Success							;
2867: F10E 32 C1 EA               LD     (exitParameterByte),A ;
2868: F111 C9                     RET                         ;
2869: F112         ;
2870: F112             RandomSeekErrorBadSeek:                      ;
2871: F112 DD 36 0E C0               LD     (IX+fcbS2Index),0C0H ; Set Write protect & overflow		;
2872: F116             RandomSeekError:                      ;
2873: F116 C1                     POP    BC                   ; Balance Stack						;
2874: F117 7D                     LD     A,L                  ; Get error code					;
2875: F118 32 C1 EA               LD     (exitParameterByte),A ;	and return it to caller			;
2876: F11B C3 D6 EF               JP     SetFileWriteFlag     ; Set flag for following close		;
2877: F11E         ;-------------------------------- Random Seek ------------------------------;
2878: F11E         ;--------------------------- Get Random Record Position -------------------;?
2879: F11E         ; on Entry :																;?
2880: F11E         ;			HL = pointer to directory entry									;?
2881: F11E         ;			DE = fcbRCIndex/seqRecord index									;?
2882: F11E             GetRandomRecordPosition:                      ;?
2883: F11E EB                     EX     DE,HL                ; DE = pointer to directory entry	;?
2884: F11F 19                     ADD    HL,DE                ;?
2885: F120         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)				;?
2886: F120 4E                     LD     C,(HL)               ; C = record count					;?
2887: F121 06 00                  LD     B,0                  ; Make count a word value			;?
2888: F123         ;?
2889: F123 21 0C 00               LD     HL,fcbExtIndex       ; FCB Extent index					;?
2890: F126 19                     ADD    HL,DE                ;?
2891: F127 7E                     LD     A,(HL)               ; ACC has Extent value				;?
2892: F128 0F                     RRCA                        ;?
2893: F129 E6 80                  AND    80H                  ; A=e000 0000						;?
2894: F12B 81                     ADD    A,C                  ;?
2895: F12C 4F                     LD     C,A                  ;?
2896: F12D 3E 00                  LD     A,0                  ;?
2897: F12F 88                     ADC    A,B                  ;?
2898: F130 47                     LD     B,A                  ;?
2899: F131         ; BC = 0000 000? errrr rrrr												;?
2900: F131 7E                     LD     A,(HL)               ;?
2901: F132 0F                     RRCA                        ;?
2902: F133 E6 0F                  AND    LO_NIBBLE_MASK       ;?
2903: F135 80                     ADD    A,B                  ;?
2904: F136 47                     LD     B,A                  ;?
2905: F137         ; BC = 000? eeee errrr rrrr			;?
2906: F137 21 0E 00               LD     HL,fcbS2Index        ;?
2907: F13A 19                     ADD    HL,DE                ;?
2908: F13B 7E                     LD     A,(HL)               ; A=XXX? mmmm						;?
2909: F13C 87                     ADD    A,A                  ;?
2910: F13D 87                     ADD    A,A                  ;?
2911: F13E 87                     ADD    A,A                  ;?
2912: F13F 87                     ADD    A,A                  ; cy=? A=mmmm 0000					;?
2913: F140 F5                     PUSH   AF                   ;?
2914: F141 80                     ADD    A,B                  ;?
2915: F142 47                     LD     B,A                  ;?
2916: F143         ; cy=?, BC = mmmm eeee errr rrrr											;?
2917: F143 F5                     PUSH   AF                   ; possible second carry				;?
2918: F144 E1                     POP    HL                   ; cy = lsb of L						;?
2919: F145 7D                     LD     A,L                  ; cy = lsb of A						;?
2920: F146 E1                     POP    HL                   ; cy = lsb of L						;?
2921: F147 B5                     OR     L                    ; cy/cy = lsb of A					;?
2922: F148 E6 01                  AND    1                    ; A = 0000 000? possible carry-out	;?
2923: F14A C9                     RET                         ;?
2924: F14B         ;--------------------------- Get Random Record Position -------------------;?
2925: F14B         ;=========================== File Utilities ================================;
2926: F14B         ;=========================== Directory Utilities ===========================;
2927: F14B         ;--------------------------- Set End of Directory indicator ----------------;
2928: F14B             SetEndDirectory:                      ;
2929: F14B 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index			;
2930: F14E 22 CE F4               LD     (dirEntryIndex),HL   ;
2931: F151 C9                     RET                         ;
2932: F152         ;--------------------------- Set End of Directory indicator ----------------;
2933: F152         ;--------------------------- Are we at End Of Directory --------------------;
2934: F152         ; Tests to see if we are at the End Of the Directory						;
2935: F152         ;																			;
2936: F152         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)						;
2937: F152         ;			Z Flag reset if still in directory								;
2938: F152         ;
2939: F152             AtEndOfDirectory:                      ;
2940: F152 21 CE F4               LD     HL,dirEntryIndex     ; Point at LSB of Dir index			;
2941: F155 7E                     LD     A,(HL)               ; Get it							;
2942: F156 23                     INC    HL                   ; Point at MSB	of Dir Index		;
2943: F157 BE                     CP     M                    ; LSB = MSB ?						;
2944: F158 C0                     RET    NZ                   ;	exit if not if different		;
2945: F159         ; Same.	are they = 0ffh?			;
2946: F159 3C                     INC    A                    ;	if yes, A= 0, set Z flag		;
2947: F15A C9                     RET                         ;
2948: F15B         ;--------------------------- Are we at End Of Directory --------------------;
2949: F15B         ;--------------------------- Get Directory Element -------------------------;
2950: F15B         ; compute the address of a directory element in Directory Buffer			;
2951: F15B         ; Returns:	HL = Address of the specific directory Entry					;
2952: F15B             GetCurrentDirectoryRecord:                      ;
2953: F15B C5                     PUSH   BC                   ; Save BC							;
2954: F15C 2A A2 F4               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base		;
2955: F15F 3A CD F4               LD     A,(dirBlockIndex)    ; Get the index value				;
2956: F162 4F                     LD     C,A                  ;
2957: F163 AF                     XOR    A                    ; Set to Zero and reset CY			;
2958: F164 47                     LD     B,A                  ;
2959: F165 ED 4A                  ADC    HL,BC                ; Compute the Entry Location		;
2960: F167 C1                     POP    BC                   ; Restore							;
2961: F168 C9                     RET                         ;
2962: F169         ;--------------------------- Get Directory Element -------------------------;
2963: F169         ;--------------------------- Set Directory Entry ---------------------------;
2964: F169         ; Will update directory if not in the directory								;
2965: F169         ;
2966: F169             SetDirectoryEntry:                      ;
2967: F169 CD 72 F1               CALL   StillInDirectory     ;
2968: F16C D8                     RET    C                    ; Exit if still in the Directory	;
2969: F16D         ;
2970: F16D         ; StillInDirectory will return with:										;
2971: F16D         ;									DE = Directory entry number				;
2972: F16D         ;									HL = Address of entry number + 1		;
2973: F16D 13                     INC    DE                   ;
2974: F16E 72                     LD     (HL),D               ;
2975: F16F 2B                     DEC    HL                   ;
2976: F170 73                     LD     (HL),E               ;
2977: F171 C9                     RET                         ;
2978: F172         ;--------------------------- Set Directory Entry ---------------------------;
2979: F172         ;--------------------------- Are we sill in the Directory ------------------;
2980: F172         ;Returns	:																;
2981: F172         ;			CY Set	if dirEntryIndex <= Directory Max Value					;
2982: F172         ;			CY Reset if dirEntryIndex	> Directory Max Value				;
2983: F172         ;			HL = (address of Index Value) + 1								;
2984: F172         ;			DE = Directory Index Value										;
2985: F172             StillInDirectory:                      ;
2986: F172 2A CE F4               LD     HL,(dirEntryIndex)   ;
2987: F175 EB                     EX     DE,HL                ; DE = directory counter			;
2988: F176 2A 9C F4               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue				;
2989: F179 7B                     LD     A,E                  ;
2990: F17A 96                     SUB    M                    ;
2991: F17B 23                     INC    HL                   ;
2992: F17C 7A                     LD     A,D                  ;
2993: F17D 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex			;
2994: F17E C9                     RET                         ;	<= Directory Max Value		;
2995: F17F         ;--------------------------- Are we sill in the Directory ------------------;
2996: F17F         ;--------------------------- Scan Disk Map ---------------------------------;
2997: F17F         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
2998: F17F         ;																			;
2999: F17F         ; On Entry	C = TRUE	Set the Map bits for each block found in FCB		;
3000: F17F         ;			C = FALSE	reset the Map bits for each block found in FCB		;
3001: F17F         ;
3002: F17F             ScanDiskMap:                      ;
3003: F17F C5                     PUSH   BC                   ; Save the Set/Reset Info			;
3004: F180 CD 5B F1               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
3005: F183 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map	;
3006: F186 19                     ADD    HL,DE                ; HL is now at start of the MAP		;
3007: F187 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1	;
3008: F189         ;
3009: F189             ScanDiskMap0:                      ;
3010: F189 D1                     POP    DE                   ; Recall the set/reset Info			;
3011: F18A 0D                     DEC    C                    ;
3012: F18B C8                     RET    Z                    ; Loop once for each disk map entry ;
3013: F18C         ;
3014: F18C D5                     PUSH   DE                   ; Save the Set/Reset Info			;
3015: F18D 3A C3 F4               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized			;
3016: F190 B7                     OR     A                    ;
3017: F191 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized				;
3018: F193         ;	Byte Allocation scan operation											;
3019: F193 C5                     PUSH   BC                   ; Save counter						;
3020: F194 E5                     PUSH   HL                   ; Save map address					;
3021: F195 4E                     LD     C,(HL)               ;
3022: F196 06 00                  LD     B,0                  ; BC=block# for Byte				;
3023: F198 18 06                  JR     ScanDiskMap2         ;
3024: F19A         ; Word scan operation														;
3025: F19A             ScanDiskMapWord:                      ;
3026: F19A 0D                     DEC    C                    ; Adjust counter for 2 bytes		;
3027: F19B C5                     PUSH   BC                   ; Save counter						;
3028: F19C 46                     LD     B,(HL)               ;
3029: F19D 23                     INC    HL                   ;
3030: F19E 4E                     LD     C,(HL)               ; BC=block# for Word				;
3031: F19F E5                     PUSH   HL                   ; Save map address					;
3032: F1A0         ;
3033: F1A0         ; Arrive here with BC=block#, E=0/1											;
3034: F1A0             ScanDiskMap2:                      ;
3035: F1A0 79                     LD     A,C                  ;
3036: F1A1 B0                     OR     B                    ; Skip if = 0000 (No Block)			;
3037: F1A2 C4 A3 EF               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C			;
3038: F1A5 E1                     POP    HL                   ;
3039: F1A6 23                     INC    HL                   ; to next bit position				;
3040: F1A7 C1                     POP    BC                   ; recall counter					;
3041: F1A8 18 DF                  JR     ScanDiskMap0         ; for another item					;
3042: F1AA         ;
3043: F1AA         ;--------------------------- Scan Disk Map ---------------------------------;
3044: F1AA         ;--------------------------- Get Closest Disk Block ------------------------;
3045: F1AA         ; Find the closest available disk block, and mark in Map as allocated		;
3046: F1AA         ; Enter	BC	= Block number to base the search on							;
3047: F1AA         ; Exit	HL	= 0000 if There are no available open blocks					;
3048: F1AA         ;			= block number of available and marked block					;
3049: F1AA         ;
3050: F1AA             GetClosestBlock:                      ;
3051: F1AA C5                     PUSH   BC                   ; save the starting Block #			;
3052: F1AB         ;
3053: F1AB 2A AF F4               LD     HL,(dpbDSM)          ; Maximum allocation value			;
3054: F1AE CD 17 F3               CALL   DivideHLby8          ; Length of Map						;
3055: F1B1 EB                     EX     DE,HL                ; put size into DE					;
3056: F1B2 E1                     POP    HL                   ; Block number into HL				;
3057: F1B3 CD 17 F3               CALL   DivideHLby8          ; Length of Map						;
3058: F1B6 EB                     EX     DE,HL                ; Size in HL, Start in DE			;
3059: F1B7 AF                     XOR    A                    ; Reset CY							;
3060: F1B8 ED 52                  SBC    HL,DE                ; Size for right					;
3061: F1BA         ; DE = Start Index															;
3062: F1BA         ; DE = Left Size															;
3063: F1BA         ; HL	= Right Size														;
3064: F1BA E5                     PUSH   HL                   ; Save right size					;
3065: F1BB D5                     PUSH   DE                   ; Save left size & Start Index		;
3066: F1BC 3E FF                  LD     A,0FFH               ; Full Octet						;
3067: F1BE         ;
3068: F1BE 2A A8 F4               LD     HL,(caAllocVector)   ; Start of Map						;
3069: F1C1 19                     ADD    HL,DE                ; Determine initial Octet			;
3070: F1C2         ; Set up Left side															;
3071: F1C2 C1                     POP    BC                   ; Left size							;
3072: F1C3 03                     INC    BC                   ; adjust							;
3073: F1C4 E5                     PUSH   HL                   ; Save initial Octet				;
3074: F1C5 11 FF FF               LD     DE,-1                ; Flag as Left register set			;
3075: F1C8         ; HL = Initial Octet														;
3076: F1C8         ; BC = Left Size															;
3077: F1C8 D9                     EXX                         ; Use alternate registers			;
3078: F1C9 11 00 00               LD     DE,0000H             ; Flag as Right register set		;
3079: F1CC E1                     POP    HL                   ; Get Initial Octet					;
3080: F1CD C1                     POP    BC                   ; Get Right Size					;
3081: F1CE 03                     INC    BC                   ; adjust							;
3082: F1CF             LookRight:                      ;
3083: F1CF ED A1                  CPI                         ; UnSet Bit?						;
3084: F1D1 20 28                  JR     NZ,FoundFreeOctet    ;	Then get out of search			;
3085: F1D3 E2 EC F1               JP     PO,NoMoreRight       ; Exhausted Map to the right		;
3086: F1D6         ;
3087: F1D6 D9                     EXX                         ; Switch to the Left				;
3088: F1D7 ED A9                  CPD                         ; UnSet Bit?						;
3089: F1D9 20 20                  JR     NZ,FoundFreeOctet    ;	Then get out of search			;
3090: F1DB E2 E1 F1               JP     PO,NoMoreLeft        ; Exhausted Map to the right		;
3091: F1DE D9                     EXX                         ; switch to right					;
3092: F1DF 18 EE                  JR     LookRight            ; Keep on looking					;
3093: F1E1         ;			----------------												;
3094: F1E1             NoMoreLeft:                      ;
3095: F1E1 D9                     EXX                         ; Switch to Right					;
3096: F1E2             NoMoreLeftLoop:                      ;
3097: F1E2 ED A1                  CPI                         ;
3098: F1E4 20 15                  JR     NZ,FoundFreeOctet    ;	Then get out of search			;
3099: F1E6 E2 F7 F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
3100: F1E9 18 F7                  JR     NoMoreLeftLoop       ; Keep looking						;
3101: F1EB 76                     HALT                        ;
3102: F1EC             NoMoreRight:                      ;
3103: F1EC D9                     EXX                         ; Switch to Left					;
3104: F1ED             NoMoreRightLoop:                      ;
3105: F1ED ED A9                  CPD                         ;
3106: F1EF 20 0A                  JR     NZ,FoundFreeOctet    ;	Then get out of search			;
3107: F1F1 E2 F7 F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
3108: F1F4 18 F7                  JR     NoMoreRightLoop      ; Keep looking						;
3109: F1F6 76                     HALT                        ;
3110: F1F7             NoFreeBlocks:                      ;
3111: F1F7 21 00 00               LD     HL,0000H             ; Return 0000 in HL					;
3112: F1FA C9                     RET                         ;
3113: F1FB         ;			----------------												;
3114: F1FB             FoundFreeOctet:                      ;
3115: F1FB BB                     CP     E                    ; Left or Right						;
3116: F1FC 28 03                  JR     Z,FoundFreeOctet1    ;	it was left						;
3117: F1FE 2B                     DEC    HL                   ; Adjust for direction				;
3118: F1FF 18 01                  JR     FoundFreeOctet2      ;
3119: F201         ;
3120: F201             FoundFreeOctet1:                      ;
3121: F201 23                     INC    HL                   ; Adjust for direction				;
3122: F202             FoundFreeOctet2:                      ;
3123: F202 01 00 00               LD     BC,00                ; need to keep track of bit			;
3124: F205             FoundFreeOctet3:                      ;
3125: F205 CB 06                  RLC    (HL)                 ;
3126: F207 03                     INC    BC                   ;
3127: F208 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set					;
3128: F20A CB C6                  SET    0,(HL)               ; Make map bit set					;
3129: F20C 41                     LD     B,C                  ; Put count in B					;
3130: F20D             FoundFreeOctet4:                      ;
3131: F20D CB 0E                  RRC    (HL)                 ;
3132: F20F 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet					;
3133: F211 0B                     DEC    BC                   ; adjust for Zero based value		;
3134: F212 C5                     PUSH   BC                   ; Save the bit index				;
3135: F213 ED 4B A8 F4               LD     BC,(caAllocVector)   ; Get Map start						;
3136: F217 AF                     XOR    A                    ; Clear CY							;
3137: F218 ED 42                  SBC    HL,BC                ; Get how far in the map			;
3138: F21A CD 21 F3               CALL   MultiplyHLby8        ; Calculate the Octet			;
3139: F21D C1                     POP    BC                   ; Restore index into Octet			;
3140: F21E 09                     ADD    HL,BC                ; This is the Block Number			;
3141: F21F C9                     RET                         ;
3142: F220         ;--------------------------- Get Closest Disk Block ------------------------;
3143: F220         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3144: F220             CopyDirEntryToUserDMA:                      ;
3145: F220 2A A2 F4               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer			;
3146: F223 ED 5B 9A F4               LD     DE,(initDAMAddress)  ; Point at User's Buffer			;
3147: F227 01 80 00               LD     BC,cpmRecordSize     ; The entire record					;
3148: F22A ED B0                  LDIR                        ; Move it							;
3149: F22C C9                     RET                         ;
3150: F22D         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3151: F22D         ;--------------------- Return last Directory Index to Caller ---------------;
3152: F22D             DirLocationToReturnLoc:                      ;
3153: F22D 3A BE F4               LD     A,(directoryIndex)   ; Get last directory Index			;
3154: F230 32 C1 EA               LD     (exitParameterByte),A ; Save for return to Caller			;
3155: F233 C9                     RET                         ;
3156: F234         ;--------------------- Return last Directory Index to Caller ---------------;
3157: F234         ;--------------------------- Check OK to Write to Disk ---------------------;
3158: F234             CheckWrite:                      ;
3159: F234 CD 40 EF               CALL   IsDiskWriteProtected ; Is this disk Write Protected?		;
3160: F237 C8                     RET    Z                    ; OK to write						;
3161: F238 C3 28 F4               JP     Error_DiskReadOnly   ; Report read only disk error		;
3162: F23B         ;--------------------------- Check OK to Write to Disk ---------------------;
3163: F23B         ;--------------------------- Check File Write Protect Status ---------------;
3164: F23B             CheckRODirectory:                      ;
3165: F23B CD 5B F1               CALL   GetCurrentDirectoryRecord ; Use Entry in Directory Buffer		;
3166: F23E         ; Use HL as the directory entry in Question									;
3167: F23E             CheckROFile:                      ;
3168: F23E 11 09 00               LD     DE,fcbROfileIndex    ; Index into FC for RO				;
3169: F241 19                     ADD    HL,DE                ; point at the byte					;
3170: F242 7E                     LD     A,(HL)               ;
3171: F243 17                     RLA                         ; Set CY if RO bit set				;
3172: F244 D0                     RET    NC                   ; Return OK							;
3173: F245 C3 2E F4               JP     Error_FileReadOnly   ; Report to read only File			;
3174: F248         ;--------------------------- Check File Write Protect Status ---------------;
3175: F248         ;------------------------- Copy FCB To Directory record --------------------;
3176: F248         ; On Entry:																	;
3177: F248         ;			C = Starting position											;
3178: F248         ;			E = length of copy												;
3179: F248         ;copy the whole file control block											;
3180: F248             CopyFCB:                        ;
3181: F248 0E 00                  LD     C,0                  ;
3182: F24A 1E 20                  LD     E,fcbLength          ; Copy all of the FCB			;
3183: F24C         ; On Entry:																	;
3184: F24C         ;			C = Starting position											;
3185: F24C         ;			E = length of copy												;
3186: F24C             CopyDir:                        ;
3187: F24C 16 00                  LD     D,0                  ; Make length a word value		;
3188: F24E D5                     PUSH   DE                   ; Length						;
3189: F24F 06 00                  LD     B,0                  ; Make index a word				;
3190: F251 2A BF EA               LD     HL,(paramDE)         ; HL = source for data			;
3191: F254 09                     ADD    HL,BC                ;
3192: F255 EB                     EX     DE,HL                ;
3193: F256 CD 5B F1               CALL   GetCurrentDirectoryRecord ; HL pointer to Dir Record		;
3194: F259 EB                     EX     DE,HL                ;
3195: F25A C1                     POP    BC                   ; Length						;
3196: F25B ED B0                  LDIR                        ;
3197: F25D CD 76 F3               CALL   SeekDir              ; Seek to the dir entry			;
3198: F260 C3 74 F0               JP     WriteDir             ; Write the directory element	;
3199: F263         ;------------------------- Copy FCB from Directory record ------------------;
3200: F263         ;-------------------------------- Get Block Number -------------------------;
3201: F263         ;compute disk block number from current FCB								;
3202: F263             GetBlockNumber:                      ;
3203: F263 CD 70 F2               CALL   GetDiskMapIndex      ;Return Alloc block index			;
3204: F266 4F                     LD     C,A                  ;
3205: F267 06 00                  LD     B,0                  ;
3206: F269 CD 7D F2               CALL   GetDiskMapValue      ; Convert to Disk record			;
3207: F26C 22 CB F4               LD     (absoluteCPMRecord),HL ; Save								;
3208: F26F C9                     RET                         ;
3209: F270         ;-------------------------------- Get Block Number -------------------------;
3210: F270         ;-------------------------------- Get Disk Map Index -----------------------;
3211: F270         ;Return the	disk map Index for current File Record in the ACC				;
3212: F270             GetDiskMapIndex:                      ;
3213: F270 21 AC F4               LD     HL,dpbBSH            ; Block# = Record# / (2***dpbBSH)	;
3214: F273 46                     LD     B,(HL)               ; shift count						;
3215: F274 3A C9 F4               LD     A,(currentFileRecord) ;
3216: F277             GetDiskMapIndexLoop:                      ;
3217: F277 CB 3F                  SRL    A                    ;
3218: F279 10 FC                  DJNZ   GetDiskMapIndexLoop  ; Loop till done					;
3219: F27B 00                     NOP                         ;
3220: F27C C9                     RET                         ;
3221: F27D         ;-------------------------------- Get Disk Map Index -----------------------;
3222: F27D         ;-------------------------------- Get Disk Map Value -----------------------;
3223: F27D         ; Enter with Disk Map Index in BC											;
3224: F27D         ; Return disk map value	in HL												;
3225: F27D             GetDiskMapValue:                      ;
3226: F27D 2A BF EA               LD     HL,(paramDE)         ; FCB								;
3227: F280 11 10 00               LD     DE,fcbDiskMapIndex   ; Index to Allocation Map			;
3228: F283 19                     ADD    HL,DE                ; Address of Allocation Map Start	;
3229: F284 09                     ADD    HL,BC                ; Point at the targeted map entry	;
3230: F285 3A C3 F4               LD     A,(byteAllocationFlag) ; Is this a byte or word			;
3231: F288 B7                     OR     A                    ;
3232: F289 28 04                  JR     Z,GetDiskMap16Bit    ; Skip if word value				;
3233: F28B 6E                     LD     L,(HL)               ;	else its a byte value			;
3234: F28C 26 00                  LD     H,0                  ;load the byte into HL				;
3235: F28E C9                     RET                         ;
3236: F28F         ;
3237: F28F             GetDiskMap16Bit:                      ;
3238: F28F 09                     ADD    HL,BC                ; make it double width				;
3239: F290 56                     LD     D,(HL)               ;
3240: F291 23                     INC    HL                   ;
3241: F292 5E                     LD     E,(HL)               ; Load word value into DE			;
3242: F293 EB                     EX     DE,HL                ; return value in HL				;
3243: F294 C9                     RET                         ;
3244: F295         ;-------------------------------- Get Disk Map Value -----------------------;
3245: F295         ;-------------------------------- Allocate The Block -----------------------;
3246: F295         ;is	block allocated															;
3247: F295             WasBlockAllocated:                      ;
3248: F295 2A CB F4               LD     HL,(absoluteCPMRecord) ; Get the Block Number				;
3249: F298 7D                     LD     A,L                  ; ZFlag set if						;
3250: F299 B4                     OR     H                    ;	absoluteCPMRecord = 0			;
3251: F29A C9                     RET                         ;
3252: F29B         ;-------------------------------- Allocate The Block -----------------------;
3253: F29B         ;----------------------------- Set Actual Record Add -----------------------;
3254: F29B         ;
3255: F29B         ;compute actual record address												;
3256: F29B         ; result = absolute CPMRecord * ( 2**BSH)									;
3257: F29B             SetActualRecordAdd:                      ;
3258: F29B 3A AC F4               LD     A,(dpbBSH)           ; Block Shift to loop control		;
3259: F29E 47                     LD     B,A                  ;
3260: F29F 2A CB F4               LD     HL,(absoluteCPMRecord) ;
3261: F2A2         ;
3262: F2A2             SetActualRecordAddLoop:                      ;
3263: F2A2 29                     ADD    HL,HL                ;
3264: F2A3 10 FD                  DJNZ   SetActualRecordAddLoop ;
3265: F2A5         ; HL has Record number for start of the block;								;
3266: F2A5 3A AD F4               LD     A,(dpbBLM)           ; Get block mask to get current		;
3267: F2A8 4F                     LD     C,A                  ;	File Record mod Block			;
3268: F2A9 3A C9 F4               LD     A,(currentFileRecord) ; Get index into block				;
3269: F2AC A1                     AND    C                    ; Record index in Block				;
3270: F2AD B5                     OR     L                    ;
3271: F2AE 6F                     LD     L,A                  ; to HL								;
3272: F2AF 22 CB F4               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL			;
3273: F2B2         ; *** Absolute CPM Record now has current record number						;
3274: F2B2         ; - Starting record number + index into block								;
3275: F2B2 C9                     RET                         ;
3276: F2B3         ;----------------------------- Set Actual Record Add -----------------------;
3277: F2B3         ;-------------------------------- Open Next Extent -------------------------;
3278: F2B3         ;close the current extent	and open the next one if possible.				;
3279: F2B3         ;readModeFlag is true if in read mode										;
3280: F2B3             OpenNextExt:                      ;
3281: F2B3 AF                     XOR    A                    ; Set to 00							;
3282: F2B4 32 BC F4               LD     (fcbCopiedFlag),A    ; Clear Flag						;
3283: F2B7 CD 40 EE               CALL   CloseDirEntry        ; Close current extent.				;
3284: F2BA CD 52 F1               CALL   AtEndOfDirectory     ; Is the directory full?			;
3285: F2BD C8                     RET    Z                    ;	exit it yes						;
3286: F2BE         ;
3287: F2BE CD 9B EF               CALL   GetExtentAddress     ; HL at FCB's EXT					;
3288: F2C1 7E                     LD     A,(HL)               ; Get previous EXT value			;
3289: F2C2 3C                     INC    A                    ; Add one to it						;
3290: F2C3 E6 1F                  AND    maxExtValue          ; Limit to max value				;
3291: F2C5 77                     LD     (HL),A               ; Put it back into the FCB			;
3292: F2C6 28 0D                  JR     Z,OpenNextModule     ;	if = 0, need to open new Module	;
3293: F2C8         ;
3294: F2C8 47                     LD     B,A                  ; put Ext value in B				;
3295: F2C9 3A AE F4               LD     A,(dpbEXM)           ; Get the Extent Mask				;
3296: F2CC A0                     AND    B                    ; Mask out unwanted bits			;
3297: F2CD         ; if result is zero, then not in the same group								;
3298: F2CD 21 BC F4               LD     HL,fcbCopiedFlag     ; Point at Copied Flag				;
3299: F2D0 A6                     AND    M                    ;	00 in Acc if not written		;
3300: F2D1 28 0C                  JR     Z,OpenNextExt1       ;	go to next physical extent if 0	;
3301: F2D3 18 24                  JR     UpdateFCB            ;	else continue					;
3302: F2D5         ;
3303: F2D5             OpenNextModule:                      ;
3304: F2D5 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ; Index difference between EXT & S2 ;
3305: F2D8 09                     ADD    HL,BC                ; Add to HL( at EXT) gives S2		;
3306: F2D9 34                     INC    M                    ; Increment the Module number		;
3307: F2DA 7E                     LD     A,(HL)               ; get the new Module number			;
3308: F2DB E6 0F                  AND    moduleMask           ; Mask out unwanted bits			;
3309: F2DD 28 25                  JR     Z,OpenNextExtError   ; If overflow to zero, error exit	;
3310: F2DF         ;
3311: F2DF             OpenNextExt1:                      ;
3312: F2DF 0E 0F                  LD     C,nameLength         ; Set search/match size				;
3313: F2E1 CD 01 F0               CALL   SearchForDirectoryRecord ; Find the file's directory record	;
3314: F2E4 CD 52 F1               CALL   AtEndOfDirectory     ; At end of Directory ?				;
3315: F2E7 20 10                  JR     NZ,UpdateFCB         ;	No, then keep going				;
3316: F2E9         ;
3317: F2E9 3A BD F4               LD     A,(readModeFlag)     ;	else at EOD						;
3318: F2EC 3C                     INC    A                    ; 0ffh becomes 00 if read			;
3319: F2ED 28 15                  JR     Z,OpenNextExtError   ; All done if a read				;
3320: F2EF         ;
3321: F2EF CD BE EE               CALL   MakeNewFile          ; With write we can extend file		;
3322: F2F2 CD 52 F1               CALL   AtEndOfDirectory     ; Is there room in the directory ?	;
3323: F2F5 28 0D                  JR     Z,OpenNextExtError   ;	no, exitParameterByte = 1		;
3324: F2F7 18 03                  JR     OpenNextExt3         ;
3325: F2F9         ;
3326: F2F9             UpdateFCB:                      ;
3327: F2F9 CD 08 EE               CALL   CopyDirRecordToFCB   ; Update FCB						;
3328: F2FC             OpenNextExt3:                      ;
3329: F2FC CD 77 EF               CALL   SetRecordVars        ; Set variables for current FCB		;
3330: F2FF AF                     XOR    A                    ;
3331: F300 32 C1 EA               LD     (exitParameterByte),A ; Set exitParameterByte = 0			;
3332: F303 C9                     RET                         ;
3333: F304         ;
3334: F304             OpenNextExtError:                      ;
3335: F304 CD 39 F3               CALL   SetExitParamTo1      ; ExitParameterByte = 1				;
3336: F307 C3 D6 EF               JP     SetFileWriteFlag     ; Ensure that it will not be closed ;
3337: F30A         ;-------------------------------- Open Next Extent -------------------------;
3338: F30A         ;=========================== Directory Utilities ===========================;
3339: F30A         ;===========================================================================;
3340: F30A         ;=========================== General	Utilities ===========================;
3341: F30A         ;--------------------------- Rotate HL right by value in C -----------------;
3342: F30A         ;
3343: F30A         ; HL = Value to be rotated Right											;
3344: F30A         ;	B = Amount to shift														;
3345: F30A             RotateRightHLbyB:                      ;
3346: F30A 37                     SCF                         ; Set carry flag, expect LSBit = 1	;
3347: F30B CB 45                  BIT    0,L                  ; is LSB set?						;
3348: F30D 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set				;
3349: F30F 3F                     CCF                         ; else Clear Carry flag				;
3350: F310             RotateRightHLbyB1:                      ;
3351: F310 CB 1C                  RR     H                    ; Shift thru CY						;
3352: F312 CB 1D                  RR     L                    ; ditto								;
3353: F314 10 F4                  DJNZ   RotateRightHLbyB     ;
3354: F316 C9                     RET                         ;
3355: F317         ;
3356: F317         ;--------------------------- Rotate HL right by value in C -----------------;
3357: F317         ;---------Divide HL by 8	&&	Shift HL right by value in C ---------------;
3358: F317         ; HL = Value to be shifted Right											;
3359: F317             DivideHLby8:                      ;
3360: F317 06 03                  LD     B,3                  ; 8 = 2**3							;
3361: F319         ;	B = Amount to shift														;
3362: F319             ShiftRightHLbyB:                      ;
3363: F319 AF                     XOR    A                    ; else Clear Carry flag				;
3364: F31A CB 1C                  RR     H                    ; Shift thru CY						;
3365: F31C CB 1D                  RR     L                    ; ditto								;
3366: F31E 10 F9                  DJNZ   ShiftRightHLbyB      ;
3367: F320 C9                     RET                         ;
3368: F321         ;---------Divide HL by 8	&&	Shift HL right by value in C ---------------;
3369: F321         ;---------Multiply HL by 8	&&	Shift HL left by value in C ----------------;
3370: F321         ; HL = Value to be shifted Left												;
3371: F321             MultiplyHLby8:                      ;
3372: F321 06 03                  LD     B,3                  ; 8 = 2**3							;
3373: F323         ;	B = Amount to shift														;
3374: F323             ShiftLeftHLbyB:                      ;
3375: F323 AF                     XOR    A                    ; else Clear Carry flag				;
3376: F324 CB 15                  RL     L                    ; Shift thru CY						;
3377: F326 CB 14                  RL     H                    ; ditto								;
3378: F328 10 F9                  DJNZ   ShiftLeftHLbyB       ;
3379: F32A C9                     RET                         ;
3380: F32B         ;---------Multiply HL by 8	&&	Shift HL left by value in C ----------------;
3381: F32B         ;----------------------------- Merge ---------------------------------------;
3382: F32B         ; Merge Map Block Numbers between FCB and directory record					;
3383: F32B         ; HL has pointer to map for either dir record or FCB,						;
3384: F32B         ; DE has the other pointer. If HL is pointing to a non empty block, then	;
3385: F32B         ; it just returns, Else it copies the block number to where DE is pointing	;
3386: F32B         ;
3387: F32B             Merge:                          ;
3388: F32B 7E                     LD     A,(HL)               ; Get the first byte				;
3389: F32C 23                     INC    HL                   ;
3390: F32D B6                     OR     M                    ; OR it with the second byte		;
3391: F32E 2B                     DEC    HL                   ; Restore HL to start				;
3392: F32F C0                     RET    NZ                   ; Exit if both are 0s				;
3393: F330         ; HL points to a non Zero value												;
3394: F330 1A                     LD     A,(DE)               ; Get the first byte				;
3395: F331 77                     LD     (HL),A               ; Move it							;
3396: F332 13                     INC    DE                   ;
3397: F333 23                     INC    HL                   ; Increment both pointers			;
3398: F334 1A                     LD     A,(DE)               ; Get the second byte				;
3399: F335 77                     LD     (HL),A               ; Move it							;
3400: F336 1B                     DEC    DE                   ;
3401: F337 2B                     DEC    HL                   ; Restore HL & DE to start			;
3402: F338 C9                     RET                         ;
3403: F339         ;----------------------------- Merge ---------------------------------------;
3404: F339         ;------------------------- Set Exit Parameter To 1 -------------------------;
3405: F339             SetExitParamTo1:                      ;
3406: F339 3E 01                  LD     A,1                  ;
3407: F33B 32 C1 EA               LD     (exitParameterByte),A ; Put a 1 in the exit parameter		;
3408: F33E C9                     RET                         ;
3409: F33F         ;------------------------- Set Exit Parameter To 1 -------------------------;
3410: F33F         ;=========================== General	Utilities ==========================;
3411: F33F         ;--------------------------- Read Directory Record -------------------------;
3412: F33F         ; read a directory entry into the directory buffer							;
3413: F33F             ReadDirRecord:                      ;
3414: F33F CD 17 EF               CALL   SetDirDMA            ; System Assigned Buffer			;
3415: F342 CD 20 EF               CALL   ReadBuffer           ; Go to BIOS for the read			;
3416: F345 C3 12 EF               JP     SetDataDMA           ; Restore DMA						;
3417: F348         ;--------------------------- Read Directory Record -------------------------;
3418: F348         ;--------------------------- Read Directory --------------------------------;
3419: F348         ; Read next directory entry													;
3420: F348         ; Enter :																	;
3421: F348         ;		C =	TRUE initializing and setting CheckSum							;
3422: F348         ;			<> TRUE Checking existing CheckSum								;
3423: F348             ReadDirectory:                      ;
3424: F348 ED 5B B1 F4               LD     DE,(dpbDRM)          ; Number of Dir Entries-1			;
3425: F34C 2A CE F4               LD     HL,(dirEntryIndex)   ; Prior Directory Index				;
3426: F34F 23                     INC    HL                   ; Increment the Index				;
3427: F350 22 CE F4               LD     (dirEntryIndex),HL   ; Save current directory index		;
3428: F353 AF                     XOR    A                    ; Clear the CY flag					;
3429: F354 ED 52                  SBC    HL,DE                ; Are we at end Of the directory	;
3430: F356 20 04                  JR     NZ,ReadDirectory0    ;	No the process					;
3431: F358 CD 4B F1               CALL   SetEndDirectory      ;	else we are done				;
3432: F35B C9                     RET                         ;
3433: F35C         ;
3434: F35C         ; Calculate the entry index Position in Buffer								;
3435: F35C             ReadDirectory0:                      ;
3436: F35C 3A CE F4               LD     A,(dirEntryIndex)    ; Get the index						;
3437: F35F E6 03                  AND    dirEntryMask         ; Determine Entry number			;
3438: F361 06 05                  LD     B,fcbShift           ; Shift value for Record Size		;
3439: F363             ReadDirectory1:                      ;
3440: F363 87                     ADD    A,A                  ;
3441: F364 10 FD                  DJNZ   ReadDirectory1       ;
3442: F366 32 CD F4               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
3443: F369 B7                     OR     A                    ; Is this the 1st entry?			;
3444: F36A C0                     RET    NZ                   ;	return if not.					;
3445: F36B         ;
3446: F36B C5                     PUSH   BC                   ; Save init Flag (CheckSum)			;
3447: F36C CD 76 F3               CALL   SeekDir              ; Set up for Directory Read			;
3448: F36F CD 3F F3               CALL   ReadDirRecord        ; Read the directory record			;
3449: F372 C1                     POP    BC                   ; Recall initialization flag		;
3450: F373 C3 C5 F3               JP     CheckSumUtility      ; Checksum the directory			;
3451: F376         ;--------------------------- Read Directory --------------------------------;
3452: F376         ;--------------------------- Seek Directory --------------------------------;
3453: F376         ;seek the record containing the current directory entry					;
3454: F376             SeekDir:                        ;
3455: F376 2A CE F4               LD     HL,(dirEntryIndex)   ; Directory Entry Index				;
3456: F379 06 02                  LD     B,dirEntryShift      ; 4 entries per record				;
3457: F37B CD 19 F3               CALL   ShiftRightHLbyB      ;
3458: F37E 22 CB F4               LD     (absoluteCPMRecord),HL ;
3459: F381 22 D0 F4               LD     (dirRecord),HL       ; Save								;
3460: F384 C3 87 F3               JP     Seek                 ;
3461: F387         ;--------------------------- Seek Directory --------------------------------;
3462: F387         ;--------------------------- Seek ------------------------------------------;
3463: F387             Seek:                           ;
3464: F387 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter		;
3465: F38A 2A CB F4               LD     HL,(absoluteCPMRecord) ; Get the record in question		;
3466: F38D ED 5B AA F4               LD     DE,(dpbSPT)          ; Get Sectors Per track				;
3467: F391         ;
3468: F391             Seek0:                          ;
3469: F391 03                     INC    BC                   ; Divide the record					;
3470: F392 AF                     XOR    A                    ;	by the sectors per track		;
3471: F393 ED 52                  SBC    HL,DE                ;
3472: F395 30 FA                  JR     NC,Seek0             ;	to get the gross track number	;
3473: F397         ;
3474: F397         ;
3475: F397 19                     ADD    HL,DE                ; Gets the sector in the track		;
3476: F398 E5                     PUSH   HL                   ; Save Index Sector					;
3477: F399         ;
3478: F399 DD E5                  PUSH   IX                   ; Save IX							;
3479: F39B DD 2A 9E F4               LD     IX,(caTrack)         ;
3480: F39F DD 71 00               LD     (IX+0),C             ;
3481: F3A2 DD 70 01               LD     (IX+1),B             ; Save the Gross Track				;
3482: F3A5         ;
3483: F3A5 EB                     EX     DE,HL                ; Take the index from the record	;
3484: F3A6 2A CB F4               LD     HL,(absoluteCPMRecord) ;
3485: F3A9 AF                     XOR    A                    ;
3486: F3AA ED 52                  SBC    HL,DE                ;	and you get the Block start		;
3487: F3AC         ;
3488: F3AC DD 2A A0 F4               LD     IX,(caSector)        ;
3489: F3B0 DD 75 00               LD     (IX+0),L             ;
3490: F3B3 DD 74 01               LD     (IX+1),H             ; Save the Block Start				;
3491: F3B6 DD E1                  POP    IX                   ; Restore IX						;
3492: F3B8         ;
3493: F3B8 2A B7 F4               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
3494: F3BB 09                     ADD    HL,BC                ;	to add to the gross Track		;
3495: F3BC E5                     PUSH   HL                   ;	which yields the net or			;
3496: F3BD C1                     POP    BC                   ;	actual track for the record		;
3497: F3BE CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track		;
3498: F3C1         ;
3499: F3C1 C1                     POP    BC                   ; Get the sector within the track	;
3500: F3C2 C3 21 F6               JP     bcSetsec             ;	and set it for the seek			;
3501: F3C5         ;
3502: F3C5         ;--------------------------- Seek ------------------------------------------;
3503: F3C5         ;--------------------------- Check Sum Utility -----------------------------;
3504: F3C5         ; At entry																	;
3505: F3C5         ;			C	= TRUE	-	Set the Checksum values in Vector				;
3506: F3C5         ;			C <> TRUE	-	Validate Checksum value in Vector				;
3507: F3C5         ;
3508: F3C5             CheckSumUtility:                      ;
3509: F3C5 2A B5 F4               LD     HL,(dpbCKS)          ;
3510: F3C8 ED 5B D0 F4               LD     DE,(dirRecord)       ;
3511: F3CC AF                     XOR    A                    ;
3512: F3CD ED 52                  SBC    HL,DE                ; Skip if past the Directory	;
3513: F3CF D8                     RET    C                    ;	Entries						;
3514: F3D0         ;
3515: F3D0 C5                     PUSH   BC                   ; Save New/Validate Flag		;
3516: F3D1         ;
3517: F3D1         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)						;
3518: F3D1             ComputeCheckSum:                      ;
3519: F3D1 06 80                  LD     B,cpmRecordSize      ;
3520: F3D3 2A A2 F4               LD     HL,(caDirectoryDMA)  ;
3521: F3D6 EE 00                  XOR                         ;
3522: F3D8             ComputeCheckSum1:                      ;
3523: F3D8 86                     ADD    A,(HL)               ;
3524: F3D9 23                     INC    HL                   ;
3525: F3DA 10 FC                  DJNZ   ComputeCheckSum1     ;
3526: F3DC         ; Checksum is in ACC														;
3527: F3DC         ;
3528: F3DC 2A A6 F4               LD     HL,(caCheckSum)      ; Address of check sum vector		;
3529: F3DF ED 5B D0 F4               LD     DE,(dirRecord)       ; Index to this record				;
3530: F3E3 19                     ADD    HL,DE                ; Address of this record in vector	;
3531: F3E4 C1                     POP    BC                   ; Retrieve New/Validate Flag		;
3532: F3E5 0C                     INC    C                    ;
3533: F3E6 28 0A                  JR     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE	;
3534: F3E8         ;
3535: F3E8 BE                     CP     M                    ; Else we are checking the value	;
3536: F3E9 C8                     RET    Z                    ; Exit if OK						;
3537: F3EA         ; possible checksum error, are we beyond the end of the disk?				;
3538: F3EA CD 72 F1               CALL   StillInDirectory     ;
3539: F3ED D0                     RET    NC                   ; OK, if not in the directory		;
3540: F3EE CD 28 EF               CALL   SetDiskReadOnly      ;	else the checksums don't match	;
3541: F3F1 C9                     RET                         ;	Set disk RO before returning	;
3542: F3F2         ;
3543: F3F2         ;initializing the checksum													;
3544: F3F2             SetNewCheckSum:                      ;
3545: F3F2 77                     LD     (HL),A               ;
3546: F3F3 C9                     RET                         ;
3547: F3F4         ;--------------------------- Check Sum Utility -----------------------------;
3548: F3F4         ;---------------------------------- Is Bit Set -----------------------------;
3549: F3F4         ; Enter HL	contains the bit map											;
3550: F3F4         ;		B	Has the bit number (0...F)										;
3551: F3F4         ; Return ZFlag = 1 if bit is reset (0)										;
3552: F3F4         ;				= 0 if bit is set (1)										;
3553: F3F4             IsBitSet:                       ;
3554: F3F4 04                     INC    B                    ;
3555: F3F5             IsBitSetLoop:                      ;
3556: F3F5 37                     SCF                         ; Set carry flag, expect LSBit = 1	;
3557: F3F6 CB 45                  BIT    0,L                  ; is LSB set?						;
3558: F3F8 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set				;
3559: F3FA 3F                     CCF                         ; else Clear Carry flag				;
3560: F3FB             IsBitSet1:                      ;
3561: F3FB CB 1C                  RR     H                    ; Shift thru CY						;
3562: F3FD CB 1D                  RR     L                    ; ditto								;
3563: F3FF 10 F4                  DJNZ   IsBitSetLoop         ;
3564: F401 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	;
3565: F403 C9                     RET                         ;
3566: F404         ;---------------------------------- Is Bit Set -----------------------------;
3567: F404         ;============================ Set/Reset Vector Bit =========================;
3568: F404         ;---------------------------------- Set Vector Bit -------------------------;
3569: F404         ; Enter	HL	contains the bit map vector										;
3570: F404         ;		B	Has the bit number (0...F)										;
3571: F404         ; Return HL	Contains the modified bit map vector							;
3572: F404             SetVectorBit:                      ;
3573: F404 C5                     PUSH   BC                   ; Save the Bit Number				;
3574: F405 CD F4 F3               CALL   IsBitSet             ; Put the bit in the LSBit			;
3575: F408         ;
3576: F408 C1                     POP    BC                   ; Get the bit position				;
3577: F409 CB FC                  SET    7,H                  ;
3578: F40B 18 07                  JR     ReAlignVector        ;
3579: F40D         ;---------------------------------- Set Vector Bit -------------------------;
3580: F40D         ;---------------------------------- Reset Vector Bit -----------------------;
3581: F40D         ; Enter	HL	contains the bit map vector										;
3582: F40D         ;		B	Has the bit number (0...F)										;
3583: F40D         ; Return HL	Contains the modified bit map vector							;
3584: F40D             ResetVectorBit:                      ;
3585: F40D C5                     PUSH   BC                   ; Save the Bit Number				;
3586: F40E CD F4 F3               CALL   IsBitSet             ; Put the bit in the LSBit			;
3587: F411         ;
3588: F411 C1                     POP    BC                   ; Get the bit position				;
3589: F412 CB BC                  RES    7,H                  ;
3590: F414         ; Fall thru to ReAlignVector												;
3591: F414         ;---------------------------------- Reset Vector Bit -----------------------;
3592: F414         ;---------------------------------- Set VectorBit --------------------------;
3593: F414         ; Adjusts the HL register to its Original Alignment after IsBitSet			;
3594: F414         ;
3595: F414             ReAlignVector:                      ;
3596: F414 04                     INC    B                    ;
3597: F415             ReAlignMapLoop:                      ;
3598: F415 37                     SCF                         ; Set carry flag, expect LSBit = 1	;
3599: F416 CB 7C                  BIT    7,H                  ; is LSB set?						;
3600: F418 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set				;
3601: F41A 3F                     CCF                         ; else Clear Carry flag				;
3602: F41B             ReAlignMap1:                      ;
3603: F41B CB 15                  RL     L                    ; Shift thru CY						;
3604: F41D CB 14                  RL     H                    ; ditto								;
3605: F41F 10 F4                  DJNZ   ReAlignMapLoop       ;
3606: F421 C9                     RET                         ;
3607: F422         ;============================ Set/Reset Vector Bit =========================;
3608: F422         ;============================= Error message World =========================;
3609: F422         ;																			;
3610: F422             Error_Select:                      ;
3611: F422 21 7A F4               LD     HL,ErrMsg_Selection  ; Error Message						;
3612: F425 C3 40 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3613: F428         ;
3614: F428             Error_DiskReadOnly:                      ;
3615: F428 21 8A F4               LD     HL,ErrMsg_ReadOnlyDisk ; Error Message						;
3616: F42B C3 40 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3617: F42E         ;
3618: F42E             Error_FileReadOnly:                      ;
3619: F42E 21 81 F4               LD     HL,ErrMsg_ReadOnlyFile ; Error Message						;
3620: F431 C3 40 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3621: F434         ;
3622: F434             Error_BadSector:                      ;
3623: F434 21 6F F4               LD     HL,ErrMsg_BadSector  ; Error Message						;
3624: F437 CD 46 F4               CALL   DisplayErrorAndWait  ; Check input from console			;
3625: F43A FE 03                  CP     CTRL_C               ;
3626: F43C CA 00 00               JP     Z,WarmBoot           ; Reboot if response is CTRL_C		;
3627: F43F C9                     RET                         ;
3628: F440         ;---------------------------------------------------------------------------;
3629: F440             WaitBeforeBoot:                      ;
3630: F440 CD 46 F4               CALL   DisplayErrorAndWait  ;
3631: F443 C3 00 00               JP     WarmBoot             ;
3632: F446         ;---------------------------------------------------------------------------;
3633: F446         ;
3634: F446             DisplayErrorAndWait:                      ;
3635: F446 E5                     PUSH   HL                   ; Save message pointer				;
3636: F447 CD E1 E9               CALL   showCRLF             ; Line Feed and Carriage Return		;
3637: F44A 3A 94 F4               LD     A,(currentDisk)      ; Disk in question					;
3638: F44D C6 41                  ADD    A,ASCII_A            ; Make ASCII out of it				;
3639: F44F 32 6B F4               LD     (ErrMsg_BDOS_DISK),A ; Put into the error message		;
3640: F452 01 5F F4               LD     BC,ErrMsg_BDOS       ; Load the start of message			;
3641: F455 CD 46 E9               CALL   Print                ; Display it						;
3642: F458 C1                     POP    BC                   ; Load the rest of message			;
3643: F459 CD 46 E9               CALL   Print                ; Display it						;
3644: F45C C3 2C E9               JP     ConIn                ; Get the input character			;
3645: F45F         ;
3646: F45F         ;***************************************************************************;
3647: F45F         ;
3648: F45F 42 44 4F 53 20 45 72 72 20 4F 6E 20     ErrMsg_BDOS: DB     'BDOS Err On '       ;
3649: F46B 20 3A 20 24     ErrMsg_BDOS_DISK: DB     ' : $'               ;
3650: F46F 42 61 64 20 53 65 63 74 6F 72 24     ErrMsg_BadSector: DB     'Bad Sector$'        ;
3651: F47A 53 65 6C 65 63 74 24     ErrMsg_Selection: DB     'Select$'            ;
3652: F481 52 2F 4F 20 46 69 6C 65 24     ErrMsg_ReadOnlyFile: DB     'R/O File$'          ;
3653: F48A 52 2F 4F 20 44 69 73 6B 24     ErrMsg_ReadOnlyDisk: DB     'R/O Disk$'          ;
3654: F493         ;
3655: F493         ;============================= Error message World =========================;
3656: F493         ;********* file control block (fcb) constants ********************
3657: F493             fcbLength  EQU    20H                  ; File control block size
3658: F493             fcbROfileIndex EQU    09H                  ; High order of first type char
3659: F493             fcbHiddenfileIndex EQU    0AH                  ; Hidden file in dir command
3660: F493             fcbExtIndex EQU    0CH                  ; Extent number field index
3661: F493             fcbS1Index EQU    0DH                  ; S1 index
3662: F493             fcbS2Index EQU    0EH                  ; S2 data module number index
3663: F493             fcbRCIndex EQU    0FH                  ; Record count field index
3664: F493             fcbDiskMapIndex EQU    10H                  ; Disk map start
3665: F493             fcbExtIndexLSB EQU    0CH                  ; LSB of Extent
3666: F493             fcbExtIndexMSB EQU    0EH                  ; Bit 7 = Write protected
3667: F493             fcbCurrentRecord EQU    21H                  ; Next record to read/write
3668: F493             highestRecordNumber EQU    RecordsPerExtent - 1 ; Last record# in extent
3669: F493             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; Directory entries / record
3670: F493             dirEntryShift EQU    2                    ; Log2(dirEntriesPerRecord)
3671: F493             dirEntryMask EQU    dirEntriesPerRecord-1
3672: F493             fcbShift   EQU    5                    ; Log2(fcbLength)
3673: F493         ;
3674: F493             maxExtValue EQU    31                   ; Largest extent number
3675: F493             moduleMask EQU    15                   ; Limits module number value
3676: F493             writeFlagMask EQU    80h                  ; File write flag is high order fcbS2Index
3677: F493             nameLength EQU    15                   ; Name length
3678: F493             emptyDir   EQU    0E5H                 ; Empty empty directory entry
3679: F493             recordSeq  EQU    fcbLength            ; Next Sequential Record
3680: F493             recordRandom EQU    recordSeq + 1        ; Random record field (2 bytes)
3681: F493             recordRandomLSB EQU    recordRandom         ; LSB of Random Record
3682: F493             recordRandomMSB EQU    recordRandom + 1     ; MSB of Random Record
3683: F493             recordRandomOVF EQU    recordRandom + 2     ; Random Record Overflow
3684: F493         ;***common values shared between bdosi and bdos******************
3685: F493 00          currentUserNumber: DB     0                    ; usrcode current user number
3686: F494 FF          currentDisk: DB     -1                   ; curdsk current disk number
3687: F495         ;********************* Local Variables ***************************
3688: F495         ;	************************
3689: F495         ;	*** Initialized Data ***
3690: F495 E5          emptyFCB:  DB     emptyDir             ; 0E5 = available dir entry
3691: F496 00 00       readOnlyVector: DW     0                    ; Read only disk vector
3692: F498 00 00       loggedDisks: DW     0                    ; Logged-in disks
3693: F49A 80 00       initDAMAddress: DW     DMABuffer            ; Initial DMA address
3694: F49C         ;	*** Current Disk attributes ****
3695: F49C         ; These are set upon disk select
3696: F49C         ; data must be adjacent, do not insert variables
3697: F49C         ; address of translate vector, not used
3698: F49C         ; ca - currentAddress
3699: F49C 00 00       caDirMaxValue: DW     0000H                ; Pointer to cur dir max value
3700: F49E 00 00       caTrack:   DW     0000H                ; Current track address
3701: F4A0 00 00       caSector:  DW     0000H                ; Current Sector
3702: F4A2             caListSizeStart:
3703: F4A2 00 00       caDirectoryDMA: DW     0000H                ; Pointer to directory DMA address
3704: F4A4 00 00       caDiskParamBlock: DW     0000H                ; Current disk parameter block address
3705: F4A6 00 00       caCheckSum: DW     0000H                ; Current checksum vector address
3706: F4A8 00 00       caAllocVector: DW     0000H                ; Current allocation vector address
3707: F4AA             caListSizeEnd:
3708: F4AA             caListSize EQU    caListSizeEnd - caListSizeStart
3709: F4AA         ;	***** Disk Parameter Block *******
3710: F4AA         ; data must be adjacent, do not insert variables
3711: F4AA         ; dpb - Disk Parameter Block
3712: F4AA             dpbStart:
3713: F4AA 00 00       dpbSPT:    DW     0000H                ; Sectors per track
3714: F4AC 00          dpbBSH:    DB     0000H                ; Block shift factor
3715: F4AD 00          dpbBLM:    DB     00H                  ; Block mask
3716: F4AE 00          dpbEXM:    DB     00H                  ; Extent mask
3717: F4AF 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3718: F4B1 00 00       dpbDRM:    DW     0000H                ; Largest directory number
3719: F4B3 00 00       dpbDABM:   DW     0000H                ; Reserved allocation bits for directory
3720: F4B5 00 00       dpbCKS:    DW     0000H                ; Size of checksum vector
3721: F4B7 00 00       dpbOFF:    DW     0000H                ; Offset tracks at beginning
3722: F4B9             dpbEnd:
3723: F4B9             dpbSize    EQU    dpbEnd - dpbStart
3724: F4B9         ;
3725: F4B9         ;	************************
3726: F4B9             SEQ_ACCESS EQU    01H                  ; Indicates sequential access to file
3727: F4B9             RANDOM_ACCESS EQU    00H                  ; Indicates random access to file
3728: F4B9 00          diskAccessType: DB     00H                  ; Set to 1 if sequential disk operation
3729: F4BA 00 00       caSkewTable: DW     0000H                ; Address of translate vector
3730: F4BC 00          fcbCopiedFlag: DB     00H                  ; Set true if CopyFCB called
3731: F4BD 00          readModeFlag: DB     00H                  ; Read mode flag for Open NextExt
3732: F4BE 00          directoryIndex: DB     00H                  ; Directory flag in rename, etc.
3733: F4BF 00          diskMapIndex: DB     00H                  ; Local for Disk_Write
3734: F4C0 00          searchLength: DB     00H                  ; Search length
3735: F4C1 00 00       searchAddress: DW     0000H                ; Search address
3736: F4C3 00          byteAllocationFlag: DB     00H                  ; Set true if single byte allocation map
3737: F4C4 00          fResel:    DB     00H                  ; Re selection flag
3738: F4C5 00          entryDisk: DB     00H                  ; Disk on entry to BDOS
3739: F4C6 00          fcbDisk:   DB     00H                  ; Disk named in FCB
3740: F4C7 00          fcbRecordCount: DB     00H                  ; Record count from current FCB
3741: F4C8 00          extentValue: DB     00H                  ; Extent number and dpbEXM from current FCB
3742: F4C9 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3743: F4CB 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3744: F4CD         ;
3745: F4CD         ;	local variables for directory access
3746: F4CD 00          dirBlockIndex: DB     00H                  ; Directory block Index 0,1,2,3
3747: F4CE 00 00       dirEntryIndex: DW     00H                  ; Directory entry Index	0,1,...,dpbDRM
3748: F4D0 00 00       dirRecord: DW     00H                  ; Directory record 0,1,...,dpbDRM/4
3749: F4D2         ;********************** data areas ******************************
3750: F4D2         ;---------------------------------- Stack Area--------------------------------;
3751: F4D2             stackBottom: DS     STACK_SIZE * 2       ; stack size						;
3752: F512             bdosStack:
3753: F512         ;
3754: F512         ;---------------------------------- Stack Area--------------------------------;
3755: F512         ;	end of Basic I/O System
3756: F512         ;-----------------------------------------------------------------;
3757: F512
3758: F512         ;
3759: F512             Z_HighestLocation:
3760: F512             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
           ************************   Xref   ************************
0000: $               F512   0363 0393
3743: absoluteCPMRecord F4CB   1491 3207 3248 3260 3272 3458 3465 3484
1505: Allocate16Bit   EBE6   1502
0961: AreWeAtEndOfBuffer EA3C   0957
0072: ASCII_A         0041   3638
0073: ASCII_C         0043
0074: ASCII_M         004D
0036: ASCII_MASK      007F   0904
0075: ASCII_O         004F
0076: ASCII_Y         0059
0059: ASCII_ZERO      0030
0057: ASTERISK        002A
2939: AtEndOfDirectory F152   1338 1621 1803 1976 2223 2254 2318 2410 2682 3284 3314 3322
1053: BackUp          EA9B   0981 1049
1058: BackUp1         EAA3   1054
0241: bcBoot          F600
0244: bcConin         F609   0552 0728 0833 0851
0245: bcConout        F60C   0545 0796 1056 1060 1066 1068
0243: bcConst         F606   0549 0829
0249: bcHome          F618   2437
0246: bcList          F60F   0519 0802
0256: bcListst        F62D
0247: bcPunch         F612   0505
0254: bcRead          F627   2475
0248: bcReader        F615   0487
0257: bcSectran       F630
0250: bcSeldsk        F61B   2126
0253: bcSetdma        F624   2470
0252: bcSetsec        F621   3500
0251: bcSettrk        F61E   2443 3497
0242: bcWboot         F603   0413
0255: bcWrite         F62A   2770
0132: BDOSBase        E800   0133 0135 0270
0101: BDOSE           0005   0102
0133: BDOSEntry       E800
0122: BDOSLength      0E00   0125 0135 0136
3752: bdosStack       F512   0285
0275: BdosStart       E800
0135: BIOSBase        F600
0123: BIOSLength      0A00   0125
0095: BIOSPAGE        0002
0136: BIOSStart       F600   0241 0242 0243 0244 0245 0246 0247 0248 0249 0250 0251 0252 0253 0254 0255 0256 0257 3760
0191: BlockSize       0800   0213
0976: BSspaceBS       EA49   0915
0032: BYTE            0001   1086
3736: byteAllocationFlag F4C3   1500 2159 2331 3015 3230
3706: caAllocVector   F4A8   1711 2179 2181 2206 2590 3068 3135
3705: caCheckSum      F4A6   3528
3703: caDirectoryDMA  F4A2   2146 2464 2954 3145 3520
3699: caDirMaxValue   F49C   2137 2213 2492 2988
3704: caDiskParamBlock F4A4   1823 2151
3708: caListSize      0008   2147
3707: caListSizeEnd   F4AA   3708
3702: caListSizeStart F4A2   3708
0077: CARET           005E   0764
0758: CaretOut        E953   0950 1031
3701: caSector        F4A0   2143 2451 3488
3729: caSkewTable     F4BA   2135
3700: caTrack         F49E   2140 2447 3479
0130: CCPEntry        E000   0132 0136
0121: CCPLength       0800   0125 0132 0136
0847: CheckCTL_S      E9B7   0836
2720: CheckExtents    F04F   2714
3164: CheckRODirectory F23B   1341 1624
3167: CheckROFile     F23E   1463
3508: CheckSumUtility F3C5   2754 3450
3158: CheckWrite      F234   1334 1461 1611 2403
2299: CloseDirEntry   EE40   1196 2837 3283
2387: CloseDirEntryEnd EEAD   2377
2395: CloseDirEntryError EEB9   2347 2357 2362
0060: COLON           003A
1084: columnPosition  EABD   0782 0806 0869 0887 1045
2645: CompareExtents  EFF0   2721
3518: ComputeCheckSum F3D1
3522: ComputeCheckSum1 F3D8   3525
0107: ComTail         0080   0108
0109: ComTailChars    0081
0108: ComTailCount    0080   0109
0824: ConBreak        E997   0660 0792
0857: ConBreak0       E9C5   0849
0859: ConBreak1       E9C8   0827
0721: ConIn           E92C   0442 0903 3644
0789: ConsoleOut      E976   0765 0776 0781 0866 0874 0880 0882 0973
3186: CopyDir         F24C   1627 1808
3144: CopyDirEntryToUserDMA F220   1248 1312
2257: CopyDirRecordToFCB EE08   3327
3180: CopyFCB         F248   2429
0168: cpmRecordSize   0080   0170 0173 0175 3147 3519 3669
0052: CR              000D   0733 0879 0908 0972
0039: CTRL_C          0003   0852 0955 3625
0040: CTRL_E          0005   0920
0041: CTRL_H          0008   0739 0914 1059
0042: CTRL_L          000C
0043: CTRL_P          0010   0835 0923
0044: CTRL_R          0012   0932
0045: CTRL_S          0013   0848
0046: CTRL_U          0015   0929
0047: CTRL_X          0018   0926
0048: CTRL_Z          001A
3686: currentDisk     F494   1120 1673 2095 2106 2112 2124 2485 2503 2521 3637
3742: currentFileRecord F4C9   1397 1406 1465 1524 1556 2544 2781 3215 3268
3685: currentUserNumber F493   0709 0714 2231 2530
0202: DataBlocks      02C7   0212
0201: DataSectors     0B1C   0202
1337: DeleteFileLoop  EB20   1348
1040: DeleteTheLine   EA8A   0927
1043: DeleteTheLine1  EA8B   1050
3746: dirBlockIndex   F4CD   2955 3442
0173: DirBuffSize     0080
0188: DirectoryBlockCount 0002   0213
0175: DirectoryEntryPerRecord 0004   0216
3732: directoryIndex  F4BE   2671 2735 3153
3669: dirEntriesPerRecord 0004   3671
3747: dirEntryIndex   F4CE   2731 2930 2940 2986 3425 3427 3436 3455
3671: dirEntryMask    0003   2732 3437
3670: dirEntryShift   0002   3456
0172: DirEntrySize    0020   0175 0213
3152: DirLocationToReturnLoc F22D   1339 1622 1804
3748: dirRecord       F4D0   3459 3510 3529
3728: diskAccessType  F4B9   1392 1457 1546 2779 2796
0160: DiskCommandBlock 0046
0159: DiskControlByte 0045
0162: DiskControlTable 0040
0363: diskf           000B
3733: diskMapIndex    F4BF   1473 1496
1393: DiskRead        EB44   1888
0164: DiskReadCode    0001
0169: diskSectorSize  0200   0170 0191 0199
0158: DiskStatusLocation 0043
1458: DiskWrite       EB87   1930
1531: DiskWrite1      EC0E   1527
1541: DiskWrite2      EC17   1535
1559: DiskWriteCleanup EC34   1545 1548
1557: DiskWriteCleanup0 EC32   1554
0165: DiskWriteCode   0002
1455: DiskWriteSeq    EB82
3634: DisplayErrorAndWait F446   3624 3630
3359: DivideHLby8     F317   2174 3054 3057
0112: DMABuffer       0080   1122 3693
0055: DOLLAR          0024   0747 2237
0214: dpb3hdAL0       00C0
0215: dpb3hdAL1       0000
0210: dpb3hdBLM       000F
0209: dpb3hdBSH       0004
0216: dpb3hdCKS       0020
0213: dpb3hdDRM       007F   0216
0212: dpb3hdDSM       02C6
0211: dpb3hdEXM       0000
0218: dpb3hdNOH       0002
0217: dpb3hdOFF       0001
0208: dpb3hdSPT       0090
3715: dpbBLM          F4AD   3266
3714: dpbBSH          F4AC   3213 3258
3720: dpbCKS          F4B5   3509
3719: dpbDABM         F4B3   2204
3718: dpbDRM          F4B1   2490 3424
3717: dpbDSM          F4AF   2157 2173 2189 3053
3722: dpbEnd          F4B9   3723
3716: dpbEXM          F4AE   2549 2648 3295
3721: dpbOFF          F4B7   2439 3493
3723: dpbSize         000F   2153
3713: dpbSPT          F4AA   3466
3712: dpbStart        F4AA   2152 3723
0395: DUMMY           E8B1   0390 0391
3678: emptyDir        00E5   1343 2227 2688 3690
3690: emptyFCB        F495   2406
0116: END_OF_FILE     001A
0037: EndOfMessage    0000
0966: EndRead         EA3F   0909 0912
3738: entryDisk       F4C5   0335 2522
0229: EOD             FFFF   2929
0064: EQUAL_SIGN      003D
3650: ErrMsg_BadSector F46F   3623
3648: ErrMsg_BDOS     F45F   3640
3649: ErrMsg_BDOS_DISK F46B   3639
3653: ErrMsg_ReadOnlyDisk F48A   3615
3652: ErrMsg_ReadOnlyFile F481   3619
3651: ErrMsg_Selection F47A   3611
3622: Error_BadSector F434   2477 2772
3614: Error_DiskReadOnly F428   3161
3618: Error_FileReadOnly F42E   3173
3610: Error_Select    F422   2105
1088: exitParameterByte EAC1   0444 0450 0553 0661 0686 0710 1407 1488 1514 1551 1674 2241 2301 2396 2733 2747 2841 2848 2860 2867 2875 3154 3331 3407
1089: exitParameterWord EAC1   0291 0344 0488 0572 1651 1712 1756 1824
3741: extentValue     F4C8   2551
0029: FALSE           0000   0842 1011 1344 1459 1928 2163 2680
0104: FCB1            005C   0105
0105: FCB2            006C
3730: fcbCopiedFlag   F4BC   2389 3282 3298
3667: fcbCurrentRecord 0021
3739: fcbDisk         F4C6   0293 0330 2524
3664: fcbDiskMapIndex 0010   1494 1617 1625 2323 2328 3005 3007 3227
3660: fcbExtIndex     000C   1335 1612 1626 1800 1807 1963 2272 2371 2380 2570 2712 2825 2845 2889 3304
3665: fcbExtIndexLSB  000C
3666: fcbExtIndexMSB  000E
3659: fcbHiddenfileIndex 000A
3657: fcbLength       0020   2266 2328 2371 2421 3007 3182 3669 3679
3663: fcbRCIndex      000F   1979 2275 2293 2380 2559 2562
3740: fcbRecordCount  F4C7   1398 1525 2547 2785
3658: fcbROfileIndex  0009   3168
3661: fcbS1Index      000D   2425 2709
3662: fcbS2Index      000E   2308 2615 2626 2637 2829 2846 2871 2906 3304
3672: fcbShift        0005   3438
1482: FindAvailableBlock EBBE   1476
1490: FoundAvailableBlock EBCB   1486
3114: FoundFreeOctet  F1FB   3084 3089 3098 3106
3120: FoundFreeOctet1 F201   3116
3122: FoundFreeOctet2 F202   3118
3124: FoundFreeOctet3 F205   3127
3130: FoundFreeOctet4 F20D   3132
3737: fResel          F4C4   0294 0324 2512
0393: functionCount   0028   0303
0350: functionTable   E85F   0308 0363 0393
3202: GetBlockNumber  F263   1411 1468
3050: GetClosestBlock F1AA   1483
2952: GetCurrentDirectoryRecord F15B   1342 1978 2226 2262 2322 2698 3004 3165 3193
3237: GetDiskMap16Bit F28F   3232
3212: GetDiskMapIndex F270   1472 3203
3216: GetDiskMapIndexLoop F277   3218
3225: GetDiskMapValue F27D   1479 3206
2568: GetExtentAddress EF9B   2258 2548 3287
2557: GetFcbRecordDetails EF8E   2541 2778
1975: GetFileSize1    ECDF   2002
2000: GetFileSize2    ECFF   1993
2003: GetFileSizeExit ED04   1977
2679: GetNextDirectoryRecord F016   1311 1347 1629 1809 2001 2717 2722
2697: GetNextDirectoryRecord1 F030   2689
2882: GetRandomRecordPosition F11E   1980 2033
0065: GREATER_THAN    003E
0054: HASH_TAG        0023   0865
1513: HaveWriteBlock  EBEF   1471
3668: highestRecordNumber 007F   1466 1544
2436: Home            EEF8   2212 2677
1063: IgnoreTheLine   EAA8   0930
3693: initDAMAddress  F49A   1123 1695 2460 3146
2172: InitDisk        ED8F   2118
2219: InitDisk1       EDD4   2229 2247
2242: InitDisk2       EDF5   2233 2238
2612: InitializeExtentNumberMSB EFC9   1164 1243 1580
0096: IOBYTE          0003   0571 0591
3553: IsBitSet        F3F4   2109 2505 3574 3586
3560: IsBitSet1       F3FB   3558
3555: IsBitSetLoop    F3F5   3563
2501: IsDiskWriteProtected EF40   2302 3159
0928: IsItDeleteTheLineU EA1D
0925: IsItDeleteTheLineX EA19
0922: IsItPrintToggle EA15
1012: IsItPrintToggle1 EA6D   1010
0916: IsItRubout      EA0D
0919: IsPhysicalEOL   EA11
0732: IsPrintableASCII E937   0443 0760
0997: ItIsPhysicalEOL EA5B   0921
1004: ItIsPrintToggle EA62   0924
0985: ItIsRubout      EA52   0918
1078: keyboardByte    EABA   0722 0825 0858
2597: Left            EFBA   2599
0068: LEFT_ARROW      005F
0125: LengthInBytes   2000   0126 0130 0199
0126: LengthInK       0009
0063: LESS_THAN       003C
0051: LF              000A   0735 0812 0881 0910
1026: LL1             EA7A   1034
0030: LO_NIBBLE_MASK  000F   0713 2902
3692: loggedDisks     F498   1118 1650 2108 2114 2116
3082: LookRight       F1CF   3092
2402: MakeNewFile     EEBE   1582 2858 3321
2202: Mark4Directory  EDBC   2194
1510: MarkNewBlock    EBEA   1504
3674: maxExtValue     001F   2657 3290
0128: MemorySize      0040   0130
3387: Merge           F32B   2351 2353
2330: MergeAllocationMaps EE6C   2368
2345: MergeDirEntryNot0 EE7D   2342
2340: MergeFCBisNot0  EE78   2338
2364: MergeMapLoop    EE95   2348
2350: MergeWordMaps   EE82   2333
3675: moduleMask      000F   3308
3371: MultiplyHLby8   F321   2188 3138
0200: myOffset        0001   0201 0217
3677: nameLength      000F   1245 2252 2316 2415 2421 3312
2744: NoDirRecordsMatch F06B   2683 2695
3110: NoFreeBlocks    F1F7   3099 3107
3094: NoMoreLeft      F1E1   3090
3096: NoMoreLeftLoop  F1E2   3100
3102: NoMoreRight     F1EC   3085
3104: NoMoreRightLoop F1ED   3108
2529: NoSelect        EF6E   2519
1419: NothingRead     EB7C   1403 1409 1413
0854: NothingWaiting  E9C3   0845
0184: NumberOfHeads   0002   0195 0197 0208 0218
0181: NumberOfLogicalDisks 0004
2251: OpenFile        EDFF   1166 2847
3280: OpenNextExt     F2B3   1404 1550
3311: OpenNextExt1    F2DF   3300
3328: OpenNextExt3    F2FC   3324
3334: OpenNextExtError F304   3309 3319 3323
3303: OpenNextModule  F2D5   3292
2291: OpenSetRecordCount EE37   2287 2289
1087: paramDE         EABF   0280 0328 0613 0889 0968 1023 1237 1309 1462 1493 1615 1694 1966 2031 2265 2292 2307 2326 2404 2407 2412 2424 2513 2531 2558 2569 2614 2625 2636 2674 2798 3190 3226
1086: paramE          EABE   0282 0336 0706 2094 2517
0056: PERCENT         0025
0058: PERIOD          002E
0099: Pg0CurentDisk   0004
0098: Pg0CurentUser   0004   0099
0745: Print           E946   0616 0754 3641 3643
1080: printEchoFlag   EABB   0800 0838 1007
0066: QMARK           003F   1239 2705
1246: QMarkFind       EB00   1240
0092: RAM             0000   0094 0095 0096 0098 0101 0104 0107 0112 0114
3727: RANDOM_ACCESS   0000
2794: RandomSeek      F09E   1887 1929
2834: RandomSeekClose F0DC   2827
2872: RandomSeekError F116   2822
2870: RandomSeekErrorBadSeek F112   2843 2856 2862
2864: RandomSeekExit  F10C   2832 2850
2474: ReadBuffer      EF20   1416 3415
3423: ReadDirectory   F348   2222 2681
3435: ReadDirectory0  F35C   3430
3439: ReadDirectory1  F363   3441
3413: ReadDirRecord   F33F   3448
0946: ReadEchoRubOut  EA29   0994
3731: readModeFlag    F4BD   1395 1460 3317
0899: ReadNext        E9F8   0963 0989 1015 1037
0902: ReadNext0       E9FA   0982 1001
3691: readOnlyVector  F496   1117 1755 2483 2488 2502
0886: ReadString      E9EB   0646 1047 1069
3602: ReAlignMap1     F41B   3600
3597: ReAlignMapLoop  F415   3605
3595: ReAlignVector   F414   3578
1410: RecordOK        EB67   1400
3680: recordRandom    0021   1967 2035 3681 3682 3683
3681: recordRandomLSB 0021   2799 2802
3682: recordRandomMSB 0022   2804
3683: recordRandomOVF 0023   2818
3679: recordSeq       0020   2032 2562 2824 3680
0193: RecordsPerBlock 0010
0177: RecordsPerExtent 0080   1402 2290 3668
0170: recordsPerSector 0004   0193 0208
1620: RenameLoop      EC54   1630
1018: RepeatLine      EA71   0933
2510: ReselectDisk    EF4B   1165 1195 1244 1310 1333 1389 1454 1581 1610 1799 1885 1927 1962
2634: ResetFileWriteFlag EFE3   1511 1537
3584: ResetVectorBit  F40D
0323: ReturnToCaller  E836   0297
0339: ReturnToCaller1 E851   0326 0332 0551
2605: Right           EFC4   2603 2607
3345: RotateRightHLbyB F30A   3353
3350: RotateRightHLbyB1 F310   3348
0069: RUBOUT          007F   0917
3002: ScanDiskMap     F17F   1345 2245
3009: ScanDiskMap0    F189   3041
3034: ScanDiskMap2    F1A0   3023
3025: ScanDiskMapWord F19A   3017
3735: searchAddress   F4C1   1308 2675 2685
2669: SearchForDirectoryRecord F001   1247 1336 1613 1801 1964 2253 2317 2409 3313
3734: searchLength    F4C0   2672 2699
0222: SectorMask      0003
0187: SectorsPerBlock 0004   0191 0193 0196 0202 0222
0197: SectorsPerCylinder 0024   0200 0201
0186: SectorsPerTrack 0012   0195 0197 0208
3463: Seek            F387   1415 1519 3460
3468: Seek0           F391   3472
3454: SeekDir         F376   2391 3197 3447
2103: Select          ED28   1125 2099
2093: SelectCurrent   ED1D   0337 1148 2527
2123: SelectDisk      ED49   2104
2166: SelectDisk1     ED8B   2162
0062: SEMICOLON       003B
3726: SEQ_ACCESS      0001   1391 1456
3257: SetActualRecordAdd F29B   1414 1518
3262: SetActualRecordAddLoop F2A2   3264
1802: SetAttributesLoop EC99   1810
2197: SetBitLoop      EDB7   2200
2459: SetDataDMA      EF12   1124 1696 2759 3416
2463: SetDirDMA       EF17   2756 3414
2966: SetDirectoryEntry F169   2246 2428
2482: SetDiskReadOnly EF28   1738 3540
2466: SetDMA          EF1A   2461
2928: SetEndDirectory F14B   2217 2676 2745 3431
3405: SetExitParamTo1 F339   1420 1467 3335
2623: SetFileWriteFlag EFD6   2270 2431 2876 3336
3544: SetNewCheckSum  F3F2   3533
2724: SetNextPosition F054   2706 2710 2718
2540: SetRecordVars   EF77   1396 1464 3329
2579: SetResetMapBit  EFA3   3037
0712: SetUserNumber   E926   0708
3572: SetVectorBit    F404   2115 2487
3374: ShiftLeftHLbyB  F323   3378
3362: ShiftRightHLbyB F319   2589 3366 3457
0878: showCRLF        E9E1   0867 1000 3636
0864: showHashCRLF    E9CB   1021 1064
0868: showHashCRLF1   E9D3   0875
0053: SPACE           0020   0741 0780 0809 0873 1055 1065 1067
0228: STACK_SIZE      0020   3751
3751: stackBottom     F4D2
1083: startingColumn  EABC   0870 0888 1044
2985: StillInDirectory F172   2693 2967 3538
0199: SystemSectors   0011   0200
0050: TAB             0009   0737 0775
0773: TabOut          E963   0448 0468 0752 0761
0779: TabOut0         E969   0784
2703: TestNextPosition F039   2729
0843: ToggleFlag1     E9B4   0841
0102: TopRAM          0007
0196: TotalNumberOfBlocks 02D0
0195: TotalNumberOfSectors 0B40   0196 0201
0114: TPA             0100
0185: TracksPerHead   0050   0195
0028: TRUE            FFFF   0839 0860 1008 1394 1886 2160 2167 2221 2244 2388 2511 2753
0067: UNDER_SCORE     005F
3326: UpdateFCB       F2F9   3301 3315
2777: UpdateRecordVariables F08C   1417 1549 1560
1076: usersStack      EAB8   0284 0342
1194: vCloseFile      EAE8   0368
1961: vComputeFileSize ECCA   0387
0441: vConsoleIn      E8B5   0352
0467: vConsoleOut     E8C9   0353
1332: vDeleteFile     EB15   0371
0540: vDirectConIO    E8DC   0357
0548: vDirectConIO1   E8E4   0543
0227: VERSION         0020   0685
1235: vFindFirst      EAEE   0369
1307: vFindNext       EB06   0370
1710: vGetAllocAddr   EC80   0379
0659: vGetConsoleStatus E90B   0362
1672: vGetCurrentDisk EC70   0377
1822: vGetDiskParamBlock ECAB   0383
0570: vGetIOBYTE      E8F2   0358
1649: vGetLoginVector EC69   0376
1754: vGetReadOnlyMap EC8A   0381
0705: vGetSetUserNumber E918   0384
0684: vGetVersion     E912   0364
0518: vListOut        E8D8   0356
1579: vMakeFile       EC37   0374
1163: vOpenFile       EADF   0367
0612: vPrintString    E8FE   0360
0504: vPunchOut       E8D4   0355
0486: vReaderIn       E8CD   0354
1884: vReadRandom     ECB2   0385
1388: vReadSeq        EB3C   0372
0645: vReadString     E907   0361
1609: vRenameFile     EC40   0375
2064: vResetDrive     ED19   0389
1115: vResetSystem    EAC3   0365
1147: vSelectDisk     EADC   0366
1693: vSetDMA         EC77   0378
1798: vSetFileAttributes EC91   0382
0590: vSetIOBYTE      E8F9   0359
2030: vSetRandomRecord ED06   0388
0412: vSystemReset    E8B2   0351
1737: vWriteProtectDisk EC87   0380
1926: vWriteRandom    ECBE   0386
2088: vWriteRandom0Fill ED1C   0392
1453: vWriteSeq       EB7F   0373
3629: WaitBeforeBoot  F440   3612 3616 3620
0094: WarmBoot        0000   0853 0959 3626 3631
3247: WasBlockAllocated F295   1412 1469
0033: WORD            0002   1087 1089
0237: WriteAllocated  0000   1470
2769: WriteBuffer     F084   1522 2758
0239: WriteCleanBuffer 0002   1512 1530
2751: WriteDir        F074   1346 2392 3198
0238: WriteDirectory  0001   2757
3676: writeFlagMask   0080
3759: Z_HighestLocation F512   3760
3760: Z_MemoryLeft    00ED
