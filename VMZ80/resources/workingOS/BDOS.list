0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process vReadRandom - 21 (33)
0005: E800
0006: E800         ; 2019-02-04 Fixed bdosStack problem
0007: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0008: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0009: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0010: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0011: E800         ; 2018-03-02 Refactored the CP/M Suite
0012: E800         ; 2018-02-12 fixed allocate 16 bit problem
0013: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0014: E800         ; 2014-03-14  :  Frank Martyn
0015: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0016: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.asm
0023: E800         ; standard equates
0024: E800
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; not false
0029: E800             FALSE      EQU    0000H
0030: E800             ON         EQU    -1
0031: E800             OFF        EQU    0000H
0032: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0033: E800
0034: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0035: E800             WORD       EQU    2                    ; number of bytes for "word" type
0036: E800
0037: E800
0038: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0039: E800             ZERO       EQU    00H                  ; Zero
0040: E800             EndOfMessage EQU    00H
0041: E800
0042: E800             CTRL_C     EQU    03H                  ; ETX
0043: E800             CTRL_E     EQU    05H                  ; physical eol
0044: E800             CTRL_H     EQU    08H                  ; backspace
0045: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0046: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0047: E800             CTRL_P     EQU    10H                  ; prnt toggle
0048: E800             CTRL_R     EQU    12H                  ; repeat line
0049: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0050: E800             CTRL_U     EQU    15H                  ; line delete
0051: E800             CTRL_X     EQU    18H                  ; =ctl-u
0052: E800             CTRL_Z     EQU    1AH                  ; end of file
0053: E800
0054: E800             NULL       EQU    00H                  ; Null
0055: E800             SOH        EQU    01H                  ; Start of Heading
0056: E800             BELL       EQU    07H                  ; Bell
0057: E800             TAB        EQU    09H                  ; Tab
0058: E800             LF         EQU    0AH                  ; Line Feed
0059: E800             CR         EQU    0DH                  ; Carriage Return
0060: E800             SPACE      EQU    20H                  ; Space
0061: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0062: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0064: E800             PERCENT    EQU    25H                  ; Percent Sign
0065: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0066: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0067: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0068: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0069: E800             COMMA      EQU    2CH                  ; Comma
0070: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0071: E800             PERIOD     EQU    2EH                  ; Period
0072: E800             SLASH      EQU    2FH                  ; /
0073: E800             ASCII_ZERO EQU    30H                  ; zero
0074: E800             COLON      EQU    3AH                  ; Colon
0075: E800
0076: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0077: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0078: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0079: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0080: E800             QMARK      EQU    3FH                  ; Question Mark
0081: E800             UNDER_SCORE EQU    5FH                  ; under score _
0082: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0083: E800             RUBOUT     EQU    7FH                  ; Delete Key
0084: E800
0085: E800
0086: E800             ASCII_A    EQU    'A'
0087: E800             ASCII_C    EQU    'C'
0088: E800             ASCII_K    EQU    'K'
0089: E800             ASCII_N    EQU    'N'
0090: E800             ASCII_Q    EQU    'Q'
0091: E800             ASCII_R    EQU    'R'
0092: E800             ASCII_W    EQU    'W'
0093: E800             ASCII_Y    EQU    'Y'
0094: E800             CARET      EQU    '^'
0095: E800             ASCII_LO_A EQU    'a'
0096: E800             ASCII_LO_K EQU    'k'
0097: E800             ASCII_LO_P EQU    'p'
0098: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0099: E800
0100: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E800                        Include ./osHeader.Z80
0102: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0103: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0104: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0105: E800         ; osHeader.Z80
0106: E800
0107: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0108: E800         ; 2017-03-02 Refactored the CP/M Suite
0109: E800
0110: E800         ; Contains the Equates used by the CP/M system
0111: E800
0112: E800         ;------------------------Page Zero Constants ---------------------------------
0113: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0114: E800
0115: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0116: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0117: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0118: E800
0119: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0120: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0121: E800
0122: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0123: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0124: E800
0125: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0126: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0127: E800
0128: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0129: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0130: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0131: E800         ;-----------------------------------------------------------------------
0132: E800
0133: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0134: E800         ;-----------------------------------------------------------------------
0135: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0136: E800         ;-----------------------------------------------------------------------
0137: E800             END_OF_FILE EQU    1AH                  ; end of file
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;--------------- CP/M Constants -----------------------------------------
0141: E800
0142: E800             CCPLength  EQU    0800H                ; Constant
0143: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0144: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0145: E800
0146: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0147: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0148: E800
0149: E800             MemorySize EQU    64
0150: E800
0151: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0152: E800
0153: E800             BDOSBase   EQU    CCPEntry + CCPLength
0154: E800             BDOSEntry  EQU    BDOSBase
0155: E800
0156: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0157: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0158: E800         ;-----------------------------------------------------------------------
0159: E800
0160: E800         ;------------------- BDOS System Call Equates --------------------------
0161: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0162: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0163: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0164: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0165: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0166: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0167: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0168: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0169: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0170: E800             fCloseFile EQU    10H                  ; closef - Close File
0171: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0172: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0173: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0174: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0175: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0176: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0177: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0178: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0179: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0180: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0181: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0182: E800         ;-----------------------------------------------------------------------
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800
0188: E800         ;*******************************************************************************
0189: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0190: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0191: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0192: E800         ; sector write) or to an allocation block that has already been allocated to a
0193: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0194: E800         ;*******************************************************************************
0195: E800             WriteAllocated EQU    00H
0196: E800             WriteDirectory EQU    01H
0197: E800             WriteCleanBuffer EQU    02H
0198: E800
0199: E800
0200: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E800                        Include ./diskHeader.Z80
0202: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0203: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0204: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0205: E800         ; diskHeader.asm
0206: E800
0207: E800         ; 2017-03-02 Refactored the CP/M Suite
0208: E800
0209: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0210: E800
0211: E800         ; Contains the Equates used by the CP/M system to handle disks
0212: E800
0213: E800
0214: E800         ;*******************************************************************************
0215: E800         ;
0216: E800         ;     Disk related values
0217: E800         ;
0218: E800         ;
0219: E800         ;*******************************************************************************
0220: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0221: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0222: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0223: E800         ; for boot
0224: E800             DiskControlTable EQU    0040H
0225: E800
0226: E800             DiskReadCode EQU    01H                  ; Code for Read
0227: E800             DiskWriteCode EQU    02H                  ; Code for Write
0228: E800
0229: E800
0230: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0231: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0232: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0233: E800
0234: E800             DirEntrySize EQU    20H                  ; (32)
0235: E800             DirBuffSize EQU    cpmRecordSize
0236: E800
0237: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0238: E800
0239: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0240: E800
0241: E800
0242: E800         ;-------------------------------------------------------------------------------------
0243: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0244: E800
0245: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0246: E800             NumberOfHeads EQU    02H                  ; number of heads
0247: E800             TracksPerHead EQU    50H                  ; 80
0248: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0249: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0250: E800             DirectoryBlockCount EQU    02H                  ;
0251: E800         ;-----------------------------------------------------------------------
0252: E800
0253: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0254: E800
0255: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0256: E800
0257: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0258: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0259: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0260: E800
0261: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0262: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0263: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0264: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0265: E800
0266: E800         ;-----------------------------------------------------------------------
0267: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0268: E800         ;-----------------------------------------------------------------------
0269: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0270: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0271: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0272: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0273: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0274: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0275: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0276: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0277: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0278: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0279: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0280: E800             dpb3hdNOH  EQU    NumberOfHeads
0281: E800
0282: E800         ;*******************************************************************************
0283: E800
0284: E800             SectorMask EQU    SectorsPerBlock - 1
0285: E800
0286: E800         ;***************************************************************************
0287: E800
0288: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0289: E800
0290: E800             VERSION    EQU    20H                  ; Version 2.0
0291: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0292: E800             EOD        EQU    -1                   ; End of Directory
0293: E800
0294: E800         ;************************ BIOS Function Constants ***************************;
0295: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0296: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0297: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0298: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0299: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0300: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0301: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0302: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0303: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0304: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0305: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0306: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0307: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0308: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0309: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0310: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0311: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0312: E800         ;************************ BIOS Function Constants ***************************;
0313: E800         ;============================================================================;
0314: E800         ;	BDOS                                                                     ;
0315: E800         ; Calling into   :                                                           ;
0316: E800         ;					Register  C - Contains BDOS Function Code                ;
0317: E800         ;					Register  A - Holds the Byte argument if any             ;
0318: E800         ;					Register DE - Holds the Word argument if any             ;
0319: E800         ; Returning from :                                                           ;
0320: E800         ;					Register  A - The Byte return value if any               ;
0321: E800         ;					Register HL - The Word return value if any               ;
0322: E800         ;                   ( Register A=L and B=H)                                  ;
0323: E800         ;============================================================================;
0324: E800
0325: E800
0326: E800                        ORG    BDOSBase
0327: E800
0328: E800         ;===========================BDOS Entry=======================================;
0329: E800         ;BDOSEntry:                                                                  ;
0330: E800         ;
0331: E800         ;
0332: E800             BdosStart:                      ;
0333: E800         ;	LD		A,C                                                              ;
0334: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0335: E800         ;
0336: E800         ; Save Calling Arguments                                                     ;
0337: E800 ED 53 C3 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0338: E804 7B                     LD     A,E                  ;
0339: E805 32 C2 EA               LD     (paramE),A           ; Save the Byte argument             ;
0340: E808         ; Save users Stack pointer                                                   ;
0341: E808 ED 73 BC EA               LD     (usersStack),SP      ; Save the User's stack				 ;
0342: E80C 31 90 F5               LD     SP,bdosStack         ; We will use our own stack			 ;
0343: E80F         ;
0344: E80F         ; initialize variables                                                       ;
0345: E80F 21 00 00               LD     HL,0000H             ;
0346: E812 22 C5 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0347: E815 AF                     XOR    A                    ;
0348: E816 32 44 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0349: E819 32 42 F5               LD     (fResel),A           ; Clear re selection flag            ;
0350: E81C         ;
0351: E81C         ; Set up for return to caller when Function Completes                        ;
0352: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0353: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0354: E820         ;
0355: E820         ; is it a valid function number ?	                                         ;
0356: E820         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0357: E820 79                     LD     A,C                  ;
0358: E821 FE 28                  CP     functionCount        ; make sure its a good number        ;
0359: E823 D0                     RET    NC                   ; exit if not a valid function       ;
0360: E824         ;
0361: E824         ; Calculate the index and get vector to go to	                             ;
0362: E824 4B                     LD     C,E                  ; Assume byte argument               ;
0363: E825 21 57 E8               LD     HL,functionTable     ; Get table base                     ;
0364: E828 5F                     LD     E,A                  ; Function number in E               ;
0365: E829 16 00                  LD     D,0                  ;
0366: E82B 19                     ADD    HL,DE                ; Have byte location                 ;
0367: E82C 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0368: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0369: E82E 23                     INC    HL                   ;
0370: E82F 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0371: E830 EB                     EX     DE,HL                ; Vector now in HL                   ;
0372: E831         ;
0373: E831         ; Vector to Function is in HL                                                ;
0374: E831 E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0375: E832         ;===========================BDOS Entry=======================================;
0376: E832         ;===========================BDOS Exit =======================================;
0377: E832         ;arrive here at end of processing to return to user                          ;
0378: E832             ReturnToCaller:                      ;
0379: E832 3A 42 F5               LD     A,(fResel)           ; get re-selection flag              ;
0380: E835 B7                     OR     A                    ; is it set?                         ;
0381: E836 28 15                  JR     Z,ReturnToCaller1    ;
0382: E838         ;re-selection  may have taken place                                         ;
0383: E838 2A C3 EA               LD     HL,(paramDE)         ;
0384: E83B 36 00                  LD     (HL),0               ;
0385: E83D 3A 44 F5               LD     A,(fcbDisk)          ;
0386: E840 B7                     OR     A                    ; Disk = 0?                          ;
0387: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0388: E843         ;
0389: E843 77                     LD     (HL),A               ;
0390: E844 3A 43 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0391: E847 32 C2 EA               LD     (paramE),A           ; and select it                      ;
0392: E84A CD 64 ED               CALL   SelectCurrent        ;
0393: E84D         ;
0394: E84D             ReturnToCaller1:                      ;
0395: E84D 2A BC EA               LD     HL,(usersStack)      ;
0396: E850 F9                     LD     SP,HL                ; restore callers stack              ;
0397: E851 2A C5 EA               LD     HL,(exitParameterWord) ;
0398: E854 7D                     LD     A,L                  ;
0399: E855 44                     LD     B,H                  ; BA = exitParameterWord             ;
0400: E856 C9                     RET                         ;
0401: E857         ;===========================BDOS Exit =======================================;
0402: E857
0403: E857         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0404: E857             functionTable:                      ;
0405: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0406: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0407: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0408: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0409: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0410: E861 CD E8                  DW     vListOut             ;   5 - List Output                  ;
0411: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0412: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0413: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0414: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                 ;
0415: E86B FC E8                  DW     vReadString          ;   A - Read Console String          ;
0416: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0417: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0418: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0419: E871 C7 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0420: E873 E0 EA                  DW     vSelectDisk          ;   E - Select Disk                  ;
0421: E875 E3 EA                  DW     vOpenFile            ;   F - Open File                    ;
0422: E877 EC EA                  DW     vCloseFile           ;  10 - Close File                   ;
0423: E879 F2 EA                  DW     vFindFirst           ;  11 - Search For First             ;
0424: E87B 0B EB                  DW     vFindNext            ;  12 - Search for Next              ;
0425: E87D 1A EB                  DW     vDeleteFile          ;  13 - Delete File                  ;
0426: E87F 41 EB                  DW     vReadSeq             ;  14 - Read Sequential              ;
0427: E881 87 EB                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0428: E883 49 EC                  DW     vMakeFile            ;  16 - Make File                    ;
0429: E885 52 EC                  DW     vRenameFile          ;  17 - Rename File                  ;
0430: E887 7C EC                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0431: E889 83 EC                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0432: E88B 8A EC                  DW     vSetDMA              ;  1A - Set DMA address              ;
0433: E88D 93 EC                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0434: E88F 9A EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0435: E891 9D EC                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0436: E893 A4 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0437: E895 BF EC                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0438: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0439: E899 C6 EC                  DW     vReadRandom          ;  21 - Read Random                  ;
0440: E89B 27 ED                  DW     vWriteRandom         ;  22 - Write Random                 ;
0441: E89D D2 EC                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0442: E89F 11 ED                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0443: E8A1 24 ED                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0444: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0445: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0446: E8A7 2D ED                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0447: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0448: E8A9         ;
0449: E8A9             DUMMY:                          ;
0450: E8A9 76                     HALT                        ;
0451: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0452: E8AA
0453: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0454: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0455: E8AA         ; same as the warm boot function invoked when you transfer control to the    ;
0456: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0457: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0458: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0459: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0460: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0461: E8AA         ;																			 ;
0462: E8AA         ;			Function Code	 :	C = 00H                                      ;
0463: E8AA         ;			Entry Parameters:	None                                         ;
0464: E8AA         ;			Exit Parameters :	Does Not Return								 ;
0465: E8AA         ;																			 ;
0466: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0467: E8AA             vSystemReset:
0468: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0469: E8AD
0470: E8AD         ;****************************************************************************;
0471: E8AD         ;								IOByte device I/O							 ;
0472: E8AD         ;****************************************************************************;
0473: E8AD
0474: E8AD
0475: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0476: E8AD         ;  This function reads the next byte of data from the console keyboard and   ;
0477: E8AD         ; puts it into register A. If the character input is a graphic character, it ;
0478: E8AD         ; will be echoed back to the console. The only control characters that are   ;
0479: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0480: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0481: E8AD         ; move the cursor to the next multiple of eight columns. All of the other    ;
0482: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0483: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0484: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0485: E8AD         ; console output should also be sent to the list device. If CONTROL-S is     ;
0486: E8AD         ; found, further output will be suspended until you type another character.  ;
0487: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0488: E8AD         ; pressed and disable it the second time. If there is no incoming data       ;
0489: E8AD         ; character, this function will wait until there is one.                     ;
0490: E8AD         ;                                                                            ;
0491: E8AD         ; This is a blocking function                                                ;
0492: E8AD         ;																			 ;
0493: E8AD         ;																			 ;
0494: E8AD         ;			Function Code	:	C = 01H                                      ;
0495: E8AD         ;			Entry Parameters:	None                                         ;
0496: E8AD         ;			Exit Parameters :	A = Data byte from console					 ;
0497: E8AD         ;																			 ;
0498: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0499: E8AD             vConsoleIn:
0500: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0501: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0502: E8B3 D8                     RET    C                    ; return nothing to echo
0503: E8B4
0504: E8B4 F5                     PUSH   AF                   ; Save printable character
0505: E8B5 4F                     LD     C,A
0506: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0507: E8B9 F1                     POP    AF                   ; retrieve exit value
0508: E8BA
0509: E8BA 32 C5 EA               LD     (exitParameterByte),A
0510: E8BD C9                     RET
0511: E8BE
0512: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0513: E8BE         ;  This function outputs the data byte in register E to the console. As with ;
0514: E8BE         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0515: E8BE         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0516: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0517: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0518: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0519: E8BE         ; printer is  toggled on or off                                              ;
0520: E8BE         ;																			 ;
0521: E8BE         ;			Function Code	:	C = 02H                                      ;
0522: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0523: E8BE         ;			Exit Parameters :	None										 ;
0524: E8BE         ;																			 ;
0525: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0526: E8BE         ;BDOS put parameter in C before entering this routine
0527: E8BE             vConsoleOut:
0528: E8BE CD 58 E9               CALL   TabOut
0529: E8C1 C9                     RET
0530: E8C2
0531: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0532: E8C2         ;   function reads the next character from the logical "reader" device into  ;
0533: E8C2         ; register A. In practice, the physical device that is accessed depends      ;
0534: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0535: E8C2         ; reader at all; this function will return some arbitrary value such as lAH  ;
0536: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0537: E8C2         ; Control is not returned to the calling program until a character has been  ;
0538: E8C2         ; read.                                                                      ;
0539: E8C2         ;                                                                            ;
0540: E8C2         ; This is a blocking function                                                ;
0541: E8C2         ;																			 ;
0542: E8C2         ;			Function Code	:	C = 03H                                      ;
0543: E8C2         ;			Entry Parameters:	None										 ;
0544: E8C2         ;			Exit Parameters :	A = Character Input							 ;
0545: E8C2         ;																			 ;
0546: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0547: E8C2             vReaderIn:
0548: E8C2 CD 15 F6               CALL   bcReader
0549: E8C5 32 C5 EA               LD     (exitParameterWord),A
0550: E8C8 C9                     RET
0551: E8C9
0552: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0553: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0554: E8C9         ; specified character from register E to the logical punch device. Again,    ;
0555: E8C9         ; the actual physical device used, if any, is determined by the BIOS.        ;
0556: E8C9         ; There is no set standard for this device; in some systems the punch        ;
0557: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0558: E8C9         ; output to it.                                                              ;
0559: E8C9         ;																			 ;
0560: E8C9         ;			Function Code	:	C = 04H                                      ;
0561: E8C9         ;			Entry Parameters:	E = Data byte to be output					 ;
0562: E8C9         ;			Exit Parameters :	None										 ;
0563: E8C9         ;																			 ;
0564: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0565: E8C9         ;BDOS put parameter in C before entering this routine
0566: E8C9             vPunchOut:
0567: E8C9 CD 12 F6               CALL   bcPunch
0568: E8CC C9                     RET
0569: E8CD
0570: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0571: E8CD         ;  This function outputs the specified byte in register E to the logical     ;
0572: E8CD         ; list device. As with the reader and the punch, the physical device used    ;
0573: E8CD         ; depends entirely on the BIOS.                                              ;
0574: E8CD         ;																			 ;
0575: E8CD         ;			Function Code	:	C = 05H                                      ;
0576: E8CD         ;			Entry Parameters:	E = Data byte to be output					 ;
0577: E8CD         ;			Exit Parameters :	None										 ;
0578: E8CD         ;																			 ;
0579: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0580: E8CD         ;BDOS put parameter in C before entering this routine
0581: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0582: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0583: E8D0 C9                     RET
0584: E8D1
0585: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0586: E8D1         ;  This function serves double duty: it both inputs and outputs characters   ;
0587: E8D1         ; from the console. However, it bypasses the normal control characters and   ;
0588: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0589: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0590: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0591: E8D1         ; then E contains a valid ASCII character that is output to the console.     ;
0592: E8D1         ;  This function works well provided you never have to send a value ofOFFH   ;
0593: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0594: E8D1         ; binary data, you cannot use this function, since these values are likely   ;
0595: E8D1         ; to be part of the data stream.                                             ;
0596: E8D1         ;                                                                            ;
0597: E8D1         ;			Function Code	:	C = 06H                                      ;
0598: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0599: E8D1         ;								E = Other than 0FFH for Output				 ;
0600: E8D1         ;			Exit Parameters :	A = Input byte or status					 ;
0601: E8D1         ;																			 ;
0602: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0603: E8D1         ;BDOS put parameter in C before entering this routine
0604: E8D1             vDirectConIO:
0605: E8D1 79                     LD     A,C
0606: E8D2 3C                     INC    A
0607: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0608: E8D5         ; send byte to console
0609: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0610: E8D8 C9                     RET
0611: E8D9
0612: E8D9         ;read byte/status from console
0613: E8D9             vDirectConIO1:
0614: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0615: E8DC B7                     OR     A                    ; 00 means not data ready
0616: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0617: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0618: E8E3 32 C5 EA               LD     (exitParameterByte),A ; Save it
0619: E8E6 C9                     RET
0620: E8E7
0621: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0622: E8E7         ; This function places the current value of the IOBYTE in register A.        ;
0623: E8E7         ;                                                                            ;
0624: E8E7         ; The IOBYTE structure:                                                      ;
0625: E8E7         ;								+-------+-------+-------+-------+            ;
0626: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0627: E8E7         ;								+-------+-------+-------+-------+            ;
0628: E8E7         ;				Logical Device     List | Punch | Reader|Console             ;
0629: E8E7         ;                                                                            ;
0630: E8E7         ;                                                                            ;
0631: E8E7         ;			Function Code	:	C = 07H                                      ;
0632: E8E7         ;			Entry Parameters:	None					  		  			 ;
0633: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0634: E8E7         ;																			 ;
0635: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0636: E8E7             vGetIOBYTE:
0637: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0638: E8EA 32 C5 EA               LD     (exitParameterWord),A ; Return it to caller
0639: E8ED C9                     RET
0640: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0641: E8EE         ; This function sets the IOBYTE         									 ;
0642: E8EE         ;                                                                            ;
0643: E8EE         ; The IOBYTE structure:                                                      ;
0644: E8EE         ;								+-------+-------+-------+-------+            ;
0645: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0646: E8EE         ;								+-------+-------+-------+-------+            ;
0647: E8EE         ;				Logical Device     List | Punch | Reader|Console             ;
0648: E8EE         ;                                                                            ;
0649: E8EE         ;                                                                            ;
0650: E8EE         ;			Function Code	:	C = 08H                                      ;
0651: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0652: E8EE         ;			Exit Parameters :	None                                         ;
0653: E8EE         ;																			 ;
0654: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0655: E8EE         ;BDOS put parameter in C before entering this routine
0656: E8EE             vSetIOBYTE:
0657: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0658: E8F1 71                     LD     (HL),C               ; Place new vale in it
0659: E8F2 C9                     RET
0660: E8F3
0661: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0662: E8F3         ;  This function outputs a string of characters to the console device. The   ;
0663: E8F3         ; address of this string is in registers DE. You must make sure that the last;
0664: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0665: E8F3         ; for the end of the string.                                                 ;
0666: E8F3         ;  The "$" itself does not get output to the console.                        ;
0667: E8F3         ;                                                                            ;
0668: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0669: E8F3         ; described, checks to see if there is an incoming character, and checks for ;
0670: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0671: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0672: E8F3         ; the printer).                                                              ;
0673: E8F3         ;                                                                            ;
0674: E8F3         ;			Function Code	:	C = 09H                                      ;
0675: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0676: E8F3         ;			Exit Parameters :	None							             ;
0677: E8F3         ;																			 ;
0678: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0679: E8F3             vPrintString:
0680: E8F3 2A C3 EA               LD     HL,(paramDE)         ; Get address of the string
0681: E8F6 4D                     LD     C,L
0682: E8F7 44                     LD     B,H                  ; Put it into BC for call
0683: E8F8 CD 3B E9               CALL   Print                ; out to console
0684: E8FB C9                     RET
0685: E8FC
0686: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0687: E8FC         ;  This function reads a string of characters from the console device        ;
0688: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0689: E8FC         ; editing is possible: the operator can backspace, cancel the line and start ;
0690: E8FC         ; over, and use all the normal control functions. What you will ultimately   ;
0691: E8FC         ; see in the buffer is the final version of the character string entered,    ;
0692: E8FC         ; without any of the errors or control characters used to do the line editing;
0693: E8FC         ;                                                                            ;
0694: E8FC         ;  The buffer that you define has a special format. The first byte in the    ;
0695: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0696: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0697: E8FC         ; were actually placed in the buffer. The following bytes contain            ;
0698: E8FC         ; the characters of the string. Character input will cease either when a     ;
0699: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0700: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0701: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0702: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0703: E8FC         ; the "characters input" byte to O. If you attempt to input more than the    ;
0704: E8FC         ; maximum number of characters, the "characters input" count will be the     ;
0705: E8FC         ; same as the maximum value allowed.                                         ;
0706: E8FC         ;                                                                            ;
0707: E8FC         ;			Function Code	:	C = 0AH                                      ;
0708: E8FC         ;			Entry Parameters:	DE = Address string buffer					 ;
0709: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0710: E8FC         ;																			 ;
0711: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0712: E8FC             vReadString:
0713: E8FC CD E0 E9               CALL   ReadString
0714: E8FF C9                     RET
0715: E900
0716: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0717: E900         ; This function tells you whether a console input character is waiting to be ;
0718: E900         ;processed. Unlike the Console Input functions, which will wait until there  ;
0719: E900         ;is input,this function simply checks and returns immediately.               ;
0720: E900         ;                                                                            ;
0721: E900         ;			Function Code	:	C = 0BH                                      ;
0722: E900         ;			Entry Parameters:	None										 ;
0723: E900         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0724: E900         ;								A = FFH	if incoming Data					 ;
0725: E900         ;																			 ;
0726: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0727: E900             vGetConsoleStatus:
0728: E900 CD 8C E9               CALL   ConBreak
0729: E903 32 C5 EA               LD     (exitParameterByte),A
0730: E906 C9                     RET
0731: E907
0732: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0733: E907         ;  This function tells you which version of CP/M you are currently running.  ;
0734: E907         ; A two-byte value is returned:                                              ;
0735: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0736: E907         ;	L = OOH for all releases before CP/M 2.0                                 ;
0737: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0738: E907         ;		and so on for any subsequent releases.                               ;
0739: E907         ;                                                                            ;
0740: E907         ; This information is of interest only if your program has some version      ;
0741: E907         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0742: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0743: E907         ; Therefore, if your program uses Random I/O, put this check at the          ;
0744: E907         ; beginning to ensure that it is indeed running under the appropriate        ;
0745: E907         ; version of CP/M.                                                           ;
0746: E907         ;                                                                            ;
0747: E907         ;			Function Code	:	C = 0CH                                      ;
0748: E907         ;			Entry Parameters:	None										 ;
0749: E907         ;			Exit Parameters :	HL =Version Number Code						 ;
0750: E907         ;								A = FFH	if incoming Data					 ;
0751: E907         ;																			 ;
0752: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0753: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0754: E907 3E 20                  LD     A,VERSION
0755: E909 32 C5 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0756: E90C C9                     RET
0757: E90D
0758: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0759: E90D         ;  This subroutine either sets or gets the current user number. The current  ;
0760: E90D         ; user number determines which file directory entries are matched during all ;
0761: E90D         ; disk file operations. When you call this function, the contents of the     ;
0762: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0763: E90D         ; will return the current user number in the A register. If you set E to a   ;
0764: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0765: E90D         ; will set the current user number to this value.                            ;
0766: E90D         ;                                                                            ;
0767: E90D         ;			Function Code	:	C = 0CH                                      ;
0768: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0769: E90D         ;								  = 0 to 15 to set User Number				 ;
0770: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0771: E90D         ;								A = FFH	if incoming Data					 ;
0772: E90D         ;																			 ;
0773: E90D         ;                                                                            ;
0774: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0775: E90D             vGetSetUserNumber:
0776: E90D 3A C2 EA               LD     A,(paramE)
0777: E910 FE FF                  CP     0FFH
0778: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0779: E914 3A 11 F5               LD     A,(currentUserNumber)
0780: E917 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0781: E91A C9                     RET
0782: E91B
0783: E91B             SetUserNumber:
0784: E91B E6 0F                  AND    LO_NIBBLE_MASK
0785: E91D 32 11 F5               LD     (currentUserNumber),A
0786: E920 C9                     RET
0787: E921
0788: E921         ;****************************************************************************;
0789: E921         ;								Character Support Routines					 ;
0790: E921         ;****************************************************************************;
0791: E921
0792: E921
0793: E921         ;-------------------- Return a Character from the console -------------------;
0794: E921         ;return byte from buffer or read from the console                            ;
0795: E921             ConIn:                          ;
0796: E921 21 BE EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0797: E924 7E                     LD     A,(HL)               ;
0798: E925 36 00                  LD     (HL),0               ;
0799: E927 B7                     OR     A                    ;
0800: E928 C0                     RET    NZ                   ;
0801: E929         ;
0802: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0803: E92C         ;-------------------- Return a Character from the console -------------------;
0804: E92C
0805: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0806: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0807: E92C             IsPrintableASCII:                      ;
0808: E92C FE 0D                  CP     CR                   ;
0809: E92E C8                     RET    Z                    ; carriage return?                                                  ;
0810: E92F FE 0A                  CP     LF                   ;
0811: E931 C8                     RET    Z                    ; line feed?                                                        ;
0812: E932 FE 09                  CP     TAB                  ;
0813: E934 C8                     RET    Z                    ; TAB?                                                              ;
0814: E935 FE 08                  CP     CTRL_H               ;
0815: E937 C8                     RET    Z                    ; backspace?                                                        ;
0816: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0817: E93A C9                     RET                         ;
0818: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0819: E93B
0820: E93B         ;------------------ Print character from (BC) until  $ found ----------------;
0821: E93B             Print:                          ;
0822: E93B 0A                     LD     A,(BC)               ; Get the next character             ;
0823: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0824: E93E C8                     RET    Z                    ;  exit if yes                       ;
0825: E93F 03                     INC    BC                   ; Update the pointer                 ;
0826: E940 C5                     PUSH   BC                   ; Save it                            ;
0827: E941 4F                     LD     C,A                  ; Does Byte require                  ;
0828: E942 CD 58 E9               CALL   TabOut               ;  special attention - check         ;
0829: E945 C1                     POP    BC                   ; Retrieve the pointer				 ;
0830: E946 18 F3                  JR     Print                ; Loop back                          ;
0831: E948         ;------------------ Print character from (BC) until  $ found ----------------;
0832: E948
0833: E948         ;-- Send printable character to console. Precede with Caret if needed -------;
0834: E948         ; character is in Reg C                                                      ;
0835: E948             CaretOut:                       ;
0836: E948 79                     LD     A,C                  ;
0837: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0838: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0839: E94E         ; send preceding up arrow                                                    ;
0840: E94E F5                     PUSH   AF                   ; Save the character                 ;
0841: E94F 0E 5E                  LD     C,CARET              ;
0842: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0843: E954 F1                     POP    AF                   ; Get the character                  ;
0844: E955 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0845: E957 4F                     LD     C,A                  ; Set up to print                    ;
0846: E958         ; fall thru to TabbOut                                                       ;
0847: E958         ;-- Send printable character to console. Precede with Caret if needed -------;
0848: E958
0849: E958         ;------------- Send printable character to console. Expand if TAB -----------;
0850: E958         ; character is in Reg C                                                      ;
0851: E958             TabOut:                         ;
0852: E958 79                     LD     A,C                  ;
0853: E959 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0854: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0855: E95E         ;
0856: E95E         ; TAB encountered                                                           ;
0857: E95E             TabOut0:                        ;
0858: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0859: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                    ;
0860: E963 3A C1 EA               LD     A,(columnPosition)   ; Get Column position                ;
0861: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0862: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0863: E96A C9                     RET                         ;
0864: E96B         ;------------- Send printable character to console. Expand if TAB -----------;
0865: E96B
0866: E96B         ;-------------------------- Send character to console -----------------------;
0867: E96B         ; C  = Character to be output                                                ;
0868: E96B             ConsoleOut:                      ;
0869: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0870: E96B C5                     PUSH   BC                   ; Save character and Count           ;
0871: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0872: E96F C1                     POP    BC                   ;
0873: E970 C5                     PUSH   BC                   ; Get/save character                 ;
0874: E971         ; Send character to Console	                                                 ;
0875: E971 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0876: E974 C1                     POP    BC                   ;
0877: E975 C5                     PUSH   BC                   ; Get/save character                 ;
0878: E976         ; is the data to be output to print device?                                  ;
0879: E976 3A BF EA               LD     A,(printEchoFlag)    ;
0880: E979 B7                     OR     A                    ;
0881: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0882: E97D C1                     POP    BC                   ; Get the character                  ;
0883: E97E         ;
0884: E97E 79                     LD     A,C                  ; Put character to ACC               ;
0885: E97F 21 C1 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0886: E982 34                     INC    M                    ; increment the ColumnPosition       ;
0887: E983         ;
0888: E983 FE 20                  CP     SPACE                ;
0889: E985 D0                     RET    NC                   ; Exit if ASCII printable            ;
0890: E986         ;
0891: E986 FE 0A                  CP     LF                   ;
0892: E988 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0893: E989         ;
0894: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0895: E98B C9                     RET                         ;
0896: E98C         ;-------------------------- Send character to console -----------------------;
0897: E98C
0898: E98C         ;--------------------  Check for Status and Control S or C ------------------;
0899: E98C         ;  Returns:																	 ;
0900: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0901: E98C         ;			ACC = 00   No data Pending										 ;
0902: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0903: E98C         ;                                                                            ;
0904: E98C             ConBreak:                       ;
0905: E98C 3A BE EA               LD     A,(keyboardByte)     ;
0906: E98F B7                     OR     A                    ; If there is a char waiting         ;
0907: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0908: E992         ;
0909: E992 CD 06 F6               CALL   bcConst              ; Get status                         ;
0910: E995 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0911: E997 C8                     RET    Z                    ; Return 00 No data pending          ;
0912: E998         ;
0913: E998 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0914: E99B         ;
0915: E99B FE 10                  CP     CTRL_P               ;
0916: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0917: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0918: E99F 21 BF EA               LD     HL,printEchoFlag     ;
0919: E9A2 3E FF                  LD     A,TRUE               ;
0920: E9A4 BE                     CP     (HL)                 ;
0921: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0922: E9A7 3E 00                  LD     A,FALSE              ;
0923: E9A9             ToggleFlag1:                      ;
0924: E9A9 77                     LD     (HL),A               ;
0925: E9AA 18 0C                  JR     NothingWaiting       ;
0926: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0927: E9AC             CheckCTL_S:                      ;
0928: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0929: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0930: E9B0         ;
0931: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0932: E9B3 FE 03                  CP     CTRL_C               ;
0933: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0934: E9B8             NothingWaiting:                      ;
0935: E9B8 AF                     XOR    A                    ;
0936: E9B9 C9                     RET                         ; Set ACC = 0 and return             ;
0937: E9BA             ConBreak0:                      ;
0938: E9BA 32 BE EA               LD     (keyboardByte),A     ; save the byte                      ;
0939: E9BD             ConBreak1:                      ;
0940: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0941: E9BF C9                     RET                         ;
0942: E9C0         ;--------------------  Check for Status and Control S or C ------------------;
0943: E9C0
0944: E9C0         ;------------------------  Console Output Utilities -------------------------;
0945: E9C0             showHashCRLF:                      ;
0946: E9C0 0E 23                  LD     C,HASH_TAG           ;
0947: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                  ;
0948: E9C5 CD D6 E9               CALL   showCRLF             ;
0949: E9C8             showHashCRLF1:                      ;
0950: E9C8 3E C1                  LD     A,columnPosition     ;
0951: E9CA 21 C0 EA               LD     HL,startingColumn    ;
0952: E9CD BF                     CP     A,M                  ;
0953: E9CE D0                     RET    NC                   ;
0954: E9CF 0E 20                  LD     C,SPACE              ;
0955: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0956: E9D4 18 F2                  JR     showHashCRLF1        ;
0957: E9D6         ;------------------------  Console Output Utilities -------------------------;
0958: E9D6
0959: E9D6         ;------------------------  Send Carriage Return and Line Feed ---------------;
0960: E9D6             showCRLF:                       ;
0961: E9D6 0E 0D                  LD     C,CR                 ;
0962: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0963: E9DB 0E 0A                  LD     C,LF                 ;
0964: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0965: E9E0         ;------------------------  Send Carriage Return and Line Feed ---------------;
0966: E9E0
0967: E9E0         ;------------------------- Read a $ terminated String -----------------------;
0968: E9E0         ;read to paramDE address (max length, current length, buffer)               ;
0969: E9E0             ReadString:                      ;
0970: E9E0 3A C1 EA               LD     A,(columnPosition)   ;
0971: E9E3 32 C0 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0972: E9E6 2A C3 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0973: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0974: E9EA 23                     INC    HL                   ; Point at actual bytes read         ;
0975: E9EB 06 00                  LD     B,0                  ; Initialize Current Count           ;
0976: E9ED         ;
0977: E9ED         ; B = Current Count                                                      ;
0978: E9ED         ; C = Maximum characters                                                 ;
0979: E9ED         ; HL= Insertion Pointer                                                  ;
0980: E9ED         ;
0981: E9ED         ; read next character, BC, HL active                                        ;
0982: E9ED             ReadNext:                       ;
0983: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0984: E9EE E5                     PUSH   HL                   ; Save pointer                       ;
0985: E9EF             ReadNext0:                      ;
0986: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character             ;
0987: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0988: E9F4 E1                     POP    HL                   ; Restore Pointer					 ;
0989: E9F5 C1                     POP    BC                   ; Restore Current Index and Max Count;
0990: E9F6         ;Is It Carriage Return                                                       ;
0991: E9F6 FE 0D                  CP     CR                   ;
0992: E9F8 CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0993: E9FB FE 0A                  CP     LF                   ;
0994: E9FD         ;Is It Linefeed                                                              ;
0995: E9FD CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0996: EA00         ;Is It BackSpace                                                             ;
0997: EA00 FE 08                  CP     CTRL_H               ;
0998: EA02 CA 48 EA               JP     Z,BSspaceBS          ;
0999: EA05             IsItRubout:                      ;
1000: EA05 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
1001: EA07 CA 52 EA               JP     Z,ItIsRubout         ;
1002: EA0A             IsPhysicalEOL:                      ;
1003: EA0A FE 05                  CP     CTRL_E               ;
1004: EA0C CA 5D EA               JP     Z,ItIsPhysicalEOL    ;
1005: EA0F             IsItPrintToggle:                      ;
1006: EA0F FE 10                  CP     CTRL_P               ;
1007: EA11 CA 65 EA               JP     Z,ItIsPrintToggle    ;
1008: EA14             IsItDeleteTheLineX:                      ;
1009: EA14 FE 18                  CP     CTRL_X               ;
1010: EA16 CA 8E EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1011: EA19             IsItDeleteTheLineU:                      ;
1012: EA19 FE 15                  CP     CTRL_U               ;
1013: EA1B CA AC EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1014: EA1E         ;Retype the line                                                             ;
1015: EA1E FE 12                  CP     CTRL_R               ;
1016: EA20 CA 75 EA               JP     Z,RepeatLine         ;
1017: EA23
1018: EA23         ;....................... Echo input back to the Console  ....................;
1019: EA23         ; Full Duplex								                                 ;
1020: EA23         ; A = Character to display	                                                 ;
1021: EA23         ; B = current char count                                                     ;
1022: EA23         ; C = maximum buffer length                                                  ;
1023: EA23         ; HL= buffer pointer                                                         ;
1024: EA23         ;ReadEcho                                                                    ;
1025: EA23 04                     INC    B                    ; Increment byte count		         ;
1026: EA24 23                     INC    HL                   ; Advance the Pointer                ;
1027: EA25 77                     LD     (HL),A               ; Put char in buffer                 ;
1028: EA26         ;
1029: EA26             ReadEchoRubOut:                      ;
1030: EA26 C5                     PUSH   BC                   ; Save index and length              ;
1031: EA27 E5                     PUSH   HL                   ; Save the Pointer                   ;
1032: EA28 4F                     LD     C,A                  ; Get char                           ;
1033: EA29 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1034: EA2C E1                     POP    HL                   ; Restore the Pointer                ;
1035: EA2D C1                     POP    BC                   ; Restore index and length           ;
1036: EA2E 7E                     LD     A,(HL)               ; Recall char                        ;
1037: EA2F         ; check for Warm Boot                                                        ;
1038: EA2F FE 03                  CP     CTRL_C               ;
1039: EA31 78                     LD     A,B                  ; Get Line position                  ;
1040: EA32 C2 3A EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1041: EA35 FE 01                  CP     1                    ; Beginning of the Line?             ;
1042: EA37 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1043: EA3A         ; Check to see if we are at the end of the buffer                            ;
1044: EA3A             AreWeAtEndOfBuffer:                      ;
1045: EA3A B9                     CP     C                    ; Over Max ?					     ;
1046: EA3B DA ED E9               JP     C,ReadNext           ;  no, Go for more				     ;
1047: EA3E         ;
1048: EA3E         ; At the end of read                                  					     ;
1049: EA3E             EndRead:                        ;
1050: EA3E         ; 	POP		HL                                                               ;
1051: EA3E 2A C3 EA               LD     HL,(paramDE)         ;
1052: EA41 23                     INC    HL                   ;
1053: EA42         ;
1054: EA42 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1055: EA43 0E 0D                  LD     C,CR                 ;
1056: EA45 C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1057: EA48         ;....................... Echo input back to the Console  ....................;
1058: EA48         ;.......................... Backspace SPACE BackSpace .......................;
1059: EA48             BSspaceBS:                      ;
1060: EA48 05                     DEC    B                    ;
1061: EA49 2B                     DEC    HL                   ;
1062: EA4A C5                     PUSH   BC                   ;
1063: EA4B E5                     PUSH   HL                   ;
1064: EA4C CD 9F EA               CALL   BackUp               ;
1065: EA4F C3 EF E9               JP     ReadNext0            ;
1066: EA52         ;.......................... Backspace SPACE BackSpace .......................;
1067: EA52         ;.......................... It is RubOut ....................................;
1068: EA52             ItIsRubout:                      ;
1069: EA52         ; RUBOUT if possible                                                         ;
1070: EA52 78                     LD     A,B                  ; Are we at the start of the line    ;
1071: EA53 B7                     OR     A                    ;
1072: EA54 CA ED E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1073: EA57         ;adjust pointers back one                                                    ;
1074: EA57 7E                     LD     A,(HL)               ; ACC = current character            ;
1075: EA58 05                     DEC    B                    ; Adjust the index			    	 ;
1076: EA59 2B                     DEC    HL                   ; Adjust the pointer                 ;
1077: EA5A C3 26 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1078: EA5D         ;.......................... It is RubOut ....................................;
1079: EA5D         ;.......................... It is PhysicalEOL ...............................;
1080: EA5D             ItIsPhysicalEOL:                      ;
1081: EA5D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1082: EA5E E5                     PUSH   HL                   ; Save pointer                       ;
1083: EA5F CD D6 E9               CALL   showCRLF             ; Make new line                      ;
1084: EA62 C3 EF E9               JP     ReadNext0            ;   and go for next char   			 ;
1085: EA65         ;.......................... It is PhysicalEOL ...............................;
1086: EA65         ;.......................... It is PrintToggle ...............................;
1087: EA65             ItIsPrintToggle:                      ;
1088: EA65 E5                     PUSH   HL                   ; Save pointer                       ;
1089: EA66         ; Toggle the printEcho Flag                                                  ;
1090: EA66 21 BF EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1091: EA69 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1092: EA6B BE                     CP     (HL)                 ; Is the flag true?                  ;
1093: EA6C 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1094: EA6E 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1095: EA70             IsItPrintToggle1:                      ;
1096: EA70 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1097: EA71 E1                     POP    HL                   ; Restore pointer                    ;
1098: EA72 C3 ED E9               JP     ReadNext             ;   and for another char             ;
1099: EA75         ;.......................... It is PrintToggle ...............................;
1100: EA75         ;.......................... RepeatLine ......................................;
1101: EA75             RepeatLine:                      ;
1102: EA75 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1103: EA76 E5                     PUSH   HL                   ;  for exit                          ;
1104: EA77 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1105: EA7A         ;
1106: EA7A 2A C3 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1107: EA7D 23                     INC    HL                   ; Skip past character count          ;
1108: EA7E         ;
1109: EA7E             LL1:                            ;
1110: EA7E 23                     INC    HL                   ; Point at next char to display      ;
1111: EA7F C5                     PUSH   BC                   ; Save counter, in B                 ;
1112: EA80 E5                     PUSH   HL                   ; Save buffer pointer                ;
1113: EA81 4E                     LD     C,M                  ; Get the next character             ;
1114: EA82 CD 48 E9               CALL   CaretOut             ; Display it                         ;
1115: EA85 E1                     POP    HL                   ; Restore                            ;
1116: EA86 C1                     POP    BC                   ;  the counter and pointer           ;
1117: EA87 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1118: EA89 E1                     POP    HL                   ; Restore values                     ;
1119: EA8A C1                     POP    BC                   ;  from routine entry                ;
1120: EA8B C3 ED E9               JP     ReadNext             ; Done here !                        ;
1121: EA8E         ;.......................... RepeatLine ......................................;
1122: EA8E         ;.......................... Delete The Line .................................;
1123: EA8E             DeleteTheLine:                      ;
1124: EA8E E1                     POP    HL                   ; Adjust Stack                       ;
1125: EA8F         ;                                             ;
1126: EA8F             DeleteTheLine1:                      ;
1127: EA8F 3A C0 EA               LD     A,(startingColumn)   ;
1128: EA92 21 C1 EA               LD     HL,columnPosition    ;
1129: EA95 BE                     CP     M                    ; Start of line ?                    ;
1130: EA96 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1131: EA99 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1132: EA9A CD 9F EA               CALL   BackUp               ; Clear 1 column                     ;
1133: EA9D 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1134: EA9F         ;.......................... Delete The Line .................................;
1135: EA9F         ;------------------------ Back-up one screen position -----------------------;
1136: EA9F             BackUp:                         ;
1137: EA9F CD A7 EA               CALL   BackUp1              ; Send Backspace                     ;
1138: EAA2 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1139: EAA4 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1140: EAA7         ;does not affect column count                                                ;
1141: EAA7             BackUp1:                        ;
1142: EAA7 0E 08                  LD     C,CTRL_H             ;
1143: EAA9 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1144: EAAC         ;------------------------ Back-up one screen position -----------------------;
1145: EAAC         ;.......................... Ignore The Line .................................;
1146: EAAC             IgnoreTheLine:                      ;
1147: EAAC CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1148: EAAF 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1149: EAB1 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1150: EAB4 0E 20                  LD     C,SPACE              ;
1151: EAB6 CD 0C F6               CALL   bcConout             ;
1152: EAB9 C3 E0 E9               JP     ReadString           ; Start all over                     ;
1153: EABC         ;.......................... Ignore The Line .................................;
1154: EABC
1155: EABC         ;------------------------- Read a $ terminated String -----------------------;
1156: EABC
1157: EABC         ;****************************************************************************
1158: EABC         ;                           DATA AREA                                       *
1159: EABC         ;****************************************************************************
1160: EABC
1161: EABC         ;------------------------------Non Disk Data Area ---------------------------;
1162: EABC             usersStack: DS     2                    ; entry stack pointer                ;
1163: EABE         ;
1164: EABE 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1165: EABF         ;
1166: EABF 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1167: EAC0         ;
1168: EAC0         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1169: EAC0 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1170: EAC1 00          columnPosition: DB     0                    ; Current Column position            ;
1171: EAC2         ;
1172: EAC2             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1173: EAC3             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1174: EAC5             exitParameterByte:                      ; Byte returned Value                ;
1175: EAC5             exitParameterWord: DS     WORD                 ; Word                           ;
1176: EAC7         ;
1177: EAC7         ;
1178: EAC7         ;------------------------------------ Data Area -----------------------------;
1179: EAC7
1180: EAC7
1181: EAC7
1182: EAC7         ;****************************************************************************;
1183: EAC7         ;								Disk I/O									 ;
1184: EAC7         ;****************************************************************************;
1185: EAC7
1186: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1187: EAC7         ;  This function requests CP/M to completely reset the disk file system.     ;
1188: EAC7         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1189: EAC7         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1190: EAC7         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1191: EAC7         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1192: EAC7         ; in each logical disk as each disk is accessed. This involves reading the   ;
1193: EAC7         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1194: EAC7         ; which keep track of which allocation blocks are free and which             ;
1195: EAC7         ; are used for file storage.                                                 ;
1196: EAC7         ;                                                                            ;
1197: EAC7         ;			Function Code	:	C = 0DH                                      ;
1198: EAC7         ;			Entry Parameters:	None										 ;
1199: EAC7         ;			Exit Parameters :	None										 ;
1200: EAC7         ;																			 ;
1201: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1202: EAC7             vResetSystem:
1203: EAC7 21 00 00               LD     HL,0
1204: EACA 22 14 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1205: EACD 22 16 F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1206: EAD0 AF                     XOR    A                    ; Clear the current disk
1207: EAD1 32 12 F5               LD     (currentDisk),A
1208: EAD4         ; note that currentUserNumber remains unchanged
1209: EAD4 21 80 00               LD     HL,DMABuffer
1210: EAD7 22 18 F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1211: EADA CD 78 EF               CALL   SetDataDMA           ; to data DMA address
1212: EADD C3 70 ED               JP     Select
1213: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1214: EAE0         ;  This function makes the logical disk named in register E the default disk;
1215: EAE0         ; All subsequent references to disk files that do not specify the disk will ;
1216: EAE0         ; use this default. When you reference a disk file that does have an        ;
1217: EAE0         ; explicit logical disk in its name you do not have to issue another        ;
1218: EAE0         ; Select Disk function; the BDOS will take care of that for you.            ;
1219: EAE0         ;                                                                           ;
1220: EAE0         ;  Notice the way in which the logical disk is specified in register E.     ;
1221: EAE0         ; It is not the same as the disk drive specification in the first byte of   ;
1222: EAE0         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1223: EAE0         ; "use the current default disk" (as specified in the last Select Disk      ;
1224: EAE0         ; call or by the operator on the console). With this function, a value      ;
1225: EAE0         ; of OOH in register A means that A is the selected drive, a value of       ;
1226: EAE0         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1227: EAE0         ; 16 drives in the system.                                                  ;
1228: EAE0         ;                                                                           ;
1229: EAE0         ;			Function Code	:	C = 0EH                                     ;
1230: EAE0         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1231: EAE0         ;			Exit Parameters :	None										;
1232: EAE0         ;																			;
1233: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1234: EAE0
1235: EAE0             vSelectDisk:
1236: EAE0 C3 64 ED               JP     SelectCurrent
1237: EAE3
1238: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1239: EAE3         ;  This function opens a specified file for reading or writing. The FCB,    ;
1240: EAE3         ; whose address must be in register DE, tells CP/M the user number,         ;
1241: EAE3         ; the logical disk, the file name, and the file type. All other bytes of    ;
1242: EAE3         ; the FCB will normally be set to O.                                        ;
1243: EAE3         ;  The code returned by the BDOS in register A indicates whether the file   ;
1244: EAE3         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1245: EAE3         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1246: EAE3         ; then the file has been opened.                                            ;
1247: EAE3         ;			Function Code	:	C  = 0FH                                    ;
1248: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1249: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1250: EAE3         ;																			;
1251: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1252: EAE3             vOpenFile:
1253: EAE3 CD 30 F0               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1254: EAE6 CD B1 EF               CALL   ReselectDisk         ; do we need to reselect disk?
1255: EAE9 C3 47 EE               JP     OpenFile
1256: EAEC
1257: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1258: EAEC         ;  This function terminates the processing of a file to which you have      ;
1259: EAEC         ; written information. Under CP/M you do not need to close a file that you  ;
1260: EAEC         ; have been reading. However, if you ever intend for your program to        ;
1261: EAEC         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1262: EAEC         ; should close all files regardless of their use.                           ;
1263: EAEC         ;  The Close File function, like Open File, returns a directory code in     ;
1264: EAEC         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1265: EAEC         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1266: EAEC         ; been closed.                                                              ;
1267: EAEC         ;                                                                           ;
1268: EAEC         ;  When the BDOS closes a file to which data has been written, it writes    ;
1269: EAEC         ; the current contents of the FCB out to the disk directory, updating       ;
1270: EAEC         ; an existing directory entry by matching the disk, name, type, and         ;
1271: EAEC         ; extent number in the same manner that the Open File function does.        ;
1272: EAEC         ; Note that the BDOS does not transfer the last record of the file to the   ;
1273: EAEC         ; disk during the close operation. It merely updates the file directory.    ;
1274: EAEC         ; You must arrange to flush any partly filled record to the disk. If the    ;
1275: EAEC         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1276: EAEC         ; arrange to fill the unused portion of the record with the standard lAH    ;
1277: EAEC         ; end-of-file characters as CP/M expects.                                   ;
1278: EAEC         ;                                                                           ;
1279: EAEC         ;			Function Code	:	C  = 10H                                    ;
1280: EAEC         ;			Entry Parameters:	DE = Address of File Control Block			;
1281: EAEC         ;			Exit Parameters :	A  = Directory Code							;
1282: EAEC         ;																			;
1283: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1284: EAEC             vCloseFile:
1285: EAEC CD B1 EF               CALL   ReselectDisk
1286: EAEF C3 8A EE               JP     CloseDirEntry
1287: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1288: EAF2         ;  This function scans down the file directory for the first entry that     ;
1289: EAF2         ; matches the file name, type, and extent in the FCB addressed by DE.       ;
1290: EAF2         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
1291: EAF2         ; more character positions. Where a "?" occurs, the BDOS will match any     ;
1292: EAF2         ; character in the corresponding position in the file directory. This is    ;
1293: EAF2         ; known as ambiguous file name matching.                                    ;
1294: EAF2         ;  The first byte of an FCB normally contains the logical disk number code. ;
1295: EAF2         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
1296: EAF2         ; and so on up to a possible maximum of 16 for disk P. However, if this     ;
1297: EAF2         ; byte contains a "?", the BDOS will search the default logical disk and    ;
1298: EAF2         ; will match the file name and type regardless of the user number. This     ;
1299: EAF2         ; function is normally used in conjunction with the Search Next function.   ;
1300: EAF2         ; Search First, in the process of matching a file, leaves certain           ;
1301: EAF2         ; variables in the BDOS set, ready for a subsequent Search Next.            ;
1302: EAF2         ;  Both Search First and Search Next return a directory code in the         ;
1303: EAF2         ; A register. With Search First, A = OFFH when no files match the FCB,      ;
1304: EAF2         ; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
1305: EAF2         ;                                                                           ;
1306: EAF2         ;  To locate the particular directory entry that either the Search First    ;
1307: EAF2         ; or Search Next function matched, multiply the directory code returned     ;
1308: EAF2         ; in A by the length of a directory entry (32 bytes). This is easily done   ;
1309: EAF2         ; by adding the A register to itself five times. Then add the DMA address   ;
1310: EAF2         ; to get the actual address where the matched directory entry is stored.    ;
1311: EAF2         ;  There are many occasions when you may need to write a program that will  ;
1312: EAF2         ; accept an ambiguous file name and operate on all of the file names that   ;
1313: EAF2         ; match it. (The DIR and ERA commands built into the CCP are examples that  ;
1314: EAF2         ; use ambiguous file names.) To do this, you must use several BDOS          ;
1315: EAF2         ; functions: the Set DMA Address function (code 26), this function          ;
1316: EAF2         ; (Search First), and Search Next (code 18). All of this is shown in the    ;
1317: EAF2         ; subroutine given in Figure 5-17.                                          ;
1318: EAF2         ;                                                                           ;
1319: EAF2         ;                                                                           ;
1320: EAF2         ;			Function Code	:	C  = 11H                                    ;
1321: EAF2         ;			Entry Parameters:	DE = Address of File Control Block			;
1322: EAF2         ;			Exit Parameters :	A  = Directory Code							;
1323: EAF2         ;																			;
1324: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1325: EAF2             vFindFirst:
1326: EAF2 0E 00                  LD     C,0                  ; Length assuming '?' true
1327: EAF4 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB
1328: EAF7 7E                     LD     A,(HL)               ; DIsk/User No
1329: EAF8 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1330: EAFA CA 05 EB               JP     Z,QMarkFind          ;  if Yes, skip disk reselect
1331: EAFD         ;  and reset of EXT
1332: EAFD
1333: EAFD CD 30 F0               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1334: EB00 CD B1 EF               CALL   ReselectDisk         ; Use FCB to set currentDisk
1335: EB03 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1336: EB05
1337: EB05             QMarkFind:
1338: EB05 CD 5C F0               CALL   SearchForDirectoryRecord ; Find the directory record
1339: EB08 C3 62 F2               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1340: EB0B
1341: EB0B         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1342: EB0B         ;	This function searches down the file directory for the next file name,  ;
1343: EB0B         ; type, and extent that match the FCB specified in a previous Search First  ;
1344: EB0B         ; function call. Search First and Search Next are the only BDOS functions   ;
1345: EB0B         ; that must be used together. As you can see, the Search Next function      ;
1346: EB0B         ; does not require an FCB address as an input parameter-all the necessary   ;
1347: EB0B         ; information will have been left in the BDOS on the Search First call.     ;
1348: EB0B         ; Like Search First, Search Next returns a directory code in the A register,;
1349: EB0B         ; in this case, if A = OFFH, it means that there are no more files that     ;
1350: EB0B         ; match the file control block. If A is not OFFH, it will be a value of     ;
1351: EB0B         ; 0, 1, 2, or 3, indicating the relative directory entry number.            ;
1352: EB0B         ;                                                                           ;
1353: EB0B         ;  There are two ways of using the Search First/ Next calls. Consider a     ;
1354: EB0B         ; simple file copying program that takes as input an ambiguous file name.   ;
1355: EB0B         ; You could scan the file directory, matching all of the possible file      ;
1356: EB0B         ; names, possibly displaying them on the console, and storing the names of  ;
1357: EB0B         ; the files to be copied in a table inside your program. This would have    ;
1358: EB0B         ; the advantage of enabling you to present the file names to the operator   ;
1359: EB0B         ; before any copying occurred. You could even arrange for the operator to   ;
1360: EB0B         ; select which files to copy on a file-by-file basis. One disadvantage      ;
1361: EB0B         ; would be that you could not accurately predict how many files might be    ;
1362: EB0B         ; selected. On some hard disk systems you might have to accommodate several ;
1363: EB0B         ; thousand file names.                                                      ;
1364: EB0B         ;  The alternative way of handling the problem would be to match one file   ;
1365: EB0B         ; name, copy it, then match the next file name, copy it, and so on. If you  ;
1366: EB0B         ; gave the operator the choice of selecting which files to copy, this person;
1367: EB0B         ; would have to wait at the terminal as each file was being copied, but the ;
1368: EB0B         ; program would not need to have large table areas set aside to hold file   ;
1369: EB0B         ; names. This solution to the problem is slightly more complicated, as you  ;
1370: EB0B         ; can see from the logic in Figure 5-17.                                    ;
1371: EB0B         ;  The subroutine in Figure 5-17, Get Next File (GNF), contains all of the  ;
1372: EB0B         ; necessary logic to search down a directory for both alternatives described;
1373: EB0B         ; It does require that you indicate on entry whether it should search for   ;
1374: EB0B         ; the first or next file match, by setting A to zero or some nonzero value  ;
1375: EB0B         ; respectively.                                                             ;
1376: EB0B         ;  You can see from Figure 5-17 that whenever the subroutine is called to   ;
1377: EB0B         ; get the next file, you must execute a Search First function to re-find    ;
1378: EB0B         ; the  previous file. Only then can a Search Next be issued. As with all    ;
1379: EB0B         ; functions that return a directory code in A, if this value is not OFFH, it;
1380: EB0B         ; will be the relative directory entry number in the directory record       ;
1381: EB0B         ; currently in memory. This directory record will have been read into memory;
1382: EB0B         ; at whatever address was specified at the last Set DMA Address function    ;
1383: EB0B         ; call. Notwithstanding its odd name, the DMA Address is simply the address ;
1384: EB0B         ; into which any record input from disk will be placed. If the Set DMA      ;
1385: EB0B         ; Address function has not been used to change the value, then the CP/M     ;
1386: EB0B         ; default DMA address, location 0080H, will be used to hold the directory   ;
1387: EB0B         ; record.                                                                   ;
1388: EB0B         ;  The actual code for locating the address of the particular directory     ;
1389: EB0B         ;  entry matched by the Search First/ Next functions is shown in Figure 5-17;
1390: EB0B         ;  near the label GNFC. The method involves multiplying the directory code  ;
1391: EB0B         ;  by 32 and then adding this product to the current DMA address.	        ;
1392: EB0B         ;                                                                           ;
1393: EB0B         ;                                                                           ;
1394: EB0B         ;			Function Code	:	C  = 12H                                    ;
1395: EB0B         ;			Entry Parameters:	None , Assume previous Search First Call	;
1396: EB0B         ;			Exit Parameters :	A  = Directory Code							;
1397: EB0B         ;																			;
1398: EB0B         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1399: EB0B             vFindNext:
1400: EB0B 2A 3F F5               LD     HL,(searchAddress)   ; Get Current Dir Entry
1401: EB0E 22 C3 EA               LD     (paramDE),HL         ; Get the user's FCB
1402: EB11 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1403: EB14 CD 71 F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1404: EB17 C3 62 F2               JP     CopyDirEntryToUserDMA ; Copy directory entry to user
1405: EB1A
1406: EB1A         ;--------------------------------Delete File - 13 (19) ---------------------;
1407: EB1A         ; This function logically deletes from the file directory files that match  ;
1408: EB1A         ; the FCB addressed by DE. It does so by replacing the first byte of each   ;
1409: EB1A         ; relevant directory entry (remember, a single file can have several        ;
1410: EB1A         ; entries, one for each extent) by the value OE5H. This flags the directory ;
1411: EB1A         ; entry as being available for use.                                         ;
1412: EB1A         ;                                                                           ;
1413: EB1A         ;  Like the previous two functions, Search First and Search Next, this      ;
1414: EB1A         ; function can take an ambiguous file name and type as part of the          ;
1415: EB1A         ; File Control Block, but unlike those functions, the logical disk select   ;
1416: EB1A         ; code cannot be a"?". This function returns a directory code in A in the   ;
1417: EB1A         ; same way as the previous file operations.                                 ;
1418: EB1A         ;                                                                           ;
1419: EB1A         ;                                                                           ;
1420: EB1A         ;			Function Code	:	C  = 13H                                    ;
1421: EB1A         ;			Entry Parameters:	DE = Address of File Control Block			;
1422: EB1A         ;			Exit Parameters :	A  = Directory Code							;
1423: EB1A         ;																			;
1424: EB1A         ;--------------------------------Delete File - 13 (19) ---------------------;
1425: EB1A             vDeleteFile:
1426: EB1A CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1427: EB1D CD 76 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1428: EB20 0E 0C                  LD     C,fcbExtIndex        ; Load the extent number field
1429: EB22 CD 5C F0               CALL   SearchForDirectoryRecord ; Look for directory entry
1430: EB25
1431: EB25             DeleteFileLoop:
1432: EB25 CD 93 F1               CALL   AtEndOfDirectory     ; Have we worked thru all entries
1433: EB28 CA 6F F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1434: EB2B
1435: EB2B         ; set each non zero disk map entry to 0 in the allocation vector
1436: EB2B CD 7D F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1437: EB2E CD 9C F1               CALL   GetCurrentDirectoryRecord ; Point to Directory Entry
1438: EB31 36 E5                  LD     (HL),emptyDir        ; Mark as Empty
1439: EB33 0E 00                  LD     C,FALSE              ; Set flag for remove
1440: EB35 CD C0 F1               CALL   ScanDiskMap          ; Reclaim Bisk Blocks, set to 0
1441: EB38 CD D9 F0               CALL   WriteDir             ; Update the directory
1442: EB3B CD 71 F0               CALL   GetNextDirectoryRecord ; Look for more
1443: EB3E C3 25 EB               JP     DeleteFileLoop       ; Loop
1444: EB41
1445: EB41         ;----------------------------Read Sequential - 14 (20) ---------------------;
1446: EB41         ;  This function reads the next record (l28-byte sector) from the designated;
1447: EB41         ; file into memory at the address set by the last Set DMA function call     ;
1448: EB41         ; (code 26, lAH). The record read is specified by the FCB's sequential      ;
1449: EB41         ; record field. This field is incremented by 1 so that a subsequent call    ;
1450: EB41         ; to Read Sequential will get the next record from the file. If the end of  ;
1451: EB41         ; the current extent is reached, then the BDOS will automatically open the  ;
1452: EB41         ; next extent and reset the sequential record field to 0, ready for the     ;
1453: EB41         ; next Read function call.                                                  ;
1454: EB41         ;  The file specified in the FCB must have been readied for input by        ;
1455: EB41         ; issuing an Open File (code 15, OFH) or a Create File (code 22, 16H)       ;
1456: EB41         ; BDOS call. The value OOH is returned in A to indicate a successful Read   ;
1457: EB41         ; Sequential operation, while a nonzero value shows that the Read could     ;
1458: EB41         ; not be completed because there was no data in the next record, as at the  ;
1459: EB41         ; end of file.                                                              ;
1460: EB41         ;                                                                           ;
1461: EB41         ;  Although it is not immediately obvious, you can change the sequential    ;
1462: EB41         ; record number, FCB$SEQREC, and within a given extent, read a record at    ;
1463: EB41         ; random. If you want to access any given record within a file, you must    ;
1464: EB41         ; compute which extent that record would be in and set the extent field in  ;
1465: EB41         ; the file control block (FCB$EXTENT) before you open the file. Thus,       ;
1466: EB41         ; although the function name implies sequential access, in practice you can ;
1467: EB41         ; use it to perform a simple type of random access. If you need to do true  ;
1468: EB41         ; random access, look ahead to the Random Read function (code 33), which    ;
1469: EB41         ; takes care of opening the correct extent automatically.                   ;
1470: EB41         ;  When you read data from a CP/M text file, the normal convention is to    ;
1471: EB41         ; fill the last record of the file with lAH characters (CONTROL-Z).         ;
1472: EB41         ; Therefore, two possible conditions can indicate end-of-file: either       ;
1473: EB41         ; encountering a IAH, or receiving a return code from the BDOS function     ;
1474: EB41         ; (in the A register) of OFFH. However, if the file that you are reading    ;
1475: EB41         ; is not an ASCII text file, then a IAH character has no special meaning,   ;
1476: EB41         ; it is just a normal data byte in the body of the file.	                ;
1477: EB41         ;                                                                           ;
1478: EB41         ;			Function Code	:	C  = 14H                                    ;
1479: EB41         ;			Entry Parameters:	DE = Address of File Control Block			;
1480: EB41         ;			Exit Parameters :	A  = 0  => Success							;
1481: EB41         ;								  <> 0  => No data read, Probably EOF		;
1482: EB41         ;																			;
1483: EB41         ;----------------------------Read Sequential - 14 (20) ---------------------;
1484: EB41             vReadSeq:
1485: EB41 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1486: EB44         ;ReadSeq:
1487: EB44 3E 01                  LD     A,SEQ_ACCESS
1488: EB46 32 37 F5               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1489: EB49
1490: EB49             DiskRead:
1491: EB49 3E FF                  LD     A,TRUE
1492: EB4B 32 3B F5               LD     (readModeFlag),A     ; Set Flag for read
1493: EB4E
1494: EB4E CD DE EF               CALL   SetRecordVars        ; Set variables for current FCB
1495: EB51 3A 47 F5               LD     A,(currentFileRecord)
1496: EB54 21 45 F5               LD     HL,fcbRecordCount
1497: EB57 BE                     CP     M                    ; is File Record < fcbRecordCount
1498: EB58 DA 6E EB               JP     C,RecordOK           ; skip if  yes
1499: EB5B         ; not enough records in the extent
1500: EB5B FE 80                  CP     RecordsPerExtent     ; Is record count the Max ?
1501: EB5D C2 84 EB               JP     NZ,NothingRead       ;  No, Exit with EOF
1502: EB60
1503: EB60 CD F5 F2               CALL   OpenNextExt          ; Need to open the next extent
1504: EB63 AF                     XOR    A
1505: EB64 32 47 F5               LD     (currentFileRecord),A ; Reset the record count
1506: EB67 3A C5 EA               LD     A,(exitParameterByte) ; Was it a good Open
1507: EB6A B7                     OR     A
1508: EB6B C2 84 EB               JP     NZ,NothingRead       ;  exit if No
1509: EB6E
1510: EB6E             RecordOK:
1511: EB6E CD A5 F2               CALL   GetBlockNumber       ; Put it in absoluteCPMRecord
1512: EB71 CD D7 F2               CALL   WasBlockAllocated    ; Was it a good Allocation ?
1513: EB74 CA 84 EB               JP     Z,NothingRead        ; get out if not allocated
1514: EB77
1515: EB77 CD DD F2               CALL   SetActualRecordAdd   ; Absolute CPM Record
1516: EB7A CD C9 F3               CALL   Seek                 ; Go to proper track,sector
1517: EB7D CD 86 EF               CALL   ReadBuffer           ; Read into DMA address
1518: EB80 CD F1 F0               CALL   UpdateRecordVariables ; update Record info
1519: EB83 C9                     RET
1520: EB84
1521: EB84             NothingRead:
1522: EB84 C3 7B F3               JP     SetExitParamTo1      ; No Data read
1523: EB87
1524: EB87         ;----------------------------Write Sequential - 15 (21) --------------------;
1525: EB87         ;	This function writes a record from the address specified in the last Set;
1526: EB87         ; DMA (code 26, lAH) function call to the file defined in the FCB. The      ;
1527: EB87         ; sequential record number in the FCB (RC) is updated by 1 so that          ;
1528: EB87         ; the next call to Write Sequential will write to the next record position  ;
1529: EB87         ; in the file. If necessary, a new extent will be opened to receive the new ;
1530: EB87         ; record.                                                                   ;
1531: EB87         ;  This function is directly analogous to the Read Sequential function,     ;
1532: EB87         ; writing instead of reading. The file specified in the FCB must first be   ;
1533: EB87         ; activated by an Open File (code 15,OFH) or create File call (code 22,16H).;
1534: EB87         ;  A directory code of OOH is returned in A to indicate that the Write was  ;
1535: EB87         ; successful, a nonzero value is returned if the Write could not be         ;
1536: EB87         ; completed because the disk was full.                                      ;
1537: EB87         ;                                                                           ;
1538: EB87         ;  As with the Read Sequential function (code 20, 14H), you can achieve     ;
1539: EB87         ; a simple form of random writing to the file by manipulating the           ;
1540: EB87         ; sequential record number (RC). However, you can only overwrite existing   ;
1541: EB87         ; records in the file, and if you want to move to another extent, you       ;
1542: EB87         ; must close the file and reopen it with the FCB$EXTENT field set to the    ;
1543: EB87         ; correct value.                                                            ;
1544: EB87         ;  The only logical error condition that can occur when writing to a file   ;
1545: EB87         ; is insufficient room on the disk to accommodate the next extent of the    ;
1546: EB87         ; file. Any hardware errors detected will be handled by the disk driver     ;
1547: EB87         ; built into the BIOS or BDOS.                                              ;
1548: EB87         ;                                                                           ;
1549: EB87         ;                                                                           ;
1550: EB87         ;			Function Code	:	C  = 15H                                    ;
1551: EB87         ;			Entry Parameters:	DE = Address of File Control Block			;
1552: EB87         ;			Exit Parameters :	A  = 0  => Success							;
1553: EB87         ;								  <> 0  => No data read, Probably EOF		;
1554: EB87         ;																			;
1555: EB87         ;----------------------------Write Sequential - 15 (21) --------------------;
1556: EB87
1557: EB87             vWriteSeq:
1558: EB87 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1559: EB8A         ;	CALL	DiskWriteSeq
1560: EB8A         ;	RET
1561: EB8A         ;====================
1562: EB8A         ;sequential disk write
1563: EB8A             DiskWriteSeq:
1564: EB8A 3E 01                  LD     A,SEQ_ACCESS
1565: EB8C 32 37 F5               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1566: EB8F
1567: EB8F             DiskWrite:
1568: EB8F 3E 00                  LD     A,FALSE
1569: EB91 32 3B F5               LD     (readModeFlag),A     ; Set Flag for Write
1570: EB94
1571: EB94 CD 76 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1572: EB97 2A C3 EA               LD     HL,(paramDE)         ; Put FCB in HL
1573: EB9A CD 80 F2               CALL   CheckROFile          ; Terminate with error if File R/O
1574: EB9D CD DE EF               CALL   SetRecordVars        ; Set variables for current FCB
1575: EBA0 3A 47 F5               LD     A,(currentFileRecord) ; Get current record number
1576: EBA3 FE 80                  CP     highestRecordNumber+1 ; Is it still in the same extent?
1577: EBA5 D2 7B F3               JP     NC,SetExitParamTo1   ; Exit with NO WRITE set
1578: EBA8
1579: EBA8 CD A5 F2               CALL   GetBlockNumber       ; Compute disk block number
1580: EBAB CD D7 F2               CALL   WasBlockAllocated    ; Is it really allocated ?
1581: EBAE 0E 00                  LD     C,WriteAllocated     ; Assume a normal write operation
1582: EBB0 C2 FA EB               JP     NZ,HaveWriteBlock    ;  Skip if block already allocated
1583: EBB3         ; not allocated -
1584: EBB3         ; the argument to getblock is the starting position for the disk search
1585: EBB3         ; and should be the last allocated block for this file,
1586: EBB3         ; or the value 0 if no space has been allocated
1587: EBB3
1588: EBB3 CD B2 F2               CALL   GetDiskMapIndex      ; Disk Map Index in ACC
1589: EBB6 32 3D F5               LD     (diskMapIndex),A     ; Save it
1590: EBB9 01 00 00               LD     BC,0000h             ; Anticipate using 0000
1591: EBBC B7                     OR     A                    ; Is it block 0?
1592: EBBD 28 07                  JR     Z,FindAvailableBlock ;  skip if yes
1593: EBBF
1594: EBBF 4F                     LD     C,A                  ;  else a previous block exists
1595: EBC0 0B                     DEC    BC                   ; Adjust the index
1596: EBC1 CD BF F2               CALL   GetDiskMapValue      ; Put previous block # into HL
1597: EBC4 44                     LD     B,H                  ; Move previous block
1598: EBC5 4D                     LD     C,L                  ;  number into BC
1599: EBC6
1600: EBC6             FindAvailableBlock:
1601: EBC6 CD EC F1               CALL   GetClosestBlock      ; Block number in HL
1602: EBC9 7D                     LD     A,L                  ; If no available blocks HL
1603: EBCA B4                     OR     H                    ;  HL set to 0000H
1604: EBCB 20 06                  JR     NZ,FoundAvailableBlock ; Skip if found
1605: EBCD
1606: EBCD 3E 02                  LD     A,2                  ; Load return value
1607: EBCF 32 C5 EA               LD     (exitParameterByte),A ; Save for caller
1608: EBD2 C9                     RET                         ; Exit with exitParameterByte=2
1609: EBD3
1610: EBD3             FoundAvailableBlock:
1611: EBD3 22 49 F5               LD     (absoluteCPMRecord),HL ; Save the block number
1612: EBD6 EB                     EX     DE,HL                ; block number to DE (E)
1613: EBD7 2A C3 EA               LD     HL,(paramDE)         ; HL at FCB
1614: EBDA 01 10 00               LD     BC,fcbDiskMapIndex   ; Index to start of FCB Map
1615: EBDD 09                     ADD    HL,BC                ; HL=.start of FCB Map
1616: EBDE
1617: EBDE
1618: EBDE 3A 3D F5               LD     A,(diskMapIndex)     ; Get target block index
1619: EBE1 4F                     LD     C,A                  ; Map index to C
1620: EBE2 06 00                  LD     B,0                  ; Set MSB to 00
1621: EBE4 09                     ADD    HL,BC                ; Calculate 8 bit block's location
1622: EBE5 3A 41 F5               LD     A,(byteAllocationFlag) ; Get allocation size flag
1623: EBE8 B7                     OR     A                    ; Test it
1624: EBE9 28 04                  JR     Z,Allocate16Bit      ; Skip if allocating word
1625: EBEB
1626: EBEB 73                     LD     (HL),E               ; Update the Map
1627: EBEC C3 F3 EB               JP     MarkNewBlock         ; Skip 16 bit calculations
1628: EBEF
1629: EBEF             Allocate16Bit:
1630: EBEF 09                     ADD    HL,BC                ; Adjust for 16 bit value
1631: EBF0 72                     LD     (HL),D               ; Save MSB
1632: EBF1 23                     INC    HL
1633: EBF2 73                     LD     (HL),E               ; SAVE LSB
1634: EBF3             MarkNewBlock:
1635: EBF3         ;	CALL	ResetFileWriteFlag
1636: EBF3 CD 36 F0               CALL   GetWriteFileFlagValue ; HL = Address of fcbS2
1637: EBF6 CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag
1638: EBF8 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1639: EBFA
1640: EBFA             HaveWriteBlock:
1641: EBFA 3A C5 EA               LD     A,(exitParameterByte)
1642: EBFD B7                     OR     A
1643: EBFE C0                     RET    NZ                   ; Exit if non zero returned value ??
1644: EBFF
1645: EBFF C5                     PUSH   BC                   ; Write flag (in C)
1646: EC00 CD DD F2               CALL   SetActualRecordAdd   ; Set absoluteCPMRecord
1647: EC03 CD C9 F3               CALL   Seek                 ; Seek to o proper file position
1648: EC06 C1                     POP    BC                   ; Write flag (in C)
1649: EC07 C5                     PUSH   BC                   ; Write flag (in C)
1650: EC08 CD E9 F0               CALL   WriteBuffer          ; Write buffer and check result
1651: EC0B C1                     POP    BC                   ; Write flag (in C)
1652: EC0C
1653: EC0C 3A 47 F5               LD     A,(currentFileRecord) ; Get the current record
1654: EC0F 21 45 F5               LD     HL,fcbRecordCount    ; Get the starting FCB record count
1655: EC12 BE                     CP     M                    ; Current File Record > fcbRecordCount
1656: EC13 DA 1A EC               JP     C,DiskWrite1         ;  skip if yes
1657: EC16 77                     LD     (HL),A               ; update the FCB RC
1658: EC17 34                     INC    M                    ; fcbRecordCount = current File Record+1
1659: EC18 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1660: EC1A             DiskWrite1:
1661: EC1A         ; A has current File Record, C=2 if new block or new record#
1662: EC1A 0D                     DEC    C
1663: EC1B 0D                     DEC    C                    ; Check if C = unallocated write
1664: EC1C C2 26 EC               JP     NZ,DiskWrite2        ; Skip if C not unallocated write
1665: EC1F F5                     PUSH   AF                   ; currentFileRecord
1666: EC20 CD 36 F0               CALL   GetWriteFileFlagValue ; HL points to FCB s2
1667: EC23 CB BE                  RES    7,(HL)               ; Reset WriteFileFlag
1668: EC25 F1                     POP    AF                   ; currentFileRecord
1669: EC26             DiskWrite2:
1670: EC26         ; check for end of extent, if found attempt
1671: EC26         ; to open next extent in preparation for next write
1672: EC26 FE 7F                  CP     highestRecordNumber  ; Space for more records ?
1673: EC28 C2 46 EC               JP     NZ,DiskWriteCleanup  ;  finish up if Yes
1674: EC2B
1675: EC2B 3A 37 F5               LD     A,(diskAccessType)   ; Is this using Random Access
1676: EC2E B7                     OR     A
1677: EC2F CA 46 EC               JP     Z,DiskWriteCleanup   ;  finish up if Yes
1678: EC32
1679: EC32 CD F1 F0               CALL   UpdateRecordVariables ; Update variables from I/O in  FCB
1680: EC35 CD F5 F2               CALL   OpenNextExt          ; Acc = 0 OK, Acc = 1 Failed
1681: EC38 21 C5 EA               LD     HL,exitParameterByte
1682: EC3B 7E                     LD     A,(HL)               ; Put Open  result in parameter
1683: EC3C B7                     OR     A                    ; Is it 00
1684: EC3D C2 44 EC               JP     NZ,DiskWriteCleanup0 ;  no, skip currentRecord update
1685: EC40 3D                     DEC    A                    ; A gets FF
1686: EC41 32 47 F5               LD     (currentFileRecord),A ; Update currentFileRecord
1687: EC44
1688: EC44             DiskWriteCleanup0:
1689: EC44 36 00                  LD     (HL),0               ; Set exitParameterByte
1690: EC46             DiskWriteCleanup:
1691: EC46 C3 F1 F0               JP     UpdateRecordVariables ; update variables from I/O in  FCB
1692: EC49
1693: EC49
1694: EC49         ;--------------------------------- Make File - 16 (22) ---------------------;
1695: EC49         ;  This function creates a new file of the specified name and type. You must;
1696: EC49         ; first ensure that no file of the same name and type already exists on the ;
1697: EC49         ; same logical disk, either by trying to open the file (if this succeeds,   ;
1698: EC49         ; the file already exists) or by unconditionally erasing the file.          ;
1699: EC49         ;  In addition to creating the file and its associated file directory entry,;
1700: EC49         ; this function also effectively opens the file so that it is ready for     ;
1701: EC49         ; records to be written to it.                                              ;
1702: EC49         ;  This function returns a normal directory code if the file creation has   ;
1703: EC49         ; completed successfully or a value of OFFH if there is insufficient        ;
1704: EC49         ; disk or directory space.                                                  ;
1705: EC49         ;  Note that this function cannot accept an ambiguous file name in the FCB. ;
1706: EC49         ;                                                                           ;
1707: EC49         ;                                                                           ;
1708: EC49         ;			Function Code	:	C  = 16H                                    ;
1709: EC49         ;			Entry Parameters:	DE = Address of File Control Block			;
1710: EC49         ;			Exit Parameters :	A  = Directory Code							;
1711: EC49         ;																			;
1712: EC49         ;---------------------------- Make File - 16 (22) --------------------------;
1713: EC49             vMakeFile:
1714: EC49 CD 30 F0               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1715: EC4C CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1716: EC4F C3 0A EF               JP     MakeNewFile          ; Go Make it
1717: EC52
1718: EC52         ;-------------------------- Rename File - 17 (23) --------------------------;
1719: EC52         ;  This function renames an existing file name and type to a new name and   ;
1720: EC52         ; type. It is unusual in that it uses a single FCB to store both the old    ;
1721: EC52         ; file name and type (in the first 16 bytes) and the new file name and type ;
1722: EC52         ; (in the second 16 bytes).                                                 ;
1723: EC52         ;  This function returns a normal directory code if the file rename was     ;
1724: EC52         ; completed successfully or a value of OFFH if the old file name could not  ;
1725: EC52         ; be found.                                                                 ;
1726: EC52         ;                                                                           ;
1727: EC52         ;  The Rename File function only checks that the old file name and type     ;
1728: EC52         ; exist; it makes no check to ensure that the new name and type combination ;
1729: EC52         ; does not already exist. Therefore, you should try to open the new file    ;
1730: EC52         ; name and type. If you succeed, do not attempt the rename operation.       ;
1731: EC52         ; CP/M will create more than one file of the same name and type, and you    ;
1732: EC52         ; stand to lose the information in both files as you attempt to sort out    ;
1733: EC52         ; the problem.                                                              ;
1734: EC52         ;  Never use ambiguous file names in a rename operation; it produces strange;
1735: EC52         ; effects and may result in files being irreparably damaged. This function  ;
1736: EC52         ; will change all occurrences of the old file name to the new name.         ;
1737: EC52         ;                                                                           ;
1738: EC52         ;                                                                           ;
1739: EC52         ;			Function Code	:	C  = 17H                                   ;
1740: EC52         ;			Entry Parameters:	DE = Address of File Control Block			;
1741: EC52         ;			Exit Parameters :	A  = Directory Code							;
1742: EC52         ;																			;
1743: EC52         ;-------------------------- Rename File - 17 (23) --------------------------;
1744: EC52             vRenameFile:
1745: EC52 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1746: EC55 CD 76 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1747: EC58 0E 0C                  LD     C,fcbExtIndex        ; Match user#, Name & Type only
1748: EC5A CD 5C F0               CALL   SearchForDirectoryRecord
1749: EC5D
1750: EC5D         ; Move the old use number to the new entry (2nd half of FCB)
1751: EC5D 2A C3 EA               LD     HL,(paramDE)         ; FCB pointer
1752: EC60 7E                     LD     A,(HL)               ; First byte of Dir entry
1753: EC61 11 10 00               LD     DE,fcbDiskMapIndex   ; Use second half of FCB
1754: EC64 19                     ADD    HL,DE                ; Point at the second half of FCB
1755: EC65 77                     LD     (HL),A               ; Put into new name user position
1756: EC66
1757: EC66             RenameLoop:
1758: EC66 CD 93 F1               CALL   AtEndOfDirectory     ; If have we checked the whole dir
1759: EC69 CA 6F F2               JP     Z,DirLocationToReturnLoc ;  return directory Index to caller
1760: EC6C         ; process this match
1761: EC6C CD 7D F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1762: EC6F 0E 10                  LD     C,fcbDiskMapIndex    ; Set starting position
1763: EC71 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1764: EC73 CD 8E F2               CALL   CopyDir              ; copy from FCB to dir entry
1765: EC76         ; element renamed, look for more
1766: EC76 CD 71 F0               CALL   GetNextDirectoryRecord ; Look for more dir entries
1767: EC79 C3 66 EC               JP     RenameLoop           ; Loop
1768: EC7C
1769: EC7C         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1770: EC7C         ; This function returns a bit map, called the login vector, in register pair ;
1771: EC7C         ; HL, indicating which logical disk drives have been selected since the last ;
1772: EC7C         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1773: EC7C         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1774: EC7C         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1775: EC7C         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1776: EC7C         ;  Logical disks can be selected programmatically through any file operation ;
1777: EC7C         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1778: EC7C         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1779: EC7C         ; where "X" is equal to A, B, ... , P.                                       ;
1780: EC7C         ;                                                                            ;
1781: EC7C         ;			Function Code	:	C = 018H                                     ;
1782: EC7C         ;			Entry Parameters:	None										 ;
1783: EC7C         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1784: EC7C         ;																			 ;
1785: EC7C         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1786: EC7C             vGetLoginVector:
1787: EC7C 2A 16 F5               LD     HL,(loggedDisks)
1788: EC7F 22 C5 EA               LD     (exitParameterWord),HL
1789: EC82 C9                     RET
1790: EC83
1791: EC83         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1792: EC83         ;   This function returns the current default disk set by the last Select    ;
1793: EC83         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1794: EC83         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1795: EC83         ;                                                                            ;
1796: EC83         ;  This function returns the current default disk in coded form.             ;
1797: EC83         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1798: EC83         ; If you need to convert this to the corresponding ASCII character, simply   ;
1799: EC83         ; add 41H to register A. Use this function when you convert a file name and  ;
1800: EC83         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1801: EC83         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1802: EC83         ; You must therefore use this function to determine the logical disk letter  ;
1803: EC83         ; for the default drive.                                                     ;
1804: EC83         ;                                                                            ;
1805: EC83         ;			Function Code	:	C = 019H                                     ;
1806: EC83         ;			Entry Parameters:	None										 ;
1807: EC83         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1808: EC83         ;																			 ;
1809: EC83         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1810: EC83             vGetCurrentDisk:
1811: EC83 3A 12 F5               LD     A,(currentDisk)
1812: EC86 32 C5 EA               LD     (exitParameterByte),A
1813: EC89 C9                     RET
1814: EC8A
1815: EC8A         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1816: EC8A         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1817: EC8A         ; value. The name is an historic relic dating back to the Intel Development  ;
1818: EC8A         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1819: EC8A         ; its hardware, could read data from a diskette directly into memory or      ;
1820: EC8A         ; write data to a diskette directly from memory. The name DMA address now    ;
1821: EC8A         ; applies to the address of the buffer to and from which data is             ;
1822: EC8A         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1823: EC8A         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1824: EC8A         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1825: EC8A         ; value of 0080H.                                                            ;
1826: EC8A         ;                                                                            ;
1827: EC8A         ;			Function Code	:	C = 0A9H                                     ;
1828: EC8A         ;			Entry Parameters:	DE = DMA Address							 ;
1829: EC8A         ;			Exit Parameters :	None										 ;
1830: EC8A         ;																			 ;
1831: EC8A         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1832: EC8A             vSetDMA:
1833: EC8A 2A C3 EA               LD     HL,(paramDE)
1834: EC8D 22 18 F5               LD     (initDAMAddress),HL
1835: EC90 C3 78 EF               JP     SetDataDMA
1836: EC93
1837: EC93         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1838: EC93         ;  This function returns the base, or starting, address of the allocation    ;
1839: EC93         ; vector for the currently selected logical disk. This information,          ;
1840: EC93         ; indicating which parts of the disk are assigned, is used by utility        ;
1841: EC93         ; programs and the BDOS itself to determine how much unused space is on the  ;
1842: EC93         ; logical disk, to locate an unused allocation block in order to extend      ;
1843: EC93         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1844: EC93         ;                                                                            ;
1845: EC93         ;			Function Code	:	C = 01BH                                     ;
1846: EC93         ;			Entry Parameters:	None										 ;
1847: EC93         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1848: EC93         ;																			 ;
1849: EC93         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1850: EC93             vGetAllocAddr:
1851: EC93 2A 26 F5               LD     HL,(caAllocVector)
1852: EC96 22 C5 EA               LD     (exitParameterWord),HL
1853: EC99 C9                     RET
1854: EC9A
1855: EC9A         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1856: EC9A         ;  This function logically sets the currently selected disk to a Read-Only   ;
1857: EC9A         ; state. Any attempts to execute a Write Sequential or Write Random function ;
1858: EC9A         ; to the selected disk will be intercepted by the BDOS, and the following    ;
1859: EC9A         ; message will appear on the console:                                        ;
1860: EC9A         ;	BDOS Err on X: R/O                                                       ;
1861: EC9A         ;	where X: is the selected disk.                                           ;
1862: EC9A         ;                                                                            ;
1863: EC9A         ;  Once you have requested Read-Only status for the currently selected       ;
1864: EC9A         ; logical disk, this status will persist even if you proceed to select       ;
1865: EC9A         ; other logical disks. In fact, it will remain in force until the next warm  ;
1866: EC9A         ; boot or Reset Disk System function call.                                   ;
1867: EC9A         ;  Digital Research documentation refers to this function code as Disk Write ;
1868: EC9A         ; Protect. The Read-Only description is used here because it corresponds     ;
1869: EC9A         ; to the error message produced if your program attempts to write on         ;
1870: EC9A         ; the disk.                                                                  ;
1871: EC9A         ;                                                                            ;
1872: EC9A         ;			Function Code	:	C = 01CH                                     ;
1873: EC9A         ;			Entry Parameters:	None										 ;
1874: EC9A         ;			Exit Parameters :	None										 ;
1875: EC9A         ;																			 ;
1876: EC9A         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1877: EC9A         ;;write protect current disk
1878: EC9A             vWriteProtectDisk:
1879: EC9A C3 8E EF               JP     SetDiskReadOnly
1880: EC9D
1881: EC9D         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1882: EC9D         ;  This function returns a bit map in registers H and L showing which logical;
1883: EC9D         ; disks in the system have been set to Read-Only status, either by the       ;
1884: EC9D         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1885: EC9D         ; BDOS itself, because it detected that a diskette had been changed.         ;
1886: EC9D         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1887: EC9D         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1888: EC9D         ; the specific logical disk is set to I if the disk has been set to          ;
1889: EC9D         ; Read-Only status.                                                          ;
1890: EC9D         ;                                                                            ;
1891: EC9D         ;			Function Code	:	C = 01DH                                     ;
1892: EC9D         ;			Entry Parameters:	None										 ;
1893: EC9D         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1894: EC9D         ;																			 ;
1895: EC9D         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1896: EC9D             vGetReadOnlyMap:
1897: EC9D 2A 14 F5               LD     HL,(readOnlyVector)
1898: ECA0 22 C5 EA               LD     (exitParameterWord),HL
1899: ECA3 C9                     RET
1900: ECA4
1901: ECA4         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1902: ECA4         ;  This function sets the bits that describe attributes of a file in the    ;
1903: ECA4         ; relevant directory entries for the specified file. Each file can be       ;
1904: ECA4         ; assigned up to 11 file attributes. Of these 11, two have predefined       ;
1905: ECA4         ; meanings, four others are available for you to use, and the remaining     ;
1906: ECA4         ; five are reserved for future use by CP/M.                                 ;
1907: ECA4         ;  Each attribute consists of a single bit. The most significant bit of     ;
1908: ECA4         ; each byte of the file name and type is used to store the attributes.      ;
1909: ECA4         ; The file attributes are known by a code consisting of the letter "f"      ;
1910: ECA4         ; (for file name) or "t" (for file type), followed by the number of the     ;
1911: ECA4         ; character position and a single quotation mark. For example, the Read-Only;
1912: ECA4         ; attribute is tl'.                                                         ;
1913: ECA4         ;	The significance of the attributes is as follows:                       ;
1914: ECA4         ;			fl' to f4' Available for you to use                             ;
1915: ECA4         ;			f5' to fS' Reserved for future CP/M use                         ;
1916: ECA4         ;			tl' Read-Only File attribute                                    ;
1917: ECA4         ;			t2' System File attribute                                       ;
1918: ECA4         ;			t3' Reserved for future CP/M use                                ;
1919: ECA4         ;			                                                                ;
1920: ECA4         ;  Attributes are set by presenting this function with an FCB in which the  ;
1921: ECA4         ; unambiguous file name has been preset with the most significant bits      ;
1922: ECA4         ; set appropriately. This function then searches the directory for a match  ;
1923: ECA4         ; and changes the matched entries to contain the attributes which have been ;
1924: ECA4         ; set in the FCB.                                                           ;
1925: ECA4         ;  The BDOS will intercept any attempt to write on a file that has the      ;
1926: ECA4         ; Read-Only attribute set. The DIR command in the CCP does not display any  ;
1927: ECA4         ; file with System status.                                                  ;
1928: ECA4         ;                                                                           ;
1929: ECA4         ;  You can use the four attributes available to you to set up a file        ;
1930: ECA4         ; security system, or perhaps to flag certain files that must be backed up  ;
1931: ECA4         ; to other disks. The Search First and Search Next functions allow you to   ;
1932: ECA4         ; view the complete file directory entry, so your programs can test the     ;
1933: ECA4         ; attributes easily.                                                        ;
1934: ECA4         ;                                                                           ;
1935: ECA4         ;                                                                           ;
1936: ECA4         ;			Function Code	:	C  = 1EH                                    ;
1937: ECA4         ;			Entry Parameters:	DE = Address of File Control Block			;
1938: ECA4         ;			Exit Parameters :	A  = Directory Code							;
1939: ECA4         ;																			;
1940: ECA4         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1941: ECA4             vSetFileAttributes:
1942: ECA4 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
1943: ECA7 0E 0C                  LD     C,fcbExtIndex        ; Size of search/match
1944: ECA9 CD 5C F0               CALL   SearchForDirectoryRecord ; Find a match
1945: ECAC
1946: ECAC             SetAttributesLoop:
1947: ECAC CD 93 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
1948: ECAF CA 6F F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller							;  exit if yes
1949: ECB2         ; Directory entry found
1950: ECB2 0E 00                  LD     C,0                  ; Set starting position
1951: ECB4 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1952: ECB6 CD 8E F2               CALL   CopyDir              ; copy from FCB to dir entry
1953: ECB9 CD 71 F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1954: ECBC C3 AC EC               JP     SetAttributesLoop    ; Loop
1955: ECBF
1956: ECBF         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1957: ECBF         ;  This function returns the address of the disk parameter block (DPB) for   ;
1958: ECBF         ; the last selected logical disk. The DPB describes the physical             ;
1959: ECBF         ; characteristics of a specific logical disk-information mainly of interest  ;
1960: ECBF         ; for system utility programs.                                               ;
1961: ECBF         ;                                                                            ;
1962: ECBF         ;			Function Code	:	C = 1FH                                      ;
1963: ECBF         ;			Entry Parameters:	None										 ;
1964: ECBF         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1965: ECBF         ;																			 ;
1966: ECBF         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1967: ECBF             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1968: ECBF 2A 22 F5               LD     HL,(caDiskParamBlock)
1969: ECC2 22 C5 EA               LD     (exitParameterWord),HL
1970: ECC5 C9                     RET
1971: ECC6
1972: ECC6         ;------------------------- Read Random - 21 (33) ---------------------------;
1973: ECC6         ; This function reads a specific CP/M record (128 bytes) from a random file ;
1974: ECC6         ; that is, a file in which records can be accessed directly. It assumes that;
1975: ECC6         ; you have already opened the file, set the DMA address using the BDOS      ;
1976: ECC6         ; Set DMA function, and set the specific record to be read into the random  ;
1977: ECC6         ; record number in the FCB. This function computes the extent of the        ;
1978: ECC6         ; specified record number and attempts to open it and read the correct CP/M ;
1979: ECC6         ; record into the DMA address.                                              ;
1980: ECC6         ;  The random record number in the FCB is three bytes long (at relative     ;
1981: ECC6         ; bytes 33, 34, and 35). Byte 33 is the least significant byte, 34 is the   ;
1982: ECC6         ; middle byte, and 35 the most significant. CP/M uses only the most         ;
1983: ECC6         ; significant byte (35) for computing the overall file size (function 35).  ;
1984: ECC6         ; You must set this byte to 0 when setting up the FCB. Bytes 33 and 34      ;
1985: ECC6         ; are used together for the Read Random, so you can access from record      ;
1986: ECC6         ; 0 to 65535 (a maximum file size of 8,388,480 bytes).                      ;
1987: ECC6         ;  This function returns with A set to 0 to indicate that the operation has ;
1988: ECC6         ; been completed successfully, or A set to a nonzero value if an error has  ;
1989: ECC6         ; occurred. The error codes are as follows:                                 ;
1990: ECC6         ;		A = 01 (attempt to read unwritten record)                           ;
1991: ECC6         ;		A = 03 (CP/M could not close current extent)                        ;
1992: ECC6         ;		A = 04 (attempt to read unwritten extent)                           ;
1993: ECC6         ;		A = 06 (attempt to read beyond end of disk)                         ;
1994: ECC6         ;		                                                                    ;
1995: ECC6         ;  Unlike the Read Sequential BOOS function (code 20, l4H), which updates   ;
1996: ECC6         ; the current (sequential) record number in the FCB, the Read Random        ;
1997: ECC6         ; function leaves the record number unchanged, so that a subsequent Write   ;
1998: ECC6         ; Random will replace the record just read.                                 ;
1999: ECC6         ;  You can follow a Read Random with a Write Sequential (code 21, l5H).     ;
2000: ECC6         ; This will rewrite the record just read, but will then update the          ;
2001: ECC6         ; sequential record number. Or you may choose to use a Read Sequential after;
2002: ECC6         ; the Read Random. In this case, the same record will be reread and the     ;
2003: ECC6         ; sequential record number will be incremented. In short, the file can be   ;
2004: ECC6         ; sequentially read or written once the Read Random has been used to        ;
2005: ECC6         ; position to the required place in the file.                               ;
2006: ECC6         ;                                                                           ;
2007: ECC6         ; To use the Read Random function, you must first open the base extent of   ;
2008: ECC6         ; the file, that is, extent O. Even though there may be no actual data      ;
2009: ECC6         ; records in this extent, opening permits the file to be processed          ;
2010: ECC6         ; correctly.                                                                ;
2011: ECC6         ;  One problem that is not immediately obvious with random files is that    ;
2012: ECC6         ; they can easily be created with gaps in the file. If you were to create   ;
2013: ECC6         ; the file with record number 0 and record number 5000, there would be no   ;
2014: ECC6         ; intervening file extents. Should you attempt to read or copy the file     ;
2015: ECC6         ; sequentially, even using CP/M's file copy utility, only the first extent  ;
2016: ECC6         ; (and in this case, record 0) would get copied. A Read Sequential function ;
2017: ECC6         ; would return an "end of file" error after reading record O. You must      ;
2018: ECC6         ; therefore be conscious of the type of the file that you try and read.     ;
2019: ECC6         ;                                                                           ;
2020: ECC6         ;                                                                           ;
2021: ECC6         ;                                                                           ;
2022: ECC6         ;			Function Code	:   C  = 21H                                    ;
2023: ECC6         ;			Entry Parameters:  DE = Address of File Control Block			;
2024: ECC6         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)   ;
2025: ECC6         ;								A = 03 (CP/M could not close current extent);
2026: ECC6         ;								A = 04 (attempt to read unwritten extent)   ;
2027: ECC6         ;								A = 05 (CP/M cannot create new extent)		;
2028: ECC6         ;								A = 06 (attempt to read beyond end of disk) ;
2029: ECC6         ;																			;
2030: ECC6         ;------------------------- Read Random - 21 (33) ---------------------------;
2031: ECC6             vReadRandom:
2032: ECC6 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
2033: ECC9         ;	JP		RandomDiskRead
2034: ECC9
2035: ECC9             RandomDiskRead:
2036: ECC9 0E FF                  LD     C,TRUE               ; Identify as a Read
2037: ECCB CD 03 F1               CALL   RandomSeek           ; Set up correct Dir entry etc.
2038: ECCE CC 49 EB               CALL   Z,DiskRead           ; Go Read
2039: ECD1 C9                     RET
2040: ECD2
2041: ECD2
2042: ECD2         ;------------------------- Get File Size - 23 (35) -------------------------;
2043: ECD2         ;  This function returns the virtual size of the specified file. It does so ;
2044: ECD2         ; by setting the random record number (bytes 33-35) in the specified FCB to ;
2045: ECD2         ; the maximum 128-byte record number in the file. The virtual file size is  ;
2046: ECD2         ; calculated from the record address of the record following the end of the ;
2047: ECD2         ; file. Bytes 33 and 34 form a 16-bit value that contains the record number,;
2048: ECD2         ; with overflow indicated in byte 35. If byte 35 is 01, this means that the ;
2049: ECD2         ; file has the maximum record count of 65,536.                              ;
2050: ECD2         ;  If the function cannot find the file specified by the FCB, it returns    ;
2051: ECD2         ; with the random record field set to O.                                    ;
2052: ECD2         ;  You can use this function when you want to add data to the end of an     ;
2053: ECD2         ; existing file. By calling this function first, the random record bytes    ;
2054: ECD2         ; will be set to the end of file. Subsequent Write Random calls will write  ;
2055: ECD2         ; out records to this preset address.                                       ;
2056: ECD2         ;                                                                           ;
2057: ECD2         ;  Do not confuse the virtual file size with the actual file size. In a     ;
2058: ECD2         ; random file, if you write just a single CP/M record to record number      ;
2059: ECD2         ; 1000 and then call this function, it will return with the random record   ;
2060: ECD2         ; number field set in the FCB to 1000, even though only a single record     ;
2061: ECD2         ; exists in the file. For sequential files, this function returns the       ;
2062: ECD2         ; number of records in the file. In this case, the virtual and actual file  ;
2063: ECD2         ; sizes coincide.                                                           ;
2064: ECD2         ;                                                                           ;
2065: ECD2         ;                                                                           ;
2066: ECD2         ;			Function Code	:	C  = 23H                                    ;
2067: ECD2         ;			Entry Parameters:	DE = Address of File Control Block			;
2068: ECD2         ;			Exit Parameters :	Random record field set in FCB				;
2069: ECD2         ;																			;
2070: ECD2         ;------------------------- Get File Size - 23 (35) -------------------------;
2071: ECD2             vComputeFileSize:
2072: ECD2 CD B1 EF               CALL   ReselectDisk         ; Reselect if needed
2073: ECD5         ;	JP		GetFileSize
2074: ECD5
2075: ECD5         ;compute logical file size for current fcb
2076: ECD5         ; GetFileSize:
2077: ECD5 0E 0C                  LD     C,fcbExtIndex        ; Set search/match length
2078: ECD7 CD 5C F0               CALL   SearchForDirectoryRecord ; Set directoryIndex
2079: ECDA         ; zero the receiving FCB Random Record field
2080: ECDA 2A C3 EA               LD     HL,(paramDE)         ; Point at FCB
2081: ECDD 11 21 00               LD     DE,recordRandom      ; Random Record index
2082: ECE0 19                     ADD    HL,DE                ; Point at Random Record
2083: ECE1 E5                     PUSH   HL                   ; Random Record LSB pointer
2084: ECE2 72                     LD     (HL),D               ; Set Random Record LSB = 0
2085: ECE3 23                     INC    HL                   ; Random Record MSB pointer
2086: ECE4 72                     LD     (HL),D               ; Set Random Record MSB = 0
2087: ECE5 23                     INC    HL                   ; Random Record overflow pointer
2088: ECE6 72                     LD     (HL),D               ; Set Random Record overflow = 0
2089: ECE7
2090: ECE7             GetFileSize1:
2091: ECE7 CD 93 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
2092: ECEA CA 0F ED               JP     Z,GetFileSizeExit    ;  exit if no
2093: ECED
2094: ECED CD 9C F1               CALL   GetCurrentDirectoryRecord ; HL points at Directory entry
2095: ECF0 11 0F 00               LD     DE,fcbRCIndex        ; FCB Record Count index
2096: ECF3 CD 37 ED               CALL   GetRandomRecordPosition
2097: ECF6         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
2098: ECF6 E1                     POP    HL
2099: ECF7 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
2100: ECF8 5F                     LD     E,A                  ; save cy
2101: ECF9 79                     LD     A,C
2102: ECFA 96                     SUB    M
2103: ECFB 23                     INC    HL                   ; ls byte
2104: ECFC 78                     LD     A,B
2105: ECFD 9E                     SBC    A,(HL)
2106: ECFE 23                     INC    HL                   ; middle byte
2107: ECFF 7B                     LD     A,E
2108: ED00 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
2109: ED01 DA 09 ED               JP     C,GetFileSize2       ; for another try
2110: ED04         ; fcb is less or equal, fill from directory
2111: ED04 73                     LD     (HL),E
2112: ED05 2B                     DEC    HL
2113: ED06 70                     LD     (HL),B
2114: ED07 2B                     DEC    HL
2115: ED08 71                     LD     (HL),C
2116: ED09             GetFileSize2:                      ; getnextsize:
2117: ED09 CD 71 F0               CALL   GetNextDirectoryRecord
2118: ED0C C3 E7 EC               JP     GetFileSize1
2119: ED0F             GetFileSizeExit:                      ; setsize:
2120: ED0F E1                     POP    HL                   ; discard .fcb(random record field)
2121: ED10 C9                     RET
2122: ED11
2123: ED11         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2124: ED11         ;  This function sets the random record number in the FCB to the correct    ;
2125: ED11         ; value for the last record read or written sequentially to the file.       ;
2126: ED11         ;                                                                           ;
2127: ED11         ;  This function provides you with a convenient way to build an index file  ;
2128: ED11         ;  so that you can randomly access a sequential file. Open the sequential   ;
2129: ED11         ;  file, and as you read each record, extract the appropriate key field from;
2130: ED11         ;  the data record. Make the BDOS Set Random Record request and create a new;
2131: ED11         ; data record with just the key field and the random record number. Write   ;
2132: ED11         ; the new data record out to the index file.                                ;
2133: ED11         ;  Once you have done this for each record in the file, your index file     ;
2134: ED11         ; provides a convenient method, given a search key value, of finding the    ;
2135: ED11         ; appropriate CP/M record in which the data lies.                           ;
2136: ED11         ;  You can also use this function as a means offinding out where you are    ;
2137: ED11         ; currently positioned in a sequential file-either to relate a CP/M record  ;
2138: ED11         ; number to the position, or simply as a place-marker to allow a            ;
2139: ED11         ; repositioning to the same place later.                                    ;
2140: ED11         ;                                                                           ;
2141: ED11         ;                                                                           ;
2142: ED11         ;			Function Code	:	C  = 24H                                    ;
2143: ED11         ;			Entry Parameters:	DE = Address of File Control Block			;
2144: ED11         ;			Exit Parameters :	Random record field set in FCB				;
2145: ED11         ;																			;
2146: ED11         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2147: ED11             vSetRandomRecord:
2148: ED11         ;	JP		SetRandomRecord
2149: ED11         ; SetRandomRecord:
2150: ED11 2A C3 EA               LD     HL,(paramDE)         ; FCB
2151: ED14 11 20 00               LD     DE,recordSeq         ; Sequential record pointer
2152: ED17 CD 37 ED               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
2153: ED1A 21 21 00               LD     HL,recordRandom
2154: ED1D 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
2155: ED1E 71                     LD     (HL),C
2156: ED1F 23                     INC    HL
2157: ED20 70                     LD     (HL),B
2158: ED21 23                     INC    HL
2159: ED22 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
2160: ED23 C9                     RET
2161: ED24
2162: ED24         ;*****************************************************************
2163: ED24
2164: ED24         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
2165: ED24         ;  This function resets individual disk drives. It is a more precise version ;
2166: ED24         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
2167: ED24         ; specific logical; disks rather than all of them.                           ;
2168: ED24         ;  The bit map in DE shows which disks are to be reset. The least significant;
2169: ED24         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
2170: ED24         ; The bits set to 1 indicate the disks to be reset.                          ;
2171: ED24         ;  Note that this function returns a zero value in A in order to maintain    ;
2172: ED24         ; compatibility with MP/ M.                                                  ;
2173: ED24         ;                                                  ;                         ;
2174: ED24         ;  Use this function when only specific diskettes need to be changed.        ;
2175: ED24         ; Changing a diskette without requesting CP/M to log it in will cause the    ;
2176: ED24         ; BDOS to assume that an error has occurred and to set the new diskette to   ;
2177: ED24         ; Read-Only status as a protective measure                                   ;
2178: ED24         ;                                                                            ;
2179: ED24         ;			Function Code	:	C = 25H                                      ;
2180: ED24         ;			Entry Parameters:	DE = Logical Drive Bit Vector				 ;
2181: ED24         ;			Exit Parameters :	A = 00H										 ;
2182: ED24         ;																			 ;
2183: ED24         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
2184: ED24         ;  **************  Not Yet Implemented   **************
2185: ED24             vResetDrive:
2186: ED24 3E FF                  LD     A,-1                 ; Error return
2187: ED26 C9                     RET
2188: ED27
2189: ED27
2190: ED27
2191: ED27         ;-----------------------------------------------------------------
2192: ED27
2193: ED27         ;*****************************************************************
2194: ED27         ;write random record
2195: ED27         ;IN  - (DE) FCB address
2196: ED27         ;OUT - (A) 01 = Reading unwritten data
2197: ED27         ;	 02 = N/U
2198: ED27         ;	 03 = Cannot close current extent
2199: ED27         ;	 04 = Seek to unwriten Extent
2200: ED27         ;	 05 = Cannot create new Extent because of directory overflow
2201: ED27         ;	 06 = Seek past Physical end of Disk
2202: ED27             vWriteRandom:                      ; func34 (34 - 22) Write Random record
2203: ED27 CD B1 EF               CALL   ReselectDisk
2204: ED2A C3 2E ED               JP     RandomDiskWrite      ; to perform the disk write
2205: ED2D         ;ret ;jmp goback
2206: ED2D         ;? ;*****************************************************************
2207: ED2D         ;? ;Reset Drive
2208: ED2D         ;? ;IN  - (DE) Drive Vector
2209: ED2D         ;? ;OUT - (A) 00
2210: ED2D         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
2211: ED2D         ;? ; Not Yet Implemented   **************
2212: ED2D         ;?	RET
2213: ED2D         ;*****************************************************************
2214: ED2D         ;*****************************************************************
2215: ED2D         ;Write Random With Zero Fill
2216: ED2D         ;IN  - (DE) FCB address
2217: ED2D         ;OUT - (A) Return Code		see Function 34
2218: ED2D             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
2219: ED2D         ; Not Yet Implemented   **************
2220: ED2D C9                     RET
2221: ED2E         ;*****************************************************************
2222: ED2E         ;******************< Random I/O Stuff ****************************
2223: ED2E         ;*****************************************************************
2224: ED2E         ;*****************************************************************
2225: ED2E         ;random disk write
2226: ED2E             RandomDiskWrite:                      ; randiskwrite
2227: ED2E 0E 00                  LD     C,FALSE              ; marked as read operation
2228: ED30 CD 03 F1               CALL   RandomSeek
2229: ED33 CC 8F EB               CALL   Z,DiskWrite          ; if seek successful
2230: ED36 C9                     RET
2231: ED37         ;*****************************************************************
2232: ED37         ;*****************************************************************
2233: ED37         ;*****************************************************************
2234: ED37         ;--------------------------- Get Random Record Position --------------------;
2235: ED37         ; on Entry :
2236: ED37         ;			HL = pointer to directory entry
2237: ED37         ;			DE = fcbRCIndex/seqRecord index
2238: ED37             GetRandomRecordPosition:
2239: ED37 EB                     EX     DE,HL                ; DE = pointer to directory entry
2240: ED38 19                     ADD    HL,DE
2241: ED39         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
2242: ED39 4E                     LD     C,(HL)               ; C = record count
2243: ED3A 06 00                  LD     B,0                  ; Make count a word value
2244: ED3C
2245: ED3C 21 0C 00               LD     HL,fcbExtIndex       ; FCB Extent index
2246: ED3F 19                     ADD    HL,DE
2247: ED40 7E                     LD     A,(HL)               ; ACC has Extent value
2248: ED41 0F                     RRCA
2249: ED42 E6 80                  AND    80H                  ; A=e000 0000
2250: ED44 81                     ADD    A,C
2251: ED45 4F                     LD     C,A
2252: ED46 3E 00                  LD     A,0
2253: ED48 88                     ADC    A,B
2254: ED49 47                     LD     B,A
2255: ED4A         ; BC = 0000 000? errrr rrrr
2256: ED4A 7E                     LD     A,(HL)
2257: ED4B 0F                     RRCA
2258: ED4C E6 0F                  AND    LO_NIBBLE_MASK
2259: ED4E 80                     ADD    A,B
2260: ED4F 47                     LD     B,A
2261: ED50         ; BC = 000? eeee errrr rrrr
2262: ED50 21 0E 00               LD     HL,fcbS2Index
2263: ED53 19                     ADD    HL,DE
2264: ED54 7E                     LD     A,(HL)               ; A=XXX? mmmm
2265: ED55 87                     ADD    A,A
2266: ED56 87                     ADD    A,A
2267: ED57 87                     ADD    A,A
2268: ED58 87                     ADD    A,A                  ; cy=? A=mmmm 0000
2269: ED59 F5                     PUSH   AF
2270: ED5A 80                     ADD    A,B
2271: ED5B 47                     LD     B,A
2272: ED5C         ; cy=?, BC = mmmm eeee errr rrrr
2273: ED5C F5                     PUSH   AF                   ; possible second carry
2274: ED5D E1                     POP    HL                   ; cy = lsb of L
2275: ED5E 7D                     LD     A,L                  ; cy = lsb of A
2276: ED5F E1                     POP    HL                   ; cy = lsb of L
2277: ED60 B5                     OR     L                    ; cy/cy = lsb of A
2278: ED61 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
2279: ED63 C9                     RET
2280: ED64         ;--------------------------- Get Random Record Position --------------------;
2281: ED64
2282: ED64
2283: ED64
2284: ED64         ;*****************************************************************
2285: ED64         ;********************** Disk  I/O ********************************
2286: ED64         ;*****************************************************************
2287: ED64         ;-----------------------------------------------------------------
2288: ED64         ;-----------------------------------------------------------------
2289: ED64         ;--------------------------- Select  Drive ---------------------------------;
2290: ED64         ; Establish the disk found in (paramE) as the current disk drive            ;
2291: ED64             SelectCurrent:                      ;
2292: ED64 3A C2 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
2293: ED67 21 12 F5               LD     HL,currentDisk       ; Get the current disk              ;
2294: ED6A BE                     CP     M                    ; Are the the same ?                ;
2295: ED6B C8                     RET    Z                    ; Exit if yes, nothing to do        ;
2296: ED6C 77                     LD     (HL),A               ;  else update curretDisk and       ;
2297: ED6D C3 70 ED               JP     Select               ;  select it                        ;
2298: ED70         ;--------------------------- Select  Drive ---------------------------------;
2299: ED70         ;--------------------------- Select Login Drive ----------------------------;
2300: ED70         ; select Login Drive                                                       ;
2301: ED70             Select:                         ;
2302: ED70 CD 91 ED               CALL   SelectDisk           ; Select the Disk                   ;
2303: ED73 CC 81 F4               CALL   Z,errSelect          ;
2304: ED76 21 12 F5               LD     HL,currentDisk       ;
2305: ED79 46                     LD     B,(HL)               ; Get Current Disk                  ;
2306: ED7A 2A 16 F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
2307: ED7D CD 53 F4               CALL   IsBitSet             ;
2308: ED80 C0                     RET    NZ                   ; Exit if already logged in         ;
2309: ED81         ;                                                                           ;
2310: ED81 21 12 F5               LD     HL,currentDisk       ;
2311: ED84 46                     LD     B,(HL)               ; Get Current Disk                  ;
2312: ED85 2A 16 F5               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
2313: ED88 CD 63 F4               CALL   SetVectorBit         ;
2314: ED8B 22 16 F5               LD     (loggedDisks),HL     ; Update the Vector                 ;
2315: ED8E         ;
2316: ED8E C3 D7 ED               JP     InitDisk             ;
2317: ED91         ;--------------------------- Select Login Drive ----------------------------;
2318: ED91         ;--------------------------- Select Disk ------------------------------------;
2319: ED91         ;*****************************************************************          ;
2320: ED91         ; select the disk drive given by currentDisk, and fill the base addresses   ;
2321: ED91         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
2322: ED91             SelectDisk:                      ;
2323: ED91 3A 12 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
2324: ED94 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
2325: ED95 CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
2326: ED98 7C                     LD     A,H                  ; Return Pointer to                  ;
2327: ED99 B5                     OR     L                    ;  Disk Parameter Header             ;
2328: ED9A C8                     RET    Z                    ; exit if error, with HL = 0000      ;
2329: ED9B         ;
2330: ED9B 5E                     LD     E,(HL)               ;
2331: ED9C 23                     INC    HL                   ;
2332: ED9D 56                     LD     D,(HL)               ; Skew Table in DE                   ;
2333: ED9E 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
2334: ED9F ED 53 38 F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
2335: EDA3         ;
2336: EDA3 22 1A F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
2337: EDA6 23                     INC    HL                   ;
2338: EDA7 23                     INC    HL                   ; HL = Last Track #                  ;
2339: EDA8 22 1C F5               LD     (caTrack),HL         ; Move to Current Track #            ;
2340: EDAB 23                     INC    HL                   ;
2341: EDAC 23                     INC    HL                   ; HL = Last Sector #                 ;
2342: EDAD 22 1E F5               LD     (caSector),HL        ; Move to Current Sector #           ;
2343: EDB0 23                     INC    HL                   ;
2344: EDB1 23                     INC    HL                   ;
2345: EDB2 11 20 F5               LD     DE,caDirectoryDMA    ;
2346: EDB5 01 08 00               LD     BC,caListSize        ;
2347: EDB8 ED B0                  LDIR                        ;
2348: EDBA         ;
2349: EDBA         ; finish filling in address list                                             ;
2350: EDBA 2A 22 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
2351: EDBD 11 28 F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
2352: EDC0 01 0F 00               LD     BC,dpbSize           ;
2353: EDC3 ED B0                  LDIR                        ; Move DPB to current                ;
2354: EDC5         ;
2355: EDC5         ; Determine if Byte or Word Allocation Table	                             ;
2356: EDC5 2A 2D F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
2357: EDC8 7C                     LD     A,H                  ; If  its 00 then < 255              ;
2358: EDC9 21 41 F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
2359: EDCC 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
2360: EDCE B7                     OR     A                    ;  is the assumption confirmed ?     ;
2361: EDCF 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
2362: EDD1 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
2363: EDD3         ;
2364: EDD3         ; Set Sign, reset Carry and Zero to indicate success                         ;
2365: EDD3             SelectDisk1:                      ;
2366: EDD3 3E FF                  LD     A,TRUE               ;
2367: EDD5 B7                     OR     A                    ;
2368: EDD6 C9                     RET                         ;
2369: EDD7         ;--------------------------- Select Disk ------------------------------------;
2370: EDD7         ;--------------------------- Initialize Disk --------------------------------;
2371: EDD7             InitDisk:                       ;
2372: EDD7 2A 2D F5               LD     HL,(dpbDSM)          ; Maximum allocation value           ;
2373: EDDA CD 59 F3               CALL   DivideHLby8          ; Length of Map                      ;
2374: EDDD E5                     PUSH   HL                   ; Save Length                        ;
2375: EDDE E5                     PUSH   HL                   ; Save for end of MAP                ;
2376: EDDF C1                     POP    BC                   ; BC = dpbDSM/8                      ;
2377: EDE0         ; Clear the Allocation Vector	                                             ;
2378: EDE0 2A 26 F5               LD     HL,(caAllocVector)   ; Allocation vector Start            ;
2379: EDE3 36 00                  LD     (HL),0               ; Clear location                     ;
2380: EDE5 ED 5B 26 F5               LD     DE,(caAllocVector)   ;
2381: EDE9 13                     INC    DE                   ; Allocation vector Start + 1        ;
2382: EDEA ED B0                  LDIR                        ; Cascade 00 thru Map                ;
2383: EDEC         ; Force bits at End of Map                                                   ;
2384: EDEC EB                     EX     DE,HL                ; Put last Map byte into DE          ;
2385: EDED E1                     POP    HL                   ;
2386: EDEE 23                     INC    HL                   ;
2387: EDEF CD 63 F3               CALL   MultiplyHLby8        ; Blocks if all bits used            ;
2388: EDF2 ED 4B 2D F5               LD     BC,(dpbDSM)          ; Actual block max                   ;
2389: EDF6 03                     INC    BC                   ; Now has size of the Map            ;
2390: EDF7 AF                     XOR    A                    ; Clear CY                           ;
2391: EDF8 ED 42                  SBC    HL,BC                ; Extra unused bits                  ;
2392: EDFA BD                     CP     L                    ;  are there any                     ;
2393: EDFB 28 07                  JR     Z,Mark4Directory     ;
2394: EDFD 45                     LD     B,L                  ; Number of bits to set              ;
2395: EDFE EB                     EX     DE,HL                ; Put last Map byte into HL          ;
2396: EDFF             SetBitLoop:                      ;
2397: EDFF 37                     SCF                         ;
2398: EE00 CB 16                  RL     (HL)                 ; Set LSB                            ;
2399: EE02 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                 ;
2400: EE04         ;
2401: EE04             Mark4Directory:                      ;
2402: EE04         ; Mark the reserved space for the directory                                  ;
2403: EE04 2A 31 F5               LD     HL,(dpbDABM)         ; Directory block reserved bits      ;
2404: EE07 EB                     EX     DE,HL                ;
2405: EE08 2A 26 F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector      ;
2406: EE0B 73                     LD     (HL),E               ;
2407: EE0C 23                     INC    HL                   ;
2408: EE0D 72                     LD     (HL),D               ; Put reserved blocks in Vector      ;
2409: EE0E         ; end of Map                                                                 ;
2410: EE0E         ; Home disk, and set current track and sector to 00                          ;
2411: EE0E CD 5E EF               CALL   Home                 ;
2412: EE11 2A 1A F5               LD     HL,(caDirMaxValue)   ;
2413: EE14 36 03                  LD     (HL),3               ;
2414: EE16 23                     INC    HL                   ;
2415: EE17 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003       ;
2416: EE19 CD 8C F1               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)           ;
2417: EE1C         ;
2418: EE1C             InitDisk1:                      ;
2419: EE1C         ; Process the directory                                                      ;
2420: EE1C 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	     ;
2421: EE1E CD 8A F3               CALL   ReadDirectory        ; Get the directory Record           ;
2422: EE21 CD 93 F1               CALL   AtEndOfDirectory     ; Are we Done ?                      ;
2423: EE24 C8                     RET    Z                    ;  Exit if Yes                       ;
2424: EE25         ; Not end of directory, valid entry?                                         ;
2425: EE25 CD 9C F1               CALL   GetCurrentDirectoryRecord ; Calculate location of the element  ;
2426: EE28 3E E5                  LD     A,emptyDir           ;
2427: EE2A BE                     CP     M                    ; Is it an Empty Dir Entry           ;
2428: EE2B 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                 ;
2429: EE2D         ; Not emptyDir, user code the same?                                          ;
2430: EE2D 3A 11 F5               LD     A,(currentUserNumber) ;
2431: EE30 BE                     CP     M                    ;
2432: EE31 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users   ;
2433: EE33         ; Same user, check for '$' submit                                            ;
2434: EE33 23                     INC    HL                   ;
2435: EE34 7E                     LD     A,(HL)               ;
2436: EE35 D6 24                  SUB    DOLLAR               ; Is first Char a $                  ;
2437: EE37 20 04                  JR     NZ,InitDisk2         ;
2438: EE39         ; dollar file found, mark in exitParameterByte                               ;
2439: EE39 3D                     DEC    A                    ; Set A to FFH                       ;
2440: EE3A 32 C5 EA               LD     (exitParameterByte),A ; Return it the exit parameter       ;
2441: EE3D             InitDisk2:                      ;
2442: EE3D         ; now scan the disk map for allocated blocks                                 ;
2443: EE3D 0E FF                  LD     C,TRUE               ; set to allocated                   ;
2444: EE3F CD C0 F1               CALL   ScanDiskMap          ;
2445: EE42 CD AA F1               CALL   SetDirectoryEntry    ; Mark directory entry               ;
2446: EE45 18 D5                  JR     InitDisk1            ; Loop for another entry             ;
2447: EE47         ;--------------------------- Initialize Disk --------------------------------;
2448: EE47         ;----------------------------- Open File -----------------------------------;
2449: EE47         ;search for the directory entry matching FCB at paramDE						;
2450: EE47             OpenFile:                       ;
2451: EE47 0E 0F                  LD     C,nameLength         ;
2452: EE49 CD 5C F0               CALL   SearchForDirectoryRecord ;
2453: EE4C CD 93 F1               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
2454: EE4F C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
2455: EE50         ;
2456: EE50             CopyDirRecordToFCB:                      ;
2457: EE50 CD 02 F0               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
2458: EE53 7E                     LD     A,(HL)               ; Get the EXT                      	;
2459: EE54 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
2460: EE55 E5                     PUSH   HL                   ;  also save FCB's pointer         	;
2461: EE56 CD 9C F1               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
2462: EE59 E5                     PUSH   HL                   ; Save Directory Record address    	;
2463: EE5A         ;
2464: EE5A ED 5B C3 EA               LD     DE,(paramDE)         ;
2465: EE5E 01 20 00               LD     BC,fcbLength         ;
2466: EE61 ED B0                  LDIR                        ; Move dir record to FCB           	;
2467: EE63         ;
2468: EE63         ; note that entire fcb is copied, including indicators                    	;
2469: EE63 CD 3F F0               CALL   SetFileWriteFlag     ; Set clean file flag				;
2470: EE66 D1                     POP    DE                   ; Get Directory Record address     	;
2471: EE67 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
2472: EE6A 19                     ADD    HL,DE                ; Directory's EXT address          	;
2473: EE6B 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
2474: EE6C 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
2475: EE6F 19                     ADD    HL,DE                ; Directory's RC address           	;
2476: EE70 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
2477: EE71 E1                     POP    HL                   ; Get FCB's Extent Address         	;
2478: EE72 F1                     POP    AF                   ; Get FCB's Extent Value           	;
2479: EE73 77                     LD     (HL),A               ; Restore Extent Value             	;
2480: EE74         ; if user ext < dir ext then user := 128 records                           	;
2481: EE74         ; if user ext = dir ext then user := dir records                           	;
2482: EE74         ; if user ext > dir ext then user := 0 records                             	;
2483: EE74 79                     LD     A,C                  ; Get the Dir's EXT                	;
2484: EE75 BE                     CP     M                    ; Does it match the FCB'd          	;
2485: EE76 78                     LD     A,B                  ; Get the Dir's  record count      	;
2486: EE77 CA 81 EE               JP     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
2487: EE7A 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
2488: EE7C DA 81 EE               JP     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
2489: EE7F 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
2490: EE81             OpenSetRecordCount:                      ;
2491: EE81 2A C3 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
2492: EE84 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
2493: EE87 19                     ADD    HL,DE                ; FCB's record count               	;
2494: EE88 77                     LD     (HL),A               ; Set the value                    	;
2495: EE89 C9                     RET                         ;
2496: EE8A         ;----------------------------- Open File -----------------------------------;
2497: EE8A         ;---------------------------- Close Directory Entry ------------------------;
2498: EE8A             CloseDirEntry:                      ;
2499: EE8A AF                     XOR    A                    ;
2500: EE8B 32 C5 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
2501: EE8E CD A6 EF               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
2502: EE91 C0                     RET    NZ                   ; Skip close if r/o disk            ;
2503: EE92         ; check file write flag - 0 indicates written                               ;
2504: EE92 CD 36 F0               CALL   GetWriteFileFlagValue ; Get file's WriteFileFlag          ;
2505: EE95 CB 7F                  BIT    7,A                  ;  Has it changed ?					;
2506: EE97         ;	AND		writeFlagMask				; Apply the RO Flag for S2          ;
2507: EE97 C0                     RET    NZ                   ; Skip close if clean file          ;
2508: EE98         ;
2509: EE98 0E 0F                  LD     C,nameLength         ;
2510: EE9A CD 5C F0               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
2511: EE9D CD 93 F1               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
2512: EEA0 C8                     RET    Z                    ;  exit if at EOD                   ;
2513: EEA1         ;
2514: EEA1         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
2515: EEA1 CD 9C F1               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
2516: EEA4 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
2517: EEA7 09                     ADD    HL,BC                ;
2518: EEA8 EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
2519: EEA9 2A C3 EA               LD     HL,(paramDE)         ;
2520: EEAC 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
2521: EEAD 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
2522: EEAF         ;
2523: EEAF             MergeAllocationMaps:                      ;
2524: EEAF 3A 41 F5               LD     A,(byteAllocationFlag) ;
2525: EEB2 B7                     OR     A                    ;
2526: EEB3 CA CA EE               JP     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2527: EEB6         ; process byte size Map	                                                    ;
2528: EEB6 7E                     LD     A,(HL)               ; FCB Block number                  ;
2529: EEB7 B7                     OR     A                    ; Is it 0 ?                         ;
2530: EEB8 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2531: EEB9 C2 BD EE               JP     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2532: EEBC 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2533: EEBD             MergeFCBisNot0:                      ;
2534: EEBD B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2535: EEBE C2 C3 EE               JP     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2536: EEC1 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2537: EEC2 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2538: EEC3             MergeDirEntryNot0:                      ;
2539: EEC3 BE                     CP     M                    ; Do FCB and Dir match values       ;
2540: EEC4 C2 05 EF               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2541: EEC7 C3 DF EE               JP     MergeMapLoop         ; Go see if there is more           ;
2542: EECA         ;
2543: EECA             MergeWordMaps:                      ;
2544: EECA CD 6D F3               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2545: EECD EB                     EX     DE,HL                ;
2546: EECE CD 6D F3               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2547: EED1 EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2548: EED2 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2549: EED3 BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2550: EED4 C2 05 EF               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2551: EED7 13                     INC    DE                   ;
2552: EED8 23                     INC    HL                   ; move on to the MSB                ;
2553: EED9 1A                     LD     A,(DE)               ;
2554: EEDA BE                     CP     M                    ; do the check for equality         ;
2555: EEDB C2 05 EF               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2556: EEDE 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2557: EEDF             MergeMapLoop:                      ;
2558: EEDF 13                     INC    DE                   ; Advance to the next positions     ;
2559: EEE0 23                     INC    HL                   ; in The Maps                       ;
2560: EEE1 0D                     DEC    C                    ; Are we done ?                     ;
2561: EEE2 C2 AF EE               JP     NZ,MergeAllocationMaps ;  No, do it again                  ;
2562: EEE5         ;
2563: EEE5         ; Check the EXT                                                             ;
2564: EEE5 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2565: EEE8 09                     ADD    HL,BC                ;
2566: EEE9 EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2567: EEEA 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2568: EEEB 1A                     LD     A,(DE)               ; FCB's extent number               ;
2569: EEEC BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2570: EEED DA F9 EE               JP     C,CloseDirEntryEnd   ;  we are done if yes               ;
2571: EEF0 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2572: EEF1         ; Update directory record count field                                       ;
2573: EEF1 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2574: EEF4 09                     ADD    HL,BC                ;
2575: EEF5 EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2576: EEF6 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2577: EEF7 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2578: EEF8 12                     LD     (DE),A               ;  the Directory Record RC          ;
2579: EEF9         ;
2580: EEF9             CloseDirEntryEnd:                      ;
2581: EEF9 3E FF                  LD     A,TRUE               ;
2582: EEFB 32 3A F5               LD     (fcbCopiedFlag),A    ; Set copied flag as true           ;
2583: EEFE         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2584: EEFE CD B8 F3               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2585: EF01 C3 D9 F0               JP     WriteDir             ; Write the directory element       ;
2586: EF04 C9                     RET                         ;
2587: EF05         ;
2588: EF05             CloseDirEntryError:                      ;
2589: EF05 21 C5 EA               LD     HL,exitParameterByte ;
2590: EF08 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2591: EF09 C9                     RET                         ;
2592: EF0A         ;---------------------------- Close Directory Entry ------------------------;
2593: EF0A         ;----------------------------------- Make new File -------------------------;
2594: EF0A         ;create a new file by creating a directory entry then opening the file      ;
2595: EF0A             MakeNewFile:                      ;
2596: EF0A CD 76 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O  ;
2597: EF0D 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB                       ;
2598: EF10 E5                     PUSH   HL                   ; FCB                               ;
2599: EF11 21 13 F5               LD     HL,emptyFCB          ;
2600: EF14 22 C3 EA               LD     (paramDE),HL         ; Find the first empty dir record   ;
2601: EF17 0E 01                  LD     C,1                  ;
2602: EF19 CD 5C F0               CALL   SearchForDirectoryRecord ; 0F5H in first position            ;
2603: EF1C CD 93 F1               CALL   AtEndOfDirectory     ; Check if at end of directory      ;
2604: EF1F E1                     POP    HL                   ; Recall the FCB pointer            ;
2605: EF20 22 C3 EA               LD     (paramDE),HL         ;  in case we return here           ;
2606: EF23 C8                     RET    Z                    ; Exit with No Dir space error      ;
2607: EF24         ; fill Allocation Map with Zeros	                                        ;
2608: EF24 11 0F 00               LD     DE,nameLength        ;
2609: EF27 19                     ADD    HL,DE                ; Start of fill                     ;
2610: EF28 36 00                  LD     (HL),00              ; Prime the values                  ;
2611: EF2A E5                     PUSH   HL                   ;
2612: EF2B D1                     POP    DE                   ; Copy to DE                        ;
2613: EF2C 13                     INC    DE                   ; adjust the to pointer             ;
2614: EF2D 01 10 00               LD     BC,fcbLength-nameLength-1 ; number of bytes to fill           ;
2615: EF30 ED B0                  LDIR                        ;
2616: EF32         ;
2617: EF32 2A C3 EA               LD     HL,(paramDE)         ; get FCB                           ;
2618: EF35 11 0D 00               LD     DE,fcbS1Index        ; Get the S1 index                  ;
2619: EF38 19                     ADD    HL,DE                ; Point to S1                       ;
2620: EF39 36 00                  LD     (HL),0               ; Set to 0                          ;
2621: EF3B CD AA F1               CALL   SetDirectoryEntry    ; Update directory entry            ;
2622: EF3E CD 8A F2               CALL   CopyFCB              ; Update dir entry to Disk          ;
2623: EF41         ; and set the file write flag to "1"                                        ;
2624: EF41 C3 3F F0               JP     SetFileWriteFlag     ; Set the clean entry flag          ;
2625: EF44         ;----------------------------------- Make new File -------------------------;
2626: EF44
2627: EF44         ; DIO
2628: EF44
2629: EF44         ;---------------
2630: EF44         ; set a "1" value in currentDisk position of BC
2631: EF44         ; return in HL
2632: EF44             SetCurrentDiskBit:
2633: EF44 C5                     PUSH   BC                   ; save input parameter
2634: EF45 3A 12 F5               LD     A,(currentDisk)
2635: EF48 4F                     LD     C,A                  ; ready parameter for shift
2636: EF49 21 01 00               LD     HL,1                 ; number to shift
2637: EF4C CD 4C F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
2638: EF4F C1                     POP    BC                   ; original mask
2639: EF50 79                     LD     A,C
2640: EF51 B5                     OR     L
2641: EF52 6F                     LD     L,A
2642: EF53 78                     LD     A,B
2643: EF54 B4                     OR     H
2644: EF55 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
2645: EF56 C9                     RET
2646: EF57         ;--------------
2647: EF57
2648: EF57         ;--------------------------- Scan      Map ----------------------------------;
2649: EF57         ;-----------------------------------
2650: EF57         ; byte value from ALLOC is in register A, with shift count
2651: EF57         ; in register C (to place bit back into position), and
2652: EF57         ; target ALLOC position in registers HL, rotate and replace
2653: EF57             RotateAndReplace:
2654: EF57 0F                     RRCA
2655: EF58 15                     DEC    D
2656: EF59 C2 57 EF               JP     NZ,RotateAndReplace  ; back into position
2657: EF5C 77                     LD     (HL),A               ; back to ALLOC
2658: EF5D C9                     RET
2659: EF5E         ;-----------------------------------
2660: EF5E
2661: EF5E         ;*****************************************************************
2662: EF5E
2663: EF5E         ;*****************************************************************
2664: EF5E         ;=========================== Disk Utilities ================================;
2665: EF5E         ;--------------------------- Home The Current Disk ------------------------;
2666: EF5E         ;move to home position, then offset to start of dir                        ;
2667: EF5E             Home:                           ;
2668: EF5E CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks      ;
2669: EF61         ; if Buffer needs to be written    ;
2670: EF61 21 35 F5               LD     HL,dpbOFF            ; Number of tracks before directory;
2671: EF64 4E                     LD     C,(HL)               ;
2672: EF65 23                     INC    HL                   ;
2673: EF66 46                     LD     B,(HL)               ;
2674: EF67 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position  ;
2675: EF6A         ;
2676: EF6A         ; Set Current Track and Sector to 00                                       ;
2677: EF6A AF                     XOR    A                    ; set ACC to 00                    ;
2678: EF6B 2A 1C F5               LD     HL,(caTrack)         ;
2679: EF6E 77                     LD     (HL),A               ;
2680: EF6F 23                     INC    HL                   ;
2681: EF70 77                     LD     (HL),A               ;
2682: EF71 2A 1E F5               LD     HL,(caSector)        ;
2683: EF74 77                     LD     (HL),A               ;
2684: EF75 23                     INC    HL                   ;
2685: EF76 77                     LD     (HL),A               ;
2686: EF77 C9                     RET                         ;
2687: EF78         ;
2688: EF78         ;--------------------------- Home The Current Disk ------------------------;
2689: EF78         ;--------------------------- Set DMAs -------------------------------------;
2690: EF78             SetDataDMA:                      ;
2691: EF78 21 18 F5               LD     HL,initDAMAddress    ;
2692: EF7B 18 03                  JR     SetDMA               ; Skip to complete the call        ;
2693: EF7D         ;	LD		BC,initDAMAddress                                              ;
2694: EF7D         ;	JP		bcSetdma					; Call BIOS to set                 ;
2695: EF7D         ;
2696: EF7D             SetDirDMA:                      ;
2697: EF7D 21 20 F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
2698: EF80         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
2699: EF80         ;	JP		bcSetdma					; Call BIOS to set                 ;
2700: EF80         ;
2701: EF80             SetDMA:                         ;
2702: EF80 4E                     LD     C,(HL)               ;
2703: EF81 23                     INC    HL                   ;
2704: EF82 46                     LD     B,(HL)               ; parameter ready              ;
2705: EF83 C3 24 F6               JP     bcSetdma             ; call bios to set             ;
2706: EF86         ;--------------------------- Set DMAs -------------------------------------;
2707: EF86         ;--------------------------- Read Buffer ----------------------------------;
2708: EF86         ;reads into current DMA, using current Disk,Track and Sector               ;
2709: EF86             ReadBuffer:                      ;
2710: EF86 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
2711: EF89 B7                     OR     A                    ; Check status                     ;
2712: EF8A C2 A6 F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2713: EF8D C9                     RET                         ;
2714: EF8E         ;--------------------------- Read Buffer ----------------------------------;
2715: EF8E         ;--------------------------- Set Current Disk Read Only --------------------;
2716: EF8E         ;set current disk to read only                                              ;
2717: EF8E             SetDiskReadOnly:                      ;
2718: EF8E 2A 14 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2719: EF91         ;
2720: EF91 3A 12 F5               LD     A,(currentDisk)      ; Get the current disk              ;
2721: EF94 47                     LD     B,A                  ; Move into B                       ;
2722: EF95 CD 63 F4               CALL   SetVectorBit         ; Set the bit	                    ;
2723: EF98 22 14 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2724: EF9B         ;
2725: EF9B 2A 2F F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2726: EF9E EB                     EX     DE,HL                ;
2727: EF9F 2A 1A F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2728: EFA2 73                     LD     (HL),E               ;
2729: EFA3 23                     INC    HL                   ;
2730: EFA4 72                     LD     (HL),D               ;
2731: EFA5 C9                     RET                         ;
2732: EFA6         ;--------------------------- Set disk Read Only ----------------------------;
2733: EFA6         ;--------------------------- Is Disk Write Protected -----------------------;
2734: EFA6         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2735: EFA6         ;					= reset if Write Protected		(NZ)					;
2736: EFA6             IsDiskWriteProtected:                      ;
2737: EFA6 2A 14 F5               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2738: EFA9 3A 12 F5               LD     A,(currentDisk)      ; Get current disk                  ;
2739: EFAC 47                     LD     B,A                  ;
2740: EFAD CD 53 F4               CALL   IsBitSet             ; Check the bit                     ;
2741: EFB0 C9                     RET                         ; NZ if Disk is RO                  ;
2742: EFB1         ;--------------------------- Is Disk Write Protected -----------------------;
2743: EFB1
2744: EFB1         ;------------------------- Reselect Disk if Necessary ----------------------;
2745: EFB1         ;check current fcb to see if reselection necessary                         ;
2746: EFB1             ReselectDisk:                      ;
2747: EFB1 3E FF                  LD     A,TRUE               ;
2748: EFB3 32 42 F5               LD     (fResel),A           ; Mark as possible reselect         ;
2749: EFB6 2A C3 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2750: EFB9 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2751: EFBA E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2752: EFBC 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2753: EFBD 32 C2 EA               LD     (paramE),A           ; Save drive code                   ;
2754: EFC0 FE 1E                  CP     30                   ;
2755: EFC2 D2 D5 EF               JP     NC,NoSelect          ; Skip drive >= 30                  ;
2756: EFC5         ;
2757: EFC5 3A 12 F5               LD     A,(currentDisk)      ; Determine the current drive       ;
2758: EFC8 32 43 F5               LD     (entryDisk),A        ; Save it                           ;
2759: EFCB 7E                     LD     A,(HL)               ;
2760: EFCC 32 44 F5               LD     (fcbDisk),A          ; Get calling disk                  ;
2761: EFCF E6 E0                  AND    11100000B            ;
2762: EFD1 77                     LD     (HL),A               ; Preserve User Number              ;
2763: EFD2 CD 64 ED               CALL   SelectCurrent        ; Select the new disk               ;
2764: EFD5         ;
2765: EFD5             NoSelect:                       ;
2766: EFD5 3A 11 F5               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2767: EFD8 2A C3 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2768: EFDB B6                     OR     M                    ; Combine                           ;
2769: EFDC 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2770: EFDD C9                     RET                         ;
2771: EFDE         ;------------------------- Reselect Disk if Necessary ----------------------;
2772: EFDE
2773: EFDE
2774: EFDE         ;=========================== Disk Utilities ================================;
2775: EFDE
2776: EFDE         ;=========================== File Utilities ================================;
2777: EFDE         ;--------------------------- Set Record Variables -------------------------;
2778: EFDE         ;set variables from currently FCB - Current Record, RC, EXM                ;
2779: EFDE             SetRecordVars:                      ;
2780: EFDE CD F5 EF               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2781: EFE1         ;  and HL => .CurrentRecord        ;
2782: EFE1 7E                     LD     A,(HL)               ;
2783: EFE2 32 47 F5               LD     (currentFileRecord),A ; Save current record              ;
2784: EFE5 EB                     EX     DE,HL                ;
2785: EFE6 7E                     LD     A,(HL)               ;
2786: EFE7 32 45 F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2787: EFEA CD 02 F0               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2788: EFED 3A 2C F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2789: EFF0 A6                     AND    M                    ; Remove unwanted bits             ;
2790: EFF1 32 46 F5               LD     (extentValue),A      ; Store the value                  ;
2791: EFF4 C9                     RET                         ;
2792: EFF5         ;--------------------------- Set Record Variables -------------------------;
2793: EFF5         ;----------------------Get File Record Count and Current Record------------;
2794: EFF5         ; returns with DE pointing at RC from FCB                                  ;
2795: EFF5         ;         with HL pointing at Current Record                               ;
2796: EFF5             GetFcbRecordDetails:                      ;
2797: EFF5 2A C3 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2798: EFF8 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2799: EFFB 19                     ADD    HL,DE                ;
2800: EFFC EB                     EX     DE,HL                ; DE Points to Record Count        ;
2801: EFFD 21 11 00               LD     HL,recordSeq-fcbRCIndex ;
2802: F000 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2803: F001 C9                     RET                         ;
2804: F002         ;----------------------Get File Record Count and Current Record------------;
2805: F002         ;----------------------Get FileExtent--------------------------------------;
2806: F002         ;get current extent field address to (HL)                                 ;
2807: F002             GetExtentAddress:                      ;
2808: F002 2A C3 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2809: F005 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2810: F008 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2811: F009 C9                     RET                         ;
2812: F00A         ;----------------------Get FileExtent--------------------------------------;
2813: F00A         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2814: F00A         ; At Entry:	BC Contains to the Block to be modified                        ;
2815: F00A         ;			E  = TRUE if bit is to be set                                  ;
2816: F00A         ;			E  <> TRUE if bit is to be reset                               ;
2817: F00A         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2818: F00A             SetResetMapBit:                      ;
2819: F00A         ;
2820: F00A 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2821: F00D 09                     ADD    HL,BC                ;  to HL                           ;
2822: F00E 4B                     LD     C,E                  ; Move the flag to E               ;
2823: F00F         ;
2824: F00F 7D                     LD     A,L                  ; LSB of the Block Number          ;
2825: F010 E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2826: F012 F5                     PUSH   AF                   ; Save the OctetBit                ;
2827: F013 06 03                  LD     B,3                  ;
2828: F015 CD 5B F3               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2829: F018 ED 5B 26 F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2830: F01C 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2831: F01D F1                     POP    AF                   ;
2832: F01E 47                     LD     B,A                  ; Get the bit                      ;
2833: F01F         ;
2834: F01F 04                     INC    B                    ; Adjust for looping               ;
2835: F020 C5                     PUSH   BC                   ; Will need this later             ;
2836: F021             Left:                           ;
2837: F021 CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2838: F023 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2839: F025 C1                     POP    BC                   ; Restore loop limit and           ;
2840: F026 37                     SCF                         ;  set/reset flag                  ;
2841: F027 0C                     INC    C                    ; was C = TRUE                     ;
2842: F028 28 01                  JR     Z,Right              ; Skip if Set                      ;
2843: F02A 3F                     CCF                         ; Set for Reset                    ;
2844: F02B             Right:                          ;
2845: F02B CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2846: F02D 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2847: F02F C9                     RET                         ;
2848: F030         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2849: F030         ;--------------------- Initialize Extent Number MSB -----------------------;
2850: F030         ;clear the Extent number field for user open/make (S2)                    ;
2851: F030             InitializeExtentNumberMSB:                      ;
2852: F030 CD 36 F0               CALL   GetExtentNumberMSB   ;
2853: F033 36 00                  LD     (HL),0               ; Set it to = 0            ;
2854: F035 C9                     RET                         ;
2855: F036         ;--------------------- Initialize Extent Number MSB -----------------------;
2856: F036         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2857: F036         ; Get S2 value                                                             ;
2858: F036         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
2859: F036         ;			HL = Address of S2 for the FCB pointed to by paramDE           ;
2860: F036             GetWriteFileFlagValue:                      ; S2 bit 7                 ;
2861: F036             GetExtentNumberMSB:                      ; S2 bits 0-6              ;
2862: F036 2A C3 EA               LD     HL,(paramDE)         ; FCB address              ;
2863: F039 11 0E 00               LD     DE,fcbS2Index        ; Index to value           ;
2864: F03C 19                     ADD    HL,DE                ; Address of value         ;
2865: F03D 7E                     LD     A,(HL)               ; load into ACC            ;
2866: F03E C9                     RET                         ;
2867: F03F         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2868: F03F         ;--------------------------- Set File Write Flag----------------------------;
2869: F03F         ;Set file write flag in FCB in (paramDE)									;
2870: F03F         ; Used to indicate the FCB is clean. No need to write on close				;
2871: F03F             SetFileWriteFlag:                      ;
2872: F03F CD 36 F0               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2873: F042 CB FE                  SET    7,(HL)               ; Set the FileWriteFlag				;
2874: F044 C9                     RET                         ;
2875: F045         ;?	OR		writeFlagMask				; Set the flag , bit 7 of S2        ;
2876: F045         ;?	LD		(HL),A						; Put into FCB                      ;
2877: F045         ;?	RET	                                                                    ;
2878: F045         ;--------------------------- Set File Write Flag----------------------------;
2879: F045         ;--------------------------- Reset File Write Flag--------------------------;
2880: F045         ;Reset file write flag in FCB in (paramDE)									;
2881: F045         ; Used to indicate the FCB is dirty. Need to write on close					;
2882: F045             ResetFileWriteFlag:                      ;
2883: F045 CD 36 F0               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2884: F048 CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag			;
2885: F04A C9                     RET                         ;
2886: F04B         ;?	AND		0FFH-writeFlagMask			; Remove the flag bit		        ;
2887: F04B         ;?	LD		(HL),A						; Put into FCB                      ;
2888: F04B         ;?	RET	                                                                    ;
2889: F04B         ;--------------------------- Reset File Write Flag--------------------------;
2890: F04B         ;-------------------------- Compare FCB Extents ----------------------------;
2891: F04B         ; Enters:	A containing Target FCB EXT value								;
2892: F04B         ;			HL Points at Possible FCB EXT value								;
2893: F04B         ;compare extent# in A with that in C, return nonzero if they do not match	;
2894: F04B             CompareExtents:                      ;
2895: F04B C5                     PUSH   BC                   ; Save Callers Registers			;
2896: F04C F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2897: F04D 3A 2C F5               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2898: F050 2F                     CPL                         ; Complement for And           		;
2899: F051 47                     LD     B,A                  ; Put negated Mask into B      		;
2900: F052 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2901: F053 A0                     AND    B                    ; Apply the Mask               		;
2902: F054 4F                     LD     C,A                  ; Low bits removed from C      		;
2903: F055 F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2904: F056 A0                     AND    B                    ; Apply the Mask               		;
2905: F057 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2906: F058 E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2907: F05A C1                     POP    BC                   ; Restore Callers Registers    		;
2908: F05B C9                     RET                         ;
2909: F05C         ;-------------------------- Compare FCB Extents ----------------------------;
2910: F05C         ;---------------------Search for Directory Record --------------------------;
2911: F05C         ;  Search for directory record of length C.									;
2912: F05C         ; Target is pointed to by paramDE. The whole directory is searched.			;
2913: F05C         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2914: F05C         ; matched directory record													;
2915: F05C         ; Entry:	C = Search Length                                               ;
2916: F05C         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2917: F05C         ;								-1 (EOD) if there is no match				;
2918: F05C             SearchForDirectoryRecord:                      ;
2919: F05C 3E FF                  LD     A,0FFH               ;
2920: F05E 32 3C F5               LD     (directoryIndex),A   ; Initialize directory Index        ;
2921: F061 21 3E F5               LD     HL,searchLength      ;
2922: F064 71                     LD     (HL),C               ; Save Search Length                ;
2923: F065 2A C3 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2924: F068 22 3F F5               LD     (searchAddress),HL   ; Start of search                   ;
2925: F06B CD 8C F1               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2926: F06E CD 5E EF               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2927: F071         ;
2928: F071             GetNextDirectoryRecord:                      ;
2929: F071 0E 00                  LD     C,FALSE              ;
2930: F073 CD 8A F3               CALL   ReadDirectory        ; Read next Dir Record              ;
2931: F076 CD 93 F1               CALL   AtEndOfDirectory     ;
2932: F079 CA D0 F0               JP     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2933: F07C         ;
2934: F07C 2A 3F F5               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2935: F07F EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2936: F080 1A                     LD     A,(DE)               ; User Number                       ;
2937: F081 FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2938: F083 CA 8E F0               JP     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2939: F086         ;
2940: F086         ; Check to be sure we are sill in the Directory                             ;
2941: F086 D5                     PUSH   DE                   ; Save search address               ;
2942: F087 CD B3 F1               CALL   StillInDirectory     ; Still in the directorY            ;
2943: F08A D1                     POP    DE                   ; Recall address                    ;
2944: F08B D2 D0 F0               JP     NC,NoDirRecordsMatch ; Get out if past directory			;
2945: F08E         ;
2946: F08E             GetNextDirectoryRecord1:                      ;
2947: F08E CD 9C F1               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2948: F091 3A 3E F5               LD     A,(searchLength)     ;
2949: F094 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2950: F095 06 00                  LD     B,0                  ; Character Index (up)              ;
2951: F097         ;
2952: F097             TestNextPosition:                      ;
2953: F097 1A                     LD     A,(DE)               ;
2954: F098 FE 3F                  CP     QMARK                ; ? is always a char match          ;
2955: F09A CA B8 F0               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2956: F09D         ;
2957: F09D 78                     LD     A,B                  ;
2958: F09E FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2959: F0A0 CA B8 F0               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2960: F0A3         ; not the fcbS1Index field, extent field?                                  ;
2961: F0A3 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2962: F0A5 1A                     LD     A,(DE)               ; Get next character                ;
2963: F0A6 CA B2 F0               JP     Z,CheckExtents       ; Skip to search extent             ;
2964: F0A9 96                     SUB    M                    ; Do they match ?                   ;
2965: F0AA E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2966: F0AC C2 71 F0               JP     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2967: F0AF C3 B8 F0               JP     SetNextPosition      ; Matched the character             ;
2968: F0B2         ;                                                                           ;
2969: F0B2             CheckExtents:                      ;
2970: F0B2 CD 4B F0               CALL   CompareExtents       ; Matching EXTs is work             ;
2971: F0B5 C2 71 F0               JP     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2972: F0B8         ;
2973: F0B8             SetNextPosition:                      ;
2974: F0B8 13                     INC    DE                   ; Pointer to Looking FOR            ;
2975: F0B9 23                     INC    HL                   ; Pointer to Looking IN             ;
2976: F0BA 04                     INC    B                    ; Character Index in FCB            ;
2977: F0BB 0D                     DEC    C                    ; Length of search                  ;
2978: F0BC C2 97 F0               JP     NZ,TestNextPosition  ;
2979: F0BF         ; Match Found, entire name matches                                          ;
2980: F0BF 3A 4C F5               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2981: F0C2 E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2982: F0C4 32 C5 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2983: F0C7         ;
2984: F0C7 21 3C F5               LD     HL,directoryIndex    ; Point at Directory Flag           ;
2985: F0CA 7E                     LD     A,(HL)               ; Get value                         ;
2986: F0CB 17                     RLA                         ; Set Carry if Flag = -1            ;
2987: F0CC D0                     RET    NC                   ; Return with flag still -1         ;
2988: F0CD         ;
2989: F0CD AF                     XOR    A                    ; Else Clear the flag               ;
2990: F0CE 77                     LD     (HL),A               ;
2991: F0CF C9                     RET                         ;  and exit                         ;
2992: F0D0         ;------                                                                     ;
2993: F0D0             NoDirRecordsMatch:                      ;
2994: F0D0 CD 8C F1               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2995: F0D3 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2996: F0D5 32 C5 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2997: F0D8 C9                     RET                         ;
2998: F0D9         ;---------------------Search for Directory Record --------------------------;
2999: F0D9         ;---------------------------- Write Current Directory Entry ----------------;
3000: F0D9             WriteDir:                       ;
3001: F0D9         ;	CALL	NewCheckSum						; initialize entry              ;
3002: F0D9 0E FF                  LD     C,TRUE               ;
3003: F0DB CD 03 F4               CALL   CheckSumUtility      ; Set New CheckSum              ;
3004: F0DE         ;
3005: F0DE CD 7D EF               CALL   SetDirDMA            ; Directory DMA                 ;
3006: F0E1 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
3007: F0E3 CD E9 F0               CALL   WriteBuffer          ; Write the buffer              ;
3008: F0E6 C3 78 EF               JP     SetDataDMA           ; Reset DMA to default			;
3009: F0E9         ;
3010: F0E9         ;---------------------------- Write Current Directory Entry ----------------;
3011: F0E9         ;----------------------------------- Write Buffer --------------------------;
3012: F0E9         ; Write buffer and check result. Current drive,Track, Sector and DMA		;
3013: F0E9         ; Are set up prior to calling this routine                                  ;
3014: F0E9         ;                                                                           ;
3015: F0E9         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
3016: F0E9         ;				1 => directory write operation	WriteDirectory              ;
3017: F0E9         ;				2 => start of new block			WriteCleanBuffer			;
3018: F0E9             WriteBuffer:                      ;
3019: F0E9 CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
3020: F0EC B7                     OR     A                    ; Get return code                   ;
3021: F0ED C2 A6 F4               JP     NZ,erPermanentNoWait ; Error if not 00                   ;
3022: F0F0 C9                     RET                         ;
3023: F0F1         ;----------------------------------- Write Buffer --------------------------;
3024: F0F1         ;---------------------------- Update Record Vars ---------------------------;
3025: F0F1         ;update variables from I/O in  FCB                                          ;
3026: F0F1             UpdateRecordVariables:                      ;
3027: F0F1 CD F5 EF               CALL   GetFcbRecordDetails  ; DE => FCB RC, HL => CurrentRecord ;
3028: F0F4 3A 37 F5               LD     A,(diskAccessType)   ; If Seq IO it is set to 1			;
3029: F0F7 4F                     LD     C,A                  ;  and move it to C                 ;
3030: F0F8 3A 47 F5               LD     A,(currentFileRecord) ; Get NEXT_RECORD                   ;
3031: F0FB 81                     ADD    A,C                  ; Update record count               ;
3032: F0FC 77                     LD     (HL),A               ;  for CurrentRecord                ;
3033: F0FD EB                     EX     DE,HL                ;
3034: F0FE 3A 45 F5               LD     A,(fcbRecordCount)   ;
3035: F101 77                     LD     (HL),A               ;  and FCB RC                       ;
3036: F102 C9                     RET                         ;
3037: F103         ;---------------------------- Update Record Vars ---------------------------;
3038: F103         ;-------------------------------- Random Seek ------------------------------;
3039: F103         ;  Record # = |000M EEEE| |ERRR RRRR|                                       ;
3040: F103         ;		M => Module                                                         ;
3041: F103         ;		E => Extent                                                         ;
3042: F103         ;		R => Record in Extent                                               ;
3043: F103             RandomSeek:                      ;
3044: F103 AF                     XOR    A                    ;
3045: F104 32 37 F5               LD     (diskAccessType),A   ; Set random access                 ;
3046: F107 C5                     PUSH   BC                   ; Save Read(TRUE) / Write (FALSE)   ;
3047: F108 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB                       ;
3048: F10B E5                     PUSH   HL                   ;
3049: F10C DD E1                  POP    IX                   ; IX has the FCB address            ;
3050: F10E DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record        ;
3051: F111 E6 7F                  AND    7FH                  ; Strip E , left with |0RRR RRRR|   ;
3052: F113 F5                     PUSH   AF                   ; recordSEQ                         ;
3053: F114 DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record        ;
3054: F117 17                     RLA                         ; CY = bit 7 from LSB (M's LSBit)   ;
3055: F118 DD 7E 22               LD     A,(IX+recordRandomMSB) ; Get MSB from Random Record        ;
3056: F11B F5                     PUSH   AF                   ; Random record's MSB               ;
3057: F11C 17                     RLA                         ; Shift LSBit into E |00ME EEEE|    ;
3058: F11D E6 1F                  AND    01FH                 ; Extent mask                       ;
3059: F11F 4F                     LD     C,A                  ; Extent is in C                    ;
3060: F120 F1                     POP    AF                   ; Random record's MSB               ;
3061: F121 1F                     RRA                         ;
3062: F122 1F                     RRA                         ;
3063: F123 1F                     RRA                         ;
3064: F124 1F                     RRA                         ; MSB's Hi Nibble                   ;
3065: F125 E6 0F                  AND    00FH                 ;  moved to Lo Nibble               ;
3066: F127 47                     LD     B,A                  ; S2' value in B                    ;
3067: F128 F1                     POP    AF                   ; recordSEQ                         ;
3068: F129         ;
3069: F129 DD 6E 23               LD     L,(IX+recordRandomOVF) ;
3070: F12C 2C                     INC    L                    ; Insure that high byte             ;
3071: F12D 2D                     DEC    L                    ;  of ran rec = 00                  ;
3072: F12E 2E 06                  LD     L,06                 ; "attempt to read beyond end of disk"  ;
3073: F130 C2 84 F1               JP     NZ,RandomSeekError   ;
3074: F133         ;
3075: F133 DD 77 20               LD     (IX+recordSeq),A     ; Put target record # in FCB	    ;
3076: F136 DD 7E 0C               LD     A,(IX+fcbExtIndex)   ; Target EXT in A, FCB EXT in C     ;
3077: F139 B9                     CP     C                    ; Are we in the right directory ?	;
3078: F13A C2 46 F1               JP     NZ,RandomSeekClose   ;  Skip if not                      ;
3079: F13D         ;
3080: F13D DD 7E 0E               LD     A,(IX+fcbS2Index)    ; Target S2 in A, FCB S2 in C       ;
3081: F140 B8                     CP     B                    ; Still in the right directory ?    ;
3082: F141 E6 7F                  AND    7FH                  ; Mask out MSBit                    ;
3083: F143 CA 7A F1               JP     Z,RandomSeekExit     ;  Exit if yes                      ;
3084: F146         ;
3085: F146             RandomSeekClose:                      ;
3086: F146 C5                     PUSH   BC                   ; Save EXT                          ;
3087: F147 D5                     PUSH   DE                   ; Save FCB                          ;
3088: F148 CD 8A EE               CALL   CloseDirEntry        ; Close this directory entry        ;
3089: F14B D1                     POP    DE                   ; FCB                               ;
3090: F14C C1                     POP    BC                   ; EXT                               ;
3091: F14D 2E 03                  LD     L,03                 ; "CP/M could not close current extent" ;
3092: F14F 3A C5 EA               LD     A,(exitParameterByte) ; Get result from Close             ;
3093: F152 3C                     INC    A                    ;
3094: F153 CA 80 F1               JP     Z,RandomSeekErrorBadSeek ; Error exit if 0FFH                ;
3095: F156         ;
3096: F156 DD 71 0C               LD     (IX+fcbExtIndex),C   ; Update FCB Ext value              ;
3097: F159 DD 70 0E               LD     (IX+fcbS2Index),B    ; Update FCB S2 value               ;
3098: F15C CD 47 EE               CALL   OpenFile             ; Open the targeted Dir entry       ;
3099: F15F 3A C5 EA               LD     A,(exitParameterByte) ; is the file present?              ;
3100: F162 3C                     INC    A                    ;
3101: F163 C2 7A F1               JP     NZ,RandomSeekExit    ; Exit if open successful	        ;
3102: F166         ; cannot open the file, read mode?                                          ;
3103: F166 C1                     POP    BC                   ; Get Read/Write flag               ;
3104: F167 C5                     PUSH   BC                   ; Read/Write flag                   ;
3105: F168 2E 04                  LD     L,04                 ; "attempt to read unwritten extent"    ;
3106: F16A 0C                     INC    C                    ; Becomes 00 if read operation      ;
3107: F16B CA 80 F1               JP     Z,RandomSeekErrorBadSeek ; Error exit if read operation      ;
3108: F16E         ;
3109: F16E CD 0A EF               CALL   MakeNewFile          ; Make Directory Entry              ;
3110: F171 2E 05                  LD     L,05                 ; "cannot create new extent"        ;
3111: F173 3A C5 EA               LD     A,(exitParameterByte) ; Get result from Make              ;
3112: F176 3C                     INC    A                    ;
3113: F177 CA 80 F1               JP     Z,RandomSeekErrorBadSeek ;  Exit if failed on Make           ;
3114: F17A         ;
3115: F17A             RandomSeekExit:                      ;
3116: F17A C1                     POP    BC                   ; Balance Stack                     ;
3117: F17B AF                     XOR    A                    ; Success                           ;
3118: F17C 32 C5 EA               LD     (exitParameterByte),A ;
3119: F17F C9                     RET                         ;
3120: F180         ;
3121: F180             RandomSeekErrorBadSeek:                      ;
3122: F180 DD 36 0E C0               LD     (IX+fcbS2Index),0C0H ; Set Write protect & overflow      ;
3123: F184             RandomSeekError:                      ;
3124: F184 C1                     POP    BC                   ; Balance Stack                     ;
3125: F185 7D                     LD     A,L                  ; Get error code                    ;
3126: F186 32 C5 EA               LD     (exitParameterByte),A ;  and return it to caller          ;
3127: F189 C3 3F F0               JP     SetFileWriteFlag     ; Set flag for following close      ;
3128: F18C         ;-------------------------------- Random Seek ------------------------------;
3129: F18C
3130: F18C
3131: F18C
3132: F18C         ; FU
3133: F18C         ;=========================== File Utilities ================================;
3134: F18C
3135: F18C         ;=========================== Directory Utilities ===========================;
3136: F18C         ;--------------------------- Set End of Directory indicator ----------------;
3137: F18C             SetEndDirectory:                      ;
3138: F18C 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
3139: F18F 22 4C F5               LD     (dirEntryIndex),HL   ;
3140: F192 C9                     RET                         ;
3141: F193         ;--------------------------- Set End of Directory indicator ----------------;
3142: F193         ;--------------------------- Are we at End Of Directory --------------------;
3143: F193         ; Tests to see if we are at the End Of the Directory                        ;
3144: F193         ;                                                                           ;
3145: F193         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
3146: F193         ;			 Z Flag reset if still in directory                             ;
3147: F193         ;
3148: F193             AtEndOfDirectory:                      ;
3149: F193 21 4C F5               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
3150: F196 7E                     LD     A,(HL)               ; Get it                            ;
3151: F197 23                     INC    HL                   ; Point at MSB	of Dir Index		;
3152: F198 BE                     CP     M                    ; LSB = MSB ?                       ;
3153: F199 C0                     RET    NZ                   ;  exit if not if different         ;
3154: F19A         ; Same.  are they = 0ffh?           ;
3155: F19A 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
3156: F19B C9                     RET                         ;
3157: F19C         ;--------------------------- Are we at End Of Directory --------------------;
3158: F19C         ;--------------------------- Get Directory Element -------------------------;
3159: F19C         ; compute the address of a directory element in Directory Buffer            ;
3160: F19C         ; Returns:  HL = Address of the specific directory Entry                    ;
3161: F19C             GetCurrentDirectoryRecord:                      ;
3162: F19C C5                     PUSH   BC                   ; Save BC                           ;
3163: F19D 2A 20 F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
3164: F1A0 3A 4B F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
3165: F1A3 4F                     LD     C,A                  ;
3166: F1A4 AF                     XOR    A                    ; Set to Zero and reset CY          ;
3167: F1A5 47                     LD     B,A                  ;
3168: F1A6 ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
3169: F1A8 C1                     POP    BC                   ; Restore	                        ;
3170: F1A9 C9                     RET                         ;
3171: F1AA         ;--------------------------- Get Directory Element -------------------------;
3172: F1AA         ;--------------------------- Set Directory Entry ---------------------------;
3173: F1AA         ; Will update directory if not in the directory                             ;
3174: F1AA         ;
3175: F1AA             SetDirectoryEntry:                      ;
3176: F1AA CD B3 F1               CALL   StillInDirectory     ;
3177: F1AD D8                     RET    C                    ; Exit if still in the Directory  	;
3178: F1AE         ;
3179: F1AE         ; StillInDirectory will return with:                                        ;
3180: F1AE         ;									DE = Directory entry number             ;
3181: F1AE         ;									HL = Address of entry number + 1        ;
3182: F1AE 13                     INC    DE                   ;
3183: F1AF 72                     LD     (HL),D               ;
3184: F1B0 2B                     DEC    HL                   ;
3185: F1B1 73                     LD     (HL),E               ;
3186: F1B2 C9                     RET                         ;
3187: F1B3         ;--------------------------- Set Directory Entry ---------------------------;
3188: F1B3         ;--------------------------- Are we sill in the Directory ------------------;
3189: F1B3         ;Returns	:                                                               ;
3190: F1B3         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
3191: F1B3         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
3192: F1B3         ;			HL = (address of Index Value) + 1                               ;
3193: F1B3         ;			DE = Directory Index Value                                      ;
3194: F1B3             StillInDirectory:                      ;
3195: F1B3 2A 4C F5               LD     HL,(dirEntryIndex)   ;
3196: F1B6 EB                     EX     DE,HL                ; DE = directory counter            ;
3197: F1B7 2A 1A F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
3198: F1BA 7B                     LD     A,E                  ;
3199: F1BB 96                     SUB    M                    ;
3200: F1BC 23                     INC    HL                   ;
3201: F1BD 7A                     LD     A,D                  ;
3202: F1BE 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
3203: F1BF C9                     RET                         ;  <= Directory Max Value       ;
3204: F1C0         ;--------------------------- Are we sill in the Directory ------------------;
3205: F1C0         ;--------------------------- Scan Disk Map ---------------------------------;
3206: F1C0         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
3207: F1C0         ;                                                                           ;
3208: F1C0         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
3209: F1C0         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
3210: F1C0         ;
3211: F1C0             ScanDiskMap:                      ;
3212: F1C0 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
3213: F1C1 CD 9C F1               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
3214: F1C4 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
3215: F1C7 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
3216: F1C8 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
3217: F1CA         ;
3218: F1CA             ScanDiskMap0:                      ;
3219: F1CA D1                     POP    DE                   ; Recall the set/reset Info         ;
3220: F1CB 0D                     DEC    C                    ;
3221: F1CC C8                     RET    Z                    ; Loop once for each disk map entry ;
3222: F1CD         ;
3223: F1CD D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
3224: F1CE 3A 41 F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
3225: F1D1 B7                     OR     A                    ;
3226: F1D2 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
3227: F1D4         ;  Byte Allocation scan operation                                           ;
3228: F1D4 C5                     PUSH   BC                   ; Save counter                      ;
3229: F1D5 E5                     PUSH   HL                   ; Save map address                  ;
3230: F1D6 4E                     LD     C,(HL)               ;
3231: F1D7 06 00                  LD     B,0                  ; BC=block# for Byte                ;
3232: F1D9 18 06                  JR     ScanDiskMap2         ;
3233: F1DB         ; Word scan operation                                                       ;
3234: F1DB             ScanDiskMapWord:                      ;
3235: F1DB 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
3236: F1DC C5                     PUSH   BC                   ; Save counter                      ;
3237: F1DD 46                     LD     B,(HL)               ;
3238: F1DE 23                     INC    HL                   ;
3239: F1DF 4E                     LD     C,(HL)               ; BC=block# for Word                ;
3240: F1E0 E5                     PUSH   HL                   ; Save map address                  ;
3241: F1E1         ;
3242: F1E1         ; Arrive here with BC=block#, E=0/1	                                        ;
3243: F1E1             ScanDiskMap2:                      ;
3244: F1E1 79                     LD     A,C                  ;
3245: F1E2 B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
3246: F1E3 C4 0A F0               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
3247: F1E6 E1                     POP    HL                   ;
3248: F1E7 23                     INC    HL                   ; to next bit position              ;
3249: F1E8 C1                     POP    BC                   ; recall counter                    ;
3250: F1E9 C3 CA F1               JP     ScanDiskMap0         ; for another item                  ;
3251: F1EC         ;
3252: F1EC         ;--------------------------- Scan Disk Map ---------------------------------;
3253: F1EC         ;--------------------------- Get Closest Disk Block ------------------------;
3254: F1EC         ; Find the closest available disk block, and mark in Map as allocated       ;
3255: F1EC         ; Enter	BC	= Block number to base the search on                            ;
3256: F1EC         ; Exit	HL	= 0000 if There are no available open blocks                    ;
3257: F1EC         ;			= block number of available and marked block                    ;
3258: F1EC         ;
3259: F1EC             GetClosestBlock:                      ;
3260: F1EC C5                     PUSH   BC                   ; save the starting Block #         ;
3261: F1ED         ;
3262: F1ED 2A 2D F5               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
3263: F1F0 CD 59 F3               CALL   DivideHLby8          ; Length of Map	                    ;
3264: F1F3 EB                     EX     DE,HL                ; put size into DE			        ;
3265: F1F4 E1                     POP    HL                   ; Block number into HL              ;
3266: F1F5 CD 59 F3               CALL   DivideHLby8          ; Length of Map                     ;
3267: F1F8 EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
3268: F1F9 AF                     XOR    A                    ; Reset CY                          ;
3269: F1FA ED 52                  SBC    HL,DE                ; Size for right                    ;
3270: F1FC         ; DE = Start Index                                                          ;
3271: F1FC         ; DE = Left Size                                                            ;
3272: F1FC         ; HL	= Right Size                                                        ;
3273: F1FC E5                     PUSH   HL                   ; Save right size                   ;
3274: F1FD D5                     PUSH   DE                   ; Save left size & Start Index      ;
3275: F1FE 3E FF                  LD     A,0FFH               ; Full Octet                        ;
3276: F200         ;
3277: F200 2A 26 F5               LD     HL,(caAllocVector)   ; Start of Map                      ;
3278: F203 19                     ADD    HL,DE                ; Determine initial Octet			;
3279: F204         ; Set up Left side                                                          ;
3280: F204 C1                     POP    BC                   ; Left size                         ;
3281: F205 03                     INC    BC                   ; adjust                            ;
3282: F206 E5                     PUSH   HL                   ; Save initial Octet                ;
3283: F207 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
3284: F20A         ; HL = Initial Octet                                                        ;
3285: F20A         ; BC = Left Size                                                            ;
3286: F20A D9                     EXX                         ; Use alternate registers           ;
3287: F20B 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
3288: F20E E1                     POP    HL                   ; Get Initial Octet                 ;
3289: F20F C1                     POP    BC                   ; Get Right Size                    ;
3290: F210 03                     INC    BC                   ; adjust                            ;
3291: F211             LookRight:                      ;
3292: F211 ED A1                  CPI                         ; UnSet Bit?                        ;
3293: F213 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3294: F215 E2 2E F2               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
3295: F218         ;
3296: F218 D9                     EXX                         ; Switch to the Left                ;
3297: F219 ED A9                  CPD                         ; UnSet Bit?                        ;
3298: F21B 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3299: F21D E2 23 F2               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
3300: F220 D9                     EXX                         ; switch to right                   ;
3301: F221 18 EE                  JR     LookRight            ; Keep on looking                   ;
3302: F223         ;			----------------			                                    ;
3303: F223             NoMoreLeft:                      ;
3304: F223 D9                     EXX                         ; Switch to Right                   ;
3305: F224             NoMoreLeftLoop:                      ;
3306: F224 ED A1                  CPI                         ;
3307: F226 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3308: F228 E2 39 F2               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
3309: F22B 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
3310: F22D 76                     HALT                        ;
3311: F22E             NoMoreRight:                      ;
3312: F22E D9                     EXX                         ; Switch to Left                    ;
3313: F22F             NoMoreRightLoop:                      ;
3314: F22F ED A9                  CPD                         ;
3315: F231 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3316: F233 E2 39 F2               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
3317: F236 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
3318: F238 76                     HALT                        ;
3319: F239             NoFreeBlocks:                      ;
3320: F239 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
3321: F23C C9                     RET                         ;
3322: F23D         ;			----------------			                                    ;
3323: F23D             FoundFreeOctet:                      ;
3324: F23D BB                     CP     E                    ; Left or Right                     ;
3325: F23E 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
3326: F240 2B                     DEC    HL                   ; Adjust for direction              ;
3327: F241 18 01                  JR     FoundFreeOctet2      ;
3328: F243         ;
3329: F243             FoundFreeOctet1:                      ;
3330: F243 23                     INC    HL                   ; Adjust for direction              ;
3331: F244             FoundFreeOctet2:                      ;
3332: F244 01 00 00               LD     BC,00                ; need to keep track of bit         ;
3333: F247             FoundFreeOctet3:                      ;
3334: F247 CB 06                  RLC    (HL)                 ;
3335: F249 03                     INC    BC                   ;
3336: F24A 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
3337: F24C CB C6                  SET    0,(HL)               ; Make map bit set                  ;
3338: F24E 41                     LD     B,C                  ; Put count in B                    ;
3339: F24F             FoundFreeOctet4:                      ;
3340: F24F CB 0E                  RRC    (HL)                 ;
3341: F251 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
3342: F253 0B                     DEC    BC                   ; adjust for Zero based value       ;
3343: F254 C5                     PUSH   BC                   ; Save the bit index                ;
3344: F255 ED 4B 26 F5               LD     BC,(caAllocVector)   ; Get Map start                     ;
3345: F259 AF                     XOR    A                    ; Clear CY                          ;
3346: F25A ED 42                  SBC    HL,BC                ; Get how far in the map            ;
3347: F25C CD 63 F3               CALL   MultiplyHLby8        ; Calculate the Octet           ;
3348: F25F C1                     POP    BC                   ; Restore index into Octet          ;
3349: F260 09                     ADD    HL,BC                ; This is the Block Number          ;
3350: F261 C9                     RET                         ;
3351: F262         ;--------------------------- Get Closest Disk Block ------------------------;
3352: F262         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3353: F262             CopyDirEntryToUserDMA:                      ;
3354: F262 2A 20 F5               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer         ;
3355: F265 ED 5B 18 F5               LD     DE,(initDAMAddress)  ; Point at User's Buffer            ;
3356: F269 01 80 00               LD     BC,cpmRecordSize     ; The entire record                 ;
3357: F26C ED B0                  LDIR                        ; Move it                           ;
3358: F26E C9                     RET                         ;
3359: F26F         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3360: F26F         ;--------------------- Return last Directory Index to Caller ---------------;
3361: F26F             DirLocationToReturnLoc:                      ;
3362: F26F 3A 3C F5               LD     A,(directoryIndex)   ; Get last directory Index          ;
3363: F272 32 C5 EA               LD     (exitParameterByte),A ; Save for return to Caller         ;
3364: F275 C9                     RET                         ;
3365: F276         ;--------------------- Return last Directory Index to Caller ---------------;
3366: F276         ;--------------------------- Check OK to Write to Disk ---------------------;
3367: F276             CheckWrite:                      ;
3368: F276 CD A6 EF               CALL   IsDiskWriteProtected ; Is this disk Write Protected?     ;
3369: F279 C8                     RET    Z                    ; OK to write                       ;
3370: F27A C3 87 F4               JP     errReadOnlyDisk      ; Report read only disk error		;
3371: F27D         ;--------------------------- Check OK to Write to Disk ---------------------;
3372: F27D         ;--------------------------- Check File Write Protect Status ---------------;
3373: F27D             CheckRODirectory:                      ;
3374: F27D CD 9C F1               CALL   GetCurrentDirectoryRecord ; Use Entry in Directory Buffer     ;
3375: F280         ; Use HL as the directory entry in Question                                 ;
3376: F280             CheckROFile:                      ;
3377: F280 11 09 00               LD     DE,fcbROfileIndex    ; Index into FC for RO              ;
3378: F283 19                     ADD    HL,DE                ; point at the byte                 ;
3379: F284 7E                     LD     A,(HL)               ;
3380: F285 17                     RLA                         ; Set CY if RO bit set              ;
3381: F286 D0                     RET    NC                   ; Return OK                         ;
3382: F287 C3 8D F4               JP     errReadOnlyFile      ; Report to read only File          ;
3383: F28A         ;--------------------------- Check File Write Protect Status ---------------;
3384: F28A         ;------------------------- Copy FCB To Directory record --------------------;
3385: F28A         ; On Entry:                                                                 ;
3386: F28A         ;			C = Starting position                                           ;
3387: F28A         ;			E = length of copy                                              ;
3388: F28A         ;copy the whole file control block                                          ;
3389: F28A             CopyFCB:                        ;
3390: F28A 0E 00                  LD     C,0                  ;
3391: F28C 1E 20                  LD     E,fcbLength          ; Copy all of the FCB		    ;
3392: F28E         ; On Entry:                                                                 ;
3393: F28E         ;			C = Starting position                                           ;
3394: F28E         ;			E = length of copy                                              ;
3395: F28E             CopyDir:                        ;
3396: F28E 16 00                  LD     D,0                  ; Make length a word value      ;
3397: F290 D5                     PUSH   DE                   ; Length                        ;
3398: F291 06 00                  LD     B,0                  ; Make index a word             ;
3399: F293 2A C3 EA               LD     HL,(paramDE)         ; HL = source for data          ;
3400: F296 09                     ADD    HL,BC                ;
3401: F297 EB                     EX     DE,HL                ;
3402: F298 CD 9C F1               CALL   GetCurrentDirectoryRecord ; HL pointer to Dir Record      ;
3403: F29B EB                     EX     DE,HL                ;
3404: F29C C1                     POP    BC                   ; Length                        ;
3405: F29D ED B0                  LDIR                        ;
3406: F29F CD B8 F3               CALL   SeekDir              ; Seek to the dir entry         ;
3407: F2A2 C3 D9 F0               JP     WriteDir             ; Write the directory element   ;
3408: F2A5         ;------------------------- Copy FCB from Directory record ------------------;
3409: F2A5         ;-------------------------------- Get Block Number -------------------------;
3410: F2A5         ;compute disk block number from current FCB                                ;
3411: F2A5             GetBlockNumber:                      ;
3412: F2A5 CD B2 F2               CALL   GetDiskMapIndex      ;Return Alloc block index           ;
3413: F2A8 4F                     LD     C,A                  ;
3414: F2A9 06 00                  LD     B,0                  ;
3415: F2AB CD BF F2               CALL   GetDiskMapValue      ; Convert to Disk record            ;
3416: F2AE 22 49 F5               LD     (absoluteCPMRecord),HL ; Save                              ;
3417: F2B1 C9                     RET                         ;
3418: F2B2         ;-------------------------------- Get Block Number -------------------------;
3419: F2B2         ;-------------------------------- Get Disk Map Index -----------------------;
3420: F2B2         ;Return the  disk map Index for current File Record in the ACC              ;
3421: F2B2             GetDiskMapIndex:                      ;
3422: F2B2 21 2A F5               LD     HL,dpbBSH            ; Block# = Record# / (2***dpbBSH)   ;
3423: F2B5 46                     LD     B,(HL)               ; shift count                       ;
3424: F2B6 3A 47 F5               LD     A,(currentFileRecord) ;
3425: F2B9             GetDiskMapIndexLoop:                      ;
3426: F2B9 CB 3F                  SRL    A                    ;
3427: F2BB 10 FC                  DJNZ   GetDiskMapIndexLoop  ; Loop till done                    ;
3428: F2BD 00                     NOP                         ;
3429: F2BE C9                     RET                         ;
3430: F2BF         ;-------------------------------- Get Disk Map Index -----------------------;
3431: F2BF         ;-------------------------------- Get Disk Map Value -----------------------;
3432: F2BF         ; Enter with Disk Map Index in BC                                           ;
3433: F2BF         ; Return disk map value  in HL                                              ;
3434: F2BF             GetDiskMapValue:                      ;
3435: F2BF 2A C3 EA               LD     HL,(paramDE)         ; FCB                               ;
3436: F2C2 11 10 00               LD     DE,fcbDiskMapIndex   ; Index to Allocation Map           ;
3437: F2C5 19                     ADD    HL,DE                ; Address of Allocation Map Start   ;
3438: F2C6 09                     ADD    HL,BC                ; Point at the targeted map entry   ;
3439: F2C7 3A 41 F5               LD     A,(byteAllocationFlag) ; Is this a byte or word            ;
3440: F2CA B7                     OR     A                    ;
3441: F2CB 28 04                  JR     Z,GetDiskMap16Bit    ; Skip if word value                ;
3442: F2CD 6E                     LD     L,(HL)               ;  else its a byte value            ;
3443: F2CE 26 00                  LD     H,0                  ;load the byte into HL              ;
3444: F2D0 C9                     RET                         ;
3445: F2D1         ;
3446: F2D1             GetDiskMap16Bit:                      ;
3447: F2D1 09                     ADD    HL,BC                ; make it double width              ;
3448: F2D2 56                     LD     D,(HL)               ;
3449: F2D3 23                     INC    HL                   ;
3450: F2D4 5E                     LD     E,(HL)               ; Load word value into DE           ;
3451: F2D5 EB                     EX     DE,HL                ; return value in HL                ;
3452: F2D6 C9                     RET                         ;
3453: F2D7         ;-------------------------------- Get Disk Map Value -----------------------;
3454: F2D7         ;-------------------------------- Allocate The Block -----------------------;
3455: F2D7         ;is  block allocated                                                        ;
3456: F2D7             WasBlockAllocated:                      ;
3457: F2D7 2A 49 F5               LD     HL,(absoluteCPMRecord) ; Get the Block Number              ;
3458: F2DA 7D                     LD     A,L                  ; ZFlag set if                      ;
3459: F2DB B4                     OR     H                    ;  absoluteCPMRecord = 0            ;
3460: F2DC C9                     RET                         ;
3461: F2DD         ;-------------------------------- Allocate The Block -----------------------;
3462: F2DD         ;----------------------------- Set Actual Record Add -----------------------;
3463: F2DD         ;
3464: F2DD         ;compute actual record address                                              ;
3465: F2DD         ; result = absolute CPMRecord * ( 2**BSH)                                  ;
3466: F2DD             SetActualRecordAdd:                      ;
3467: F2DD 3A 2A F5               LD     A,(dpbBSH)           ; Block Shift to loop control       ;
3468: F2E0 47                     LD     B,A
3469: F2E1 2A 49 F5               LD     HL,(absoluteCPMRecord) ;
3470: F2E4         ;
3471: F2E4             SetActualRecordAddLoop:                      ;
3472: F2E4 29                     ADD    HL,HL                ;
3473: F2E5 10 FD                  DJNZ   SetActualRecordAddLoop ;
3474: F2E7         ;?	DEC		A								; shl(absolute CPMRecord,dpbBSH);
3475: F2E7         ;?	JP	NZ,SetActualRecordAddLoop                                           ;
3476: F2E7         ;
3477: F2E7         ; HL has Record number for start of the block;                              ;
3478: F2E7 3A 2B F5               LD     A,(dpbBLM)           ; Get block mask to get current     ;
3479: F2EA 4F                     LD     C,A                  ;  File Record mod Block            ;
3480: F2EB 3A 47 F5               LD     A,(currentFileRecord) ; Get index into block              ;
3481: F2EE A1                     AND    C                    ; Record index in Block             ;
3482: F2EF B5                     OR     L                    ;
3483: F2F0 6F                     LD     L,A                  ; to HL                             ;
3484: F2F1 22 49 F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL            ;
3485: F2F4         ; *** Absolute CPM Record now has current record number                     ;
3486: F2F4         ; - Starting record number + index into block                               ;
3487: F2F4 C9                     RET                         ;
3488: F2F5         ;----------------------------- Set Actual Record Add -----------------------;
3489: F2F5         ;-------------------------------- Open Next Extent -------------------------;
3490: F2F5         ;close the current extent  and open the next one if possible.              ;
3491: F2F5         ;readModeFlag is true if in read mode                                      ;
3492: F2F5             OpenNextExt:                      ;
3493: F2F5 AF                     XOR    A                    ; Set to 00                         ;
3494: F2F6 32 3A F5               LD     (fcbCopiedFlag),A    ; Clear Flag                        ;
3495: F2F9 CD 8A EE               CALL   CloseDirEntry        ; Close current extent.             ;
3496: F2FC CD 93 F1               CALL   AtEndOfDirectory     ; Is the directory full?            ;
3497: F2FF C8                     RET    Z                    ;  exit it yes                      ;
3498: F300         ;
3499: F300 CD 02 F0               CALL   GetExtentAddress     ; HL at FCB's EXT                   ;
3500: F303 7E                     LD     A,(HL)               ; Get previous EXT value            ;
3501: F304 3C                     INC    A                    ; Add one to it                     ;
3502: F305 E6 1F                  AND    maxExtValue          ; Limit to max value                ;
3503: F307 77                     LD     (HL),A               ; Put it back into the FCB          ;
3504: F308 28 0D                  JR     Z,OpenNextModule     ;  if = 0, need to open new Module  ;
3505: F30A         ;
3506: F30A 47                     LD     B,A                  ; put Ext value in B                ;
3507: F30B 3A 2C F5               LD     A,(dpbEXM)           ; Get the Extent Mask               ;
3508: F30E A0                     AND    B                    ; Mask out unwanted bits            ;
3509: F30F         ; if result is zero, then not in the same group                             ;
3510: F30F 21 3A F5               LD     HL,fcbCopiedFlag     ; Point at Copied Flag              ;
3511: F312 A6                     AND    M                    ;  00 in Acc if not written         ;
3512: F313 28 0C                  JR     Z,OpenNextExt1       ;  go to next physical extent if 0  ;
3513: F315 18 24                  JR     UpdateFCB            ;  else continue                    ;
3514: F317         ;
3515: F317             OpenNextModule:                      ;
3516: F317 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ; Index difference between EXT & S2 ;
3517: F31A 09                     ADD    HL,BC                ; Add to HL( at EXT) gives S2       ;
3518: F31B 34                     INC    M                    ; Increment the Module number       ;
3519: F31C 7E                     LD     A,(HL)               ; get the new Module number         ;
3520: F31D E6 0F                  AND    moduleMask           ; Mask out unwanted bits            ;
3521: F31F 28 25                  JR     Z,OpenNextExtError   ; If overflow to zero, error exit   ;
3522: F321         ;
3523: F321             OpenNextExt1:                      ;
3524: F321 0E 0F                  LD     C,nameLength         ; Set search/match size             ;
3525: F323 CD 5C F0               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
3526: F326 CD 93 F1               CALL   AtEndOfDirectory     ; At end of Directory ?             ;
3527: F329 20 10                  JR     NZ,UpdateFCB         ;  No, then keep going              ;
3528: F32B         ;
3529: F32B 3A 3B F5               LD     A,(readModeFlag)     ;  else at EOD                      ;
3530: F32E 3C                     INC    A                    ; 0ffh becomes 00 if read           ;
3531: F32F 28 15                  JR     Z,OpenNextExtError   ; All done if a read                ;
3532: F331         ;
3533: F331 CD 0A EF               CALL   MakeNewFile          ; With write we can extend file     ;
3534: F334 CD 93 F1               CALL   AtEndOfDirectory     ; Is there room in the directory ?  ;
3535: F337 28 0D                  JR     Z,OpenNextExtError   ;  no, exitParameterByte = 1        ;
3536: F339 18 03                  JR     OpenNextExt3         ;
3537: F33B         ;
3538: F33B             UpdateFCB:                      ;
3539: F33B CD 50 EE               CALL   CopyDirRecordToFCB   ; Update FCB                        ;
3540: F33E             OpenNextExt3:                      ;
3541: F33E CD DE EF               CALL   SetRecordVars        ; Set variables for current FCB     ;
3542: F341 AF                     XOR    A                    ;
3543: F342 32 C5 EA               LD     (exitParameterByte),A ; Set exitParameterByte = 0         ;
3544: F345 C9                     RET                         ;
3545: F346         ;
3546: F346             OpenNextExtError:                      ;
3547: F346 CD 7B F3               CALL   SetExitParamTo1      ; ExitParameterByte = 1             ;
3548: F349 C3 3F F0               JP     SetFileWriteFlag     ; Ensure that it will not be closed ;
3549: F34C         ;-------------------------------- Open Next Extent -------------------------;
3550: F34C
3551: F34C         ;=========================== Directory Utilities ===========================;
3552: F34C         ; DU
3553: F34C
3554: F34C         ;=========================== General   Utilities ===========================;
3555: F34C
3556: F34C         ;--------------------------- Rotate HL right by value in C ----------------;
3557: F34C         ;
3558: F34C         ; HL = Value to be rotated Right                                           ;
3559: F34C         ;  B = Amount to shift                                                     ;
3560: F34C             RotateRightHLbyB:                      ;
3561: F34C 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
3562: F34D CB 45                  BIT    0,L                  ; is LSB set?                      ;
3563: F34F 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
3564: F351 3F                     CCF                         ; else Clear Carry flag            ;
3565: F352             RotateRightHLbyB1:                      ;
3566: F352 CB 1C                  RR     H                    ; Shift thru CY                    ;
3567: F354 CB 1D                  RR     L                    ; ditto                            ;
3568: F356 10 F4                  DJNZ   RotateRightHLbyB     ;
3569: F358 C9                     RET                         ;
3570: F359         ;
3571: F359         ;--------------------------- Rotate HL right by value in C ----------------;
3572: F359         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
3573: F359         ; HL = Value to be shifted Right                                           ;
3574: F359             DivideHLby8:                      ;
3575: F359 06 03                  LD     B,3                  ; 8 = 2**3						   ;
3576: F35B         ;  B = Amount to shift                                                     ;
3577: F35B             ShiftRightHLbyB:                      ;
3578: F35B AF                     XOR    A                    ; else Clear Carry flag            ;
3579: F35C CB 1C                  RR     H                    ; Shift thru CY                    ;
3580: F35E CB 1D                  RR     L                    ; ditto                            ;
3581: F360 10 F9                  DJNZ   ShiftRightHLbyB      ;
3582: F362 C9                     RET                         ;
3583: F363         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
3584: F363         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
3585: F363         ; HL = Value to be shifted Left                                            ;
3586: F363             MultiplyHLby8:                      ;
3587: F363 06 03                  LD     B,3                  ; 8 = 2**3						   ;
3588: F365         ;  B = Amount to shift                                                     ;
3589: F365             ShiftLeftHLbyB:                      ;
3590: F365 AF                     XOR    A                    ; else Clear Carry flag            ;
3591: F366 CB 15                  RL     L                    ; Shift thru CY                    ;
3592: F368 CB 14                  RL     H                    ; ditto                            ;
3593: F36A 10 F9                  DJNZ   ShiftLeftHLbyB       ;
3594: F36C C9                     RET                         ;
3595: F36D         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
3596: F36D         ;----------------------------- Merge ---------------------------------------;
3597: F36D         ; Merge Map Block Numbers between FCB and directory record                  ;
3598: F36D         ; HL has pointer to map for either dir record or FCB,                       ;
3599: F36D         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
3600: F36D         ; it just returns, Else it copies the block number to where DE is pointing  ;
3601: F36D         ;
3602: F36D             Merge:                          ;
3603: F36D 7E                     LD     A,(HL)               ; Get the first byte                ;
3604: F36E 23                     INC    HL                   ;
3605: F36F B6                     OR     M                    ; OR it with the second byte        ;
3606: F370 2B                     DEC    HL                   ; Restore HL to start               ;
3607: F371 C0                     RET    NZ                   ; Exit if both are 0s               ;
3608: F372         ; HL points to a non Zero value	                                            ;
3609: F372 1A                     LD     A,(DE)               ; Get the first byte                ;
3610: F373 77                     LD     (HL),A               ; Move it                           ;
3611: F374 13                     INC    DE                   ;
3612: F375 23                     INC    HL                   ; Increment both pointers           ;
3613: F376 1A                     LD     A,(DE)               ; Get the second byte               ;
3614: F377 77                     LD     (HL),A               ; Move it                           ;
3615: F378 1B                     DEC    DE                   ;
3616: F379 2B                     DEC    HL                   ; Restore HL & DE to start          ;
3617: F37A C9                     RET                         ;
3618: F37B         ;----------------------------- Merge ---------------------------------------;
3619: F37B         ;------------------------- Set Exit Parameter To 1 -------------------------;
3620: F37B             SetExitParamTo1:                      ;
3621: F37B 3E 01                  LD     A,1                  ;
3622: F37D 32 C5 EA               LD     (exitParameterByte),A ; Put a 1 in the exit parameter     ;
3623: F380 C9                     RET                         ;
3624: F381         ;------------------------- Set Exit Parameter To 1 -------------------------;
3625: F381
3626: F381         ; GU
3627: F381
3628: F381         ;=========================== General   Utilities ===========================;
3629: F381
3630: F381         ;--------------------------- Read Directory Record -------------------------;
3631: F381         ; read a directory entry into the directory buffer                          ;
3632: F381             ReadDirRecord:                      ;
3633: F381 CD 7D EF               CALL   SetDirDMA            ; System Assigned Buffer            ;
3634: F384 CD 86 EF               CALL   ReadBuffer           ; Go to BIOS for the read           ;
3635: F387 C3 78 EF               JP     SetDataDMA           ; Restore DMA                       ;
3636: F38A         ;--------------------------- Read Directory Record -------------------------;
3637: F38A
3638: F38A         ;--------------------------- Read Directory --------------------------------;
3639: F38A         ; Read next directory entry                                                 ;
3640: F38A         ; Enter :                                                                   ;
3641: F38A         ;		C =  TRUE initializing and setting CheckSum                         ;
3642: F38A         ;		  <> TRUE Checking existing CheckSum                                ;
3643: F38A             ReadDirectory:                      ;
3644: F38A ED 5B 2F F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
3645: F38E 2A 4C F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
3646: F391 23                     INC    HL                   ; Increment the Index               ;
3647: F392 22 4C F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
3648: F395 AF                     XOR    A                    ; Clear the CY flag                 ;
3649: F396 ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
3650: F398 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
3651: F39A CD 8C F1               CALL   SetEndDirectory      ;  else we are done                 ;
3652: F39D C9                     RET                         ;
3653: F39E         ;
3654: F39E         ; Calculate the entry index Position in Buffer                              ;
3655: F39E             ReadDirectory0:                      ;
3656: F39E 3A 4C F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
3657: F3A1 E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
3658: F3A3 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
3659: F3A5             ReadDirectory1:                      ;
3660: F3A5 87                     ADD    A,A                  ;
3661: F3A6 10 FD                  DJNZ   ReadDirectory1       ;
3662: F3A8 32 4B F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
3663: F3AB B7                     OR     A                    ; Is this the 1st entry?            ;
3664: F3AC C0                     RET    NZ                   ;  return if not.                   ;
3665: F3AD         ;
3666: F3AD C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
3667: F3AE CD B8 F3               CALL   SeekDir              ; Set up for Directory Read         ;
3668: F3B1 CD 81 F3               CALL   ReadDirRecord        ; Read the directory record         ;
3669: F3B4 C1                     POP    BC                   ; Recall initialization flag        ;
3670: F3B5 C3 03 F4               JP     CheckSumUtility      ; Checksum the directory            ;
3671: F3B8         ;--------------------------- Read Directory --------------------------------;
3672: F3B8         ;--------------------------- Seek Directory --------------------------------;
3673: F3B8         ;seek the record containing the current directory entry					;
3674: F3B8             SeekDir:                        ;
3675: F3B8 2A 4C F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
3676: F3BB 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
3677: F3BD CD 5B F3               CALL   ShiftRightHLbyB      ;
3678: F3C0 22 49 F5               LD     (absoluteCPMRecord),HL ;
3679: F3C3 22 4E F5               LD     (dirRecord),HL       ; Save                              ;
3680: F3C6 C3 C9 F3               JP     Seek                 ;
3681: F3C9         ;--------------------------- Seek Directory --------------------------------;
3682: F3C9         ;--------------------------- Seek ------------------------------------------;
3683: F3C9             Seek:                           ;
3684: F3C9 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
3685: F3CC 2A 49 F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
3686: F3CF ED 5B 28 F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
3687: F3D3         ;
3688: F3D3             Seek0:                          ;
3689: F3D3 03                     INC    BC                   ; Divide the record                 ;
3690: F3D4 AF                     XOR    A                    ;  by the sectors per track         ;
3691: F3D5 ED 52                  SBC    HL,DE                ;
3692: F3D7 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
3693: F3D9         ;
3694: F3D9         ;
3695: F3D9 19                     ADD    HL,DE                ; Gets the sector in the track      ;
3696: F3DA E5                     PUSH   HL                   ; Save Index Sector                 ;
3697: F3DB         ;
3698: F3DB DD 2A 1C F5               LD     IX,(caTrack)         ;
3699: F3DF DD 71 00               LD     (IX+0),C             ;
3700: F3E2 DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
3701: F3E5         ;
3702: F3E5 EB                     EX     DE,HL                ; Take the index from the record    ;
3703: F3E6 2A 49 F5               LD     HL,(absoluteCPMRecord) ;
3704: F3E9 AF                     XOR    A                    ;
3705: F3EA ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
3706: F3EC         ;
3707: F3EC DD 2A 1E F5               LD     IX,(caSector)        ;
3708: F3F0 DD 75 00               LD     (IX+0),L             ;
3709: F3F3 DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
3710: F3F6         ;
3711: F3F6 2A 35 F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
3712: F3F9 09                     ADD    HL,BC                ;  to add to the gross Track        ;
3713: F3FA E5                     PUSH   HL                   ;  which yields the net or          ;
3714: F3FB C1                     POP    BC                   ;  actual track for the record      ;
3715: F3FC CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
3716: F3FF         ;
3717: F3FF C1                     POP    BC                   ; Get the sector within the track   ;
3718: F400 C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
3719: F403         ;
3720: F403         ;--------------------------- Seek ------------------------------------------;
3721: F403         ;--------------------------- Check Sum Utility -----------------------------;
3722: F403         ; At entry                                                                  ;
3723: F403         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
3724: F403         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
3725: F403         ;
3726: F403             CheckSumUtility:                      ;
3727: F403 2A 33 F5               LD     HL,(dpbCKS)          ;
3728: F406 ED 5B 4E F5               LD     DE,(dirRecord)       ;
3729: F40A AF                     XOR    A                    ;
3730: F40B ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
3731: F40D D8                     RET    C                    ;  Entries                      ;
3732: F40E         ;
3733: F40E C5                     PUSH   BC                   ; Save New/Validate Flag        ;
3734: F40F         ;
3735: F40F         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
3736: F40F             ComputeCheckSum:                      ;
3737: F40F 06 80                  LD     B,cpmRecordSize      ;
3738: F411 2A 20 F5               LD     HL,(caDirectoryDMA)  ;
3739: F414 EE 00                  XOR                         ;
3740: F416             ComputeCheckSum1:                      ;
3741: F416 86                     ADD    A,(HL)               ;
3742: F417 23                     INC    HL                   ;
3743: F418 10 FC                  DJNZ   ComputeCheckSum1     ;
3744: F41A         ; Checksum is in ACC	                                                    ;
3745: F41A         ;
3746: F41A 2A 24 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
3747: F41D ED 5B 4E F5               LD     DE,(dirRecord)       ; Index to this record              ;
3748: F421 19                     ADD    HL,DE                ; Address of this record in vector  ;
3749: F422 C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
3750: F423 0C                     INC    C                    ;
3751: F424 CA 31 F4               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
3752: F427         ;
3753: F427 BE                     CP     M                    ; Else we are checking the value    ;
3754: F428 C8                     RET    Z                    ; Exit if OK                        ;
3755: F429         ; possible checksum error, are we beyond the end of the disk?               ;
3756: F429 CD B3 F1               CALL   StillInDirectory     ;
3757: F42C D0                     RET    NC                   ; OK, if not in the directory       ;
3758: F42D CD 8E EF               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
3759: F430 C9                     RET                         ;  Set disk RO before returning     ;
3760: F431         ;
3761: F431         ;initializing the checksum                                                 ;
3762: F431             SetNewCheckSum:                      ;
3763: F431 77                     LD     (HL),A               ;
3764: F432 C9                     RET                         ;
3765: F433         ;--------------------------- Check Sum Utility -----------------------------;
3766: F433         ;*****************************************************************
3767: F433
3768: F433         ;*****************************************************************
3769: F433         ;********************** File  Routines ***************************
3770: F433         ;-----------------------------------------------------------------
3771: F433         ;-----------------------------------------------------------------
3772: F433         ;-----------------------------------------------------------------
3773: F433         ;-----------------------------------------------------------------
3774: F433         ;-----------------------------------------------------------------
3775: F433         ;*****************************************************************
3776: F433
3777: F433         ;-----------------------------------------------------------------
3778: F433         ;-----------------------------------------------------------------
3779: F433
3780: F433         ;-----------------------------------------------------------------
3781: F433         ;-----------------------------------------------------------------
3782: F433
3783: F433
3784: F433
3785: F433
3786: F433         ;---------------------------------- Is Bit Set -----------------------------;
3787: F433
3788: F433
3789: F433
3790: F433         ;---------------------
3791: F433         ;set exitParameterByte to 1
3792: F433
3793: F433         ;---------------------
3794: F433         ;---------------------
3795: F433         ;*****************************************************************
3796: F433         ;************************ Utilities ******************************
3797: F433         ;*****************************************************************
3798: F433             AddAtoHL:
3799: F433 85                     ADD    A,L
3800: F434 6F                     LD     L,A
3801: F435 D0                     RET    NC
3802: F436 24                     INC    H
3803: F437 C9                     RET
3804: F438         ;----------
3805: F438             DEminusHL2HL:
3806: F438 7B                     LD     A,E
3807: F439 95                     SUB    L
3808: F43A 6F                     LD     L,A
3809: F43B 7A                     LD     A,D
3810: F43C 9C                     SBC    A,H
3811: F43D 67                     LD     H,A
3812: F43E C9                     RET
3813: F43F         ;-------------
3814: F43F             ShiftRightHLbyC:
3815: F43F 0C                     INC    C
3816: F440             ShiftRightHLbyC0:
3817: F440 0D                     DEC    C
3818: F441 C8                     RET    Z
3819: F442 7C                     LD     A,H
3820: F443 B7                     OR     A
3821: F444 1F                     RRA
3822: F445 67                     LD     H,A
3823: F446 7D                     LD     A,L
3824: F447 1F                     RRA
3825: F448 6F                     LD     L,A
3826: F449 C3 40 F4               JP     ShiftRightHLbyC0
3827: F44C         ;-------
3828: F44C             ShiftLeftHLbyC:
3829: F44C 0C                     INC    C
3830: F44D             ShiftLeftHLbyC0:
3831: F44D 0D                     DEC    C
3832: F44E C8                     RET    Z                    ; exit when done
3833: F44F 29                     ADD    HL,HL
3834: F450 C3 4D F4               JP     ShiftLeftHLbyC0
3835: F453         ;*****************************************************************
3836: F453         ;? ;move data length of length C from source DE to HL
3837: F453         ;? MoveX:
3838: F453         ;?	INC		C
3839: F453         ;? MoveX0:
3840: F453         ;?	DEC		C
3841: F453         ;?	RET	Z
3842: F453         ;?	LD	A,(DE)
3843: F453         ;?	LD		(HL),A
3844: F453         ;?	INC		DE
3845: F453         ;?	INC		HL
3846: F453         ;?	JP		MoveX0
3847: F453         ;?
3848: F453         ;********** Console OUT Routines*******************??????
3849: F453
3850: F453         ;---------------------------------- Is Bit Set ------------------------------;
3851: F453         ; Enter HL  contains the bit map                                             ;
3852: F453         ;       B   Has the bit number (0...F)                                       ;
3853: F453         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3854: F453         ;              = 0 if bit is set (1)                                         ;
3855: F453             IsBitSet:                       ;
3856: F453 04                     INC    B                    ;
3857: F454             IsBitSetLoop:                      ;
3858: F454 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3859: F455 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3860: F457 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3861: F459 3F                     CCF                         ; else Clear Carry flag              ;
3862: F45A             IsBitSet1:                      ;
3863: F45A CB 1C                  RR     H                    ; Shift thru CY                      ;
3864: F45C CB 1D                  RR     L                    ; ditto                              ;
3865: F45E 10 F4                  DJNZ   IsBitSetLoop         ;
3866: F460 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3867: F462 C9                     RET                         ;
3868: F463         ;---------------------------------- Is Bit Set ------------------------------;
3869: F463
3870: F463         ;============================ Set/Reset Vector Bit ==========================;
3871: F463         ;---------------------------------- Set Vector Bit -------------------------;;
3872: F463         ; Enter  HL  contains the bit map vector                                    ;;
3873: F463         ;        B   Has the bit number (0...F)                                     ;;
3874: F463         ; Return HL  Contains the modified bit map vector                           ;;
3875: F463             SetVectorBit:                      ;;
3876: F463 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3877: F464 CD 53 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3878: F467         ;;
3879: F467 C1                     POP    BC                   ; Get the bit position              ;;
3880: F468 CB FC                  SET    7,H                  ;;
3881: F46A 18 07                  JR     ReAlignVector        ;                                    ;
3882: F46C         ;---------------------------------- Set Vector Bit -------------------------;;
3883: F46C         ;---------------------------------- Reset Vector Bit -----------------------;;
3884: F46C         ; Enter  HL  contains the bit map vector                                    ;;
3885: F46C         ;        B   Has the bit number (0...F)                                     ;;
3886: F46C         ; Return HL  Contains the modified bit map vector                           ;;
3887: F46C             ResetVectorBit:                      ;;
3888: F46C C5                     PUSH   BC                   ; Save the Bit Number               ;;
3889: F46D CD 53 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3890: F470         ;;
3891: F470 C1                     POP    BC                   ; Get the bit position              ;;
3892: F471 CB BC                  RES    7,H                  ;;
3893: F473         ; Fall thru to ReAlignVector                                                 ;
3894: F473         ;---------------------------------- Reset Vector Bit -----------------------;;
3895: F473         ;---------------------------------- Set VectorBit --------------------------;;
3896: F473         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3897: F473         ;
3898: F473             ReAlignVector:                      ;
3899: F473 04                     INC    B                    ;
3900: F474             ReAlignMapLoop:                      ;
3901: F474 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3902: F475 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3903: F477 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3904: F479 3F                     CCF                         ; else Clear Carry flag              ;
3905: F47A             ReAlignMap1:                      ;
3906: F47A CB 15                  RL     L                    ; Shift thru CY                      ;
3907: F47C CB 14                  RL     H                    ; ditto                              ;
3908: F47E 10 F4                  DJNZ   ReAlignMapLoop       ;
3909: F480 C9                     RET                         ;
3910: F481         ;============================ Set/Reset Vector Bit ==========================;
3911: F481         ;************Error message World*************************
3912: F481             errSelect:
3913: F481 21 A0 F4               LD     HL,evSelection
3914: F484 C3 99 F4               JP     GoToError
3915: F487             errReadOnlyDisk:
3916: F487 21 A2 F4               LD     HL,evReadOnlyDisk
3917: F48A C3 99 F4               JP     GoToError
3918: F48D             errReadOnlyFile:
3919: F48D 21 A4 F4               LD     HL,evReadOnlyFile
3920: F490 C3 99 F4               JP     GoToError
3921: F493             errPermanent:
3922: F493 21 9E F4               LD     HL,evPermanent
3923: F496 C3 99 F4               JP     GoToError
3924: F499         ;************Error message handler **********************
3925: F499             GoToError:
3926: F499         ;HL = .errorhandler, call subroutine
3927: F499 5E                     LD     E,(HL)
3928: F49A 23                     INC    HL
3929: F49B 56                     LD     D,(HL)               ; address of routine in DE
3930: F49C EB                     EX     DE,HL
3931: F49D E9                     JP     (HL)                 ; vector to subroutine
3932: F49E         ;************ Error Vectors *****************************
3933: F49E AC F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3934: F4A0 B8 F4       evSelection: DW     erSelection          ; selerr select error subroutine
3935: F4A2 BE F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3936: F4A4 C4 F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3937: F4A6         ;************Error Routines ******************************
3938: F4A6             erPermanentNoWait:
3939: F4A6 21 F6 F4               LD     HL,emPermanent
3940: F4A9 C3 99 F4               JP     GoToError
3941: F4AC             erPermanent:
3942: F4AC 21 F6 F4               LD     HL,emPermanent
3943: F4AF CD CD F4               CALL   displayAndWait       ; to report the error
3944: F4B2 FE 03                  CP     CTRL_C
3945: F4B4 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3946: F4B7 C9                     RET                         ; and ignore the error
3947: F4B8         ;
3948: F4B8             erSelection:
3949: F4B8 21 01 F5               LD     HL,emSelection
3950: F4BB C3 C7 F4               JP     waitB4boot           ; wait console before boot
3951: F4BE         ;
3952: F4BE             erReadOnlyDisk:
3953: F4BE 21 0D F5               LD     HL,emReadOnlyDisk
3954: F4C1 C3 C7 F4               JP     waitB4boot           ; wait console before boot
3955: F4C4         ;
3956: F4C4             erReadOnlyFile:
3957: F4C4 21 08 F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3958: F4C7         ;
3959: F4C7         ; wait for response before boot
3960: F4C7             waitB4boot:
3961: F4C7 CD CD F4               CALL   displayAndWait
3962: F4CA C3 00 00               JP     WarmBoot
3963: F4CD
3964: F4CD         ;report error to console, message address in HL
3965: F4CD             displayAndWait:
3966: F4CD E5                     PUSH   HL                   ; save message pointer
3967: F4CE CD D6 E9               CALL   showCRLF             ; stack mssg address, new line
3968: F4D1 3A 12 F5               LD     A,(currentDisk)
3969: F4D4 C6 41                  ADD    A,ASCII_A
3970: F4D6 32 F2 F4               LD     (emDisk),A           ; Problem disk name
3971: F4D9 01 E6 F4               LD     BC,emDisk0
3972: F4DC CD 3B E9               CALL   Print                ; the error message
3973: F4DF C1                     POP    BC
3974: F4E0 CD 3B E9               CALL   Print                ; error mssage tail
3975: F4E3 C3 21 E9               JP     ConIn                ; to get the input character
3976: F4E6         ;ret
3977: F4E6         ;**************Error Messages*******************************
3978: F4E6 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3979: F4F2 20 3A 20 24     emDisk:    DB     ' : $'
3980: F4F6 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3981: F501 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3982: F508 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3983: F50D 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3984: F511         ;*****************************************************************
3985: F511
3986: F511         ;********* file control block (fcb) constants ********************
3987: F511             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3988: F511             fcbROfileIndex EQU    09H                  ; high order of first type char
3989: F511             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3990: F511             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3991: F511             fcbS1Index EQU    0DH                  ;13				; S1 index
3992: F511             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3993: F511             fcbRCIndex EQU    0FH                  ;15				; record count field index
3994: F511             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3995: F511
3996: F511             fcbCurrentRecord EQU    21H                  ;33
3997: F511
3998: F511             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3999: F511
4000: F511             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
4001: F511             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
4002: F511             dirEntryMask EQU    dirEntriesPerRecord-1
4003: F511             fcbShift   EQU    5                    ; log2(fcbLength)
4004: F511         ;
4005: F511
4006: F511
4007: F511
4008: F511             maxExtValue EQU    31                   ; largest extent number
4009: F511             moduleMask EQU    15                   ; limits module number value
4010: F511             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
4011: F511             nameLength EQU    15                   ;  name length
4012: F511
4013: F511             emptyDir   EQU    0E5H                 ; empty empty directory entry
4014: F511             recordSeq  EQU    fcbLength            ; Next Sequential Record
4015: F511             recordRandom EQU    recordSeq + 1        ; Random record field (2 bytes)
4016: F511             recordRandomLSB EQU    recordRandom         ; LSB of Random Record
4017: F511             recordRandomMSB EQU    recordRandom + 1     ; MSB of Random Record
4018: F511             recordRandomOVF EQU    recordRandom + 2     ; Random Record Overflow
4019: F511         ;
4020: F511         ;	reserved file indicators
4021: F511         ;	equ	11				; reserved
4022: F511         ;*****************************************************************
4023: F511         ;*****************************************************************
4024: F511
4025: F511         ;***common values shared between bdosi and bdos******************
4026: F511 00          currentUserNumber: DB     0                    ; usrcode current user number
4027: F512         ; paramDE:			DS	2					; ParamsDE information address
4028: F512         ; exitParameterByte:
4029: F512         ; exitParameterWord:	DS	2					; address value to return
4030: F512 FF          currentDisk: DB     -1                   ; curdsk current disk number
4031: F513         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
4032: F513
4033: F513         ;********************* Local Variables ***************************
4034: F513         ;     ************************
4035: F513         ;     *** Initialized Data ***
4036: F513
4037: F513 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
4038: F514 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
4039: F516 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
4040: F518 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
4041: F51A
4042: F51A         ;     *** Current Disk attributes ****
4043: F51A         ; These are set upon disk select
4044: F51A         ; data must be adjacent, do not insert variables
4045: F51A         ; address of translate vector, not used
4046: F51A         ; ca - currentAddress
4047: F51A
4048: F51A 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
4049: F51C 00 00       caTrack:   DW     0000H                ; curtrka current track address
4050: F51E 00 00       caSector:  DW     0000H                ; current Sector
4051: F520             caListSizeStart:
4052: F520 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
4053: F522 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
4054: F524 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
4055: F526 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
4056: F528             caListSizeEnd:
4057: F528             caListSize EQU    caListSizeEnd - caListSizeStart
4058: F528
4059: F528         ;     ***** Disk Parameter Block *******
4060: F528         ; data must be adjacent, do not insert variables
4061: F528         ; dpb - Disk Parameter Block
4062: F528             dpbStart:
4063: F528 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
4064: F52A 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
4065: F52B 00          dpbBLM:    DB     00H                  ; blkmsk block mask
4066: F52C 00          dpbEXM:    DB     00H                  ; extmsk extent mask
4067: F52D 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
4068: F52F 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
4069: F531 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
4070: F533 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
4071: F535 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
4072: F537             dpbEnd:
4073: F537             dpbSize    EQU    dpbEnd - dpbStart
4074: F537         ;
4075: F537
4076: F537         ;     ************************
4077: F537             SEQ_ACCESS EQU    01H                  ; Indicates sequential access to file
4078: F537             RANDOM_ACCESS EQU    00H                  ; Indicates random access to file
4079: F537 00          diskAccessType: DB     00H                  ; Set to 1 if sequential disk operation
4080: F538
4081: F538 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
4082: F53A 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
4083: F53B 00          readModeFlag: DB     00H                  ; rmf read mode flag for Open NextExt
4084: F53C 00          directoryIndex: DB     00H                  ; dirloc directory flag in rename, etc.
4085: F53D 00          diskMapIndex: DB     00H                  ; dminx  local for Disk_Write
4086: F53E 00          searchLength: DB     00H                  ; searchl search length
4087: F53F 00 00       searchAddress: DW     0000H                ; searcha search address
4088: F541         ;tinfo:	ds	word							; temp for info in "make"
4089: F541 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
4090: F542 00          fResel:    DB     00H                  ; resel reselection flag
4091: F543 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
4092: F544 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
4093: F545 00          fcbRecordCount: DB     00H                  ; record count from current FCB
4094: F546 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
4095: F547 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
4096: F549 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
4097: F54B         ;
4098: F54B         ;	local variables for directory access
4099: F54B 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
4100: F54C 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
4101: F54E 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
4102: F550
4103: F550         ;********************** data areas ******************************
4104: F550
4105: F550
4106: F550         ;---------------------------------- Stack Area--------------------------------;
4107: F550             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
4108: F590             bdosStack:
4109: F590         ;
4110: F590         ;---------------------------------- Stack Area--------------------------------;
4111: F590         ;	end of Basic I/O System
4112: F590         ;-----------------------------------------------------------------;
4113: F590
4114: F590
4115: F590         ;
4116: F590             Z_HighestLocation:
4117: F590             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
4118: F590
4119: F590
           ************************   Xref   ************************
0000: $               F590   0417 0447
4096: absoluteCPMRecord F549   1611 3416 3457 3469 3484 3678 3685 3703
3798: AddAtoHL        F433
1629: Allocate16Bit   EBEF   1624
1044: AreWeAtEndOfBuffer EA3A   1040
0086: ASCII_A         0041   3969
0087: ASCII_C         0043
0088: ASCII_K         004B
0095: ASCII_LO_A      0061
0096: ASCII_LO_K      006B
0097: ASCII_LO_P      0070
0038: ASCII_MASK      007F   0987
0089: ASCII_N         004E
0090: ASCII_Q         0051
0091: ASCII_R         0052
0092: ASCII_W         0057
0093: ASCII_Y         0059
0073: ASCII_ZERO      0030
0067: ASTERISK        002A
3148: AtEndOfDirectory F193   1432 1758 1947 2091 2422 2453 2511 2603 2931 3496 3526 3534
1136: BackUp          EA9F   1064 1132
1141: BackUp1         EAA7   1137
0295: bcBoot          F600
0298: bcConin         F609   0617 0802 0913 0931
0299: bcConout        F60C   0609 0875 1139 1143 1149 1151
0297: bcConst         F606   0614 0909
0303: bcHome          F618   2668
0300: bcList          F60F   0582 0881
0310: bcListst        F62D
0301: bcPunch         F612   0567
0308: bcRead          F627   2710
0302: bcReader        F615   0548
0311: bcSectran       F630
0304: bcSeldsk        F61B   2325
0307: bcSetdma        F624   2705
0306: bcSetsec        F621   3718
0305: bcSettrk        F61E   2674 3715
0296: bcWboot         F603   0468
0309: bcWrite         F62A   3019
0153: BDOSBase        E800   0154 0156 0326
0122: BDOSE           0005   0123
0154: BDOSEntry       E800
0143: BDOSLength      0E00   0146 0156 0157
4108: bdosStack       F590   0342
0332: BdosStart       E800
0056: BELL            0007
0156: BIOSBase        F600
0144: BIOSLength      0A00   0146
0116: BIOSPAGE        0002
0157: BIOSStart       F600   0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 0311 4117
0253: BlockSize       0800   0275
1059: BSspaceBS       EA48   0998
0034: BYTE            0001   1172
4089: byteAllocationFlag F541   1622 2358 2524 3224 3439
4055: caAllocVector   F526   1851 2378 2380 2405 2829 3277 3344
4054: caCheckSum      F524   3746
4052: caDirectoryDMA  F520   2345 2697 3163 3354 3738
4048: caDirMaxValue   F51A   2336 2412 2727 3197
4053: caDiskParamBlock F522   1968 2350
4057: caListSize      0008   2346
4056: caListSizeEnd   F528   4057
4051: caListSizeStart F520   4057
0094: CARET           005E   0841
0835: CaretOut        E948   1033 1114
4050: caSector        F51E   2342 2682 3707
4081: caSkewTable     F538   2334
4049: caTrack         F51C   2339 2678 3698
0151: CCPEntry        E000   0153 0157
0142: CCPLength       0800   0146 0153 0157
0927: CheckCTL_S      E9AC   0916
2969: CheckExtents    F0B2   2963
3373: CheckRODirectory F27D   1436 1761
3376: CheckROFile     F280   1573
3726: CheckSumUtility F403   3003 3670
3367: CheckWrite      F276   1427 1571 1746 2596
2498: CloseDirEntry   EE8A   1286 3088 3495
2580: CloseDirEntryEnd EEF9   2570
2588: CloseDirEntryError EF05   2540 2550 2555
0074: COLON           003A
1170: columnPosition  EAC1   0860 0885 0950 0970 1128
0069: COMMA           002C
2894: CompareExtents  F04B   2970
3736: ComputeCheckSum F40F
3740: ComputeCheckSum1 F416   3743
0128: ComTail         0080   0129
0130: ComTailChars    0082
0129: ComTailCount    0081   0130
0904: ConBreak        E98C   0728 0871
0937: ConBreak0       E9BA   0929
0939: ConBreak1       E9BD   0907
0795: ConIn           E921   0500 0986 3975
0868: ConsoleOut      E96B   0842 0854 0859 0947 0955 0962 0964 1056
3395: CopyDir         F28E   1764 1952
3353: CopyDirEntryToUserDMA F262   1339 1404
2456: CopyDirRecordToFCB EE50   3539
3389: CopyFCB         F28A   2622
0230: cpmRecordSize   0080   0232 0235 0237 3356 3737 4000
0059: CR              000D   0808 0961 0991 1055
0042: CTRL_C          0003   0932 1038 3944
0043: CTRL_E          0005   1003
0044: CTRL_H          0008   0814 0997 1142
0045: CTRL_K          000B
0046: CTRL_L          000C
0047: CTRL_P          0010   0915 1006
0048: CTRL_R          0012   1015
0049: CTRL_S          0013   0928
0050: CTRL_U          0015   1012
0051: CTRL_X          0018   1009
0052: CTRL_Z          001A
4030: currentDisk     F512   1207 1811 2293 2304 2310 2323 2634 2720 2738 2757 3968
4095: currentFileRecord F547   1495 1505 1575 1653 1686 2783 3030 3424 3480
4026: currentUserNumber F511   0779 0785 2430 2766
0070: DASH            002D
0264: DataBlocks      02C7   0274
0263: DataSectors     0B1C   0264
1431: DeleteFileLoop  EB25   1443
1123: DeleteTheLine   EA8E   1010
1126: DeleteTheLine1  EA8F   1133
3805: DEminusHL2HL    F438
4099: dirBlockIndex   F54B   3164 3662
0235: DirBuffSize     0080
0250: DirectoryBlockCount 0002   0275
0237: DirectoryEntryPerRecord 0004   0278
4084: directoryIndex  F53C   2920 2984 3362
4000: dirEntriesPerRecord 0004   4002
4100: dirEntryIndex   F54C   2980 3139 3149 3195 3645 3647 3656 3675
4002: dirEntryMask    0003   2981 3657
4001: dirEntryShift   0002   3676
0234: DirEntrySize    0020   0237 0275
3361: DirLocationToReturnLoc F26F   1433 1759 1948
4101: dirRecord       F54E   3679 3728 3747
4079: diskAccessType  F537   1488 1565 1675 3028 3045
0222: DiskCommandBlock 0046
0221: DiskControlByte 0045
0224: DiskControlTable 0040
0417: diskf           000B
4085: diskMapIndex    F53D   1589 1618
1490: DiskRead        EB49   2038
0226: DiskReadCode    0001
0231: diskSectorSize  0200   0232 0253 0261
0220: DiskStatusLocation 0043
1567: DiskWrite       EB8F   2229
1660: DiskWrite1      EC1A   1656
1669: DiskWrite2      EC26   1664
1690: DiskWriteCleanup EC46   1673 1677
1688: DiskWriteCleanup0 EC44   1684
0227: DiskWriteCode   0002
1563: DiskWriteSeq    EB8A
3965: displayAndWait  F4CD   3943 3961
3574: DivideHLby8     F359   2373 3263 3266
0133: DMABuffer       0080   1209 4040
0063: DOLLAR          0024   0823 2436
0276: dpb3hdAL0       00C0
0277: dpb3hdAL1       0000
0272: dpb3hdBLM       000F
0271: dpb3hdBSH       0004
0278: dpb3hdCKS       0020
0275: dpb3hdDRM       007F   0278
0274: dpb3hdDSM       02C6
0273: dpb3hdEXM       0000
0280: dpb3hdNOH       0002
0279: dpb3hdOFF       0001
0270: dpb3hdSPT       0090
4065: dpbBLM          F52B   3478
4064: dpbBSH          F52A   3422 3467
4070: dpbCKS          F533   3727
4069: dpbDABM         F531   2403
4068: dpbDRM          F52F   2725 3644
4067: dpbDSM          F52D   2356 2372 2388 3262
4072: dpbEnd          F537   4073
4066: dpbEXM          F52C   2788 2897 3507
4071: dpbOFF          F535   2670 3711
4073: dpbSize         000F   2352
4063: dpbSPT          F528   3686
4062: dpbStart        F528   2351 4073
0449: DUMMY           E8A9   0444 0445
3979: emDisk          F4F2   3970
3978: emDisk0         F4E6   3971
3980: emPermanent     F4F6   3939 3942
4013: emptyDir        00E5   1438 2426 2937 4037
4037: emptyFCB        F513   2599
3983: emReadOnlyDisk  F50D   3953
3982: emReadOnlyFile  F508   3957
3981: emSelection     F501   3949
0137: END_OF_FILE     001A
0040: EndOfMessage    0000
1049: EndRead         EA3E   0992 0995
4091: entryDisk       F543   0390 2758
0292: EOD             FFFF   3138
0078: EQUAL_SIGN      003D
3941: erPermanent     F4AC   3933
3938: erPermanentNoWait F4A6   2712 3021
3952: erReadOnlyDisk  F4BE   3935
3956: erReadOnlyFile  F4C4   3936
3921: errPermanent    F493
3915: errReadOnlyDisk F487   3370
3918: errReadOnlyFile F48D   3382
3912: errSelect       F481   2303
3948: erSelection     F4B8   3934
3933: evPermanent     F49E   3922
3935: evReadOnlyDisk  F4A2   3916
3936: evReadOnlyFile  F4A4   3919
3934: evSelection     F4A0   3913
0061: EXCLAIM_POINT   0021
1174: exitParameterByte EAC5   0509 0618 0729 0755 0780 1506 1607 1641 1681 1812 2440 2500 2589 2982 2996 3092 3099 3111 3118 3126 3363 3543 3622
1175: exitParameterWord EAC5   0346 0397 0549 0638 1788 1852 1898 1969
4094: extentValue     F546   2790
0029: FALSE           0000   0922 1094 1439 1568 2227 2362 2929
0125: FCB1            005C   0126
0126: FCB2            006C
4082: fcbCopiedFlag   F53A   2582 3494 3510
3996: fcbCurrentRecord 0021
4092: fcbDisk         F544   0348 0385 2760
3994: fcbDiskMapIndex 0010   1614 1753 1762 2516 2521 3214 3216 3436
3990: fcbExtIndex     000C   1428 1747 1763 1943 1951 2077 2245 2471 2564 2573 2809 2961 3076 3096 3516
0015: fcbExtIndexLSB  000C
0016: fcbExtIndexMSB  000E
3989: fcbHiddenfileIndex 000A
3987: fcbLength       0020   2465 2521 2564 2614 3216 3391 4000 4014
3993: fcbRCIndex      000F   2095 2474 2492 2573 2798 2801
4093: fcbRecordCount  F545   1496 1654 2786 3034
3988: fcbROfileIndex  0009   3377
3991: fcbS1Index      000D   2618 2958
3992: fcbS2Index      000E   2262 2863 3080 3097 3122 3516
4003: fcbShift        0005   3658
0170: fCloseFile      0010
0161: fConsoleIn      0001
0162: fConsoleOut     0002
0173: fDeleteFile     0013
0165: fGetConsoleStatus 000B
0179: fGetCurrentDisk 0019
0178: fGetLoginVector 0018
0181: fGetSetUserNumber 0020
0166: fGetVersion     000C
1600: FindAvailableBlock EBC6   1592
0176: fMakeFile       0016
0169: fOpenFile       000F
1610: FoundAvailableBlock EBD3   1604
3323: FoundFreeOctet  F23D   3293 3298 3307 3315
3329: FoundFreeOctet1 F243   3325
3331: FoundFreeOctet2 F244   3327
3333: FoundFreeOctet3 F247   3336
3339: FoundFreeOctet4 F24F   3341
0163: fPrintString    0009
0174: fReadSeq        0014
0164: fReadString     000A
0177: fRenameFile     0017
4090: fResel          F542   0349 0379 2748
0167: fResetSystem    000D
0171: fSearchFirst    0011
0172: fSearchNext     0012
0168: fSelectDisk     000E
0180: fSetDMA         001A
0447: functionCount   0028   0358
0404: functionTable   E857   0363 0417 0447
0175: fWriteSeq       0015
3411: GetBlockNumber  F2A5   1511 1579
3259: GetClosestBlock F1EC   1601
3161: GetCurrentDirectoryRecord F19C   1437 2094 2425 2461 2515 2947 3213 3374 3402
3446: GetDiskMap16Bit F2D1   3441
3421: GetDiskMapIndex F2B2   1588 3412
3425: GetDiskMapIndexLoop F2B9   3427
3434: GetDiskMapValue F2BF   1596 3415
2807: GetExtentAddress F002   2457 2787 3499
2861: GetExtentNumberMSB F036   2852
2796: GetFcbRecordDetails EFF5   2780 3027
2090: GetFileSize1    ECE7   2118
2116: GetFileSize2    ED09   2109
2119: GetFileSizeExit ED0F   2092
2928: GetNextDirectoryRecord F071   1403 1442 1766 1953 2117 2966 2971
2946: GetNextDirectoryRecord1 F08E   2938
2238: GetRandomRecordPosition ED37   2096 2152
2860: GetWriteFileFlagValue F036   1636 1666 2504 2872 2883
3925: GoToError       F499   3914 3917 3920 3923 3940
0079: GREATER_THAN    003E
0062: HASH_TAG        0023   0946
1640: HaveWriteBlock  EBFA   1582
3998: highestRecordNumber 007F   1576 1672
2667: Home            EF5E   2411 2926
1146: IgnoreTheLine   EAAC   1013
4040: initDAMAddress  F518   1210 1834 2691 3355
2371: InitDisk        EDD7   2316
2418: InitDisk1       EE1C   2428 2446
2441: InitDisk2       EE3D   2432 2437
2851: InitializeExtentNumberMSB F030   1253 1333 1714
0117: IOBYTE          0003   0637 0657
3855: IsBitSet        F453   2307 2740 3877 3889
3862: IsBitSet1       F45A   3860
3857: IsBitSetLoop    F454   3865
2736: IsDiskWriteProtected EFA6   2501 3368
1011: IsItDeleteTheLineU EA19
1008: IsItDeleteTheLineX EA14
1005: IsItPrintToggle EA0F
1095: IsItPrintToggle1 EA70   1093
0999: IsItRubout      EA05
1002: IsPhysicalEOL   EA0A
0807: IsPrintableASCII E92C   0501 0837
1080: ItIsPhysicalEOL EA5D   1004
1087: ItIsPrintToggle EA65   1007
1068: ItIsRubout      EA52   1001
1164: keyboardByte    EABE   0796 0905 0938
0065: L_PAREN         0028
2836: Left            F021   2838
0082: LEFT_ARROW      005F
0098: LEFT_CURLY      007B
0146: LengthInBytes   2000   0147 0151 0261
0147: LengthInK       0009
0077: LESS_THAN       003C
0058: LF              000A   0810 0891 0963 0993
1109: LL1             EA7E   1117
0032: LO_NIBBLE_MASK  000F   0784 2258
4039: loggedDisks     F516   1205 1787 2306 2312 2314
3291: LookRight       F211   3301
2595: MakeNewFile     EF0A   1716 3109 3533
2401: Mark4Directory  EE04   2393
1634: MarkNewBlock    EBF3   1627
4008: maxExtValue     001F   2906 3502
0149: MemorySize      0040   0151
3602: Merge           F36D   2544 2546
2523: MergeAllocationMaps EEAF   2561
2538: MergeDirEntryNot0 EEC3   2535
2533: MergeFCBisNot0  EEBD   2531
2557: MergeMapLoop    EEDF   2541
2543: MergeWordMaps   EECA   2526
4009: moduleMask      000F   3520
3586: MultiplyHLby8   F363   2387 3347
0262: myOffset        0001   0263 0279
4011: nameLength      000F   1335 2451 2509 2608 2614 3524
2993: NoDirRecordsMatch F0D0   2932 2944
3319: NoFreeBlocks    F239   3308 3316
3303: NoMoreLeft      F223   3299
3305: NoMoreLeftLoop  F224   3309
3311: NoMoreRight     F22E   3294
3313: NoMoreRightLoop F22F   3317
2765: NoSelect        EFD5   2755
1521: NothingRead     EB84   1501 1508 1513
0934: NothingWaiting  E9B8   0925
0054: NULL            0000
0246: NumberOfHeads   0002   0257 0259 0270 0280
0243: NumberOfLogicalDisks 0004
0031: OFF             0000
0030: ON              FFFF
2450: OpenFile        EE47   1255 3098
3492: OpenNextExt     F2F5   1503 1680
3523: OpenNextExt1    F321   3512
3540: OpenNextExt3    F33E   3536
3546: OpenNextExtError F346   3521 3531 3535
3515: OpenNextModule  F317   3504
2490: OpenSetRecordCount EE81   2486 2488
1173: paramDE         EAC3   0337 0383 0680 0972 1051 1106 1327 1401 1572 1613 1751 1833 2080 2150 2464 2491 2519 2597 2600 2605 2617 2749 2767 2797 2808 2862 2923 3047 3399 3435
1172: paramE          EAC2   0339 0391 0776 2292 2753
0064: PERCENT         0025
0071: PERIOD          002E
0120: Pg0CurentDisk   0004
0119: Pg0CurentUser   0004   0120
0068: PLUS_SIGN       002B
0821: Print           E93B   0683 0830 3972 3974
1166: printEchoFlag   EABF   0879 0918 1090
0080: QMARK           003F   1329 2954
1337: QMarkFind       EB05   1330
0066: R_PAREN         0029
0113: RAM             0000   0115 0116 0117 0119 0122 0125 0128 0133 0135
4078: RANDOM_ACCESS   0000
2035: RandomDiskRead  ECC9
2226: RandomDiskWrite ED2E   2204
3043: RandomSeek      F103   2037 2228
3085: RandomSeekClose F146   3078
3123: RandomSeekError F184   3073
3121: RandomSeekErrorBadSeek F180   3094 3107 3113
3115: RandomSeekExit  F17A   3083 3101
2709: ReadBuffer      EF86   1517 3634
3643: ReadDirectory   F38A   2421 2930
3655: ReadDirectory0  F39E   3650
3659: ReadDirectory1  F3A5   3661
3632: ReadDirRecord   F381   3668
1029: ReadEchoRubOut  EA26   1077
4083: readModeFlag    F53B   1492 1569 3529
0982: ReadNext        E9ED   1046 1072 1098 1120
0985: ReadNext0       E9EF   1065 1084
4038: readOnlyVector  F514   1204 1897 2718 2723 2737
0969: ReadString      E9E0   0713 1130 1152
3905: ReAlignMap1     F47A   3903
3900: ReAlignMapLoop  F474   3908
3898: ReAlignVector   F473   3881
1510: RecordOK        EB6E   1498
4015: recordRandom    0021   2081 2153 4016 4017 4018
4016: recordRandomLSB 0021   3050 3053
4017: recordRandomMSB 0022   3055
4018: recordRandomOVF 0023   3069
4014: recordSeq       0020   2151 2801 3075 4015
0255: RecordsPerBlock 0010
0239: RecordsPerExtent 0080   1500 2489 3998
0232: recordsPerSector 0004   0255 0270
1757: RenameLoop      EC66   1767
1101: RepeatLine      EA75   1016
2746: ReselectDisk    EFB1   1254 1285 1334 1402 1426 1485 1558 1715 1745 1942 2032 2072 2203
2882: ResetFileWriteFlag F045
3887: ResetVectorBit  F46C
0378: ReturnToCaller  E832   0352
0394: ReturnToCaller1 E84D   0381 0387 0616
2844: Right           F02B   2842 2846
2653: RotateAndReplace EF57   2656
3560: RotateRightHLbyB F34C   3568
3565: RotateRightHLbyB1 F352   3563
0083: RUBOUT          007F   1000
3211: ScanDiskMap     F1C0   1440 2444
3218: ScanDiskMap0    F1CA   3250
3243: ScanDiskMap2    F1E1   3232
3234: ScanDiskMapWord F1DB   3226
4087: searchAddress   F53F   1400 2924 2934
2918: SearchForDirectoryRecord F05C   1338 1429 1748 1944 2078 2452 2510 2602 3525
4086: searchLength    F53E   2921 2948
0284: SectorMask      0003
0249: SectorsPerBlock 0004   0253 0255 0258 0264 0284
0259: SectorsPerCylinder 0024   0262 0263
0248: SectorsPerTrack 0012   0257 0259 0270
3683: Seek            F3C9   1516 1647 3680
3688: Seek0           F3D3   3692
3674: SeekDir         F3B8   2584 3406 3667
2301: Select          ED70   1212 2297
2291: SelectCurrent   ED64   0392 1236 2763
2322: SelectDisk      ED91   2302
2365: SelectDisk1     EDD3   2361
0076: SEMICOLON       003B
4077: SEQ_ACCESS      0001   1487 1564
3466: SetActualRecordAdd F2DD   1515 1646
3471: SetActualRecordAddLoop F2E4   3473
1946: SetAttributesLoop ECAC   1954
2396: SetBitLoop      EDFF   2399
2632: SetCurrentDiskBit EF44
2690: SetDataDMA      EF78   1211 1835 3008 3635
2696: SetDirDMA       EF7D   3005 3633
3175: SetDirectoryEntry F1AA   2445 2621
2717: SetDiskReadOnly EF8E   1879 3758
2701: SetDMA          EF80   2692
3137: SetEndDirectory F18C   2416 2925 2994 3651
3620: SetExitParamTo1 F37B   1522 1577 3547
2871: SetFileWriteFlag F03F   2469 2624 3127 3548
3762: SetNewCheckSum  F431   3751
2973: SetNextPosition F0B8   2955 2959 2967
2779: SetRecordVars   EFDE   1494 1574 3541
2818: SetResetMapBit  F00A   3246
0783: SetUserNumber   E91B   0778
3875: SetVectorBit    F463   2313 2722
3589: ShiftLeftHLbyB  F365   3593
3828: ShiftLeftHLbyC  F44C   2637
3830: ShiftLeftHLbyC0 F44D   3834
3577: ShiftRightHLbyB F35B   2828 3581 3677
3814: ShiftRightHLbyC F43F
3816: ShiftRightHLbyC0 F440   3826
0960: showCRLF        E9D6   0948 1083 3967
0945: showHashCRLF    E9C0   1104 1147
0949: showHashCRLF1   E9C8   0956
0072: SLASH           002F
0055: SOH             0001
0060: SPACE           0020   0816 0858 0888 0954 1138 1148 1150
0291: STACK_SIZE      0020   4107
4107: stackBottom     F550
1169: startingColumn  EAC0   0951 0971 1127
3194: StillInDirectory F1B3   2942 3176 3756
0261: SystemSectors   0011   0262
0057: TAB             0009   0812 0853
0851: TabOut          E958   0506 0528 0828 0838
0857: TabOut0         E95E   0862
2952: TestNextPosition F097   2978
0923: ToggleFlag1     E9A9   0921
0123: TopRAM          0007
0258: TotalNumberOfBlocks 02D0
0257: TotalNumberOfSectors 0B40   0258 0263
0135: TPA             0100
0247: TracksPerHead   0050   0257
0028: TRUE            FFFF   0919 0940 1091 1491 2036 2359 2366 2420 2443 2581 2747 3002
0081: UNDER_SCORE     005F
3538: UpdateFCB       F33B   3513 3527
3026: UpdateRecordVariables F0F1   1518 1679 1691
1162: usersStack      EABC   0341 0395
1284: vCloseFile      EAEC   0422
2071: vComputeFileSize ECD2   0441
0499: vConsoleIn      E8AD   0406
0527: vConsoleOut     E8BE   0407
1425: vDeleteFile     EB1A   0425
0604: vDirectConIO    E8D1   0411
0613: vDirectConIO1   E8D9   0607
0290: VERSION         0020   0754
1325: vFindFirst      EAF2   0423
1399: vFindNext       EB0B   0424
1850: vGetAllocAddr   EC93   0433
0727: vGetConsoleStatus E900   0416
1810: vGetCurrentDisk EC83   0431
1967: vGetDiskParamBlock ECBF   0437
0636: vGetIOBYTE      E8E7   0412
1786: vGetLoginVector EC7C   0430
1896: vGetReadOnlyMap EC9D   0435
0775: vGetSetUserNumber E90D   0438
0753: vGetVersion     E907   0418
0581: vListOut        E8CD   0410
1713: vMakeFile       EC49   0428
1252: vOpenFile       EAE3   0421
0679: vPrintString    E8F3   0414
0566: vPunchOut       E8C9   0409
0547: vReaderIn       E8C2   0408
2031: vReadRandom     ECC6   0439
1484: vReadSeq        EB41   0426
0712: vReadString     E8FC   0415
1744: vRenameFile     EC52   0429
2185: vResetDrive     ED24   0443
1202: vResetSystem    EAC7   0419
1235: vSelectDisk     EAE0   0420
1832: vSetDMA         EC8A   0432
1941: vSetFileAttributes ECA4   0436
0656: vSetIOBYTE      E8EE   0413
2147: vSetRandomRecord ED11   0442
0467: vSystemReset    E8AA   0405
1878: vWriteProtectDisk EC9A   0434
2202: vWriteRandom    ED27   0440
2218: vWriteRandom0Fill ED2D   0446
1557: vWriteSeq       EB87   0427
3960: waitB4boot      F4C7   3950 3954
0115: WarmBoot        0000   0933 1042 3945 3962
3456: WasBlockAllocated F2D7   1512 1580
0035: WORD            0002   1173 1175
0195: WriteAllocated  0000   1581
3018: WriteBuffer     F0E9   1650 3007
0197: WriteCleanBuffer 0002   1638 1659
3000: WriteDir        F0D9   1441 2585 3407
0196: WriteDirectory  0001   3006
4010: writeFlagMask   0080
4116: Z_HighestLocation F590   4117
4117: Z_MemoryLeft    006F
0039: ZERO            0000
