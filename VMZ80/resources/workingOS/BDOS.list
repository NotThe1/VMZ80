0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800         ; 2017-12-28 Started to refactor to Z80 idiom
0006: E800         ; 2017-03-31 added vector for BDOS Call 5 -ListOut
0007: E800         ; 2017-03-02 Refactored the CP/M Suite
0008: E800         ; 2017-02-12 fixed allocate 16 bit problem
0009: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0010: E800         ; 2014-03-14  :  Frank Martyn
0011: E800
0012: E800
0013: E800                        Include ./stdHeader.Z80
0014: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0015: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0016: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0017: E800         ; stdHeader.asm
0018: E800         ; standard equates
0019: E800
0020: E800         ; 2017-03-02 Refactored the CP/M Suite
0021: E800
0022: E800
0023: E800             TRUE       EQU    -1                   ; not false
0024: E800             FALSE      EQU    0000H
0025: E800             ON         EQU    -1
0026: E800             OFF        EQU    0000H
0027: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0028: E800
0029: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0030: E800             WORD       EQU    2                    ; number of bytes for "word" type
0031: E800
0032: E800
0033: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0034: E800             ZERO       EQU    00H                  ; Zero
0035: E800             EndOfMessage EQU    00H
0036: E800
0037: E800             CTRL_C     EQU    03H                  ; ETX
0038: E800             CTRL_E     EQU    05H                  ; physical eol
0039: E800             CTRL_H     EQU    08H                  ; backspace
0040: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0041: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0042: E800             CTRL_P     EQU    10H                  ; prnt toggle
0043: E800             CTRL_R     EQU    12H                  ; repeat line
0044: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0045: E800             CTRL_U     EQU    15H                  ; line delete
0046: E800             CTRL_X     EQU    18H                  ; =ctl-u
0047: E800             CTRL_Z     EQU    1AH                  ; end of file
0048: E800
0049: E800             NULL       EQU    00H                  ; Null
0050: E800             SOH        EQU    01H                  ; Start of Heading
0051: E800             BELL       EQU    07H                  ; Bell
0052: E800             TAB        EQU    09H                  ; Tab
0053: E800             LF         EQU    0AH                  ; Line Feed
0054: E800             CR         EQU    0DH                  ; Carriage Return
0055: E800             SPACE      EQU    20H                  ; Space
0056: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0057: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0058: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0059: E800             PERCENT    EQU    25H                  ; Percent Sign
0060: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0061: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0062: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0063: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0064: E800             COMMA      EQU    2CH                  ; Comma
0065: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0066: E800             PERIOD     EQU    2EH                  ; Period
0067: E800             SLASH      EQU    2FH                  ; /
0068: E800             ASCII_ZERO EQU    30H                  ; zero
0069: E800             COLON      EQU    3AH                  ; Colon
0070: E800
0071: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0072: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0073: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0074: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0075: E800             QMARK      EQU    3FH                  ; Question Mark
0076: E800             UNDER_SCORE EQU    5FH                  ; under score _
0077: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0078: E800             RUBOUT     EQU    7FH                  ; Delete Key
0079: E800
0080: E800
0081: E800             ASCII_A    EQU    'A'
0082: E800             ASCII_C    EQU    'C'
0083: E800             ASCII_K    EQU    'K'
0084: E800             ASCII_N    EQU    'N'
0085: E800             ASCII_Q    EQU    'Q'
0086: E800             ASCII_R    EQU    'R'
0087: E800             ASCII_W    EQU    'W'
0088: E800             ASCII_Y    EQU    'Y'
0089: E800             CARET      EQU    '^'
0090: E800             ASCII_LO_A EQU    'a'
0091: E800             ASCII_LO_K EQU    'k'
0092: E800             ASCII_LO_P EQU    'p'
0093: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0094: E800
0095: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0096: E800                        Include ./osHeader.Z80
0097: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0098: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0099: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0100: E800         ; osHeader.Z80
0101: E800
0102: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0103: E800         ; 2017-03-02 Refactored the CP/M Suite
0104: E800
0105: E800         ; Contains the Equates used by the CP/M system
0106: E800
0107: E800         ;------------------------Page Zero Constants ---------------------------------
0108: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0109: E800
0110: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0111: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0112: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0113: E800
0114: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0115: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0116: E800
0117: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0118: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0119: E800
0120: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0121: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0122: E800
0123: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0124: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0125: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0126: E800         ;-----------------------------------------------------------------------
0127: E800
0128: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0129: E800         ;-----------------------------------------------------------------------
0130: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0131: E800         ;-----------------------------------------------------------------------
0132: E800             END_OF_FILE EQU    1AH                  ; end of file
0133: E800         ;-----------------------------------------------------------------------
0134: E800
0135: E800         ;--------------- CP/M Constants -----------------------------------------
0136: E800
0137: E800             CCPLength  EQU    0800H                ; Constant
0138: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0139: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0140: E800
0141: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0142: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0143: E800
0144: E800             MemorySize EQU    64
0145: E800
0146: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0147: E800
0148: E800             BDOSBase   EQU    CCPEntry + CCPLength
0149: E800             BDOSEntry  EQU    BDOSBase
0150: E800
0151: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0152: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0153: E800         ;-----------------------------------------------------------------------
0154: E800
0155: E800         ;------------------- BDOS System Call Equates --------------------------
0156: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0157: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0158: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0159: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0160: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0161: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0162: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0163: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0164: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0165: E800             fCloseFile EQU    10H                  ; closef - Close File
0166: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0167: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0168: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0169: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0170: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0171: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0172: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0173: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0174: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0175: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0176: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0177: E800         ;-----------------------------------------------------------------------
0178: E800
0179: E800
0180: E800
0181: E800
0182: E800
0183: E800         ;*******************************************************************************
0184: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0185: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0186: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0187: E800         ; sector write) or to an allocation block that has already been allocated to a
0188: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0189: E800         ;*******************************************************************************
0190: E800             WriteAllocated EQU    00H
0191: E800             WriteDirectory EQU    01H
0192: E800             WriteCleanBuffer EQU    02H
0193: E800
0194: E800
0195: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0196: E800                        Include ./diskHeader.Z80
0197: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0198: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0199: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0200: E800         ; diskHeader.asm
0201: E800
0202: E800         ; 2017-03-02 Refactored the CP/M Suite
0203: E800
0204: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0205: E800
0206: E800         ; Contains the Equates used by the CP/M system to handle disks
0207: E800
0208: E800
0209: E800         ;*******************************************************************************
0210: E800         ;
0211: E800         ;     Disk related values
0212: E800         ;
0213: E800         ;
0214: E800         ;*******************************************************************************
0215: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0216: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0217: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0218: E800         ; for boot
0219: E800             DiskControlTable EQU    0040H
0220: E800
0221: E800             DiskReadCode EQU    01H                  ; Code for Read
0222: E800             DiskWriteCode EQU    02H                  ; Code for Write
0223: E800
0224: E800
0225: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0226: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0227: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0228: E800
0229: E800             DirEntrySize EQU    20H                  ; (32)
0230: E800             DirBuffSize EQU    cpmRecordSize
0231: E800
0232: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0233: E800
0234: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0235: E800
0236: E800
0237: E800         ;-------------------------------------------------------------------------------------
0238: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0239: E800
0240: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0241: E800             NumberOfHeads EQU    02H                  ; number of heads
0242: E800             TracksPerHead EQU    50H                  ; 80
0243: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0244: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0245: E800             DirectoryBlockCount EQU    02H                  ;
0246: E800         ;-----------------------------------------------------------------------
0247: E800
0248: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0249: E800
0250: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0251: E800
0252: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0253: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0254: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0255: E800
0256: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0257: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0258: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0259: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0260: E800
0261: E800         ;-----------------------------------------------------------------------
0262: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0263: E800         ;-----------------------------------------------------------------------
0264: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0265: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0266: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0267: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0268: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0269: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0270: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0271: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0272: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0273: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0274: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0275: E800             dpb3hdNOH  EQU    NumberOfHeads
0276: E800
0277: E800         ;*******************************************************************************
0278: E800
0279: E800             SectorMask EQU    SectorsPerBlock - 1
0280: E800
0281: E800         ;***************************************************************************
0282: E800
0283: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0284: E800
0285: E800             VERSION    EQU    20H                  ; Version 2.0
0286: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0287: E800             EOD        EQU    -1                   ; End of Directory
0288: E800
0289: E800         ;************************ BIOS Function Constants ***************************;
0290: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	              ;
0291: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                  ;
0292: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function             ;
0293: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function              ;
0294: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function             ;
0295: E800             bcList     EQU    BIOSStart+3*5        ; List Output function                ;
0296: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function               ;
0297: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function               ;
0298: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                  ;
0299: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function                ;
0300: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                  ;
0301: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                 ;
0302: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                    ;
0303: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                  ;
0304: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                 ;
0305: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function                ;
0306: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                    ;
0307: E800         ;************************ BIOS Function Constants ***************************;
0308: E800
0309: E800         ;=============================================================================;
0310: E800         ;	BDOS                                                                      ;
0311: E800         ; Calling into   :                                                            ;
0312: E800         ;                	Register  C - Contains BDOS Function Code                 ;
0313: E800         ;                	Register  A - Holds the Byte argument if any              ;
0314: E800         ;                	Register DE - Holds the Word argument if any              ;
0315: E800         ; Returning from :                                                            ;
0316: E800         ;                	Register  A - The Byte return value if any                ;
0317: E800         ;                	Register HL - The Word return value if any                ;
0318: E800         ;                   ( Register A=L and B=H)                                   ;
0319: E800         ;=============================================================================;
0320: E800
0321: E800
0322: E800                        ORG    BDOSBase
0323: E800
0324: E800         ;===========================BDOS Entry========================================;
0325: E800         ;BDOSEntry:                                                                   ;
0326: E800         ;
0327: E800             BdosStart:                      ;
0328: E800         ;	LD		A,C                                                               ;
0329: E800         ; 	LD		(FunctionValue),A			; Save the function number            ;
0330: E800         ;
0331: E800         ; Save Calling Arguments                                                      ;
0332: E800 ED 53 DF EA               LD     (paramDE),DE         ; Save the Word Argument              ;
0333: E804 7B                     LD     A,E                  ;
0334: E805 32 DE EA               LD     (paramE),A           ; Save the Byte argument              ;
0335: E808         ; Save users Stack pointer                                                    ;
0336: E808 ED 73 D7 EA               LD     (usersStack),SP      ; We will use our own stack           ;
0337: E80C         ;
0338: E80C         ; initialize variables                                                        ;
0339: E80C 21 00 00               LD     HL,0000H             ;
0340: E80F 22 E1 EA               LD     (exitParameterWord),HL ; Assume all is well for return       ;
0341: E812 AF                     XOR    A                    ;
0342: E813 32 66 F5               LD     (fcbDisk),A          ; Initialize to 00                    ;
0343: E816 32 64 F5               LD     (fResel),A           ; Clear re selection flag             ;
0344: E819         ;
0345: E819         ; Set up for return to caller when Function Completes                         ;
0346: E819 21 2F E8               LD     HL,ReturnToCaller    ;
0347: E81C E5                     PUSH   HL                   ;Set up to ReturnToCaller             ;
0348: E81D         ;
0349: E81D         ; is it a valid fuction number ?	                                          ;
0350: E81D         ;	LD		A,(FunctionValue)			; Get the Function Number             ;
0351: E81D 79                     LD     A,C                  ;
0352: E81E FE 28                  CP     functionCount        ; make sure its a good number         ;
0353: E820 D0                     RET    NC                   ; exit if not a valid function        ;
0354: E821         ;
0355: E821         ; Calculate the index and get vector to go to	                              ;
0356: E821 4B                     LD     C,E                  ; Assume byte argument                ;
0357: E822 21 56 E8               LD     HL,functionTable     ; Get table base                      ;
0358: E825 5F                     LD     E,A                  ; Function number in E                ;
0359: E826 16 00                  LD     D,0                  ;
0360: E828 19                     ADD    HL,DE                ; Have byte location                  ;
0361: E829 19                     ADD    HL,DE                ;  but we want a Word offset          ;
0362: E82A 5E                     LD     E,(HL)               ; Get LSB of vector                   ;
0363: E82B 23                     INC    HL                   ;
0364: E82C 56                     LD     D,(HL)               ; Get MSB of vector                   ;
0365: E82D EB                     EX     DE,HL                ; Vector now in HL                    ;
0366: E82E         ;
0367: E82E         ; Load vector into HL                                         ;
0368: E82E E9                     JP     (HL)                 ; Move to Program Counter             ;
0369: E82F         ;===========================BDOS Entry========================================;
0370: E82F         ;===========================BDOS Exit ========================================;
0371: E82F         ;arrive here at end of processing to return to user                          ;
0372: E82F             ReturnToCaller:                      ;
0373: E82F 3A 64 F5               LD     A,(fResel)           ; get re-selection flag               ;
0374: E832 B7                     OR     A                    ; is it set?                          ;
0375: E833 CA 4C E8               JP     Z,ReturnToCaller1    ;
0376: E836         ;re-selection  may have taken place                                          ;
0377: E836 2A DF EA               LD     HL,(paramDE)         ;
0378: E839 36 00                  LD     (HL),0               ;
0379: E83B 3A 66 F5               LD     A,(fcbDisk)          ;
0380: E83E B7                     OR     A                    ; Disk = 0?                           ;
0381: E83F CA 4C E8               JP     Z,ReturnToCaller1    ; exit if yes                  		  ;
0382: E842         ;
0383: E842 77                     LD     (HL),A               ;
0384: E843 3A 65 F5               LD     A,(entryDisk)        ; get back original Disk              ;
0385: E846 32 DE EA               LD     (paramE),A           ; and select it                       ;
0386: E849 CD 6D EC               CALL   SelectCurrent        ;
0387: E84C         ;
0388: E84C             ReturnToCaller1:                      ;
0389: E84C 2A D7 EA               LD     HL,(usersStack)      ;
0390: E84F F9                     LD     SP,HL                ; restore callers stack               ;
0391: E850 2A E1 EA               LD     HL,(exitParameterWord) ;
0392: E853 7D                     LD     A,L                  ;
0393: E854 44                     LD     B,H                  ; BA = exitParameterWord               ;
0394: E855 C9                     RET                         ;
0395: E856         ;===========================BDOS Exit ========================================;
0396: E856
0397: E856         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++++;
0398: E856             functionTable:                      ;
0399: E856 A9 E8                  DW     vSystemReset         ;   0 - System Reset                  ;
0400: E858 AC E8                  DW     vConsoleIn           ;   1 - Console Input                 ;
0401: E85A BD E8                  DW     vConsoleOut          ;   2 - Console Output                ;
0402: E85C C1 E8                  DW     vReaderIn            ;   3 - Reader Input                  ;
0403: E85E C8 E8                  DW     vPunchOut            ;   4 - Punch Output                  ;
0404: E860 CC E8                  DW     vListOut             ;   5 - List Output                   ;
0405: E862 D0 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O            ;
0406: E864 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                  ;
0407: E866 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                  ;
0408: E868 F3 E8                  DW     vPrintString         ;   9 - Print String                  ;
0409: E86A FC E8                  DW     vReadString          ;   A - Read Console String           ;
0410: E86C 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status            ;
0411: E86E             diskf      EQU    ($-functionTable)/2  ; disk functions                      ;
0412: E86E 99 F4                  DW     vGetVersion          ;   C - Return Version Number         ;
0413: E870 19 EC                  DW     vResetSystem         ;   D - Reset Disk System             ;
0414: E872 32 EC                  DW     vSelectDisk          ;   E - Select Disk                   ;
0415: E874 5B EF                  DW     vOpenFile            ;   F - Open File                     ;
0416: E876 64 EF                  DW     vCloseFile           ;  10 - Close File                    ;
0417: E878 6A EF                  DW     vFindFirst           ;  11 - Search For First              ;
0418: E87A 83 EF                  DW     vFindNext            ;  12 - Search for Next               ;
0419: E87C 92 EF                  DW     vDeleteFile          ;  13 - Delete File                   ;
0420: E87E 9B EF                  DW     vReadSeq             ;  14 - Read Sequential               ;
0421: E880 A2 EF                  DW     vWriteSeq            ;  15 - Write Sequential              ;
0422: E882 A9 EF                  DW     vMakeFile            ;  16 - Make File                     ;
0423: E884 B2 EF                  DW     vRenameFile          ;  17 - Rename File                   ;
0424: E886 35 EC                  DW     vGetLoginVector      ;  18 - Return Login Vector           ;
0425: E888 3C EC                  DW     vGetCurrentDisk      ;  19 - Return Current Disk           ;
0426: E88A 43 EC                  DW     vSetDMA              ;  1A - Set DMA address               ;
0427: E88C 4C EC                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)              ;
0428: E88E 53 EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk            ;
0429: E890 56 EC                  DW     vGetRoVector         ;  1D - Get Read/Only Vector          ;
0430: E892 5D EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??        ;
0431: E894 66 EC                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)    ;
0432: E896 07 E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code             ;
0433: E898 E3 EA                  DW     vReadRandom          ;  21 - Read Random                   ;
0434: E89A E9 EA                  DW     vWriteRandom         ;  22 - Write Random                  ;
0435: E89C EF EA                  DW     vComputeFileSize     ;  23 - Compute File Size             ;
0436: E89E F5 EA                  DW     vSetRandomRecord     ;  24 - Set Random Record             ;
0437: E8A0 F8 EA                  DW     vResetDrive          ;  25 - Reset Drive                   ;
0438: E8A2 A8 E8                  DW     DUMMY                ;  26 - Access Drive (not supported)  ;
0439: E8A4 A8 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)    ;
0440: E8A6 F9 EA                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill           ;
0441: E8A8             functionCount EQU    ($-functionTable)/2  ; Number of  functions                ;
0442: E8A8         ;
0443: E8A8             DUMMY:                          ;
0444: E8A8 76                     HALT                        ;
0445: E8A9         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++++;
0446: E8A9
0447: E8A9         ;-------------------------- System Reset - 0 (0) -----------------------------;
0448: E8A9         ;  The system reset function makes CP/M do a complete reset, exactly the same ;
0449: E8A9         ; as the warm boot function invoked when you transfer control to the WARMBOOT ;
0450: E8A9         ; point. In addition to resetting the BDOS, this function reloads the CCP,    ;
0451: E8A9         ; rebuilds the allocation vectors for the currently logged disks, sets the    ;
0452: E8A9         ; DMA address (used byCP/M to address the disk read/write buffer) to 80H,     ;
0453: E8A9         ; marks all disks as being Read/Write status, and transfers control to the    ;
0454: E8A9         ; CCP. The CCP then outputs its prompt to the console.                        ;
0455: E8A9         ;																			  ;
0456: E8A9         ;			Function Code	 :	C = 00H                                       ;
0457: E8A9         ;           Entry Parameters:	None                                          ;
0458: E8A9         ;           Exit Parameters :	Does Not Return								  ;
0459: E8A9         ;																			  ;
0460: E8A9         ;-------------------------- System Reset - 0 (0) -----------------------------;
0461: E8A9             vSystemReset:
0462: E8A9 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0463: E8AC
0464: E8AC         ;*****************************************************************************;
0465: E8AC         ;								IOByte device I/O							  ;
0466: E8AC         ;*****************************************************************************;
0467: E8AC
0468: E8AC
0469: E8AC         ;-------------------------- Read Console Byte - 1 (1) ------------------------;
0470: E8AC         ;  This function reads the next byte of data from the console keyboard and    ;
0471: E8AC         ; puts it into register A. If the character input is a graphic character, it  ;
0472: E8AC         ; will be echoed back to the console. The only control characters that are    ;
0473: E8AC         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case     ;
0474: E8AC         ; of a TAB character, the BDOS outputs as many spaces as are required to      ;
0475: E8AC         ; move the cursor to the next multiple of eight columns. All of the other     ;
0476: E8AC         ; control characters, including CONTROL-C, are input but are not echoed.      ;
0477: E8AC         ;  This function also checks for CONTROL-S (XOFF) to see if console output    ;
0478: E8AC         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if      ;
0479: E8AC         ; console output should also be sent to the list device. If CONTROL-S is      ;
0480: E8AC         ; found, further output will be suspended until you type another character.   ;
0481: E8AC         ; CONTROL-P will enable the echoing of console output the first time it is    ;
0482: E8AC         ; pressed and disable it the second time. If there is no incoming data        ;
0483: E8AC         ; character, this function will wait until there is one.                      ;
0484: E8AC         ;                                                                             ;
0485: E8AC         ; This is a blocking function                                                 ;
0486: E8AC         ;																			  ;
0487: E8AC         ;																			  ;
0488: E8AC         ;			Function Code	:	C = 01H                                       ;
0489: E8AC         ;           Entry Parameters:	None                                          ;
0490: E8AC         ;           Exit Parameters :	A = Data byte from console					  ;
0491: E8AC         ;																			  ;
0492: E8AC         ;-------------------------- Read Console Byte - 1 (1) ------------------------;
0493: E8AC             vConsoleIn:
0494: E8AC CD 1C E9               CALL   ConIn                ; Don't come back without input
0495: E8AF CD 27 E9               CALL   isPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0496: E8B2 D8                     RET    C                    ; return nothing to echo
0497: E8B3
0498: E8B3 F5                     PUSH   AF                   ; Save printable character
0499: E8B4 4F                     LD     C,A
0500: E8B5 CD 55 E9               CALL   TabOut               ; Send to console. if TAB expand
0501: E8B8 F1                     POP    AF                   ; retrieve exit value
0502: E8B9
0503: E8B9 32 E1 EA               LD     (exitParameterByte),A
0504: E8BC C9                     RET
0505: E8BD
0506: E8BD         ;------------------------- Write Console Byte - 2 (2) ------------------------;
0507: E8BD         ;  This function outputs the data byte in register E to the console. As with  ;
0508: E8BD         ; function 1, if the data byte is a TAB character, it will be expanded by the ;
0509: E8BD         ; BDOS to the next column that is a multiple of eight. The BDOS also checks   ;
0510: E8BD         ; to see if there is an incoming character, and if there is, checks to see if ;
0511: E8BD         ; it is a CONTROL-S ,in which case console output is suspended or CONTROL-P,  ;
0512: E8BD         ; in which case echoing of console output to the printer is toggled on or off);
0513: E8BD         ;																			  ;
0514: E8BD         ;			Function Code	:	C = 02H                                       ;
0515: E8BD         ;           Entry Parameters:	E = Data byte to be output					  ;
0516: E8BD         ;           Exit Parameters :	None										  ;
0517: E8BD         ;																			  ;
0518: E8BD         ;------------------------- Write Console Byte - 2 (2) ------------------------;
0519: E8BD         ;BDOS put parameter in C before entering this routine
0520: E8BD             vConsoleOut:
0521: E8BD CD 55 E9               CALL   TabOut
0522: E8C0 C9                     RET
0523: E8C1
0524: E8C1         ;--------------------------- Read Reader Byte - 3 (3) ------------------------;
0525: E8C1         ;   function reads the next character from the logical "reader" device into   ;
0526: E8C1         ; register A. In practice, the physical device that is accessed depends       ;
0527: E8C1         ; entirely on how your BIOS is configured. In some systems, there is no       ;
0528: E8C1         ; reader at all; this function will return some arbitrary value such as lAH   ;
0529: E8C1         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').      ;
0530: E8C1         ; Control is not returned to the calling program until a character has been   ;
0531: E8C1         ; read.                                                                       ;
0532: E8C1         ;                                                                             ;
0533: E8C1         ; This is a blocking function                                                 ;
0534: E8C1         ;																			  ;
0535: E8C1         ;			Function Code	:	C = 03H                                       ;
0536: E8C1         ;           Entry Parameters:	None										  ;
0537: E8C1         ;           Exit Parameters :	A = Character Input							  ;
0538: E8C1         ;																			  ;
0539: E8C1         ;--------------------------- Read Reader Byte - 3 (3) ------------------------;
0540: E8C1             vReaderIn:
0541: E8C1 CD 15 F6               CALL   bcReader
0542: E8C4 32 E1 EA               LD     (exitParameterWord),A
0543: E8C7 C9                     RET
0544: E8C8
0545: E8C8         ;--------------------------- Write Punch Byte - 4 (4) ------------------------;
0546: E8C8         ;  This function is a counterpart to the Read "Reader" Byte It outputs the    ;
0547: E8C8         ; specified character from register E to the logical punch device. Again, the ;
0548: E8C8         ; actual physical device used, if any, is determined by the BIOS. There is no ;
0549: E8C8         ; set standard for this device; in some systems the punch device is a         ;
0550: E8C8         ; "bit bucket," so called because it absorbs all data that you output to it.  ;
0551: E8C8         ;																			  ;
0552: E8C8         ;			Function Code	:	C = 04H                                       ;
0553: E8C8         ;           Entry Parameters:	E = Data byte to be output					  ;
0554: E8C8         ;           Exit Parameters :	None										  ;
0555: E8C8         ;																			  ;
0556: E8C8         ;--------------------------- Write Punch Byte - 4 (4) ------------------------;
0557: E8C8         ;BDOS put parameter in C before entering this routine
0558: E8C8             vPunchOut:
0559: E8C8 CD 12 F6               CALL   bcPunch
0560: E8CB C9                     RET
0561: E8CC
0562: E8CC         ;---------------------------- Write List Byte - 5 (5) ------------------------;
0563: E8CC         ;  This function outputs the specified byte in register E to the logical list ;
0564: E8CC         ; device. As with the reader and the punch, the physical device used depends  ;
0565: E8CC         ; entirely on the BIOS.                                                       ;
0566: E8CC         ;																			  ;
0567: E8CC         ;			Function Code	:	C = 05H                                       ;
0568: E8CC         ;           Entry Parameters:	E = Data byte to be output					  ;
0569: E8CC         ;           Exit Parameters :	None										  ;
0570: E8CC         ;																			  ;
0571: E8CC         ;---------------------------- Write List Byte - 5 (5) ------------------------;
0572: E8CC         ;BDOS put parameter in C before entering this routine
0573: E8CC             vListOut:                       ; func5 (05 - 05) List Output
0574: E8CC CD 0F F6               CALL   bcList               ; direct call to BIOS
0575: E8CF C9                     RET
0576: E8D0
0577: E8D0         ;--------------------------- Direct Console I/O - 6 (6) ----------------------;
0578: E8D0         ;  This function serves double duty: it both inputs and outputs characters    ;
0579: E8D0         ; from the console. However, it bypasses the normal control characters and    ;
0580: E8D0         ; line editing features (such as CONTROL-P and CONTROL-S) normally associated ;
0581: E8D0         ; with console I( O. Hence the name "direct" (or "unadorned" as Digital       ;
0582: E8D0         ; Research describes it). If the value in register E is not OFFH, then E      ;
0583: E8D0         ; contains a valid ASCII character that is output to the console.             ;
0584: E8D0         ;  This function works well provided you never have to send a value ofOFFH or ;
0585: E8D0         ; expect to receive a value ofOOH. Ifyou do need to send or receive pure      ;
0586: E8D0         ; binary data, you cannot use this function, since these values are likely to ;
0587: E8D0         ; be part of the data stream.                                                 ;
0588: E8D0         ;                                                                             ;
0589: E8D0         ;			Function Code	:	C = 06H                                       ;
0590: E8D0         ;           Entry Parameters:	E = 0FFH for Input					  		  ;
0591: E8D0         ;								E = Other than 0FFH for Output				  ;
0592: E8D0         ;           Exit Parameters :	A = Input byte or status					  ;
0593: E8D0         ;																			  ;
0594: E8D0         ;--------------------------- Direct Console I/O - 6 (6) ----------------------;
0595: E8D0         ;BDOS put parameter in C before entering this routine
0596: E8D0             vDirectConIO:
0597: E8D0 79                     LD     A,C
0598: E8D1 3C                     INC    A
0599: E8D2 CA D9 E8               JP     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0600: E8D5         ; send byte to console
0601: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0602: E8D8 C9                     RET
0603: E8D9
0604: E8D9         ;read byte/status from console
0605: E8D9             vDirectConIO1:
0606: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0607: E8DC B7                     OR     A                    ; 00 means not data ready
0608: E8DD CA 4C E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0609: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0610: E8E3 32 E1 EA               LD     (exitParameterByte),A ; Save it
0611: E8E6 C9                     RET
0612: E8E7
0613: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ----------------------;
0614: E8E7         ; This function places the current value of the IOBYTE in register A.         ;
0615: E8E7         ;                                                                             ;
0616: E8E7         ; The IOBYTE structure:                                                       ;
0617: E8E7         ;								+-------+-------+-------+-------+             ;
0618: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |             ;
0619: E8E7         ;								+-------+-------+-------+-------+             ;
0620: E8E7         ;				Logical Device     List | Punch | Reader|Console              ;
0621: E8E7         ;                                                                             ;
0622: E8E7         ;                                                                             ;
0623: E8E7         ;			Function Code	:	C = 07H                                       ;
0624: E8E7         ;           Entry Parameters:	None					  		  			  ;
0625: E8E7         ;           Exit Parameters :	A = Current IOBYTE value					  ;
0626: E8E7         ;																			  ;
0627: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ----------------------;
0628: E8E7             vGetIOBYTE:
0629: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0630: E8EA 32 E1 EA               LD     (exitParameterWord),A ; Return it to caller
0631: E8ED C9                     RET
0632: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ----------------------;
0633: E8EE         ; This function sets the IOBYTE         ;
0634: E8EE         ;                                                                             ;
0635: E8EE         ; The IOBYTE structure:                                                       ;
0636: E8EE         ;								+-------+-------+-------+-------+             ;
0637: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |             ;
0638: E8EE         ;								+-------+-------+-------+-------+             ;
0639: E8EE         ;				Logical Device     List | Punch | Reader|Console              ;
0640: E8EE         ;                                                                             ;
0641: E8EE         ;                                                                             ;
0642: E8EE         ;			Function Code	:	C = 08H                                       ;
0643: E8EE         ;           Entry Parameters:	E = New IOBYTE value	  		  			  ;
0644: E8EE         ;           Exit Parameters :	None					  ;
0645: E8EE         ;																			  ;
0646: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ----------------------;
0647: E8EE         ;BDOS put parameter in C before entering this routine
0648: E8EE             vSetIOBYTE:
0649: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0650: E8F1 71                     LD     (HL),C               ; Place new vale in it
0651: E8F2 C9                     RET
0652: E8F3
0653: E8F3         ;---------------------- Display $ terminated String - 9 (9) ------------------;
0654: E8F3         ;  This function outputs a string of characters to the console device. The    ;
0655: E8F3         ; address of this string is in registers DE. You must make sure that the last ;
0656: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker    ;
0657: E8F3         ; for the end of the string.                                                  ;
0658: E8F3         ;  The "$" itself does not get output to the console.                         ;
0659: E8F3         ;                                                                             ;
0660: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously      ;
0661: E8F3         ; described, checks to see if there is an incoming character, and checks for  ;
0662: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered) ;
0663: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to        ;
0664: E8F3         ; the printer).                                                               ;
0665: E8F3         ;                                                                             ;
0666: E8F3         ;			Function Code	:	C = 09H                                       ;
0667: E8F3         ;           Entry Parameters:	DE = Address of the first byte of the string  ;
0668: E8F3         ;           Exit Parameters :	None					  ;                   ;
0669: E8F3         ;																			  ;
0670: E8F3         ;---------------------- Display $ terminated String - 9 (9) ------------------;
0671: E8F3             vPrintString:
0672: E8F3 2A DF EA               LD     HL,(paramDE)         ; Get address of the string
0673: E8F6 4D                     LD     C,L
0674: E8F7 44                     LD     B,H                  ; Put it into BC for call
0675: E8F8 CD 36 E9               CALL   Print                ; out to console
0676: E8FB C9                     RET
0677: E8FC         ;----------
0678: E8FC         ;read String from Console until limit or CR is reached
0679: E8FC         ;In - (DE) = limit
0680: E8FC         ;Out - (DE+1) = count of chars read (DE+2) = characters read
0681: E8FC             vReadString:                      ; func10 (10 - 0A)	read String from console
0682: E8FC CD E5 E9               CALL   ReadString
0683: E8FF C9                     RET
0684: E900         ;------------------------- Read Console Status - B (11) ----------------------;
0685: E900         ; This function tells you whether a console input character is waiting to be  ;
0686: E900         ;processed. Unlike the Console Input functions, which will wait until there   ;
0687: E900         ;is input,this function simply checks and returns immediately.                ;
0688: E900         ;                                                                             ;
0689: E900         ;			Function Code	:	C = 0BH                                       ;
0690: E900         ;           Entry Parameters:	None										  ;
0691: E900         ;           Exit Parameters :	A = 00H if no incoming Data					  ;
0692: E900         ;								A = FFH	if incoming Data					  ;
0693: E900         ;																			  ;
0694: E900         ;------------------------- Read Console Status - B (11) ----------------------;
0695: E900
0696: E900         ;check console status
0697: E900             vGetConsoleStatus:                      ; func11 (11 - 01)	read Dollar terminated String from console
0698: E900 CD A0 E9               CALL   ConBreak
0699: E903 32 E1 EA               LD     (exitParameterByte),A
0700: E906 C9                     RET
0701: E907         ;----------
0702: E907         ;get/set user code
0703: E907         ; IN - (E) = FF its a get else user Number(0-15)
0704: E907         ; OUT - (A) Current user number or no value
0705: E907             vGetSetUserNumber:                      ; func32 (32 - 20)	Get or set User code
0706: E907 3A DE EA               LD     A,(paramE)
0707: E90A FE FF                  CP     0FFH
0708: E90C C2 16 E9               JP     NZ,SetUserNumber     ; interrogate user code instead
0709: E90F 3A 2F F5               LD     A,(currentUserNumber)
0710: E912 32 E1 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0711: E915 C9                     RET
0712: E916
0713: E916             SetUserNumber:                      ; setusrcode
0714: E916 E6 0F                  AND    LO_NIBBLE_MASK
0715: E918 32 2F F5               LD     (currentUserNumber),A
0716: E91B C9                     RET
0717: E91C
0718: E91C         ;****************************************************************************;
0719: E91C         ;								Character Support Routines					 ;
0720: E91C         ;****************************************************************************;
0721: E91C
0722: E91C         ;****************************************************************************;
0723: E91C         ; 								Console Routines							 ;
0724: E91C         ;****************************************************************************;
0725: E91C
0726: E91C         ;-------------------- Return a Character from the console -------------------;
0727: E91C         ;return byte from buffer or read from the console                            ;
0728: E91C             ConIn:                          ;
0729: E91C 21 D9 EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0730: E91F 7E                     LD     A,(HL)               ;
0731: E920 36 00                  LD     (HL),0               ;
0732: E922 B7                     OR     A                    ;
0733: E923 C0                     RET    NZ                   ;
0734: E924         ;
0735: E924 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0736: E927         ;-------------------- Return a Character from the console -------------------;
0737: E927
0738: E927         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0739: E927         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0740: E927             isPrintableASCII:                      ;
0741: E927 FE 0D                  CP     CR                   ;
0742: E929 C8                     RET    Z                    ; carriage return?                                                  ;
0743: E92A FE 0A                  CP     LF                   ;
0744: E92C C8                     RET    Z                    ; line feed?                                                        ;
0745: E92D FE 09                  CP     TAB                  ;
0746: E92F C8                     RET    Z                    ; TAB?                                                              ;
0747: E930 FE 08                  CP     CTRL_H               ;
0748: E932 C8                     RET    Z                    ; backspace?                                                        ;
0749: E933 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0750: E935 C9                     RET                         ;
0751: E936         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0752: E936
0753: E936         ;------------------ Print character from (BC) until  $ found ----------------;
0754: E936             Print:                          ;
0755: E936 0A                     LD     A,(BC)               ; Get the next character             ;
0756: E937 FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0757: E939 C8                     RET    Z                    ;  exit if yes                       ;
0758: E93A 03                     INC    BC                   ; Update the pointer                 ;
0759: E93B C5                     PUSH   BC                   ; Save it                            ;
0760: E93C 4F                     LD     C,A                  ; Does Byte require                  ;
0761: E93D CD 55 E9               CALL   TabOut               ;  special attention - check         ;
0762: E940 C1                     POP    BC                   ; Retrieve the pointer				 ;
0763: E941 C3 36 E9               JP     Print                ; Loop back                          ;
0764: E944         ;------------------ Print character from (BC) until  $ found ----------------;
0765: E944
0766: E944         ;-- Send printable character to console. Precede with Caret if needed -------;
0767: E944         ; character is in Reg C                                                      ;
0768: E944             CaretCout:                      ;
0769: E944 79                     LD     A,C                  ;
0770: E945 CD 27 E9               CALL   isPrintableASCII     ;
0771: E948 D2 55 E9               JP     NC,TabOut            ; Skip if Caret not needed           ;
0772: E94B         ; send preceding up arrow                                                    ;
0773: E94B F5                     PUSH   AF                   ; Save the character                 ;
0774: E94C 0E 5E                  LD     C,CARET              ;
0775: E94E CD 69 E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0776: E951 F1                     POP    AF                   ; Get the character                  ;
0777: E952 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0778: E954 4F                     LD     C,A                  ; Set up to print                    ;
0779: E955         ; fall thru to TabbOut                                                       ;
0780: E955         ;-- Send printable character to console. Precede with Caret if needed -------;
0781: E955
0782: E955         ;------------- Send printable character to console. Expand if TAB -----------;
0783: E955         ; character is in Reg C                                                      ;
0784: E955             TabOut:                         ;
0785: E955 79                     LD     A,C                  ;
0786: E956 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0787: E958 C2 69 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0788: E95B         ;
0789: E95B         ; TAB encountered                                                           ;
0790: E95B             TabOut0:                        ;
0791: E95B 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0792: E95D CD 69 E9               CALL   ConsoleOut           ; Send to Console                    ;
0793: E960 3A DD EA               LD     A,(columnPosition)   ; Get Column position                ;
0794: E963 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0795: E965 C2 5B E9               JP     NZ,TabOut0           ; Do again if not                    ;
0796: E968 C9                     RET                         ;
0797: E969         ;------------- Send printable character to console. Expand if TAB -----------;
0798: E969
0799: E969         ;------------- Send character to console. Manage Column Positions -----------;
0800: E969             ConsoleOut:                      ;                                                                           ;
0801: E969         ; is it at the start of line                                                 ;
0802: E969 3A DB EA               LD     A,(manageColPosFlag) ; Get manage Column Position Flag    ;
0803: E96C B7                     OR     A                    ;
0804: E96D C2 83 E9               JP     NZ,ConsoleOut1       ; Skip if not managing               ;
0805: E970         ;                                                                         ;
0806: E970         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0807: E970 C5                     PUSH   BC                   ; Save character to output in Reg C  ;
0808: E971 CD A0 E9               CALL   ConBreak             ; Check for screen stop function	 ;
0809: E974 C1                     POP    BC                   ;
0810: E975 C5                     PUSH   BC                   ; Get/save character                 ;
0811: E976         ; Send character to Console	                                                 ;
0812: E976 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0813: E979 C1                     POP    BC                   ;
0814: E97A C5                     PUSH   BC                   ; Get/save character                 ;
0815: E97B         ; is the data to be output to print device?                                 ;
0816: E97B 3A DA EA               LD     A,(printEchoFlag)    ;
0817: E97E B7                     OR     A                    ;
0818: E97F C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0819: E982         ;	CP		TRUE                                                             ;
0820: E982         ;	CALL	Z,bcList                                                         ;
0821: E982 C1                     POP    BC                   ; Get the character                  ;
0822: E983         ;
0823: E983             ConsoleOut1:                      ;
0824: E983 79                     LD     A,C                  ; Move character to ACC              ;
0825: E984 21 DD EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0826: E987 FE 7F                  CP     RUBOUT               ;
0827: E989 C8                     RET    Z                    ; Column Position does not change    ;
0828: E98A         ;
0829: E98A 34                     INC    M                    ; Increment the columnPosition       ;
0830: E98B FE 20                  CP     SPACE                ;
0831: E98D D0                     RET    NC                   ; Exit if ASCII printable            ;
0832: E98E         ;
0833: E98E 35                     DEC    M                    ; columnPosition = columnPosition - 1;
0834: E98F 7E                     LD     A,(HL)               ;
0835: E990 B7                     OR     A                    ;
0836: E991 C8                     RET    Z                    ; return if at beginning             ;
0837: E992         ;										                                     ;
0838: E992 79                     LD     A,C                  ; Move character to ACC              ;
0839: E993 FE 08                  CP     CTRL_H               ;
0840: E995 C2 9A E9               JP     NZ,NotBackSpace      ; skip if not a Backspace            ;
0841: E998         ;
0842: E998 35                     DEC    M                    ; columnPosition = columnPosition - 1;
0843: E999 C9                     RET                         ;
0844: E99A         ;
0845: E99A             NotBackSpace:                      ;
0846: E99A FE 0A                  CP     LF                   ;
0847: E99C C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0848: E99D         ;
0849: E99D 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0850: E99F C9                     RET                         ; and exit                           ;
0851: E9A0         ;------------- Send character to console. Manage Column Positions -----------;
0852: E9A0
0853: E9A0         ;--------------------  Check for Status and Control S or C ------------------;
0854: E9A0         ;  Returns:																	 ;
0855: E9A0         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0856: E9A0         ;			ACC = 00   No data Pending										 ;
0857: E9A0         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0858: E9A0         ;                                                                            ;
0859: E9A0             ConBreak:                       ;
0860: E9A0 3A D9 EA               LD     A,(keyboardByte)     ;
0861: E9A3 B7                     OR     A                    ;
0862: E9A4 C2 D3 E9               JP     NZ,ConBreak1         ; Return with FF in ACC              ;
0863: E9A7         ;
0864: E9A7 CD 06 F6               CALL   bcConst              ; Get status                         ;
0865: E9AA FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0866: E9AC C8                     RET    Z                    ; Return 00 No data pending          ;
0867: E9AD         ;
0868: E9AD CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0869: E9B0         ;
0870: E9B0         ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>            ;
0871: E9B0 FE 10                  CP     CTRL_P               ;
0872: E9B2 20 0D                  JR     NZ,CheckCTL_S        ;
0873: E9B4 21 DA EA               LD     HL,printEchoFlag     ;
0874: E9B7 3E FF                  LD     A,TRUE               ;
0875: E9B9 BE                     CP     (HL)                 ;
0876: E9BA 20 02                  JR     NZ,ToggleFlag1       ;
0877: E9BC 3E 00                  LD     A,FALSE              ;
0878: E9BE             ToggleFlag1:                      ;
0879: E9BE 77                     LD     (HL),A               ;
0880: E9BF 18 0D                  JR     NothingWaiting       ;
0881: E9C1             CheckCTL_S:                      ;
0882: E9C1         ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>           ;
0883: E9C1 FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0884: E9C3 C2 D0 E9               JP     NZ,ConBreak0         ;   and and return 0FFH              ;
0885: E9C6         ;
0886: E9C6 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0887: E9C9 FE 03                  CP     CTRL_C               ;
0888: E9CB CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0889: E9CE             NothingWaiting:                      ;              ;
0890: E9CE AF                     XOR    A                    ;
0891: E9CF C9                     RET                         ; Set ACC = 0 and return             ;
0892: E9D0             ConBreak0:                      ;
0893: E9D0 32 D9 EA               LD     (keyboardByte),A     ; save the byte                      ;
0894: E9D3             ConBreak1:                      ;
0895: E9D3 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0896: E9D5 C9                     RET                         ;
0897: E9D6         ;--------------------  Check for Status and Control S or C ------------------;
0898: E9D6
0899: E9D6         ;------------------------  Console Output Utilities -------------------------;
0900: E9D6             showHashCRLF:                      ;
0901: E9D6 0E 23                  LD     C,HASH_TAG           ;
0902: E9D8 CD 69 E9               CALL   ConsoleOut           ; Send # to console                  ;
0903: E9DB         ;Send the Carriage Return Line Feed sequence                                 ;
0904: E9DB             showCRLF:                       ;
0905: E9DB 0E 0D                  LD     C,CR                 ;
0906: E9DD CD 69 E9               CALL   ConsoleOut           ;
0907: E9E0 0E 0A                  LD     C,LF                 ;
0908: E9E2 C3 69 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0909: E9E5         ;
0910: E9E5         ;------------------------  Console Output Utilities -------------------------;
0911: E9E5
0912: E9E5         ;------------------------- Read a $ terminated String -----------------------;
0913: E9E5         ;read to paramDE address (max length, current length, buffer)               ;
0914: E9E5             ReadString:                      ;
0915: E9E5 3A DD EA               LD     A,(columnPosition)   ;
0916: E9E8 32 DC EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0917: E9EB 2A DF EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0918: E9EE 4E                     LD     C,(HL)               ; Set character for later BIOS Call  ;
0919: E9EF 23                     INC    HL                   ;
0920: E9F0 E5                     PUSH   HL                   ; Save the pointer                   ;
0921: E9F1 06 00                  LD     B,0                  ; Initialize buffer length           ;
0922: E9F3         ; B = current buffer length,                                                ;
0923: E9F3         ; C = maximum buffer length,                                                ;
0924: E9F3         ; HL= next to fill - 1                                                      ;
0925: E9F3         ;
0926: E9F3         ; read next character, BC, HL active                                        ;
0927: E9F3             ReadNext:                       ;
0928: E9F3 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0929: E9F4 E5                     PUSH   HL                   ; Save pointer                       ;
0930: E9F5             ReadNext0:                      ;
0931: E9F5 CD 1C E9               CALL   ConIn                ; Get the next Character             ;
0932: E9F8 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0933: E9FA E1                     POP    HL                   ; Restore Pointer					 ;
0934: E9FB C1                     POP    BC                   ; Restore Current Index and Max Count;
0935: E9FC         ;Is It Carriage Return                                                       ;
0936: E9FC FE 0D                  CP     CR                   ;
0937: E9FE CA C3 EA               JP     Z,EndRead            ; End the read if yes                ;
0938: EA01 FE 0A                  CP     LF                   ;
0939: EA03         ;Is It Linefeed                                                              ;
0940: EA03 CA C3 EA               JP     Z,EndRead            ; End the read if yes                ;
0941: EA06         ;Is It BackSpace                                                             ;
0942: EA06 FE 08                  CP     CTRL_H               ;
0943: EA08 C2 1B EA               JP     NZ,IsItRubout        ; Skip if not Backspace              ;
0944: EA0B         ;Do we have any characters to back over?                                     ;
0945: EA0B 78                     LD     A,B                  ; B has the current Column           ;
0946: EA0C B7                     OR     A                    ;
0947: EA0D CA F3 E9               JP     Z,ReadNext           ; Just go read next if at start      ;
0948: EA10         ;Characters remain in buffer, backup one                                     ;
0949: EA10 05                     DEC    B                    ; Decrement the Index                ;
0950: EA11 3A DD EA               LD     A,(columnPosition)   ; Update the current Column Position ;
0951: EA14 2B                     DEC    HL                   ; Decrement the pointer				 ;
0952: EA15 32 DB EA               LD     (manageColPosFlag),A ; Set the manage Column Pos Flag     ;
0953: EA18         ; temp_ColumnPosition > 0 marks repeat as length compute                     ;
0954: EA18 C3 60 EA               JP     LineLengthOrRepeat   ; uses same code as repeat     		 ;
0955: EA1B         ;
0956: EA1B             IsItRubout:                      ;
0957: EA1B FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
0958: EA1D C2 2B EA               JP     NZ,IsPhysicalEOL     ; Skip if not Rubout                 ;
0959: EA20         ; RUBOUT if possible                                                         ;
0960: EA20 78                     LD     A,B                  ; Are we at the start of the line    ;
0961: EA21 B7                     OR     A                    ;
0962: EA22 CA F3 E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
0963: EA25         ;adjust pointers back one                                                    ;
0964: EA25 7E                     LD     A,(HL)               ; ACC = current character            ;
0965: EA26 05                     DEC    B                    ; Adjust the index			    	 ;                                                                ;
0966: EA27 2B                     DEC    HL                   ; Adjust the pointer                 ;
0967: EA28 C3 AB EA               JP     ReadEcho             ; Echo back - Full Duplex            ;
0968: EA2B         ;
0969: EA2B             IsPhysicalEOL:                      ;
0970: EA2B FE 05                  CP     CTRL_E               ;
0971: EA2D C2 3C EA               JP     NZ,IsItPrintToggle   ; Skip if not physical end line?     ;
0972: EA30 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0973: EA31 E5                     PUSH   HL                   ; Save pointer                       ;
0974: EA32 CD DB E9               CALL   showCRLF             ; Make new line                      ;
0975: EA35 AF                     XOR    A                    ;
0976: EA36 32 DC EA               LD     (startingColumn),A   ; Set start column to 00             ;
0977: EA39 C3 F5 E9               JP     ReadNext0            ;   and go for next char   			 ;
0978: EA3C         ;
0979: EA3C             IsItPrintToggle:                      ;
0980: EA3C FE 10                  CP     CTRL_P               ;
0981: EA3E C2 51 EA               JP     NZ,IsItDeleteTheLineX ; Skip if not CTRL_P	             ;
0982: EA41 E5                     PUSH   HL                   ; Save pointer                       ;
0983: EA42         ; Toggle the printEcho Flag                                                  ;
0984: EA42 21 DA EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
0985: EA45 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
0986: EA47 BE                     CP     (HL)                 ; Is the flag true?                  ;
0987: EA48 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
0988: EA4A 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
0989: EA4C             IsItPrintToggle1:                      ;
0990: EA4C 77                     LD     (HL),A               ; Set the Flags new Value	         ;
0991: EA4D E1                     POP    HL                   ; Restore pointer                    ;
0992: EA4E C3 F3 E9               JP     ReadNext             ;   and for another char             ;
0993: EA51         ;
0994: EA51             IsItDeleteTheLineX:                      ;
0995: EA51 FE 18                  CP     CTRL_X               ;
0996: EA53 CA 89 EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
0997: EA56             IsItDeleteTheLineU:                      ;
0998: EA56 FE 15                  CP     CTRL_U               ;
0999: EA58 CA 89 EA               JP     Z,DeleteTheLine      ; If CTRL_U go delete the line       ;
1000: EA5B         ;
1001: EA5B         ;	CP		CTRL_R                                                           ;
1002: EA5B         ;JP		ReadEcho					; display char, no more CTRL chars   ;
1003: EA5B         ;
1004: EA5B         ;Retype the line ?                                                           ;
1005: EA5B FE 12                  CP     CTRL_R               ;
1006: EA5D C2 A8 EA               JP     NZ,ReadEcho1         ; No control chars, so echo it       ;
1007: EA60         ;
1008: EA60             LineLengthOrRepeat:                      ;
1009: EA60         ; repeat line, or compute line len (CTRL_H) if temp_ColumnPosition > 0       ;
1010: EA60 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1011: EA61 CD D6 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1012: EA64 E1                     POP    HL                   ; Restore Pointer					 ;
1013: EA65 C1                     POP    BC                   ; Restore Character and Length       ;
1014: EA66 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1015: EA67 E5                     PUSH   HL                   ; Save pointer                       ;
1016: EA68             Repeat:                         ;
1017: EA68 78                     LD     A,B                  ;
1018: EA69 B7                     OR     A                    ; Index at the Start?				 ;
1019: EA6A CA 7A EA               JP     Z,Repeat1            ;   get out if yes                   ;
1020: EA6D 23                     INC    HL                   ;
1021: EA6E 4E                     LD     C,(HL)               ; Get the current char               ;
1022: EA6F 05                     DEC    B                    ; Decrement the Index                ;
1023: EA70 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1024: EA71 E5                     PUSH   HL                   ; Save pointer                       ;
1025: EA72 CD 44 E9               CALL   CaretCout            ; Character to be echoed             ;
1026: EA75 E1                     POP    HL                   ; Restore Pointer					 ;
1027: EA76 C1                     POP    BC                   ; Restore Character and Length       ;
1028: EA77 C3 68 EA               JP     Repeat               ; Loop                               ;
1029: EA7A             Repeat1:                        ; rep1:                          ;
1030: EA7A         ; end of repeat, recall lengths original BC still remains pushed             ;
1031: EA7A E5                     PUSH   HL                   ; Save the Pointer                   ;
1032: EA7B 3A DB EA               LD     A,(manageColPosFlag) ; See if we are managing             ;
1033: EA7E B7                     OR     A                    ;  the columns.                      ;
1034: EA7F CA F5 E9               JP     Z,ReadNext0          ; If not then go fro next input      ;
1035: EA82         ; columnPosition position computed for CTRL_H                                ;
1036: EA82 21 DD EA               LD     HL,columnPosition    ;
1037: EA85 96                     SUB    M                    ; Decrement the Pointer              ;
1038: EA86 32 DB EA               LD     (manageColPosFlag),A ; Save as Set manage Column flag     ;
1039: EA89         ; move back temp_ColumnPosition-columnPosition spaces                        ;
1040: EA89             DeleteTheLine:                      ;
1041: EA89 E1                     POP    HL                   ; Adjust Stack                       ;
1042: EA8A         ; loop while columnPosition > startingColumn                                 ;
1043: EA8A             DeleteTheLine1:                      ;
1044: EA8A 3A DC EA               LD     A,(startingColumn)   ;
1045: EA8D 21 DD EA               LD     HL,columnPosition    ;
1046: EA90 BE                     CP     M                    ; Start of line ?                    ;
1047: EA91 D2 E5 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1048: EA94 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1049: EA95 CD CA EA               CALL   BackUp               ; Clear 1 column                     ;
1050: EA98 C3 8A EA               JP     DeleteTheLine1       ; Loop for more                      ;
1051: EA9B         ;
1052: EA9B         ;.......................... move back one more space  .......................;
1053: EA9B             BackSpace:                      ;
1054: EA9B CD CA EA               CALL   BackUp               ; one space                      ;
1055: EA9E 21 DB EA               LD     HL,manageColPosFlag  ;
1056: EAA1 35                     DEC    M                    ;
1057: EAA2 C2 9B EA               JP     NZ,BackSpace         ;
1058: EAA5 C3 F5 E9               JP     ReadNext0            ; for next character	         ;
1059: EAA8         ;.......................... move back one more space  .......................;
1060: EAA8
1061: EAA8         ;....................... Echo input back to the Console  ....................;
1062: EAA8         ; Full Duplex								                                 ;
1063: EAA8         ;
1064: EAA8         ; B = current buffer length, (index)                                         ;
1065: EAA8         ; C = maximum buffer length,                                                 ;
1066: EAA8         ; HL= next to fill - 1 (Pointer)                                             ;
1067: EAA8             ReadEcho1:
1068: EAA8 23                     INC    HL                   ; Advance the Pointer                ;
1069: EAA9 77                     LD     (HL),A               ; Get the current char               ;
1070: EAAA 04                     INC    B                    ; Increment the command length       ;
1071: EAAB         ;
1072: EAAB             ReadEcho:                       ;
1073: EAAB C5                     PUSH   BC                   ; Save index and length              ;
1074: EAAC E5                     PUSH   HL                   ; Save the Pointer                   ;
1075: EAAD 4F                     LD     C,A                  ; Get char                           ;
1076: EAAE CD 44 E9               CALL   CaretCout            ; Output to Console (^ if needed)    ;
1077: EAB1 E1                     POP    HL                   ; Restore the Pointer                ;
1078: EAB2 C1                     POP    BC                   ; Restore index and length           ;
1079: EAB3 7E                     LD     A,(HL)               ; Recall char                        ;
1080: EAB4         ; check for Warm Boot                                                        ;
1081: EAB4 FE 03                  CP     CTRL_C               ;
1082: EAB6 78                     LD     A,B                  ; Get Line position                  ;
1083: EAB7 C2 BF EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1084: EABA FE 01                  CP     1                    ; Beginning of the Line?             ;
1085: EABC CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1086: EABF         ; Check to see if we are at the end of the buffer                            ;
1087: EABF             AreWeAtEndOfBuffer:                      ;
1088: EABF B9                     CP     C                    ; Over Max ?					     ;
1089: EAC0 DA F3 E9               JP     C,ReadNext           ;  no, Go for more				     ;
1090: EAC3         ;
1091: EAC3         ; At the end of read                                  					     ;
1092: EAC3             EndRead:                        ;
1093: EAC3 E1                     POP    HL                   ;
1094: EAC4 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1095: EAC5 0E 0D                  LD     C,CR                 ;
1096: EAC7 C3 69 E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1097: EACA         ;....................... Echo input back to the Console  ....................;
1098: EACA         ;------------------------- Read a $ terminated String -----------------------;
1099: EACA
1100: EACA         ;------------------------ Back-up one screen position -----------------------;
1101: EACA             BackUp:                         ;
1102: EACA CD D2 EA               CALL   BackUp1              ; Send Backspace                     ;
1103: EACD 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1104: EACF CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1105: EAD2         ;does not affect column count                                                ;
1106: EAD2             BackUp1:                        ;
1107: EAD2 0E 08                  LD     C,CTRL_H             ;
1108: EAD4 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1109: EAD7         ;------------------------ Back-up one screen position -----------------------;
1110: EAD7
1111: EAD7         ;****************************************************************************
1112: EAD7         ;                           DATA AREA                                       *
1113: EAD7         ;****************************************************************************
1114: EAD7
1115: EAD7         ;------------------------------Non Disk Data Area ---------------------------;
1116: EAD7             usersStack: DS     2                    ; entry stack pointer                ;
1117: EAD9         ;
1118: EAD9 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1119: EADA         ;
1120: EADA 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1121: EADB         ;
1122: EADB         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1123: EADB 00          manageColPosFlag: DB     0                    ; Non-Zero if managing col pos       ;
1124: EADC 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1125: EADD 00          columnPosition: DB     0                    ; Current Column position            ;
1126: EADE         ;
1127: EADE             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1128: EADF             paramDE:   DS     WORD                 ; Word Argument for BDOS Call    ;
1129: EAE1             exitParameterByte:                      ; Byte returned Value                ;
1130: EAE1             exitParameterWord: DS     WORD                 ; Word                           ;
1131: EAE3         ;
1132: EAE3         ;
1133: EAE3         ;------------------------------------ Data Area -----------------------------;
1134: EAE3
1135: EAE3
1136: EAE3
1137: EAE3         ;*****************************************************************************;
1138: EAE3         ;								Disk I/O									  ;
1139: EAE3         ;*****************************************************************************;
1140: EAE3
1141: EAE3
1142: EAE3         ;*****************************************************************
1143: EAE3         ;random disk read
1144: EAE3         ;IN  - (DE) FCB address
1145: EAE3         ;OUT - (A) 01 = Reading unwritten data
1146: EAE3         ;	 02 = N/U
1147: EAE3         ;	 03 = Cannot close current extent
1148: EAE3         ;	 04 = Seek to unwriten Extent
1149: EAE3         ;	 05 = N/U
1150: EAE3         ;	 06 = Seek past Physical end of Disk
1151: EAE3             vReadRandom:                      ; func33 (33 - 21) Read Random record
1152: EAE3 CD F0 F2               CALL   Reselect
1153: EAE6 C3 FA EA               JP     RandomDiskRead       ; to perform the disk read
1154: EAE9         ;*****************************************************************
1155: EAE9         ;write random record
1156: EAE9         ;IN  - (DE) FCB address
1157: EAE9         ;OUT - (A) 01 = Reading unwritten data
1158: EAE9         ;	 02 = N/U
1159: EAE9         ;	 03 = Cannot close current extent
1160: EAE9         ;	 04 = Seek to unwriten Extent
1161: EAE9         ;	 05 = Cannot create new Extent because of directory overflow
1162: EAE9         ;	 06 = Seek past Physical end of Disk
1163: EAE9             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1164: EAE9 CD F0 F2               CALL   Reselect
1165: EAEC C3 03 EB               JP     RandomDiskWrite      ; to perform the disk write
1166: EAEF         ;ret ;jmp goback
1167: EAEF         ;*****************************************************************
1168: EAEF         ;return file size (0-65536)
1169: EAEF         ;IN  - (DE) FCB address
1170: EAEF             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1171: EAEF CD F0 F2               CALL   Reselect
1172: EAF2 C3 B0 EB               JP     GetFileSize
1173: EAF5         ;*****************************************************************
1174: EAF5         ;set random record
1175: EAF5         ;IN  - (DE) FCB address
1176: EAF5         ;OUT - Random Record Field is set
1177: EAF5             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1178: EAF5 C3 9D EB               JP     SetRandomRecord
1179: EAF8         ;*****************************************************************
1180: EAF8         ;Reset Drive
1181: EAF8         ;IN  - (DE) Drive Vector
1182: EAF8         ;OUT - (A) 00
1183: EAF8             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1184: EAF8         ; Not Yet Implemented   **************
1185: EAF8 C9                     RET
1186: EAF9         ;*****************************************************************
1187: EAF9         ;*****************************************************************
1188: EAF9         ;Write Random With Zero Fill
1189: EAF9         ;IN  - (DE) FCB address
1190: EAF9         ;OUT - (A) Return Code		see Function 34
1191: EAF9             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1192: EAF9         ; Not Yet Implemented   **************
1193: EAF9 C9                     RET
1194: EAFA         ;*****************************************************************
1195: EAFA         ;******************< Random I/O Stuff ****************************
1196: EAFA         ;*****************************************************************
1197: EAFA         ;random disk read
1198: EAFA             RandomDiskRead:                      ; randiskread
1199: EAFA 0E FF                  LD     C,TRUE               ; marked as read operation
1200: EAFC CD 0C EB               CALL   RandomSeek
1201: EAFF CC E2 EF               CALL   Z,DiskRead           ; if seek successful
1202: EB02 C9                     RET
1203: EB03         ;*****************************************************************
1204: EB03         ;random disk write
1205: EB03             RandomDiskWrite:                      ; randiskwrite
1206: EB03 0E 00                  LD     C,FALSE              ; marked as read operation
1207: EB05 CD 0C EB               CALL   RandomSeek
1208: EB08 CC 25 F0               CALL   Z,DiskWrite          ; if seek successful
1209: EB0B C9                     RET
1210: EB0C         ;*****************************************************************
1211: EB0C         ;*****************************************************************
1212: EB0C         ;random access seek operation, C=0ffh if read mode
1213: EB0C         ;fcb is assumed to address an active file control block
1214: EB0C         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1215: EB0C             RandomSeek:
1216: EB0C AF                     XOR    A
1217: EB0D 32 5E F5               LD     (seqReadFlag),A      ; marked as random access operation
1218: EB10 C5                     PUSH   BC                   ; save r/w flag
1219: EB11 2A DF EA               LD     HL,(paramDE)
1220: EB14 EB                     EX     DE,HL                ; DE will hold base of fcb
1221: EB15 21 21 00               LD     HL,RANDOM_REC_FIELD
1222: EB18 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1223: EB19 7E                     LD     A,(HL)
1224: EB1A E6 7F                  AND    7FH
1225: EB1C F5                     PUSH   AF                   ; record number
1226: EB1D 7E                     LD     A,(HL)
1227: EB1E 17                     RLA                         ; cy=lsb of extent#
1228: EB1F 23                     INC    HL
1229: EB20 7E                     LD     A,(HL)
1230: EB21 17                     RLA
1231: EB22 E6 1F                  AND    11111B               ; A=ext#
1232: EB24 4F                     LD     C,A                  ; C holds extent number, record stacked
1233: EB25 7E                     LD     A,(HL)
1234: EB26 1F                     RRA
1235: EB27 1F                     RRA
1236: EB28 1F                     RRA
1237: EB29 1F                     RRA
1238: EB2A E6 0F                  AND    1111B                ; mod#
1239: EB2C 47                     LD     B,A                  ; B holds module#, C holds ext#
1240: EB2D F1                     POP    AF                   ; recall sought record #
1241: EB2E         ;check to insure that high byte of ran rec = 00
1242: EB2E 23                     INC    HL
1243: EB2F 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1244: EB30 2C                     INC    L
1245: EB31 2D                     DEC    L
1246: EB32 2E 06                  LD     L,06                 ; zero flag, l=6
1247: EB34         ; produce error 6, seek past physical eod
1248: EB34 C2 95 EB               JP     NZ,RandomSeekError
1249: EB37         ; otherwise, high byte = 0, A = sought record
1250: EB37 21 20 00               LD     HL,NEXT_RECORD
1251: EB3A 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1252: EB3B 77                     LD     (HL),A               ; sought rec# stored away
1253: EB3C         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1254: EB3C         ; the r/w flag is still stacked.  compare fcb values
1255: EB3C 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1256: EB3F 19                     ADD    HL,DE
1257: EB40 79                     LD     A,C                  ; A=seek ext#
1258: EB41 96                     SUB    M
1259: EB42 C2 50 EB               JP     NZ,RandomSeekClose   ; tests for = extents
1260: EB45         ; extents match, check mod#
1261: EB45 21 0E 00               LD     HL,fcbS2Index
1262: EB48 19                     ADD    HL,DE
1263: EB49 78                     LD     A,B                  ; B=seek mod#
1264: EB4A         ; could be overflow at eof, producing module#
1265: EB4A         ; of 90H or 10H, so compare all but fwf
1266: EB4A 96                     SUB    M
1267: EB4B E6 7F                  AND    7FH
1268: EB4D CA 88 EB               JP     Z,RandomSeekExit     ; same?
1269: EB50             RandomSeekClose:
1270: EB50 C5                     PUSH   BC
1271: EB51 D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1272: EB52 CD C5 F1               CALL   CloseDirEntry        ; current extent closed
1273: EB55 D1                     POP    DE
1274: EB56 C1                     POP    BC                   ; recall parameters and fill
1275: EB57 2E 03                  LD     L,03                 ; cannot close error #3
1276: EB59 3A E1 EA               LD     A,(exitParameterByte)
1277: EB5C 3C                     INC    A
1278: EB5D CA 8E EB               JP     Z,RandomSeekErrorBadSeek
1279: EB60 21 0C 00               LD     HL,fcbExtIndex
1280: EB63 19                     ADD    HL,DE
1281: EB64 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1282: EB65 21 0E 00               LD     HL,fcbS2Index
1283: EB68 19                     ADD    HL,DE
1284: EB69 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1285: EB6A CD 1D F3               CALL   OpenFile             ; is the file present?
1286: EB6D 3A E1 EA               LD     A,(exitParameterByte)
1287: EB70 3C                     INC    A
1288: EB71 C2 88 EB               JP     NZ,RandomSeekExit    ; open successful?
1289: EB74         ; cannot open the file, read mode?
1290: EB74 C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1291: EB75 C5                     PUSH   BC                   ; everyone expects this item stacked
1292: EB76 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1293: EB78 0C                     INC    C                    ; becomes 00 if read operation
1294: EB79 CA 8E EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1295: EB7C CD 6D F1               CALL   MakeNewFile          ; write operation, make new extent
1296: EB7F 2E 05                  LD     L,05                 ; cannot create new extent #5
1297: EB81 3A E1 EA               LD     A,(exitParameterByte)
1298: EB84 3C                     INC    A
1299: EB85 CA 8E EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1300: EB88         ; file make operation successful
1301: EB88             RandomSeekExit:                      ; seekok:
1302: EB88 C1                     POP    BC                   ; discard r/w flag
1303: EB89 AF                     XOR    A
1304: EB8A 32 E1 EA               LD     (exitParameterByte),A
1305: EB8D C9                     RET                         ; with zero set
1306: EB8E
1307: EB8E             RandomSeekErrorBadSeek:
1308: EB8E         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1309: EB8E         ; appears as overflow with file write flag set
1310: EB8E E5                     PUSH   HL                   ; save error flag
1311: EB8F CD E7 F2               CALL   GetModuleNum         ; HL = .fcbS2Index
1312: EB92 36 C0                  LD     (HL),11000000B
1313: EB94 E1                     POP    HL                   ; and drop through
1314: EB95             RandomSeekError:                      ; seekerr:
1315: EB95 C1                     POP    BC                   ; discard r/w flag
1316: EB96 7D                     LD     A,L
1317: EB97 32 E1 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1318: EB9A         ; SetFileWriteFlag returns non-zero accumulator for err
1319: EB9A C3 F0 F3               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1320: EB9D         ;ret
1321: EB9D         ;
1322: EB9D         ;*****************************************************************
1323: EB9D             SetRandomRecord:                      ; setrandom
1324: EB9D 2A DF EA               LD     HL,(paramDE)
1325: EBA0 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1326: EBA3 CD EC EB               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1327: EBA6 21 21 00               LD     HL,RANDOM_REC_FIELD
1328: EBA9 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1329: EBAA 71                     LD     (HL),C
1330: EBAB 23                     INC    HL
1331: EBAC 70                     LD     (HL),B
1332: EBAD 23                     INC    HL
1333: EBAE 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1334: EBAF C9                     RET
1335: EBB0         ;*****************************************************************
1336: EBB0         ;compute logical file size for current fcb
1337: EBB0             GetFileSize:                      ; getfilesize
1338: EBB0 0E 0C                  LD     C,fcbExtIndex
1339: EBB2 CD 60 F3               CALL   Search4DirElement
1340: EBB5         ; zero the receiving Ramdom record field
1341: EBB5 2A DF EA               LD     HL,(paramDE)
1342: EBB8 11 21 00               LD     DE,RANDOM_REC_FIELD
1343: EBBB 19                     ADD    HL,DE
1344: EBBC E5                     PUSH   HL                   ; save position
1345: EBBD 72                     LD     (HL),D
1346: EBBE 23                     INC    HL
1347: EBBF 72                     LD     (HL),D
1348: EBC0 23                     INC    HL
1349: EBC1 72                     LD     (HL),D               ; =00 00 00
1350: EBC2             GetFileSize1:                      ; getsize:
1351: EBC2 CD 04 EE               CALL   EndOfDirectory
1352: EBC5 CA EA EB               JP     Z,GetFileSizeExit
1353: EBC8         ; current fcb addressed by dptr
1354: EBC8 CD F0 EE               CALL   GetDirElementAddress
1355: EBCB 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1356: EBCE CD EC EB               CALL   GetRandomRecordPosition
1357: EBD1         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1358: EBD1 E1                     POP    HL
1359: EBD2 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1360: EBD3 5F                     LD     E,A                  ; save cy
1361: EBD4 79                     LD     A,C
1362: EBD5 96                     SUB    M
1363: EBD6 23                     INC    HL                   ; ls byte
1364: EBD7 78                     LD     A,B
1365: EBD8 9E                     SBC    A,(HL)
1366: EBD9 23                     INC    HL                   ; middle byte
1367: EBDA 7B                     LD     A,E
1368: EBDB 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1369: EBDC DA E4 EB               JP     C,GetFileSize2       ; for another try
1370: EBDF         ; fcb is less or equal, fill from directory
1371: EBDF 73                     LD     (HL),E
1372: EBE0 2B                     DEC    HL
1373: EBE1 70                     LD     (HL),B
1374: EBE2 2B                     DEC    HL
1375: EBE3 71                     LD     (HL),C
1376: EBE4             GetFileSize2:                      ; getnextsize:
1377: EBE4 CD 78 F3               CALL   Search4NextDirElement
1378: EBE7 C3 C2 EB               JP     GetFileSize1
1379: EBEA             GetFileSizeExit:                      ; setsize:
1380: EBEA E1                     POP    HL                   ; discard .fcb(random record field)
1381: EBEB C9                     RET
1382: EBEC         ;-----------------------------------------------------------------
1383: EBEC         ;compute random record position
1384: EBEC             GetRandomRecordPosition:                      ; compute$rr
1385: EBEC EB                     EX     DE,HL
1386: EBED 19                     ADD    HL,DE
1387: EBEE         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1388: EBEE 4E                     LD     C,(HL)
1389: EBEF 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1390: EBF1 21 0C 00               LD     HL,fcbExtIndex
1391: EBF4 19                     ADD    HL,DE
1392: EBF5 7E                     LD     A,(HL)
1393: EBF6 0F                     RRCA
1394: EBF7 E6 80                  AND    80H                  ; A=e000 0000
1395: EBF9 81                     ADD    A,C
1396: EBFA 4F                     LD     C,A
1397: EBFB 3E 00                  LD     A,0
1398: EBFD 88                     ADC    A,B
1399: EBFE 47                     LD     B,A
1400: EBFF         ; BC = 0000 000? errrr rrrr
1401: EBFF 7E                     LD     A,(HL)
1402: EC00 0F                     RRCA
1403: EC01 E6 0F                  AND    LO_NIBBLE_MASK
1404: EC03 80                     ADD    A,B
1405: EC04 47                     LD     B,A
1406: EC05         ; BC = 000? eeee errrr rrrr
1407: EC05 21 0E 00               LD     HL,fcbS2Index
1408: EC08 19                     ADD    HL,DE
1409: EC09 7E                     LD     A,(HL)               ; A=XXX? mmmm
1410: EC0A 87                     ADD    A,A
1411: EC0B 87                     ADD    A,A
1412: EC0C 87                     ADD    A,A
1413: EC0D 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1414: EC0E F5                     PUSH   AF
1415: EC0F 80                     ADD    A,B
1416: EC10 47                     LD     B,A
1417: EC11         ; cy=?, BC = mmmm eeee errr rrrr
1418: EC11 F5                     PUSH   AF                   ; possible second carry
1419: EC12 E1                     POP    HL                   ; cy = lsb of L
1420: EC13 7D                     LD     A,L                  ; cy = lsb of A
1421: EC14 E1                     POP    HL                   ; cy = lsb of L
1422: EC15 B5                     OR     L                    ; cy/cy = lsb of A
1423: EC16 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1424: EC18 C9                     RET
1425: EC19         ;-----------------------------------------------------------------
1426: EC19
1427: EC19         ;*****************************************************************
1428: EC19         ;****************** Random I/O Stuff >****************************
1429: EC19         ;*****************************************************************
1430: EC19
1431: EC19
1432: EC19         ;? ;------------------
1433: EC19         ;? ;back-up one screen position
1434: EC19         ;? BackUp:
1435: EC19         ;?  	CALL	PutCntl_H
1436: EC19         ;? 	LD		C,SPACE
1437: EC19         ;? 	CALL	bcConout
1438: EC19         ;? ;send CTRL_H to console without affecting column count
1439: EC19         ;? PutCntl_H:
1440: EC19         ;? 	LD		C,CTRL_H
1441: EC19         ;? 	JP		bcConout
1442: EC19         ;? 	;ret
1443: EC19         ;----------------------------------------------------------------
1444: EC19         ;
1445: EC19
1446: EC19
1447: EC19         ;------------------
1448: EC19         ;? ;send C character with possible preceding up-arrow
1449: EC19         ;? CaretCout:
1450: EC19         ;? 	LD		A,C
1451: EC19         ;? 	CALL	isPrintableASCII			; cy if not graphic (or special case)
1452: EC19         ;? 	JP	NC,TabOut							; skip if graphic, TAB, CR, LF, or CTRL_H
1453: EC19         ;? ; send preceding up arrow
1454: EC19         ;? 	PUSH	AF
1455: EC19         ;? 	LD		C,CARET
1456: EC19         ;? 	CALL	ConsoleOut						; up arrow
1457: EC19         ;? 	POP		AF
1458: EC19         ;? 	OR		40H								; becomes graphic letter
1459: EC19         ;? 	LD		C,A								; ready to print
1460: EC19
1461: EC19
1462: EC19
1463: EC19
1464: EC19         ;*****************************************************************
1465: EC19         ;********************** Disk  I/O ********************************
1466: EC19         ;*****************************************************************
1467: EC19
1468: EC19         ;reset disk system - initialize to disk 0
1469: EC19             vResetSystem:                      ; func13 (13 - 0D)	 Reset Disk System
1470: EC19 21 00 00               LD     HL,0
1471: EC1C 22 36 F5               LD     (ReadOnlyVector),HL
1472: EC1F 22 38 F5               LD     (loggedDisks),HL     ; clear the vectors for R/O and Logged Disks
1473: EC22 AF                     XOR    A                    ; also clear the current disk
1474: EC23 32 34 F5               LD     (currentDisk),A      ; note that currentUserNumber remains unchanged
1475: EC26 21 80 00               LD     HL,DMABuffer
1476: EC29 22 3A F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = DMABuffer
1477: EC2C CD F5 ED               CALL   SetDataDMA           ; to data dma address
1478: EC2F C3 79 EC               JP     Select
1479: EC32         ;ret ;jmp goback
1480: EC32         ;-----------------------------------------------------------------
1481: EC32         ;select disk in (E) paramDE
1482: EC32         ; IN - (E) disk number -- 0=A  1=B ...15=P
1483: EC32             vSelectDisk:                      ; func14 (14 - 0E)	Select Current Disk
1484: EC32 C3 6D EC               JP     SelectCurrent
1485: EC35         ;ret ;jmp goba
1486: EC35         ;-----------------------------------------------------------------
1487: EC35         ;return the login vector
1488: EC35         ;OUT - (HL) loggedDisks
1489: EC35             vGetLoginVector:                      ; func24: (24 - 18) Return login Vector
1490: EC35 2A 38 F5               LD     HL,(loggedDisks)
1491: EC38 22 E1 EA               LD     (exitParameterWord),HL
1492: EC3B C9                     RET
1493: EC3C         ;-----------------------------------------------------------------
1494: EC3C         ;return selected disk number
1495: EC3C         ;OUT - A current disk -- 0=A  1=B ...15=P
1496: EC3C             vGetCurrentDisk:                      ; func25 (25 - 19)	Get Current Disk
1497: EC3C 3A 34 F5               LD     A,(currentDisk)
1498: EC3F 32 E1 EA               LD     (exitParameterByte),A
1499: EC42 C9                     RET
1500: EC43         ;-----------------------------------------------------------------
1501: EC43         ;set the subsequent dma address to paramDE
1502: EC43         ;IN - (HL) value to set as DMA
1503: EC43             vSetDMA:                        ; func26 (25 - 1A) Set Dma Address
1504: EC43 2A DF EA               LD     HL,(paramDE)
1505: EC46 22 3A F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = paramDE
1506: EC49 C3 F5 ED               JP     SetDataDMA           ; to data dma address
1507: EC4C         ;-----------------------------------------------------------------
1508: EC4C         ;return the Allocation Vector Address
1509: EC4C         ;OUT - (HL) Allocation Vector Address
1510: EC4C             vGetAllocAddr:                      ; func27 (27 - 1B) Get Allocation Vector Address
1511: EC4C 2A 48 F5               LD     HL,(caAllocVector)
1512: EC4F 22 E1 EA               LD     (exitParameterWord),HL
1513: EC52 C9                     RET
1514: EC53         ;-----------------------------------------------------------------
1515: EC53         ;;write protect current disk
1516: EC53             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1517: EC53 C3 F8 EC               JP     SetDiskReadOnly
1518: EC56         ;-----------------------------------------------------------------
1519: EC56         ;return r/o bit vector
1520: EC56         ;OUT - (HL) Read Only Vector Vector
1521: EC56             vGetRoVector:                      ; func29 (29 - 1D)	Get read Only vector
1522: EC56 2A 36 F5               LD     HL,(ReadOnlyVector)
1523: EC59 22 E1 EA               LD     (exitParameterWord),HL
1524: EC5C C9                     RET
1525: EC5D         ;-----------------------------------------------------------------
1526: EC5D         ;;set file Attributes
1527: EC5D             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1528: EC5D CD F0 F2               CALL   Reselect
1529: EC60 CD 45 EF               CALL   SetAttributes
1530: EC63 C3 DA F2               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1531: EC66         ;-----------------------------------------------------------------
1532: EC66         ;return address of disk parameter block
1533: EC66         ; OUT - (HL) Disk Parameter Black for current drive
1534: EC66             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1535: EC66 2A 44 F5               LD     HL,(caDiskParamBlock)
1536: EC69 22 E1 EA               LD     (exitParameterWord),HL
1537: EC6C C9                     RET
1538: EC6D         ;-----------------------------------------------------------------
1539: EC6D
1540: EC6D             SelectCurrent:                      ; curselect
1541: EC6D 3A DE EA               LD     A,(paramE)
1542: EC70 21 34 F5               LD     HL,currentDisk
1543: EC73 BE                     CP     M
1544: EC74 C8                     RET    Z                    ; exit if parame = Current disk
1545: EC75 77                     LD     (HL),A
1546: EC76 C3 79 EC               JP     Select
1547: EC79         ;*****************************************************************
1548: EC79         ; select Login Drive
1549: EC79             Select:
1550: EC79 2A 38 F5               LD     HL,(loggedDisks)
1551: EC7C 3A 34 F5               LD     A,(currentDisk)
1552: EC7F 4F                     LD     C,A
1553: EC80 CD 7B F4               CALL   ShiftRightHLbyC      ; see if we already have drive logged in
1554: EC83 E5                     PUSH   HL                   ; save result
1555: EC84 EB                     EX     DE,HL                ; send to seldsk
1556: EC85 CD 9D EC               CALL   SelectDisk
1557: EC88 E1                     POP    HL                   ; get back logged disk vector
1558: EC89 CC 9F F4               CALL   Z,errSelect
1559: EC8C 7D                     LD     A,L                  ; get logged disks
1560: EC8D 1F                     RRA
1561: EC8E D8                     RET    C                    ; exit if the disk already logged in
1562: EC8F
1563: EC8F 2A 38 F5               LD     HL,(loggedDisks)     ; else log in a differenet disk
1564: EC92 4D                     LD     C,L
1565: EC93 44                     LD     B,H                  ; BC has logged disk
1566: EC94 CD E5 EC               CALL   SetCurrentDiskBit
1567: EC97 22 38 F5               LD     (loggedDisks),HL     ; save result
1568: EC9A C3 0F ED               JP     InitDisk
1569: EC9D         ;*****************************************************************
1570: EC9D         ; select the disk drive given by currentDisk, and fill the base addresses
1571: EC9D         ; caTrack - caAllocVector, then fill the values of the disk parameter block
1572: EC9D             SelectDisk:
1573: EC9D 3A 34 F5               LD     A,(currentDisk)
1574: ECA0 4F                     LD     C,A                  ; prepare for Bios Call
1575: ECA1 CD 1B F6               CALL   bcSeldsk
1576: ECA4 7C                     LD     A,H                  ; HL = 0000 if error, otherwise disk headers
1577: ECA5 B5                     OR     L
1578: ECA6 C8                     RET    Z                    ; exit if error, with Zflag set
1579: ECA7 5E                     LD     E,(HL)
1580: ECA8 23                     INC    HL
1581: ECA9 56                     LD     D,(HL)               ; Disk Header Block pointer in DE
1582: ECAA 23                     INC    HL
1583: ECAB 22 3C F5               LD     (caDirMaxValue),HL
1584: ECAE 23                     INC    HL
1585: ECAF 23                     INC    HL
1586: ECB0 22 3E F5               LD     (caTrack),HL
1587: ECB3 23                     INC    HL
1588: ECB4 23                     INC    HL
1589: ECB5 22 40 F5               LD     (caSector),HL
1590: ECB8 23                     INC    HL
1591: ECB9 23                     INC    HL
1592: ECBA EB                     EX     DE,HL                ; DE points at Directory DMA, HL at Skew Table
1593: ECBB 22 59 F5               LD     (caSkewTable),HL
1594: ECBE 21 42 F5               LD     HL,caDirectoryDMA
1595: ECC1 0E 08                  LD     C,caListSize
1596: ECC3 CD 8F F4               CALL   Move                 ; finish filling in address list
1597: ECC6
1598: ECC6 2A 44 F5               LD     HL,(caDiskParamBlock)
1599: ECC9 EB                     EX     DE,HL                ; DE is source
1600: ECCA 21 4A F5               LD     HL,dpbStart          ; start of Disk Parameter Block
1601: ECCD 0E 0F                  LD     C,dpbSize
1602: ECCF CD 8F F4               CALL   Move                 ; load the table
1603: ECD2 2A 4F F5               LD     HL,(dpbDSM)          ; max entry number
1604: ECD5 7C                     LD     A,H                  ; if 00 then < 255
1605: ECD6 21 63 F5               LD     HL,single            ; point at the single byte entry flag
1606: ECD9 36 FF                  LD     (HL),TRUE            ; assume its less than 255
1607: ECDB B7                     OR     A                    ; assumtion confirmed ?
1608: ECDC CA E1 EC               JP     Z,SelectDisk1        ; skip if yes
1609: ECDF 36 00                  LD     (HL),FALSE           ; correct assumption, set falg to false
1610: ECE1
1611: ECE1             SelectDisk1:
1612: ECE1 3E FF                  LD     A,TRUE
1613: ECE3 B7                     OR     A                    ; Set Sign, reset Carry and   Zero
1614: ECE4 C9                     RET
1615: ECE5
1616: ECE5         ;---------------
1617: ECE5         ; set a "1" value in currentDisk position of BC
1618: ECE5         ; return in HL
1619: ECE5             SetCurrentDiskBit:
1620: ECE5 C5                     PUSH   BC                   ; save input parameter
1621: ECE6 3A 34 F5               LD     A,(currentDisk)
1622: ECE9 4F                     LD     C,A                  ; ready parameter for shift
1623: ECEA 21 01 00               LD     HL,1                 ; number to shift
1624: ECED CD 88 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1625: ECF0 C1                     POP    BC                   ; original mask
1626: ECF1 79                     LD     A,C
1627: ECF2 B5                     OR     L
1628: ECF3 6F                     LD     L,A
1629: ECF4 78                     LD     A,B
1630: ECF5 B4                     OR     H
1631: ECF6 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1632: ECF7 C9                     RET
1633: ECF8         ;--------------
1634: ECF8         ;set current disk to read only
1635: ECF8             SetDiskReadOnly:
1636: ECF8 21 36 F5               LD     HL,ReadOnlyVector
1637: ECFB 4E                     LD     C,(HL)
1638: ECFC 23                     INC    HL
1639: ECFD 46                     LD     B,(HL)
1640: ECFE CD E5 EC               CALL   SetCurrentDiskBit    ; sets bit to 1
1641: ED01 22 36 F5               LD     (ReadOnlyVector),HL
1642: ED04         ; high water mark in directory goes to max
1643: ED04 2A 51 F5               LD     HL,(dpbDRM)          ; directory max
1644: ED07 EB                     EX     DE,HL                ; DE = directory max
1645: ED08 2A 3C F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value
1646: ED0B 73                     LD     (HL),E
1647: ED0C 23                     INC    HL
1648: ED0D 72                     LD     (HL),D               ; cdrmax = dpbDRM
1649: ED0E C9                     RET
1650: ED0F         ;----------------------- initialize the current disk
1651: ED0F         ;
1652: ED0F         ;exitParameterByte = false ;set to true if $ file exists
1653: ED0F         ; compute the length of the allocation vector - 2
1654: ED0F
1655: ED0F             InitDisk:
1656: ED0F 2A 4F F5               LD     HL,(dpbDSM)          ; get max allocation value
1657: ED12 0E 03                  LD     C,3                  ; we want dpbDSM/8
1658: ED14         ; number of bytes in alloc vector is (dpbDSM/8)+1
1659: ED14 CD 7B F4               CALL   ShiftRightHLbyC
1660: ED17 23                     INC    HL                   ; HL = dpbDSM/8+1
1661: ED18 44                     LD     B,H
1662: ED19 4D                     LD     C,L                  ; BC has size of AllocationVector
1663: ED1A 2A 48 F5               LD     HL,(caAllocVector)   ; base of allocation vector
1664: ED1D         ;fill the allocation vector with zeros
1665: ED1D             InitDisk0:
1666: ED1D 36 00                  LD     (HL),0
1667: ED1F 23                     INC    HL                   ; alloc(i)=0
1668: ED20 0B                     DEC    BC                   ; count length down
1669: ED21 78                     LD     A,B
1670: ED22 B1                     OR     C
1671: ED23 C2 1D ED               JP     NZ,InitDisk0
1672: ED26         ; set the reserved space for the directory
1673: ED26 2A 53 F5               LD     HL,(dpbDABM)         ; get the directory block reserved bits
1674: ED29 EB                     EX     DE,HL
1675: ED2A 2A 48 F5               LD     HL,(caAllocVector)   ; HL=.alloc()
1676: ED2D 73                     LD     (HL),E
1677: ED2E 23                     INC    HL
1678: ED2F 72                     LD     (HL),D               ; sets reserved directory blks
1679: ED30         ; allocation vector initialized, home disk
1680: ED30 CD D4 ED               CALL   Home
1681: ED33         ; caDirMaxValue = 3 (scans at least one directory record)
1682: ED33 2A 3C F5               LD     HL,(caDirMaxValue)
1683: ED36 36 03                  LD     (HL),3
1684: ED38 23                     INC    HL
1685: ED39 36 00                  LD     (HL),0               ; caDirMaxValue = 0003
1686: ED3B
1687: ED3B CD EE ED               CALL   SetEndDirectory      ; dirEntryIndex = EOD
1688: ED3E         ; read directory entries and check for allocated storage
1689: ED3E             InitDisk1:
1690: ED3E 0E FF                  LD     C,TRUE
1691: ED40 CD 16 EE               CALL   ReadDirectory
1692: ED43 CD 04 EE               CALL   EndOfDirectory
1693: ED46 C8                     RET    Z                    ; return if end of directory
1694: ED47         ; not end of directory, valid entry?
1695: ED47 CD F0 EE               CALL   GetDirElementAddress ; HL = caDirectoryDMA + dirBlockIndex
1696: ED4A 3E E5                  LD     A,emptyDir
1697: ED4C BE                     CP     M
1698: ED4D CA 3E ED               JP     Z,InitDisk1          ; go get another item
1699: ED50         ; not emptyDir, user code the same?
1700: ED50 3A 2F F5               LD     A,(currentUserNumber)
1701: ED53 BE                     CP     M
1702: ED54 C2 62 ED               JP     NZ,InitDisk2
1703: ED57         ; same user code, check for '$' submit
1704: ED57 23                     INC    HL
1705: ED58 7E                     LD     A,(HL)               ; first character
1706: ED59 D6 24                  SUB    DOLLAR               ; dollar file?
1707: ED5B C2 62 ED               JP     NZ,InitDisk2
1708: ED5E         ; dollar file found, mark in exitParameterByte
1709: ED5E 3D                     DEC    A
1710: ED5F 32 E1 EA               LD     (exitParameterByte),A ; exitParameterByte = 255
1711: ED62             InitDisk2:
1712: ED62         ; now scan the disk map for allocated blocks
1713: ED62 0E 01                  LD     C,1                  ; set to allocated
1714: ED64 CD 6D ED               CALL   ScanDiskMap
1715: ED67 CD F9 EE               CALL   SetDirectoryEntry    ; set DirMaxVAlue to dirEntryIndex
1716: ED6A C3 3E ED               JP     InitDisk1            ; for another entry
1717: ED6D         ;
1718: ED6D         ;-------------Scan the disk map for unallocated entry-----------------------------------
1719: ED6D         ; scan the disk map addressed by dptr for non-zero entries.  The allocation
1720: ED6D         ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
1721: ED6D             ScanDiskMap:
1722: ED6D CD F0 EE               CALL   GetDirElementAddress ; HL = buffa + dptr
1723: ED70         ; HL addresses the beginning of the directory entry
1724: ED70 11 10 00               LD     DE,fcbDiskMapIndex
1725: ED73 19                     ADD    HL,DE                ; hl now addresses the disk map
1726: ED74 C5                     PUSH   BC                   ; save the set/reset bit
1727: ED75 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; size of Disk Allocation Map + 1
1728: ED77
1729: ED77             ScanDiskMap0:                      ; loop once for each disk map entry
1730: ED77 D1                     POP    DE                   ; recall the set/reset bit
1731: ED78 0D                     DEC    C
1732: ED79 C8                     RET    Z
1733: ED7A
1734: ED7A D5                     PUSH   DE                   ; save the set/reset bit
1735: ED7B 3A 63 F5               LD     A,(single)           ; single byte entry flag
1736: ED7E B7                     OR     A
1737: ED7F CA 8A ED               JP     Z,ScanDiskMap1       ; skip if two byte value
1738: ED82         ; single byte scan operation
1739: ED82 C5                     PUSH   BC                   ; save counter
1740: ED83 E5                     PUSH   HL                   ; save map address
1741: ED84 4E                     LD     C,(HL)
1742: ED85 06 00                  LD     B,0                  ; BC=block#
1743: ED87 C3 90 ED               JP     ScanDiskMap2
1744: ED8A         ; two byte scan operation
1745: ED8A             ScanDiskMap1:
1746: ED8A 0D                     DEC    C                    ; adjust counter for double byte
1747: ED8B C5                     PUSH   BC                   ; save counter
1748: ED8C         ;	MOV		C,M
1749: ED8C 46                     LD     B,(HL)
1750: ED8D 23                     INC    HL
1751: ED8E         ;	MOV		B,M								; BC=block#
1752: ED8E 4E                     LD     C,(HL)               ; BC=block#
1753: ED8F E5                     PUSH   HL                   ; save map address
1754: ED90             ScanDiskMap2:                      ; arrive here with BC=block#, E=0/1
1755: ED90 79                     LD     A,C
1756: ED91 B0                     OR     B                    ; skip if = 0000
1757: ED92 C4 C2 ED               CALL   NZ,SetAllocBit       ; bit set to 0/1 its in C
1758: ED95 E1                     POP    HL
1759: ED96 23                     INC    HL                   ; to next bit position
1760: ED97 C1                     POP    BC                   ; recall counter
1761: ED98 C3 77 ED               JP     ScanDiskMap0         ; for another item
1762: ED9B         ;
1763: ED9B         ;-----------------------------------
1764: ED9B         ;given allocation vector position BC, return with byte
1765: ED9B         ;containing BC shifted so that the least significant
1766: ED9B         ;bit is in the low order accumulator position.  HL is
1767: ED9B         ;the address of the byte for possible replacement in
1768: ED9B         ;memory upon return, and D contains the number of shifts
1769: ED9B         ;required to place the returned value back into position
1770: ED9B
1771: ED9B             GetAllocBit:                      ; getallocbit
1772: ED9B 79                     LD     A,C
1773: ED9C E6 07                  AND    111b
1774: ED9E 3C                     INC    A
1775: ED9F 5F                     LD     E,A
1776: EDA0 57                     LD     D,A
1777: EDA1         ; d and e both contain the number of bit positions to shift
1778: EDA1 79                     LD     A,C
1779: EDA2 0F                     RRCA
1780: EDA3 0F                     RRCA
1781: EDA4 0F                     RRCA
1782: EDA5 E6 1F                  AND    11111b
1783: EDA7 4F                     LD     C,A                  ; C shr 3 to C
1784: EDA8 78                     LD     A,B
1785: EDA9 87                     ADD    A,A
1786: EDAA 87                     ADD    A,A
1787: EDAB 87                     ADD    A,A
1788: EDAC 87                     ADD    A,A
1789: EDAD 87                     ADD    A,A                  ; B shl 5
1790: EDAE B1                     OR     C
1791: EDAF 4F                     LD     C,A                  ; bbbccccc to C
1792: EDB0 78                     LD     A,B
1793: EDB1 0F                     RRCA
1794: EDB2 0F                     RRCA
1795: EDB3 0F                     RRCA
1796: EDB4 E6 1F                  AND    11111b
1797: EDB6 47                     LD     B,A                  ; BC shr 3 to BC
1798: EDB7 2A 48 F5               LD     HL,(caAllocVector)   ; base address of allocation vector
1799: EDBA 09                     ADD    HL,BC
1800: EDBB 7E                     LD     A,(HL)               ; byte to A, hl = .alloc(BC shr 3)
1801: EDBC         ;now move the bit to the low order position of A
1802: EDBC             GetAllocBitl:
1803: EDBC 07                     RLCA
1804: EDBD 1D                     DEC    E
1805: EDBE C2 BC ED               JP     NZ,GetAllocBitl
1806: EDC1 C9                     RET
1807: EDC2
1808: EDC2         ;-----------------------------------
1809: EDC2         ; BC is the bit position of ALLOC to set or reset.  The
1810: EDC2         ; value of the bit is in register E.
1811: EDC2             SetAllocBit:
1812: EDC2 D5                     PUSH   DE
1813: EDC3 CD 9B ED               CALL   GetAllocBit          ; shifted val A, count in D
1814: EDC6 E6 FE                  AND    11111110b            ; mask low bit to zero (may be set)
1815: EDC8 C1                     POP    BC
1816: EDC9 B1                     OR     C                    ; low bit of C is masked into A
1817: EDCA C3 CD ED               JP     RotateAndReplace     ; to rotate back into proper position
1818: EDCD         ;ret
1819: EDCD         ;-----------------------------------
1820: EDCD         ; byte value from ALLOC is in register A, with shift count
1821: EDCD         ; in register C (to place bit back into position), and
1822: EDCD         ; target ALLOC position in registers HL, rotate and replace
1823: EDCD             RotateAndReplace:
1824: EDCD 0F                     RRCA
1825: EDCE 15                     DEC    D
1826: EDCF C2 CD ED               JP     NZ,RotateAndReplace  ; back into position
1827: EDD2 77                     LD     (HL),A               ; back to ALLOC
1828: EDD3 C9                     RET
1829: EDD4         ;-----------------------------------
1830: EDD4
1831: EDD4         ;move to home position, then offset to start of dir
1832: EDD4             Home:
1833: EDD4 CD 18 F6               CALL   bcHome               ; move to track 00, sector 00 reference
1834: EDD7 21 57 F5               LD     HL,dpbOFF            ; get track ofset at begining
1835: EDDA 4E                     LD     C,(HL)
1836: EDDB 23                     INC    HL
1837: EDDC 46                     LD     B,(HL)
1838: EDDD CD 1E F6               CALL   bcSettrk             ; select first directory position
1839: EDE0
1840: EDE0 AF                     XOR    A                    ; constant zero to accumulator
1841: EDE1 2A 3E F5               LD     HL,(caTrack)
1842: EDE4 77                     LD     (HL),A
1843: EDE5 23                     INC    HL
1844: EDE6 77                     LD     (HL),A               ; curtrk=0000
1845: EDE7 2A 40 F5               LD     HL,(caSector)
1846: EDEA 77                     LD     (HL),A
1847: EDEB 23                     INC    HL
1848: EDEC 77                     LD     (HL),A               ; currec=0000
1849: EDED C9                     RET
1850: EDEE
1851: EDEE
1852: EDEE         ;*****************************************************************
1853: EDEE
1854: EDEE         ;*****************************************************************
1855: EDEE         ;*****************************************************************
1856: EDEE         ; set directory counter to end  -1
1857: EDEE             SetEndDirectory:
1858: EDEE 21 FF FF               LD     HL,EOD
1859: EDF1 22 6E F5               LD     (dirEntryIndex),HL
1860: EDF4 C9                     RET
1861: EDF5         ;---------------
1862: EDF5             SetDataDMA:                      ; setdata
1863: EDF5 21 3A F5               LD     HL,InitDAMAddress
1864: EDF8 C3 FE ED               JP     SetDMA               ; to complete the call
1865: EDFB         ;---------------
1866: EDFB             SetDirDMA:                      ; setdir
1867: EDFB 21 42 F5               LD     HL,caDirectoryDMA
1868: EDFE
1869: EDFE             SetDMA:                         ; setdma
1870: EDFE 4E                     LD     C,(HL)
1871: EDFF 23                     INC    HL
1872: EE00 46                     LD     B,(HL)               ; parameter ready
1873: EE01 C3 24 F6               JP     bcSetdma             ; call bios to set
1874: EE04         ;---------------
1875: EE04         ;---------------
1876: EE04         ; return zero flag if at end of directory
1877: EE04         ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
1878: EE04             EndOfDirectory:
1879: EE04 21 6E F5               LD     HL,dirEntryIndex
1880: EE07 7E                     LD     A,(HL)               ; may be 0ffh
1881: EE08 23                     INC    HL
1882: EE09 BE                     CP     M                    ; low(dirEntryIndex) = high(dirEntryIndex)?
1883: EE0A C0                     RET    NZ                   ; non zero returned if different
1884: EE0B         ; high and low the same, = 0ffh?
1885: EE0B 3C                     INC    A                    ; 0ffh becomes 00 if so
1886: EE0C C9                     RET
1887: EE0D         ;---------------
1888: EE0D         ; read a directory entry into the directory buffer
1889: EE0D             ReadDirRecord:
1890: EE0D CD FB ED               CALL   SetDirDMA            ; directory dma
1891: EE10 CD 5E F2               CALL   ReadBuffer           ; directory record loaded
1892: EE13 C3 F5 ED               JP     SetDataDMA           ; to data dma address
1893: EE16         ;ret
1894: EE16         ;---------------
1895: EE16         ; read next directory entry, with C=true if initializing
1896: EE16             ReadDirectory:
1897: EE16 2A 51 F5               LD     HL,(dpbDRM)
1898: EE19 EB                     EX     DE,HL                ; determine number of directory entries
1899: EE1A 2A 6E F5               LD     HL,(dirEntryIndex)   ; index into directory
1900: EE1D 23                     INC    HL
1901: EE1E 22 6E F5               LD     (dirEntryIndex),HL   ; initialize directory index
1902: EE21         ; continue while dpbDRM >= dirEntryIndex (dpbDRM-dirEntryIndex no cy)
1903: EE21 CD 74 F4               CALL   DEminusHL2HL         ; DE-HL - processed all entries ?
1904: EE24 D2 2B EE               JP     NC,ReadDirectory0    ; no - do it again
1905: EE27         ; yes, set dirEntryIndex to end of directory
1906: EE27 CD EE ED               CALL   SetEndDirectory
1907: EE2A C9                     RET
1908: EE2B
1909: EE2B         ; not at end of directory, seek next element, initialization flag is in C
1910: EE2B             ReadDirectory0:
1911: EE2B 3A 6E F5               LD     A,(dirEntryIndex)
1912: EE2E E6 03                  AND    dirEntryMask         ; low(dirEntryIndex) and dirEntryMask
1913: EE30 06 05                  LD     B,fcbShift           ; to multiply by fcb size to get the correct index in dir record
1914: EE32             ReadDirectory1:
1915: EE32 87                     ADD    A,A
1916: EE33 05                     DEC    B
1917: EE34 C2 32 EE               JP     NZ,ReadDirectory1
1918: EE37         ; A = (low(dirEntryIndex) and dirEntryMask) shl fcbShift
1919: EE37 32 6D F5               LD     (dirBlockIndex),A    ; ready for next dir operation
1920: EE3A B7                     OR     A
1921: EE3B C0                     RET    NZ                   ; return if not a new record (Directory Block)
1922: EE3C C5                     PUSH   BC                   ; save initialization flag C
1923: EE3D CD 47 EE               CALL   SeekDir              ; seek$dir seek proper record
1924: EE40 CD 0D EE               CALL   ReadDirRecord        ; read the directory record
1925: EE43 C1                     POP    BC                   ; recall initialization flag
1926: EE44 C3 BB EE               JP     CalculateCheckSum    ; checksum the directory elt
1927: EE47         ;---------
1928: EE47         ;seek the record containing the current dir entry
1929: EE47             SeekDir:
1930: EE47 2A 6E F5               LD     HL,(dirEntryIndex)   ; directory counter to HL
1931: EE4A 0E 02                  LD     C,dirEntryShift      ; 4 entries per record
1932: EE4C CD 7B F4               CALL   ShiftRightHLbyC      ; value to HL
1933: EE4F 22 6B F5               LD     (currentBlock),HL
1934: EE52 22 70 F5               LD     (dirRecord),HL       ; ready for seek
1935: EE55 C3 58 EE               JP     Seek
1936: EE58         ;---------------------------
1937: EE58             Seek:                           ; seek
1938: EE58         ;seek the track given by currentBlock (actual record number)
1939: EE58
1940: EE58 21 6B F5               LD     HL,currentBlock      ; contains the cpm record number
1941: EE5B 4E                     LD     C,(HL)               ; Actual Record Number Low
1942: EE5C 23                     INC    HL
1943: EE5D 46                     LD     B,(HL)               ; Actual Record Number High
1944: EE5E 2A 40 F5               LD     HL,(caSector)        ; Current Sector
1945: EE61 5E                     LD     E,(HL)               ; Current Sector Number Low
1946: EE62 23                     INC    HL
1947: EE63 56                     LD     D,(HL)               ; Current Sector Number High
1948: EE64 2A 3E F5               LD     HL,(caTrack)         ; Current track
1949: EE67 7E                     LD     A,(HL)               ; Current track Number Low - temp
1950: EE68 23                     INC    HL
1951: EE69 66                     LD     H,(HL)               ; Current track Number High
1952: EE6A 6F                     LD     L,A                  ; Current track Number Low
1953: EE6B         ;(BC) - cpmRecord Number
1954: EE6B         ;(DE) - Current Sector
1955: EE6B         ;(HL) - Current Track
1956: EE6B
1957: EE6B         ;loop while currentBlock < currec   ?????
1958: EE6B             Seek0:
1959: EE6B 79                     LD     A,C                  ;   Current Sector
1960: EE6C 93                     SUB    E                    ;
1961: EE6D 78                     LD     A,B                  ; - cpmRecord Number
1962: EE6E 9A                     SBC    A,D                  ;
1963: EE6F D2 81 EE               JP     NC,Seek1             ; skip if cpmRecord Number >= Current Sector
1964: EE72
1965: EE72 E5                     PUSH   HL
1966: EE73 2A 4A F5               LD     HL,(dpbSPT)
1967: EE76 7B                     LD     A,E
1968: EE77 95                     SUB    L
1969: EE78 5F                     LD     E,A
1970: EE79 7A                     LD     A,D
1971: EE7A 9C                     SBC    A,H
1972: EE7B 57                     LD     D,A
1973: EE7C E1                     POP    HL
1974: EE7D 2B                     DEC    HL
1975: EE7E C3 6B EE               JP     Seek0
1976: EE81
1977: EE81             Seek1:
1978: EE81
1979: EE81 E5                     PUSH   HL                   ; Save Current Track
1980: EE82 2A 4A F5               LD     HL,(dpbSPT)          ; records per track
1981: EE85 19                     ADD    HL,DE                ; HL = Current Sector + sectorsPerClynder
1982: EE86 79                     LD     A,C                  ;     cpmRecord Number
1983: EE87 95                     SUB    L                    ;
1984: EE88 78                     LD     A,B                  ;  - HL (above)
1985: EE89 9C                     SBC    A,H                  ;
1986: EE8A DA 93 EE               JP     C,Seek2              ; skip if cpmRecord Number > HL (above)
1987: EE8D
1988: EE8D EB                     EX     DE,HL
1989: EE8E
1990: EE8E E1                     POP    HL
1991: EE8F 23                     INC    HL
1992: EE90 C3 81 EE               JP     Seek1
1993: EE93
1994: EE93             Seek2:
1995: EE93 E1                     POP    HL                   ; retreive Current Track
1996: EE94 C5                     PUSH   BC                   ; save  cpmRecord Number
1997: EE95 D5                     PUSH   DE                   ; save  Current Sector
1998: EE96 E5                     PUSH   HL                   ; save CurrentTrack
1999: EE97         ; stack contains CurrentTrack , Current Sector, cpmRecord Number
2000: EE97 EB                     EX     DE,HL                ; DE => CurrentTrack, HL => Current Sector
2001: EE98 2A 57 F5               LD     HL,(dpbOFF)          ; Block Zero starting Track
2002: EE9B 19                     ADD    HL,DE                ; HL =  actual physical Track number
2003: EE9C 44                     LD     B,H
2004: EE9D 4D                     LD     C,L                  ; BC has physical Track number
2005: EE9E CD 1E F6               CALL   bcSettrk             ; track set up
2006: EEA1         ; note that BC - curtrk is difference to move in bios
2007: EEA1 D1                     POP    DE                   ; recall CurrentTrack
2008: EEA2 2A 3E F5               LD     HL,(caTrack)         ; point at current Track
2009: EEA5 73                     LD     (HL),E
2010: EEA6 23                     INC    HL
2011: EEA7 72                     LD     (HL),D               ; current Track updated
2012: EEA8         ; now compute sector as currentBlock-currec
2013: EEA8 D1                     POP    DE                   ; recall Current Sector
2014: EEA9 2A 40 F5               LD     HL,(caSector)        ; point at current Sector
2015: EEAC 73                     LD     (HL),E
2016: EEAD 23                     INC    HL
2017: EEAE 72                     LD     (HL),D               ; current sector updated / DE has currentSector
2018: EEAF C1                     POP    BC                   ; recall cpmRecord Number
2019: EEB0 79                     LD     A,C                  ; cpmRecord Number
2020: EEB1 93                     SUB    E
2021: EEB2 4F                     LD     C,A                  ; - currentSector
2022: EEB3 78                     LD     A,B
2023: EEB4 9A                     SBC    A,D
2024: EEB5 47                     LD     B,A                  ; back into BC
2025: EEB6 C3 21 F6               JP     bcSetsec             ; sector selected
2026: EEB9         ;ret
2027: EEB9         ;************* CheckSum *******************************
2028: EEB9         ; compute current checksum record
2029: EEB9         ; if C = TRUE , update the allocation vector
2030: EEB9         ;
2031: EEB9         ; or check for = if not dirRecord < dpbCKS ????
2032: EEB9
2033: EEB9             NewCheckSum:
2034: EEB9 0E FF                  LD     C,TRUE
2035: EEBB
2036: EEBB             CalculateCheckSum:
2037: EEBB 2A 70 F5               LD     HL,(dirRecord)
2038: EEBE EB                     EX     DE,HL
2039: EEBF 2A 55 F5               LD     HL,(dpbCKS)          ; size of checksum vector
2040: EEC2 CD 74 F4               CALL   DEminusHL2HL         ; DE-HL
2041: EEC5 D0                     RET    NC                   ; skip checksum if past checksum vector size
2042: EEC6 C5                     PUSH   BC                   ; save init flag
2043: EEC7 CD E3 EE               CALL   ComputeCheckSum      ; check sum value to A
2044: EECA 2A 46 F5               LD     HL,(caCheckSum)      ; address of check sum vector
2045: EECD EB                     EX     DE,HL
2046: EECE 2A 70 F5               LD     HL,(dirRecord)       ; value of dirRecord
2047: EED1 19                     ADD    HL,DE                ; HL = .check(dirRecord)
2048: EED2 C1                     POP    BC                   ; recall true=0ffh or false=00 to C
2049: EED3 0C                     INC    C                    ; 0ffh produces zero flag
2050: EED4 CA E1 EE               JP     Z,SetNewCheckSum
2051: EED7         ; not initializing, compare
2052: EED7 BE                     CP     M                    ; compute$cs=check(dirRecord)?
2053: EED8 C8                     RET    Z                    ; no message if ok
2054: EED9         ; possible checksum error, are we beyond the end of the disk?
2055: EED9 CD 02 EF               CALL   StillInDirectory
2056: EEDC D0                     RET    NC                   ; no message if so
2057: EEDD CD F8 EC               CALL   SetDiskReadOnly      ; read/only disk set
2058: EEE0 C9                     RET
2059: EEE1
2060: EEE1         ;initializing the checksum
2061: EEE1             SetNewCheckSum:
2062: EEE1 77                     LD     (HL),A
2063: EEE2 C9                     RET
2064: EEE3         ;------------------
2065: EEE3         ;compute checksum for current directory buffer
2066: EEE3             ComputeCheckSum:
2067: EEE3 0E 80                  LD     C,cpmRecordSize      ; size of directory buffer
2068: EEE5 2A 42 F5               LD     HL,(caDirectoryDMA)  ; current directory buffer
2069: EEE8 AF                     XOR    A                    ; clear checksum value
2070: EEE9             ComputeCheckSum0:
2071: EEE9 86                     ADD    A,(HL)
2072: EEEA 23                     INC    HL
2073: EEEB 0D                     DEC    C                    ; cs=cs+buff(cpmRecordSize-C)
2074: EEEC C2 E9 EE               JP     NZ,ComputeCheckSum0
2075: EEEF C9                     RET                         ; with checksum in A
2076: EEF0         ;*****************************************************************
2077: EEF0         ; compute the address of a directory element at positon dirBlockIndex in the buffer
2078: EEF0             GetDirElementAddress:
2079: EEF0 2A 42 F5               LD     HL,(caDirectoryDMA)
2080: EEF3 3A 6D F5               LD     A,(dirBlockIndex)
2081: EEF6 C3 6F F4               JP     AddAtoHL
2082: EEF9         ;---------------------
2083: EEF9         ;if not still in directory set max value
2084: EEF9             SetDirectoryEntry:
2085: EEF9 CD 02 EF               CALL   StillInDirectory
2086: EEFC D8                     RET    C
2087: EEFD         ; return if yes,otherwise, HL = DirMaxValue+1, DE = directoryCount
2088: EEFD
2089: EEFD 13                     INC    DE
2090: EEFE 72                     LD     (HL),D
2091: EEFF 2B                     DEC    HL
2092: EF00 73                     LD     (HL),E
2093: EF01 C9                     RET
2094: EF02         ; return CY if entry is still in Directory
2095: EF02             StillInDirectory:
2096: EF02 2A 6E F5               LD     HL,(dirEntryIndex)
2097: EF05 EB                     EX     DE,HL                ; DE = directory counter
2098: EF06 2A 3C F5               LD     HL,(caDirMaxValue)   ; HL=caDirMaxValue
2099: EF09 7B                     LD     A,E
2100: EF0A 96                     SUB    M                    ; low(dirEntryIndex) - low(cdrmax)
2101: EF0B 23                     INC    HL                   ; HL = .cdrmax+1
2102: EF0C 7A                     LD     A,D
2103: EF0D 9E                     SBC    A,(HL)               ; hi(dirEntryIndex) - hig(cdrmax)
2104: EF0E         ;condition dirEntryIndex - cdrmax  produces cy if cdrmax>dirEntryIndex
2105: EF0E C9                     RET
2106: EF0F         ;---------------------
2107: EF0F         ;compute fcbRCIndex and NEXT_RECORD addresses for get/setfcb
2108: EF0F         ; returns with DE pointing at RC from FCB
2109: EF0F         ;         with HL pointing at Next Record
2110: EF0F             GetFcbAddress:                      ; getfcba
2111: EF0F 2A DF EA               LD     HL,(paramDE)
2112: EF12 11 0F 00               LD     DE,fcbRCIndex
2113: EF15 19                     ADD    HL,DE
2114: EF16 EB                     EX     DE,HL                ; DE=.fcb(fcbRCIndex)
2115: EF17 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;RATS
2116: EF1A 19                     ADD    HL,DE                ; HL=.fcb(NEXT_RECORD)
2117: EF1B C9                     RET
2118: EF1C         ;---------------------
2119: EF1C         ;set variables from currently fcb - NEXT_RECORD, RC, EXM
2120: EF1C             SetRecordVars:
2121: EF1C CD 0F EF               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2122: EF1F 7E                     LD     A,(HL)
2123: EF20 32 69 F5               LD     (cpmRecord),A        ; cpmRecord=fcb(NEXT_RECORD)
2124: EF23 EB                     EX     DE,HL
2125: EF24 7E                     LD     A,(HL)
2126: EF25 32 67 F5               LD     (fcbRecordCount),A   ; fcbRecordCount=fcb(fcbRCIndex)
2127: EF28 CD E8 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2128: EF2B 3A 4E F5               LD     A,(dpbEXM)           ; extent mask to a
2129: EF2E A6                     AND    M                    ; fcb(fcbExtIndex) and dpbEXM
2130: EF2F 32 68 F5               LD     (extentValue),A      ; save extent number
2131: EF32 C9                     RET
2132: EF33         ;---------------------
2133: EF33         ;update variables from I/O in  fcb
2134: EF33             UpdateRecordVars:
2135: EF33 CD 0F EF               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2136: EF36 3A 5E F5               LD     A,(seqReadFlag)
2137: EF39 4F                     LD     C,A                  ; =1 if sequential i/o
2138: EF3A 3A 69 F5               LD     A,(cpmRecord)        ; get NEXT_RECORD
2139: EF3D 81                     ADD    A,C
2140: EF3E 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=cpmRecord+seqReadFlag
2141: EF3F EB                     EX     DE,HL
2142: EF40 3A 67 F5               LD     A,(fcbRecordCount)
2143: EF43 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2144: EF44 C9                     RET
2145: EF45         ;---------------------
2146: EF45         ;set file Attributes for current fcb
2147: EF45             SetAttributes:
2148: EF45 0E 0C                  LD     C,fcbExtIndex
2149: EF47 CD 60 F3               CALL   Search4DirElement    ; through file type
2150: EF4A             SetAttributes1:
2151: EF4A CD 04 EE               CALL   EndOfDirectory
2152: EF4D C8                     RET    Z                    ; exit at end of dir
2153: EF4E 0E 00                  LD     C,0
2154: EF50 1E 0C                  LD     E,fcbExtIndex        ;copy name
2155: EF52 CD 21 F4               CALL   CopyDir
2156: EF55 CD 78 F3               CALL   Search4NextDirElement
2157: EF58 C3 4A EF               JP     SetAttributes1
2158: EF5B         ;
2159: EF5B         ;*****************************************************************
2160: EF5B
2161: EF5B         ;*****************************************************************
2162: EF5B         ;********************** File  Routines ***************************
2163: EF5B         ;*****************************************************************
2164: EF5B         ;open file
2165: EF5B         ; IN  - (DE)	FCB Address
2166: EF5B         ; OUT - (A)	Directory Code
2167: EF5B         ;	0-3 = success ; 0FFH = File Not Found
2168: EF5B             vOpenFile:                      ;
2169: EF5B CD E1 F2               CALL   ClearModuleNum       ; clear the module number
2170: EF5E CD F0 F2               CALL   Reselect             ; do we need to reselect disk?
2171: EF61 C3 1D F3               JP     OpenFile
2172: EF64         ;ret ;jmp goback
2173: EF64         ;-----------------------------------------------------------------
2174: EF64         ;close file
2175: EF64             vCloseFile:                      ; func16: (16 - 10) Close File
2176: EF64 CD F0 F2               CALL   Reselect
2177: EF67 C3 C5 F1               JP     CloseDirEntry
2178: EF6A         ;-----------------------------------------------------------------
2179: EF6A         ;search for first occurrence of a file
2180: EF6A         ; In - (DE)	FCB Address
2181: EF6A         ; OUT - (A)	Directory Code
2182: EF6A         ;	0-3 = success ; 0FFH = File Not Found
2183: EF6A             vFindFirst:                      ; func17: (17 - 11) Search for first
2184: EF6A 0E 00                  LD     C,0                  ; length assuming '?' true
2185: EF6C 2A DF EA               LD     HL,(paramDE)
2186: EF6F 7E                     LD     A,(HL)
2187: EF70 FE 3F                  CP     QMARK                ; no reselect if ?
2188: EF72 CA 7D EF               JP     Z,QMarkSelect        ; skip reselect if so
2189: EF75
2190: EF75 CD E1 F2               CALL   ClearModuleNum       ; module number zeroed
2191: EF78 CD F0 F2               CALL   Reselect
2192: EF7B 0E 0F                  LD     C,nameLength
2193: EF7D             QMarkSelect:                      ; qselect:
2194: EF7D CD 60 F3               CALL   Search4DirElement
2195: EF80 C3 0E F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2196: EF83         ;-----------------------------------------------------------------
2197: EF83         ;search for next occurrence of a file name
2198: EF83         ; OUT - (A)	Directory Code
2199: EF83         ;	0-3 = success ; 0FFH = File Not Found
2200: EF83             vFindNext:                      ; func18: (18 - 12) Search for next
2201: EF83 2A 61 F5               LD     HL,(searchAddress)
2202: EF86 22 DF EA               LD     (paramDE),HL
2203: EF89 CD F0 F2               CALL   Reselect
2204: EF8C CD 78 F3               CALL   Search4NextDirElement
2205: EF8F C3 0E F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2206: EF92         ;-----------------------------------------------------------------
2207: EF92         ;search for next occurrence of a file name
2208: EF92         ; OUT - (A)	Directory Code
2209: EF92         ;delete a file
2210: EF92             vDeleteFile:                      ; func18: (19 - 13) Delete File
2211: EF92 CD F0 F2               CALL   Reselect
2212: EF95 CD A3 F1               CALL   DeleteFile
2213: EF98 C3 DA F2               JP     DirLocationToReturnLoc
2214: EF9B         ;-----------------------------------------------------------------
2215: EF9B         ;read sequential
2216: EF9B         ;IN  - (DE) FCB address
2217: EF9B         ;OUT - (A) 00 = success and data available. else no read and no data
2218: EF9B             vReadSeq:                       ; func20: (20 - 14) read sequential
2219: EF9B CD F0 F2               CALL   Reselect
2220: EF9E CD DD EF               CALL   ReadSeq
2221: EFA1 C9                     RET
2222: EFA2         ;-----------------------------------------------------------------
2223: EFA2         ;write sequential
2224: EFA2         ;IN  - (DE) FCB address
2225: EFA2         ;OUT - (A) 00 = success and data available. else no read and no data
2226: EFA2             vWriteSeq:                      ; func21 (21 - 15) write sequention
2227: EFA2 CD F0 F2               CALL   Reselect
2228: EFA5 CD 20 F0               CALL   DiskWriteSeq
2229: EFA8 C9                     RET
2230: EFA9         ;-----------------------------------------------------------------
2231: EFA9         ; Make file
2232: EFA9         ; In - (DE)	FCB Address
2233: EFA9         ; OUT - (A)	Directory Code
2234: EFA9         ;	0-3 = success ; 0FFH = File Not Found
2235: EFA9             vMakeFile:                      ; func22 (22 - 16) Make file
2236: EFA9 CD E1 F2               CALL   ClearModuleNum       ; set S2 to Zero
2237: EFAC CD F0 F2               CALL   Reselect
2238: EFAF C3 6D F1               JP     MakeNewFile
2239: EFB2         ;-----------------------------------------------------------------
2240: EFB2         ; Rename file
2241: EFB2         ; In - (DE)	FCB Address
2242: EFB2         ; OUT - (A)	Directory Code
2243: EFB2         ;	0-3 = success ; 0FFH = File Not Found
2244: EFB2             vRenameFile:                      ; func23 (23 - 17) Rename File
2245: EFB2 CD F0 F2               CALL   Reselect
2246: EFB5 CD 48 F1               CALL   Rename
2247: EFB8 C3 DA F2               JP     DirLocationToReturnLoc
2248: EFBB         ;-----------------------------------------------------------------
2249: EFBB         ;-----------------------------------------------------------------
2250: EFBB         ;*****************************************************************
2251: EFBB         ;-----------------------------------------------------------------
2252: EFBB         ;check current directory element for read/only status
2253: EFBB             CheckRODirectory:
2254: EFBB CD F0 EE               CALL   GetDirElementAddress ; address of element
2255: EFBE         ;	JMP	CheckROFile
2256: EFBE         ;------------
2257: EFBE         ;check current buff(dptr) or fcb(0) for r/o status
2258: EFBE             CheckROFile:
2259: EFBE 11 09 00               LD     DE,fcbROfileIndex
2260: EFC1 19                     ADD    HL,DE                ; offset to ro bit
2261: EFC2 7E                     LD     A,(HL)
2262: EFC3 17                     RLA
2263: EFC4 D0                     RET    NC                   ; return if not set
2264: EFC5 C3 AB F4               JP     errReadOnlyFile      ; exit to read only disk message
2265: EFC8         ;-----------------------------------------------------------------
2266: EFC8         ;check for write protected disk
2267: EFC8             CheckWrite:
2268: EFC8 CD CF EF               CALL   DoNotWrite
2269: EFCB C8                     RET    Z                    ; ok to write if not rodsk
2270: EFCC C3 A5 F4               JP     errReadOnlyDisk      ; read only disk error
2271: EFCF         ;-----------------------------------------------------------------
2272: EFCF         ;return true if dir checksum difference occurred
2273: EFCF             DoNotWrite:
2274: EFCF 2A 36 F5               LD     HL,(ReadOnlyVector)
2275: EFD2 3A 34 F5               LD     A,(currentDisk)
2276: EFD5 4F                     LD     C,A
2277: EFD6 CD 7B F4               CALL   ShiftRightHLbyC
2278: EFD9 7D                     LD     A,L
2279: EFDA E6 1B                  AND    1BH                  ; 01BH
2280: EFDC C9                     RET                         ; non zero if nowrite
2281: EFDD         ;-----------------------------------------------------------------
2282: EFDD         ;sequential disk read operation
2283: EFDD             ReadSeq:
2284: EFDD 3E 01                  LD     A,1
2285: EFDF 32 5E F5               LD     (seqReadFlag),A      ; set flag for seqential read
2286: EFE2         ;---
2287: EFE2         ; read the disk
2288: EFE2         ; read the next record from the current fcb
2289: EFE2             DiskRead:
2290: EFE2 3E FF                  LD     A,TRUE
2291: EFE4 32 5C F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
2292: EFE7
2293: EFE7 CD 1C EF               CALL   SetRecordVars        ; sets cpmRecord, fcbRecordCount and EXM
2294: EFEA 3A 69 F5               LD     A,(cpmRecord)
2295: EFED 21 67 F5               LD     HL,fcbRecordCount
2296: EFF0 BE                     CP     M                    ; cpmRecord-fcbRecordCount
2297: EFF1         ; skip if  cpmRecord < fcbRecordCount
2298: EFF1 DA 07 F0               JP     C,RecordOK
2299: EFF4         ; not enough records in the extent
2300: EFF4 FE 80                  CP     RecordsPerExtent     ; cpmRecord = 128?   *** Records in an Extent
2301: EFF6 C2 1D F0               JP     NZ,DiskEOF           ; skip if cpmRecord<>128
2302: EFF9 CD E5 F0               CALL   OpenNextExt          ; go to next extent if so
2303: EFFC AF                     XOR    A
2304: EFFD 32 69 F5               LD     (cpmRecord),A        ; cpmRecord=00
2305: F000         ; now check for open ok
2306: F000 3A E1 EA               LD     A,(exitParameterByte)
2307: F003 B7                     OR     A
2308: F004 C2 1D F0               JP     NZ,DiskEOF
2309: F007         ; stop at eof
2310: F007         ; arrive with fcb addressing a record to read
2311: F007             RecordOK:                       ; recordok:
2312: F007 CD AE F2               CALL   GetBlockNumber       ; save it in currentBlock
2313: F00A CD BB F2               CALL   IsAllocated          ; currentBlock=0000?
2314: F00D CA 1D F0               JP     Z,DiskEOF            ; get out if not allocated already
2315: F010
2316: F010 CD C1 F2               CALL   SetActualRecordAdd   ; currentBlock now a record value
2317: F013 CD 58 EE               CALL   Seek                 ; to proper track,sector
2318: F016 CD 5E F2               CALL   ReadBuffer           ; to dma address
2319: F019 CD 33 EF               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
2320: F01C C9                     RET
2321: F01D             DiskEOF:                        ; diskeof:
2322: F01D C3 F7 F3               JP     SetLowReturnTo1      ; exitParameterByte = 1
2323: F020         ;ret
2324: F020         ;-----------------------------------------------------------------
2325: F020         ;sequential disk write
2326: F020             DiskWriteSeq:
2327: F020 3E 01                  LD     A,1
2328: F022 32 5E F5               LD     (seqReadFlag),A
2329: F025         ;--------
2330: F025         ;disk write
2331: F025             DiskWrite:
2332: F025 3E 00                  LD     A,FALSE
2333: F027 32 5C F5               LD     (readModeFlag),A
2334: F02A         ; write record to currently selected file
2335: F02A CD C8 EF               CALL   CheckWrite           ; in case write protected
2336: F02D 2A DF EA               LD     HL,(paramDE)         ; HL = .fcb(0)
2337: F030 CD BE EF               CALL   CheckROFile          ; may be a read-only file
2338: F033 CD 1C EF               CALL   SetRecordVars        ; set local Record parameters
2339: F036 3A 69 F5               LD     A,(cpmRecord)
2340: F039 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
2341: F03B DA 42 F0               JP     C,DiskWrite1         ; skip if in the same Extent
2342: F03E CD F7 F3               CALL   SetLowReturnTo1
2343: F041 C9                     RET                         ; Exit ???????????
2344: F042
2345: F042         ; can write the next record, so continue
2346: F042             DiskWrite1:
2347: F042 CD AE F2               CALL   GetBlockNumber       ; sets up actual block number
2348: F045 CD BB F2               CALL   IsAllocated
2349: F048 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
2350: F04A C2 95 F0               JP     NZ,DiskWrite3
2351: F04D         ; not allocated -
2352: F04D         ; the argument to getblock is the starting position for the disk search
2353: F04D         ; and should be the last allocated block for this file,
2354: F04D         ; or the value 0 if no space has been allocated
2355: F04D
2356: F04D CD 36 F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
2357: F050 32 5F F5               LD     (diskMapIndex),A     ; save for later
2358: F053 01 00 00               LD     BC,0000h             ; may use block zero
2359: F056 B7                     OR     A
2360: F057 CA 61 F0               JP     Z,FirstBlock         ; skip if no previous block
2361: F05A         ; previous block exists
2362: F05A 4F                     LD     C,A
2363: F05B 0B                     DEC    BC                   ; previous block # in BC
2364: F05C CD 56 F4               CALL   GetDiskMapValue      ; previous block # to HL
2365: F05F 44                     LD     B,H
2366: F060 4D                     LD     C,L                  ; BC=prev block#
2367: F061         ; BC = 0000, or previous block #
2368: F061             FirstBlock:
2369: F061 CD 74 F2               CALL   GetClosestBlock      ; block # to HL
2370: F064         ; arrive here with block# or zero
2371: F064 7D                     LD     A,L
2372: F065 B4                     OR     H
2373: F066 C2 6F F0               JP     NZ,BlockOK
2374: F069         ; cannot find a block to allocate
2375: F069 3E 02                  LD     A,2
2376: F06B 32 E1 EA               LD     (exitParameterByte),A
2377: F06E C9                     RET                         ; exitParameterByte=2
2378: F06F
2379: F06F             BlockOK:
2380: F06F 22 6B F5               LD     (currentBlock),HL    ; allocated block number is in HL
2381: F072 EB                     EX     DE,HL                ; block number to DE
2382: F073 2A DF EA               LD     HL,(paramDE)
2383: F076 01 10 00               LD     BC,fcbDiskMapIndex
2384: F079 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
2385: F07A 3A 63 F5               LD     A,(single)
2386: F07D B7                     OR     A                    ; set flags for single byte dm
2387: F07E 3A 5F F5               LD     A,(diskMapIndex)     ; recall dm index
2388: F081 CA 8B F0               JP     Z,Allocate16Bit      ; skip if allocating word
2389: F084         ; else allocate using a byte value
2390: F084 CD 6F F4               CALL   AddAtoHL
2391: F087 73                     LD     (HL),E               ; single byte alloc
2392: F088 C3 93 F0               JP     DiskWrite2           ; to continue
2393: F08B
2394: F08B             Allocate16Bit:                      ; allocate a word value
2395: F08B
2396: F08B 4F                     LD     C,A
2397: F08C 06 00                  LD     B,0                  ; double(diskMapIndex)
2398: F08E 09                     ADD    HL,BC
2399: F08F 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
2400: F090 72                     LD     (HL),D
2401: F091 23                     INC    HL
2402: F092 73                     LD     (HL),E               ; double wd
2403: F093         ; disk write to previously unallocated block
2404: F093             DiskWrite2:
2405: F093 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
2406: F095
2407: F095         ; continue the write operation of no allocation error
2408: F095         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
2409: F095
2410: F095             DiskWrite3:
2411: F095 3A E1 EA               LD     A,(exitParameterByte)
2412: F098 B7                     OR     A
2413: F099 C0                     RET    NZ                   ; stop if non zero returned value
2414: F09A
2415: F09A C5                     PUSH   BC                   ; save write flag ( in C see above)
2416: F09B CD C1 F2               CALL   SetActualRecordAdd   ; currentBlock set to actual record number
2417: F09E CD 58 EE               CALL   Seek                 ; to proper file position
2418: F0A1 C1                     POP    BC                   ; get write flag
2419: F0A2 C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
2420: F0A3 CD 56 F2               CALL   WriteBuffer          ; written to disk
2421: F0A6 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
2422: F0A7         ; increment record count if fcbRecordCount<=cpmRecord
2423: F0A7 3A 69 F5               LD     A,(cpmRecord)
2424: F0AA 21 67 F5               LD     HL,fcbRecordCount
2425: F0AD BE                     CP     M                    ; cpmRecord-fcbRecordCount
2426: F0AE DA B5 F0               JP     C,DiskWrite4
2427: F0B1         ; fcbRecordCount <= cpmRecord
2428: F0B1 77                     LD     (HL),A
2429: F0B2 34                     INC    M                    ; fcbRecordCount = cpmRecord+1
2430: F0B3 0E 02                  LD     C,2                  ; mark as record count incremented
2431: F0B5             DiskWrite4:
2432: F0B5         ; A has cpmRecord, C=2 if new block or new record#
2433: F0B5 0D                     DEC    C
2434: F0B6 0D                     DEC    C
2435: F0B7 C2 C2 F0               JP     NZ,DiskWrite5
2436: F0BA F5                     PUSH   AF                   ; save cpmRecord value
2437: F0BB CD E7 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2438: F0BE         ; reset the file write flag to mark as written fcb
2439: F0BE E6 7F                  AND    7FH                  ; not writeFlagMask
2440: F0C0 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2441: F0C1 F1                     POP    AF                   ; restore cpmRecord
2442: F0C2             DiskWrite5:
2443: F0C2         ; check for end of extent, if found attempt to open next extent in preparation for next write
2444: F0C2 FE 7F                  CP     highestRecordNumber  ; cpmRecord=highestRecordNumber?
2445: F0C4 C2 E2 F0               JP     NZ,DiskWrite7        ; skip if not
2446: F0C7         ; may be random access write, if so we are done
2447: F0C7 3A 5E F5               LD     A,(seqReadFlag)
2448: F0CA B7                     OR     A
2449: F0CB CA E2 F0               JP     Z,DiskWrite7         ; skip next extent open op
2450: F0CE         ; update current fcb before going to next extent
2451: F0CE CD 33 EF               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2452: F0D1 CD E5 F0               CALL   OpenNextExt          ; readModeFlag=false
2453: F0D4         ; cpmRecord remains at highestRecordNumber causing eof if no more directory space is available
2454: F0D4 21 E1 EA               LD     HL,exitParameterByte
2455: F0D7 7E                     LD     A,(HL)
2456: F0D8 B7                     OR     A
2457: F0D9 C2 E0 F0               JP     NZ,DiskWrite6        ; no space
2458: F0DC         ; space available, set cpmRecord=255
2459: F0DC 3D                     DEC    A
2460: F0DD 32 69 F5               LD     (cpmRecord),A        ; goes to 00 next time
2461: F0E0             DiskWrite6:
2462: F0E0 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
2463: F0E2             DiskWrite7:
2464: F0E2 C3 33 EF               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2465: F0E5         ;ret
2466: F0E5         ;-----------------------------------------------------------------
2467: F0E5         ;close the current extent  and open the next one if possible.
2468: F0E5         ;readModeFlag is true if in read mode
2469: F0E5             OpenNextExt:                      ; open$reel
2470: F0E5 AF                     XOR    A
2471: F0E6 32 5B F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
2472: F0E9 CD C5 F1               CALL   CloseDirEntry        ; close current extent
2473: F0EC         ; exitParameterByte remains at enddir if we cannot open the next ext
2474: F0EC CD 04 EE               CALL   EndOfDirectory
2475: F0EF C8                     RET    Z                    ; return if end
2476: F0F0 2A DF EA               LD     HL,(paramDE)         ; increment extent number
2477: F0F3 01 0C 00               LD     BC,fcbExtIndex
2478: F0F6 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
2479: F0F7 7E                     LD     A,(HL)
2480: F0F8 3C                     INC    A
2481: F0F9 E6 1F                  AND    maxExtValue
2482: F0FB 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
2483: F0FC CA 0E F1               JP     Z,OpenNextModule     ; move to next module if zero
2484: F0FF         ; may be in the same extent group
2485: F0FF 47                     LD     B,A
2486: F100 3A 4E F5               LD     A,(dpbEXM)
2487: F103 A0                     AND    B
2488: F104         ; if result is zero, then not in the same group
2489: F104 21 5B F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
2490: F107 A6                     AND    M                    ; produces a 00 in accumulator if not written
2491: F108 CA 19 F1               JP     Z,OpenNextExt1       ; go to next physical extent
2492: F10B         ; result is non zero, so we must be in same logical ext
2493: F10B C3 37 F1               JP     OpenNextExt2         ; to copy fcb information
2494: F10E         ; extent number overflow, go to next module
2495: F10E
2496: F10E             OpenNextModule:
2497: F10E 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
2498: F111 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
2499: F112 34                     INC    M                    ; fcb(fcbS2Index)=++1
2500: F113         ; module number incremented, check for overflow
2501: F113 7E                     LD     A,(HL)
2502: F114 E6 0F                  AND    moduleMask           ; mask high order bits
2503: F116 CA 42 F1               JP     Z,OpenNextExtError   ; cannot overflow to zero
2504: F119         ; otherwise, ok to continue with new module
2505: F119
2506: F119             OpenNextExt1:
2507: F119 0E 0F                  LD     C,nameLength
2508: F11B CD 60 F3               CALL   Search4DirElement    ; next extent found?
2509: F11E CD 04 EE               CALL   EndOfDirectory
2510: F121 C2 37 F1               JP     NZ,OpenNextExt2
2511: F124         ; end of file encountered
2512: F124 3A 5C F5               LD     A,(readModeFlag)
2513: F127 3C                     INC    A                    ; 0ffh becomes 00 if read
2514: F128 CA 42 F1               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
2515: F12B         ; try to extend the current file
2516: F12B CD 6D F1               CALL   MakeNewFile
2517: F12E         ; cannot be end of directory
2518: F12E CD 04 EE               CALL   EndOfDirectory
2519: F131 CA 42 F1               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
2520: F134 C3 3A F1               JP     OpenNextExt3
2521: F137
2522: F137         ; not end of file, open
2523: F137             OpenNextExt2:
2524: F137 CD 26 F3               CALL   OpenFileCopyFCB
2525: F13A             OpenNextExt3:
2526: F13A CD 1C EF               CALL   SetRecordVars        ; Set Record parameters
2527: F13D AF                     XOR    A
2528: F13E 32 E1 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
2529: F141 C9                     RET                         ; with exitParameterByte = 0
2530: F142
2531: F142         ; cannot move to next extent of this file
2532: F142             OpenNextExtError:
2533: F142 CD F7 F3               CALL   SetLowReturnTo1      ; exitParameterByte = 1
2534: F145 C3 F0 F3               JP     SetFileWriteFlag     ; ensure that it will not be closed
2535: F148         ;-----------------------------------------------------------------
2536: F148         ;rename the file described by the first half of the currently addressed FCB.
2537: F148         ;the new name is contained in the last half of the FCB. The file name and type
2538: F148         ;are changed, but the reel number is ignored.  the user number is identical
2539: F148             Rename:
2540: F148 CD C8 EF               CALL   CheckWrite           ; may be write protected
2541: F14B         ; search up to the extent field
2542: F14B 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
2543: F14D CD 60 F3               CALL   Search4DirElement
2544: F150         ; copy position 0
2545: F150 2A DF EA               LD     HL,(paramDE)
2546: F153 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
2547: F154 11 10 00               LD     DE,fcbDiskMapIndex
2548: F157 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
2549: F158 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
2550: F159         ; assume the same disk drive for new named file
2551: F159             Rename1:
2552: F159 CD 04 EE               CALL   EndOfDirectory
2553: F15C C8                     RET    Z                    ; stop at end of dir
2554: F15D         ; not end of directory, rename next element
2555: F15D CD BB EF               CALL   CheckRODirectory     ; may be read-only file
2556: F160 0E 10                  LD     C,fcbDiskMapIndex
2557: F162 1E 0C                  LD     E,fcbExtIndex
2558: F164 CD 21 F4               CALL   CopyDir
2559: F167         ; element renamed, move to next
2560: F167 CD 78 F3               CALL   Search4NextDirElement
2561: F16A C3 59 F1               JP     Rename1
2562: F16D         ;-----------------------------------------------------------------
2563: F16D         ;create a new file by creating a directory entry then opening the file
2564: F16D             MakeNewFile:
2565: F16D CD C8 EF               CALL   CheckWrite           ; may be write protected
2566: F170 2A DF EA               LD     HL,(paramDE)
2567: F173 E5                     PUSH   HL                   ; save fcb address, look for e5
2568: F174 21 35 F5               LD     HL,emptyFCB
2569: F177 22 DF EA               LD     (paramDE),HL         ; paramDE = .empty
2570: F17A 0E 01                  LD     C,1
2571: F17C CD 60 F3               CALL   Search4DirElement    ; length 1 match on empty entry
2572: F17F CD 04 EE               CALL   EndOfDirectory       ; zero flag set if no space
2573: F182 E1                     POP    HL                   ; recall paramDE address
2574: F183 22 DF EA               LD     (paramDE),HL         ; in case we return here
2575: F186 C8                     RET    Z                    ; return with error condition 255 if not found
2576: F187 EB                     EX     DE,HL                ; DE = paramDE address
2577: F188         ; clear the remainder of the fcb
2578: F188 21 0F 00               LD     HL,nameLength
2579: F18B 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
2580: F18C 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
2581: F18E AF                     XOR    A                    ; clear accumulator to 00 for fill
2582: F18F             MakeNewFile1:
2583: F18F 77                     LD     (HL),A
2584: F190 23                     INC    HL
2585: F191 0D                     DEC    C
2586: F192 C2 8F F1               JP     NZ,MakeNewFile1
2587: F195 21 0D 00               LD     HL,fcbS1Index
2588: F198 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
2589: F199 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
2590: F19A CD F9 EE               CALL   SetDirectoryEntry    ; may have extended the directory
2591: F19D         ; now copy entry to the directory
2592: F19D CD 1A F4               CALL   CopyFCB
2593: F1A0         ; and set the file write flag to "1"
2594: F1A0 C3 F0 F3               JP     SetFileWriteFlag
2595: F1A3         ;-----------------------------------------------------------------
2596: F1A3         ;delete the currently addressed file
2597: F1A3             DeleteFile:
2598: F1A3 CD C8 EF               CALL   CheckWrite           ; write protected ?
2599: F1A6 0E 0C                  LD     C,fcbExtIndex        ; extent number field
2600: F1A8 CD 60 F3               CALL   Search4DirElement    ; search through file type
2601: F1AB             DeleteFile1:
2602: F1AB         ; loop while directory matches
2603: F1AB CD 04 EE               CALL   EndOfDirectory
2604: F1AE C8                     RET    Z                    ; exit if end
2605: F1AF         ; set each non zero disk map entry to 0 in the allocation vector
2606: F1AF CD BB EF               CALL   CheckRODirectory     ; ro disk error if found
2607: F1B2 CD F0 EE               CALL   GetDirElementAddress ; HL=.buff(dptr)
2608: F1B5 36 E5                  LD     (HL),emptyDir
2609: F1B7 0E 00                  LD     C,0
2610: F1B9 CD 6D ED               CALL   ScanDiskMap          ; alloc elts set to 0
2611: F1BC CD 48 F2               CALL   WriteDir             ; write the directory
2612: F1BF CD 78 F3               CALL   Search4NextDirElement ; to next element
2613: F1C2 C3 AB F1               JP     DeleteFile1          ; for another record
2614: F1C5         ;-----------------------------------------------------------------
2615: F1C5         ;locate the directory element and re-write it
2616: F1C5             CloseDirEntry:
2617: F1C5 AF                     XOR    A
2618: F1C6 32 E1 EA               LD     (exitParameterByte),A
2619: F1C9 CD CF EF               CALL   DoNotWrite           ; return TRUE (0) if checksum change
2620: F1CC C0                     RET    NZ                   ; skip close if r/o disk
2621: F1CD         ; check file write flag - 0 indicates written
2622: F1CD CD E7 F2               CALL   GetModuleNum         ; fcb(fcbS2Index) in A
2623: F1D0 E6 80                  AND    writeFlagMask
2624: F1D2 C0                     RET    NZ                   ; return if bit remains set
2625: F1D3 0E 0F                  LD     C,nameLength
2626: F1D5 CD 60 F3               CALL   Search4DirElement    ; locate file
2627: F1D8 CD 04 EE               CALL   EndOfDirectory
2628: F1DB C8                     RET    Z                    ; return if not found
2629: F1DC         ; merge the disk map at paramDE with that at buff(dptr)
2630: F1DC 01 10 00               LD     BC,fcbDiskMapIndex
2631: F1DF CD F0 EE               CALL   GetDirElementAddress
2632: F1E2 09                     ADD    HL,BC
2633: F1E3 EB                     EX     DE,HL                ; DE is .buff(dptr+16)
2634: F1E4 2A DF EA               LD     HL,(paramDE)
2635: F1E7 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
2636: F1E8 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of single byte dm
2637: F1EA             CloseDirEntry1:
2638: F1EA 3A 63 F5               LD     A,(single)
2639: F1ED B7                     OR     A
2640: F1EE CA 05 F2               JP     Z,CloseDirEntry4     ; skip to double
2641: F1F1         ; this is a single byte map
2642: F1F1         ; if fcb(i) = 0 then fcb(i) = buff(i)
2643: F1F1         ; if buff(i) = 0 then buff(i) = fcb(i)
2644: F1F1         ; if fcb(i) <> buff(i) then error
2645: F1F1 7E                     LD     A,(HL)
2646: F1F2 B7                     OR     A
2647: F1F3 1A                     LD     A,(DE)
2648: F1F4 C2 F8 F1               JP     NZ,CloseDirEntry2
2649: F1F7         ; fcb(i) = 0
2650: F1F7 77                     LD     (HL),A               ; fcb(i) = buff(i)
2651: F1F8             CloseDirEntry2:
2652: F1F8 B7                     OR     A
2653: F1F9 C2 FE F1               JP     NZ,CloseDirEntry3
2654: F1FC         ; buff(i) = 0
2655: F1FC 7E                     LD     A,(HL)
2656: F1FD 12                     LD     (DE),AE              ; buff(i)=fcb(i)
2657: F1FE             CloseDirEntry3:
2658: F1FE BE                     CP     M
2659: F1FF C2 3D F2               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
2660: F202 C3 1A F2               JP     CloseDirEntry5       ; if merge ok
2661: F205
2662: F205         ; this is a double byte merge operation
2663: F205             CloseDirEntry4:
2664: F205 CD 66 F2               CALL   Merge                ; buff = fcb if buff 0000
2665: F208 EB                     EX     DE,HL
2666: F209 CD 66 F2               CALL   Merge
2667: F20C EB                     EX     DE,HL                ; fcb = buff if fcb 0000
2668: F20D         ; they should be identical at this point
2669: F20D 1A                     LD     A,(DE)
2670: F20E BE                     CP     M
2671: F20F C2 3D F2               JP     NZ,CloseDirEntryError ; low same?
2672: F212 13                     INC    DE
2673: F213 23                     INC    HL                   ; to high byte
2674: F214 1A                     LD     A,(DE)
2675: F215 BE                     CP     M
2676: F216 C2 3D F2               JP     NZ,CloseDirEntryError ; high same?
2677: F219         ;	merge operation ok for this pair
2678: F219 0D                     DEC    C                    ; extra count for double byte
2679: F21A             CloseDirEntry5:
2680: F21A 13                     INC    DE
2681: F21B 23                     INC    HL                   ; to next byte position
2682: F21C 0D                     DEC    C
2683: F21D C2 EA F1               JP     NZ,CloseDirEntry1    ; for more
2684: F220         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
2685: F220 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
2686: F223 09                     ADD    HL,BC
2687: F224 EB                     EX     DE,HL
2688: F225 09                     ADD    HL,BC
2689: F226         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
2690: F226 1A                     LD     A,(DE)               ; current user extent number
2691: F227         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
2692: F227 BE                     CP     M
2693: F228 DA 34 F2               JP     C,CloseDirEntryEnd
2694: F22B         ; fcb extent number >= dir extent number
2695: F22B 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
2696: F22C         ; update directory record count field
2697: F22C 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
2698: F22F 09                     ADD    HL,BC
2699: F230 EB                     EX     DE,HL
2700: F231 09                     ADD    HL,BC
2701: F232         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
2702: F232 7E                     LD     A,(HL)
2703: F233 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
2704: F234             CloseDirEntryEnd:
2705: F234 3E FF                  LD     A,TRUE
2706: F236 32 5B F5               LD     (fcbCopiedFlag),A    ; mark as copied
2707: F239 CD 42 F2               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
2708: F23C C9                     RET
2709: F23D
2710: F23D         ; elements did not merge correctly
2711: F23D             CloseDirEntryError:
2712: F23D 21 E1 EA               LD     HL,exitParameterByte
2713: F240 35                     DEC    M                    ; =255 non zero flag set
2714: F241 C9                     RET
2715: F242         ;-----------------------------------------------------------------
2716: F242         ;enter from CloseDirEntry to seek and copy current element
2717: F242             SeekCopy:
2718: F242 CD 47 EE               CALL   SeekDir              ; to the directory element
2719: F245 C3 48 F2               JP     WriteDir             ; write the directory element
2720: F248         ;ret
2721: F248         ;-----------------------------------------------------------------
2722: F248         ;write the current directory entry, set checksum
2723: F248             WriteDir:
2724: F248 CD B9 EE               CALL   NewCheckSum          ; initialize entry
2725: F24B CD FB ED               CALL   SetDirDMA            ; directory dma
2726: F24E 0E 01                  LD     C,1                  ; indicates a write directory operation
2727: F250 CD 56 F2               CALL   WriteBuffer          ; write the buffer
2728: F253 C3 F5 ED               JP     SetDataDMA           ; to data dma address
2729: F256         ;ret
2730: F256         ;-----------------------------------------------------------------
2731: F256         ;write buffer and check condition
2732: F256         ;write type (wrtype) is in register C
2733: F256         ;wrtype = 0 => normal write operation		WriteAllocated
2734: F256         ;wrtype = 1 => directory write operation	WriteDirectory
2735: F256         ;wrtype = 2 => start of new block			WriteCleanBuffer
2736: F256             WriteBuffer:
2737: F256 CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
2738: F259 B7                     OR     A
2739: F25A C2 C4 F4               JP     NZ,erPermanentNoWait ; error if not 00
2740: F25D C9                     RET
2741: F25E         ;-----------------------------------------------------------------
2742: F25E         ;read buffer and check condition
2743: F25E             ReadBuffer:
2744: F25E CD 27 F6               CALL   bcRead               ; current drive, track, sector, dma
2745: F261 B7                     OR     A
2746: F262 C2 C4 F4               JP     NZ,erPermanentNoWait
2747: F265 C9                     RET
2748: F266         ;-----------------------------------------------------------------
2749: F266         ;HL = .fcb1(i), DE = .fcb2(i),
2750: F266         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
2751: F266             Merge:
2752: F266 7E                     LD     A,(HL)
2753: F267 23                     INC    HL
2754: F268 B6                     OR     M
2755: F269 2B                     DEC    HL
2756: F26A C0                     RET    NZ                   ; return if = 0000
2757: F26B 1A                     LD     A,(DE)
2758: F26C 77                     LD     (HL),A
2759: F26D 13                     INC    DE
2760: F26E 23                     INC    HL                   ; low byte copied
2761: F26F 1A                     LD     A,(DE)
2762: F270 77                     LD     (HL),A
2763: F271 1B                     DEC    DE
2764: F272 2B                     DEC    HL                   ; back to input form
2765: F273 C9                     RET
2766: F274         ;-----------------------------------------------------------------
2767: F274         ;compute closest disk block number from current block
2768: F274         ;given allocation vector position BC, find the zero bit closest to this position
2769: F274         ;by searching left and right.
2770: F274         ;if found, set the bit to one and return the bit position in hl.
2771: F274         ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
2772: F274             GetClosestBlock:
2773: F274 50                     LD     D,B
2774: F275 59                     LD     E,C                  ; copy of starting position to de
2775: F276             TestLeft:
2776: F276 79                     LD     A,C
2777: F277 B0                     OR     B
2778: F278 CA 87 F2               JP     Z,TestRight          ; skip if left=0000
2779: F27B         ; left not at position zero, bit zero?
2780: F27B 0B                     DEC    BC
2781: F27C D5                     PUSH   DE
2782: F27D C5                     PUSH   BC                   ; left,right pushed
2783: F27E CD 9B ED               CALL   GetAllocBit
2784: F281 1F                     RRA
2785: F282 D2 A2 F2               JP     NC,ReturnBlockNumber ; return block number if zero
2786: F285         ; bit is one, so try the right
2787: F285 C1                     POP    BC
2788: F286 D1                     POP    DE                   ; left, right restored
2789: F287             TestRight:
2790: F287 2A 4F F5               LD     HL,(dpbDSM)          ; value of maximum allocation#
2791: F28A 7B                     LD     A,E
2792: F28B 95                     SUB    L
2793: F28C 7A                     LD     A,D
2794: F28D 9C                     SBC    A,H                  ; right=dpbDSM?
2795: F28E D2 AA F2               JP     NC,ReturnBlockZero   ; return block 0000 if so
2796: F291 13                     INC    DE
2797: F292 C5                     PUSH   BC
2798: F293 D5                     PUSH   DE                   ; left, right pushed
2799: F294 42                     LD     B,D
2800: F295 4B                     LD     C,E                  ; ready right for call
2801: F296 CD 9B ED               CALL   GetAllocBit
2802: F299 1F                     RRA
2803: F29A D2 A2 F2               JP     NC,ReturnBlockNumber ; return block number if zero
2804: F29D D1                     POP    DE
2805: F29E C1                     POP    BC                   ; restore left and right pointers
2806: F29F C3 76 F2               JP     TestLeft             ; for another attempt
2807: F2A2             ReturnBlockNumber:
2808: F2A2 17                     RLA
2809: F2A3 3C                     INC    A                    ; bit back into position and set to 1
2810: F2A4         ; 	D contains the number of shifts required to reposition
2811: F2A4 CD CD ED               CALL   RotateAndReplace     ; move bit back to position and store
2812: F2A7 E1                     POP    HL
2813: F2A8 D1                     POP    DE                   ; HL returned value, DE discarded
2814: F2A9 C9                     RET
2815: F2AA
2816: F2AA         ; cannot find an available bit, return 0000
2817: F2AA             ReturnBlockZero:
2818: F2AA 21 00 00               LD     HL,0000H
2819: F2AD C9                     RET
2820: F2AE         ;-----------------------------------------------------------------
2821: F2AE         ;compute disk block number from current fcb
2822: F2AE             GetBlockNumber:
2823: F2AE CD 36 F4               CALL   GetDiskMapIndex      ; 0...15 in register A
2824: F2B1 4F                     LD     C,A
2825: F2B2 06 00                  LD     B,0
2826: F2B4 CD 56 F4               CALL   GetDiskMapValue      ; return value in HL
2827: F2B7 22 6B F5               LD     (currentBlock),HL    ; save for later
2828: F2BA C9                     RET
2829: F2BB         ;-----------------------------------------------------------------
2830: F2BB         ;is  block allocated
2831: F2BB             IsAllocated:
2832: F2BB 2A 6B F5               LD     HL,(currentBlock)
2833: F2BE 7D                     LD     A,L
2834: F2BF B4                     OR     H
2835: F2C0 C9                     RET
2836: F2C1         ;-----------------------------------------------------------------
2837: F2C1         ;compute actual record address
2838: F2C1         ; result = currentBlock * ( 2**BSH)
2839: F2C1             SetActualRecordAdd:
2840: F2C1 3A 4C F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
2841: F2C4 2A 6B F5               LD     HL,(currentBlock)
2842: F2C7
2843: F2C7             SetActualRecordAdd1:
2844: F2C7 29                     ADD    HL,HL
2845: F2C8 3D                     DEC    A                    ; shl(currentBlock,dpbBSH)
2846: F2C9 C2 C7 F2               JP     NZ,SetActualRecordAdd1
2847: F2CC         ; HL has Record number for start of the block;
2848: F2CC 3A 4D F5               LD     A,(dpbBLM)           ; get block mask
2849: F2CF 4F                     LD     C,A                  ; to get cpmRecord mod Block
2850: F2D0 3A 69 F5               LD     A,(cpmRecord)        ; get index into block
2851: F2D3 A1                     AND    C                    ; masked value in A
2852: F2D4 B5                     OR     L
2853: F2D5 6F                     LD     L,A                  ; to HL
2854: F2D6 22 6B F5               LD     (currentBlock),HL    ; currentBlock=HL or (cpmRecord and dpbBLM)
2855: F2D9         ; *** currentBlock now has current record number - Starting record number + index into block
2856: F2D9 C9                     RET
2857: F2DA         ;-----------------------------------------------------------------
2858: F2DA         ;---------------------
2859: F2DA         ;copy directory location to exitParameterByte
2860: F2DA             DirLocationToReturnLoc:
2861: F2DA 3A 5D F5               LD     A,(directoryFlag)
2862: F2DD 32 E1 EA               LD     (exitParameterByte),A
2863: F2E0 C9                     RET
2864: F2E1         ;---------------------
2865: F2E1         ;clear the module number field for user open/make (S2)
2866: F2E1             ClearModuleNum:
2867: F2E1 CD E7 F2               CALL   GetModuleNum
2868: F2E4 36 00                  LD     (HL),0               ; fcb(fcbS2Index)=0
2869: F2E6 C9                     RET
2870: F2E7         ;---------------------
2871: F2E7         ;get data module number (high order bit is fwf -file write flag)
2872: F2E7             GetModuleNum:
2873: F2E7 2A DF EA               LD     HL,(paramDE)
2874: F2EA 11 0E 00               LD     DE,fcbS2Index
2875: F2ED 19                     ADD    HL,DE                ; HL=.fcb(fcbS2Index)
2876: F2EE 7E                     LD     A,(HL)
2877: F2EF C9                     RET                         ; A=fcb(fcbS2Index)
2878: F2F0         ;---------------------
2879: F2F0         ;check current fcb to see if reselection necessary
2880: F2F0             Reselect:
2881: F2F0 3E FF                  LD     A,TRUE
2882: F2F2 32 64 F5               LD     (fResel),A           ;mark possible reselect
2883: F2F5 2A DF EA               LD     HL,(paramDE)
2884: F2F8 7E                     LD     A,(HL)               ; drive select code
2885: F2F9 E6 1F                  AND    00011111B            ; non zero is auto drive select
2886: F2FB 3D                     DEC    A                    ; drive code normalized to 0..30, or 255
2887: F2FC 32 DE EA               LD     (paramE),A           ; save drive code
2888: F2FF FE 1E                  CP     30
2889: F301 D2 14 F3               JP     NC,NoSelect
2890: F304         ; auto select function, save currentDisk
2891: F304 3A 34 F5               LD     A,(currentDisk)
2892: F307 32 65 F5               LD     (entryDisk),A        ; entryDisk=currentDisk
2893: F30A 7E                     LD     A,(HL)
2894: F30B 32 66 F5               LD     (fcbDisk),A          ; save drive code
2895: F30E E6 E0                  AND    11100000B
2896: F310 77                     LD     (HL),A               ; preserve hi bits
2897: F311 CD 6D EC               CALL   SelectCurrent
2898: F314             NoSelect:                       ; noselect:
2899: F314
2900: F314 3A 2F F5               LD     A,(currentUserNumber) ; set user code 0...31
2901: F317 2A DF EA               LD     HL,(paramDE)
2902: F31A B6                     OR     M
2903: F31B 77                     LD     (HL),A
2904: F31C C9                     RET
2905: F31D         ;---------------------
2906: F31D         ;search for the directory entry, copy to fcb
2907: F31D             OpenFile:
2908: F31D 0E 0F                  LD     C,nameLength
2909: F31F CD 60 F3               CALL   Search4DirElement
2910: F322 CD 04 EE               CALL   EndOfDirectory
2911: F325 C8                     RET    Z                    ; return with exitParameterByte=255 if end
2912: F326
2913: F326         ; not end of directory, copy fcb information
2914: F326             OpenFileCopyFCB:
2915: F326 CD E8 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2916: F329 7E                     LD     A,(HL)
2917: F32A F5                     PUSH   AF
2918: F32B E5                     PUSH   HL                   ; save extent#
2919: F32C CD F0 EE               CALL   GetDirElementAddress
2920: F32F EB                     EX     DE,HL                ; DE = .buff(dptr)
2921: F330 2A DF EA               LD     HL,(paramDE)         ; HL=.fcb(0)
2922: F333 0E 20                  LD     C,NEXT_RECORD        ; length of move operation
2923: F335 D5                     PUSH   DE                   ; save .buff(dptr)
2924: F336 CD 8F F4               CALL   Move                 ; from .buff(dptr) to .fcb(0)
2925: F339         ; note that entire fcb is copied, including indicators
2926: F339 CD F0 F3               CALL   SetFileWriteFlag     ; sets file write flag
2927: F33C D1                     POP    DE
2928: F33D 21 0C 00               LD     HL,fcbExtIndex
2929: F340 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbExtIndex)
2930: F341 4E                     LD     C,(HL)               ; C = directory extent number
2931: F342 21 0F 00               LD     HL,fcbRCIndex        ; point at the record Count field
2932: F345 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbRCIndex)
2933: F346 46                     LD     B,(HL)               ; B holds directory record count
2934: F347 E1                     POP    HL
2935: F348 F1                     POP    AF
2936: F349 77                     LD     (HL),A               ; restore extent number
2937: F34A         ; HL = .user extent#, B = dir rec cnt, C = dir extent#
2938: F34A         ; if user ext < dir ext then user := 128 records
2939: F34A         ; if user ext = dir ext then user := dir records
2940: F34A         ; if user ext > dir ext then user := 0 records
2941: F34A 79                     LD     A,C
2942: F34B BE                     CP     M
2943: F34C 78                     LD     A,B                  ; ready dir fcbRCIndex
2944: F34D CA 57 F3               JP     Z,OpenRecordCount    ; if same, user gets dir fcbRCIndex
2945: F350 3E 00                  LD     A,0
2946: F352 DA 57 F3               JP     C,OpenRecordCount    ; user is larger
2947: F355 3E 80                  LD     A,RecordsPerExtent   ; directory is larger >>>RecordsPerExtent
2948: F357             OpenRecordCount:                      ;Acc has record count to fill
2949: F357 2A DF EA               LD     HL,(paramDE)
2950: F35A 11 0F 00               LD     DE,fcbRCIndex
2951: F35D 19                     ADD    HL,DE
2952: F35E 77                     LD     (HL),A
2953: F35F C9                     RET
2954: F360
2955: F360         ;---------------------
2956: F360         ;search for directory element of length C at info
2957: F360             Search4DirElement:
2958: F360 3E FF                  LD     A,0FFH
2959: F362 32 5D F5               LD     (directoryFlag),A    ; changed if actually found
2960: F365 21 60 F5               LD     HL,searchLength
2961: F368 71                     LD     (HL),C               ; searchLength = C
2962: F369 2A DF EA               LD     HL,(paramDE)
2963: F36C 22 61 F5               LD     (searchAddress),HL   ; searchAddress = paramDE
2964: F36F CD EE ED               CALL   SetEndDirectory      ; dirEntryIndex = enddir
2965: F372 CD D4 ED               CALL   Home                 ; to start at the beginning
2966: F375 C3 78 F3               JP     Search4NextDirElement
2967: F378         ;---------------------
2968: F378         ;search for the next directory element, assuming a previous
2969: F378         ;call on search which sets searchAddress and searchLength
2970: F378             Search4NextDirElement:
2971: F378 0E 00                  LD     C,FALSE
2972: F37A CD 16 EE               CALL   ReadDirectory        ; read next dir element
2973: F37D CD 04 EE               CALL   EndOfDirectory
2974: F380 CA DF F3               JP     Z,SearchDone         ; skip to end if so
2975: F383         ; not end of directory, scan for match
2976: F383 2A 61 F5               LD     HL,(searchAddress)
2977: F386 EB                     EX     DE,HL                ; DE=beginning of user fcb
2978: F387 1A                     LD     A,(DE)               ; first character
2979: F388 FE E5                  CP     emptyDir             ; keep scanning if Dir entry is empty
2980: F38A CA 95 F3               JP     Z,Search4NextDirElement1
2981: F38D         ; not emptyDir, may be end of logical directory
2982: F38D D5                     PUSH   DE                   ; save search address
2983: F38E CD 02 EF               CALL   StillInDirectory     ; past logical end?
2984: F391 D1                     POP    DE                   ; recall address
2985: F392 D2 DF F3               JP     NC,SearchDone        ; artificial stop
2986: F395             Search4NextDirElement1:
2987: F395 CD F0 EE               CALL   GetDirElementAddress ; HL = buffa+dptr
2988: F398 3A 60 F5               LD     A,(searchLength)
2989: F39B 4F                     LD     C,A                  ; length of search to c
2990: F39C 06 00                  LD     B,0                  ; bcounts up, c counts down
2991: F39E             Search4NextLoop:
2992: F39E 79                     LD     A,C
2993: F39F B7                     OR     A
2994: F3A0 CA CE F3               JP     Z,EndDirElementSearch
2995: F3A3 1A                     LD     A,(DE)
2996: F3A4 FE 3F                  CP     QMARK
2997: F3A6 CA C7 F3               JP     Z,Search4NextOK      ; ? matches all
2998: F3A9         ; scan next character if not fcbS1Index
2999: F3A9 78                     LD     A,B
3000: F3AA FE 0D                  CP     fcbS1Index
3001: F3AC CA C7 F3               JP     Z,Search4NextOK
3002: F3AF         ; not the fcbS1Index field, extent field?
3003: F3AF FE 0C                  CP     fcbExtIndex          ; may be extent field
3004: F3B1 1A                     LD     A,(DE)               ; fcb character
3005: F3B2 CA BE F3               JP     Z,Search4Ext         ; skip to search extent
3006: F3B5 96                     SUB    M
3007: F3B6 E6 7F                  AND    07FH                 ; mask-out flags/extent modulus
3008: F3B8 C2 78 F3               JP     NZ,Search4NextDirElement ; skip if not matched
3009: F3BB C3 C7 F3               JP     Search4NextOK        ;matched character
3010: F3BE
3011: F3BE         ; A has fcb character attempt an extent # match
3012: F3BE             Search4Ext:
3013: F3BE C5                     PUSH   BC                   ; save counters
3014: F3BF 4E                     LD     C,(HL)               ; directory character to c
3015: F3C0 CD FD F3               CALL   CompareExtents       ; compare user/dir char
3016: F3C3 C1                     POP    BC                   ; recall counters
3017: F3C4 C2 78 F3               JP     NZ,Search4NextDirElement ; skip if no match
3018: F3C7
3019: F3C7         ; current character matches
3020: F3C7             Search4NextOK:
3021: F3C7 13                     INC    DE
3022: F3C8 23                     INC    HL
3023: F3C9 04                     INC    B
3024: F3CA 0D                     DEC    C
3025: F3CB C3 9E F3               JP     Search4NextLoop
3026: F3CE
3027: F3CE         ; entire name matches, return dir position
3028: F3CE             EndDirElementSearch:
3029: F3CE 3A 6E F5               LD     A,(dirEntryIndex)
3030: F3D1 E6 03                  AND    dirEntryMask
3031: F3D3 32 E1 EA               LD     (exitParameterByte),A
3032: F3D6         ; exitParameterByte = low(dirEntryIndex) and 11b
3033: F3D6 21 5D F5               LD     HL,directoryFlag
3034: F3D9 7E                     LD     A,(HL)
3035: F3DA 17                     RLA
3036: F3DB D0                     RET    NC                   ; directoryFlag=0ffh?
3037: F3DC         ; yes, change it to 0 to mark as found
3038: F3DC AF                     XOR    A
3039: F3DD 77                     LD     (HL),A               ; directoryFlag=0
3040: F3DE C9                     RET
3041: F3DF
3042: F3DF         ; end of directory, or empty name
3043: F3DF             SearchDone:
3044: F3DF CD EE ED               CALL   SetEndDirectory      ; may be artifical end
3045: F3E2 3E FF                  LD     A,0FFH
3046: F3E4 32 E1 EA               LD     (exitParameterByte),A
3047: F3E7 C9                     RET
3048: F3E8         ;---------------------
3049: F3E8         ;get current extent field address to (HL)
3050: F3E8             GetExtentAddress:
3051: F3E8 2A DF EA               LD     HL,(paramDE)
3052: F3EB 11 0C 00               LD     DE,fcbExtIndex
3053: F3EE 19                     ADD    HL,DE                ;HL=.fcb(fcbExtIndex)
3054: F3EF C9                     RET
3055: F3F0         ;---------------------
3056: F3F0         ;Set file write flag
3057: F3F0             SetFileWriteFlag:
3058: F3F0 CD E7 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3059: F3F3 F6 80                  OR     writeFlagMask        ; set fwf (file write flag) to "1"
3060: F3F5 77                     LD     (HL),A               ; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
3061: F3F6 C9                     RET                         ; also returns non zero in accumulator
3062: F3F7         ;---------------------
3063: F3F7         ;set exitParameterByte to 1
3064: F3F7             SetLowReturnTo1:
3065: F3F7 3E 01                  LD     A,1
3066: F3F9 32 E1 EA               LD     (exitParameterByte),A
3067: F3FC C9                     RET
3068: F3FD         ;---------------------
3069: F3FD         ;compare extent# in A with that in C, return nonzero if they do not match
3070: F3FD             CompareExtents:
3071: F3FD C5                     PUSH   BC                   ; save C's original value
3072: F3FE F5                     PUSH   AF
3073: F3FF 3A 4E F5               LD     A,(dpbEXM)
3074: F402 2F                     CPL
3075: F403 47                     LD     B,A
3076: F404         ; B has negated form of extent mask
3077: F404 79                     LD     A,C
3078: F405 A0                     AND    B
3079: F406 4F                     LD     C,A                  ; low bits removed from C
3080: F407 F1                     POP    AF
3081: F408 A0                     AND    B                    ; low bits removed from A
3082: F409 91                     SUB    C
3083: F40A E6 1F                  AND    maxExtValue          ; set flags
3084: F40C C1                     POP    BC                   ; restore original values
3085: F40D C9                     RET
3086: F40E         ;---------------------
3087: F40E         ;copy the directory entry to the user buffer
3088: F40E             CopyDirEntryToUser:
3089: F40E 2A 42 F5               LD     HL,(caDirectoryDMA)
3090: F411 EB                     EX     DE,HL                ; source is directory buffer
3091: F412 2A 3A F5               LD     HL,(InitDAMAddress)  ; destination is user dma address
3092: F415 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3093: F417 C3 8F F4               JP     Move
3094: F41A         ;---------------------
3095: F41A         ;copy the whole file control block
3096: F41A             CopyFCB:
3097: F41A 0E 00                  LD     C,0
3098: F41C 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3099: F41E C3 21 F4               JP     CopyDir
3100: F421         ;---------------------
3101: F421         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3102: F421             CopyDir:
3103: F421 D5                     PUSH   DE                   ; save length for later
3104: F422 06 00                  LD     B,0                  ; double index to BC
3105: F424 2A DF EA               LD     HL,(paramDE)         ; HL = source for data
3106: F427 09                     ADD    HL,BC
3107: F428 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3108: F429 CD F0 EE               CALL   GetDirElementAddress ; HL=.buff(dptr), destination
3109: F42C C1                     POP    BC                   ; DE=source, HL=dest, C=length
3110: F42D CD 8F F4               CALL   Move                 ; data moved
3111: F430         ;enter from close to seek and copy current element
3112: F430             SeekAndCopy:                      ; seek$copy:
3113: F430 CD 47 EE               CALL   SeekDir              ; seek$dir ;to the directory element
3114: F433 C3 48 F2               JP     WriteDir             ; write the directory element
3115: F436         ;---------------------
3116: F436         ;Return the  disk map Index for cpmRecord in the ACC
3117: F436         ;  account for multiple extents in 1 physical Directory entry
3118: F436             GetDiskMapIndex:                      ; dm$position
3119: F436 21 4C F5               LD     HL,dpbBSH            ; get block shift value
3120: F439 4E                     LD     C,(HL)               ; shift count to C
3121: F43A 3A 69 F5               LD     A,(cpmRecord)        ; current virtual record to A
3122: F43D             GetDiskMapIndex1:
3123: F43D B7                     OR     A                    ; reset the carry flag
3124: F43E 1F                     RRA
3125: F43F 0D                     DEC    C
3126: F440 C2 3D F4               JP     NZ,GetDiskMapIndex1
3127: F443         ; A = shr(cpmRecord,dpbBSH) = cpmRecord/2**(sect/block)
3128: F443         ; A has the relative position in the block.
3129: F443 47                     LD     B,A                  ; save it for later addition
3130: F444 3E 08                  LD     A,8
3131: F446 96                     SUB    M                    ; 8-dpbBSH to accumulator
3132: F447 4F                     LD     C,A                  ; extent shift count in register c
3133: F448 3A 68 F5               LD     A,(extentValue)      ; extent value ani extmsk
3134: F44B             GetDiskMapIndex2:                      ; dmpos1:
3135: F44B         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3136: F44B         ; shift is 4,3,2,1,0
3137: F44B 0D                     DEC    C
3138: F44C CA 54 F4               JP     Z,GetDiskMapIndex3
3139: F44F B7                     OR     A                    ; clear the carry flag
3140: F450 17                     RLA
3141: F451 C3 4B F4               JP     GetDiskMapIndex2
3142: F454
3143: F454         ; The ACC has the Block Number for this record
3144: F454             GetDiskMapIndex3:
3145: F454         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3146: F454 80                     ADD    A,B                  ; add the previous shr(cpmRecord,dpbBSH) value
3147: F455         ; A is one of the following values, depending upon alloc
3148: F455         ; bks dpbBSH
3149: F455         ; 1k   3     v/8 + extentValue * 16
3150: F455         ; 2k   4     v/16+ extentValue * 8
3151: F455         ; 4k   5     v/32+ extentValue * 4
3152: F455         ; 8k   6     v/64+ extentValue * 2
3153: F455         ; 16k  7     v/128+extentValue * 1
3154: F455 C9                     RET                         ; with disk map position in A
3155: F456         ;---------------------
3156: F456         ; Enter with Disk Map Index in BG
3157: F456         ; Return disk map value  in HL
3158: F456             GetDiskMapValue:
3159: F456 2A DF EA               LD     HL,(paramDE)         ; base address of file control block
3160: F459 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3161: F45C 19                     ADD    HL,DE                ; HL =.diskmap
3162: F45D 09                     ADD    HL,BC                ; index by a single byte value
3163: F45E 3A 63 F5               LD     A,(single)           ; single byte/map entry?
3164: F461 B7                     OR     A
3165: F462 CA 69 F4               JP     Z,GetDiskMap16Bit    ; get disk map single byte
3166: F465 6E                     LD     L,(HL)
3167: F466 26 00                  LD     H,0
3168: F468 C9                     RET                         ; with HL=00bb
3169: F469             GetDiskMap16Bit:                      ; getdmd:
3170: F469 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3171: F46A         ; double precision value returned
3172: F46A 56                     LD     D,(HL)
3173: F46B 23                     INC    HL
3174: F46C 5E                     LD     E,(HL)
3175: F46D EB                     EX     DE,HL
3176: F46E C9                     RET
3177: F46F         ;---------------------
3178: F46F         ;---------------------
3179: F46F         ;*****************************************************************
3180: F46F         ;************************ Utilities ******************************
3181: F46F         ;*****************************************************************
3182: F46F             AddAtoHL:
3183: F46F 85                     ADD    A,L
3184: F470 6F                     LD     L,A
3185: F471 D0                     RET    NC
3186: F472 24                     INC    H
3187: F473 C9                     RET
3188: F474         ;----------
3189: F474             DEminusHL2HL:
3190: F474 7B                     LD     A,E
3191: F475 95                     SUB    L
3192: F476 6F                     LD     L,A
3193: F477 7A                     LD     A,D
3194: F478 9C                     SBC    A,H
3195: F479 67                     LD     H,A
3196: F47A C9                     RET
3197: F47B         ;-------------
3198: F47B             ShiftRightHLbyC:
3199: F47B 0C                     INC    C
3200: F47C             ShiftRightHLbyC0:
3201: F47C 0D                     DEC    C
3202: F47D C8                     RET    Z
3203: F47E 7C                     LD     A,H
3204: F47F B7                     OR     A
3205: F480 1F                     RRA
3206: F481 67                     LD     H,A
3207: F482 7D                     LD     A,L
3208: F483 1F                     RRA
3209: F484 6F                     LD     L,A
3210: F485 C3 7C F4               JP     ShiftRightHLbyC0
3211: F488         ;-------
3212: F488             ShiftLeftHLbyC:
3213: F488 0C                     INC    C
3214: F489             ShiftLeftHLbyC0:
3215: F489 0D                     DEC    C
3216: F48A C8                     RET    Z                    ; exit when done
3217: F48B 29                     ADD    HL,HL
3218: F48C C3 89 F4               JP     ShiftLeftHLbyC0
3219: F48F         ;*****************************************************************
3220: F48F         ;move data length of length C from source DE to HL
3221: F48F             Move:
3222: F48F 0C                     INC    C
3223: F490             Move0:
3224: F490 0D                     DEC    C
3225: F491 C8                     RET    Z
3226: F492 1A                     LD     A,(DE)
3227: F493 77                     LD     (HL),A
3228: F494 13                     INC    DE
3229: F495 23                     INC    HL
3230: F496 C3 90 F4               JP     Move0
3231: F499
3232: F499
3233: F499
3234: F499
3235: F499         ;read character with echo
3236: F499         ;? ConsoleInWithEcho:
3237: F499         ;? 	CALL	ConIn
3238: F499         ;? 	CALL	isPrintableASCII
3239: F499         ;? 	RET	C; return if graphic character
3240: F499         ;? ; character must be echoed before return
3241: F499         ;? 	PUSH	AF
3242: F499         ;? 	LD		C,A
3243: F499         ;? 	CALL	TabOut
3244: F499         ;? 	POP		AF
3245: F499         ;? 	RET										; with character in A
3246: F499         ;********** Console OUT Routines*******************
3247: F499
3248: F499
3249: F499
3250: F499
3251: F499
3252: F499         ;********************************************************
3253: F499         ;return version number
3254: F499             vGetVersion:                      ; func12 (12 - 0C)	 Get Verson
3255: F499 3E 20                  LD     A,VERSION
3256: F49B 32 E1 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION (high = 00)
3257: F49E C9                     RET
3258: F49F         ;************Error message World*************************
3259: F49F             errSelect:
3260: F49F 21 BE F4               LD     HL,evSelection
3261: F4A2 C3 B7 F4               JP     GoToError
3262: F4A5             errReadOnlyDisk:
3263: F4A5 21 C0 F4               LD     HL,evReadOnlyDisk
3264: F4A8 C3 B7 F4               JP     GoToError
3265: F4AB             errReadOnlyFile:
3266: F4AB 21 C2 F4               LD     HL,evReadOnlyFile
3267: F4AE C3 B7 F4               JP     GoToError
3268: F4B1             errPermanent:
3269: F4B1 21 BC F4               LD     HL,evPermanent
3270: F4B4 C3 B7 F4               JP     GoToError
3271: F4B7         ;************Error message handler **********************
3272: F4B7             GoToError:
3273: F4B7         ;HL = .errorhandler, call subroutine
3274: F4B7 5E                     LD     E,(HL)
3275: F4B8 23                     INC    HL
3276: F4B9 56                     LD     D,(HL)               ; address of routine in DE
3277: F4BA EB                     EX     DE,HL
3278: F4BB E9                     JP     (HL)                 ; vector to subroutine
3279: F4BC         ;************ Error Vectors *****************************
3280: F4BC CA F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3281: F4BE D6 F4       evSelection: DW     erSelection          ; selerr select error subroutine
3282: F4C0 DC F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3283: F4C2 E2 F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3284: F4C4         ;************Error Routines ******************************
3285: F4C4             erPermanentNoWait:
3286: F4C4 21 14 F5               LD     HL,emPermanent
3287: F4C7 C3 B7 F4               JP     GoToError
3288: F4CA             erPermanent:
3289: F4CA 21 14 F5               LD     HL,emPermanent
3290: F4CD CD EB F4               CALL   displayAndWait       ; to report the error
3291: F4D0 FE 03                  CP     CTRL_C
3292: F4D2 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3293: F4D5 C9                     RET                         ; and ignore the error
3294: F4D6         ;
3295: F4D6             erSelection:
3296: F4D6 21 1F F5               LD     HL,emSelection
3297: F4D9 C3 E5 F4               JP     waitB4boot           ; wait console before boot
3298: F4DC         ;
3299: F4DC             erReadOnlyDisk:
3300: F4DC 21 2B F5               LD     HL,emReadOnlyDisk
3301: F4DF C3 E5 F4               JP     waitB4boot           ; wait console before boot
3302: F4E2         ;
3303: F4E2             erReadOnlyFile:
3304: F4E2 21 26 F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3305: F4E5         ;
3306: F4E5         ; wait for response before boot
3307: F4E5             waitB4boot:
3308: F4E5 CD EB F4               CALL   displayAndWait
3309: F4E8 C3 00 00               JP     WarmBoot
3310: F4EB
3311: F4EB         ;report error to console, message address in HL
3312: F4EB             displayAndWait:
3313: F4EB E5                     PUSH   HL                   ; save message pointer
3314: F4EC CD DB E9               CALL   showCRLF             ; stack mssg address, new line
3315: F4EF 3A 34 F5               LD     A,(currentDisk)
3316: F4F2 C6 41                  ADD    A,ASCII_A
3317: F4F4 32 10 F5               LD     (emDisk),A           ; Problem disk name
3318: F4F7 01 04 F5               LD     BC,emDisk0
3319: F4FA CD 36 E9               CALL   Print                ; the error message
3320: F4FD C1                     POP    BC
3321: F4FE CD 36 E9               CALL   Print                ; error mssage tail
3322: F501 C3 1C E9               JP     ConIn                ; to get the input character
3323: F504         ;ret
3324: F504         ;**************Error Messages*******************************
3325: F504 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3326: F510 20 3A 20 24     emDisk:    DB     ' : $'
3327: F514 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3328: F51F 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3329: F526 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3330: F52B 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3331: F52F         ;*****************************************************************
3332: F52F
3333: F52F         ;********* file control block (fcb) constants ********************
3334: F52F             fcbLength  EQU    32                   ; fcblen file control block size
3335: F52F             fcbROfileIndex EQU    9                    ; high order of first type char
3336: F52F             fcbHiddenfileIndex EQU    10                   ; invisible file in dir command
3337: F52F             fcbExtIndex EQU    12                   ; extent number field index
3338: F52F             fcbS1Index EQU    13                   ; S1 index
3339: F52F             fcbS2Index EQU    14                   ; S2 data module number index
3340: F52F             fcbRCIndex EQU    15                   ; record count field index
3341: F52F             fcbDiskMapIndex EQU    16                   ; dskmap disk map field
3342: F52F
3343: F52F             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3344: F52F
3345: F52F             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3346: F52F             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3347: F52F             dirEntryMask EQU    dirEntriesPerRecord-1
3348: F52F             fcbShift   EQU    5                    ; log2(fcbLength)
3349: F52F         ;
3350: F52F
3351: F52F
3352: F52F
3353: F52F             maxExtValue EQU    31                   ; largest extent number
3354: F52F             moduleMask EQU    15                   ; limits module number value
3355: F52F             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3356: F52F             nameLength EQU    15                   ; namlen name length
3357: F52F
3358: F52F             emptyDir   EQU    0E5H                 ; empty empty directory entry
3359: F52F             NEXT_RECORD EQU    fcbLength            ; nxtrec
3360: F52F             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3361: F52F         ;
3362: F52F         ;	reserved file indicators
3363: F52F         ;	equ	11				; reserved
3364: F52F         ;*****************************************************************
3365: F52F         ;*****************************************************************
3366: F52F
3367: F52F         ;***common values shared between bdosi and bdos******************
3368: F52F 00          currentUserNumber: DB     0                    ; usrcode current user number
3369: F530             paramDE:   DS     2                    ; ParamsDE information address
3370: F532             exitParameterByte:
3371: F532             exitParameterWord: DS     2                    ; address value to return
3372: F534 FF          currentDisk: DB     -1                   ; curdsk current disk number
3373: F535         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3374: F535
3375: F535         ;********************* Local Variables ***************************
3376: F535         ;     ************************
3377: F535         ;     *** Initialized Data ***
3378: F535
3379: F535 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3380: F536 00 00       ReadOnlyVector: DW     0                    ; rodsk read only disk vector
3381: F538 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3382: F53A 80 00       InitDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3383: F53C
3384: F53C         ;     *** Current Disk attributes ****
3385: F53C         ; These are set upon disk select
3386: F53C         ; data must be adjacent, do not insert variables
3387: F53C         ; address of translate vector, not used
3388: F53C         ; ca - currentAddress
3389: F53C
3390: F53C 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3391: F53E 00 00       caTrack:   DW     0000H                ; curtrka current track address
3392: F540 00 00       caSector:  DW     0000H                ; current Sector
3393: F542             caListSizeStart:
3394: F542 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3395: F544 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3396: F546 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3397: F548 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3398: F54A             caListSizeEnd:
3399: F54A             caListSize EQU    caListSizeEnd - caListSizeStart
3400: F54A
3401: F54A         ;     ***** Disk Parameter Block *******
3402: F54A         ; data must be adjacent, do not insert variables
3403: F54A         ; dpb - Disk Parameter Block
3404: F54A             dpbStart:
3405: F54A 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3406: F54C 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3407: F54D 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3408: F54E 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3409: F54F 00 00       dpbDSM:    DW     0000H                ; maxall maximum allocation number
3410: F551 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3411: F553 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3412: F555 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3413: F557 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3414: F559             dpbEnd:
3415: F559             dpbSize    EQU    dpbEnd - dpbStart
3416: F559         ;
3417: F559
3418: F559         ;     ************************
3419: F559
3420: F559 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3421: F55B 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3422: F55C 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3423: F55D 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3424: F55E 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3425: F55F 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3426: F560 00          searchLength: DB     00H                  ; searchl search length
3427: F561 00 00       searchAddress: DW     0000H                ; searcha search address
3428: F563         ;tinfo:	ds	word							; temp for info in "make"
3429: F563 00          single:    DB     00H                  ; set true if single byte allocation map
3430: F564 00          fResel:    DB     00H                  ; resel reselection flag
3431: F565 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3432: F566 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3433: F567 00          fcbRecordCount: DB     00H                  ; record count from current fcb
3434: F568 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3435: F569 00 00       cpmRecord: DW     0000H                ; current virtual record - NEXT_RECORD
3436: F56B 00 00       currentBlock: DW     0000H                ; arecord current actual record
3437: F56D         ;
3438: F56D         ;	local variables for directory access
3439: F56D 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3440: F56E 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3441: F570 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3442: F572
3443: F572         ;********************** data areas ******************************
3444: F572
3445: F572
3446: F572         ;---------------------------------- Stack Area--------------------------------;
3447: F572             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3448: F5B2             bdosStack:
3449: F5B2         ;
3450: F5B2         ;---------------------------------- Stack Area--------------------------------;
3451: F5B2         ;	end of Basic I/O System
3452: F5B2         ;-----------------------------------------------------------------;
3453: F5B2
3454: F5B2
3455: F5B2         ;
3456: F5B2             Z_HighestLocation:
3457: F5B2             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3458: F5B2
3459: F5B2
           ************************   Xref   ************************
0000: $               F5B2   0411 0441
3182: AddAtoHL        F46F   2081 2390
2394: Allocate16Bit   F08B   2388
1087: AreWeAtEndOfBuffer EABF   1083
0081: ASCII_A         0041   3316
0082: ASCII_C         0043
0083: ASCII_K         004B
0090: ASCII_LO_A      0061
0091: ASCII_LO_K      006B
0092: ASCII_LO_P      0070
0033: ASCII_MASK      007F   0932
0084: ASCII_N         004E
0085: ASCII_Q         0051
0086: ASCII_R         0052
0087: ASCII_W         0057
0088: ASCII_Y         0059
0068: ASCII_ZERO      0030
0062: ASTERISK        002A
1053: BackSpace       EA9B   1057
1101: BackUp          EACA   1049 1054
1106: BackUp1         EAD2   1102
0290: bcBoot          F600
0293: bcConin         F609   0609 0735 0868 0886
0294: bcConout        F60C   0601 0812 1104 1108
0292: bcConst         F606   0606 0864
0298: bcHome          F618   1833
0295: bcList          F60F   0574 0818
0305: bcListst        F62D
0296: bcPunch         F612   0559
0303: bcRead          F627   2744
0297: bcReader        F615   0541
0306: bcSectran       F630
0299: bcSeldsk        F61B   1575
0302: bcSetdma        F624   1873
0301: bcSetsec        F621   2025
0300: bcSettrk        F61E   1838 2005
0291: bcWboot         F603   0462
0304: bcWrite         F62A   2737
0148: BDOSBase        E800   0149 0151 0322
0117: BDOSE           0005   0118
0149: BDOSEntry       E800
0138: BDOSLength      0E00   0141 0151 0152
3448: bdosStack       F5B2
0327: BdosStart       E800
0051: BELL            0007
0151: BIOSBase        F600
0139: BIOSLength      0A00   0141
0111: BIOSPAGE        0002
0152: BIOSStart       F600   0290 0291 0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 3457
2379: BlockOK         F06F   2373
0248: BlockSize       0800   0270
0029: BYTE            0001   1127
3397: caAllocVector   F548   1511 1663 1675 1798
3396: caCheckSum      F546   2044
3394: caDirectoryDMA  F542   1594 1867 2068 2079 3089
3390: caDirMaxValue   F53C   1583 1645 1682 2098
3395: caDiskParamBlock F544   1535 1598
2036: CalculateCheckSum EEBB   1926
3399: caListSize      0008   1595
3398: caListSizeEnd   F54A   3399
3393: caListSizeStart F542   3399
0089: CARET           005E   0774
0768: CaretCout       E944   1025 1076
3392: caSector        F540   1589 1845 1944 2014
3420: caSkewTable     F559   1593
3391: caTrack         F53E   1586 1841 1948 2008
0146: CCPEntry        E000   0148 0152
0137: CCPLength       0800   0141 0148 0152
0881: CheckCTL_S      E9C1   0872
2253: CheckRODirectory EFBB   2555 2606
2258: CheckROFile     EFBE   2337
2267: CheckWrite      EFC8   2335 2540 2565 2598
2866: ClearModuleNum  F2E1   2169 2190 2236
2616: CloseDirEntry   F1C5   1272 2177 2472
2637: CloseDirEntry1  F1EA   2683
2651: CloseDirEntry2  F1F8   2648
2657: CloseDirEntry3  F1FE   2653
2663: CloseDirEntry4  F205   2640
2679: CloseDirEntry5  F21A   2660
2704: CloseDirEntryEnd F234   2693
2711: CloseDirEntryError F23D   2659 2671 2676
0069: COLON           003A
1125: columnPosition  EADD   0793 0825 0915 0950 1036 1045
0064: COMMA           002C
3070: CompareExtents  F3FD   3015
2066: ComputeCheckSum EEE3   2043
2070: ComputeCheckSum0 EEE9   2074
0123: ComTail         0080   0124
0125: ComTailChars    0082
0124: ComTailCount    0081   0125
0859: ConBreak        E9A0   0698 0808
0892: ConBreak0       E9D0   0884
0894: ConBreak1       E9D3   0862
0728: ConIn           E91C   0494 0931 3322
0800: ConsoleOut      E969   0775 0787 0792 0902 0906 0908 1096
0823: ConsoleOut1     E983   0804
3102: CopyDir         F421   2155 2558 3099
3088: CopyDirEntryToUser F40E   2195 2205
3096: CopyFCB         F41A   2592
3435: cpmRecord       F569   2123 2138 2294 2304 2339 2423 2460 2850 3121
0225: cpmRecordSize   0080   0227 0230 0232 2067 3092 3345
0054: CR              000D   0741 0905 0936 1095
0037: CTRL_C          0003   0887 1081 3291
0038: CTRL_E          0005   0970
0039: CTRL_H          0008   0747 0839 0942 1107
0040: CTRL_K          000B
0041: CTRL_L          000C
0042: CTRL_P          0010   0871 0980
0043: CTRL_R          0012   1005
0044: CTRL_S          0013   0883
0045: CTRL_U          0015   0998
0046: CTRL_X          0018   0995
0047: CTRL_Z          001A
3436: currentBlock    F56B   1933 1940 2380 2827 2832 2841 2854
3372: currentDisk     F534   1474 1497 1542 1551 1573 1621 2275 2891 3315
3368: currentUserNumber F52F   0709 0715 1700 2900
0065: DASH            002D
0259: DataBlocks      02C7   0269
0258: DataSectors     0B1C   0259
2597: DeleteFile      F1A3   2212
2601: DeleteFile1     F1AB   2613
1040: DeleteTheLine   EA89   0996 0999
1043: DeleteTheLine1  EA8A   1050
3189: DEminusHL2HL    F474   1903 2040
3439: dirBlockIndex   F56D   1919 2080
0230: DirBuffSize     0080
0245: DirectoryBlockCount 0002   0270
0232: DirectoryEntryPerRecord 0004   0273
3423: directoryFlag   F55D   2861 2959 3033
3345: dirEntriesPerRecord 0004   3347
3440: dirEntryIndex   F56E   1859 1879 1899 1901 1911 1930 2096 3029
3347: dirEntryMask    0003   1912 3030
3346: dirEntryShift   0002   1931
0229: DirEntrySize    0020   0232 0270
2860: DirLocationToReturnLoc F2DA   1530 2213 2247
3441: dirRecord       F570   1934 2037 2046
0217: DiskCommandBlock 0046
0216: DiskControlByte 0045
0219: DiskControlTable 0040
2321: DiskEOF         F01D   2301 2308 2314
0411: diskf           000B
3425: diskMapIndex    F55F   2357 2387
2289: DiskRead        EFE2   1201
0221: DiskReadCode    0001
0226: diskSectorSize  0200   0227 0248 0256
0215: DiskStatusLocation 0043
2331: DiskWrite       F025   1208
2346: DiskWrite1      F042   2341
2404: DiskWrite2      F093   2392
2410: DiskWrite3      F095   2350
2431: DiskWrite4      F0B5   2426
2442: DiskWrite5      F0C2   2435
2461: DiskWrite6      F0E0   2457
2463: DiskWrite7      F0E2   2445 2449
0222: DiskWriteCode   0002
2326: DiskWriteSeq    F020   2228
3312: displayAndWait  F4EB   3290 3308
0128: DMABuffer       0080   1475 3382
0058: DOLLAR          0024   0756 1706
2273: DoNotWrite      EFCF   2268 2619
0271: dpb3hdAL0       00C0
0272: dpb3hdAL1       0000
0267: dpb3hdBLM       000F
0266: dpb3hdBSH       0004
0273: dpb3hdCKS       0020
0270: dpb3hdDRM       007F   0273
0269: dpb3hdDSM       02C6
0268: dpb3hdEXM       0000
0275: dpb3hdNOH       0002
0274: dpb3hdOFF       0001
0265: dpb3hdSPT       0090
3407: dpbBLM          F54D   2848
3406: dpbBSH          F54C   2840 3119
3412: dpbCKS          F555   2039
3411: dpbDABM         F553   1673
3410: dpbDRM          F551   1643 1897
3409: dpbDSM          F54F   1603 1656 2790
3414: dpbEnd          F559   3415
3408: dpbEXM          F54E   2128 2486 3073
3413: dpbOFF          F557   1834 2001
3415: dpbSize         000F   1601
3405: dpbSPT          F54A   1966 1980
3404: dpbStart        F54A   1600 3415
0443: DUMMY           E8A8   0438 0439
3326: emDisk          F510   3317
3325: emDisk0         F504   3318
3327: emPermanent     F514   3286 3289
3358: emptyDir        00E5   1696 2608 2979 3379
3379: emptyFCB        F535   2568
3330: emReadOnlyDisk  F52B   3300
3329: emReadOnlyFile  F526   3304
3328: emSelection     F51F   3296
0132: END_OF_FILE     001A
3028: EndDirElementSearch F3CE   2994
1878: EndOfDirectory  EE04   1351 1692 2151 2474 2509 2518 2552 2572 2603 2627 2910 2973
0035: EndOfMessage    0000
1092: EndRead         EAC3   0937 0940
3431: entryDisk       F565   0384 2892
0287: EOD             FFFF   1858
0073: EQUAL_SIGN      003D
3288: erPermanent     F4CA   3280
3285: erPermanentNoWait F4C4   2739 2746
3299: erReadOnlyDisk  F4DC   3282
3303: erReadOnlyFile  F4E2   3283
3268: errPermanent    F4B1
3262: errReadOnlyDisk F4A5   2270
3265: errReadOnlyFile F4AB   2264
3259: errSelect       F49F   1558
3295: erSelection     F4D6   3281
3280: evPermanent     F4BC   3269
3282: evReadOnlyDisk  F4C0   3263
3283: evReadOnlyFile  F4C2   3266
3281: evSelection     F4BE   3260
0056: EXCLAIM_POINT   0021
1129: exitParameterByte EAE1   0503 0610 0699 0710 1276 1286 1297 1304 1317 1498 1710 2306 2376 2411 2454 2528 2618 2712 2862 3031 3046 3066 3256
1130: exitParameterWord EAE1   0340 0391 0542 0630 1491 1512 1523 1536
3434: extentValue     F568   2130 3133
0024: FALSE           0000   0877 0988 1206 1609 2332 2971
0120: FCB1            005C   0121
0121: FCB2            006C
3421: fcbCopiedFlag   F55B   2471 2489 2706
3432: fcbDisk         F566   0342 0379 2894
3341: fcbDiskMapIndex 0010   1724 1727 2383 2547 2556 2630 2636 3160
3337: fcbExtIndex     000C   1255 1279 1338 1390 2148 2154 2477 2497 2542 2557 2599 2685 2697 2928 3003 3052
3336: fcbHiddenfileIndex 000A
3334: fcbLength       0020   1727 2580 2636 2685 3098 3345 3359
3340: fcbRCIndex      000F   1355 2112 2115 2697 2931 2950
3433: fcbRecordCount  F567   2126 2142 2295 2424
3335: fcbROfileIndex  0009   2259
3338: fcbS1Index      000D   2587 3000
3339: fcbS2Index      000E   1261 1282 1407 2497 2874
3348: fcbShift        0005   1913
0165: fCloseFile      0010
0156: fConsoleIn      0001
0157: fConsoleOut     0002
0168: fDeleteFile     0013
0160: fGetConsoleStatus 000B
0174: fGetCurrentDisk 0019
0173: fGetLoginVector 0018
0176: fGetSetUserNumber 0020
0161: fGetVersion     000C
2368: FirstBlock      F061   2360
0171: fMakeFile       0016
0164: fOpenFile       000F
0158: fPrintString    0009
0169: fReadSeq        0014
0159: fReadString     000A
0172: fRenameFile     0017
3430: fResel          F564   0343 0373 2882
0162: fResetSystem    000D
0166: fSearchFirst    0011
0167: fSearchNext     0012
0163: fSelectDisk     000E
0175: fSetDMA         001A
0441: functionCount   0028   0352
0398: functionTable   E856   0357 0411 0441
0170: fWriteSeq       0015
1771: GetAllocBit     ED9B   1813 2783 2801
1802: GetAllocBitl    EDBC   1805
2822: GetBlockNumber  F2AE   2312 2347
2772: GetClosestBlock F274   2369
2078: GetDirElementAddress EEF0   1354 1695 1722 2254 2607 2631 2919 2987 3108
3169: GetDiskMap16Bit F469   3165
3118: GetDiskMapIndex F436   2356 2823
3122: GetDiskMapIndex1 F43D   3126
3134: GetDiskMapIndex2 F44B   3141
3144: GetDiskMapIndex3 F454   3138
3158: GetDiskMapValue F456   2364 2826
3050: GetExtentAddress F3E8   2127 2915
2110: GetFcbAddress   EF0F   2121 2135
1337: GetFileSize     EBB0   1172
1350: GetFileSize1    EBC2   1378
1376: GetFileSize2    EBE4   1369
1379: GetFileSizeExit EBEA   1352
2872: GetModuleNum    F2E7   1311 2437 2622 2867 3058
1384: GetRandomRecordPosition EBEC   1326 1356
3272: GoToError       F4B7   3261 3264 3267 3270 3287
0074: GREATER_THAN    003E
0057: HASH_TAG        0023   0901
3343: highestRecordNumber 007F   2340 2444
1832: Home            EDD4   1680 2965
3382: InitDAMAddress  F53A   1476 1505 1863 3091
1655: InitDisk        ED0F   1568
1665: InitDisk0       ED1D   1671
1689: InitDisk1       ED3E   1698 1716
1711: InitDisk2       ED62   1702 1707
0112: IOBYTE          0003   0629 0649
2831: IsAllocated     F2BB   2313 2348
0997: IsItDeleteTheLineU EA56
0994: IsItDeleteTheLineX EA51   0981
0979: IsItPrintToggle EA3C   0971
0989: IsItPrintToggle1 EA4C   0987
0956: IsItRubout      EA1B   0943
0969: IsPhysicalEOL   EA2B   0958
0740: isPrintableASCII E927   0495 0770
1118: keyboardByte    EAD9   0729 0860 0893
0060: L_PAREN         0028
0077: LEFT_ARROW      005F
0093: LEFT_CURLY      007B
0141: LengthInBytes   2000   0142 0146 0256
0142: LengthInK       0009
0072: LESS_THAN       003C
0053: LF              000A   0743 0846 0907 0938
1008: LineLengthOrRepeat EA60   0954
0027: LO_NIBBLE_MASK  000F   0714 1403
3381: loggedDisks     F538   1472 1490 1550 1563 1567
2564: MakeNewFile     F16D   1295 2238 2516
2582: MakeNewFile1    F18F   2586
1123: manageColPosFlag EADB   0802 0952 1032 1038 1055
3353: maxExtValue     001F   2481 3083
0144: MemorySize      0040   0146
2751: Merge           F266   2664 2666
3354: moduleMask      000F   2502
3221: Move            F48F   1596 1602 2924 3093 3110
3223: Move0           F490   3230
0257: myOffset        0001   0258 0274
3356: nameLength      000F   2192 2507 2578 2580 2625 2908
2033: NewCheckSum     EEB9   2724
3359: NEXT_RECORD     0020   1250 1325 2115 2922 3360
2898: NoSelect        F314   2889
0845: NotBackSpace    E99A   0840
0889: NothingWaiting  E9CE   0880
0049: NULL            0000
0241: NumberOfHeads   0002   0252 0254 0265 0275
0238: NumberOfLogicalDisks 0004
0026: OFF             0000
0025: ON              FFFF
2907: OpenFile        F31D   1285 2171
2914: OpenFileCopyFCB F326   2524
2469: OpenNextExt     F0E5   2302 2452
2506: OpenNextExt1    F119   2491
2523: OpenNextExt2    F137   2493 2510
2525: OpenNextExt3    F13A   2520
2532: OpenNextExtError F142   2503 2514 2519
2496: OpenNextModule  F10E   2483
2948: OpenRecordCount F357   2944 2946
1128: paramDE         EADF   0332 0377 0672 0917 1219 1324 1341 1504 2111 2185 2202 2336 2382 2476 2545 2566 2569 2574 2634 2873 2883 2901 2921 2949 2962 3051 3105 3159
1127: paramE          EADE   0334 0385 0706 1541 2887
0059: PERCENT         0025
0066: PERIOD          002E
0115: Pg0CurentDisk   0004
0114: Pg0CurentUser   0004   0115
0063: PLUS_SIGN       002B
0754: Print           E936   0675 0763 3319 3321
1120: printEchoFlag   EADA   0816 0873 0984
0075: QMARK           003F   2187 2996
2193: QMarkSelect     EF7D   2188
0061: R_PAREN         0029
0108: RAM             0000   0110 0111 0112 0114 0117 0120 0123 0128 0130
3360: RANDOM_REC_FIELD 0021   1221 1327 1342
1198: RandomDiskRead  EAFA   1153
1205: RandomDiskWrite EB03   1165
1215: RandomSeek      EB0C   1200 1207
1269: RandomSeekClose EB50   1259
1314: RandomSeekError EB95   1248
1307: RandomSeekErrorBadSeek EB8E   1278 1294 1299
1301: RandomSeekExit  EB88   1268 1288
2743: ReadBuffer      F25E   1891 2318
1896: ReadDirectory   EE16   1691 2972
1910: ReadDirectory0  EE2B   1904
1914: ReadDirectory1  EE32   1917
1889: ReadDirRecord   EE0D   1924
1072: ReadEcho        EAAB   0967
1067: ReadEcho1       EAA8   1006
3422: readModeFlag    F55C   2291 2333 2512
0927: ReadNext        E9F3   0947 0962 0992 1089
0930: ReadNext0       E9F5   0977 1034 1058
3380: ReadOnlyVector  F536   1471 1522 1636 1641 2274
2283: ReadSeq         EFDD   2220
0914: ReadString      E9E5   0682 1047
2311: RecordOK        F007   2298
0250: RecordsPerBlock 0010
0234: RecordsPerExtent 0080   2300 2947 3343
0227: recordsPerSector 0004   0250 0265
2539: Rename          F148   2246
2551: Rename1         F159   2561
1016: Repeat          EA68   1028
1029: Repeat1         EA7A   1019
2880: Reselect        F2F0   1152 1164 1171 1528 2170 2176 2191 2203 2211 2219 2227 2237 2245
2807: ReturnBlockNumber F2A2   2785 2803
2817: ReturnBlockZero F2AA   2795
0372: ReturnToCaller  E82F   0346
0388: ReturnToCaller1 E84C   0375 0381 0608
1823: RotateAndReplace EDCD   1817 1826 2811
0078: RUBOUT          007F   0826 0957
1721: ScanDiskMap     ED6D   1714 2610
1729: ScanDiskMap0    ED77   1761
1745: ScanDiskMap1    ED8A   1737
1754: ScanDiskMap2    ED90   1743
2957: Search4DirElement F360   1339 2149 2194 2508 2543 2571 2600 2626 2909
3012: Search4Ext      F3BE   3005
2970: Search4NextDirElement F378   1377 2156 2204 2560 2612 2966 3008 3017
2986: Search4NextDirElement1 F395   2980
2991: Search4NextLoop F39E   3025
3020: Search4NextOK   F3C7   2997 3001 3009
3427: searchAddress   F561   2201 2963 2976
3043: SearchDone      F3DF   2974 2985
3426: searchLength    F560   2960 2988
0279: SectorMask      0003
0244: SectorsPerBlock 0004   0248 0250 0253 0259 0279
0254: SectorsPerCylinder 0024   0257 0258
0243: SectorsPerTrack 0012   0252 0254 0265
1937: Seek            EE58   1935 2317 2417
1958: Seek0           EE6B   1975
1977: Seek1           EE81   1963 1992
1994: Seek2           EE93   1986
3112: SeekAndCopy     F430
2717: SeekCopy        F242   2707
1929: SeekDir         EE47   1923 2718 3113
1549: Select          EC79   1478 1546
1540: SelectCurrent   EC6D   0386 1484 2897
1572: SelectDisk      EC9D   1556
1611: SelectDisk1     ECE1   1608
0071: SEMICOLON       003B
3424: seqReadFlag     F55E   1217 2136 2285 2328 2447
2839: SetActualRecordAdd F2C1   2316 2416
2843: SetActualRecordAdd1 F2C7   2846
1811: SetAllocBit     EDC2   1757
2147: SetAttributes   EF45   1529
2150: SetAttributes1  EF4A   2157
1619: SetCurrentDiskBit ECE5   1566 1640
1862: SetDataDMA      EDF5   1477 1506 1892 2728
1866: SetDirDMA       EDFB   1890 2725
2084: SetDirectoryEntry EEF9   1715 2590
1635: SetDiskReadOnly ECF8   1517 2057
1869: SetDMA          EDFE   1864
1857: SetEndDirectory EDEE   1687 1906 2964 3044
3057: SetFileWriteFlag F3F0   1319 2534 2594 2926
3064: SetLowReturnTo1 F3F7   2322 2342 2533
2061: SetNewCheckSum  EEE1   2050
1323: SetRandomRecord EB9D   1178
2120: SetRecordVars   EF1C   2293 2338 2526
0713: SetUserNumber   E916   0708
3212: ShiftLeftHLbyC  F488   1624
3214: ShiftLeftHLbyC0 F489   3218
3198: ShiftRightHLbyC F47B   1553 1659 1932 2277
3200: ShiftRightHLbyC0 F47C   3210
0904: showCRLF        E9DB   0974 3314
0900: showHashCRLF    E9D6   1011
3429: single          F563   1605 1735 2385 2638 3163
0067: SLASH           002F
0050: SOH             0001
0055: SPACE           0020   0749 0791 0830 1103
0286: STACK_SIZE      0020   3447
3447: stackBottom     F572
1124: startingColumn  EADC   0916 0976 1044
2095: StillInDirectory EF02   2055 2085 2983
0256: SystemSectors   0011   0257
0052: TAB             0009   0745 0786
0784: TabOut          E955   0500 0521 0761 0771
0790: TabOut0         E95B   0795
2775: TestLeft        F276   2806
2789: TestRight       F287   2778
0878: ToggleFlag1     E9BE   0876
0118: TopRAM          0007
0253: TotalNumberOfBlocks 02D0
0252: TotalNumberOfSectors 0B40   0253 0258
0130: TPA             0100
0242: TracksPerHead   0050   0252
0023: TRUE            FFFF   0874 0895 0985 1199 1606 1612 1690 2034 2290 2705 2881
0076: UNDER_SCORE     005F
2134: UpdateRecordVars EF33   2319 2451 2464
1116: usersStack      EAD7   0336 0389
2175: vCloseFile      EF64   0416
1170: vComputeFileSize EAEF   0435
0493: vConsoleIn      E8AC   0400
0520: vConsoleOut     E8BD   0401
2210: vDeleteFile     EF92   0419
0596: vDirectConIO    E8D0   0405
0605: vDirectConIO1   E8D9   0599
0285: VERSION         0020   3255
2183: vFindFirst      EF6A   0417
2200: vFindNext       EF83   0418
1510: vGetAllocAddr   EC4C   0427
0697: vGetConsoleStatus E900   0410
1496: vGetCurrentDisk EC3C   0425
1534: vGetDiskParamBlock EC66   0431
0628: vGetIOBYTE      E8E7   0406
1489: vGetLoginVector EC35   0424
1521: vGetRoVector    EC56   0429
0705: vGetSetUserNumber E907   0432
3254: vGetVersion     F499   0412
0573: vListOut        E8CC   0404
2235: vMakeFile       EFA9   0422
2168: vOpenFile       EF5B   0415
0671: vPrintString    E8F3   0408
0558: vPunchOut       E8C8   0403
0540: vReaderIn       E8C1   0402
1151: vReadRandom     EAE3   0433
2218: vReadSeq        EF9B   0420
0681: vReadString     E8FC   0409
2244: vRenameFile     EFB2   0423
1183: vResetDrive     EAF8   0437
1469: vResetSystem    EC19   0413
1483: vSelectDisk     EC32   0414
1503: vSetDMA         EC43   0426
1527: vSetFileAttributes EC5D   0430
0648: vSetIOBYTE      E8EE   0407
1177: vSetRandomRecord EAF5   0436
0461: vSystemReset    E8A9   0399
1516: vWriteProtectDisk EC53   0428
1163: vWriteRandom    EAE9   0434
1191: vWriteRandom0Fill EAF9   0440
2226: vWriteSeq       EFA2   0421
3307: waitB4boot      F4E5   3297 3301
0110: WarmBoot        0000   0888 1085 3292 3309
0030: WORD            0002   1128 1130
0190: WriteAllocated  0000   2349
2736: WriteBuffer     F256   2420 2727
0192: WriteCleanBuffer 0002   2405
2723: WriteDir        F248   2611 2719 3114
0191: WriteDirectory  0001
3355: writeFlagMask   0080   2623 3059
3456: Z_HighestLocation F5B2   3457
3457: Z_MemoryLeft    004D
0034: ZERO            0000
