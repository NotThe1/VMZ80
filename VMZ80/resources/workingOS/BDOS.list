0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800         ; 2019-03-02 Refactored constants and removed header files
0006: E800         ; 2019-02-29 Version 1.0
0007: E800         ; 2019-02-04 Fixed bdosStack problem
0008: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0009: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0010: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0011: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0012: E800         ; 2018-03-02 Refactored the CP/M Suite
0013: E800         ; 2018-02-12 fixed allocate 16 bit problem
0014: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0015: E800         ; 2014-03-14  :  Frank Martyn
0016: E800
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.Z80
0023: E800         ; standard equates for use by CP/M
0024: E800
0025: E800         ; 2019-03-02 Removed any unused constants
0026: E800         ; 2017-03-02 Refactored the CP/M Suite
0027: E800
0028: E800
0029: E800             TRUE       EQU    -1                   ; Not false
0030: E800             FALSE      EQU    0000H
0031: E800             LO_NIBBLE_MASK EQU    0FH                  ; Mask used to obtain the bytes low four bits
0032: E800
0033: E800             BYTE       EQU    1                    ; Number of bytes for "byte" type
0034: E800             WORD       EQU    2                    ; Number of bytes for "word" type
0035: E800
0036: E800
0037: E800             ASCII_MASK EQU    7FH                  ; ASCII mask 7 bits
0038: E800             EndOfMessage EQU    00H
0039: E800
0040: E800             CTRL_C     EQU    03H                  ; ETX
0041: E800             CTRL_E     EQU    05H                  ; Physical EOL
0042: E800             CTRL_H     EQU    08H                  ; Backspace
0043: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0044: E800             CTRL_P     EQU    10H                  ; Print toggle
0045: E800             CTRL_R     EQU    12H                  ; Repeat line
0046: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0047: E800             CTRL_U     EQU    15H                  ; Line delete
0048: E800             CTRL_X     EQU    18H                  ; Logical line delete
0049: E800             CTRL_Z     EQU    1AH                  ; End of file
0050: E800
0051: E800             TAB        EQU    09H                  ; Tab
0052: E800             LF         EQU    0AH                  ; Line Feed
0053: E800             CR         EQU    0DH                  ; Carriage Return
0054: E800             SPACE      EQU    20H                  ; Space
0055: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0056: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0057: E800             PERCENT    EQU    25H                  ; Percent Sign
0058: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0059: E800             PERIOD     EQU    2EH                  ; Period
0060: E800             ASCII_ZERO EQU    30H                  ; zero
0061: E800             COLON      EQU    3AH                  ; Colon
0062: E800
0063: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0064: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0065: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0066: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0067: E800             QMARK      EQU    3FH                  ; Question Mark
0068: E800             UNDER_SCORE EQU    5FH                  ; under score _
0069: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0070: E800             RUBOUT     EQU    7FH                  ; Delete Key
0071: E800
0072: E800
0073: E800             ASCII_A    EQU    'A'
0074: E800             ASCII_C    EQU    'C'
0075: E800             ASCII_M    EQU    'M'
0076: E800             ASCII_O    EQU    'O'
0077: E800             ASCII_Y    EQU    'Y'
0078: E800             CARET      EQU    '^'
0079: E800
0080: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0081: E800                        Include ./osHeader.Z80
0082: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0083: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0084: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0085: E800         ; osHeader.Z80
0086: E800
0087: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0088: E800         ; 2017-03-02 Refactored the CP/M Suite
0089: E800
0090: E800         ; Contains the Equates used by the CP/M system
0091: E800
0092: E800         ;------------------------Page Zero Constants ---------------------------------
0093: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0094: E800
0095: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0096: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0097: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0098: E800
0099: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0100: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0101: E800
0102: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0103: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0104: E800
0105: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0106: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0107: E800
0108: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0109: E800             ComTailCount EQU    ComTail              ; Count of the number of char in tail
0110: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0111: E800         ;-----------------------------------------------------------------------
0112: E800
0113: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0114: E800         ;-----------------------------------------------------------------------
0115: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0116: E800         ;-----------------------------------------------------------------------
0117: E800             END_OF_FILE EQU    1AH                  ; end of file
0118: E800         ;-----------------------------------------------------------------------
0119: E800
0120: E800         ;--------------- CP/M Constants -----------------------------------------
0121: E800
0122: E800             CCPLength  EQU    0800H                ; Constant
0123: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0124: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0125: E800
0126: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0127: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0128: E800
0129: E800             MemorySize EQU    64
0130: E800
0131: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0132: E800
0133: E800             BDOSBase   EQU    CCPEntry + CCPLength
0134: E800             BDOSEntry  EQU    BDOSBase
0135: E800
0136: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0137: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;? ;------------------- BDOS System Call Equates --------------------------
0141: E800         ;? fConsoleIn			EQU		01H			; rcharf - Console Input
0142: E800         ;? fConsoleOut			EQU		02H			; pcharf - Console Output
0143: E800         ;? fPrintString		EQU		09H			; pbuff	- Print String
0144: E800         ;? fReadString			EQU		0AH			; rbuff	- Read Console String
0145: E800         ;? fGetConsoleStatus	EQU		0BH			; breakf - Get Console Status
0146: E800         ;? fGetVersion			EQU		0CH			; liftf	- Return Version Number
0147: E800         ;? fResetSystem		EQU		0DH			; initf	- Reset Disk System
0148: E800         ;? fSelectDisk			EQU		0EH			; self	- Select Disk
0149: E800         ;? fOpenFile			EQU		0FH			; openf	- Open File
0150: E800         ;? fCloseFile			EQU		10H			; closef - Close File
0151: E800         ;? fSearchFirst		EQU		11H			; searf	- Search For First
0152: E800         ;? fSearchNext			EQU		12H			; searnf - Search for Next
0153: E800         ;? fDeleteFile			EQU		13H			; delf - Delete File
0154: E800         ;? fReadSeq			EQU		14H			; dreadf - Read Sequential
0155: E800         ;? fWriteSeq			EQU		15H			; dwritf - Write Sequential
0156: E800         ;? fMakeFile			EQU		16H			; makef	- Make File
0157: E800         ;? fRenameFile			EQU		17H			; renf	- Rename File
0158: E800         ;? fGetLoginVector		EQU		18H			; logf	- Return Login Vector
0159: E800         ;? fGetCurrentDisk		EQU		19H			; cself	- Return Current Disk
0160: E800         ;? fSetDMA				EQU		1AH			; dmaf	- Set DMA address
0161: E800         ;? fGetSetUserNumber	EQU		20H			; userf	- Set/Get User Code
0162: E800         ;? ;-----------------------------------------------------------------------
0163: E800         ;?
0164: E800         ;?
0165: E800         ;?
0166: E800         ;?
0167: E800         ;?
0168: E800         ;? ;*******************************************************************************
0169: E800         ;? ; These are the values handed over by the BDOS when it calls the Writer operation
0170: E800         ;? ; The allocated.unallocated indicates whether the BDOS is set to write to an
0171: E800         ;? ; unallocated allocation block (it only indicates this for the first 128 byte
0172: E800         ;? ; sector write) or to an allocation block that has already been allocated to a
0173: E800         ;? ; file. The BDOS also indicates if it is set to write to the file directory
0174: E800         ;? ;*******************************************************************************
0175: E800         ;? WriteAllocated		EQU	00H
0176: E800         ;? WriteDirectory		EQU	01H
0177: E800         ;? WriteCleanBuffer	EQU	02H
0178: E800
0179: E800
0180: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0181: E800                        Include ./diskHeader.Z80
0182: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0183: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0184: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0185: E800         ; diskHeader.asm
0186: E800
0187: E800         ; 2017-03-02 Refactored the CP/M Suite
0188: E800
0189: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0190: E800
0191: E800         ; Contains the Equates used by the CP/M system to handle disks
0192: E800
0193: E800
0194: E800         ;*******************************************************************************
0195: E800         ;
0196: E800         ;     Disk related values
0197: E800         ;
0198: E800         ;
0199: E800         ;*******************************************************************************
0200: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0201: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0202: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0203: E800         ; for boot
0204: E800             DiskControlTable EQU    0040H
0205: E800
0206: E800             DiskReadCode EQU    01H                  ; Code for Read
0207: E800             DiskWriteCode EQU    02H                  ; Code for Write
0208: E800
0209: E800
0210: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0211: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0212: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0213: E800
0214: E800             DirEntrySize EQU    20H                  ; (32)
0215: E800             DirBuffSize EQU    cpmRecordSize
0216: E800
0217: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0218: E800
0219: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0220: E800
0221: E800
0222: E800         ;-------------------------------------------------------------------------------------
0223: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0224: E800
0225: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0226: E800             NumberOfHeads EQU    02H                  ; number of heads
0227: E800             TracksPerHead EQU    50H                  ; 80
0228: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0229: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0230: E800             DirectoryBlockCount EQU    02H                  ;
0231: E800         ;-----------------------------------------------------------------------
0232: E800
0233: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0234: E800
0235: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0236: E800
0237: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0238: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0239: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0240: E800
0241: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0242: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0243: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0244: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0245: E800
0246: E800         ;-----------------------------------------------------------------------
0247: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0248: E800         ;-----------------------------------------------------------------------
0249: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0250: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0251: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0252: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0253: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0254: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0255: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0256: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0257: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0258: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0259: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0260: E800             dpb3hdNOH  EQU    NumberOfHeads
0261: E800
0262: E800         ;*******************************************************************************
0263: E800
0264: E800             SectorMask EQU    SectorsPerBlock - 1
0265: E800
0266: E800         ;***************************************************************************
0267: E800
0268: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0269: E800
0270: E800             VERSION    EQU    20H                  ; Version 2.0
0271: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0272: E800             EOD        EQU    -1                   ; End of Directory
0273: E800
0274: E800         ;*******************************************************************************
0275: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0276: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0277: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0278: E800         ; sector write) or to an allocation block that has already been allocated to a
0279: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0280: E800         ;*******************************************************************************
0281: E800             WriteAllocated EQU    00H
0282: E800             WriteDirectory EQU    01H
0283: E800             WriteCleanBuffer EQU    02H
0284: E800
0285: E800         ;************************ BIOS Function Constants **************************;
0286: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	            ;
0287: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                ;
0288: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function           ;
0289: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function            ;
0290: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function           ;
0291: E800             bcList     EQU    BIOSStart+3*5        ; List Output function              ;
0292: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function             ;
0293: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function             ;
0294: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                ;
0295: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function              ;
0296: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                ;
0297: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function               ;
0298: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                  ;
0299: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                ;
0300: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function               ;
0301: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function              ;
0302: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                  ;
0303: E800         ;************************ BIOS Function Constants **************************;
0304: E800         ;===========================================================================;
0305: E800         ;	BDOS                                                                    ;
0306: E800         ; Calling into   :                                                          ;
0307: E800         ;					Register  C - Contains BDOS Function Code               ;
0308: E800         ;					Register  A - Holds the Byte argument if any            ;
0309: E800         ;					Register DE - Holds the Word argument if any            ;
0310: E800         ; Returning from :                                                          ;
0311: E800         ;					Register  A - The Byte return value if any              ;
0312: E800         ;					Register HL - The Word return value if any              ;
0313: E800         ;                   ( Register A=L and B=H)                                 ;
0314: E800         ;===========================================================================;
0315: E800
0316: E800
0317: E800                        ORG    BDOSBase
0318: E800
0319: E800         ;===========================BDOS Entry======================================;
0320: E800         ;BDOSEntry:                                                                 ;
0321: E800         ;
0322: E800         ;
0323: E800             BdosStart:                      ;
0324: E800         ;	LD		A,C                                                             ;
0325: E800         ; 	LD		(FunctionValue),A			; Save the function number          ;
0326: E800         ;
0327: E800         ; Save Calling Arguments                                                    ;
0328: E800 ED 53 B4 EA               LD     (paramDE),DE         ; Save the Word Argument            ;
0329: E804 7B                     LD     A,E                  ;
0330: E805 32 B3 EA               LD     (paramE),A           ; Save the Byte argument            ;
0331: E808         ; Save users Stack pointer                                                  ;
0332: E808 ED 73 AD EA               LD     (usersStack),SP      ; Save the User's stack				;
0333: E80C 31 07 F5               LD     SP,bdosStack         ; We will use our own stack			;
0334: E80F         ;
0335: E80F         ; initialize variables                                                      ;
0336: E80F 21 00 00               LD     HL,0000H             ;
0337: E812 22 B6 EA               LD     (exitParameterWord),HL ; Assume all is well for return     ;
0338: E815 AF                     XOR    A                    ;
0339: E816 32 BB F4               LD     (fcbDisk),A          ; Initialize to 00                  ;
0340: E819 32 B9 F4               LD     (fResel),A           ; Clear re selection flag           ;
0341: E81C         ;
0342: E81C         ; Set up for return to caller when Function Completes                       ;
0343: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0344: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller           ;
0345: E820         ;
0346: E820         ; is it a valid function number ?	                                        ;
0347: E820         ;	LD		A,(FunctionValue)			; Get the Function Number           ;
0348: E820 79                     LD     A,C                  ;
0349: E821 FE 28                  CP     functionCount        ; make sure its a good number       ;
0350: E823 D0                     RET    NC                   ; exit if not a valid function      ;
0351: E824         ;
0352: E824         ; Calculate the index and get vector to go to	                            ;
0353: E824 4B                     LD     C,E                  ; Assume byte argument              ;
0354: E825 21 57 E8               LD     HL,functionTable     ; Get table base                    ;
0355: E828 5F                     LD     E,A                  ; Function number in E              ;
0356: E829 16 00                  LD     D,0                  ;
0357: E82B 19                     ADD    HL,DE                ; Have byte location                ;
0358: E82C 19                     ADD    HL,DE                ;  but we want a Word offset        ;
0359: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                 ;
0360: E82E 23                     INC    HL                   ;
0361: E82F 56                     LD     D,(HL)               ; Get MSB of vector                 ;
0362: E830 EB                     EX     DE,HL                ; Vector now in HL                  ;
0363: E831         ;
0364: E831         ; Vector to Function is in HL                                               ;
0365: E831 E9                     JP     (HL)                 ; Put it into the Program Counter   ;
0366: E832         ;===========================BDOS Entry======================================;
0367: E832         ;===========================BDOS Exit ======================================;
0368: E832         ;arrive here at end of processing to return to user                         ;
0369: E832             ReturnToCaller:                      ;
0370: E832 3A B9 F4               LD     A,(fResel)           ; get re-selection flag             ;
0371: E835 B7                     OR     A                    ; is it set?                        ;
0372: E836 28 15                  JR     Z,ReturnToCaller1    ;
0373: E838         ;re-selection  may have taken place                                        ;
0374: E838 2A B4 EA               LD     HL,(paramDE)         ;
0375: E83B 36 00                  LD     (HL),0               ;
0376: E83D 3A BB F4               LD     A,(fcbDisk)          ;
0377: E840 B7                     OR     A                    ; Disk = 0?                         ;
0378: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		;
0379: E843         ;
0380: E843 77                     LD     (HL),A               ;
0381: E844 3A BA F4               LD     A,(entryDisk)        ; get back original Disk            ;
0382: E847 32 B3 EA               LD     (paramE),A           ; and select it                     ;
0383: E84A CD 12 ED               CALL   SelectCurrent        ;
0384: E84D         ;
0385: E84D             ReturnToCaller1:                      ;
0386: E84D 2A AD EA               LD     HL,(usersStack)      ;
0387: E850 F9                     LD     SP,HL                ; restore callers stack             ;
0388: E851 2A B6 EA               LD     HL,(exitParameterWord) ;
0389: E854 7D                     LD     A,L                  ;
0390: E855 44                     LD     B,H                  ; BA = exitParameterWord            ;
0391: E856 C9                     RET                         ;
0392: E857         ;===========================BDOS Exit ======================================;
0393: E857
0394: E857         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++;
0395: E857             functionTable:                      ;
0396: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                ;
0397: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input               ;
0398: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output              ;
0399: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                ;
0400: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                ;
0401: E861 CD E8                  DW     vListOut             ;   5 - List Output                 ;
0402: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O          ;
0403: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                ;
0404: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                ;
0405: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                ;
0406: E86B FC E8                  DW     vReadString          ;   A - Read Console String         ;
0407: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status          ;
0408: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                    ;
0409: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number       ;
0410: E871 B8 EA                  DW     vResetSystem         ;   D - Reset Disk System           ;
0411: E873 D1 EA                  DW     vSelectDisk          ;   E - Select Disk                 ;
0412: E875 D4 EA                  DW     vOpenFile            ;   F - Open File                   ;
0413: E877 DD EA                  DW     vCloseFile           ;  10 - Close File                  ;
0414: E879 E3 EA                  DW     vFindFirst           ;  11 - Search For First            ;
0415: E87B FB EA                  DW     vFindNext            ;  12 - Search for Next             ;
0416: E87D 0A EB                  DW     vDeleteFile          ;  13 - Delete File                 ;
0417: E87F 31 EB                  DW     vReadSeq             ;  14 - Read Sequential             ;
0418: E881 74 EB                  DW     vWriteSeq            ;  15 - Write Sequential            ;
0419: E883 2C EC                  DW     vMakeFile            ;  16 - Make File                   ;
0420: E885 35 EC                  DW     vRenameFile          ;  17 - Rename File                 ;
0421: E887 5E EC                  DW     vGetLoginVector      ;  18 - Return Login Vector         ;
0422: E889 65 EC                  DW     vGetCurrentDisk      ;  19 - Return Current Disk         ;
0423: E88B 6C EC                  DW     vSetDMA              ;  1A - Set DMA address             ;
0424: E88D 75 EC                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)            ;
0425: E88F 7C EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk          ;
0426: E891 7F EC                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	        ;
0427: E893 86 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??      ;
0428: E895 A0 EC                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)  ;
0429: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code           ;
0430: E899 A7 EC                  DW     vReadRandom          ;  21 - Read Random                 ;
0431: E89B B3 EC                  DW     vWriteRandom         ;  22 - Write Random                ;
0432: E89D BF EC                  DW     vComputeFileSize     ;  23 - Compute File Size           ;
0433: E89F FB EC                  DW     vSetRandomRecord     ;  24 - Set Random Record           ;
0434: E8A1 0E ED                  DW     vResetDrive          ;  25 - Reset Drive                 ;
0435: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported);
0436: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)  ;
0437: E8A7 11 ED                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill         ;
0438: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions              ;
0439: E8A9         ;
0440: E8A9             DUMMY:                          ;
0441: E8A9 76                     HALT                        ;
0442: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++;
0443: E8AA
0444: E8AA         ;-------------------------- System Reset - 0 (0) ---------------------------;
0445: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the    ;
0446: E8AA         ; same as the warm boot function invoked when you transfer control to the   ;
0447: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads  ;
0448: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,  ;
0449: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)  ;
0450: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control ;
0451: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.              ;
0452: E8AA         ;																			;
0453: E8AA         ;			Function Code	 :	C = 00H                                     ;
0454: E8AA         ;			Entry Parameters:	None                                        ;
0455: E8AA         ;			Exit Parameters :	Does Not Return								;
0456: E8AA         ;																			;
0457: E8AA         ;-------------------------- System Reset - 0 (0) ---------------------------;
0458: E8AA             vSystemReset:
0459: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0460: E8AD
0461: E8AD         ;***************************************************************************;
0462: E8AD         ;								IOByte device I/O							;
0463: E8AD         ;***************************************************************************;
0464: E8AD
0465: E8AD
0466: E8AD         ;-------------------------- Read Console Byte - 1 (1) ----------------------;
0467: E8AD         ;  This function reads the next byte of data from the console keyboard and  ;
0468: E8AD         ; puts it into register A. If the character input is a graphic character, it;
0469: E8AD         ; will be echoed back to the console. The only control characters that are  ;
0470: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case   ;
0471: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to    ;
0472: E8AD         ; move the cursor to the next multiple of eight columns. All of the other   ;
0473: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.    ;
0474: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output  ;
0475: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if    ;
0476: E8AD         ; console output should also be sent to the list device. If CONTROL-S is    ;
0477: E8AD         ; found, further output will be suspended until you type another character. ;
0478: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is  ;
0479: E8AD         ; pressed and disable it the second time. If there is no incoming data      ;
0480: E8AD         ; character, this function will wait until there is one.                    ;
0481: E8AD         ;                                                                           ;
0482: E8AD         ; This is a blocking function                                               ;
0483: E8AD         ;																			;
0484: E8AD         ;																			;
0485: E8AD         ;			Function Code	:	C = 01H                                     ;
0486: E8AD         ;			Entry Parameters:	None                                        ;
0487: E8AD         ;			Exit Parameters :	A = Data byte from console					;
0488: E8AD         ;																			;
0489: E8AD         ;-------------------------- Read Console Byte - 1 (1) ----------------------;
0490: E8AD             vConsoleIn:
0491: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0492: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0493: E8B3 D8                     RET    C                    ; return nothing to echo
0494: E8B4
0495: E8B4 F5                     PUSH   AF                   ; Save printable character
0496: E8B5 4F                     LD     C,A
0497: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0498: E8B9 F1                     POP    AF                   ; retrieve exit value
0499: E8BA
0500: E8BA 32 B6 EA               LD     (exitParameterByte),A
0501: E8BD C9                     RET
0502: E8BE
0503: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0504: E8BE         ;  This function outputs the data byte in register E to the console. As      ;
0505: E8BE         ; with function 1, if the data byte is a TAB character, it will be expanded  ;
0506: E8BE         ; by the BDOS to the next column that is a multiple of eight. The BDOS also  ;
0507: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0508: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0509: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0510: E8BE         ; printer is  toggled on or off                                              ;
0511: E8BE         ;																			 ;
0512: E8BE         ;			Function Code	:	C = 02H                                      ;
0513: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0514: E8BE         ;			Exit Parameters :	None										 ;
0515: E8BE         ;																			 ;
0516: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0517: E8BE         ;BDOS put parameter in C before entering this routine
0518: E8BE             vConsoleOut:
0519: E8BE CD 58 E9               CALL   TabOut
0520: E8C1 C9                     RET
0521: E8C2
0522: E8C2         ;--------------------------- Read Reader Byte - 3 (3) ----------------------;
0523: E8C2         ;   function reads the next character from the logical "reader" device into ;
0524: E8C2         ; register A. In practice, the physical device that is accessed depends     ;
0525: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no     ;
0526: E8C2         ; reader at all; this function will return some arbitrary value such as lAH ;
0527: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').    ;
0528: E8C2         ; Control is not returned to the calling program until a character has been ;
0529: E8C2         ; read.                                                                     ;
0530: E8C2         ;                                                                           ;
0531: E8C2         ; This is a blocking function                                               ;
0532: E8C2         ;																			;
0533: E8C2         ;			Function Code	:	C = 03H                                     ;
0534: E8C2         ;			Entry Parameters:	None										;
0535: E8C2         ;			Exit Parameters :	A = Character Input							;
0536: E8C2         ;																			;
0537: E8C2         ;--------------------------- Read Reader Byte - 3 (3) ----------------------;
0538: E8C2             vReaderIn:
0539: E8C2 CD 15 F6               CALL   bcReader
0540: E8C5 32 B6 EA               LD     (exitParameterWord),A
0541: E8C8 C9                     RET
0542: E8C9
0543: E8C9         ;--------------------------- Write Punch Byte - 4 (4) ----------------------;
0544: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the  ;
0545: E8C9         ; specified character from register E to the logical punch device. Again,   ;
0546: E8C9         ; the actual physical device used, if any, is determined by the BIOS.       ;
0547: E8C9         ; There is no set standard for this device; in some systems the punch       ;
0548: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you  ;
0549: E8C9         ; output to it.                                                             ;
0550: E8C9         ;																			;
0551: E8C9         ;			Function Code	:	C = 04H                                     ;
0552: E8C9         ;			Entry Parameters:	E = Data byte to be output					;
0553: E8C9         ;			Exit Parameters :	None										;
0554: E8C9         ;																			;
0555: E8C9         ;--------------------------- Write Punch Byte - 4 (4) ----------------------;
0556: E8C9         ;BDOS put parameter in C before entering this routine
0557: E8C9             vPunchOut:
0558: E8C9 CD 12 F6               CALL   bcPunch
0559: E8CC C9                     RET
0560: E8CD
0561: E8CD         ;---------------------------- Write List Byte - 5 (5) ----------------------;
0562: E8CD         ;  This function outputs the specified byte in register E to the logical    ;
0563: E8CD         ; list device. As with the reader and the punch, the physical device used   ;
0564: E8CD         ; depends entirely on the BIOS.                                             ;
0565: E8CD         ;																			;
0566: E8CD         ;			Function Code	:	C = 05H                                     ;
0567: E8CD         ;			Entry Parameters:	E = Data byte to be output					;
0568: E8CD         ;			Exit Parameters :	None										;
0569: E8CD         ;																			;
0570: E8CD         ;---------------------------- Write List Byte - 5 (5) ----------------------;
0571: E8CD         ;BDOS put parameter in C before entering this routine
0572: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0573: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0574: E8D0 C9                     RET
0575: E8D1
0576: E8D1         ;--------------------------- Direct Console I/O - 6 (6) --------------------;
0577: E8D1         ;  This function serves double duty: it both inputs and outputs characters  ;
0578: E8D1         ; from the console. However, it bypasses the normal control characters and  ;
0579: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally          ;
0580: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as  ;
0581: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,   ;
0582: E8D1         ; then E contains a valid ASCII character that is output to the console.    ;
0583: E8D1         ;  This function works well provided you never have to send a value ofOFFH  ;
0584: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive     ;
0585: E8D1         ;  pure binary data, you cannot use this function, since these values are   ;
0586: E8D1         ;  likely to be part of the data stream.                                    ;
0587: E8D1         ;                                                                           ;
0588: E8D1         ;			Function Code	:	C = 06H                                     ;
0589: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		;
0590: E8D1         ;								E = Other than 0FFH for Output				;
0591: E8D1         ;			Exit Parameters :	A = Input byte or status					;
0592: E8D1         ;																			;
0593: E8D1         ;--------------------------- Direct Console I/O - 6 (6) --------------------;
0594: E8D1         ;BDOS put parameter in C before entering this routine
0595: E8D1             vDirectConIO:
0596: E8D1 79                     LD     A,C
0597: E8D2 3C                     INC    A
0598: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0599: E8D5         ; send byte to console
0600: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0601: E8D8 C9                     RET
0602: E8D9
0603: E8D9         ;read byte/status from console
0604: E8D9             vDirectConIO1:
0605: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0606: E8DC B7                     OR     A                    ; 00 means not data ready
0607: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0608: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0609: E8E3 32 B6 EA               LD     (exitParameterByte),A ; Save it
0610: E8E6 C9                     RET
0611: E8E7
0612: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) --------------------;
0613: E8E7         ; This function places the current value of the IOBYTE in register A.       ;
0614: E8E7         ;                                                                           ;
0615: E8E7         ; The IOBYTE structure:                                                     ;
0616: E8E7         ;								+-------+-------+-------+-------+           ;
0617: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |           ;
0618: E8E7         ;								+-------+-------+-------+-------+           ;
0619: E8E7         ;				Logical Device     List | Punch | Reader|Console            ;
0620: E8E7         ;                                                                           ;
0621: E8E7         ;                                                                           ;
0622: E8E7         ;			Function Code	:	C = 07H                                     ;
0623: E8E7         ;			Entry Parameters:	None					  		  			;
0624: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					;
0625: E8E7         ;																			;
0626: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) --------------------;
0627: E8E7             vGetIOBYTE:
0628: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0629: E8EA 32 B6 EA               LD     (exitParameterWord),A ; Return it to caller
0630: E8ED C9                     RET
0631: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) --------------------;
0632: E8EE         ; This function sets the IOBYTE         									;
0633: E8EE         ;                                                                           ;
0634: E8EE         ; The IOBYTE structure:                                                     ;
0635: E8EE         ;								+-------+-------+-------+-------+           ;
0636: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |           ;
0637: E8EE         ;								+-------+-------+-------+-------+           ;
0638: E8EE         ;				Logical Device     List | Punch | Reader|Console            ;
0639: E8EE         ;                                                                           ;
0640: E8EE         ;                                                                           ;
0641: E8EE         ;			Function Code	:	C = 08H                                     ;
0642: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			;
0643: E8EE         ;			Exit Parameters :	None                                        ;
0644: E8EE         ;																			;
0645: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) --------------------;
0646: E8EE         ;BDOS put parameter in C before entering this routine
0647: E8EE             vSetIOBYTE:
0648: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0649: E8F1 71                     LD     (HL),C               ; Place new vale in it
0650: E8F2 C9                     RET
0651: E8F3
0652: E8F3         ;---------------------- Display $ terminated String - 9 (9) ----------------;
0653: E8F3         ;  This function outputs a string of characters to the console device. The  ;
0654: E8F3         ; address of this string is in registers DE. You must make sure that the    ;
0655: E8F3         ; last character of the string is "$"; the BDOS uses this character as a    ;
0656: E8F3         ; marker for the end of the string. The "$" itself does not get output to   ;
0657: E8F3         ; the console.                                                              ;
0658: E8F3         ;                                                                           ;
0659: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously    ;
0660: E8F3         ; described, checks to see if there is an incoming character, and checks    ;
0661: E8F3         ; for  CONTROL-S (XOFF, which stops the output until another character is   ;
0662: E8F3         ; entered) or CONTROL-P (which turns on or off echoing of console characters;
0663: E8F3         ; to  the printer).                                                         ;
0664: E8F3         ;                                                                           ;
0665: E8F3         ;			Function Code	:	C = 09H                                     ;
0666: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string;
0667: E8F3         ;			Exit Parameters :	None							            ;
0668: E8F3         ;																			;
0669: E8F3         ;---------------------- Display $ terminated String - 9 (9) ----------------;
0670: E8F3             vPrintString:
0671: E8F3 2A B4 EA               LD     HL,(paramDE)         ; Get address of the string
0672: E8F6 4D                     LD     C,L
0673: E8F7 44                     LD     B,H                  ; Put it into BC for call
0674: E8F8 CD 3B E9               CALL   Print                ; out to console
0675: E8FB C9                     RET
0676: E8FC
0677: E8FC         ;-------------------------- Read Console String - A (10) -------------------;
0678: E8FC         ;  This function reads a string of characters from the console device       ;
0679: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line    ;
0680: E8FC         ; editing is possible: the operator can backspace, cancel the line and      ;
0681: E8FC         ; start over, and use all the normal control functions. What you will       ;
0682: E8FC         ; ultimately see in the buffer is the final version of the character string ;
0683: E8FC         ; entered, without any of the errors or control characters used to do the   ;
0684: E8FC         ; line editing;                                                             ;
0685: E8FC         ;                                                                           ;
0686: E8FC         ;  The buffer that you define has a special format. The first byte in the   ;
0687: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.    ;
0688: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters  ;
0689: E8FC         ; were actually placed in the buffer. The following bytes contain           ;
0690: E8FC         ; the characters of the string. Character input will cease either when a    ;
0691: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,      ;
0692: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not ;
0693: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If    ;
0694: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets      ;
0695: E8FC         ; the "characters input" byte to O. If you attempt to input more than the   ;
0696: E8FC         ; maximum number of characters, the "characters input" count will be the    ;
0697: E8FC         ; same as the maximum value allowed.                                        ;
0698: E8FC         ;                                                                           ;
0699: E8FC         ;			Function Code	:	C = 0AH                                     ;
0700: E8FC         ;			Entry Parameters:	DE = Address string buffer					;
0701: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it      ;
0702: E8FC         ;																			;
0703: E8FC         ;-------------------------- Read Console String - A (10) -------------------;
0704: E8FC             vReadString:
0705: E8FC CD E0 E9               CALL   ReadString
0706: E8FF C9                     RET
0707: E900
0708: E900         ;------------------------- Read Console Status - B (11) --------------------;
0709: E900         ; This function tells you whether a console input character is waiting to   ;
0710: E900         ; be processed. Unlike the Console Input functions, which will wait until   ;
0711: E900         ; there is input,this function simply checks and returns immediately.       ;
0712: E900         ;                                                                           ;
0713: E900         ;			Function Code	:	C = 0BH                                     ;
0714: E900         ;			Entry Parameters:	None										;
0715: E900         ;			Exit Parameters :	A = 00H if no incoming Data					;
0716: E900         ;								A = FFH	if incoming Data					;
0717: E900         ;																			;
0718: E900         ;------------------------- Read Console Status - B (11) --------------------;
0719: E900             vGetConsoleStatus:
0720: E900 CD 8C E9               CALL   ConBreak
0721: E903 32 B6 EA               LD     (exitParameterByte),A
0722: E906 C9                     RET
0723: E907
0724: E907         ;--------------------------- Get CP/M Version - C (12) ---------------------;
0725: E907         ;  This function tells you which version of CP/M you are currently running. ;
0726: E907         ; A two-byte value is returned:                                             ;
0727: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                      ;
0728: E907         ;	L = OOH for all releases before CP/M 2.0                                ;
0729: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                         ;
0730: E907         ;		and so on for any subsequent releases.                              ;
0731: E907         ;                                                                           ;
0732: E907         ; This information is of interest only if your program has some version     ;
0733: E907         ; specific logic built into it. For example, CP/M version 1.4 does not      ;
0734: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does. ;
0735: E907         ; Therefore, if your program uses Random I/O, put this check at the         ;
0736: E907         ; beginning to ensure that it is indeed running under the appropriate       ;
0737: E907         ; version of CP/M.                                                          ;
0738: E907         ;                                                                           ;
0739: E907         ;			Function Code	:	C = 0CH                                     ;
0740: E907         ;			Entry Parameters:	None										;
0741: E907         ;			Exit Parameters :	HL =Version Number Code						;
0742: E907         ;								A = FFH	if incoming Data					;
0743: E907         ;																			;
0744: E907         ;--------------------------- Get CP/M Version - C (12) ---------------------;
0745: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0746: E907 3E 20                  LD     A,VERSION
0747: E909 32 B6 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0748: E90C C9                     RET
0749: E90D
0750: E90D         ;--------------------------- Get/Set User Number - 20 (32) -----------------;
0751: E90D         ;  This subroutine either sets or gets the current user number. The current ;
0752: E90D         ; user number determines which file directory entries are matched during all;
0753: E90D         ; disk file operations. When you call this function, the contents of the    ;
0754: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function;
0755: E90D         ; will return the current user number in the A register. If you set E to a  ;
0756: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function  ;
0757: E90D         ; will set the current user number to this value.                           ;
0758: E90D         ;                                                                           ;
0759: E90D         ;			Function Code	:	C = 0CH                                     ;
0760: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				;
0761: E90D         ;								  = 0 to 15 to set User Number				;
0762: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH;
0763: E90D         ;								A = FFH	if incoming Data					;
0764: E90D         ;																			;
0765: E90D         ;                                                                           ;
0766: E90D         ;--------------------------- Get/Set User Number - 20 (32) -----------------;
0767: E90D             vGetSetUserNumber:
0768: E90D 3A B3 EA               LD     A,(paramE)
0769: E910 FE FF                  CP     0FFH
0770: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0771: E914 3A 88 F4               LD     A,(currentUserNumber)
0772: E917 32 B6 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0773: E91A C9                     RET
0774: E91B
0775: E91B             SetUserNumber:
0776: E91B E6 0F                  AND    LO_NIBBLE_MASK
0777: E91D 32 88 F4               LD     (currentUserNumber),A
0778: E920 C9                     RET
0779: E921
0780: E921         ;***************************************************************************;
0781: E921         ;								Character Support Routines					;
0782: E921         ;***************************************************************************;
0783: E921
0784: E921
0785: E921         ;-------------------- Return a Character from the console ------------------;
0786: E921         ;return byte from buffer or read from the console                           ;
0787: E921             ConIn:                          ;
0788: E921 21 AF EA               LD     HL,keyboardByte      ; is there a Byte waiting?          ;
0789: E924 7E                     LD     A,(HL)               ;
0790: E925 36 00                  LD     (HL),0               ;
0791: E927 B7                     OR     A                    ;
0792: E928 C0                     RET    NZ                   ;
0793: E929         ;
0794: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console          ;
0795: E92C         ;-------------------- Return a Character from the console ------------------;
0796: E92C
0797: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ---------;
0798: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE     ;
0799: E92C             IsPrintableASCII:                      ;
0800: E92C FE 0D                  CP     CR                   ;
0801: E92E C8                     RET    Z                    ; carriage return?                                                 ;
0802: E92F FE 0A                  CP     LF                   ;
0803: E931 C8                     RET    Z                    ; line feed?                                                       ;
0804: E932 FE 09                  CP     TAB                  ;
0805: E934 C8                     RET    Z                    ; TAB?                                                             ;
0806: E935 FE 08                  CP     CTRL_H               ;
0807: E937 C8                     RET    Z                    ; backspace?                                                       ;
0808: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable        ;
0809: E93A C9                     RET                         ;
0810: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ---------;
0811: E93B
0812: E93B         ;------------------ Print character from (BC) until  $ found ---------------;
0813: E93B             Print:                          ;
0814: E93B 0A                     LD     A,(BC)               ; Get the next character            ;
0815: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                   ;
0816: E93E C8                     RET    Z                    ;  exit if yes                      ;
0817: E93F 03                     INC    BC                   ; Update the pointer                ;
0818: E940 C5                     PUSH   BC                   ; Save it                           ;
0819: E941 4F                     LD     C,A                  ; Does Byte require                 ;
0820: E942 CD 58 E9               CALL   TabOut               ;  special attention - check        ;
0821: E945 C1                     POP    BC                   ; Retrieve the pointer				;
0822: E946 18 F3                  JR     Print                ; Loop back                         ;
0823: E948         ;------------------ Print character from (BC) until  $ found ---------------;
0824: E948
0825: E948         ;-- Send printable character to console. Precede with Caret if needed ------;
0826: E948         ; character is in Reg C                                                     ;
0827: E948             CaretOut:                       ;
0828: E948 79                     LD     A,C                  ;
0829: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0830: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed          ;
0831: E94E         ; send preceding up arrow                                                   ;
0832: E94E F5                     PUSH   AF                   ; Save the character                ;
0833: E94F 0E 5E                  LD     C,CARET              ;
0834: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console             ;
0835: E954 F1                     POP    AF                   ; Get the character                 ;
0836: E955 F6 40                  OR     40H                  ; Make the graphic a letter         ;
0837: E957 4F                     LD     C,A                  ; Set up to print                   ;
0838: E958         ; fall thru to TabbOut                                                      ;
0839: E958         ;-- Send printable character to console. Precede with Caret if needed ------;
0840: E958
0841: E958         ;------------- Send printable character to console. Expand if TAB ----------;
0842: E958         ; character is in Reg C                                                     ;
0843: E958             TabOut:                         ;
0844: E958 79                     LD     A,C                  ;
0845: E959 FE 09                  CP     TAB                  ; Is it a TAB                       ;
0846: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not  ;
0847: E95E         ;
0848: E95E         ; TAB encountered                                                          ;
0849: E95E             TabOut0:                        ;
0850: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs           ;
0851: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                   ;
0852: E963 3A B2 EA               LD     A,(columnPosition)   ; Get Column position               ;
0853: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?      ;
0854: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                   ;
0855: E96A C9                     RET                         ;
0856: E96B         ;------------- Send printable character to console. Expand if TAB ----------;
0857: E96B
0858: E96B         ;-------------------------- Send character to console ----------------------;
0859: E96B         ; C  = Character to be output                                               ;
0860: E96B             ConsoleOut:                      ;
0861: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                 ;
0862: E96B C5                     PUSH   BC                   ; Save character and Count          ;
0863: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke  ;
0864: E96F C1                     POP    BC                   ;
0865: E970 C5                     PUSH   BC                   ; Get/save character                ;
0866: E971         ; Send character to Console	                                                ;
0867: E971 CD 0C F6               CALL   bcConout             ; Send character to the console     ;
0868: E974 C1                     POP    BC                   ;
0869: E975 C5                     PUSH   BC                   ; Get/save character                ;
0870: E976         ; is the data to be output to print device?                                 ;
0871: E976 3A B0 EA               LD     A,(printEchoFlag)    ;
0872: E979 B7                     OR     A                    ;
0873: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so         ;
0874: E97D C1                     POP    BC                   ; Get the character                 ;
0875: E97E         ;
0876: E97E 79                     LD     A,C                  ; Put character to ACC              ;
0877: E97F 21 B2 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition    ;
0878: E982 34                     INC    M                    ; increment the ColumnPosition      ;
0879: E983         ;
0880: E983 FE 20                  CP     SPACE                ;
0881: E985 D0                     RET    NC                   ; Exit if ASCII printable           ;
0882: E986         ;
0883: E986 FE 0A                  CP     LF                   ;
0884: E988 C0                     RET    NZ                   ; Exit if not a Line Feed           ;
0885: E989         ;
0886: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0    ;
0887: E98B C9                     RET                         ;
0888: E98C         ;-------------------------- Send character to console ----------------------;
0889: E98C
0890: E98C         ;--------------------  Check for Status and Control S or C -----------------;
0891: E98C         ;  Returns:																	;
0892: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console;
0893: E98C         ;			ACC = 00   No data Pending										;
0894: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard          ;
0895: E98C         ;                                                                           ;
0896: E98C             ConBreak:                       ;
0897: E98C 3A AF EA               LD     A,(keyboardByte)     ;
0898: E98F B7                     OR     A                    ; If there is a char waiting        ;
0899: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC            ;
0900: E992         ;
0901: E992 CD 06 F6               CALL   bcConst              ; Get status                        ;
0902: E995 FE 00                  CP     00H                  ; If 00 => No data pending	        ;
0903: E997 C8                     RET    Z                    ; Return 00 No data pending         ;
0904: E998         ;
0905: E998 CD 09 F6               CALL   bcConin              ; Read the byte                     ;
0906: E99B         ;
0907: E99B FE 10                  CP     CTRL_P               ;
0908: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0909: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>            ;
0910: E99F 21 B0 EA               LD     HL,printEchoFlag     ;
0911: E9A2 3E FF                  LD     A,TRUE               ;
0912: E9A4 BE                     CP     (HL)                 ;
0913: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0914: E9A7 3E 00                  LD     A,FALSE              ;
0915: E9A9             ToggleFlag1:                      ;
0916: E9A9 77                     LD     (HL),A               ;
0917: E9AA 18 0C                  JR     NothingWaiting       ;
0918: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>            ;
0919: E9AC             CheckCTL_S:                      ;
0920: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save    ;
0921: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH             ;
0922: E9B0         ;
0923: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte               ;
0924: E9B3 FE 03                  CP     CTRL_C               ;
0925: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C            ;
0926: E9B8             NothingWaiting:                      ;
0927: E9B8 AF                     XOR    A                    ;
0928: E9B9 C9                     RET                         ; Set ACC = 0 and return            ;
0929: E9BA             ConBreak0:                      ;
0930: E9BA 32 AF EA               LD     (keyboardByte),A     ; save the byte                     ;
0931: E9BD             ConBreak1:                      ;
0932: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC       ;
0933: E9BF C9                     RET                         ;
0934: E9C0         ;--------------------  Check for Status and Control S or C -----------------;
0935: E9C0
0936: E9C0         ;------------------------  Console Output Utilities ------------------------;
0937: E9C0             showHashCRLF:                      ;
0938: E9C0 0E 23                  LD     C,HASH_TAG           ;
0939: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                 ;
0940: E9C5 CD D6 E9               CALL   showCRLF             ;
0941: E9C8             showHashCRLF1:                      ;
0942: E9C8 3E B2                  LD     A,columnPosition     ;
0943: E9CA 21 B1 EA               LD     HL,startingColumn    ;
0944: E9CD BF                     CP     A,M                  ;
0945: E9CE D0                     RET    NC                   ;
0946: E9CF 0E 20                  LD     C,SPACE              ;
0947: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0948: E9D4 18 F2                  JR     showHashCRLF1        ;
0949: E9D6         ;------------------------  Console Output Utilities ------------------------;
0950: E9D6
0951: E9D6         ;------------------------  Send Carriage Return and Line Feed --------------;
0952: E9D6             showCRLF:                       ;
0953: E9D6 0E 0D                  LD     C,CR                 ;
0954: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0955: E9DB 0E 0A                  LD     C,LF                 ;
0956: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET          ;
0957: E9E0         ;------------------------  Send Carriage Return and Line Feed --------------;
0958: E9E0
0959: E9E0         ;------------------------- Read a $ terminated String ----------------------;
0960: E9E0         ;read to paramDE address (max length, current length, buffer)              ;
0961: E9E0             ReadString:                      ;
0962: E9E0 3A B2 EA               LD     A,(columnPosition)   ;
0963: E9E3 32 B1 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R  ;
0964: E9E6 2A B4 EA               LD     HL,(paramDE)         ; Get the start of the String       ;
0965: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					;
0966: E9EA 23                     INC    HL                   ; Point at actual bytes read        ;
0967: E9EB 06 00                  LD     B,0                  ; Initialize Current Count          ;
0968: E9ED         ;
0969: E9ED         ; B = Current Count                                                     ;
0970: E9ED         ; C = Maximum characters                                                ;
0971: E9ED         ; HL= Insertion Pointer                                                 ;
0972: E9ED         ;
0973: E9ED         ; read next character, BC, HL active                                       ;
0974: E9ED             ReadNext:                       ;
0975: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count  ;
0976: E9EE E5                     PUSH   HL                   ; Save pointer                      ;
0977: E9EF             ReadNext0:                      ;
0978: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character            ;
0979: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                   ;
0980: E9F4 E1                     POP    HL                   ; Restore Pointer					;
0981: E9F5 C1                     POP    BC                   ; Current Index and Max Count		;
0982: E9F6         ;Is It Carriage Return                                                      ;
0983: E9F6 FE 0D                  CP     CR                   ;
0984: E9F8 28 3A                  JR     Z,EndRead            ; End the read if yes               ;
0985: E9FA FE 0A                  CP     LF                   ;
0986: E9FC         ;Is It Linefeed                                                             ;
0987: E9FC 28 36                  JR     Z,EndRead            ; End the read if yes               ;
0988: E9FE         ;Is It BackSpace                                                            ;
0989: E9FE FE 08                  CP     CTRL_H               ;
0990: EA00 28 3C                  JR     Z,BSspaceBS          ;
0991: EA02             IsItRubout:                      ;
0992: EA02 FE 7F                  CP     RUBOUT               ; Non destructive delete            ;
0993: EA04 28 41                  JR     Z,ItIsRubout         ;
0994: EA06             IsPhysicalEOL:                      ;
0995: EA06 FE 05                  CP     CTRL_E               ;
0996: EA08 28 46                  JR     Z,ItIsPhysicalEOL    ;
0997: EA0A             IsItPrintToggle:                      ;
0998: EA0A FE 10                  CP     CTRL_P               ;
0999: EA0C 28 49                  JR     Z,ItIsPrintToggle    ;
1000: EA0E             IsItDeleteTheLineX:                      ;
1001: EA0E FE 18                  CP     CTRL_X               ;
1002: EA10 28 6D                  JR     Z,DeleteTheLine      ; If CTRL_X go delete the line      ;
1003: EA12             IsItDeleteTheLineU:                      ;
1004: EA12 FE 15                  CP     CTRL_U               ;
1005: EA14 CA 9D EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line         ;
1006: EA17         ;Retype the line                                                            ;
1007: EA17 FE 12                  CP     CTRL_R               ;
1008: EA19 28 4B                  JR     Z,RepeatLine         ;
1009: EA1B         ;
1010: EA1B         ;....................... Echo input back to the Console  ...................;
1011: EA1B         ; Full Duplex								                                ;
1012: EA1B         ; A = Character to display	                                                ;
1013: EA1B         ; B = current char count                                                    ;
1014: EA1B         ; C = maximum buffer length                                                 ;
1015: EA1B         ; HL= buffer pointer                                                        ;
1016: EA1B         ;ReadEcho                                                                   ;
1017: EA1B 04                     INC    B                    ; Increment byte count		        ;
1018: EA1C 23                     INC    HL                   ; Advance the Pointer               ;
1019: EA1D 77                     LD     (HL),A               ; Put char in buffer                ;
1020: EA1E         ;
1021: EA1E             ReadEchoRubOut:                      ;
1022: EA1E C5                     PUSH   BC                   ; Save index and length             ;
1023: EA1F E5                     PUSH   HL                   ; Save the Pointer                  ;
1024: EA20 4F                     LD     C,A                  ; Get char                          ;
1025: EA21 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)   ;
1026: EA24 E1                     POP    HL                   ; Restore the Pointer               ;
1027: EA25 C1                     POP    BC                   ; Restore index and length          ;
1028: EA26 7E                     LD     A,(HL)               ; Recall char                       ;
1029: EA27         ; check for Warm Boot                                                       ;
1030: EA27 FE 03                  CP     CTRL_C               ;
1031: EA29 78                     LD     A,B                  ; Get Line position                 ;
1032: EA2A 20 05                  JR     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                ;
1033: EA2C FE 01                  CP     1                    ; Beginning of the Line?            ;
1034: EA2E CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot              ;
1035: EA31         ; Check to see if we are at the end of the buffer                           ;
1036: EA31             AreWeAtEndOfBuffer:                      ;
1037: EA31 B9                     CP     C                    ; Over Max ?					    ;
1038: EA32 38 B9                  JR     C,ReadNext           ;  no, Go for more				    ;
1039: EA34         ;
1040: EA34         ; At the end of read                                  					    ;
1041: EA34             EndRead:                        ;
1042: EA34         ; 	POP		HL                                                              ;
1043: EA34 2A B4 EA               LD     HL,(paramDE)         ;
1044: EA37 23                     INC    HL                   ;
1045: EA38         ;
1046: EA38 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer  ;
1047: EA39 0E 0D                  LD     C,CR                 ;
1048: EA3B C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			;
1049: EA3E         ;....................... Echo input back to the Console  ...................;
1050: EA3E         ;.......................... Backspace SPACE BackSpace ......................;
1051: EA3E             BSspaceBS:                      ;
1052: EA3E 05                     DEC    B                    ;
1053: EA3F 2B                     DEC    HL                   ;
1054: EA40 C5                     PUSH   BC                   ;
1055: EA41 E5                     PUSH   HL                   ;
1056: EA42 CD 90 EA               CALL   BackUp               ;
1057: EA45 18 A8                  JR     ReadNext0            ;
1058: EA47         ;.......................... Backspace SPACE BackSpace ......................;
1059: EA47         ;.......................... It is RubOut ...................................;
1060: EA47             ItIsRubout:                      ;
1061: EA47         ; RUBOUT if possible                                                        ;
1062: EA47 78                     LD     A,B                  ; Are we at the start of the line   ;
1063: EA48 B7                     OR     A                    ;
1064: EA49 28 A2                  JR     Z,ReadNext           ; then ignore and go for next char  ;
1065: EA4B         ;adjust pointers back one                                                   ;
1066: EA4B 7E                     LD     A,(HL)               ; ACC = current character           ;
1067: EA4C 05                     DEC    B                    ; Adjust the index			    	;
1068: EA4D 2B                     DEC    HL                   ; Adjust the pointer                ;
1069: EA4E 18 CE                  JR     ReadEchoRubOut       ; Echo back - Full Duplex           ;
1070: EA50         ;.......................... It is RubOut ...................................;
1071: EA50         ;.......................... It is PhysicalEOL ..............................;
1072: EA50             ItIsPhysicalEOL:                      ;
1073: EA50 C5                     PUSH   BC                   ; Save Current Index and Max Count  ;
1074: EA51 E5                     PUSH   HL                   ; Save pointer                      ;
1075: EA52 CD D6 E9               CALL   showCRLF             ; Make new line                     ;
1076: EA55 18 98                  JR     ReadNext0            ;   and go for next char   			;
1077: EA57         ;.......................... It is PhysicalEOL ..............................;
1078: EA57         ;.......................... It is PrintToggle ..............................;
1079: EA57             ItIsPrintToggle:                      ;
1080: EA57 E5                     PUSH   HL                   ; Save pointer                      ;
1081: EA58         ; Toggle the printEcho Flag                                                 ;
1082: EA58 21 B0 EA               LD     HL,printEchoFlag     ; Point at the flag                 ;
1083: EA5B 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                ;
1084: EA5D BE                     CP     (HL)                 ; Is the flag true?                 ;
1085: EA5E 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                       ;
1086: EA60 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE       ;
1087: EA62             IsItPrintToggle1:                      ;
1088: EA62 77                     LD     (HL),A               ; Set the Flags new Value	        ;
1089: EA63 E1                     POP    HL                   ; Restore pointer                   ;
1090: EA64 18 87                  JR     ReadNext             ;   and for another char            ;
1091: EA66         ;.......................... It is PrintToggle ..............................;
1092: EA66         ;.......................... RepeatLine .....................................;
1093: EA66             RepeatLine:                      ;
1094: EA66 C5                     PUSH   BC                   ; Save Current Index and Max Count  ;
1095: EA67 E5                     PUSH   HL                   ;  for exit                         ;
1096: EA68 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			;
1097: EA6B         ;
1098: EA6B 2A B4 EA               LD     HL,(paramDE)         ; Get start of Buffer               ;
1099: EA6E 23                     INC    HL                   ; Skip past character count         ;
1100: EA6F         ;
1101: EA6F             LL1:                            ;
1102: EA6F 23                     INC    HL                   ; Point at next char to display     ;
1103: EA70 C5                     PUSH   BC                   ; Save counter, in B                ;
1104: EA71 E5                     PUSH   HL                   ; Save buffer pointer               ;
1105: EA72 4E                     LD     C,M                  ; Get the next character            ;
1106: EA73 CD 48 E9               CALL   CaretOut             ; Display it                        ;
1107: EA76 E1                     POP    HL                   ; Restore                           ;
1108: EA77 C1                     POP    BC                   ;  the counter and pointer          ;
1109: EA78 10 F5                  DJNZ   LL1                  ; loop if still more to show        ;
1110: EA7A E1                     POP    HL                   ; Restore values                    ;
1111: EA7B C1                     POP    BC                   ;  from routine entry               ;
1112: EA7C C3 ED E9               JP     ReadNext             ; Done here !                       ;
1113: EA7F         ;.......................... RepeatLine .....................................;
1114: EA7F         ;.......................... Delete The Line ................................;
1115: EA7F             DeleteTheLine:                      ;
1116: EA7F E1                     POP    HL                   ; Adjust Stack                      ;
1117: EA80         ;                                            ;
1118: EA80             DeleteTheLine1:                      ;
1119: EA80 3A B1 EA               LD     A,(startingColumn)   ;
1120: EA83 21 B2 EA               LD     HL,columnPosition    ;
1121: EA86 BE                     CP     M                    ; Start of line ?                   ;
1122: EA87 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more   ;
1123: EA8A 35                     DEC    M                    ; Adjust the ColumnPosition         ;
1124: EA8B CD 90 EA               CALL   BackUp               ; Clear 1 column                    ;
1125: EA8E 18 F0                  JR     DeleteTheLine1       ; Loop for more                     ;
1126: EA90         ;.......................... Delete The Line ................................;
1127: EA90         ;------------------------ Back-up one screen position ----------------------;
1128: EA90             BackUp:                         ;
1129: EA90 CD 98 EA               CALL   BackUp1              ; Send Backspace                    ;
1130: EA93 0E 20                  LD     C,SPACE              ; Overwrite with SPACE              ;
1131: EA95 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				;
1132: EA98         ;does not affect column count                                               ;
1133: EA98             BackUp1:                        ;
1134: EA98 0E 08                  LD     C,CTRL_H             ;
1135: EA9A C3 0C F6               JP     bcConout             ; Send Backspace                    ;
1136: EA9D         ;------------------------ Back-up one screen position ----------------------;
1137: EA9D         ;.......................... Ignore The Line ................................;
1138: EA9D             IgnoreTheLine:                      ;
1139: EA9D CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			;
1140: EAA0 0E 20                  LD     C,SPACE              ; We want to add a few spaces       ;
1141: EAA2 CD 0C F6               CALL   bcConout             ;  to the console                   ;
1142: EAA5 0E 20                  LD     C,SPACE              ;
1143: EAA7 CD 0C F6               CALL   bcConout             ;
1144: EAAA C3 E0 E9               JP     ReadString           ; Start all over                    ;
1145: EAAD         ;.......................... Ignore The Line ................................;
1146: EAAD
1147: EAAD         ;------------------------- Read a $ terminated String ----------------------;
1148: EAAD
1149: EAAD         ;****************************************************************************
1150: EAAD         ;                           DATA AREA                                       *
1151: EAAD         ;****************************************************************************
1152: EAAD
1153: EAAD         ;------------------------------Non Disk Data Area --------------------------;
1154: EAAD             usersStack: DS     2                    ; entry stack pointer               ;
1155: EAAF         ;
1156: EAAF 00          keyboardByte: DB     00                   ; Saved keyboard character          ;
1157: EAB0         ;
1158: EAB0 00          printEchoFlag: DB     00                   ; Controlled by ^P                  ;
1159: EAB1         ;
1160: EAB1         ; FunctionValue:DB	00H					; Reg C on BDOS Entry               ;
1161: EAB1 00          startingColumn: DB     0                    ; Starting col pos after read       ;
1162: EAB2 00          columnPosition: DB     0                    ; Current Column position           ;
1163: EAB3         ;
1164: EAB3             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call       ;
1165: EAB4             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	    ;
1166: EAB6             exitParameterByte:                      ; Byte returned Value               ;
1167: EAB6             exitParameterWord: DS     WORD                 ; Word                          ;
1168: EAB8         ;
1169: EAB8         ;
1170: EAB8         ;------------------------------------ Data Area ----------------------------;
1171: EAB8
1172: EAB8
1173: EAB8
1174: EAB8         ;***************************************************************************;
1175: EAB8         ;								Disk I/O									;
1176: EAB8         ;***************************************************************************;
1177: EAB8
1178: EAB8         ;---------------------------- Reset Disk System - D (13) -------------------;
1179: EAB8         ;  This function requests CP/M to completely reset the disk file system.    ;
1180: EAB8         ; CP/M then resets its internal tables, selects logical disk A as the       ;
1181: EAB8         ; default disk, resets the DMAaddress back to 0080H (the address of the     ;
1182: EAB8         ; buffer used by the BDOS to read and write to the disk), and marks all     ;
1183: EAB8         ; logical disks as having Read/Write status. The BDOS will then have to log ;
1184: EAB8         ; in each logical disk as each disk is accessed. This involves reading the  ;
1185: EAB8         ; entire file directory for the disk and rebuilding the allocation vectors  ;
1186: EAB8         ; which keep track of which allocation blocks are free and which            ;
1187: EAB8         ; are used for file storage.                                                ;
1188: EAB8         ;	Submit file is created by external command Submit. The file is          ;
1189: EAB8         ; identified as $$$.SUB                                                     ;
1190: EAB8         ;                                                                           ;
1191: EAB8         ;			Function Code	:	C = 0DH                                     ;
1192: EAB8         ;			Entry Parameters:	None										;
1193: EAB8         ;			Exit Parameters :	A = 00H if no Submit File found				;
1194: EAB8         ;								  = 0FFH if Submit file found				;
1195: EAB8         ;																			;
1196: EAB8         ;---------------------------- Reset Disk System - D (13) -------------------;
1197: EAB8             vResetSystem:
1198: EAB8 21 00 00               LD     HL,0
1199: EABB 22 8B F4               LD     (readOnlyVector),HL  ; Clear the vectors for
1200: EABE 22 8D F4               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1201: EAC1 AF                     XOR    A                    ; Clear the current disk
1202: EAC2 32 89 F4               LD     (currentDisk),A
1203: EAC5         ; note that currentUserNumber remains unchanged
1204: EAC5 21 80 00               LD     HL,DMABuffer
1205: EAC8 22 8F F4               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1206: EACB CD 07 EF               CALL   SetDataDMA           ; to data DMA address
1207: EACE C3 1D ED               JP     Select
1208: EAD1         ;---------------------------- Select Disk - E (14) -------------------------;
1209: EAD1         ;  This function makes the logical disk named in register E the default disk;
1210: EAD1         ; All subsequent references to disk files that do not specify the disk will ;
1211: EAD1         ; use this default. When you reference a disk file that does have an        ;
1212: EAD1         ; explicit logical disk in its name you do not have to issue another        ;
1213: EAD1         ; Select Disk function; the BDOS will take care of that for you.            ;
1214: EAD1         ;                                                                           ;
1215: EAD1         ;  Notice the way in which the logical disk is specified in register E.     ;
1216: EAD1         ; It is not the same as the disk drive specification in the first byte of   ;
1217: EAD1         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1218: EAD1         ; "use the current default disk" (as specified in the last Select Disk      ;
1219: EAD1         ; call or by the operator on the console). With this function, a value      ;
1220: EAD1         ; of OOH in register A means that A is the selected drive, a value of       ;
1221: EAD1         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1222: EAD1         ; 16 drives in the system.                                                  ;
1223: EAD1         ;                                                                           ;
1224: EAD1         ;			Function Code	:	C = 0EH                                     ;
1225: EAD1         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1226: EAD1         ;			Exit Parameters :	None										;
1227: EAD1         ;																			;
1228: EAD1         ;---------------------------- Select Disk - E (14) -------------------------;
1229: EAD1
1230: EAD1             vSelectDisk:
1231: EAD1 C3 12 ED               JP     SelectCurrent
1232: EAD4
1233: EAD4         ;---------------------------- Open File - F (15) ---------------------------;
1234: EAD4         ;  This function opens a specified file for reading or writing. The FCB,    ;
1235: EAD4         ; whose address must be in register DE, tells CP/M the user number,         ;
1236: EAD4         ; the logical disk, the file name, and the file type. All other bytes of    ;
1237: EAD4         ; the FCB will normally be set to O.                                        ;
1238: EAD4         ;  The code returned by the BDOS in register A indicates whether the file   ;
1239: EAD4         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1240: EAD4         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1241: EAD4         ; then the file has been opened.                                            ;
1242: EAD4         ;			Function Code	:	C  = 0FH                                    ;
1243: EAD4         ;			Entry Parameters:	DE = Address of File Control Block			;
1244: EAD4         ;			Exit Parameters :	A  = Directory Code							;
1245: EAD4         ;																			;
1246: EAD4         ;---------------------------- Open File - F (15) ---------------------------;
1247: EAD4             vOpenFile:
1248: EAD4 CD BE EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1249: EAD7 CD 40 EF               CALL   ReselectDisk         ; do we need to reselect disk?
1250: EADA C3 F4 ED               JP     OpenFile
1251: EADD
1252: EADD         ;---------------------------- Close File - 10 (16) -------------------------;
1253: EADD         ;  This function terminates the processing of a file to which you have      ;
1254: EADD         ; written information. Under CP/M you do not need to close a file that you  ;
1255: EADD         ; have been reading. However, if you ever intend for your program to        ;
1256: EADD         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1257: EADD         ; should close all files regardless of their use.                           ;
1258: EADD         ;  The Close File function, like Open File, returns a directory code in     ;
1259: EADD         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1260: EADD         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1261: EADD         ; been closed.                                                              ;
1262: EADD         ;                                                                           ;
1263: EADD         ;  When the BDOS closes a file to which data has been written, it writes    ;
1264: EADD         ; the current contents of the FCB out to the disk directory, updating       ;
1265: EADD         ; an existing directory entry by matching the disk, name, type, and         ;
1266: EADD         ; extent number in the same manner that the Open File function does.        ;
1267: EADD         ; Note that the BDOS does not transfer the last record of the file to the   ;
1268: EADD         ; disk during the close operation. It merely updates the file directory.    ;
1269: EADD         ; You must arrange to flush any partly filled record to the disk. If the    ;
1270: EADD         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1271: EADD         ; arrange to fill the unused portion of the record with the standard lAH    ;
1272: EADD         ; end-of-file characters as CP/M expects.                                   ;
1273: EADD         ;                                                                           ;
1274: EADD         ;			Function Code	:	C  = 10H                                    ;
1275: EADD         ;			Entry Parameters:	DE = Address of File Control Block			;
1276: EADD         ;			Exit Parameters :	A  = Directory Code							;
1277: EADD         ;																			;
1278: EADD         ;---------------------------- Close File - 10 (16) -------------------------;
1279: EADD             vCloseFile:
1280: EADD CD 40 EF               CALL   ReselectDisk
1281: EAE0 C3 35 EE               JP     CloseDirEntry
1282: EAE3         ;---------------------Search for First Name Match - 11 (17) ----------------;
1283: EAE3         ;  This function scans down the file directory for the first entry that     ;
1284: EAE3         ; matches the file name, type, and extent in the FCB addressed by DE.       ;
1285: EAE3         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
1286: EAE3         ; more character positions. Where a "?" occurs, the BDOS will match any     ;
1287: EAE3         ; character in the corresponding position in the file directory. This is    ;
1288: EAE3         ; known as ambiguous file name matching.                                    ;
1289: EAE3         ;  The first byte of an FCB normally contains the logical disk number code. ;
1290: EAE3         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
1291: EAE3         ; and so on up to a possible maximum of 16 for disk P. However, if this     ;
1292: EAE3         ; byte contains a "?", the BDOS will search the default logical disk and    ;
1293: EAE3         ; will match the file name and type regardless of the user number. This     ;
1294: EAE3         ; function is normally used in conjunction with the Search Next function.   ;
1295: EAE3         ; Search First, in the process of matching a file, leaves certain           ;
1296: EAE3         ; variables in the BDOS set, ready for a subsequent Search Next.            ;
1297: EAE3         ;  Both Search First and Search Next return a directory code in the         ;
1298: EAE3         ; A register. With Search First, A = OFFH when no files match the FCB,      ;
1299: EAE3         ; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
1300: EAE3         ;                                                                           ;
1301: EAE3         ;  To locate the particular directory entry that either the Search First    ;
1302: EAE3         ; or Search Next function matched, multiply the directory code returned     ;
1303: EAE3         ; in A by the length of a directory entry (32 bytes). This is easily done   ;
1304: EAE3         ; by adding the A register to itself five times. Then add the DMA address   ;
1305: EAE3         ; to get the actual address where the matched directory entry is stored.    ;
1306: EAE3         ;  There are many occasions when you may need to write a program that will  ;
1307: EAE3         ; accept an ambiguous file name and operate on all of the file names that   ;
1308: EAE3         ; match it. (The DIR and ERA commands built into the CCP are examples that  ;
1309: EAE3         ; use ambiguous file names.) To do this, you must use several BDOS          ;
1310: EAE3         ; functions: the Set DMA Address function (code 26), this function          ;
1311: EAE3         ; (Search First), and Search Next (code 18). All of this is shown in the    ;
1312: EAE3         ; subroutine given in Figure 5-17.                                          ;
1313: EAE3         ;                                                                           ;
1314: EAE3         ;                                                                           ;
1315: EAE3         ;			Function Code	:	C  = 11H                                    ;
1316: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1317: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1318: EAE3         ;																			;
1319: EAE3         ;---------------------Search for First Name Match - 11 (17) ----------------;
1320: EAE3             vFindFirst:
1321: EAE3 0E 00                  LD     C,0                  ; Length assuming '?' true
1322: EAE5 2A B4 EA               LD     HL,(paramDE)         ; Get the FCB
1323: EAE8 7E                     LD     A,(HL)               ; DIsk/User No
1324: EAE9 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1325: EAEB 28 08                  JR     Z,QMarkFind          ;  if Yes, skip disk reselect
1326: EAED         ;  and reset of EXT
1327: EAED
1328: EAED CD BE EF               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1329: EAF0 CD 40 EF               CALL   ReselectDisk         ; Use FCB to set currentDisk
1330: EAF3 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1331: EAF5
1332: EAF5             QMarkFind:
1333: EAF5 CD F6 EF               CALL   SearchForDirectoryRecord ; Find the directory record
1334: EAF8 C3 15 F2               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1335: EAFB
1336: EAFB         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1337: EAFB         ;	This function searches down the file directory for the next file name,  ;
1338: EAFB         ; type, and extent that match the FCB specified in a previous Search First  ;
1339: EAFB         ; function call. Search First and Search Next are the only BDOS functions   ;
1340: EAFB         ; that must be used together. As you can see, the Search Next function      ;
1341: EAFB         ; does not require an FCB address as an input parameter-all the necessary   ;
1342: EAFB         ; information will have been left in the BDOS on the Search First call.     ;
1343: EAFB         ; Like Search First, Search Next returns a directory code in the A register,;
1344: EAFB         ; in this case, if A = OFFH, it means that there are no more files that     ;
1345: EAFB         ; match the file control block. If A is not OFFH, it will be a value of     ;
1346: EAFB         ; 0, 1, 2, or 3, indicating the relative directory entry number.            ;
1347: EAFB         ;                                                                           ;
1348: EAFB         ;  There are two ways of using the Search First/ Next calls. Consider a     ;
1349: EAFB         ; simple file copying program that takes as input an ambiguous file name.   ;
1350: EAFB         ; You could scan the file directory, matching all of the possible file      ;
1351: EAFB         ; names, possibly displaying them on the console, and storing the names of  ;
1352: EAFB         ; the files to be copied in a table inside your program. This would have    ;
1353: EAFB         ; the advantage of enabling you to present the file names to the operator   ;
1354: EAFB         ; before any copying occurred. You could even arrange for the operator to   ;
1355: EAFB         ; select which files to copy on a file-by-file basis. One disadvantage      ;
1356: EAFB         ; would be that you could not accurately predict how many files might be    ;
1357: EAFB         ; selected. On some hard disk systems you might have to accommodate several ;
1358: EAFB         ; thousand file names.                                                      ;
1359: EAFB         ;  The alternative way of handling the problem would be to match one file   ;
1360: EAFB         ; name, copy it, then match the next file name, copy it, and so on. If you  ;
1361: EAFB         ; gave the operator the choice of selecting which files to copy, this person;
1362: EAFB         ; would have to wait at the terminal as each file was being copied, but the ;
1363: EAFB         ; program would not need to have large table areas set aside to hold file   ;
1364: EAFB         ; names. This solution to the problem is slightly more complicated, as you  ;
1365: EAFB         ; can see from the logic in Figure 5-17.                                    ;
1366: EAFB         ;  The subroutine in Figure 5-17, Get Next File (GNF), contains all of the  ;
1367: EAFB         ; necessary logic to search down a directory for both alternatives described;
1368: EAFB         ; It does require that you indicate on entry whether it should search for   ;
1369: EAFB         ; the first or next file match, by setting A to zero or some nonzero value  ;
1370: EAFB         ; respectively.                                                             ;
1371: EAFB         ;  You can see from Figure 5-17 that whenever the subroutine is called to   ;
1372: EAFB         ; get the next file, you must execute a Search First function to re-find    ;
1373: EAFB         ; the  previous file. Only then can a Search Next be issued. As with all    ;
1374: EAFB         ; functions that return a directory code in A, if this value is not OFFH, it;
1375: EAFB         ; will be the relative directory entry number in the directory record       ;
1376: EAFB         ; currently in memory. This directory record will have been read into memory;
1377: EAFB         ; at whatever address was specified at the last Set DMA Address function    ;
1378: EAFB         ; call. Notwithstanding its odd name, the DMA Address is simply the address ;
1379: EAFB         ; into which any record input from disk will be placed. If the Set DMA      ;
1380: EAFB         ; Address function has not been used to change the value, then the CP/M     ;
1381: EAFB         ; default DMA address, location 0080H, will be used to hold the directory   ;
1382: EAFB         ; record.                                                                   ;
1383: EAFB         ;  The actual code for locating the address of the particular directory     ;
1384: EAFB         ;  entry matched by the Search First/ Next functions is shown in Figure 5-17;
1385: EAFB         ;  near the label GNFC. The method involves multiplying the directory code  ;
1386: EAFB         ;  by 32 and then adding this product to the current DMA address.	        ;
1387: EAFB         ;                                                                           ;
1388: EAFB         ;                                                                           ;
1389: EAFB         ;			Function Code	:	C  = 12H                                    ;
1390: EAFB         ;			Entry Parameters:	None , Assume previous Search First Call	;
1391: EAFB         ;			Exit Parameters :	A  = Directory Code							;
1392: EAFB         ;																			;
1393: EAFB         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1394: EAFB             vFindNext:
1395: EAFB 2A B6 F4               LD     HL,(searchAddress)   ; Get Current Dir Entry
1396: EAFE 22 B4 EA               LD     (paramDE),HL         ; Get the user's FCB
1397: EB01 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1398: EB04 CD 0B F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1399: EB07 C3 15 F2               JP     CopyDirEntryToUserDMA ; Copy directory entry to user
1400: EB0A
1401: EB0A         ;--------------------------------Delete File - 13 (19) ---------------------;
1402: EB0A         ; This function logically deletes from the file directory files that match  ;
1403: EB0A         ; the FCB addressed by DE. It does so by replacing the first byte of each   ;
1404: EB0A         ; relevant directory entry (remember, a single file can have several        ;
1405: EB0A         ; entries, one for each extent) by the value OE5H. This flags the directory ;
1406: EB0A         ; entry as being available for use.                                         ;
1407: EB0A         ;                                                                           ;
1408: EB0A         ;  Like the previous two functions, Search First and Search Next, this      ;
1409: EB0A         ; function can take an ambiguous file name and type as part of the          ;
1410: EB0A         ; File Control Block, but unlike those functions, the logical disk select   ;
1411: EB0A         ; code cannot be a"?". This function returns a directory code in A in the   ;
1412: EB0A         ; same way as the previous file operations.                                 ;
1413: EB0A         ;                                                                           ;
1414: EB0A         ;                                                                           ;
1415: EB0A         ;			Function Code	:	C  = 13H                                    ;
1416: EB0A         ;			Entry Parameters:	DE = Address of File Control Block			;
1417: EB0A         ;			Exit Parameters :	A  = Directory Code							;
1418: EB0A         ;																			;
1419: EB0A         ;--------------------------------Delete File - 13 (19) ---------------------;
1420: EB0A             vDeleteFile:
1421: EB0A CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1422: EB0D CD 29 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1423: EB10 0E 0C                  LD     C,fcbExtIndex        ; Load the extent number field
1424: EB12 CD F6 EF               CALL   SearchForDirectoryRecord ; Look for directory entry
1425: EB15
1426: EB15             DeleteFileLoop:
1427: EB15 CD 47 F1               CALL   AtEndOfDirectory     ; Have we worked thru all entries
1428: EB18 CA 22 F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1429: EB1B
1430: EB1B         ; set each non zero disk map entry to 0 in the allocation vector
1431: EB1B CD 30 F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1432: EB1E CD 50 F1               CALL   GetCurrentDirectoryRecord ; Point to Directory Entry
1433: EB21 36 E5                  LD     (HL),emptyDir        ; Mark as Empty
1434: EB23 0E 00                  LD     C,FALSE              ; Set flag for remove
1435: EB25 CD 74 F1               CALL   ScanDiskMap          ; Reclaim Bisk Blocks, set to 0
1436: EB28 CD 69 F0               CALL   WriteDir             ; Update the directory
1437: EB2B CD 0B F0               CALL   GetNextDirectoryRecord ; Look for more
1438: EB2E C3 15 EB               JP     DeleteFileLoop       ; Loop
1439: EB31
1440: EB31         ;----------------------------Read Sequential - 14 (20) ---------------------;
1441: EB31         ;  This function reads the next record (l28-byte sector) from the designated;
1442: EB31         ; file into memory at the address set by the last Set DMA function call     ;
1443: EB31         ; (code 26, lAH). The record read is specified by the FCB's sequential      ;
1444: EB31         ; record field. This field is incremented by 1 so that a subsequent call    ;
1445: EB31         ; to Read Sequential will get the next record from the file. If the end of  ;
1446: EB31         ; the current extent is reached, then the BDOS will automatically open the  ;
1447: EB31         ; next extent and reset the sequential record field to 0, ready for the     ;
1448: EB31         ; next Read function call.                                                  ;
1449: EB31         ;  The file specified in the FCB must have been readied for input by        ;
1450: EB31         ; issuing an Open File (code 15, OFH) or a Create File (code 22, 16H)       ;
1451: EB31         ; BDOS call. The value OOH is returned in A to indicate a successful Read   ;
1452: EB31         ; Sequential operation, while a nonzero value shows that the Read could     ;
1453: EB31         ; not be completed because there was no data in the next record, as at the  ;
1454: EB31         ; end of file.                                                              ;
1455: EB31         ;                                                                           ;
1456: EB31         ;  Although it is not immediately obvious, you can change the sequential    ;
1457: EB31         ; record number, FCB$SEQREC, and within a given extent, read a record at    ;
1458: EB31         ; random. If you want to access any given record within a file, you must    ;
1459: EB31         ; compute which extent that record would be in and set the extent field in  ;
1460: EB31         ; the file control block (FCB$EXTENT) before you open the file. Thus,       ;
1461: EB31         ; although the function name implies sequential access, in practice you can ;
1462: EB31         ; use it to perform a simple type of random access. If you need to do true  ;
1463: EB31         ; random access, look ahead to the Random Read function (code 33), which    ;
1464: EB31         ; takes care of opening the correct extent automatically.                   ;
1465: EB31         ;  When you read data from a CP/M text file, the normal convention is to    ;
1466: EB31         ; fill the last record of the file with lAH characters (CONTROL-Z).         ;
1467: EB31         ; Therefore, two possible conditions can indicate end-of-file: either       ;
1468: EB31         ; encountering a IAH, or receiving a return code from the BDOS function     ;
1469: EB31         ; (in the A register) of OFFH. However, if the file that you are reading    ;
1470: EB31         ; is not an ASCII text file, then a IAH character has no special meaning,   ;
1471: EB31         ; it is just a normal data byte in the body of the file.	                ;
1472: EB31         ;                                                                           ;
1473: EB31         ;			Function Code	:	C  = 14H                                    ;
1474: EB31         ;			Entry Parameters:	DE = Address of File Control Block			;
1475: EB31         ;			Exit Parameters :	A  = 0  => Success							;
1476: EB31         ;								  <> 0  => No data read, Probably EOF		;
1477: EB31         ;																			;
1478: EB31         ;----------------------------Read Sequential - 14 (20) ---------------------;
1479: EB31             vReadSeq:
1480: EB31 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1481: EB34         ;ReadSeq:
1482: EB34 3E 01                  LD     A,SEQ_ACCESS
1483: EB36 32 AE F4               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1484: EB39
1485: EB39             DiskRead:
1486: EB39 3E FF                  LD     A,TRUE
1487: EB3B 32 B2 F4               LD     (readModeFlag),A     ; Set Flag for read
1488: EB3E
1489: EB3E CD 6C EF               CALL   SetRecordVars        ; Set variables for current FCB
1490: EB41 3A BE F4               LD     A,(currentFileRecord)
1491: EB44 21 BC F4               LD     HL,fcbRecordCount
1492: EB47 BE                     CP     M                    ; is File Record < fcbRecordCount
1493: EB48 DA 5C EB               JP     C,RecordOK           ; skip if  yes
1494: EB4B         ; not enough records in the extent
1495: EB4B FE 80                  CP     RecordsPerExtent     ; Is record count the Max ?
1496: EB4D 20 22                  JR     NZ,NothingRead       ;  No, Exit with EOF
1497: EB4F
1498: EB4F CD A8 F2               CALL   OpenNextExt          ; Need to open the next extent
1499: EB52 AF                     XOR    A
1500: EB53 32 BE F4               LD     (currentFileRecord),A ; Reset the record count
1501: EB56 3A B6 EA               LD     A,(exitParameterByte) ; Was it a good Open
1502: EB59 B7                     OR     A
1503: EB5A 20 15                  JR     NZ,NothingRead       ;  exit if No
1504: EB5C
1505: EB5C             RecordOK:
1506: EB5C CD 58 F2               CALL   GetBlockNumber       ; Put it in absoluteCPMRecord
1507: EB5F CD 8A F2               CALL   WasBlockAllocated    ; Was it a good Allocation ?
1508: EB62 28 0D                  JR     Z,NothingRead        ; get out if not allocated
1509: EB64
1510: EB64 CD 90 F2               CALL   SetActualRecordAdd   ; Absolute CPM Record
1511: EB67 CD 7C F3               CALL   Seek                 ; Go to proper track,sector
1512: EB6A CD 15 EF               CALL   ReadBuffer           ; Read into DMA address
1513: EB6D CD 81 F0               CALL   UpdateRecordVariables ; update Record info
1514: EB70 C9                     RET
1515: EB71
1516: EB71             NothingRead:
1517: EB71 C3 2E F3               JP     SetExitParamTo1      ; No Data read
1518: EB74
1519: EB74         ;----------------------------Write Sequential - 15 (21) --------------------;
1520: EB74         ;	This function writes a record from the address specified in the last Set;
1521: EB74         ; DMA (code 26, lAH) function call to the file defined in the FCB. The      ;
1522: EB74         ; sequential record number in the FCB (RC) is updated by 1 so that          ;
1523: EB74         ; the next call to Write Sequential will write to the next record position  ;
1524: EB74         ; in the file. If necessary, a new extent will be opened to receive the new ;
1525: EB74         ; record.                                                                   ;
1526: EB74         ;  This function is directly analogous to the Read Sequential function,     ;
1527: EB74         ; writing instead of reading. The file specified in the FCB must first be   ;
1528: EB74         ; activated by an Open File (code 15,OFH) or create File call (code 22,16H).;
1529: EB74         ;  A directory code of OOH is returned in A to indicate that the Write was  ;
1530: EB74         ; successful, a nonzero value is returned if the Write could not be         ;
1531: EB74         ; completed because the disk was full.                                      ;
1532: EB74         ;                                                                           ;
1533: EB74         ;  As with the Read Sequential function (code 20, 14H), you can achieve     ;
1534: EB74         ; a simple form of random writing to the file by manipulating the           ;
1535: EB74         ; sequential record number (RC). However, you can only overwrite existing   ;
1536: EB74         ; records in the file, and if you want to move to another extent, you       ;
1537: EB74         ; must close the file and reopen it with the FCB$EXTENT field set to the    ;
1538: EB74         ; correct value.                                                            ;
1539: EB74         ;  The only logical error condition that can occur when writing to a file   ;
1540: EB74         ; is insufficient room on the disk to accommodate the next extent of the    ;
1541: EB74         ; file. Any hardware errors detected will be handled by the disk driver     ;
1542: EB74         ; built into the BIOS or BDOS.                                              ;
1543: EB74         ;                                                                           ;
1544: EB74         ;                                                                           ;
1545: EB74         ;			Function Code	:	C  = 15H                                    ;
1546: EB74         ;			Entry Parameters:	DE = Address of File Control Block			;
1547: EB74         ;			Exit Parameters :	A  = 0  => Success							;
1548: EB74         ;								  <> 0  => No data read, Probably EOF		;
1549: EB74         ;																			;
1550: EB74         ;----------------------------Write Sequential - 15 (21) --------------------;
1551: EB74
1552: EB74             vWriteSeq:
1553: EB74 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1554: EB77
1555: EB77             DiskWriteSeq:
1556: EB77 3E 01                  LD     A,SEQ_ACCESS
1557: EB79 32 AE F4               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1558: EB7C
1559: EB7C             DiskWrite:
1560: EB7C 3E 00                  LD     A,FALSE
1561: EB7E 32 B2 F4               LD     (readModeFlag),A     ; Set Flag for Write
1562: EB81
1563: EB81 CD 29 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1564: EB84 2A B4 EA               LD     HL,(paramDE)         ; Put FCB in HL
1565: EB87 CD 33 F2               CALL   CheckROFile          ; Terminate with error if File R/O
1566: EB8A CD 6C EF               CALL   SetRecordVars        ; Set variables for current FCB
1567: EB8D 3A BE F4               LD     A,(currentFileRecord) ; Get current record number
1568: EB90 FE 80                  CP     highestRecordNumber+1 ; Is it still in the same extent?
1569: EB92 D2 2E F3               JP     NC,SetExitParamTo1   ; Exit with NO WRITE set
1570: EB95
1571: EB95 CD 58 F2               CALL   GetBlockNumber       ; Compute disk block number
1572: EB98 CD 8A F2               CALL   WasBlockAllocated    ; Is it really allocated ?
1573: EB9B 0E 00                  LD     C,WriteAllocated     ; Assume a normal write operation
1574: EB9D C2 E4 EB               JP     NZ,HaveWriteBlock    ;  Skip if block already allocated
1575: EBA0
1576: EBA0 CD 65 F2               CALL   GetDiskMapIndex      ; Disk Map Index in ACC
1577: EBA3 32 B4 F4               LD     (diskMapIndex),A     ; Save it
1578: EBA6 01 00 00               LD     BC,0000h             ; Anticipate using 0000
1579: EBA9 B7                     OR     A                    ; Is it block 0?
1580: EBAA 28 07                  JR     Z,FindAvailableBlock ;  skip if yes
1581: EBAC
1582: EBAC 4F                     LD     C,A                  ;  else a previous block exists
1583: EBAD 0B                     DEC    BC                   ; Adjust the index
1584: EBAE CD 72 F2               CALL   GetDiskMapValue      ; Put previous block # into HL
1585: EBB1 44                     LD     B,H                  ; Move previous block
1586: EBB2 4D                     LD     C,L                  ;  number into BC
1587: EBB3
1588: EBB3             FindAvailableBlock:
1589: EBB3 CD 9F F1               CALL   GetClosestBlock      ; Block number in HL
1590: EBB6 7D                     LD     A,L                  ; If no available blocks HL
1591: EBB7 B4                     OR     H                    ;  HL set to 0000H
1592: EBB8 20 06                  JR     NZ,FoundAvailableBlock ; Skip if found
1593: EBBA
1594: EBBA 3E 02                  LD     A,2                  ; Load return value
1595: EBBC 32 B6 EA               LD     (exitParameterByte),A ; Save for caller
1596: EBBF C9                     RET                         ; Exit with exitParameterByte=2
1597: EBC0
1598: EBC0             FoundAvailableBlock:
1599: EBC0 22 C0 F4               LD     (absoluteCPMRecord),HL ; Save the block number
1600: EBC3 EB                     EX     DE,HL                ; block number to DE (E)
1601: EBC4 2A B4 EA               LD     HL,(paramDE)         ; HL at FCB
1602: EBC7 01 10 00               LD     BC,fcbDiskMapIndex   ; Index to start of FCB Map
1603: EBCA 09                     ADD    HL,BC                ; HL=.start of FCB Map
1604: EBCB
1605: EBCB
1606: EBCB 3A B4 F4               LD     A,(diskMapIndex)     ; Get target block index
1607: EBCE 4F                     LD     C,A                  ; Map index to C
1608: EBCF 06 00                  LD     B,0                  ; Set MSB to 00
1609: EBD1 09                     ADD    HL,BC                ; Calculate 8 bit block's location
1610: EBD2 3A B8 F4               LD     A,(byteAllocationFlag) ; Get allocation size flag
1611: EBD5 B7                     OR     A                    ; Test it
1612: EBD6 28 03                  JR     Z,Allocate16Bit      ; Skip if allocating word
1613: EBD8
1614: EBD8 73                     LD     (HL),E               ; Update the Map
1615: EBD9 18 04                  JR     MarkNewBlock         ; Skip 16 bit calculations
1616: EBDB
1617: EBDB             Allocate16Bit:
1618: EBDB 09                     ADD    HL,BC                ; Adjust for 16 bit value
1619: EBDC 72                     LD     (HL),D               ; Save MSB
1620: EBDD 23                     INC    HL
1621: EBDE 73                     LD     (HL),E               ; SAVE LSB
1622: EBDF             MarkNewBlock:
1623: EBDF CD D8 EF               CALL   ResetFileWriteFlag
1624: EBE2 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1625: EBE4
1626: EBE4             HaveWriteBlock:
1627: EBE4 3A B6 EA               LD     A,(exitParameterByte)
1628: EBE7 B7                     OR     A
1629: EBE8 C0                     RET    NZ                   ; Exit if non zero returned value ??
1630: EBE9
1631: EBE9 C5                     PUSH   BC                   ; Write flag (in C)
1632: EBEA CD 90 F2               CALL   SetActualRecordAdd   ; Set absoluteCPMRecord
1633: EBED CD 7C F3               CALL   Seek                 ; Seek to o proper file position
1634: EBF0 C1                     POP    BC                   ; Write flag (in C)
1635: EBF1 C5                     PUSH   BC                   ; Write flag (in C)
1636: EBF2 CD 79 F0               CALL   WriteBuffer          ; Write buffer and check result
1637: EBF5 C1                     POP    BC                   ; Write flag (in C)
1638: EBF6
1639: EBF6 3A BE F4               LD     A,(currentFileRecord) ; Get the current record
1640: EBF9 21 BC F4               LD     HL,fcbRecordCount    ; Get the starting FCB record count
1641: EBFC BE                     CP     M                    ; Current File Record > fcbRecordCount
1642: EBFD 38 04                  JR     C,DiskWrite1         ;  skip if yes
1643: EBFF 77                     LD     (HL),A               ; update the FCB RC
1644: EC00 34                     INC    M                    ; fcbRecordCount = current File Record+1
1645: EC01 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1646: EC03             DiskWrite1:
1647: EC03         ; A has current File Record, C=2 if new block or new record#
1648: EC03 0D                     DEC    C
1649: EC04 0D                     DEC    C                    ; Check if C = unallocated write
1650: EC05 20 05                  JR     NZ,DiskWrite2        ; Skip if C not unallocated write
1651: EC07 F5                     PUSH   AF                   ; currentFileRecord
1652: EC08 CD D8 EF               CALL   ResetFileWriteFlag
1653: EC0B         ;	CALL	GetWriteFileFlagValue		; HL points to FCB s2
1654: EC0B         ;	RES		7,(HL)						; Reset WriteFileFlag
1655: EC0B F1                     POP    AF                   ; currentFileRecord
1656: EC0C             DiskWrite2:
1657: EC0C         ; check for end of extent, if found attempt
1658: EC0C         ; to open next extent in preparation for next write
1659: EC0C FE 7F                  CP     highestRecordNumber  ; Space for more records ?
1660: EC0E 20 19                  JR     NZ,DiskWriteCleanup  ;  finish up if Yes
1661: EC10
1662: EC10 3A AE F4               LD     A,(diskAccessType)   ; Is this using Random Access
1663: EC13 B7                     OR     A
1664: EC14 28 13                  JR     Z,DiskWriteCleanup   ;  finish up if Yes
1665: EC16
1666: EC16 CD 81 F0               CALL   UpdateRecordVariables ; Update variables from I/O in  FCB
1667: EC19 CD A8 F2               CALL   OpenNextExt          ; Acc = 0 OK, Acc = 1 Failed
1668: EC1C 21 B6 EA               LD     HL,exitParameterByte
1669: EC1F 7E                     LD     A,(HL)               ; Put Open  result in parameter
1670: EC20 B7                     OR     A                    ; Is it 00
1671: EC21 20 04                  JR     NZ,DiskWriteCleanup0 ;  no, skip currentRecord update
1672: EC23 3D                     DEC    A                    ; A gets FF
1673: EC24 32 BE F4               LD     (currentFileRecord),A ; Update currentFileRecord
1674: EC27
1675: EC27             DiskWriteCleanup0:
1676: EC27 36 00                  LD     (HL),0               ; Set exitParameterByte
1677: EC29             DiskWriteCleanup:
1678: EC29 C3 81 F0               JP     UpdateRecordVariables ; update variables from I/O in  FCB
1679: EC2C
1680: EC2C
1681: EC2C         ;--------------------------------- Make File - 16 (22) ---------------------;
1682: EC2C         ;  This function creates a new file of the specified name and type. You must;
1683: EC2C         ; first ensure that no file of the same name and type already exists on the ;
1684: EC2C         ; same logical disk, either by trying to open the file (if this succeeds,   ;
1685: EC2C         ; the file already exists) or by unconditionally erasing the file.          ;
1686: EC2C         ;  In addition to creating the file and its associated file directory entry,;
1687: EC2C         ; this function also effectively opens the file so that it is ready for     ;
1688: EC2C         ; records to be written to it.                                              ;
1689: EC2C         ;  This function returns a normal directory code if the file creation has   ;
1690: EC2C         ; completed successfully or a value of OFFH if there is insufficient        ;
1691: EC2C         ; disk or directory space.                                                  ;
1692: EC2C         ;  Note that this function cannot accept an ambiguous file name in the FCB. ;
1693: EC2C         ;                                                                           ;
1694: EC2C         ;                                                                           ;
1695: EC2C         ;			Function Code	:	C  = 16H                                    ;
1696: EC2C         ;			Entry Parameters:	DE = Address of File Control Block			;
1697: EC2C         ;			Exit Parameters :	A  = Directory Code							;
1698: EC2C         ;																			;
1699: EC2C         ;---------------------------- Make File - 16 (22) --------------------------;
1700: EC2C             vMakeFile:
1701: EC2C CD BE EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1702: EC2F CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1703: EC32 C3 B3 EE               JP     MakeNewFile          ; Go Make it
1704: EC35
1705: EC35         ;-------------------------- Rename File - 17 (23) --------------------------;
1706: EC35         ;  This function renames an existing file name and type to a new name and   ;
1707: EC35         ; type. It is unusual in that it uses a single FCB to store both the old    ;
1708: EC35         ; file name and type (in the first 16 bytes) and the new file name and type ;
1709: EC35         ; (in the second 16 bytes).                                                 ;
1710: EC35         ;  This function returns a normal directory code if the file rename was     ;
1711: EC35         ; completed successfully or a value of OFFH if the old file name could not  ;
1712: EC35         ; be found.                                                                 ;
1713: EC35         ;                                                                           ;
1714: EC35         ;  The Rename File function only checks that the old file name and type     ;
1715: EC35         ; exist; it makes no check to ensure that the new name and type combination ;
1716: EC35         ; does not already exist. Therefore, you should try to open the new file    ;
1717: EC35         ; name and type. If you succeed, do not attempt the rename operation.       ;
1718: EC35         ; CP/M will create more than one file of the same name and type, and you    ;
1719: EC35         ; stand to lose the information in both files as you attempt to sort out    ;
1720: EC35         ; the problem.                                                              ;
1721: EC35         ;  Never use ambiguous file names in a rename operation; it produces strange;
1722: EC35         ; effects and may result in files being irreparably damaged. This function  ;
1723: EC35         ; will change all occurrences of the old file name to the new name.         ;
1724: EC35         ;                                                                           ;
1725: EC35         ;                                                                           ;
1726: EC35         ;			Function Code	:	C  = 17H									;
1727: EC35         ;			Entry Parameters:	DE = Address of File Control Block			;
1728: EC35         ;			Exit Parameters :	A  = Directory Code							;
1729: EC35         ;																			;
1730: EC35         ;-------------------------- Rename File - 17 (23) --------------------------;
1731: EC35             vRenameFile:
1732: EC35 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1733: EC38 CD 29 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1734: EC3B 0E 0C                  LD     C,fcbExtIndex        ; Match user#, Name & Type only
1735: EC3D CD F6 EF               CALL   SearchForDirectoryRecord
1736: EC40
1737: EC40         ; Move the old use number to the new entry (2nd half of FCB)
1738: EC40 2A B4 EA               LD     HL,(paramDE)         ; FCB pointer
1739: EC43 7E                     LD     A,(HL)               ; First byte of Dir entry
1740: EC44 11 10 00               LD     DE,fcbDiskMapIndex   ; Use second half of FCB
1741: EC47 19                     ADD    HL,DE                ; Point at the second half of FCB
1742: EC48 77                     LD     (HL),A               ; Put into new name user position
1743: EC49
1744: EC49             RenameLoop:
1745: EC49 CD 47 F1               CALL   AtEndOfDirectory     ; If have we checked the whole dir
1746: EC4C CA 22 F2               JP     Z,DirLocationToReturnLoc ;  return directory Index to caller
1747: EC4F         ; process this match
1748: EC4F CD 30 F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1749: EC52 0E 10                  LD     C,fcbDiskMapIndex    ; Set starting position
1750: EC54 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1751: EC56 CD 41 F2               CALL   CopyDir              ; copy from FCB to dir entry
1752: EC59         ; element renamed, look for more
1753: EC59 CD 0B F0               CALL   GetNextDirectoryRecord ; Look for more dir entries
1754: EC5C 18 EB                  JR     RenameLoop           ; Loop
1755: EC5E
1756: EC5E         ;---------------------------- Get Active Disks - 18 (24) -------------------;
1757: EC5E         ; This function returns a bit map, called the login vector, in register     ;
1758: EC5E         ; pair  HL, indicating which logical disk drives have been selected since   ;
1759: EC5E         ; the last  warm boot or Reset Disk function (code 13, ODH). The least      ;
1760: EC5E         ; significant bit of L corresponds to disk A, while the highest order bit   ;
1761: EC5E         ; in H maps disk P. The bit corresponding to the specific logical disk is   ;
1762: EC5E         ; set to 1 if the disk has been selected or to 0 if the disk is not         ;
1763: EC5E         ; currently on-line.                                                        ;
1764: EC5E         ;  Logical disks can be selected programmatically through any file          ;
1765: EC5E         ; operation  that sets the drive field to a nonzero value, through the      ;
1766: EC5E         ; Select Disk function (code 14, OEH), or by the operator entering an       ;
1767: EC5E         ; "X:" command where "X" is equal to A, B, ... , P.                         ;
1768: EC5E         ;                                                                           ;
1769: EC5E         ;			Function Code	:	C = 018H                                    ;
1770: EC5E         ;			Entry Parameters:	None										;
1771: EC5E         ;			Exit Parameters :	HL = Active disk map (login vector)			;
1772: EC5E         ;																			;
1773: EC5E         ;---------------------------- Get Active Disks - 18 (24) -------------------;
1774: EC5E             vGetLoginVector:
1775: EC5E 2A 8D F4               LD     HL,(loggedDisks)
1776: EC61 22 B6 EA               LD     (exitParameterWord),HL
1777: EC64 C9                     RET
1778: EC65
1779: EC65         ;---------------------------- Get Current Disk- 19 (25) --------------------;
1780: EC65         ;   This function returns the current default disk set by the last Select   ;
1781: EC65         ; Disk function call (code 14, OEH) or by the operator entering the         ;
1782: EC65         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                       ;
1783: EC65         ;                                                                           ;
1784: EC65         ;  This function returns the current default disk in coded form.            ;
1785: EC65         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.   ;
1786: EC65         ; If you need to convert this to the corresponding ASCII character, simply  ;
1787: EC65         ; add 41H to register A. Use this function when you convert a file name and ;
1788: EC65         ; type in an FCB to an ASCII string in order to display it. If the first    ;
1789: EC65         ; byte of the FCB is OOH, the current default drive is to be used.          ;
1790: EC65         ; You must therefore use this function to determine the logical disk letter ;
1791: EC65         ; for the default drive.                                                    ;
1792: EC65         ;                                                                           ;
1793: EC65         ;			Function Code	:	C = 019H                                    ;
1794: EC65         ;			Entry Parameters:	None										;
1795: EC65         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			;
1796: EC65         ;																			;
1797: EC65         ;---------------------------- Get Current Disk- 19 (25) --------------------;
1798: EC65             vGetCurrentDisk:
1799: EC65 3A 89 F4               LD     A,(currentDisk)
1800: EC68 32 B6 EA               LD     (exitParameterByte),A
1801: EC6B C9                     RET
1802: EC6C
1803: EC6C         ;---------------------------- Set DMA Address - 1A (26) --------------------;
1804: EC6C         ;  This function sets the BDOS's direct memory access (DMA) address to a new;
1805: EC6C         ; value. The name is an historic relic dating back to the Intel Development ;
1806: EC6C         ; System on which CP/M was originally developed. This machine, by virtue of ;
1807: EC6C         ; its hardware, could read data from a diskette directly into memory or     ;
1808: EC6C         ; write data to a diskette directly from memory. The name DMA address now   ;
1809: EC6C         ; applies to the address of the buffer to and from which data is            ;
1810: EC6C         ; transferred whenever a diskette Read, Write, or directory operation is    ;
1811: EC6C         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or     ;
1812: EC6C         ; Reset Disk operation occurs, the DMA address is reset to its default      ;
1813: EC6C         ; value of 0080H.                                                           ;
1814: EC6C         ;                                                                           ;
1815: EC6C         ;			Function Code	:	C = 0A9H                                    ;
1816: EC6C         ;			Entry Parameters:	DE = DMA Address							;
1817: EC6C         ;			Exit Parameters :	None										;
1818: EC6C         ;																			;
1819: EC6C         ;---------------------------- Set DMA Address - 1A (26) --------------------;
1820: EC6C             vSetDMA:
1821: EC6C 2A B4 EA               LD     HL,(paramDE)
1822: EC6F 22 8F F4               LD     (initDAMAddress),HL
1823: EC72 C3 07 EF               JP     SetDataDMA
1824: EC75
1825: EC75         ;---------------------------- Get Allocation Vector - 1B (27) --------------;
1826: EC75         ;  This function returns the base, or starting, address of the allocation   ;
1827: EC75         ; vector for the currently selected logical disk. This information,         ;
1828: EC75         ; indicating which parts of the disk are assigned, is used by utility       ;
1829: EC75         ; programs and the BDOS itself to determine how much unused space is on the ;
1830: EC75         ; logical disk, to locate an unused allocation block in order to extend     ;
1831: EC75         ; a file, or to relinquish an allocation block when a file is deleted.      ;
1832: EC75         ;                                                                           ;
1833: EC75         ;			Function Code	:	C = 01BH                                    ;
1834: EC75         ;			Entry Parameters:	None										;
1835: EC75         ;			Exit Parameters :	HL = Address of allocation vector			;
1836: EC75         ;																			;
1837: EC75         ;---------------------------- Get Allocation Vector - 1B (27) --------------;
1838: EC75             vGetAllocAddr:
1839: EC75 2A 9D F4               LD     HL,(caAllocVector)
1840: EC78 22 B6 EA               LD     (exitParameterWord),HL
1841: EC7B C9                     RET
1842: EC7C
1843: EC7C         ;---------------------------- Write Protect Disk - 1C (28) -----------------;
1844: EC7C         ;  This function logically sets the currently selected disk to a Read-Only  ;
1845: EC7C         ; state. Any attempts to execute a Write Sequential or Write Random function;
1846: EC7C         ; to the selected disk will be intercepted by the BDOS, and the following   ;
1847: EC7C         ; message will appear on the console:                                       ;
1848: EC7C         ;	BDOS Err on X: R/O                                                      ;
1849: EC7C         ;	where X: is the selected disk.                                          ;
1850: EC7C         ;                                                                           ;
1851: EC7C         ;  Once you have requested Read-Only status for the currently selected      ;
1852: EC7C         ; logical disk, this status will persist even if you proceed to select      ;
1853: EC7C         ; other logical disks. In fact, it will remain in force until the next warm ;
1854: EC7C         ; boot or Reset Disk System function call.                                  ;
1855: EC7C         ;  Digital Research documentation refers to this function code as Disk Write;
1856: EC7C         ; Protect. The Read-Only description is used here because it corresponds    ;
1857: EC7C         ; to the error message produced if your program attempts to write on        ;
1858: EC7C         ; the disk.                                                                 ;
1859: EC7C         ;                                                                           ;
1860: EC7C         ;			Function Code	:	C = 01CH                                    ;
1861: EC7C         ;			Entry Parameters:	None										;
1862: EC7C         ;			Exit Parameters :	None										;
1863: EC7C         ;																			;
1864: EC7C         ;---------------------------- Write Protect Disk - 1C (28) -----------------;
1865: EC7C         ;;write protect current disk
1866: EC7C             vWriteProtectDisk:
1867: EC7C C3 1D EF               JP     SetDiskReadOnly
1868: EC7F
1869: EC7F         ;---------------------------- Get Read-Only Map - 1D (29) ------------------;
1870: EC7F         ;  This function returns a bit map in registers H and L showing which       ;
1871: EC7F         ; logical disks in the system have been set to Read-Only status, either by  ;
1872: EC7F         ; the Set Logical Disk to Read-Only function call (code 28, ICH), or by     ;
1873: EC7F         ; the BDOS itself, because it detected that a diskette had been changed.    ;
1874: EC7F         ;  The least significant bit of L corresponds to logical disk A, while the  ;
1875: EC7F         ; most significant bit of H corresponds to disk P. The bit corresponding to ;
1876: EC7F         ; the specific logical disk is set to I if the disk has been set to         ;
1877: EC7F         ; Read-Only status.                                                         ;
1878: EC7F         ;                                                                           ;
1879: EC7F         ;			Function Code	:	C = 01DH                                    ;
1880: EC7F         ;			Entry Parameters:	None										;
1881: EC7F         ;			Exit Parameters :	HL = Read-Only Vector						;
1882: EC7F         ;																			;
1883: EC7F         ;---------------------------- Get Read-Only Map - 1D (29) ------------------;
1884: EC7F             vGetReadOnlyMap:
1885: EC7F 2A 8B F4               LD     HL,(readOnlyVector)
1886: EC82 22 B6 EA               LD     (exitParameterWord),HL
1887: EC85 C9                     RET
1888: EC86
1889: EC86         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1890: EC86         ;  This function sets the bits that describe attributes of a file in the    ;
1891: EC86         ; relevant directory entries for the specified file. Each file can be       ;
1892: EC86         ; assigned up to 11 file attributes. Of these 11, two have predefined       ;
1893: EC86         ; meanings, four others are available for you to use, and the remaining     ;
1894: EC86         ; five are reserved for future use by CP/M.                                 ;
1895: EC86         ;  Each attribute consists of a single bit. The most significant bit of     ;
1896: EC86         ; each byte of the file name and type is used to store the attributes.      ;
1897: EC86         ; The file attributes are known by a code consisting of the letter "f"      ;
1898: EC86         ; (for file name) or "t" (for file type), followed by the number of the     ;
1899: EC86         ; character position and a single quotation mark. For example, the Read-Only;
1900: EC86         ; attribute is tl'.                                                         ;
1901: EC86         ;	The significance of the attributes is as follows:                       ;
1902: EC86         ;			fl' to f4' Available for you to use                             ;
1903: EC86         ;			f5' to fS' Reserved for future CP/M use                         ;
1904: EC86         ;			tl' Read-Only File attribute                                    ;
1905: EC86         ;			t2' System File attribute                                       ;
1906: EC86         ;			t3' Reserved for future CP/M use                                ;
1907: EC86         ;			                                                                ;
1908: EC86         ;  Attributes are set by presenting this function with an FCB in which the  ;
1909: EC86         ; unambiguous file name has been preset with the most significant bits      ;
1910: EC86         ; set appropriately. This function then searches the directory for a match  ;
1911: EC86         ; and changes the matched entries to contain the attributes which have been ;
1912: EC86         ; set in the FCB.                                                           ;
1913: EC86         ;  The BDOS will intercept any attempt to write on a file that has the      ;
1914: EC86         ; Read-Only attribute set. The DIR command in the CCP does not display any  ;
1915: EC86         ; file with System status.                                                  ;
1916: EC86         ;                                                                           ;
1917: EC86         ;  You can use the four attributes available to you to set up a file        ;
1918: EC86         ; security system, or perhaps to flag certain files that must be backed up  ;
1919: EC86         ; to other disks. The Search First and Search Next functions allow you to   ;
1920: EC86         ; view the complete file directory entry, so your programs can test the     ;
1921: EC86         ; attributes easily.                                                        ;
1922: EC86         ;                                                                           ;
1923: EC86         ;                                                                           ;
1924: EC86         ;			Function Code	:	C  = 1EH                                    ;
1925: EC86         ;			Entry Parameters:	DE = Address of File Control Block			;
1926: EC86         ;			Exit Parameters :	A  = Directory Code							;
1927: EC86         ;																			;
1928: EC86         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1929: EC86             vSetFileAttributes:
1930: EC86 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
1931: EC89 0E 0C                  LD     C,fcbExtIndex        ; Size of search/match
1932: EC8B CD F6 EF               CALL   SearchForDirectoryRecord ; Find a match
1933: EC8E
1934: EC8E             SetAttributesLoop:
1935: EC8E CD 47 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
1936: EC91 CA 22 F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1937: EC94         ; Directory entry found
1938: EC94 0E 00                  LD     C,0                  ; Set starting position
1939: EC96 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1940: EC98 CD 41 F2               CALL   CopyDir              ; copy from FCB to dir entry
1941: EC9B CD 0B F0               CALL   GetNextDirectoryRecord ; Go find the next directory record
1942: EC9E 18 EE                  JR     SetAttributesLoop    ; Loop
1943: ECA0
1944: ECA0         ;------------------ Get Disk Parameter Block Address - 1F (31) -------------;
1945: ECA0         ;  This function returns the address of the disk parameter block (DPB) for  ;
1946: ECA0         ; the last selected logical disk. The DPB describes the physical            ;
1947: ECA0         ; characteristics of a specific logical disk-information mainly of interest ;
1948: ECA0         ; for system utility programs.                                              ;
1949: ECA0         ;                                                                           ;
1950: ECA0         ;			Function Code	:	C = 1FH                                     ;
1951: ECA0         ;			Entry Parameters:	None										;
1952: ECA0         ;			Exit Parameters :	HL = Address of Disk Parameter Block		;
1953: ECA0         ;																			;
1954: ECA0         ;------------------ Get Disk Parameter Block Address - 1F (31) -------------;
1955: ECA0             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1956: ECA0 2A 99 F4               LD     HL,(caDiskParamBlock)
1957: ECA3 22 B6 EA               LD     (exitParameterWord),HL
1958: ECA6 C9                     RET
1959: ECA7
1960: ECA7         ;------------------------- Read Random - 21 (33) ---------------------------;
1961: ECA7         ; This function reads a specific CP/M record (128 bytes) from a random file ;
1962: ECA7         ; that is, a file in which records can be accessed directly. It assumes that;
1963: ECA7         ; you have already opened the file, set the DMA address using the BDOS      ;
1964: ECA7         ; Set DMA function, and set the specific record to be read into the random  ;
1965: ECA7         ; record number in the FCB. This function computes the extent of the        ;
1966: ECA7         ; specified record number and attempts to open it and read the correct CP/M ;
1967: ECA7         ; record into the DMA address.                                              ;
1968: ECA7         ;  The random record number in the FCB is three bytes long (at relative     ;
1969: ECA7         ; bytes 33, 34, and 35). Byte 33 is the least significant byte, 34 is the   ;
1970: ECA7         ; middle byte, and 35 the most significant. CP/M uses only the most         ;
1971: ECA7         ; significant byte (35) for computing the overall file size (function 35).  ;
1972: ECA7         ; You must set this byte to 0 when setting up the FCB. Bytes 33 and 34      ;
1973: ECA7         ; are used together for the Read Random, so you can access from record      ;
1974: ECA7         ; 0 to 65535 (a maximum file size of 8,388,480 bytes).                      ;
1975: ECA7         ;  This function returns with A set to 0 to indicate that the operation has ;
1976: ECA7         ; been completed successfully, or A set to a nonzero value if an error has  ;
1977: ECA7         ; occurred. The error codes are as follows:                                 ;
1978: ECA7         ;		A = 01 (attempt to read unwritten record)                           ;
1979: ECA7         ;		A = 03 (CP/M could not close current extent)                        ;
1980: ECA7         ;		A = 04 (attempt to read unwritten extent)                           ;
1981: ECA7         ;		A = 06 (attempt to read beyond end of disk)                         ;
1982: ECA7         ;		                                                                    ;
1983: ECA7         ;  Unlike the Read Sequential BOOS function (code 20, l4H), which updates   ;
1984: ECA7         ; the current (sequential) record number in the FCB, the Read Random        ;
1985: ECA7         ; function leaves the record number unchanged, so that a subsequent Write   ;
1986: ECA7         ; Random will replace the record just read.                                 ;
1987: ECA7         ;  You can follow a Read Random with a Write Sequential (code 21, l5H).     ;
1988: ECA7         ; This will rewrite the record just read, but will then update the          ;
1989: ECA7         ; sequential record number. Or you may choose to use a Read Sequential after;
1990: ECA7         ; the Read Random. In this case, the same record will be reread and the     ;
1991: ECA7         ; sequential record number will be incremented. In short, the file can be   ;
1992: ECA7         ; sequentially read or written once the Read Random has been used to        ;
1993: ECA7         ; position to the required place in the file.                               ;
1994: ECA7         ;                                                                           ;
1995: ECA7         ; To use the Read Random function, you must first open the base extent of   ;
1996: ECA7         ; the file, that is, extent O. Even though there may be no actual data      ;
1997: ECA7         ; records in this extent, opening permits the file to be processed          ;
1998: ECA7         ; correctly.                                                                ;
1999: ECA7         ;  One problem that is not immediately obvious with random files is that    ;
2000: ECA7         ; they can easily be created with gaps in the file. If you were to create   ;
2001: ECA7         ; the file with record number 0 and record number 5000, there would be no   ;
2002: ECA7         ; intervening file extents. Should you attempt to read or copy the file     ;
2003: ECA7         ; sequentially, even using CP/M's file copy utility, only the first extent  ;
2004: ECA7         ; (and in this case, record 0) would get copied. A Read Sequential function ;
2005: ECA7         ; would return an "end of file" error after reading record O. You must      ;
2006: ECA7         ; therefore be conscious of the type of the file that you try and read.     ;
2007: ECA7         ;                                                                           ;
2008: ECA7         ;                                                                           ;
2009: ECA7         ;                                                                           ;
2010: ECA7         ;			Function Code	:   C  = 21H                                    ;
2011: ECA7         ;			Entry Parameters:  DE = Address of File Control Block			;
2012: ECA7         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)   ;
2013: ECA7         ;								A = 03 (CP/M could not close current extent);
2014: ECA7         ;								A = 04 (attempt to read unwritten extent)   ;
2015: ECA7         ;								A = 06 (attempt to read beyond end of disk) ;
2016: ECA7         ;																			;
2017: ECA7         ;------------------------- Read Random - 21 (33) ---------------------------;
2018: ECA7             vReadRandom:
2019: ECA7 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
2020: ECAA
2021: ECAA 0E FF                  LD     C,TRUE               ; Identify as a Read
2022: ECAC CD 93 F0               CALL   RandomSeek           ; Set up correct Dir entry etc.
2023: ECAF CC 39 EB               CALL   Z,DiskRead           ; Go Read
2024: ECB2 C9                     RET
2025: ECB3         ;------------------------- Write Random - 22 (34) --------------------------;
2026: ECB3         ; This function writes a specific CP/M record (128 bytes) into a random     ;
2027: ECB3         ; file. It is initiated in much the same way as the companion function,     ;
2028: ECB3         ; Read Random (code 33,21H). It assumes that you have already opened the    ;
2029: ECB3         ; file, set the DMAaddress to the address in memory containing the record to;
2030: ECB3         ; be written to disk, and set the random record number in the FCB to the    ;
2031: ECB3         ; specified record being written. This function also computes the extent in ;
2032: ECB3         ; which the specified record number lies and opens the extent (creating it  ;
2033: ECB3         ; if it does not already exist). The error codes returned in A by this call ;
2034: ECB3         ; are the same as those for Read Random, with the addition of error         ;
2035: ECB3         ; code 05, which indicates a full directory.                                ;
2036: ECB3         ;  Like the Read Random (but unlike the Write Sequential), this function    ;
2037: ECB3         ; does not update the logical extent and sequential (current) record number ;
2038: ECB3         ; in the FCB. Therefore, any subsequent sequential operation will access    ;
2039: ECB3         ; the record just written by the Read Random call, but these functions will ;
2040: ECB3         ; update the sequential record number. The Write Random can therefore be    ;
2041: ECB3         ; used to position to the required place in the file, which can then be     ;
2042: ECB3         ; accessed sequentially.                                                    ;
2043: ECB3         ;                                                                           ;
2044: ECB3         ;  In order to use the Write Random, you must first open the base extent    ;
2045: ECB3         ; (extent 0) of the file. Even though there may be no data records in this  ;
2046: ECB3         ; extent, opening permits the file to be processed correctly.               ;
2047: ECB3         ;  As explained in the notes for the Read Random function, you can easily   ;
2048: ECB3         ; create a random file with gaps in it. If you were to create a file with   ;
2049: ECB3         ; record number 0 and record number 5000, there would be no intervening     ;
2050: ECB3         ; file extents.                                                             ;
2051: ECB3         ;                                                                           ;
2052: ECB3         ;			Function Code	:   C  = 24H                                    ;
2053: ECB3         ;			Entry Parameters:  DE = Address of File Control Block			;
2054: ECB3         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)   ;
2055: ECB3         ;								A = 03 (CP/M could not close current extent);
2056: ECB3         ;								A = 04 (attempt to read unwritten extent)   ;
2057: ECB3         ;								A = 05 (CP/M cannot create new extent)		;
2058: ECB3         ;								A = 06 (attempt to read beyond end of disk) ;
2059: ECB3         ;																			;
2060: ECB3         ;------------------------- Write Random - 22 (34) --------------------------;
2061: ECB3             vWriteRandom:
2062: ECB3 CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
2063: ECB6
2064: ECB6 0E 00                  LD     C,FALSE              ; Identify as a Write
2065: ECB8 CD 93 F0               CALL   RandomSeek
2066: ECBB CC 7C EB               CALL   Z,DiskWrite          ; Go Write
2067: ECBE C9                     RET
2068: ECBF
2069: ECBF         ;------------------------- Get File Size - 23 (35) -------------------------;
2070: ECBF         ;  This function returns the virtual size of the specified file. It does so ;
2071: ECBF         ; by setting the random record number (bytes 33-35) in the specified FCB to ;
2072: ECBF         ; the maximum 128-byte record number in the file. The virtual file size is  ;
2073: ECBF         ; calculated from the record address of the record following the end of the ;
2074: ECBF         ; file. Bytes 33 and 34 form a 16-bit value that contains the record number,;
2075: ECBF         ; with overflow indicated in byte 35. If byte 35 is 01, this means that the ;
2076: ECBF         ; file has the maximum record count of 65,536.                              ;
2077: ECBF         ;  If the function cannot find the file specified by the FCB, it returns    ;
2078: ECBF         ; with the random record field set to O.                                    ;
2079: ECBF         ;  You can use this function when you want to add data to the end of an     ;
2080: ECBF         ; existing file. By calling this function first, the random record bytes    ;
2081: ECBF         ; will be set to the end of file. Subsequent Write Random calls will write  ;
2082: ECBF         ; out records to this preset address.                                       ;
2083: ECBF         ;                                                                           ;
2084: ECBF         ;  Do not confuse the virtual file size with the actual file size. In a     ;
2085: ECBF         ; random file, if you write just a single CP/M record to record number      ;
2086: ECBF         ; 1000 and then call this function, it will return with the random record   ;
2087: ECBF         ; number field set in the FCB to 1000, even though only a single record     ;
2088: ECBF         ; exists in the file. For sequential files, this function returns the       ;
2089: ECBF         ; number of records in the file. In this case, the virtual and actual file  ;
2090: ECBF         ; sizes coincide.                                                           ;
2091: ECBF         ;                                                                           ;
2092: ECBF         ;                                                                           ;
2093: ECBF         ;			Function Code	:	C  = 23H                                    ;
2094: ECBF         ;			Entry Parameters:	DE = Address of File Control Block			;
2095: ECBF         ;			Exit Parameters :	Random record field set in FCB				;
2096: ECBF         ;																			;
2097: ECBF         ;------------------------- Get File Size - 23 (35) -------------------------;
2098: ECBF             vComputeFileSize:
2099: ECBF CD 40 EF               CALL   ReselectDisk         ; Reselect if needed
2100: ECC2
2101: ECC2 0E 0C                  LD     C,fcbExtIndex        ; Set search/match length
2102: ECC4 CD F6 EF               CALL   SearchForDirectoryRecord ; Set directoryIndex
2103: ECC7         ; zero the receiving FCB Random Record field
2104: ECC7 2A B4 EA               LD     HL,(paramDE)         ; Point at FCB
2105: ECCA 11 21 00               LD     DE,recordRandom      ; Random Record index
2106: ECCD 19                     ADD    HL,DE                ; Point at Random Record
2107: ECCE E5                     PUSH   HL                   ; Random Record LSB pointer
2108: ECCF 72                     LD     (HL),D               ; Set Random Record LSB = 0
2109: ECD0 23                     INC    HL                   ; Random Record MSB pointer
2110: ECD1 72                     LD     (HL),D               ; Set Random Record MSB = 0
2111: ECD2 23                     INC    HL                   ; Random Record overflow pointer
2112: ECD3 72                     LD     (HL),D               ; Set Random Record overflow = 0
2113: ECD4
2114: ECD4             GetFileSize1:
2115: ECD4 CD 47 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
2116: ECD7 28 20                  JR     Z,GetFileSizeExit    ;  exit if no
2117: ECD9
2118: ECD9 CD 50 F1               CALL   GetCurrentDirectoryRecord ; HL points at Directory entry
2119: ECDC 11 0F 00               LD     DE,fcbRCIndex        ; FCB Record Count index
2120: ECDF CD 13 F1               CALL   GetRandomRecordPosition
2121: ECE2         ; ???????
2122: ECE2 E1                     POP    HL
2123: ECE3 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
2124: ECE4 5F                     LD     E,A                  ; save cy
2125: ECE5 79                     LD     A,C
2126: ECE6 96                     SUB    M
2127: ECE7 23                     INC    HL                   ; ls byte
2128: ECE8 78                     LD     A,B
2129: ECE9 9E                     SBC    A,(HL)
2130: ECEA 23                     INC    HL                   ; middle byte
2131: ECEB 7B                     LD     A,E
2132: ECEC 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
2133: ECED 38 05                  JR     C,GetFileSize2       ; for another try
2134: ECEF         ; fcb is less or equal, fill from directory
2135: ECEF 73                     LD     (HL),E
2136: ECF0 2B                     DEC    HL
2137: ECF1 70                     LD     (HL),B
2138: ECF2 2B                     DEC    HL
2139: ECF3 71                     LD     (HL),C
2140: ECF4             GetFileSize2:                      ; getnextsize:
2141: ECF4 CD 0B F0               CALL   GetNextDirectoryRecord
2142: ECF7 18 DB                  JR     GetFileSize1
2143: ECF9             GetFileSizeExit:                      ; setsize:
2144: ECF9 E1                     POP    HL                   ; discard .fcb(random record field)
2145: ECFA C9                     RET
2146: ECFB
2147: ECFB         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2148: ECFB         ;  This function sets the random record number in the FCB to the correct    ;
2149: ECFB         ; value for the last record read or written sequentially to the file.       ;
2150: ECFB         ;                                                                           ;
2151: ECFB         ;  This function provides you with a convenient way to build an index file  ;
2152: ECFB         ; so that you can randomly access a sequential file. Open the sequential    ;
2153: ECFB         ; file, and as you read each record, extract the appropriate key field from ;
2154: ECFB         ; the data record. Make the BDOS Set Random Record request and create a new ;
2155: ECFB         ; data record with just the key field and the random record number. Write   ;
2156: ECFB         ; the new data record out to the index file.                                ;
2157: ECFB         ;  Once you have done this for each record in the file, your index file     ;
2158: ECFB         ; provides a convenient method, given a search key value, of finding the    ;
2159: ECFB         ; appropriate CP/M record in which the data lies.                           ;
2160: ECFB         ;  You can also use this function as a means of finding out where you are   ;
2161: ECFB         ; currently positioned in a sequential file-either to relate a CP/M record  ;
2162: ECFB         ; number to the position, or simply as a place-marker to allow a            ;
2163: ECFB         ; repositioning to the same place later.                                    ;
2164: ECFB         ;                                                                           ;
2165: ECFB         ;                                                                           ;
2166: ECFB         ;			Function Code	:	C  = 24H                                    ;
2167: ECFB         ;			Entry Parameters:	DE = Address of File Control Block			;
2168: ECFB         ;			Exit Parameters :	Random record field set in FCB				;
2169: ECFB         ;																			;
2170: ECFB         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2171: ECFB             vSetRandomRecord:
2172: ECFB 2A B4 EA               LD     HL,(paramDE)         ; FCB
2173: ECFE 11 20 00               LD     DE,recordSeq         ; Sequential record index
2174: ED01 CD 13 F1               CALL   GetRandomRecordPosition
2175: ED04         ; A = Overflow, B = randomRecord MSB, C = randomRecord LSB
2176: ED04 21 21 00               LD     HL,recordRandom
2177: ED07 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
2178: ED08 71                     LD     (HL),C
2179: ED09 23                     INC    HL
2180: ED0A 70                     LD     (HL),B
2181: ED0B 23                     INC    HL
2182: ED0C 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
2183: ED0D C9                     RET
2184: ED0E
2185: ED0E         ;------------------------ Reset Logical Disk Drive - 25 (37) ---------------;
2186: ED0E         ;  This function resets individual disk drives. It is a more precise        ;
2187: ED0E         ; version of the Reset Disk System function (code 13,ODH), in that you      ;
2188: ED0E         ; can set specific logical; disks rather than all of them.                  ;
2189: ED0E         ;  The bit map in DE shows which disks are to be reset. The least           ;
2190: ED0E         ; significant bit of E represents disk A, and the most significant bit of   ;
2191: ED0E         ; D, disk P. The bits set to 1 indicate the disks to be reset.              ;
2192: ED0E         ;  Note that this function returns a zero value in A in order to maintain   ;
2193: ED0E         ; compatibility with MP/ M.                                                 ;
2194: ED0E         ;                                                  ;                        ;
2195: ED0E         ;  Use this function when only specific diskettes need to be changed.       ;
2196: ED0E         ; Changing a diskette without requesting CP/M to log it in will cause the   ;
2197: ED0E         ; BDOS to assume that an error has occurred and to set the new diskette to  ;
2198: ED0E         ; Read-Only status as a protective measure                                  ;
2199: ED0E         ;                                                                           ;
2200: ED0E         ;			Function Code	:	C = 25H                                     ;
2201: ED0E         ;			Entry Parameters:	DE = Logical Drive Bit Vector				;
2202: ED0E         ;			Exit Parameters :	A = 00H										;
2203: ED0E         ;																			;
2204: ED0E         ;------------------------ Reset Logical Disk Drive - 25 (37) ---------------;
2205: ED0E         ;  **************  Not Yet Implemented   **************
2206: ED0E             vResetDrive:
2207: ED0E 3E FF                  LD     A,-1                 ; Error return
2208: ED10 C9                     RET
2209: ED11
2210: ED11         ;------------------------------ Access Drive - 26 (38) ---------------------;
2211: ED11         ;								NOT SUPPORTED								;
2212: ED11         ;------------------------------ Access Drive - 26 (38) ---------------------;
2213: ED11
2214: ED11         ;------------------------------ Free   Drive - 27 (39) ---------------------;
2215: ED11         ;								NOT SUPPORTED								;
2216: ED11         ;------------------------------ Free   Drive - 27 (39) ---------------------;
2217: ED11
2218: ED11         ;---------------- Write Random with Zero Fill - 28 (40) --------------------;
2219: ED11         ;  This function is an extension to the Write Random function described     ;
2220: ED11         ; previously. In addition to performing the Write Random, it will also fill ;
2221: ED11         ; each new allocation block with OOH's. Digital Research added this function;
2222: ED11         ; to assist Microsoft with the production of its COBOL compiler-it makes the;
2223: ED11         ; logic of the file handling code easier. It also is an economical way to   ;
2224: ED11         ; completely fill a random file with OOH's. You need only write one record  ;
2225: ED11         ; per allocation block, the BDOS will clear the rest of the block for you.  ;
2226: ED11         ;                                                                           ;
2227: ED11         ;                                                                           ;
2228: ED11         ;			Function Code	:	C  = 24H                                    ;
2229: ED11         ;			Entry Parameters:	DE = Address of File Control Block			;
2230: ED11         ;			Exit Parameters :	A = Return Code								;
2231: ED11         ;																			;
2232: ED11         ;---------------- Write Random with Zero Fill - 28 (40) --------------------;
2233: ED11             vWriteRandom0Fill:
2234: ED11         ; Not Yet Implemented   **************
2235: ED11 C9                     RET
2236: ED12         ;--------------------------- Select  Drive ---------------------------------;
2237: ED12         ; Establish the disk found in (paramE) as the current disk drive            ;
2238: ED12             SelectCurrent:                      ;
2239: ED12 3A B3 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
2240: ED15 21 89 F4               LD     HL,currentDisk       ; Get the current disk              ;
2241: ED18 BE                     CP     M                    ; Are the the same ?                ;
2242: ED19 C8                     RET    Z                    ; Exit if yes, nothing to do        ;
2243: ED1A 77                     LD     (HL),A               ;  else update curretDisk and       ;
2244: ED1B 18 00                  JR     Select               ;  select it                        ;
2245: ED1D         ;--------------------------- Select  Drive ---------------------------------;
2246: ED1D         ;--------------------------- Select Login Drive ----------------------------;
2247: ED1D         ; select Login Drive                                                       ;
2248: ED1D             Select:                         ;
2249: ED1D CD 3E ED               CALL   SelectDisk           ; Select the Disk                   ;
2250: ED20 CC 17 F4               CALL   Z,Error_Select       ;
2251: ED23 21 89 F4               LD     HL,currentDisk       ;
2252: ED26 46                     LD     B,(HL)               ; Get Current Disk                  ;
2253: ED27 2A 8D F4               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
2254: ED2A CD E9 F3               CALL   IsBitSet             ;
2255: ED2D C0                     RET    NZ                   ; Exit if already logged in         ;
2256: ED2E         ;                                                                           ;
2257: ED2E 21 89 F4               LD     HL,currentDisk       ;
2258: ED31 46                     LD     B,(HL)               ; Get Current Disk                  ;
2259: ED32 2A 8D F4               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
2260: ED35 CD F9 F3               CALL   SetVectorBit         ;
2261: ED38 22 8D F4               LD     (loggedDisks),HL     ; Update the Vector                 ;
2262: ED3B         ;
2263: ED3B C3 84 ED               JP     InitDisk             ;
2264: ED3E         ;--------------------------- Select Login Drive ----------------------------;
2265: ED3E         ;--------------------------- Select Disk -----------------------------------;
2266: ED3E         ; select the disk drive given by currentDisk, and fill the base addresses   ;
2267: ED3E         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
2268: ED3E             SelectDisk:                      ;
2269: ED3E 3A 89 F4               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)     ;
2270: ED41 4F                     LD     C,A                  ; Prepare for BIOS Call             ;
2271: ED42 CD 1B F6               CALL   bcSeldsk             ; Select the disk                   ;
2272: ED45 7C                     LD     A,H                  ; Return Pointer to                 ;
2273: ED46 B5                     OR     L                    ;  Disk Parameter Header            ;
2274: ED47 C8                     RET    Z                    ; exit if error, with HL = 0000     ;
2275: ED48         ;
2276: ED48 5E                     LD     E,(HL)               ;
2277: ED49 23                     INC    HL                   ;
2278: ED4A 56                     LD     D,(HL)               ; Skew Table in DE                  ;
2279: ED4B 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File    ;
2280: ED4C ED 53 AF F4               LD     (caSkewTable),DE     ; Move to Current Skew Table        ;
2281: ED50         ;
2282: ED50 22 91 F4               LD     (caDirMaxValue),HL   ; Move to Current Dir max           ;
2283: ED53 23                     INC    HL                   ;
2284: ED54 23                     INC    HL                   ; HL = Last Track #                 ;
2285: ED55 22 93 F4               LD     (caTrack),HL         ; Move to Current Track #           ;
2286: ED58 23                     INC    HL                   ;
2287: ED59 23                     INC    HL                   ; HL = Last Sector #                ;
2288: ED5A 22 95 F4               LD     (caSector),HL        ; Move to Current Sector #          ;
2289: ED5D 23                     INC    HL                   ;
2290: ED5E 23                     INC    HL                   ;
2291: ED5F 11 97 F4               LD     DE,caDirectoryDMA    ;
2292: ED62 01 08 00               LD     BC,caListSize        ;
2293: ED65 ED B0                  LDIR                        ;
2294: ED67         ;
2295: ED67         ; finish filling in address list                                            ;
2296: ED67 2A 99 F4               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block        ;
2297: ED6A 11 9F F4               LD     DE,dpbStart          ; Point at BIOS DPB                 ;
2298: ED6D 01 0F 00               LD     BC,dpbSize           ;
2299: ED70 ED B0                  LDIR                        ; Move DPB to current               ;
2300: ED72         ;
2301: ED72         ; Determine if Byte or Word Allocation Table	                            ;
2302: ED72 2A A4 F4               LD     HL,(dpbDSM)          ; Get max entry number              ;
2303: ED75 7C                     LD     A,H                  ; If  its 00 then < 255             ;
2304: ED76 21 B8 F4               LD     HL,byteAllocationFlag ; Point at the  flag				;
2305: ED79 36 FF                  LD     (HL),TRUE            ; Assume its less than 255          ;
2306: ED7B B7                     OR     A                    ;  is the assumption confirmed ?    ;
2307: ED7C 28 02                  JR     Z,SelectDisk1        ;  skip if yes                      ;
2308: ED7E 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false  ;
2309: ED80         ;
2310: ED80         ; Set Sign, reset Carry and Zero to indicate success                        ;
2311: ED80             SelectDisk1:                      ;
2312: ED80 3E FF                  LD     A,TRUE               ;
2313: ED82 B7                     OR     A                    ;
2314: ED83 C9                     RET                         ;
2315: ED84         ;--------------------------- Select Disk -----------------------------------;
2316: ED84         ;--------------------------- Initialize Disk -------------------------------;
2317: ED84             InitDisk:                       ;
2318: ED84 2A A4 F4               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
2319: ED87 CD 0C F3               CALL   DivideHLby8          ; Length of Map                     ;
2320: ED8A E5                     PUSH   HL                   ; Save Length                       ;
2321: ED8B E5                     PUSH   HL                   ; Save for end of MAP               ;
2322: ED8C C1                     POP    BC                   ; BC = dpbDSM/8                     ;
2323: ED8D         ; Clear the Allocation Vector	                                            ;
2324: ED8D 2A 9D F4               LD     HL,(caAllocVector)   ; Allocation vector Start           ;
2325: ED90 36 00                  LD     (HL),0               ; Clear location                    ;
2326: ED92 ED 5B 9D F4               LD     DE,(caAllocVector)   ;
2327: ED96 13                     INC    DE                   ; Allocation vector Start + 1       ;
2328: ED97 ED B0                  LDIR                        ; Cascade 00 thru Map               ;
2329: ED99         ; Force bits at End of Map                                                  ;
2330: ED99 EB                     EX     DE,HL                ; Put last Map byte into DE         ;
2331: ED9A E1                     POP    HL                   ;
2332: ED9B 23                     INC    HL                   ;
2333: ED9C CD 16 F3               CALL   MultiplyHLby8        ; Blocks if all bits used           ;
2334: ED9F ED 4B A4 F4               LD     BC,(dpbDSM)          ; Actual block max                  ;
2335: EDA3 03                     INC    BC                   ; Now has size of the Map           ;
2336: EDA4 AF                     XOR    A                    ; Clear CY                          ;
2337: EDA5 ED 42                  SBC    HL,BC                ; Extra unused bits                 ;
2338: EDA7 BD                     CP     L                    ;  are there any                    ;
2339: EDA8 28 07                  JR     Z,Mark4Directory     ;
2340: EDAA 45                     LD     B,L                  ; Number of bits to set             ;
2341: EDAB EB                     EX     DE,HL                ; Put last Map byte into HL         ;
2342: EDAC             SetBitLoop:                      ;
2343: EDAC 37                     SCF                         ;
2344: EDAD CB 16                  RL     (HL)                 ; Set LSB                           ;
2345: EDAF 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                ;
2346: EDB1         ;
2347: EDB1             Mark4Directory:                      ;
2348: EDB1         ; Mark the reserved space for the directory                                 ;
2349: EDB1 2A A8 F4               LD     HL,(dpbDABM)         ; Directory block reserved bits     ;
2350: EDB4 EB                     EX     DE,HL                ;
2351: EDB5 2A 9D F4               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector     ;
2352: EDB8 73                     LD     (HL),E               ;
2353: EDB9 23                     INC    HL                   ;
2354: EDBA 72                     LD     (HL),D               ; Put reserved blocks in Vector     ;
2355: EDBB         ; end of Map                                                                ;
2356: EDBB         ; Home disk, and set current track and sector to 00                         ;
2357: EDBB CD ED EE               CALL   Home                 ;
2358: EDBE 2A 91 F4               LD     HL,(caDirMaxValue)   ;
2359: EDC1 36 03                  LD     (HL),3               ;
2360: EDC3 23                     INC    HL                   ;
2361: EDC4 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003      ;
2362: EDC6 CD 40 F1               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)          ;
2363: EDC9         ;
2364: EDC9             InitDisk1:                      ;
2365: EDC9         ; Process the directory                                                     ;
2366: EDC9 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	    ;
2367: EDCB CD 3D F3               CALL   ReadDirectory        ; Get the directory Record          ;
2368: EDCE CD 47 F1               CALL   AtEndOfDirectory     ; Are we Done ?                     ;
2369: EDD1 C8                     RET    Z                    ;  Exit if Yes                      ;
2370: EDD2         ; Not end of directory, valid entry?                                        ;
2371: EDD2 CD 50 F1               CALL   GetCurrentDirectoryRecord ; Calculate location of the element ;
2372: EDD5 3E E5                  LD     A,emptyDir           ;
2373: EDD7 BE                     CP     M                    ; Is it an Empty Dir Entry          ;
2374: EDD8 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                ;
2375: EDDA         ; Not emptyDir, user code the same?                                         ;
2376: EDDA 3A 88 F4               LD     A,(currentUserNumber) ;
2377: EDDD BE                     CP     M                    ;
2378: EDDE 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users  ;
2379: EDE0         ; Same user, check for '$' submit                                           ;
2380: EDE0 23                     INC    HL                   ;
2381: EDE1 7E                     LD     A,(HL)               ;
2382: EDE2 D6 24                  SUB    DOLLAR               ; Is first Char a $                 ;
2383: EDE4 20 04                  JR     NZ,InitDisk2         ;
2384: EDE6         ; dollar file found, mark in exitParameterByte                              ;
2385: EDE6 3D                     DEC    A                    ; Set A to FFH                      ;
2386: EDE7 32 B6 EA               LD     (exitParameterByte),A ; Return it the exit parameter      ;
2387: EDEA             InitDisk2:                      ;
2388: EDEA         ; now scan the disk map for allocated blocks                                ;
2389: EDEA 0E FF                  LD     C,TRUE               ; set to allocated                  ;
2390: EDEC CD 74 F1               CALL   ScanDiskMap          ;
2391: EDEF CD 5E F1               CALL   SetDirectoryEntry    ; Mark directory entry              ;
2392: EDF2 18 D5                  JR     InitDisk1            ; Loop for another entry            ;
2393: EDF4         ;--------------------------- Initialize Disk -------------------------------;
2394: EDF4         ;----------------------------- Open File -----------------------------------;
2395: EDF4         ;search for the directory entry matching FCB at paramDE						;
2396: EDF4             OpenFile:                       ;
2397: EDF4 0E 0F                  LD     C,nameLength         ;
2398: EDF6 CD F6 EF               CALL   SearchForDirectoryRecord ;
2399: EDF9 CD 47 F1               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
2400: EDFC C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
2401: EDFD         ;
2402: EDFD             CopyDirRecordToFCB:                      ;
2403: EDFD CD 90 EF               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
2404: EE00 7E                     LD     A,(HL)               ; Get the EXT                      	;
2405: EE01 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
2406: EE02 E5                     PUSH   HL                   ;  also save FCB's pointer         	;
2407: EE03 CD 50 F1               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
2408: EE06 E5                     PUSH   HL                   ; Save Directory Record address    	;
2409: EE07         ;
2410: EE07 ED 5B B4 EA               LD     DE,(paramDE)         ;
2411: EE0B 01 20 00               LD     BC,fcbLength         ;
2412: EE0E ED B0                  LDIR                        ; Move dir record to FCB           	;
2413: EE10         ;
2414: EE10         ; note that entire fcb is copied, including indicators                    	;
2415: EE10 CD CB EF               CALL   SetFileWriteFlag     ; Set clean file flag				;
2416: EE13 D1                     POP    DE                   ; Get Directory Record address     	;
2417: EE14 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
2418: EE17 19                     ADD    HL,DE                ; Directory's EXT address          	;
2419: EE18 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
2420: EE19 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
2421: EE1C 19                     ADD    HL,DE                ; Directory's RC address           	;
2422: EE1D 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
2423: EE1E E1                     POP    HL                   ; Get FCB's Extent Address         	;
2424: EE1F F1                     POP    AF                   ; Get FCB's Extent Value           	;
2425: EE20 77                     LD     (HL),A               ; Restore Extent Value             	;
2426: EE21         ; if user ext < dir ext then user := 128 records                           	;
2427: EE21         ; if user ext = dir ext then user := dir records                           	;
2428: EE21         ; if user ext > dir ext then user := 0 records                             	;
2429: EE21 79                     LD     A,C                  ; Get the Dir's EXT                	;
2430: EE22 BE                     CP     M                    ; Does it match the FCB'd          	;
2431: EE23 78                     LD     A,B                  ; Get the Dir's  record count      	;
2432: EE24 28 06                  JR     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
2433: EE26 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
2434: EE28 38 02                  JR     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
2435: EE2A 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
2436: EE2C             OpenSetRecordCount:                      ;
2437: EE2C 2A B4 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
2438: EE2F 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
2439: EE32 19                     ADD    HL,DE                ; FCB's record count               	;
2440: EE33 77                     LD     (HL),A               ; Set the value                    	;
2441: EE34 C9                     RET                         ;
2442: EE35         ;----------------------------- Open File -----------------------------------;
2443: EE35         ;---------------------------- Close Directory Entry ------------------------;
2444: EE35             CloseDirEntry:                      ;
2445: EE35 AF                     XOR    A                    ;
2446: EE36 32 B6 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
2447: EE39 CD 35 EF               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
2448: EE3C C0                     RET    NZ                   ; Skip close if r/o disk            ;
2449: EE3D         ; check file write flag - 0 indicates written                               ;
2450: EE3D         ;
2451: EE3D DD E5                  PUSH   IX                   ;
2452: EE3F DD 2A B4 EA               LD     IX,(paramDE)         ; FCB address                       ;
2453: EE43 DD CB 0E 7E               BIT    7,(IX+fcbS2Index)    ; Has WFF changed ?	                ;
2454: EE47 DD E1                  POP    IX                   ;
2455: EE49 C0                     RET    NZ                   ; Skip close if clean file          ;
2456: EE4A         ;
2457: EE4A         ;	CALL	GetWriteFileFlagValue		; Get file's WriteFileFlag          ;
2458: EE4A         ;	BIT		7,A							;  Has it changed ?					;
2459: EE4A         ;	RET		NZ							; Skip close if clean file          ;
2460: EE4A         ;
2461: EE4A 0E 0F                  LD     C,nameLength         ;
2462: EE4C CD F6 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
2463: EE4F CD 47 F1               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
2464: EE52 C8                     RET    Z                    ;  exit if at EOD                   ;
2465: EE53         ;
2466: EE53         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
2467: EE53 CD 50 F1               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
2468: EE56 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
2469: EE59 09                     ADD    HL,BC                ;
2470: EE5A EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
2471: EE5B 2A B4 EA               LD     HL,(paramDE)         ;
2472: EE5E 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
2473: EE5F 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
2474: EE61         ;
2475: EE61             MergeAllocationMaps:                      ;
2476: EE61 3A B8 F4               LD     A,(byteAllocationFlag) ;
2477: EE64 B7                     OR     A                    ;
2478: EE65 28 10                  JR     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2479: EE67         ; process byte size Map	                                                    ;
2480: EE67 7E                     LD     A,(HL)               ; FCB Block number                  ;
2481: EE68 B7                     OR     A                    ; Is it 0 ?                         ;
2482: EE69 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2483: EE6A 20 01                  JR     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2484: EE6C 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2485: EE6D             MergeFCBisNot0:                      ;
2486: EE6D B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2487: EE6E 20 02                  JR     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2488: EE70 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2489: EE71 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2490: EE72             MergeDirEntryNot0:                      ;
2491: EE72 BE                     CP     M                    ; Do FCB and Dir match values       ;
2492: EE73 20 39                  JR     NZ,CloseDirEntryError ;  If not then report error         ;
2493: EE75 18 13                  JR     MergeMapLoop         ; Go see if there is more           ;
2494: EE77         ;
2495: EE77             MergeWordMaps:                      ;
2496: EE77 CD 20 F3               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2497: EE7A EB                     EX     DE,HL                ;
2498: EE7B CD 20 F3               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2499: EE7E EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2500: EE7F 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2501: EE80 BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2502: EE81 20 2B                  JR     NZ,CloseDirEntryError ;  If not then report error         ;
2503: EE83 13                     INC    DE                   ;
2504: EE84 23                     INC    HL                   ; move on to the MSB                ;
2505: EE85 1A                     LD     A,(DE)               ;
2506: EE86 BE                     CP     M                    ; do the check for equality         ;
2507: EE87 20 25                  JR     NZ,CloseDirEntryError ;  If not then report error         ;
2508: EE89 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2509: EE8A             MergeMapLoop:                      ;
2510: EE8A 13                     INC    DE                   ; Advance to the next positions     ;
2511: EE8B 23                     INC    HL                   ; in The Maps                       ;
2512: EE8C 0D                     DEC    C                    ; Are we done ?                     ;
2513: EE8D 20 D2                  JR     NZ,MergeAllocationMaps ;  No, do it again                  ;
2514: EE8F         ;
2515: EE8F         ; Check the EXT                                                             ;
2516: EE8F 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2517: EE92 09                     ADD    HL,BC                ;
2518: EE93 EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2519: EE94 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2520: EE95 1A                     LD     A,(DE)               ; FCB's extent number               ;
2521: EE96 BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2522: EE97 38 09                  JR     C,CloseDirEntryEnd   ;  we are done if yes               ;
2523: EE99 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2524: EE9A         ; Update directory record count field                                       ;
2525: EE9A 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2526: EE9D 09                     ADD    HL,BC                ;
2527: EE9E EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2528: EE9F 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2529: EEA0 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2530: EEA1 12                     LD     (DE),A               ;  the Directory Record RC          ;
2531: EEA2         ;
2532: EEA2             CloseDirEntryEnd:                      ;
2533: EEA2 3E FF                  LD     A,TRUE               ;
2534: EEA4 32 B1 F4               LD     (fcbCopiedFlag),A    ; Set copied flag as true           ;
2535: EEA7         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2536: EEA7 CD 6B F3               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2537: EEAA C3 69 F0               JP     WriteDir             ; Write the directory element       ;
2538: EEAD C9                     RET                         ;
2539: EEAE         ;
2540: EEAE             CloseDirEntryError:                      ;
2541: EEAE 21 B6 EA               LD     HL,exitParameterByte ;
2542: EEB1 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2543: EEB2 C9                     RET                         ;
2544: EEB3         ;---------------------------- Close Directory Entry ------------------------;
2545: EEB3         ;----------------------------------- Make new File -------------------------;
2546: EEB3         ;create a new file by creating a directory entry then opening the file      ;
2547: EEB3             MakeNewFile:                      ;
2548: EEB3 CD 29 F2               CALL   CheckWrite           ; Terminate with error if Disk R/O  ;
2549: EEB6 2A B4 EA               LD     HL,(paramDE)         ; Get the FCB                       ;
2550: EEB9 E5                     PUSH   HL                   ; FCB                               ;
2551: EEBA 21 8A F4               LD     HL,emptyFCB          ;
2552: EEBD 22 B4 EA               LD     (paramDE),HL         ; Find the first empty dir record   ;
2553: EEC0 0E 01                  LD     C,1                  ;
2554: EEC2 CD F6 EF               CALL   SearchForDirectoryRecord ; 0F5H in first position            ;
2555: EEC5 CD 47 F1               CALL   AtEndOfDirectory     ; Check if at end of directory      ;
2556: EEC8 E1                     POP    HL                   ; Recall the FCB pointer            ;
2557: EEC9 22 B4 EA               LD     (paramDE),HL         ;  in case we return here           ;
2558: EECC C8                     RET    Z                    ; Exit with No Dir space error      ;
2559: EECD         ; fill Allocation Map with Zeros	                                        ;
2560: EECD 11 0F 00               LD     DE,nameLength        ;
2561: EED0 19                     ADD    HL,DE                ; Start of fill                     ;
2562: EED1 36 00                  LD     (HL),00              ; Prime the values                  ;
2563: EED3 E5                     PUSH   HL                   ;
2564: EED4 D1                     POP    DE                   ; Copy to DE                        ;
2565: EED5 13                     INC    DE                   ; adjust the to pointer             ;
2566: EED6 01 10 00               LD     BC,fcbLength-nameLength-1 ; number of bytes to fill           ;
2567: EED9 ED B0                  LDIR                        ;
2568: EEDB         ;
2569: EEDB 2A B4 EA               LD     HL,(paramDE)         ; get FCB                           ;
2570: EEDE 11 0D 00               LD     DE,fcbS1Index        ; Get the S1 index                  ;
2571: EEE1 19                     ADD    HL,DE                ; Point to S1                       ;
2572: EEE2 36 00                  LD     (HL),0               ; Set to 0                          ;
2573: EEE4 CD 5E F1               CALL   SetDirectoryEntry    ; Update directory entry            ;
2574: EEE7 CD 3D F2               CALL   CopyFCB              ; Update dir entry to Disk          ;
2575: EEEA         ; and set the file write flag to "1"                                        ;
2576: EEEA C3 CB EF               JP     SetFileWriteFlag     ; Set the clean entry flag          ;
2577: EEED         ;----------------------------------- Make new File -------------------------;
2578: EEED
2579: EEED         ;=========================== Disk Utilities ================================;
2580: EEED
2581: EEED         ;--------------------------- Home The Current Disk -------------------------;
2582: EEED         ;move to home position, then offset to start of dir                         ;
2583: EEED             Home:                           ;
2584: EEED CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks       ;
2585: EEF0         ; if Buffer needs to be written     ;
2586: EEF0 21 AC F4               LD     HL,dpbOFF            ; Number of tracks before directory ;
2587: EEF3 4E                     LD     C,(HL)               ;
2588: EEF4 23                     INC    HL                   ;
2589: EEF5 46                     LD     B,(HL)               ;
2590: EEF6 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position   ;
2591: EEF9         ;
2592: EEF9         ; Set Current Track and Sector to 00                                        ;
2593: EEF9 AF                     XOR    A                    ; set ACC to 00                     ;
2594: EEFA 2A 93 F4               LD     HL,(caTrack)         ;
2595: EEFD 77                     LD     (HL),A               ;
2596: EEFE 23                     INC    HL                   ;
2597: EEFF 77                     LD     (HL),A               ;
2598: EF00 2A 95 F4               LD     HL,(caSector)        ;
2599: EF03 77                     LD     (HL),A               ;
2600: EF04 23                     INC    HL                   ;
2601: EF05 77                     LD     (HL),A               ;
2602: EF06 C9                     RET                         ;
2603: EF07         ;
2604: EF07         ;--------------------------- Home The Current Disk -------------------------;
2605: EF07         ;--------------------------- Set DMAs --------------------------------------;
2606: EF07             SetDataDMA:                      ;
2607: EF07 21 8F F4               LD     HL,initDAMAddress    ;
2608: EF0A 18 03                  JR     SetDMA               ; Skip to complete the call         ;
2609: EF0C         ;
2610: EF0C             SetDirDMA:                      ;
2611: EF0C 21 97 F4               LD     HL,caDirectoryDMA    ; Load current directory Buffer     ;
2612: EF0F         ;
2613: EF0F             SetDMA:                         ;
2614: EF0F 4E                     LD     C,(HL)               ;
2615: EF10 23                     INC    HL                   ;
2616: EF11 46                     LD     B,(HL)               ; parameter ready               ;
2617: EF12 C3 24 F6               JP     bcSetdma             ; call bios to set              ;
2618: EF15         ;--------------------------- Set DMAs --------------------------------------;
2619: EF15         ;--------------------------- Read Buffer -----------------------------------;
2620: EF15         ;reads into current DMA, using current Disk,Track and Sector                ;
2621: EF15             ReadBuffer:                      ;
2622: EF15 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level     ;
2623: EF18 B7                     OR     A                    ; Check status                      ;
2624: EF19 C2 29 F4               JP     NZ,Error_BadSector   ; Report if Status not OK		;
2625: EF1C C9                     RET                         ;
2626: EF1D         ;--------------------------- Read Buffer -----------------------------------;
2627: EF1D         ;--------------------------- Set Current Disk Read Only --------------------;
2628: EF1D         ;set current disk to read only                                              ;
2629: EF1D             SetDiskReadOnly:                      ;
2630: EF1D 2A 8B F4               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2631: EF20         ;
2632: EF20 3A 89 F4               LD     A,(currentDisk)      ; Get the current disk              ;
2633: EF23 47                     LD     B,A                  ; Move into B                       ;
2634: EF24 CD F9 F3               CALL   SetVectorBit         ; Set the bit	                    ;
2635: EF27 22 8B F4               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2636: EF2A         ;
2637: EF2A 2A A6 F4               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2638: EF2D EB                     EX     DE,HL                ;
2639: EF2E 2A 91 F4               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2640: EF31 73                     LD     (HL),E               ;
2641: EF32 23                     INC    HL                   ;
2642: EF33 72                     LD     (HL),D               ;
2643: EF34 C9                     RET                         ;
2644: EF35         ;--------------------------- Set disk Read Only ----------------------------;
2645: EF35         ;--------------------------- Is Disk Write Protected -----------------------;
2646: EF35         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2647: EF35         ;					= reset if Write Protected		(NZ)					;
2648: EF35             IsDiskWriteProtected:                      ;
2649: EF35 2A 8B F4               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2650: EF38 3A 89 F4               LD     A,(currentDisk)      ; Get current disk                  ;
2651: EF3B 47                     LD     B,A                  ;
2652: EF3C CD E9 F3               CALL   IsBitSet             ; Check the bit                     ;
2653: EF3F C9                     RET                         ; NZ if Disk is RO                  ;
2654: EF40         ;--------------------------- Is Disk Write Protected -----------------------;
2655: EF40
2656: EF40         ;------------------------- Reselect Disk if Necessary ----------------------;
2657: EF40         ;check current fcb to see if reselection necessary                         ;
2658: EF40             ReselectDisk:                      ;
2659: EF40 3E FF                  LD     A,TRUE               ;
2660: EF42 32 B9 F4               LD     (fResel),A           ; Mark as possible reselect         ;
2661: EF45 2A B4 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2662: EF48 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2663: EF49 E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2664: EF4B 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2665: EF4C 32 B3 EA               LD     (paramE),A           ; Save drive code                   ;
2666: EF4F FE 1E                  CP     30                   ;
2667: EF51 30 10                  JR     NC,NoSelect          ; Skip drive >= 30                  ;
2668: EF53         ;
2669: EF53 3A 89 F4               LD     A,(currentDisk)      ; Determine the current drive       ;
2670: EF56 32 BA F4               LD     (entryDisk),A        ; Save it                           ;
2671: EF59 7E                     LD     A,(HL)               ;
2672: EF5A 32 BB F4               LD     (fcbDisk),A          ; Get calling disk                  ;
2673: EF5D E6 E0                  AND    11100000B            ;
2674: EF5F 77                     LD     (HL),A               ; Preserve User Number              ;
2675: EF60 CD 12 ED               CALL   SelectCurrent        ; Select the new disk               ;
2676: EF63         ;
2677: EF63             NoSelect:                       ;
2678: EF63 3A 88 F4               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2679: EF66 2A B4 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2680: EF69 B6                     OR     M                    ; Combine                           ;
2681: EF6A 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2682: EF6B C9                     RET                         ;
2683: EF6C         ;------------------------- Reselect Disk if Necessary ----------------------;
2684: EF6C
2685: EF6C
2686: EF6C         ;=========================== Disk Utilities ================================;
2687: EF6C
2688: EF6C         ;=========================== File Utilities ================================;
2689: EF6C         ;--------------------------- Set Record Variables --------------------------;
2690: EF6C         ;set variables from currently FCB - Current Record, RC, EXM                 ;
2691: EF6C             SetRecordVars:                      ;
2692: EF6C CD 83 EF               CALL   GetFcbRecordDetails  ; DE = .RecordCount                 ;
2693: EF6F         ;  and HL => .CurrentRecord         ;
2694: EF6F 7E                     LD     A,(HL)               ;
2695: EF70 32 BE F4               LD     (currentFileRecord),A ; Save current record               ;
2696: EF73 EB                     EX     DE,HL                ;
2697: EF74 7E                     LD     A,(HL)               ;
2698: EF75 32 BC F4               LD     (fcbRecordCount),A   ; Save the FCBs RC                  ;
2699: EF78 CD 90 EF               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)              ;
2700: EF7B 3A A3 F4               LD     A,(dpbEXM)           ; Extent mask                       ;
2701: EF7E A6                     AND    M                    ; Remove unwanted bits              ;
2702: EF7F 32 BD F4               LD     (extentValue),A      ; Store the value                   ;
2703: EF82 C9                     RET                         ;
2704: EF83         ;--------------------------- Set Record Variables --------------------------;
2705: EF83         ;----------------------Get File Record Count and Current Record-------------;
2706: EF83         ; returns with DE pointing at RC from FCB                                   ;
2707: EF83         ;         with HL pointing at Current Record                                ;
2708: EF83             GetFcbRecordDetails:                      ;
2709: EF83 2A B4 EA               LD     HL,(paramDE)         ; Get FCB start                     ;
2710: EF86 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count            ;
2711: EF89 19                     ADD    HL,DE                ;
2712: EF8A EB                     EX     DE,HL                ; DE Points to Record Count         ;
2713: EF8B 21 11 00               LD     HL,recordSeq-fcbRCIndex ;
2714: EF8E 19                     ADD    HL,DE                ; HL Points to Current Record       ;
2715: EF8F C9                     RET                         ;
2716: EF90         ;----------------------Get File Record Count and Current Record-------------;
2717: EF90         ;----------------------Get FileExtent---------------------------------------;
2718: EF90         ;get current extent field address to (HL)                                  ;
2719: EF90             GetExtentAddress:                      ;
2720: EF90 2A B4 EA               LD     HL,(paramDE)         ; Get FCB                           ;
2721: EF93 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                    ;
2722: EF96 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)              ;
2723: EF97 C9                     RET                         ;
2724: EF98         ;----------------------Get FileExtent---------------------------------------;
2725: EF98         ;--------------------- Set/Reset Disk Map Allocation Bit -------------------;
2726: EF98         ; At Entry:	BC Contains to the Block to be modified                         ;
2727: EF98         ;			E  = TRUE if bit is to be set                                   ;
2728: EF98         ;			E  <> TRUE if bit is to be reset                                ;
2729: EF98         ; At Exit:  The target bit in the target Octet will be set/reset	        ;
2730: EF98             SetResetMapBit:                      ;
2731: EF98         ;
2732: EF98 21 00 00               LD     HL,0000H             ; Move the block number from BC     ;
2733: EF9B 09                     ADD    HL,BC                ;  to HL                            ;
2734: EF9C 4B                     LD     C,E                  ; Move the flag to E                ;
2735: EF9D         ;
2736: EF9D 7D                     LD     A,L                  ; LSB of the Block Number           ;
2737: EF9E E6 07                  AND    07H                  ; Calculate Mod(Block,8)            ;
2738: EFA0 F5                     PUSH   AF                   ; Save the OctetBit                 ;
2739: EFA1 06 03                  LD     B,3                  ;
2740: EFA3 CD 0E F3               CALL   ShiftRightHLbyB      ; Calculate Block / 8               ;
2741: EFA6 ED 5B 9D F4               LD     DE,(caAllocVector)   ; Start Of Map                      ;
2742: EFAA 19                     ADD    HL,DE                ; Address of targeted Octet         ;
2743: EFAB F1                     POP    AF                   ;
2744: EFAC 47                     LD     B,A                  ; Get the bit                       ;
2745: EFAD         ;
2746: EFAD 04                     INC    B                    ; Adjust for looping                ;
2747: EFAE C5                     PUSH   BC                   ; Will need this later              ;
2748: EFAF             Left:                           ;
2749: EFAF CB 16                  RL     (HL)                 ; Rotate the Octet                  ;
2750: EFB1 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0      ;
2751: EFB3 C1                     POP    BC                   ; Restore loop limit and            ;
2752: EFB4 37                     SCF                         ;  set/reset flag                   ;
2753: EFB5 0C                     INC    C                    ; was C = TRUE                      ;
2754: EFB6 28 01                  JR     Z,Right              ; Skip if Set                       ;
2755: EFB8 3F                     CCF                         ; Set for Reset                     ;
2756: EFB9             Right:                          ;
2757: EFB9 CB 1E                  RR     (HL)                 ; Move the Octet back               ;
2758: EFBB 10 FC                  DJNZ   Right                ;  to its original alignment        ;
2759: EFBD C9                     RET                         ;
2760: EFBE         ;--------------------- Set/Reset Disk Map Allocation Bit -------------------;
2761: EFBE         ;--------------------- Initialize Extent Number MSB ------------------------;
2762: EFBE         ;clear the Extent number field for user open/make (S2)                     ;
2763: EFBE             InitializeExtentNumberMSB:                      ;
2764: EFBE DD E5                  PUSH   IX                   ;
2765: EFC0 DD 2A B4 EA               LD     IX,(paramDE)         ; FCB address                       ;
2766: EFC4 DD 36 0E 00               LD     (IX+fcbS2Index),0    ; Clear value                       ;
2767: EFC8 DD E1                  POP    IX                   ;
2768: EFCA C9                     RET                         ;
2769: EFCB         ;
2770: EFCB         ;--------------------- Initialize Extent Number MSB ------------------------;
2771: EFCB         ;--------------------------- Set File Write Flag----------------------------;
2772: EFCB         ;Set file write flag in FCB in (paramDE)									;
2773: EFCB         ; Used to indicate the FCB is clean. No need to write on close				;
2774: EFCB             SetFileWriteFlag:                      ;
2775: EFCB DD E5                  PUSH   IX                   ;
2776: EFCD DD 2A B4 EA               LD     IX,(paramDE)         ; FCB address                       ;
2777: EFD1 DD CB 0E FE               SET    7,(IX+fcbS2Index)    ; Set Flag                          ;
2778: EFD5 DD E1                  POP    IX                   ;
2779: EFD7 C9                     RET                         ;
2780: EFD8         ;
2781: EFD8         ;--------------------------- Set File Write Flag----------------------------;
2782: EFD8         ;--------------------------- Reset File Write Flag--------------------------;
2783: EFD8         ;Reset file write flag in FCB in (paramDE)									;
2784: EFD8         ; Used to indicate the FCB is dirty. Need to write on close					;
2785: EFD8             ResetFileWriteFlag:                      ;
2786: EFD8 DD E5                  PUSH   IX                   ;
2787: EFDA DD 2A B4 EA               LD     IX,(paramDE)         ; FCB address                       ;
2788: EFDE DD CB 0E BE               RES    7,(IX+fcbS2Index)    ; Reset Flag                        ;
2789: EFE2 DD E1                  POP    IX                   ;
2790: EFE4 C9                     RET                         ;
2791: EFE5         ;--------------------------- Reset File Write Flag--------------------------;
2792: EFE5         ;-------------------------- Compare FCB Extents ----------------------------;
2793: EFE5         ; Enters:	A containing Target FCB EXT value								;
2794: EFE5         ;			HL Points at Possible FCB EXT value								;
2795: EFE5         ;compare extent# in A with that in C, return nonzero if they do not match	;
2796: EFE5             CompareExtents:                      ;
2797: EFE5 C5                     PUSH   BC                   ; Save Callers Registers			;
2798: EFE6 F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2799: EFE7 3A A3 F4               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2800: EFEA 2F                     CPL                         ; Complement for And           		;
2801: EFEB 47                     LD     B,A                  ; Put negated Mask into B      		;
2802: EFEC 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2803: EFED A0                     AND    B                    ; Apply the Mask               		;
2804: EFEE 4F                     LD     C,A                  ; Low bits removed from C      		;
2805: EFEF F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2806: EFF0 A0                     AND    B                    ; Apply the Mask               		;
2807: EFF1 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2808: EFF2 E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2809: EFF4 C1                     POP    BC                   ; Restore Callers Registers    		;
2810: EFF5 C9                     RET                         ;
2811: EFF6         ;-------------------------- Compare FCB Extents ----------------------------;
2812: EFF6         ;---------------------Search for Directory Record --------------------------;
2813: EFF6         ;  Search for directory record of length C.									;
2814: EFF6         ; Target is pointed to by paramDE. The whole directory is searched.			;
2815: EFF6         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2816: EFF6         ; matched directory record													;
2817: EFF6         ; Entry:	C = Search Length                                               ;
2818: EFF6         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2819: EFF6         ;								-1 (EOD) if there is no match				;
2820: EFF6             SearchForDirectoryRecord:                      ;
2821: EFF6 3E FF                  LD     A,0FFH               ;
2822: EFF8 32 B3 F4               LD     (directoryIndex),A   ; Initialize directory Index        ;
2823: EFFB 21 B5 F4               LD     HL,searchLength      ;
2824: EFFE 71                     LD     (HL),C               ; Save Search Length                ;
2825: EFFF 2A B4 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2826: F002 22 B6 F4               LD     (searchAddress),HL   ; Start of search                   ;
2827: F005 CD 40 F1               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2828: F008 CD ED EE               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2829: F00B         ;
2830: F00B             GetNextDirectoryRecord:                      ;
2831: F00B 0E 00                  LD     C,FALSE              ;
2832: F00D CD 3D F3               CALL   ReadDirectory        ; Read next Dir Record              ;
2833: F010 CD 47 F1               CALL   AtEndOfDirectory     ;
2834: F013 28 4B                  JR     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2835: F015         ;
2836: F015 2A B6 F4               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2837: F018 EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2838: F019 1A                     LD     A,(DE)               ; User Number                       ;
2839: F01A FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2840: F01C 28 07                  JR     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2841: F01E         ;
2842: F01E         ; Check to be sure we are sill in the Directory                             ;
2843: F01E D5                     PUSH   DE                   ; Save search address               ;
2844: F01F CD 67 F1               CALL   StillInDirectory     ; Still in the directorY            ;
2845: F022 D1                     POP    DE                   ; Recall address                    ;
2846: F023 30 3B                  JR     NC,NoDirRecordsMatch ; Get out if past directory			;
2847: F025         ;
2848: F025             GetNextDirectoryRecord1:                      ;
2849: F025 CD 50 F1               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2850: F028 3A B5 F4               LD     A,(searchLength)     ;
2851: F02B 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2852: F02C 06 00                  LD     B,0                  ; Character Index (up)              ;
2853: F02E         ;
2854: F02E             TestNextPosition:                      ;
2855: F02E 1A                     LD     A,(DE)               ;
2856: F02F FE 3F                  CP     QMARK                ; ? is always a char match          ;
2857: F031 28 16                  JR     Z,SetNextPosition    ; Done with this if it is ?		;
2858: F033         ;
2859: F033 78                     LD     A,B                  ;
2860: F034 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2861: F036 28 11                  JR     Z,SetNextPosition    ; Done with this if it is ?		;
2862: F038         ; not the fcbS1Index field, extent field?                                  ;
2863: F038 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2864: F03A 1A                     LD     A,(DE)               ; Get next character                ;
2865: F03B 28 07                  JR     Z,CheckExtents       ; Skip to search extent             ;
2866: F03D 96                     SUB    M                    ; Do they match ?                   ;
2867: F03E E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2868: F040 20 C9                  JR     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2869: F042 18 05                  JR     SetNextPosition      ; Matched the character             ;
2870: F044         ;                                                                           ;
2871: F044             CheckExtents:                      ;
2872: F044 CD E5 EF               CALL   CompareExtents       ; Matching EXTs is work             ;
2873: F047 20 C2                  JR     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2874: F049         ;
2875: F049             SetNextPosition:                      ;
2876: F049 13                     INC    DE                   ; Pointer to Looking FOR            ;
2877: F04A 23                     INC    HL                   ; Pointer to Looking IN             ;
2878: F04B 04                     INC    B                    ; Character Index in FCB            ;
2879: F04C 0D                     DEC    C                    ; Length of search                  ;
2880: F04D 20 DF                  JR     NZ,TestNextPosition  ;
2881: F04F         ; Match Found, entire name matches                                          ;
2882: F04F 3A C3 F4               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2883: F052 E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2884: F054 32 B6 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2885: F057         ;
2886: F057 21 B3 F4               LD     HL,directoryIndex    ; Point at Directory Flag           ;
2887: F05A 7E                     LD     A,(HL)               ; Get value                         ;
2888: F05B 17                     RLA                         ; Set Carry if Flag = -1            ;
2889: F05C D0                     RET    NC                   ; Return with flag still -1         ;
2890: F05D         ;
2891: F05D AF                     XOR    A                    ; Else Clear the flag               ;
2892: F05E 77                     LD     (HL),A               ;
2893: F05F C9                     RET                         ;  and exit                         ;
2894: F060         ;------                                                                     ;
2895: F060             NoDirRecordsMatch:                      ;
2896: F060 CD 40 F1               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2897: F063 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2898: F065 32 B6 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2899: F068 C9                     RET                         ;
2900: F069         ;---------------------Search for Directory Record --------------------------;
2901: F069         ;---------------------------- Write Current Directory Entry ----------------;
2902: F069             WriteDir:                       ;
2903: F069         ;	CALL	NewCheckSum						; initialize entry              ;
2904: F069 0E FF                  LD     C,TRUE               ;
2905: F06B CD BA F3               CALL   CheckSumUtility      ; Set New CheckSum              ;
2906: F06E         ;
2907: F06E CD 0C EF               CALL   SetDirDMA            ; Directory DMA                 ;
2908: F071 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
2909: F073 CD 79 F0               CALL   WriteBuffer          ; Write the buffer              ;
2910: F076 C3 07 EF               JP     SetDataDMA           ; Reset DMA to default			;
2911: F079         ;
2912: F079         ;---------------------------- Write Current Directory Entry ----------------;
2913: F079         ;----------------------------------- Write Buffer --------------------------;
2914: F079         ; Write buffer and check result. Current drive,Track, Sector and DMA		;
2915: F079         ; Are set up prior to calling this routine                                  ;
2916: F079         ;                                                                           ;
2917: F079         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
2918: F079         ;				1 => directory write operation	WriteDirectory              ;
2919: F079         ;				2 => start of new block			WriteCleanBuffer			;
2920: F079             WriteBuffer:                      ;
2921: F079 CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
2922: F07C B7                     OR     A                    ; Get return code                   ;
2923: F07D C2 29 F4               JP     NZ,Error_BadSector   ; Error if not 00                   ;
2924: F080 C9                     RET                         ;
2925: F081         ;----------------------------------- Write Buffer --------------------------;
2926: F081         ;---------------------------- Update Record Vars ---------------------------;
2927: F081         ;update variables from I/O in  FCB                                          ;
2928: F081             UpdateRecordVariables:                      ;
2929: F081 CD 83 EF               CALL   GetFcbRecordDetails  ; DE => FCB RC, HL => CurrentRecord ;
2930: F084 3A AE F4               LD     A,(diskAccessType)   ; If Seq IO it is set to 1			;
2931: F087 4F                     LD     C,A                  ;  and move it to C                 ;
2932: F088 3A BE F4               LD     A,(currentFileRecord) ; Get NEXT_RECORD                   ;
2933: F08B 81                     ADD    A,C                  ; Update record count               ;
2934: F08C 77                     LD     (HL),A               ;  for CurrentRecord                ;
2935: F08D EB                     EX     DE,HL                ;
2936: F08E 3A BC F4               LD     A,(fcbRecordCount)   ;
2937: F091 77                     LD     (HL),A               ;  and FCB RC                       ;
2938: F092 C9                     RET                         ;
2939: F093         ;---------------------------- Update Record Vars ---------------------------;
2940: F093         ;-------------------------------- Random Seek ------------------------------;
2941: F093         ;  Record # = |000M EEEE| |ERRR RRRR|                                       ;
2942: F093         ;		M => Module                                                         ;
2943: F093         ;		E => Extent                                                         ;
2944: F093         ;		R => Record in Extent                                               ;
2945: F093             RandomSeek:                      ;
2946: F093 AF                     XOR    A                    ;
2947: F094 32 AE F4               LD     (diskAccessType),A   ; Set random access                 ;
2948: F097 C5                     PUSH   BC                   ; Save Read(TRUE) / Write (FALSE)   ;
2949: F098 DD 2A B4 EA               LD     IX,(paramDE)         ; Get the FCB						;
2950: F09C DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record        ;
2951: F09F E6 7F                  AND    7FH                  ; Strip E , left with |0RRR RRRR|   ;
2952: F0A1 F5                     PUSH   AF                   ; recordSEQ                         ;
2953: F0A2 DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record        ;
2954: F0A5 17                     RLA                         ; CY = bit 7 from LSB (M's LSBit)   ;
2955: F0A6 DD 7E 22               LD     A,(IX+recordRandomMSB) ; Get MSB from Random Record        ;
2956: F0A9 F5                     PUSH   AF                   ; Random record's MSB               ;
2957: F0AA 17                     RLA                         ; Shift LSBit into E |00ME EEEE|    ;
2958: F0AB E6 1F                  AND    01FH                 ; Extent mask                       ;
2959: F0AD 4F                     LD     C,A                  ; Extent is in C                    ;
2960: F0AE F1                     POP    AF                   ; Random record's MSB               ;
2961: F0AF 1F                     RRA                         ;
2962: F0B0 1F                     RRA                         ;
2963: F0B1 1F                     RRA                         ;
2964: F0B2 1F                     RRA                         ; MSB's Hi Nibble                   ;
2965: F0B3 E6 0F                  AND    00FH                 ;  moved to Lo Nibble               ;
2966: F0B5 47                     LD     B,A                  ; S2' value in B                    ;
2967: F0B6 F1                     POP    AF                   ; recordSEQ                         ;
2968: F0B7         ;
2969: F0B7 DD 6E 23               LD     L,(IX+recordRandomOVF) ;
2970: F0BA 2C                     INC    L                    ; Insure that high byte             ;
2971: F0BB 2D                     DEC    L                    ;  of ran rec = 00                  ;
2972: F0BC 2E 06                  LD     L,06                 ; "attempt to read beyond end of disk"  ;
2973: F0BE 20 4B                  JR     NZ,RandomSeekError   ;
2974: F0C0         ;
2975: F0C0 DD 77 20               LD     (IX+recordSeq),A     ; Put target record # in FCB	    ;
2976: F0C3 DD 7E 0C               LD     A,(IX+fcbExtIndex)   ; Target EXT in A, FCB EXT in C     ;
2977: F0C6 B9                     CP     C                    ; Are we in the right directory ?	;
2978: F0C7 20 08                  JR     NZ,RandomSeekClose   ;  Skip if not                      ;
2979: F0C9         ;
2980: F0C9 DD 7E 0E               LD     A,(IX+fcbS2Index)    ; Target S2 in A, FCB S2 in C       ;
2981: F0CC B8                     CP     B                    ; Still in the right directory ?    ;
2982: F0CD E6 7F                  AND    7FH                  ; Mask out MSBit                    ;
2983: F0CF 28 30                  JR     Z,RandomSeekExit     ;  Exit if yes                      ;
2984: F0D1         ;
2985: F0D1             RandomSeekClose:                      ;
2986: F0D1 C5                     PUSH   BC                   ; Save EXT                          ;
2987: F0D2 D5                     PUSH   DE                   ; Save FCB                          ;
2988: F0D3 CD 35 EE               CALL   CloseDirEntry        ; Close this directory entry        ;
2989: F0D6 D1                     POP    DE                   ; FCB                               ;
2990: F0D7 C1                     POP    BC                   ; EXT                               ;
2991: F0D8 2E 03                  LD     L,03                 ; "CP/M could not close current extent" ;
2992: F0DA 3A B6 EA               LD     A,(exitParameterByte) ; Get result from Close             ;
2993: F0DD 3C                     INC    A                    ;
2994: F0DE 28 27                  JR     Z,RandomSeekErrorBadSeek ; Error exit if 0FFH                ;
2995: F0E0         ;
2996: F0E0 DD 71 0C               LD     (IX+fcbExtIndex),C   ; Update FCB Ext value              ;
2997: F0E3 DD 70 0E               LD     (IX+fcbS2Index),B    ; Update FCB S2 value               ;
2998: F0E6 CD F4 ED               CALL   OpenFile             ; Open the targeted Dir entry       ;
2999: F0E9 3A B6 EA               LD     A,(exitParameterByte) ; is the file present?              ;
3000: F0EC 3C                     INC    A                    ;
3001: F0ED 20 12                  JR     NZ,RandomSeekExit    ; Exit if open successful	        ;
3002: F0EF         ; cannot open the file, read mode?                                          ;
3003: F0EF C1                     POP    BC                   ; Get Read/Write flag               ;
3004: F0F0 C5                     PUSH   BC                   ; Read/Write flag                   ;
3005: F0F1 2E 04                  LD     L,04                 ; "attempt to read unwritten extent"    ;
3006: F0F3 0C                     INC    C                    ; Becomes 00 if read operation      ;
3007: F0F4 28 11                  JR     Z,RandomSeekErrorBadSeek ; Error exit if read operation      ;
3008: F0F6         ;
3009: F0F6 CD B3 EE               CALL   MakeNewFile          ; Make Directory Entry              ;
3010: F0F9 2E 05                  LD     L,05                 ; "cannot create new extent"        ;
3011: F0FB 3A B6 EA               LD     A,(exitParameterByte) ; Get result from Make              ;
3012: F0FE 3C                     INC    A                    ;
3013: F0FF 28 06                  JR     Z,RandomSeekErrorBadSeek ;  Exit if failed on Make           ;
3014: F101         ;
3015: F101             RandomSeekExit:                      ;
3016: F101 C1                     POP    BC                   ; Balance Stack                     ;
3017: F102 AF                     XOR    A                    ; Success                           ;
3018: F103 32 B6 EA               LD     (exitParameterByte),A ;
3019: F106 C9                     RET                         ;
3020: F107         ;
3021: F107             RandomSeekErrorBadSeek:                      ;
3022: F107 DD 36 0E C0               LD     (IX+fcbS2Index),0C0H ; Set Write protect & overflow      ;
3023: F10B             RandomSeekError:                      ;
3024: F10B C1                     POP    BC                   ; Balance Stack                     ;
3025: F10C 7D                     LD     A,L                  ; Get error code                    ;
3026: F10D 32 B6 EA               LD     (exitParameterByte),A ;  and return it to caller          ;
3027: F110 C3 CB EF               JP     SetFileWriteFlag     ; Set flag for following close      ;
3028: F113         ;-------------------------------- Random Seek ------------------------------;
3029: F113         ;--------------------------- Get Random Record Position -------------------;?
3030: F113         ; on Entry :                                                               ;?
3031: F113         ;			HL = pointer to directory entry                                ;?
3032: F113         ;			DE = fcbRCIndex/seqRecord index                                ;?
3033: F113             GetRandomRecordPosition:                      ;?
3034: F113 EB                     EX     DE,HL                ; DE = pointer to directory entry  ;?
3035: F114 19                     ADD    HL,DE                ;?
3036: F115         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)               ;?
3037: F115 4E                     LD     C,(HL)               ; C = record count                 ;?
3038: F116 06 00                  LD     B,0                  ; Make count a word value          ;?
3039: F118         ;?
3040: F118 21 0C 00               LD     HL,fcbExtIndex       ; FCB Extent index                 ;?
3041: F11B 19                     ADD    HL,DE                ;?
3042: F11C 7E                     LD     A,(HL)               ; ACC has Extent value             ;?
3043: F11D 0F                     RRCA                        ;?
3044: F11E E6 80                  AND    80H                  ; A=e000 0000                      ;?
3045: F120 81                     ADD    A,C                  ;?
3046: F121 4F                     LD     C,A                  ;?
3047: F122 3E 00                  LD     A,0                  ;?
3048: F124 88                     ADC    A,B                  ;?
3049: F125 47                     LD     B,A                  ;?
3050: F126         ; BC = 0000 000? errrr rrrr                                               ;?
3051: F126 7E                     LD     A,(HL)               ;?
3052: F127 0F                     RRCA                        ;?
3053: F128 E6 0F                  AND    LO_NIBBLE_MASK       ;?
3054: F12A 80                     ADD    A,B                  ;?
3055: F12B 47                     LD     B,A                  ;?
3056: F12C         ; BC = 000? eeee errrr rrrr        ;?
3057: F12C 21 0E 00               LD     HL,fcbS2Index        ;?
3058: F12F 19                     ADD    HL,DE                ;?
3059: F130 7E                     LD     A,(HL)               ; A=XXX? mmmm                      ;?
3060: F131 87                     ADD    A,A                  ;?
3061: F132 87                     ADD    A,A                  ;?
3062: F133 87                     ADD    A,A                  ;?
3063: F134 87                     ADD    A,A                  ; cy=? A=mmmm 0000                 ;?
3064: F135 F5                     PUSH   AF                   ;?
3065: F136 80                     ADD    A,B                  ;?
3066: F137 47                     LD     B,A                  ;?
3067: F138         ; cy=?, BC = mmmm eeee errr rrrr                                          ;?
3068: F138 F5                     PUSH   AF                   ; possible second carry            ;?
3069: F139 E1                     POP    HL                   ; cy = lsb of L                    ;?
3070: F13A 7D                     LD     A,L                  ; cy = lsb of A                    ;?
3071: F13B E1                     POP    HL                   ; cy = lsb of L                    ;?
3072: F13C B5                     OR     L                    ; cy/cy = lsb of A                 ;?
3073: F13D E6 01                  AND    1                    ; A = 0000 000? possible carry-out ;?
3074: F13F C9                     RET                         ;?
3075: F140         ;--------------------------- Get Random Record Position -------------------;?
3076: F140
3077: F140         ;=========================== File Utilities ================================;
3078: F140
3079: F140         ;=========================== Directory Utilities ===========================;
3080: F140         ;--------------------------- Set End of Directory indicator ----------------;
3081: F140             SetEndDirectory:                      ;
3082: F140 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
3083: F143 22 C3 F4               LD     (dirEntryIndex),HL   ;
3084: F146 C9                     RET                         ;
3085: F147         ;--------------------------- Set End of Directory indicator ----------------;
3086: F147         ;--------------------------- Are we at End Of Directory --------------------;
3087: F147         ; Tests to see if we are at the End Of the Directory                        ;
3088: F147         ;                                                                           ;
3089: F147         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
3090: F147         ;			 Z Flag reset if still in directory                             ;
3091: F147         ;
3092: F147             AtEndOfDirectory:                      ;
3093: F147 21 C3 F4               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
3094: F14A 7E                     LD     A,(HL)               ; Get it                            ;
3095: F14B 23                     INC    HL                   ; Point at MSB	of Dir Index		;
3096: F14C BE                     CP     M                    ; LSB = MSB ?                       ;
3097: F14D C0                     RET    NZ                   ;  exit if not if different         ;
3098: F14E         ; Same.  are they = 0ffh?           ;
3099: F14E 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
3100: F14F C9                     RET                         ;
3101: F150         ;--------------------------- Are we at End Of Directory --------------------;
3102: F150         ;--------------------------- Get Directory Element -------------------------;
3103: F150         ; compute the address of a directory element in Directory Buffer            ;
3104: F150         ; Returns:  HL = Address of the specific directory Entry                    ;
3105: F150             GetCurrentDirectoryRecord:                      ;
3106: F150 C5                     PUSH   BC                   ; Save BC                           ;
3107: F151 2A 97 F4               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
3108: F154 3A C2 F4               LD     A,(dirBlockIndex)    ; Get the index value               ;
3109: F157 4F                     LD     C,A                  ;
3110: F158 AF                     XOR    A                    ; Set to Zero and reset CY          ;
3111: F159 47                     LD     B,A                  ;
3112: F15A ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
3113: F15C C1                     POP    BC                   ; Restore	                        ;
3114: F15D C9                     RET                         ;
3115: F15E         ;--------------------------- Get Directory Element -------------------------;
3116: F15E         ;--------------------------- Set Directory Entry ---------------------------;
3117: F15E         ; Will update directory if not in the directory                             ;
3118: F15E         ;
3119: F15E             SetDirectoryEntry:                      ;
3120: F15E CD 67 F1               CALL   StillInDirectory     ;
3121: F161 D8                     RET    C                    ; Exit if still in the Directory  	;
3122: F162         ;
3123: F162         ; StillInDirectory will return with:                                        ;
3124: F162         ;									DE = Directory entry number             ;
3125: F162         ;									HL = Address of entry number + 1        ;
3126: F162 13                     INC    DE                   ;
3127: F163 72                     LD     (HL),D               ;
3128: F164 2B                     DEC    HL                   ;
3129: F165 73                     LD     (HL),E               ;
3130: F166 C9                     RET                         ;
3131: F167         ;--------------------------- Set Directory Entry ---------------------------;
3132: F167         ;--------------------------- Are we sill in the Directory ------------------;
3133: F167         ;Returns	:                                                               ;
3134: F167         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
3135: F167         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
3136: F167         ;			HL = (address of Index Value) + 1                               ;
3137: F167         ;			DE = Directory Index Value                                      ;
3138: F167             StillInDirectory:                      ;
3139: F167 2A C3 F4               LD     HL,(dirEntryIndex)   ;
3140: F16A EB                     EX     DE,HL                ; DE = directory counter            ;
3141: F16B 2A 91 F4               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
3142: F16E 7B                     LD     A,E                  ;
3143: F16F 96                     SUB    M                    ;
3144: F170 23                     INC    HL                   ;
3145: F171 7A                     LD     A,D                  ;
3146: F172 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
3147: F173 C9                     RET                         ;  <= Directory Max Value       ;
3148: F174         ;--------------------------- Are we sill in the Directory ------------------;
3149: F174         ;--------------------------- Scan Disk Map ---------------------------------;
3150: F174         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
3151: F174         ;                                                                           ;
3152: F174         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
3153: F174         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
3154: F174         ;
3155: F174             ScanDiskMap:                      ;
3156: F174 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
3157: F175 CD 50 F1               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
3158: F178 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
3159: F17B 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
3160: F17C 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
3161: F17E         ;
3162: F17E             ScanDiskMap0:                      ;
3163: F17E D1                     POP    DE                   ; Recall the set/reset Info         ;
3164: F17F 0D                     DEC    C                    ;
3165: F180 C8                     RET    Z                    ; Loop once for each disk map entry ;
3166: F181         ;
3167: F181 D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
3168: F182 3A B8 F4               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
3169: F185 B7                     OR     A                    ;
3170: F186 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
3171: F188         ;  Byte Allocation scan operation                                           ;
3172: F188 C5                     PUSH   BC                   ; Save counter                      ;
3173: F189 E5                     PUSH   HL                   ; Save map address                  ;
3174: F18A 4E                     LD     C,(HL)               ;
3175: F18B 06 00                  LD     B,0                  ; BC=block# for Byte                ;
3176: F18D 18 06                  JR     ScanDiskMap2         ;
3177: F18F         ; Word scan operation                                                       ;
3178: F18F             ScanDiskMapWord:                      ;
3179: F18F 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
3180: F190 C5                     PUSH   BC                   ; Save counter                      ;
3181: F191 46                     LD     B,(HL)               ;
3182: F192 23                     INC    HL                   ;
3183: F193 4E                     LD     C,(HL)               ; BC=block# for Word                ;
3184: F194 E5                     PUSH   HL                   ; Save map address                  ;
3185: F195         ;
3186: F195         ; Arrive here with BC=block#, E=0/1	                                        ;
3187: F195             ScanDiskMap2:                      ;
3188: F195 79                     LD     A,C                  ;
3189: F196 B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
3190: F197 C4 98 EF               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
3191: F19A E1                     POP    HL                   ;
3192: F19B 23                     INC    HL                   ; to next bit position              ;
3193: F19C C1                     POP    BC                   ; recall counter                    ;
3194: F19D 18 DF                  JR     ScanDiskMap0         ; for another item                  ;
3195: F19F         ;
3196: F19F         ;--------------------------- Scan Disk Map ---------------------------------;
3197: F19F         ;--------------------------- Get Closest Disk Block ------------------------;
3198: F19F         ; Find the closest available disk block, and mark in Map as allocated       ;
3199: F19F         ; Enter	BC	= Block number to base the search on                            ;
3200: F19F         ; Exit	HL	= 0000 if There are no available open blocks                    ;
3201: F19F         ;			= block number of available and marked block                    ;
3202: F19F         ;
3203: F19F             GetClosestBlock:                      ;
3204: F19F C5                     PUSH   BC                   ; save the starting Block #         ;
3205: F1A0         ;
3206: F1A0 2A A4 F4               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
3207: F1A3 CD 0C F3               CALL   DivideHLby8          ; Length of Map	                    ;
3208: F1A6 EB                     EX     DE,HL                ; put size into DE			        ;
3209: F1A7 E1                     POP    HL                   ; Block number into HL              ;
3210: F1A8 CD 0C F3               CALL   DivideHLby8          ; Length of Map                     ;
3211: F1AB EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
3212: F1AC AF                     XOR    A                    ; Reset CY                          ;
3213: F1AD ED 52                  SBC    HL,DE                ; Size for right                    ;
3214: F1AF         ; DE = Start Index                                                          ;
3215: F1AF         ; DE = Left Size                                                            ;
3216: F1AF         ; HL	= Right Size                                                        ;
3217: F1AF E5                     PUSH   HL                   ; Save right size                   ;
3218: F1B0 D5                     PUSH   DE                   ; Save left size & Start Index      ;
3219: F1B1 3E FF                  LD     A,0FFH               ; Full Octet                        ;
3220: F1B3         ;
3221: F1B3 2A 9D F4               LD     HL,(caAllocVector)   ; Start of Map                      ;
3222: F1B6 19                     ADD    HL,DE                ; Determine initial Octet			;
3223: F1B7         ; Set up Left side                                                          ;
3224: F1B7 C1                     POP    BC                   ; Left size                         ;
3225: F1B8 03                     INC    BC                   ; adjust                            ;
3226: F1B9 E5                     PUSH   HL                   ; Save initial Octet                ;
3227: F1BA 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
3228: F1BD         ; HL = Initial Octet                                                        ;
3229: F1BD         ; BC = Left Size                                                            ;
3230: F1BD D9                     EXX                         ; Use alternate registers           ;
3231: F1BE 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
3232: F1C1 E1                     POP    HL                   ; Get Initial Octet                 ;
3233: F1C2 C1                     POP    BC                   ; Get Right Size                    ;
3234: F1C3 03                     INC    BC                   ; adjust                            ;
3235: F1C4             LookRight:                      ;
3236: F1C4 ED A1                  CPI                         ; UnSet Bit?                        ;
3237: F1C6 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3238: F1C8 E2 E1 F1               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
3239: F1CB         ;
3240: F1CB D9                     EXX                         ; Switch to the Left                ;
3241: F1CC ED A9                  CPD                         ; UnSet Bit?                        ;
3242: F1CE 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3243: F1D0 E2 D6 F1               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
3244: F1D3 D9                     EXX                         ; switch to right                   ;
3245: F1D4 18 EE                  JR     LookRight            ; Keep on looking                   ;
3246: F1D6         ;			----------------			                                    ;
3247: F1D6             NoMoreLeft:                      ;
3248: F1D6 D9                     EXX                         ; Switch to Right                   ;
3249: F1D7             NoMoreLeftLoop:                      ;
3250: F1D7 ED A1                  CPI                         ;
3251: F1D9 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3252: F1DB E2 EC F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
3253: F1DE 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
3254: F1E0 76                     HALT                        ;
3255: F1E1             NoMoreRight:                      ;
3256: F1E1 D9                     EXX                         ; Switch to Left                    ;
3257: F1E2             NoMoreRightLoop:                      ;
3258: F1E2 ED A9                  CPD                         ;
3259: F1E4 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3260: F1E6 E2 EC F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
3261: F1E9 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
3262: F1EB 76                     HALT                        ;
3263: F1EC             NoFreeBlocks:                      ;
3264: F1EC 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
3265: F1EF C9                     RET                         ;
3266: F1F0         ;			----------------			                                    ;
3267: F1F0             FoundFreeOctet:                      ;
3268: F1F0 BB                     CP     E                    ; Left or Right                     ;
3269: F1F1 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
3270: F1F3 2B                     DEC    HL                   ; Adjust for direction              ;
3271: F1F4 18 01                  JR     FoundFreeOctet2      ;
3272: F1F6         ;
3273: F1F6             FoundFreeOctet1:                      ;
3274: F1F6 23                     INC    HL                   ; Adjust for direction              ;
3275: F1F7             FoundFreeOctet2:                      ;
3276: F1F7 01 00 00               LD     BC,00                ; need to keep track of bit         ;
3277: F1FA             FoundFreeOctet3:                      ;
3278: F1FA CB 06                  RLC    (HL)                 ;
3279: F1FC 03                     INC    BC                   ;
3280: F1FD 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
3281: F1FF CB C6                  SET    0,(HL)               ; Make map bit set                  ;
3282: F201 41                     LD     B,C                  ; Put count in B                    ;
3283: F202             FoundFreeOctet4:                      ;
3284: F202 CB 0E                  RRC    (HL)                 ;
3285: F204 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
3286: F206 0B                     DEC    BC                   ; adjust for Zero based value       ;
3287: F207 C5                     PUSH   BC                   ; Save the bit index                ;
3288: F208 ED 4B 9D F4               LD     BC,(caAllocVector)   ; Get Map start                     ;
3289: F20C AF                     XOR    A                    ; Clear CY                          ;
3290: F20D ED 42                  SBC    HL,BC                ; Get how far in the map            ;
3291: F20F CD 16 F3               CALL   MultiplyHLby8        ; Calculate the Octet           ;
3292: F212 C1                     POP    BC                   ; Restore index into Octet          ;
3293: F213 09                     ADD    HL,BC                ; This is the Block Number          ;
3294: F214 C9                     RET                         ;
3295: F215         ;--------------------------- Get Closest Disk Block ------------------------;
3296: F215         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3297: F215             CopyDirEntryToUserDMA:                      ;
3298: F215 2A 97 F4               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer         ;
3299: F218 ED 5B 8F F4               LD     DE,(initDAMAddress)  ; Point at User's Buffer            ;
3300: F21C 01 80 00               LD     BC,cpmRecordSize     ; The entire record                 ;
3301: F21F ED B0                  LDIR                        ; Move it                           ;
3302: F221 C9                     RET                         ;
3303: F222         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3304: F222         ;--------------------- Return last Directory Index to Caller ---------------;
3305: F222             DirLocationToReturnLoc:                      ;
3306: F222 3A B3 F4               LD     A,(directoryIndex)   ; Get last directory Index          ;
3307: F225 32 B6 EA               LD     (exitParameterByte),A ; Save for return to Caller         ;
3308: F228 C9                     RET                         ;
3309: F229         ;--------------------- Return last Directory Index to Caller ---------------;
3310: F229         ;--------------------------- Check OK to Write to Disk ---------------------;
3311: F229             CheckWrite:                      ;
3312: F229 CD 35 EF               CALL   IsDiskWriteProtected ; Is this disk Write Protected?     ;
3313: F22C C8                     RET    Z                    ; OK to write                       ;
3314: F22D C3 1D F4               JP     Error_DiskReadOnly   ; Report read only disk error		;
3315: F230         ;--------------------------- Check OK to Write to Disk ---------------------;
3316: F230         ;--------------------------- Check File Write Protect Status ---------------;
3317: F230             CheckRODirectory:                      ;
3318: F230 CD 50 F1               CALL   GetCurrentDirectoryRecord ; Use Entry in Directory Buffer     ;
3319: F233         ; Use HL as the directory entry in Question                                 ;
3320: F233             CheckROFile:                      ;
3321: F233 11 09 00               LD     DE,fcbROfileIndex    ; Index into FC for RO              ;
3322: F236 19                     ADD    HL,DE                ; point at the byte                 ;
3323: F237 7E                     LD     A,(HL)               ;
3324: F238 17                     RLA                         ; Set CY if RO bit set              ;
3325: F239 D0                     RET    NC                   ; Return OK                         ;
3326: F23A C3 23 F4               JP     Error_FileReadOnly   ; Report to read only File          ;
3327: F23D         ;--------------------------- Check File Write Protect Status ---------------;
3328: F23D         ;------------------------- Copy FCB To Directory record --------------------;
3329: F23D         ; On Entry:                                                                 ;
3330: F23D         ;			C = Starting position                                           ;
3331: F23D         ;			E = length of copy                                              ;
3332: F23D         ;copy the whole file control block                                          ;
3333: F23D             CopyFCB:                        ;
3334: F23D 0E 00                  LD     C,0                  ;
3335: F23F 1E 20                  LD     E,fcbLength          ; Copy all of the FCB		    ;
3336: F241         ; On Entry:                                                                 ;
3337: F241         ;			C = Starting position                                           ;
3338: F241         ;			E = length of copy                                              ;
3339: F241             CopyDir:                        ;
3340: F241 16 00                  LD     D,0                  ; Make length a word value      ;
3341: F243 D5                     PUSH   DE                   ; Length                        ;
3342: F244 06 00                  LD     B,0                  ; Make index a word             ;
3343: F246 2A B4 EA               LD     HL,(paramDE)         ; HL = source for data          ;
3344: F249 09                     ADD    HL,BC                ;
3345: F24A EB                     EX     DE,HL                ;
3346: F24B CD 50 F1               CALL   GetCurrentDirectoryRecord ; HL pointer to Dir Record      ;
3347: F24E EB                     EX     DE,HL                ;
3348: F24F C1                     POP    BC                   ; Length                        ;
3349: F250 ED B0                  LDIR                        ;
3350: F252 CD 6B F3               CALL   SeekDir              ; Seek to the dir entry         ;
3351: F255 C3 69 F0               JP     WriteDir             ; Write the directory element   ;
3352: F258         ;------------------------- Copy FCB from Directory record ------------------;
3353: F258         ;-------------------------------- Get Block Number -------------------------;
3354: F258         ;compute disk block number from current FCB                                ;
3355: F258             GetBlockNumber:                      ;
3356: F258 CD 65 F2               CALL   GetDiskMapIndex      ;Return Alloc block index           ;
3357: F25B 4F                     LD     C,A                  ;
3358: F25C 06 00                  LD     B,0                  ;
3359: F25E CD 72 F2               CALL   GetDiskMapValue      ; Convert to Disk record            ;
3360: F261 22 C0 F4               LD     (absoluteCPMRecord),HL ; Save                              ;
3361: F264 C9                     RET                         ;
3362: F265         ;-------------------------------- Get Block Number -------------------------;
3363: F265         ;-------------------------------- Get Disk Map Index -----------------------;
3364: F265         ;Return the  disk map Index for current File Record in the ACC              ;
3365: F265             GetDiskMapIndex:                      ;
3366: F265 21 A1 F4               LD     HL,dpbBSH            ; Block# = Record# / (2***dpbBSH)   ;
3367: F268 46                     LD     B,(HL)               ; shift count                       ;
3368: F269 3A BE F4               LD     A,(currentFileRecord) ;
3369: F26C             GetDiskMapIndexLoop:                      ;
3370: F26C CB 3F                  SRL    A                    ;
3371: F26E 10 FC                  DJNZ   GetDiskMapIndexLoop  ; Loop till done                    ;
3372: F270 00                     NOP                         ;
3373: F271 C9                     RET                         ;
3374: F272         ;-------------------------------- Get Disk Map Index -----------------------;
3375: F272         ;-------------------------------- Get Disk Map Value -----------------------;
3376: F272         ; Enter with Disk Map Index in BC                                           ;
3377: F272         ; Return disk map value  in HL                                              ;
3378: F272             GetDiskMapValue:                      ;
3379: F272 2A B4 EA               LD     HL,(paramDE)         ; FCB                               ;
3380: F275 11 10 00               LD     DE,fcbDiskMapIndex   ; Index to Allocation Map           ;
3381: F278 19                     ADD    HL,DE                ; Address of Allocation Map Start   ;
3382: F279 09                     ADD    HL,BC                ; Point at the targeted map entry   ;
3383: F27A 3A B8 F4               LD     A,(byteAllocationFlag) ; Is this a byte or word            ;
3384: F27D B7                     OR     A                    ;
3385: F27E 28 04                  JR     Z,GetDiskMap16Bit    ; Skip if word value                ;
3386: F280 6E                     LD     L,(HL)               ;  else its a byte value            ;
3387: F281 26 00                  LD     H,0                  ;load the byte into HL              ;
3388: F283 C9                     RET                         ;
3389: F284         ;
3390: F284             GetDiskMap16Bit:                      ;
3391: F284 09                     ADD    HL,BC                ; make it double width              ;
3392: F285 56                     LD     D,(HL)               ;
3393: F286 23                     INC    HL                   ;
3394: F287 5E                     LD     E,(HL)               ; Load word value into DE           ;
3395: F288 EB                     EX     DE,HL                ; return value in HL                ;
3396: F289 C9                     RET                         ;
3397: F28A         ;-------------------------------- Get Disk Map Value -----------------------;
3398: F28A         ;-------------------------------- Allocate The Block -----------------------;
3399: F28A         ;is  block allocated                                                        ;
3400: F28A             WasBlockAllocated:                      ;
3401: F28A 2A C0 F4               LD     HL,(absoluteCPMRecord) ; Get the Block Number              ;
3402: F28D 7D                     LD     A,L                  ; ZFlag set if                      ;
3403: F28E B4                     OR     H                    ;  absoluteCPMRecord = 0            ;
3404: F28F C9                     RET                         ;
3405: F290         ;-------------------------------- Allocate The Block -----------------------;
3406: F290         ;----------------------------- Set Actual Record Add -----------------------;
3407: F290         ;
3408: F290         ;compute actual record address                                              ;
3409: F290         ; result = absolute CPMRecord * ( 2**BSH)                                  ;
3410: F290             SetActualRecordAdd:                      ;
3411: F290 3A A1 F4               LD     A,(dpbBSH)           ; Block Shift to loop control       ;
3412: F293 47                     LD     B,A                  ;
3413: F294 2A C0 F4               LD     HL,(absoluteCPMRecord) ;
3414: F297         ;
3415: F297             SetActualRecordAddLoop:                      ;
3416: F297 29                     ADD    HL,HL                ;
3417: F298 10 FD                  DJNZ   SetActualRecordAddLoop ;
3418: F29A         ; HL has Record number for start of the block;                              ;
3419: F29A 3A A2 F4               LD     A,(dpbBLM)           ; Get block mask to get current     ;
3420: F29D 4F                     LD     C,A                  ;  File Record mod Block            ;
3421: F29E 3A BE F4               LD     A,(currentFileRecord) ; Get index into block              ;
3422: F2A1 A1                     AND    C                    ; Record index in Block             ;
3423: F2A2 B5                     OR     L                    ;
3424: F2A3 6F                     LD     L,A                  ; to HL                             ;
3425: F2A4 22 C0 F4               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL            ;
3426: F2A7         ; *** Absolute CPM Record now has current record number                     ;
3427: F2A7         ; - Starting record number + index into block                               ;
3428: F2A7 C9                     RET                         ;
3429: F2A8         ;----------------------------- Set Actual Record Add -----------------------;
3430: F2A8         ;-------------------------------- Open Next Extent -------------------------;
3431: F2A8         ;close the current extent  and open the next one if possible.              ;
3432: F2A8         ;readModeFlag is true if in read mode                                      ;
3433: F2A8             OpenNextExt:                      ;
3434: F2A8 AF                     XOR    A                    ; Set to 00                         ;
3435: F2A9 32 B1 F4               LD     (fcbCopiedFlag),A    ; Clear Flag                        ;
3436: F2AC CD 35 EE               CALL   CloseDirEntry        ; Close current extent.             ;
3437: F2AF CD 47 F1               CALL   AtEndOfDirectory     ; Is the directory full?            ;
3438: F2B2 C8                     RET    Z                    ;  exit it yes                      ;
3439: F2B3         ;
3440: F2B3 CD 90 EF               CALL   GetExtentAddress     ; HL at FCB's EXT                   ;
3441: F2B6 7E                     LD     A,(HL)               ; Get previous EXT value            ;
3442: F2B7 3C                     INC    A                    ; Add one to it                     ;
3443: F2B8 E6 1F                  AND    maxExtValue          ; Limit to max value                ;
3444: F2BA 77                     LD     (HL),A               ; Put it back into the FCB          ;
3445: F2BB 28 0D                  JR     Z,OpenNextModule     ;  if = 0, need to open new Module  ;
3446: F2BD         ;
3447: F2BD 47                     LD     B,A                  ; put Ext value in B                ;
3448: F2BE 3A A3 F4               LD     A,(dpbEXM)           ; Get the Extent Mask               ;
3449: F2C1 A0                     AND    B                    ; Mask out unwanted bits            ;
3450: F2C2         ; if result is zero, then not in the same group                             ;
3451: F2C2 21 B1 F4               LD     HL,fcbCopiedFlag     ; Point at Copied Flag              ;
3452: F2C5 A6                     AND    M                    ;  00 in Acc if not written         ;
3453: F2C6 28 0C                  JR     Z,OpenNextExt1       ;  go to next physical extent if 0  ;
3454: F2C8 18 24                  JR     UpdateFCB            ;  else continue                    ;
3455: F2CA         ;
3456: F2CA             OpenNextModule:                      ;
3457: F2CA 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ; Index difference between EXT & S2 ;
3458: F2CD 09                     ADD    HL,BC                ; Add to HL( at EXT) gives S2       ;
3459: F2CE 34                     INC    M                    ; Increment the Module number       ;
3460: F2CF 7E                     LD     A,(HL)               ; get the new Module number         ;
3461: F2D0 E6 0F                  AND    moduleMask           ; Mask out unwanted bits            ;
3462: F2D2 28 25                  JR     Z,OpenNextExtError   ; If overflow to zero, error exit   ;
3463: F2D4         ;
3464: F2D4             OpenNextExt1:                      ;
3465: F2D4 0E 0F                  LD     C,nameLength         ; Set search/match size             ;
3466: F2D6 CD F6 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
3467: F2D9 CD 47 F1               CALL   AtEndOfDirectory     ; At end of Directory ?             ;
3468: F2DC 20 10                  JR     NZ,UpdateFCB         ;  No, then keep going              ;
3469: F2DE         ;
3470: F2DE 3A B2 F4               LD     A,(readModeFlag)     ;  else at EOD                      ;
3471: F2E1 3C                     INC    A                    ; 0ffh becomes 00 if read           ;
3472: F2E2 28 15                  JR     Z,OpenNextExtError   ; All done if a read                ;
3473: F2E4         ;
3474: F2E4 CD B3 EE               CALL   MakeNewFile          ; With write we can extend file     ;
3475: F2E7 CD 47 F1               CALL   AtEndOfDirectory     ; Is there room in the directory ?  ;
3476: F2EA 28 0D                  JR     Z,OpenNextExtError   ;  no, exitParameterByte = 1        ;
3477: F2EC 18 03                  JR     OpenNextExt3         ;
3478: F2EE         ;
3479: F2EE             UpdateFCB:                      ;
3480: F2EE CD FD ED               CALL   CopyDirRecordToFCB   ; Update FCB                        ;
3481: F2F1             OpenNextExt3:                      ;
3482: F2F1 CD 6C EF               CALL   SetRecordVars        ; Set variables for current FCB     ;
3483: F2F4 AF                     XOR    A                    ;
3484: F2F5 32 B6 EA               LD     (exitParameterByte),A ; Set exitParameterByte = 0         ;
3485: F2F8 C9                     RET                         ;
3486: F2F9         ;
3487: F2F9             OpenNextExtError:                      ;
3488: F2F9 CD 2E F3               CALL   SetExitParamTo1      ; ExitParameterByte = 1             ;
3489: F2FC C3 CB EF               JP     SetFileWriteFlag     ; Ensure that it will not be closed ;
3490: F2FF         ;-------------------------------- Open Next Extent -------------------------;
3491: F2FF
3492: F2FF         ;=========================== Directory Utilities ===========================;
3493: F2FF
3494: F2FF         ;===========================================================================;
3495: F2FF
3496: F2FF         ;=========================== General   Utilities ===========================;
3497: F2FF
3498: F2FF         ;--------------------------- Rotate HL right by value in C -----------------;
3499: F2FF         ;
3500: F2FF         ; HL = Value to be rotated Right                                            ;
3501: F2FF         ;  B = Amount to shift                                                      ;
3502: F2FF             RotateRightHLbyB:                      ;
3503: F2FF 37                     SCF                         ; Set carry flag, expect LSBit = 1  ;
3504: F300 CB 45                  BIT    0,L                  ; is LSB set?                       ;
3505: F302 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set               ;
3506: F304 3F                     CCF                         ; else Clear Carry flag             ;
3507: F305             RotateRightHLbyB1:                      ;
3508: F305 CB 1C                  RR     H                    ; Shift thru CY                     ;
3509: F307 CB 1D                  RR     L                    ; ditto                             ;
3510: F309 10 F4                  DJNZ   RotateRightHLbyB     ;
3511: F30B C9                     RET                         ;
3512: F30C         ;
3513: F30C         ;--------------------------- Rotate HL right by value in C -----------------;
3514: F30C         ;---------Divide HL by 8  &&  Shift HL right by value in C -----------------;
3515: F30C         ; HL = Value to be shifted Right                                            ;
3516: F30C             DivideHLby8:                      ;
3517: F30C 06 03                  LD     B,3                  ; 8 = 2**3						    ;
3518: F30E         ;  B = Amount to shift                                                      ;
3519: F30E             ShiftRightHLbyB:                      ;
3520: F30E AF                     XOR    A                    ; else Clear Carry flag             ;
3521: F30F CB 1C                  RR     H                    ; Shift thru CY                     ;
3522: F311 CB 1D                  RR     L                    ; ditto                             ;
3523: F313 10 F9                  DJNZ   ShiftRightHLbyB      ;
3524: F315 C9                     RET                         ;
3525: F316         ;---------Divide HL by 8  &&  Shift HL right by value in C -----------------;
3526: F316         ;---------Multiply HL by 8  &&  Shift HL left by value in C ----------------;
3527: F316         ; HL = Value to be shifted Left                                             ;
3528: F316             MultiplyHLby8:                      ;
3529: F316 06 03                  LD     B,3                  ; 8 = 2**3						    ;
3530: F318         ;  B = Amount to shift                                                      ;
3531: F318             ShiftLeftHLbyB:                      ;
3532: F318 AF                     XOR    A                    ; else Clear Carry flag             ;
3533: F319 CB 15                  RL     L                    ; Shift thru CY                     ;
3534: F31B CB 14                  RL     H                    ; ditto                             ;
3535: F31D 10 F9                  DJNZ   ShiftLeftHLbyB       ;
3536: F31F C9                     RET                         ;
3537: F320         ;---------Multiply HL by 8  &&  Shift HL left by value in C ----------------;
3538: F320         ;----------------------------- Merge ---------------------------------------;
3539: F320         ; Merge Map Block Numbers between FCB and directory record                  ;
3540: F320         ; HL has pointer to map for either dir record or FCB,                       ;
3541: F320         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
3542: F320         ; it just returns, Else it copies the block number to where DE is pointing  ;
3543: F320         ;
3544: F320             Merge:                          ;
3545: F320 7E                     LD     A,(HL)               ; Get the first byte                ;
3546: F321 23                     INC    HL                   ;
3547: F322 B6                     OR     M                    ; OR it with the second byte        ;
3548: F323 2B                     DEC    HL                   ; Restore HL to start               ;
3549: F324 C0                     RET    NZ                   ; Exit if both are 0s               ;
3550: F325         ; HL points to a non Zero value	                                            ;
3551: F325 1A                     LD     A,(DE)               ; Get the first byte                ;
3552: F326 77                     LD     (HL),A               ; Move it                           ;
3553: F327 13                     INC    DE                   ;
3554: F328 23                     INC    HL                   ; Increment both pointers           ;
3555: F329 1A                     LD     A,(DE)               ; Get the second byte               ;
3556: F32A 77                     LD     (HL),A               ; Move it                           ;
3557: F32B 1B                     DEC    DE                   ;
3558: F32C 2B                     DEC    HL                   ; Restore HL & DE to start          ;
3559: F32D C9                     RET                         ;
3560: F32E         ;----------------------------- Merge ---------------------------------------;
3561: F32E         ;------------------------- Set Exit Parameter To 1 -------------------------;
3562: F32E             SetExitParamTo1:                      ;
3563: F32E 3E 01                  LD     A,1                  ;
3564: F330 32 B6 EA               LD     (exitParameterByte),A ; Put a 1 in the exit parameter     ;
3565: F333 C9                     RET                         ;
3566: F334         ;------------------------- Set Exit Parameter To 1 -------------------------;
3567: F334
3568: F334         ;=========================== General   Utilities ===========================;
3569: F334
3570: F334         ;--------------------------- Read Directory Record -------------------------;
3571: F334         ; read a directory entry into the directory buffer                          ;
3572: F334             ReadDirRecord:                      ;
3573: F334 CD 0C EF               CALL   SetDirDMA            ; System Assigned Buffer            ;
3574: F337 CD 15 EF               CALL   ReadBuffer           ; Go to BIOS for the read           ;
3575: F33A C3 07 EF               JP     SetDataDMA           ; Restore DMA                       ;
3576: F33D         ;--------------------------- Read Directory Record -------------------------;
3577: F33D
3578: F33D         ;--------------------------- Read Directory --------------------------------;
3579: F33D         ; Read next directory entry                                                 ;
3580: F33D         ; Enter :                                                                   ;
3581: F33D         ;		C =  TRUE initializing and setting CheckSum                         ;
3582: F33D         ;		  <> TRUE Checking existing CheckSum                                ;
3583: F33D             ReadDirectory:                      ;
3584: F33D ED 5B A6 F4               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
3585: F341 2A C3 F4               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
3586: F344 23                     INC    HL                   ; Increment the Index               ;
3587: F345 22 C3 F4               LD     (dirEntryIndex),HL   ; Save current directory index      ;
3588: F348 AF                     XOR    A                    ; Clear the CY flag                 ;
3589: F349 ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
3590: F34B 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
3591: F34D CD 40 F1               CALL   SetEndDirectory      ;  else we are done                 ;
3592: F350 C9                     RET                         ;
3593: F351         ;
3594: F351         ; Calculate the entry index Position in Buffer                              ;
3595: F351             ReadDirectory0:                      ;
3596: F351 3A C3 F4               LD     A,(dirEntryIndex)    ; Get the index                     ;
3597: F354 E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
3598: F356 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
3599: F358             ReadDirectory1:                      ;
3600: F358 87                     ADD    A,A                  ;
3601: F359 10 FD                  DJNZ   ReadDirectory1       ;
3602: F35B 32 C2 F4               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
3603: F35E B7                     OR     A                    ; Is this the 1st entry?            ;
3604: F35F C0                     RET    NZ                   ;  return if not.                   ;
3605: F360         ;
3606: F360 C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
3607: F361 CD 6B F3               CALL   SeekDir              ; Set up for Directory Read         ;
3608: F364 CD 34 F3               CALL   ReadDirRecord        ; Read the directory record         ;
3609: F367 C1                     POP    BC                   ; Recall initialization flag        ;
3610: F368 C3 BA F3               JP     CheckSumUtility      ; Checksum the directory            ;
3611: F36B         ;--------------------------- Read Directory --------------------------------;
3612: F36B         ;--------------------------- Seek Directory --------------------------------;
3613: F36B         ;seek the record containing the current directory entry					;
3614: F36B             SeekDir:                        ;
3615: F36B 2A C3 F4               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
3616: F36E 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
3617: F370 CD 0E F3               CALL   ShiftRightHLbyB      ;
3618: F373 22 C0 F4               LD     (absoluteCPMRecord),HL ;
3619: F376 22 C5 F4               LD     (dirRecord),HL       ; Save                              ;
3620: F379 C3 7C F3               JP     Seek                 ;
3621: F37C         ;--------------------------- Seek Directory --------------------------------;
3622: F37C         ;--------------------------- Seek ------------------------------------------;
3623: F37C             Seek:                           ;
3624: F37C 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
3625: F37F 2A C0 F4               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
3626: F382 ED 5B 9F F4               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
3627: F386         ;
3628: F386             Seek0:                          ;
3629: F386 03                     INC    BC                   ; Divide the record                 ;
3630: F387 AF                     XOR    A                    ;  by the sectors per track         ;
3631: F388 ED 52                  SBC    HL,DE                ;
3632: F38A 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
3633: F38C         ;
3634: F38C         ;
3635: F38C 19                     ADD    HL,DE                ; Gets the sector in the track      ;
3636: F38D E5                     PUSH   HL                   ; Save Index Sector                 ;
3637: F38E         ;
3638: F38E DD E5                  PUSH   IX                   ; Save IX							;
3639: F390 DD 2A 93 F4               LD     IX,(caTrack)         ;
3640: F394 DD 71 00               LD     (IX+0),C             ;
3641: F397 DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
3642: F39A         ;
3643: F39A EB                     EX     DE,HL                ; Take the index from the record    ;
3644: F39B 2A C0 F4               LD     HL,(absoluteCPMRecord) ;
3645: F39E AF                     XOR    A                    ;
3646: F39F ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
3647: F3A1         ;
3648: F3A1 DD 2A 95 F4               LD     IX,(caSector)        ;
3649: F3A5 DD 75 00               LD     (IX+0),L             ;
3650: F3A8 DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
3651: F3AB DD E1                  POP    IX                   ; Restore IX							;
3652: F3AD         ;
3653: F3AD 2A AC F4               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
3654: F3B0 09                     ADD    HL,BC                ;  to add to the gross Track        ;
3655: F3B1 E5                     PUSH   HL                   ;  which yields the net or          ;
3656: F3B2 C1                     POP    BC                   ;  actual track for the record      ;
3657: F3B3 CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
3658: F3B6         ;
3659: F3B6 C1                     POP    BC                   ; Get the sector within the track   ;
3660: F3B7 C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
3661: F3BA         ;
3662: F3BA         ;--------------------------- Seek ------------------------------------------;
3663: F3BA         ;--------------------------- Check Sum Utility -----------------------------;
3664: F3BA         ; At entry                                                                  ;
3665: F3BA         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
3666: F3BA         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
3667: F3BA         ;
3668: F3BA             CheckSumUtility:                      ;
3669: F3BA 2A AA F4               LD     HL,(dpbCKS)          ;
3670: F3BD ED 5B C5 F4               LD     DE,(dirRecord)       ;
3671: F3C1 AF                     XOR    A                    ;
3672: F3C2 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
3673: F3C4 D8                     RET    C                    ;  Entries                      ;
3674: F3C5         ;
3675: F3C5 C5                     PUSH   BC                   ; Save New/Validate Flag        ;
3676: F3C6         ;
3677: F3C6         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
3678: F3C6             ComputeCheckSum:                      ;
3679: F3C6 06 80                  LD     B,cpmRecordSize      ;
3680: F3C8 2A 97 F4               LD     HL,(caDirectoryDMA)  ;
3681: F3CB EE 00                  XOR                         ;
3682: F3CD             ComputeCheckSum1:                      ;
3683: F3CD 86                     ADD    A,(HL)               ;
3684: F3CE 23                     INC    HL                   ;
3685: F3CF 10 FC                  DJNZ   ComputeCheckSum1     ;
3686: F3D1         ; Checksum is in ACC	                                                    ;
3687: F3D1         ;
3688: F3D1 2A 9B F4               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
3689: F3D4 ED 5B C5 F4               LD     DE,(dirRecord)       ; Index to this record              ;
3690: F3D8 19                     ADD    HL,DE                ; Address of this record in vector  ;
3691: F3D9 C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
3692: F3DA 0C                     INC    C                    ;
3693: F3DB 28 0A                  JR     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
3694: F3DD         ;
3695: F3DD BE                     CP     M                    ; Else we are checking the value    ;
3696: F3DE C8                     RET    Z                    ; Exit if OK                        ;
3697: F3DF         ; possible checksum error, are we beyond the end of the disk?               ;
3698: F3DF CD 67 F1               CALL   StillInDirectory     ;
3699: F3E2 D0                     RET    NC                   ; OK, if not in the directory       ;
3700: F3E3 CD 1D EF               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
3701: F3E6 C9                     RET                         ;  Set disk RO before returning     ;
3702: F3E7         ;
3703: F3E7         ;initializing the checksum                                                 ;
3704: F3E7             SetNewCheckSum:                      ;
3705: F3E7 77                     LD     (HL),A               ;
3706: F3E8 C9                     RET                         ;
3707: F3E9         ;--------------------------- Check Sum Utility -----------------------------;
3708: F3E9         ;---------------------------------- Is Bit Set -----------------------------;
3709: F3E9         ; Enter HL  contains the bit map                                            ;
3710: F3E9         ;       B   Has the bit number (0...F)                                      ;
3711: F3E9         ; Return ZFlag = 1 if bit is reset (0)                                      ;
3712: F3E9         ;              = 0 if bit is set (1)                                        ;
3713: F3E9             IsBitSet:                       ;
3714: F3E9 04                     INC    B                    ;
3715: F3EA             IsBitSetLoop:                      ;
3716: F3EA 37                     SCF                         ; Set carry flag, expect LSBit = 1  ;
3717: F3EB CB 45                  BIT    0,L                  ; is LSB set?                       ;
3718: F3ED 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set               ;
3719: F3EF 3F                     CCF                         ; else Clear Carry flag             ;
3720: F3F0             IsBitSet1:                      ;
3721: F3F0 CB 1C                  RR     H                    ; Shift thru CY                     ;
3722: F3F2 CB 1D                  RR     L                    ; ditto                             ;
3723: F3F4 10 F4                  DJNZ   IsBitSetLoop         ;
3724: F3F6 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	;
3725: F3F8 C9                     RET                         ;
3726: F3F9         ;---------------------------------- Is Bit Set -----------------------------;
3727: F3F9
3728: F3F9         ;============================ Set/Reset Vector Bit =========================;
3729: F3F9         ;---------------------------------- Set Vector Bit -------------------------;
3730: F3F9         ; Enter  HL  contains the bit map vector                                    ;
3731: F3F9         ;        B   Has the bit number (0...F)                                     ;
3732: F3F9         ; Return HL  Contains the modified bit map vector                           ;
3733: F3F9             SetVectorBit:                      ;
3734: F3F9 C5                     PUSH   BC                   ; Save the Bit Number               ;
3735: F3FA CD E9 F3               CALL   IsBitSet             ; Put the bit in the LSBit          ;
3736: F3FD         ;
3737: F3FD C1                     POP    BC                   ; Get the bit position              ;
3738: F3FE CB FC                  SET    7,H                  ;
3739: F400 18 07                  JR     ReAlignVector        ;
3740: F402         ;---------------------------------- Set Vector Bit -------------------------;
3741: F402         ;---------------------------------- Reset Vector Bit -----------------------;
3742: F402         ; Enter  HL  contains the bit map vector                                    ;
3743: F402         ;        B   Has the bit number (0...F)                                     ;
3744: F402         ; Return HL  Contains the modified bit map vector                           ;
3745: F402             ResetVectorBit:                      ;
3746: F402 C5                     PUSH   BC                   ; Save the Bit Number               ;
3747: F403 CD E9 F3               CALL   IsBitSet             ; Put the bit in the LSBit          ;
3748: F406         ;
3749: F406 C1                     POP    BC                   ; Get the bit position              ;
3750: F407 CB BC                  RES    7,H                  ;
3751: F409         ; Fall thru to ReAlignVector                                                ;
3752: F409         ;---------------------------------- Reset Vector Bit -----------------------;
3753: F409         ;---------------------------------- Set VectorBit --------------------------;
3754: F409         ; Adjusts the HL register to its Original Alignment after IsBitSet          ;
3755: F409         ;
3756: F409             ReAlignVector:                      ;
3757: F409 04                     INC    B                    ;
3758: F40A             ReAlignMapLoop:                      ;
3759: F40A 37                     SCF                         ; Set carry flag, expect LSBit = 1  ;
3760: F40B CB 7C                  BIT    7,H                  ; is LSB set?                       ;
3761: F40D 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set               ;
3762: F40F 3F                     CCF                         ; else Clear Carry flag             ;
3763: F410             ReAlignMap1:                      ;
3764: F410 CB 15                  RL     L                    ; Shift thru CY                     ;
3765: F412 CB 14                  RL     H                    ; ditto                             ;
3766: F414 10 F4                  DJNZ   ReAlignMapLoop       ;
3767: F416 C9                     RET                         ;
3768: F417         ;============================ Set/Reset Vector Bit =========================;
3769: F417         ;============================= Error message World =========================;
3770: F417         ;																			;
3771: F417             Error_Select:                      ;
3772: F417 21 6F F4               LD     HL,ErrMsg_Selection  ; Error Message                     ;
3773: F41A C3 35 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3774: F41D         ;
3775: F41D             Error_DiskReadOnly:                      ;
3776: F41D 21 7F F4               LD     HL,ErrMsg_ReadOnlyDisk ; Error Message                     ;
3777: F420 C3 35 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3778: F423         ;
3779: F423             Error_FileReadOnly:                      ;
3780: F423 21 76 F4               LD     HL,ErrMsg_ReadOnlyFile ; Error Message                     ;
3781: F426 C3 35 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3782: F429         ;
3783: F429             Error_BadSector:                      ;
3784: F429 21 64 F4               LD     HL,ErrMsg_BadSector  ; Error Message                     ;
3785: F42C CD 3B F4               CALL   DisplayErrorAndWait  ; Check input from console          ;
3786: F42F FE 03                  CP     CTRL_C               ;
3787: F431 CA 00 00               JP     Z,WarmBoot           ; Reboot if response is CTRL_C      ;
3788: F434 C9                     RET                         ;
3789: F435         ;---------------------------------------------------------------------------;
3790: F435             WaitBeforeBoot:                      ;
3791: F435 CD 3B F4               CALL   DisplayErrorAndWait  ;
3792: F438 C3 00 00               JP     WarmBoot             ;
3793: F43B         ;---------------------------------------------------------------------------;
3794: F43B         ;
3795: F43B             DisplayErrorAndWait:                      ;
3796: F43B E5                     PUSH   HL                   ; Save message pointer              ;
3797: F43C CD D6 E9               CALL   showCRLF             ; Line Feed and Carriage Return     ;
3798: F43F 3A 89 F4               LD     A,(currentDisk)      ; Disk in question                  ;
3799: F442 C6 41                  ADD    A,ASCII_A            ; Make ASCII out of it              ;
3800: F444 32 60 F4               LD     (ErrMsg_BDOS_DISK),A ; Put into the error message        ;
3801: F447 01 54 F4               LD     BC,ErrMsg_BDOS       ; Load the start of message         ;
3802: F44A CD 3B E9               CALL   Print                ; Display it                        ;
3803: F44D C1                     POP    BC                   ; Load the rest of message          ;
3804: F44E CD 3B E9               CALL   Print                ; Display it                        ;
3805: F451 C3 21 E9               JP     ConIn                ; Get the input character           ;
3806: F454         ;
3807: F454         ;***************************************************************************;
3808: F454         ;
3809: F454 42 44 4F 53 20 45 72 72 20 4F 6E 20     ErrMsg_BDOS: DB     'BDOS Err On '       ;
3810: F460 20 3A 20 24     ErrMsg_BDOS_DISK: DB     ' : $'               ;
3811: F464 42 61 64 20 53 65 63 74 6F 72 24     ErrMsg_BadSector: DB     'Bad Sector$'        ;
3812: F46F 53 65 6C 65 63 74 24     ErrMsg_Selection: DB     'Select$'            ;
3813: F476 52 2F 4F 20 46 69 6C 65 24     ErrMsg_ReadOnlyFile: DB     'R/O File$'          ;
3814: F47F 52 2F 4F 20 44 69 73 6B 24     ErrMsg_ReadOnlyDisk: DB     'R/O Disk$'          ;
3815: F488         ;
3816: F488         ;============================= Error message World =========================;
3817: F488
3818: F488         ;********* file control block (fcb) constants ********************
3819: F488             fcbLength  EQU    20H                  ; File control block size
3820: F488             fcbROfileIndex EQU    09H                  ; High order of first type char
3821: F488             fcbHiddenfileIndex EQU    0AH                  ; Hidden file in dir command
3822: F488             fcbExtIndex EQU    0CH                  ; Extent number field index
3823: F488             fcbS1Index EQU    0DH                  ; S1 index
3824: F488             fcbS2Index EQU    0EH                  ; S2 data module number index
3825: F488             fcbRCIndex EQU    0FH                  ; Record count field index
3826: F488             fcbDiskMapIndex EQU    10H                  ; Disk map start
3827: F488             fcbExtIndexLSB EQU    0CH                  ; LSB of Extent
3828: F488             fcbExtIndexMSB EQU    0EH                  ; Bit 7 = Write protected
3829: F488
3830: F488             fcbCurrentRecord EQU    21H                  ; Next record to read/write
3831: F488
3832: F488             highestRecordNumber EQU    RecordsPerExtent - 1 ; Last record# in extent
3833: F488
3834: F488             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; Directory entries / record
3835: F488             dirEntryShift EQU    2                    ; Log2(dirEntriesPerRecord)
3836: F488             dirEntryMask EQU    dirEntriesPerRecord-1
3837: F488             fcbShift   EQU    5                    ; Log2(fcbLength)
3838: F488         ;
3839: F488
3840: F488
3841: F488
3842: F488             maxExtValue EQU    31                   ; Largest extent number
3843: F488             moduleMask EQU    15                   ; Limits module number value
3844: F488             writeFlagMask EQU    80h                  ; File write flag is high order fcbS2Index
3845: F488             nameLength EQU    15                   ; Name length
3846: F488
3847: F488             emptyDir   EQU    0E5H                 ; Empty empty directory entry
3848: F488             recordSeq  EQU    fcbLength            ; Next Sequential Record
3849: F488             recordRandom EQU    recordSeq + 1        ; Random record field (2 bytes)
3850: F488             recordRandomLSB EQU    recordRandom         ; LSB of Random Record
3851: F488             recordRandomMSB EQU    recordRandom + 1     ; MSB of Random Record
3852: F488             recordRandomOVF EQU    recordRandom + 2     ; Random Record Overflow
3853: F488
3854: F488
3855: F488         ;***common values shared between bdosi and bdos******************
3856: F488 00          currentUserNumber: DB     0                    ; usrcode current user number
3857: F489 FF          currentDisk: DB     -1                   ; curdsk current disk number
3858: F48A
3859: F48A         ;********************* Local Variables ***************************
3860: F48A         ;     ************************
3861: F48A         ;     *** Initialized Data ***
3862: F48A
3863: F48A E5          emptyFCB:  DB     emptyDir             ; 0E5 = available dir entry
3864: F48B 00 00       readOnlyVector: DW     0                    ; Read only disk vector
3865: F48D 00 00       loggedDisks: DW     0                    ; Logged-in disks
3866: F48F 80 00       initDAMAddress: DW     DMABuffer            ; Initial DMA address
3867: F491
3868: F491         ;     *** Current Disk attributes ****
3869: F491         ; These are set upon disk select
3870: F491         ; data must be adjacent, do not insert variables
3871: F491         ; address of translate vector, not used
3872: F491         ; ca - currentAddress
3873: F491
3874: F491 00 00       caDirMaxValue: DW     0000H                ; Pointer to cur dir max value
3875: F493 00 00       caTrack:   DW     0000H                ; Current track address
3876: F495 00 00       caSector:  DW     0000H                ; Current Sector
3877: F497             caListSizeStart:
3878: F497 00 00       caDirectoryDMA: DW     0000H                ; Pointer to directory DMA address
3879: F499 00 00       caDiskParamBlock: DW     0000H                ; Current disk parameter block address
3880: F49B 00 00       caCheckSum: DW     0000H                ; Current checksum vector address
3881: F49D 00 00       caAllocVector: DW     0000H                ; Current allocation vector address
3882: F49F             caListSizeEnd:
3883: F49F             caListSize EQU    caListSizeEnd - caListSizeStart
3884: F49F
3885: F49F         ;     ***** Disk Parameter Block *******
3886: F49F         ; data must be adjacent, do not insert variables
3887: F49F         ; dpb - Disk Parameter Block
3888: F49F             dpbStart:
3889: F49F 00 00       dpbSPT:    DW     0000H                ; Sectors per track
3890: F4A1 00          dpbBSH:    DB     0000H                ; Block shift factor
3891: F4A2 00          dpbBLM:    DB     00H                  ; Block mask
3892: F4A3 00          dpbEXM:    DB     00H                  ; Extent mask
3893: F4A4 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3894: F4A6 00 00       dpbDRM:    DW     0000H                ; Largest directory number
3895: F4A8 00 00       dpbDABM:   DW     0000H                ; Reserved allocation bits for directory
3896: F4AA 00 00       dpbCKS:    DW     0000H                ; Size of checksum vector
3897: F4AC 00 00       dpbOFF:    DW     0000H                ; Offset tracks at beginning
3898: F4AE             dpbEnd:
3899: F4AE             dpbSize    EQU    dpbEnd - dpbStart
3900: F4AE         ;
3901: F4AE
3902: F4AE         ;     ************************
3903: F4AE             SEQ_ACCESS EQU    01H                  ; Indicates sequential access to file
3904: F4AE             RANDOM_ACCESS EQU    00H                  ; Indicates random access to file
3905: F4AE 00          diskAccessType: DB     00H                  ; Set to 1 if sequential disk operation
3906: F4AF
3907: F4AF 00 00       caSkewTable: DW     0000H                ; Address of translate vector
3908: F4B1 00          fcbCopiedFlag: DB     00H                  ; Set true if CopyFCB called
3909: F4B2 00          readModeFlag: DB     00H                  ; Read mode flag for Open NextExt
3910: F4B3 00          directoryIndex: DB     00H                  ; Directory flag in rename, etc.
3911: F4B4 00          diskMapIndex: DB     00H                  ; Local for Disk_Write
3912: F4B5 00          searchLength: DB     00H                  ; Search length
3913: F4B6 00 00       searchAddress: DW     0000H                ; Search address
3914: F4B8 00          byteAllocationFlag: DB     00H                  ; Set true if single byte allocation map
3915: F4B9 00          fResel:    DB     00H                  ; Re selection flag
3916: F4BA 00          entryDisk: DB     00H                  ; Disk on entry to BDOS
3917: F4BB 00          fcbDisk:   DB     00H                  ; Disk named in FCB
3918: F4BC 00          fcbRecordCount: DB     00H                  ; Record count from current FCB
3919: F4BD 00          extentValue: DB     00H                  ; Extent number and dpbEXM from current FCB
3920: F4BE 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3921: F4C0 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3922: F4C2         ;
3923: F4C2         ;	local variables for directory access
3924: F4C2 00          dirBlockIndex: DB     00H                  ; Directory block Index 0,1,2,3
3925: F4C3 00 00       dirEntryIndex: DW     00H                  ; Directory entry Index  0,1,...,dpbDRM
3926: F4C5 00 00       dirRecord: DW     00H                  ; Directory record 0,1,...,dpbDRM/4
3927: F4C7
3928: F4C7         ;********************** data areas ******************************
3929: F4C7
3930: F4C7
3931: F4C7         ;---------------------------------- Stack Area--------------------------------;
3932: F4C7             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3933: F507             bdosStack:
3934: F507         ;
3935: F507         ;---------------------------------- Stack Area--------------------------------;
3936: F507         ;	end of Basic I/O System
3937: F507         ;-----------------------------------------------------------------;
3938: F507
3939: F507
3940: F507         ;
3941: F507             Z_HighestLocation:
3942: F507             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3943: F507
3944: F507
           ************************   Xref   ************************
0000: $               F507   0408 0438
3921: absoluteCPMRecord F4C0   1599 3360 3401 3413 3425 3618 3625 3644
1617: Allocate16Bit   EBDB   1612
1036: AreWeAtEndOfBuffer EA31   1032
0073: ASCII_A         0041   3799
0074: ASCII_C         0043
0075: ASCII_M         004D
0037: ASCII_MASK      007F   0979
0076: ASCII_O         004F
0077: ASCII_Y         0059
0060: ASCII_ZERO      0030
0058: ASTERISK        002A
3092: AtEndOfDirectory F147   1427 1745 1935 2115 2368 2399 2463 2555 2833 3437 3467 3475
1128: BackUp          EA90   1056 1124
1133: BackUp1         EA98   1129
0286: bcBoot          F600
0289: bcConin         F609   0608 0794 0905 0923
0290: bcConout        F60C   0600 0867 1131 1135 1141 1143
0288: bcConst         F606   0605 0901
0294: bcHome          F618   2584
0291: bcList          F60F   0573 0873
0301: bcListst        F62D
0292: bcPunch         F612   0558
0299: bcRead          F627   2622
0293: bcReader        F615   0539
0302: bcSectran       F630
0295: bcSeldsk        F61B   2271
0298: bcSetdma        F624   2617
0297: bcSetsec        F621   3660
0296: bcSettrk        F61E   2590 3657
0287: bcWboot         F603   0459
0300: bcWrite         F62A   2921
0133: BDOSBase        E800   0134 0136 0317
0102: BDOSE           0005   0103
0134: BDOSEntry       E800
0123: BDOSLength      0E00   0126 0136 0137
3933: bdosStack       F507   0333
0323: BdosStart       E800
0136: BIOSBase        F600
0124: BIOSLength      0A00   0126
0096: BIOSPAGE        0002
0137: BIOSStart       F600   0286 0287 0288 0289 0290 0291 0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 3942
0233: BlockSize       0800   0255
1051: BSspaceBS       EA3E   0990
0033: BYTE            0001   1164
3914: byteAllocationFlag F4B8   1610 2304 2476 3168 3383
3881: caAllocVector   F49D   1839 2324 2326 2351 2741 3221 3288
3880: caCheckSum      F49B   3688
3878: caDirectoryDMA  F497   2291 2611 3107 3298 3680
3874: caDirMaxValue   F491   2282 2358 2639 3141
3879: caDiskParamBlock F499   1956 2296
3883: caListSize      0008   2292
3882: caListSizeEnd   F49F   3883
3877: caListSizeStart F497   3883
0078: CARET           005E   0833
0827: CaretOut        E948   1025 1106
3876: caSector        F495   2288 2598 3648
3907: caSkewTable     F4AF   2280
3875: caTrack         F493   2285 2594 3639
0131: CCPEntry        E000   0133 0137
0122: CCPLength       0800   0126 0133 0137
0919: CheckCTL_S      E9AC   0908
2871: CheckExtents    F044   2865
3317: CheckRODirectory F230   1431 1748
3320: CheckROFile     F233   1565
3668: CheckSumUtility F3BA   2905 3610
3311: CheckWrite      F229   1422 1563 1733 2548
2444: CloseDirEntry   EE35   1281 2988 3436
2532: CloseDirEntryEnd EEA2   2522
2540: CloseDirEntryError EEAE   2492 2502 2507
0061: COLON           003A
1162: columnPosition  EAB2   0852 0877 0942 0962 1120
2796: CompareExtents  EFE5   2872
3678: ComputeCheckSum F3C6
3682: ComputeCheckSum1 F3CD   3685
0108: ComTail         0080   0109
0110: ComTailChars    0081
0109: ComTailCount    0080   0110
0896: ConBreak        E98C   0720 0863
0929: ConBreak0       E9BA   0921
0931: ConBreak1       E9BD   0899
0787: ConIn           E921   0491 0978 3805
0860: ConsoleOut      E96B   0834 0846 0851 0939 0947 0954 0956 1048
3339: CopyDir         F241   1751 1940
3297: CopyDirEntryToUserDMA F215   1334 1399
2402: CopyDirRecordToFCB EDFD   3480
3333: CopyFCB         F23D   2574
0210: cpmRecordSize   0080   0212 0215 0217 3300 3679 3834
0053: CR              000D   0800 0953 0983 1047
0040: CTRL_C          0003   0924 1030 3786
0041: CTRL_E          0005   0995
0042: CTRL_H          0008   0806 0989 1134
0043: CTRL_L          000C
0044: CTRL_P          0010   0907 0998
0045: CTRL_R          0012   1007
0046: CTRL_S          0013   0920
0047: CTRL_U          0015   1004
0048: CTRL_X          0018   1001
0049: CTRL_Z          001A
3857: currentDisk     F489   1202 1799 2240 2251 2257 2269 2632 2650 2669 3798
3920: currentFileRecord F4BE   1490 1500 1567 1639 1673 2695 2932 3368 3421
3856: currentUserNumber F488   0771 0777 2376 2678
0244: DataBlocks      02C7   0254
0243: DataSectors     0B1C   0244
1426: DeleteFileLoop  EB15   1438
1115: DeleteTheLine   EA7F   1002
1118: DeleteTheLine1  EA80   1125
3924: dirBlockIndex   F4C2   3108 3602
0215: DirBuffSize     0080
0230: DirectoryBlockCount 0002   0255
0217: DirectoryEntryPerRecord 0004   0258
3910: directoryIndex  F4B3   2822 2886 3306
3834: dirEntriesPerRecord 0004   3836
3925: dirEntryIndex   F4C3   2882 3083 3093 3139 3585 3587 3596 3615
3836: dirEntryMask    0003   2883 3597
3835: dirEntryShift   0002   3616
0214: DirEntrySize    0020   0217 0255
3305: DirLocationToReturnLoc F222   1428 1746 1936
3926: dirRecord       F4C5   3619 3670 3689
3905: diskAccessType  F4AE   1483 1557 1662 2930 2947
0202: DiskCommandBlock 0046
0201: DiskControlByte 0045
0204: DiskControlTable 0040
0408: diskf           000B
3911: diskMapIndex    F4B4   1577 1606
1485: DiskRead        EB39   2023
0206: DiskReadCode    0001
0211: diskSectorSize  0200   0212 0233 0241
0200: DiskStatusLocation 0043
1559: DiskWrite       EB7C   2066
1646: DiskWrite1      EC03   1642
1656: DiskWrite2      EC0C   1650
1677: DiskWriteCleanup EC29   1660 1664
1675: DiskWriteCleanup0 EC27   1671
0207: DiskWriteCode   0002
1555: DiskWriteSeq    EB77
3795: DisplayErrorAndWait F43B   3785 3791
3516: DivideHLby8     F30C   2319 3207 3210
0113: DMABuffer       0080   1204 3866
0056: DOLLAR          0024   0815 2382
0256: dpb3hdAL0       00C0
0257: dpb3hdAL1       0000
0252: dpb3hdBLM       000F
0251: dpb3hdBSH       0004
0258: dpb3hdCKS       0020
0255: dpb3hdDRM       007F   0258
0254: dpb3hdDSM       02C6
0253: dpb3hdEXM       0000
0260: dpb3hdNOH       0002
0259: dpb3hdOFF       0001
0250: dpb3hdSPT       0090
3891: dpbBLM          F4A2   3419
3890: dpbBSH          F4A1   3366 3411
3896: dpbCKS          F4AA   3669
3895: dpbDABM         F4A8   2349
3894: dpbDRM          F4A6   2637 3584
3893: dpbDSM          F4A4   2302 2318 2334 3206
3898: dpbEnd          F4AE   3899
3892: dpbEXM          F4A3   2700 2799 3448
3897: dpbOFF          F4AC   2586 3653
3899: dpbSize         000F   2298
3889: dpbSPT          F49F   3626
3888: dpbStart        F49F   2297 3899
0440: DUMMY           E8A9   0435 0436
3847: emptyDir        00E5   1433 2372 2839 3863
3863: emptyFCB        F48A   2551
0117: END_OF_FILE     001A
0038: EndOfMessage    0000
1041: EndRead         EA34   0984 0987
3916: entryDisk       F4BA   0381 2670
0272: EOD             FFFF   3082
0065: EQUAL_SIGN      003D
3811: ErrMsg_BadSector F464   3784
3809: ErrMsg_BDOS     F454   3801
3810: ErrMsg_BDOS_DISK F460   3800
3814: ErrMsg_ReadOnlyDisk F47F   3776
3813: ErrMsg_ReadOnlyFile F476   3780
3812: ErrMsg_Selection F46F   3772
3783: Error_BadSector F429   2624 2923
3775: Error_DiskReadOnly F41D   3314
3779: Error_FileReadOnly F423   3326
3771: Error_Select    F417   2250
1166: exitParameterByte EAB6   0500 0609 0721 0747 0772 1501 1595 1627 1668 1800 2386 2446 2541 2884 2898 2992 2999 3011 3018 3026 3307 3484 3564
1167: exitParameterWord EAB6   0337 0388 0540 0629 1776 1840 1886 1957
3919: extentValue     F4BD   2702
0030: FALSE           0000   0914 1086 1434 1560 2064 2308 2831
0105: FCB1            005C   0106
0106: FCB2            006C
3908: fcbCopiedFlag   F4B1   2534 3435 3451
3830: fcbCurrentRecord 0021
3917: fcbDisk         F4BB   0339 0376 2672
3826: fcbDiskMapIndex 0010   1602 1740 1749 2468 2473 3158 3160 3380
3822: fcbExtIndex     000C   1423 1734 1750 1931 1939 2101 2417 2516 2525 2721 2863 2976 2996 3040 3457
3827: fcbExtIndexLSB  000C
3828: fcbExtIndexMSB  000E
3821: fcbHiddenfileIndex 000A
3819: fcbLength       0020   2411 2473 2516 2566 3160 3335 3834 3848
3825: fcbRCIndex      000F   2119 2420 2438 2525 2710 2713
3918: fcbRecordCount  F4BC   1491 1640 2698 2936
3820: fcbROfileIndex  0009   3321
3823: fcbS1Index      000D   2570 2860
3824: fcbS2Index      000E   2453 2766 2777 2788 2980 2997 3022 3057 3457
3837: fcbShift        0005   3598
1588: FindAvailableBlock EBB3   1580
1598: FoundAvailableBlock EBC0   1592
3267: FoundFreeOctet  F1F0   3237 3242 3251 3259
3273: FoundFreeOctet1 F1F6   3269
3275: FoundFreeOctet2 F1F7   3271
3277: FoundFreeOctet3 F1FA   3280
3283: FoundFreeOctet4 F202   3285
3915: fResel          F4B9   0340 0370 2660
0438: functionCount   0028   0349
0395: functionTable   E857   0354 0408 0438
3355: GetBlockNumber  F258   1506 1571
3203: GetClosestBlock F19F   1589
3105: GetCurrentDirectoryRecord F150   1432 2118 2371 2407 2467 2849 3157 3318 3346
3390: GetDiskMap16Bit F284   3385
3365: GetDiskMapIndex F265   1576 3356
3369: GetDiskMapIndexLoop F26C   3371
3378: GetDiskMapValue F272   1584 3359
2719: GetExtentAddress EF90   2403 2699 3440
2708: GetFcbRecordDetails EF83   2692 2929
2114: GetFileSize1    ECD4   2142
2140: GetFileSize2    ECF4   2133
2143: GetFileSizeExit ECF9   2116
2830: GetNextDirectoryRecord F00B   1398 1437 1753 1941 2141 2868 2873
2848: GetNextDirectoryRecord1 F025   2840
3033: GetRandomRecordPosition F113   2120 2174
0066: GREATER_THAN    003E
0055: HASH_TAG        0023   0938
1626: HaveWriteBlock  EBE4   1574
3832: highestRecordNumber 007F   1568 1659
2583: Home            EEED   2357 2828
1138: IgnoreTheLine   EA9D   1005
3866: initDAMAddress  F48F   1205 1822 2607 3299
2317: InitDisk        ED84   2263
2364: InitDisk1       EDC9   2374 2392
2387: InitDisk2       EDEA   2378 2383
2763: InitializeExtentNumberMSB EFBE   1248 1328 1701
0097: IOBYTE          0003   0628 0648
3713: IsBitSet        F3E9   2254 2652 3735 3747
3720: IsBitSet1       F3F0   3718
3715: IsBitSetLoop    F3EA   3723
2648: IsDiskWriteProtected EF35   2447 3312
1003: IsItDeleteTheLineU EA12
1000: IsItDeleteTheLineX EA0E
0997: IsItPrintToggle EA0A
1087: IsItPrintToggle1 EA62   1085
0991: IsItRubout      EA02
0994: IsPhysicalEOL   EA06
0799: IsPrintableASCII E92C   0492 0829
1072: ItIsPhysicalEOL EA50   0996
1079: ItIsPrintToggle EA57   0999
1060: ItIsRubout      EA47   0993
1156: keyboardByte    EAAF   0788 0897 0930
2748: Left            EFAF   2750
0069: LEFT_ARROW      005F
0126: LengthInBytes   2000   0127 0131 0241
0127: LengthInK       0009
0064: LESS_THAN       003C
0052: LF              000A   0802 0883 0955 0985
1101: LL1             EA6F   1109
0031: LO_NIBBLE_MASK  000F   0776 3053
3865: loggedDisks     F48D   1200 1775 2253 2259 2261
3235: LookRight       F1C4   3245
2547: MakeNewFile     EEB3   1703 3009 3474
2347: Mark4Directory  EDB1   2339
1622: MarkNewBlock    EBDF   1615
3842: maxExtValue     001F   2808 3443
0129: MemorySize      0040   0131
3544: Merge           F320   2496 2498
2475: MergeAllocationMaps EE61   2513
2490: MergeDirEntryNot0 EE72   2487
2485: MergeFCBisNot0  EE6D   2483
2509: MergeMapLoop    EE8A   2493
2495: MergeWordMaps   EE77   2478
3843: moduleMask      000F   3461
3528: MultiplyHLby8   F316   2333 3291
0242: myOffset        0001   0243 0259
3845: nameLength      000F   1330 2397 2461 2560 2566 3465
2895: NoDirRecordsMatch F060   2834 2846
3263: NoFreeBlocks    F1EC   3252 3260
3247: NoMoreLeft      F1D6   3243
3249: NoMoreLeftLoop  F1D7   3253
3255: NoMoreRight     F1E1   3238
3257: NoMoreRightLoop F1E2   3261
2677: NoSelect        EF63   2667
1516: NothingRead     EB71   1496 1503 1508
0926: NothingWaiting  E9B8   0917
0226: NumberOfHeads   0002   0237 0239 0250 0260
0223: NumberOfLogicalDisks 0004
2396: OpenFile        EDF4   1250 2998
3433: OpenNextExt     F2A8   1498 1667
3464: OpenNextExt1    F2D4   3453
3481: OpenNextExt3    F2F1   3477
3487: OpenNextExtError F2F9   3462 3472 3476
3456: OpenNextModule  F2CA   3445
2436: OpenSetRecordCount EE2C   2432 2434
1165: paramDE         EAB4   0328 0374 0671 0964 1043 1098 1322 1396 1564 1601 1738 1821 2104 2172 2410 2437 2452 2471 2549 2552 2557 2569 2661 2679 2709 2720 2765 2776 2787 2825 2949 3343 3379
1164: paramE          EAB3   0330 0382 0768 2239 2665
0057: PERCENT         0025
0059: PERIOD          002E
0100: Pg0CurentDisk   0004
0099: Pg0CurentUser   0004   0100
0813: Print           E93B   0674 0822 3802 3804
1158: printEchoFlag   EAB0   0871 0910 1082
0067: QMARK           003F   1324 2856
1332: QMarkFind       EAF5   1325
0093: RAM             0000   0095 0096 0097 0099 0102 0105 0108 0113 0115
3904: RANDOM_ACCESS   0000
2945: RandomSeek      F093   2022 2065
2985: RandomSeekClose F0D1   2978
3023: RandomSeekError F10B   2973
3021: RandomSeekErrorBadSeek F107   2994 3007 3013
3015: RandomSeekExit  F101   2983 3001
2621: ReadBuffer      EF15   1512 3574
3583: ReadDirectory   F33D   2367 2832
3595: ReadDirectory0  F351   3590
3599: ReadDirectory1  F358   3601
3572: ReadDirRecord   F334   3608
1021: ReadEchoRubOut  EA1E   1069
3909: readModeFlag    F4B2   1487 1561 3470
0974: ReadNext        E9ED   1038 1064 1090 1112
0977: ReadNext0       E9EF   1057 1076
3864: readOnlyVector  F48B   1199 1885 2630 2635 2649
0961: ReadString      E9E0   0705 1122 1144
3763: ReAlignMap1     F410   3761
3758: ReAlignMapLoop  F40A   3766
3756: ReAlignVector   F409   3739
1505: RecordOK        EB5C   1493
3849: recordRandom    0021   2105 2176 3850 3851 3852
3850: recordRandomLSB 0021   2950 2953
3851: recordRandomMSB 0022   2955
3852: recordRandomOVF 0023   2969
3848: recordSeq       0020   2173 2713 2975 3849
0235: RecordsPerBlock 0010
0219: RecordsPerExtent 0080   1495 2435 3832
0212: recordsPerSector 0004   0235 0250
1744: RenameLoop      EC49   1754
1093: RepeatLine      EA66   1008
2658: ReselectDisk    EF40   1249 1280 1329 1397 1421 1480 1553 1702 1732 1930 2019 2062 2099
2785: ResetFileWriteFlag EFD8   1623 1652
3745: ResetVectorBit  F402
0369: ReturnToCaller  E832   0343
0385: ReturnToCaller1 E84D   0372 0378 0607
2756: Right           EFB9   2754 2758
3502: RotateRightHLbyB F2FF   3510
3507: RotateRightHLbyB1 F305   3505
0070: RUBOUT          007F   0992
3155: ScanDiskMap     F174   1435 2390
3162: ScanDiskMap0    F17E   3194
3187: ScanDiskMap2    F195   3176
3178: ScanDiskMapWord F18F   3170
3913: searchAddress   F4B6   1395 2826 2836
2820: SearchForDirectoryRecord EFF6   1333 1424 1735 1932 2102 2398 2462 2554 3466
3912: searchLength    F4B5   2823 2850
0264: SectorMask      0003
0229: SectorsPerBlock 0004   0233 0235 0238 0244 0264
0239: SectorsPerCylinder 0024   0242 0243
0228: SectorsPerTrack 0012   0237 0239 0250
3623: Seek            F37C   1511 1633 3620
3628: Seek0           F386   3632
3614: SeekDir         F36B   2536 3350 3607
2248: Select          ED1D   1207 2244
2238: SelectCurrent   ED12   0383 1231 2675
2268: SelectDisk      ED3E   2249
2311: SelectDisk1     ED80   2307
0063: SEMICOLON       003B
3903: SEQ_ACCESS      0001   1482 1556
3410: SetActualRecordAdd F290   1510 1632
3415: SetActualRecordAddLoop F297   3417
1934: SetAttributesLoop EC8E   1942
2342: SetBitLoop      EDAC   2345
2606: SetDataDMA      EF07   1206 1823 2910 3575
2610: SetDirDMA       EF0C   2907 3573
3119: SetDirectoryEntry F15E   2391 2573
2629: SetDiskReadOnly EF1D   1867 3700
2613: SetDMA          EF0F   2608
3081: SetEndDirectory F140   2362 2827 2896 3591
3562: SetExitParamTo1 F32E   1517 1569 3488
2774: SetFileWriteFlag EFCB   2415 2576 3027 3489
3704: SetNewCheckSum  F3E7   3693
2875: SetNextPosition F049   2857 2861 2869
2691: SetRecordVars   EF6C   1489 1566 3482
2730: SetResetMapBit  EF98   3190
0775: SetUserNumber   E91B   0770
3733: SetVectorBit    F3F9   2260 2634
3531: ShiftLeftHLbyB  F318   3535
3519: ShiftRightHLbyB F30E   2740 3523 3617
0952: showCRLF        E9D6   0940 1075 3797
0937: showHashCRLF    E9C0   1096 1139
0941: showHashCRLF1   E9C8   0948
0054: SPACE           0020   0808 0850 0880 0946 1130 1140 1142
0271: STACK_SIZE      0020   3932
3932: stackBottom     F4C7
1161: startingColumn  EAB1   0943 0963 1119
3138: StillInDirectory F167   2844 3120 3698
0241: SystemSectors   0011   0242
0051: TAB             0009   0804 0845
0843: TabOut          E958   0497 0519 0820 0830
0849: TabOut0         E95E   0854
2854: TestNextPosition F02E   2880
0915: ToggleFlag1     E9A9   0913
0103: TopRAM          0007
0238: TotalNumberOfBlocks 02D0
0237: TotalNumberOfSectors 0B40   0238 0243
0115: TPA             0100
0227: TracksPerHead   0050   0237
0029: TRUE            FFFF   0911 0932 1083 1486 2021 2305 2312 2366 2389 2533 2659 2904
0068: UNDER_SCORE     005F
3479: UpdateFCB       F2EE   3454 3468
2928: UpdateRecordVariables F081   1513 1666 1678
1154: usersStack      EAAD   0332 0386
1279: vCloseFile      EADD   0413
2098: vComputeFileSize ECBF   0432
0490: vConsoleIn      E8AD   0397
0518: vConsoleOut     E8BE   0398
1420: vDeleteFile     EB0A   0416
0595: vDirectConIO    E8D1   0402
0604: vDirectConIO1   E8D9   0598
0270: VERSION         0020   0746
1320: vFindFirst      EAE3   0414
1394: vFindNext       EAFB   0415
1838: vGetAllocAddr   EC75   0424
0719: vGetConsoleStatus E900   0407
1798: vGetCurrentDisk EC65   0422
1955: vGetDiskParamBlock ECA0   0428
0627: vGetIOBYTE      E8E7   0403
1774: vGetLoginVector EC5E   0421
1884: vGetReadOnlyMap EC7F   0426
0767: vGetSetUserNumber E90D   0429
0745: vGetVersion     E907   0409
0572: vListOut        E8CD   0401
1700: vMakeFile       EC2C   0419
1247: vOpenFile       EAD4   0412
0670: vPrintString    E8F3   0405
0557: vPunchOut       E8C9   0400
0538: vReaderIn       E8C2   0399
2018: vReadRandom     ECA7   0430
1479: vReadSeq        EB31   0417
0704: vReadString     E8FC   0406
1731: vRenameFile     EC35   0420
2206: vResetDrive     ED0E   0434
1197: vResetSystem    EAB8   0410
1230: vSelectDisk     EAD1   0411
1820: vSetDMA         EC6C   0423
1929: vSetFileAttributes EC86   0427
0647: vSetIOBYTE      E8EE   0404
2171: vSetRandomRecord ECFB   0433
0458: vSystemReset    E8AA   0396
1866: vWriteProtectDisk EC7C   0425
2061: vWriteRandom    ECB3   0431
2233: vWriteRandom0Fill ED11   0437
1552: vWriteSeq       EB74   0418
3790: WaitBeforeBoot  F435   3773 3777 3781
0095: WarmBoot        0000   0925 1034 3787 3792
3400: WasBlockAllocated F28A   1507 1572
0034: WORD            0002   1165 1167
0281: WriteAllocated  0000   1573
2920: WriteBuffer     F079   1636 2909
0283: WriteCleanBuffer 0002   1624 1645
2902: WriteDir        F069   1436 2537 3351
0282: WriteDirectory  0001   2908
3844: writeFlagMask   0080
3941: Z_HighestLocation F507   3942
3942: Z_MemoryLeft    00F8
