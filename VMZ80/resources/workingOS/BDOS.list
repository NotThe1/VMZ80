0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process Search For First (11H)
0005: E800
0006: E800         ; 2019-02-04 Fixed bdosStack problem
0007: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0008: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0009: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0010: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0011: E800         ; 2018-03-02 Refactored the CP/M Suite
0012: E800         ; 2018-02-12 fixed allocate 16 bit problem
0013: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0014: E800         ; 2014-03-14  :  Frank Martyn
0015: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0016: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.asm
0023: E800         ; standard equates
0024: E800
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; not false
0029: E800             FALSE      EQU    0000H
0030: E800             ON         EQU    -1
0031: E800             OFF        EQU    0000H
0032: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0033: E800
0034: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0035: E800             WORD       EQU    2                    ; number of bytes for "word" type
0036: E800
0037: E800
0038: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0039: E800             ZERO       EQU    00H                  ; Zero
0040: E800             EndOfMessage EQU    00H
0041: E800
0042: E800             CTRL_C     EQU    03H                  ; ETX
0043: E800             CTRL_E     EQU    05H                  ; physical eol
0044: E800             CTRL_H     EQU    08H                  ; backspace
0045: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0046: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0047: E800             CTRL_P     EQU    10H                  ; prnt toggle
0048: E800             CTRL_R     EQU    12H                  ; repeat line
0049: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0050: E800             CTRL_U     EQU    15H                  ; line delete
0051: E800             CTRL_X     EQU    18H                  ; =ctl-u
0052: E800             CTRL_Z     EQU    1AH                  ; end of file
0053: E800
0054: E800             NULL       EQU    00H                  ; Null
0055: E800             SOH        EQU    01H                  ; Start of Heading
0056: E800             BELL       EQU    07H                  ; Bell
0057: E800             TAB        EQU    09H                  ; Tab
0058: E800             LF         EQU    0AH                  ; Line Feed
0059: E800             CR         EQU    0DH                  ; Carriage Return
0060: E800             SPACE      EQU    20H                  ; Space
0061: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0062: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0064: E800             PERCENT    EQU    25H                  ; Percent Sign
0065: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0066: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0067: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0068: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0069: E800             COMMA      EQU    2CH                  ; Comma
0070: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0071: E800             PERIOD     EQU    2EH                  ; Period
0072: E800             SLASH      EQU    2FH                  ; /
0073: E800             ASCII_ZERO EQU    30H                  ; zero
0074: E800             COLON      EQU    3AH                  ; Colon
0075: E800
0076: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0077: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0078: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0079: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0080: E800             QMARK      EQU    3FH                  ; Question Mark
0081: E800             UNDER_SCORE EQU    5FH                  ; under score _
0082: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0083: E800             RUBOUT     EQU    7FH                  ; Delete Key
0084: E800
0085: E800
0086: E800             ASCII_A    EQU    'A'
0087: E800             ASCII_C    EQU    'C'
0088: E800             ASCII_K    EQU    'K'
0089: E800             ASCII_N    EQU    'N'
0090: E800             ASCII_Q    EQU    'Q'
0091: E800             ASCII_R    EQU    'R'
0092: E800             ASCII_W    EQU    'W'
0093: E800             ASCII_Y    EQU    'Y'
0094: E800             CARET      EQU    '^'
0095: E800             ASCII_LO_A EQU    'a'
0096: E800             ASCII_LO_K EQU    'k'
0097: E800             ASCII_LO_P EQU    'p'
0098: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0099: E800
0100: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E800                        Include ./osHeader.Z80
0102: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0103: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0104: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0105: E800         ; osHeader.Z80
0106: E800
0107: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0108: E800         ; 2017-03-02 Refactored the CP/M Suite
0109: E800
0110: E800         ; Contains the Equates used by the CP/M system
0111: E800
0112: E800         ;------------------------Page Zero Constants ---------------------------------
0113: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0114: E800
0115: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0116: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0117: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0118: E800
0119: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0120: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0121: E800
0122: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0123: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0124: E800
0125: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0126: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0127: E800
0128: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0129: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0130: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0131: E800         ;-----------------------------------------------------------------------
0132: E800
0133: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0134: E800         ;-----------------------------------------------------------------------
0135: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0136: E800         ;-----------------------------------------------------------------------
0137: E800             END_OF_FILE EQU    1AH                  ; end of file
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;--------------- CP/M Constants -----------------------------------------
0141: E800
0142: E800             CCPLength  EQU    0800H                ; Constant
0143: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0144: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0145: E800
0146: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0147: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0148: E800
0149: E800             MemorySize EQU    64
0150: E800
0151: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0152: E800
0153: E800             BDOSBase   EQU    CCPEntry + CCPLength
0154: E800             BDOSEntry  EQU    BDOSBase
0155: E800
0156: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0157: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0158: E800         ;-----------------------------------------------------------------------
0159: E800
0160: E800         ;------------------- BDOS System Call Equates --------------------------
0161: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0162: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0163: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0164: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0165: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0166: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0167: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0168: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0169: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0170: E800             fCloseFile EQU    10H                  ; closef - Close File
0171: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0172: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0173: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0174: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0175: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0176: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0177: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0178: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0179: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0180: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0181: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0182: E800         ;-----------------------------------------------------------------------
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800
0188: E800         ;*******************************************************************************
0189: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0190: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0191: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0192: E800         ; sector write) or to an allocation block that has already been allocated to a
0193: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0194: E800         ;*******************************************************************************
0195: E800             WriteAllocated EQU    00H
0196: E800             WriteDirectory EQU    01H
0197: E800             WriteCleanBuffer EQU    02H
0198: E800
0199: E800
0200: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E800                        Include ./diskHeader.Z80
0202: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0203: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0204: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0205: E800         ; diskHeader.asm
0206: E800
0207: E800         ; 2017-03-02 Refactored the CP/M Suite
0208: E800
0209: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0210: E800
0211: E800         ; Contains the Equates used by the CP/M system to handle disks
0212: E800
0213: E800
0214: E800         ;*******************************************************************************
0215: E800         ;
0216: E800         ;     Disk related values
0217: E800         ;
0218: E800         ;
0219: E800         ;*******************************************************************************
0220: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0221: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0222: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0223: E800         ; for boot
0224: E800             DiskControlTable EQU    0040H
0225: E800
0226: E800             DiskReadCode EQU    01H                  ; Code for Read
0227: E800             DiskWriteCode EQU    02H                  ; Code for Write
0228: E800
0229: E800
0230: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0231: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0232: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0233: E800
0234: E800             DirEntrySize EQU    20H                  ; (32)
0235: E800             DirBuffSize EQU    cpmRecordSize
0236: E800
0237: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0238: E800
0239: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0240: E800
0241: E800
0242: E800         ;-------------------------------------------------------------------------------------
0243: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0244: E800
0245: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0246: E800             NumberOfHeads EQU    02H                  ; number of heads
0247: E800             TracksPerHead EQU    50H                  ; 80
0248: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0249: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0250: E800             DirectoryBlockCount EQU    02H                  ;
0251: E800         ;-----------------------------------------------------------------------
0252: E800
0253: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0254: E800
0255: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0256: E800
0257: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0258: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0259: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0260: E800
0261: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0262: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0263: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0264: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0265: E800
0266: E800         ;-----------------------------------------------------------------------
0267: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0268: E800         ;-----------------------------------------------------------------------
0269: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0270: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0271: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0272: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0273: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0274: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0275: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0276: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0277: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0278: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0279: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0280: E800             dpb3hdNOH  EQU    NumberOfHeads
0281: E800
0282: E800         ;*******************************************************************************
0283: E800
0284: E800             SectorMask EQU    SectorsPerBlock - 1
0285: E800
0286: E800         ;***************************************************************************
0287: E800
0288: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0289: E800
0290: E800             VERSION    EQU    20H                  ; Version 2.0
0291: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0292: E800             EOD        EQU    -1                   ; End of Directory
0293: E800
0294: E800         ;************************ BIOS Function Constants ***************************;
0295: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0296: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0297: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0298: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0299: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0300: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0301: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0302: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0303: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0304: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0305: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0306: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0307: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0308: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0309: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0310: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0311: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0312: E800         ;************************ BIOS Function Constants ***************************;
0313: E800
0314: E800         ;============================================================================;
0315: E800         ;	BDOS                                                                     ;
0316: E800         ; Calling into   :                                                           ;
0317: E800         ;					Register  C - Contains BDOS Function Code                ;
0318: E800         ;					Register  A - Holds the Byte argument if any             ;
0319: E800         ;					Register DE - Holds the Word argument if any             ;
0320: E800         ; Returning from :                                                           ;
0321: E800         ;					Register  A - The Byte return value if any               ;
0322: E800         ;					Register HL - The Word return value if any               ;
0323: E800         ;                   ( Register A=L and B=H)                                  ;
0324: E800         ;============================================================================;
0325: E800
0326: E800
0327: E800                        ORG    BDOSBase
0328: E800
0329: E800         ;===========================BDOS Entry=======================================;
0330: E800         ;BDOSEntry:                                                                  ;
0331: E800         ;
0332: E800         ;
0333: E800             BdosStart:                      ;
0334: E800         ;	LD		A,C                                                              ;
0335: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0336: E800         ;
0337: E800         ; Save Calling Arguments                                                     ;
0338: E800 ED 53 C3 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0339: E804 7B                     LD     A,E                  ;
0340: E805 32 C2 EA               LD     (paramE),A           ; Save the Byte argument             ;
0341: E808         ; Save users Stack pointer                                                   ;
0342: E808 ED 73 BC EA               LD     (usersStack),SP      ; Save the User's stack				 ;
0343: E80C 31 E4 F5               LD     SP,bdosStack         ; We will use our own stack			 ;
0344: E80F         ;
0345: E80F         ; initialize variables                                                       ;
0346: E80F 21 00 00               LD     HL,0000H             ;
0347: E812 22 C5 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0348: E815 AF                     XOR    A                    ;
0349: E816 32 98 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0350: E819 32 96 F5               LD     (fResel),A           ; Clear re selection flag            ;
0351: E81C         ;
0352: E81C         ; Set up for return to caller when Function Completes                        ;
0353: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0354: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0355: E820         ;
0356: E820         ; is it a valid function number ?	                                         ;
0357: E820         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0358: E820 79                     LD     A,C                  ;
0359: E821 FE 28                  CP     functionCount        ; make sure its a good number        ;
0360: E823 D0                     RET    NC                   ; exit if not a valid function       ;
0361: E824         ;
0362: E824         ; Calculate the index and get vector to go to	                             ;
0363: E824 4B                     LD     C,E                  ; Assume byte argument               ;
0364: E825 21 57 E8               LD     HL,functionTable     ; Get table base                     ;
0365: E828 5F                     LD     E,A                  ; Function number in E               ;
0366: E829 16 00                  LD     D,0                  ;
0367: E82B 19                     ADD    HL,DE                ; Have byte location                 ;
0368: E82C 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0369: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0370: E82E 23                     INC    HL                   ;
0371: E82F 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0372: E830 EB                     EX     DE,HL                ; Vector now in HL                   ;
0373: E831         ;
0374: E831         ; Vector to Function is in HL                                                ;
0375: E831 E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0376: E832         ;===========================BDOS Entry=======================================;
0377: E832         ;===========================BDOS Exit =======================================;
0378: E832         ;arrive here at end of processing to return to user                          ;
0379: E832             ReturnToCaller:                      ;
0380: E832 3A 96 F5               LD     A,(fResel)           ; get re-selection flag              ;
0381: E835 B7                     OR     A                    ; is it set?                         ;
0382: E836 28 15                  JR     Z,ReturnToCaller1    ;
0383: E838         ;re-selection  may have taken place                                         ;
0384: E838 2A C3 EA               LD     HL,(paramDE)         ;
0385: E83B 36 00                  LD     (HL),0               ;
0386: E83D 3A 98 F5               LD     A,(fcbDisk)          ;
0387: E840 B7                     OR     A                    ; Disk = 0?                          ;
0388: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0389: E843         ;
0390: E843 77                     LD     (HL),A               ;
0391: E844 3A 97 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0392: E847 32 C2 EA               LD     (paramE),A           ; and select it                      ;
0393: E84A CD 79 EC               CALL   SelectCurrent        ;
0394: E84D         ;
0395: E84D             ReturnToCaller1:                      ;
0396: E84D 2A BC EA               LD     HL,(usersStack)      ;
0397: E850 F9                     LD     SP,HL                ; restore callers stack              ;
0398: E851 2A C5 EA               LD     HL,(exitParameterWord) ;
0399: E854 7D                     LD     A,L                  ;
0400: E855 44                     LD     B,H                  ; BA = exitParameterWord             ;
0401: E856 C9                     RET                         ;
0402: E857         ;===========================BDOS Exit =======================================;
0403: E857
0404: E857         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0405: E857             functionTable:                      ;
0406: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0407: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0408: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0409: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0410: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0411: E861 CD E8                  DW     vListOut             ;   5 - List Output                  ;
0412: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0413: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0414: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0415: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                 ;
0416: E86B FC E8                  DW     vReadString          ;   A - Read Console String          ;
0417: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0418: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0419: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0420: E871 C7 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0421: E873 E0 EA                  DW     vSelectDisk          ;   E - Select Disk                  ;
0422: E875 E3 EA                  DW     vOpenFile            ;   F - Open File                    ;
0423: E877 EC EA                  DW     vCloseFile           ;  10 - Close File                   ;
0424: E879 F2 EA                  DW     vFindFirst           ;  11 - Search For First             ;
0425: E87B B8 F1                  DW     vFindNext            ;  12 - Search for Next              ;
0426: E87D C7 F1                  DW     vDeleteFile          ;  13 - Delete File                  ;
0427: E87F D0 F1                  DW     vReadSeq             ;  14 - Read Sequential              ;
0428: E881 D7 F1                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0429: E883 DE F1                  DW     vMakeFile            ;  16 - Make File                    ;
0430: E885 E7 F1                  DW     vRenameFile          ;  17 - Rename File                  ;
0431: E887 0B EB                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0432: E889 12 EB                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0433: E88B 19 EB                  DW     vSetDMA              ;  1A - Set DMA address              ;
0434: E88D 22 EB                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0435: E88F 29 EB                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0436: E891 2C EB                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0437: E893 70 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0438: E895 33 EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0439: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0440: E899 3B EB                  DW     vReadRandom          ;  21 - Read Random                  ;
0441: E89B 41 EB                  DW     vWriteRandom         ;  22 - Write Random                 ;
0442: E89D 47 EB                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0443: E89F 4D EB                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0444: E8A1 3A EB                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0445: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0446: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0447: E8A7 50 EB                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0448: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0449: E8A9         ;
0450: E8A9             DUMMY:                          ;
0451: E8A9 76                     HALT                        ;
0452: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0453: E8AA
0454: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0455: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0456: E8AA         ; same as the warm boot function invoked when you transfer control to the    ;
0457: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0458: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0459: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0460: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0461: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0462: E8AA         ;																			 ;
0463: E8AA         ;			Function Code	 :	C = 00H                                      ;
0464: E8AA         ;			Entry Parameters:	None                                         ;
0465: E8AA         ;			Exit Parameters :	Does Not Return								 ;
0466: E8AA         ;																			 ;
0467: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0468: E8AA             vSystemReset:
0469: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0470: E8AD
0471: E8AD         ;****************************************************************************;
0472: E8AD         ;								IOByte device I/O							 ;
0473: E8AD         ;****************************************************************************;
0474: E8AD
0475: E8AD
0476: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0477: E8AD         ;  This function reads the next byte of data from the console keyboard and   ;
0478: E8AD         ; puts it into register A. If the character input is a graphic character, it ;
0479: E8AD         ; will be echoed back to the console. The only control characters that are   ;
0480: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0481: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0482: E8AD         ; move the cursor to the next multiple of eight columns. All of the other    ;
0483: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0484: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0485: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0486: E8AD         ; console output should also be sent to the list device. If CONTROL-S is     ;
0487: E8AD         ; found, further output will be suspended until you type another character.  ;
0488: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0489: E8AD         ; pressed and disable it the second time. If there is no incoming data       ;
0490: E8AD         ; character, this function will wait until there is one.                     ;
0491: E8AD         ;                                                                            ;
0492: E8AD         ; This is a blocking function                                                ;
0493: E8AD         ;																			 ;
0494: E8AD         ;																			 ;
0495: E8AD         ;			Function Code	:	C = 01H                                      ;
0496: E8AD         ;			Entry Parameters:	None                                         ;
0497: E8AD         ;			Exit Parameters :	A = Data byte from console					 ;
0498: E8AD         ;																			 ;
0499: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0500: E8AD             vConsoleIn:
0501: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0502: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0503: E8B3 D8                     RET    C                    ; return nothing to echo
0504: E8B4
0505: E8B4 F5                     PUSH   AF                   ; Save printable character
0506: E8B5 4F                     LD     C,A
0507: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0508: E8B9 F1                     POP    AF                   ; retrieve exit value
0509: E8BA
0510: E8BA 32 C5 EA               LD     (exitParameterByte),A
0511: E8BD C9                     RET
0512: E8BE
0513: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0514: E8BE         ;  This function outputs the data byte in register E to the console. As with ;
0515: E8BE         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0516: E8BE         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0517: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0518: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0519: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0520: E8BE         ; printer is  toggled on or off                                              ;
0521: E8BE         ;																			 ;
0522: E8BE         ;			Function Code	:	C = 02H                                      ;
0523: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0524: E8BE         ;			Exit Parameters :	None										 ;
0525: E8BE         ;																			 ;
0526: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0527: E8BE         ;BDOS put parameter in C before entering this routine
0528: E8BE             vConsoleOut:
0529: E8BE CD 58 E9               CALL   TabOut
0530: E8C1 C9                     RET
0531: E8C2
0532: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0533: E8C2         ;   function reads the next character from the logical "reader" device into  ;
0534: E8C2         ; register A. In practice, the physical device that is accessed depends      ;
0535: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0536: E8C2         ; reader at all; this function will return some arbitrary value such as lAH  ;
0537: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0538: E8C2         ; Control is not returned to the calling program until a character has been  ;
0539: E8C2         ; read.                                                                      ;
0540: E8C2         ;                                                                            ;
0541: E8C2         ; This is a blocking function                                                ;
0542: E8C2         ;																			 ;
0543: E8C2         ;			Function Code	:	C = 03H                                      ;
0544: E8C2         ;			Entry Parameters:	None										 ;
0545: E8C2         ;			Exit Parameters :	A = Character Input							 ;
0546: E8C2         ;																			 ;
0547: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0548: E8C2             vReaderIn:
0549: E8C2 CD 15 F6               CALL   bcReader
0550: E8C5 32 C5 EA               LD     (exitParameterWord),A
0551: E8C8 C9                     RET
0552: E8C9
0553: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0554: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0555: E8C9         ; specified character from register E to the logical punch device. Again,    ;
0556: E8C9         ; the actual physical device used, if any, is determined by the BIOS.        ;
0557: E8C9         ; There is no set standard for this device; in some systems the punch        ;
0558: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0559: E8C9         ; output to it.                                                              ;
0560: E8C9         ;																			 ;
0561: E8C9         ;			Function Code	:	C = 04H                                      ;
0562: E8C9         ;			Entry Parameters:	E = Data byte to be output					 ;
0563: E8C9         ;			Exit Parameters :	None										 ;
0564: E8C9         ;																			 ;
0565: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0566: E8C9         ;BDOS put parameter in C before entering this routine
0567: E8C9             vPunchOut:
0568: E8C9 CD 12 F6               CALL   bcPunch
0569: E8CC C9                     RET
0570: E8CD
0571: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0572: E8CD         ;  This function outputs the specified byte in register E to the logical     ;
0573: E8CD         ; list device. As with the reader and the punch, the physical device used    ;
0574: E8CD         ; depends entirely on the BIOS.                                              ;
0575: E8CD         ;																			 ;
0576: E8CD         ;			Function Code	:	C = 05H                                      ;
0577: E8CD         ;			Entry Parameters:	E = Data byte to be output					 ;
0578: E8CD         ;			Exit Parameters :	None										 ;
0579: E8CD         ;																			 ;
0580: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0581: E8CD         ;BDOS put parameter in C before entering this routine
0582: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0583: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0584: E8D0 C9                     RET
0585: E8D1
0586: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0587: E8D1         ;  This function serves double duty: it both inputs and outputs characters   ;
0588: E8D1         ; from the console. However, it bypasses the normal control characters and   ;
0589: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0590: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0591: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0592: E8D1         ; then E contains a valid ASCII character that is output to the console.     ;
0593: E8D1         ;  This function works well provided you never have to send a value ofOFFH   ;
0594: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0595: E8D1         ; binary data, you cannot use this function, since these values are likely   ;
0596: E8D1         ; to be part of the data stream.                                             ;
0597: E8D1         ;                                                                            ;
0598: E8D1         ;			Function Code	:	C = 06H                                      ;
0599: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0600: E8D1         ;								E = Other than 0FFH for Output				 ;
0601: E8D1         ;			Exit Parameters :	A = Input byte or status					 ;
0602: E8D1         ;																			 ;
0603: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0604: E8D1         ;BDOS put parameter in C before entering this routine
0605: E8D1             vDirectConIO:
0606: E8D1 79                     LD     A,C
0607: E8D2 3C                     INC    A
0608: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0609: E8D5         ; send byte to console
0610: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0611: E8D8 C9                     RET
0612: E8D9
0613: E8D9         ;read byte/status from console
0614: E8D9             vDirectConIO1:
0615: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0616: E8DC B7                     OR     A                    ; 00 means not data ready
0617: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0618: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0619: E8E3 32 C5 EA               LD     (exitParameterByte),A ; Save it
0620: E8E6 C9                     RET
0621: E8E7
0622: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0623: E8E7         ; This function places the current value of the IOBYTE in register A.        ;
0624: E8E7         ;                                                                            ;
0625: E8E7         ; The IOBYTE structure:                                                      ;
0626: E8E7         ;								+-------+-------+-------+-------+            ;
0627: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0628: E8E7         ;								+-------+-------+-------+-------+            ;
0629: E8E7         ;				Logical Device     List | Punch | Reader|Console             ;
0630: E8E7         ;                                                                            ;
0631: E8E7         ;                                                                            ;
0632: E8E7         ;			Function Code	:	C = 07H                                      ;
0633: E8E7         ;			Entry Parameters:	None					  		  			 ;
0634: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0635: E8E7         ;																			 ;
0636: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0637: E8E7             vGetIOBYTE:
0638: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0639: E8EA 32 C5 EA               LD     (exitParameterWord),A ; Return it to caller
0640: E8ED C9                     RET
0641: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0642: E8EE         ; This function sets the IOBYTE         									 ;
0643: E8EE         ;                                                                            ;
0644: E8EE         ; The IOBYTE structure:                                                      ;
0645: E8EE         ;								+-------+-------+-------+-------+            ;
0646: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0647: E8EE         ;								+-------+-------+-------+-------+            ;
0648: E8EE         ;				Logical Device     List | Punch | Reader|Console             ;
0649: E8EE         ;                                                                            ;
0650: E8EE         ;                                                                            ;
0651: E8EE         ;			Function Code	:	C = 08H                                      ;
0652: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0653: E8EE         ;			Exit Parameters :	None                                         ;
0654: E8EE         ;																			 ;
0655: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0656: E8EE         ;BDOS put parameter in C before entering this routine
0657: E8EE             vSetIOBYTE:
0658: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0659: E8F1 71                     LD     (HL),C               ; Place new vale in it
0660: E8F2 C9                     RET
0661: E8F3
0662: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0663: E8F3         ;  This function outputs a string of characters to the console device. The   ;
0664: E8F3         ; address of this string is in registers DE. You must make sure that the last;
0665: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0666: E8F3         ; for the end of the string.                                                 ;
0667: E8F3         ;  The "$" itself does not get output to the console.                        ;
0668: E8F3         ;                                                                            ;
0669: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0670: E8F3         ; described, checks to see if there is an incoming character, and checks for ;
0671: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0672: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0673: E8F3         ; the printer).                                                              ;
0674: E8F3         ;                                                                            ;
0675: E8F3         ;			Function Code	:	C = 09H                                      ;
0676: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0677: E8F3         ;			Exit Parameters :	None							             ;
0678: E8F3         ;																			 ;
0679: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0680: E8F3             vPrintString:
0681: E8F3 2A C3 EA               LD     HL,(paramDE)         ; Get address of the string
0682: E8F6 4D                     LD     C,L
0683: E8F7 44                     LD     B,H                  ; Put it into BC for call
0684: E8F8 CD 3B E9               CALL   Print                ; out to console
0685: E8FB C9                     RET
0686: E8FC
0687: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0688: E8FC         ;  This function reads a string of characters from the console device        ;
0689: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0690: E8FC         ; editing is possible: the operator can backspace, cancel the line and start ;
0691: E8FC         ; over, and use all the normal control functions. What you will ultimately   ;
0692: E8FC         ; see in the buffer is the final version of the character string entered,    ;
0693: E8FC         ; without any of the errors or control characters used to do the line editing;
0694: E8FC         ;                                                                            ;
0695: E8FC         ;  The buffer that you define has a special format. The first byte in the    ;
0696: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0697: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0698: E8FC         ; were actually placed in the buffer. The following bytes contain            ;
0699: E8FC         ; the characters of the string. Character input will cease either when a     ;
0700: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0701: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0702: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0703: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0704: E8FC         ; the "characters input" byte to O. If you attempt to input more than the    ;
0705: E8FC         ; maximum number of characters, the "characters input" count will be the     ;
0706: E8FC         ; same as the maximum value allowed.                                         ;
0707: E8FC         ;                                                                            ;
0708: E8FC         ;			Function Code	:	C = 0AH                                      ;
0709: E8FC         ;			Entry Parameters:	DE = Address string buffer					 ;
0710: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0711: E8FC         ;																			 ;
0712: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0713: E8FC             vReadString:
0714: E8FC CD E0 E9               CALL   ReadString
0715: E8FF C9                     RET
0716: E900
0717: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0718: E900         ; This function tells you whether a console input character is waiting to be ;
0719: E900         ;processed. Unlike the Console Input functions, which will wait until there  ;
0720: E900         ;is input,this function simply checks and returns immediately.               ;
0721: E900         ;                                                                            ;
0722: E900         ;			Function Code	:	C = 0BH                                      ;
0723: E900         ;			Entry Parameters:	None										 ;
0724: E900         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0725: E900         ;								A = FFH	if incoming Data					 ;
0726: E900         ;																			 ;
0727: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0728: E900             vGetConsoleStatus:
0729: E900 CD 8C E9               CALL   ConBreak
0730: E903 32 C5 EA               LD     (exitParameterByte),A
0731: E906 C9                     RET
0732: E907
0733: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0734: E907         ;  This function tells you which version of CP/M you are currently running.  ;
0735: E907         ; A two-byte value is returned:                                              ;
0736: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0737: E907         ;	L = OOH for all releases before CP/M 2.0                                 ;
0738: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0739: E907         ;		and so on for any subsequent releases.                               ;
0740: E907         ;                                                                            ;
0741: E907         ; This information is of interest only if your program has some version      ;
0742: E907         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0743: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0744: E907         ; Therefore, if your program uses Random I/O, put this check at the          ;
0745: E907         ; beginning to ensure that it is indeed running under the appropriate        ;
0746: E907         ; version of CP/M.                                                           ;
0747: E907         ;                                                                            ;
0748: E907         ;			Function Code	:	C = 0CH                                      ;
0749: E907         ;			Entry Parameters:	None										 ;
0750: E907         ;			Exit Parameters :	HL =Version Number Code						 ;
0751: E907         ;								A = FFH	if incoming Data					 ;
0752: E907         ;																			 ;
0753: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0754: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0755: E907 3E 20                  LD     A,VERSION
0756: E909 32 C5 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0757: E90C C9                     RET
0758: E90D
0759: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0760: E90D         ;  This subroutine either sets or gets the current user number. The current  ;
0761: E90D         ; user number determines which file directory entries are matched during all ;
0762: E90D         ; disk file operations. When you call this function, the contents of the     ;
0763: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0764: E90D         ; will return the current user number in the A register. If you set E to a   ;
0765: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0766: E90D         ; will set the current user number to this value.                            ;
0767: E90D         ;                                                                            ;
0768: E90D         ;			Function Code	:	C = 0CH                                      ;
0769: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0770: E90D         ;								  = 0 to 15 to set User Number				 ;
0771: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0772: E90D         ;								A = FFH	if incoming Data					 ;
0773: E90D         ;																			 ;
0774: E90D         ;                                                                            ;
0775: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0776: E90D             vGetSetUserNumber:
0777: E90D 3A C2 EA               LD     A,(paramE)
0778: E910 FE FF                  CP     0FFH
0779: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0780: E914 3A 65 F5               LD     A,(currentUserNumber)
0781: E917 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0782: E91A C9                     RET
0783: E91B
0784: E91B             SetUserNumber:
0785: E91B E6 0F                  AND    LO_NIBBLE_MASK
0786: E91D 32 65 F5               LD     (currentUserNumber),A
0787: E920 C9                     RET
0788: E921
0789: E921         ;****************************************************************************;
0790: E921         ;								Character Support Routines					 ;
0791: E921         ;****************************************************************************;
0792: E921
0793: E921
0794: E921         ;-------------------- Return a Character from the console -------------------;
0795: E921         ;return byte from buffer or read from the console                            ;
0796: E921             ConIn:                          ;
0797: E921 21 BE EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0798: E924 7E                     LD     A,(HL)               ;
0799: E925 36 00                  LD     (HL),0               ;
0800: E927 B7                     OR     A                    ;
0801: E928 C0                     RET    NZ                   ;
0802: E929         ;
0803: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0804: E92C         ;-------------------- Return a Character from the console -------------------;
0805: E92C
0806: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0807: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0808: E92C             IsPrintableASCII:                      ;
0809: E92C FE 0D                  CP     CR                   ;
0810: E92E C8                     RET    Z                    ; carriage return?                                                  ;
0811: E92F FE 0A                  CP     LF                   ;
0812: E931 C8                     RET    Z                    ; line feed?                                                        ;
0813: E932 FE 09                  CP     TAB                  ;
0814: E934 C8                     RET    Z                    ; TAB?                                                              ;
0815: E935 FE 08                  CP     CTRL_H               ;
0816: E937 C8                     RET    Z                    ; backspace?                                                        ;
0817: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0818: E93A C9                     RET                         ;
0819: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0820: E93B
0821: E93B         ;------------------ Print character from (BC) until  $ found ----------------;
0822: E93B             Print:                          ;
0823: E93B 0A                     LD     A,(BC)               ; Get the next character             ;
0824: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0825: E93E C8                     RET    Z                    ;  exit if yes                       ;
0826: E93F 03                     INC    BC                   ; Update the pointer                 ;
0827: E940 C5                     PUSH   BC                   ; Save it                            ;
0828: E941 4F                     LD     C,A                  ; Does Byte require                  ;
0829: E942 CD 58 E9               CALL   TabOut               ;  special attention - check         ;
0830: E945 C1                     POP    BC                   ; Retrieve the pointer				 ;
0831: E946 18 F3                  JR     Print                ; Loop back                          ;
0832: E948         ;------------------ Print character from (BC) until  $ found ----------------;
0833: E948
0834: E948         ;-- Send printable character to console. Precede with Caret if needed -------;
0835: E948         ; character is in Reg C                                                      ;
0836: E948             CaretOut:                       ;
0837: E948 79                     LD     A,C                  ;
0838: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0839: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0840: E94E         ; send preceding up arrow                                                    ;
0841: E94E F5                     PUSH   AF                   ; Save the character                 ;
0842: E94F 0E 5E                  LD     C,CARET              ;
0843: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0844: E954 F1                     POP    AF                   ; Get the character                  ;
0845: E955 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0846: E957 4F                     LD     C,A                  ; Set up to print                    ;
0847: E958         ; fall thru to TabbOut                                                       ;
0848: E958         ;-- Send printable character to console. Precede with Caret if needed -------;
0849: E958
0850: E958         ;------------- Send printable character to console. Expand if TAB -----------;
0851: E958         ; character is in Reg C                                                      ;
0852: E958             TabOut:                         ;
0853: E958 79                     LD     A,C                  ;
0854: E959 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0855: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0856: E95E         ;
0857: E95E         ; TAB encountered                                                           ;
0858: E95E             TabOut0:                        ;
0859: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0860: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                    ;
0861: E963 3A C1 EA               LD     A,(columnPosition)   ; Get Column position                ;
0862: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0863: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0864: E96A C9                     RET                         ;
0865: E96B         ;------------- Send printable character to console. Expand if TAB -----------;
0866: E96B
0867: E96B         ;-------------------------- Send character to console -----------------------;
0868: E96B         ; C  = Character to be output                                                ;
0869: E96B             ConsoleOut:                      ;
0870: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0871: E96B C5                     PUSH   BC                   ; Save character and Count           ;
0872: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0873: E96F C1                     POP    BC                   ;
0874: E970 C5                     PUSH   BC                   ; Get/save character                 ;
0875: E971         ; Send character to Console	                                                 ;
0876: E971 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0877: E974 C1                     POP    BC                   ;
0878: E975 C5                     PUSH   BC                   ; Get/save character                 ;
0879: E976         ; is the data to be output to print device?                                  ;
0880: E976 3A BF EA               LD     A,(printEchoFlag)    ;
0881: E979 B7                     OR     A                    ;
0882: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0883: E97D C1                     POP    BC                   ; Get the character                  ;
0884: E97E         ;
0885: E97E 79                     LD     A,C                  ; Put character to ACC               ;
0886: E97F 21 C1 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0887: E982 34                     INC    M                    ; increment the ColumnPosition       ;
0888: E983         ;
0889: E983 FE 20                  CP     SPACE                ;
0890: E985 D0                     RET    NC                   ; Exit if ASCII printable            ;
0891: E986         ;
0892: E986 FE 0A                  CP     LF                   ;
0893: E988 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0894: E989         ;
0895: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0896: E98B C9                     RET                         ;
0897: E98C         ;-------------------------- Send character to console -----------------------;
0898: E98C
0899: E98C         ;--------------------  Check for Status and Control S or C ------------------;
0900: E98C         ;  Returns:																	 ;
0901: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0902: E98C         ;			ACC = 00   No data Pending										 ;
0903: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0904: E98C         ;                                                                            ;
0905: E98C             ConBreak:                       ;
0906: E98C 3A BE EA               LD     A,(keyboardByte)     ;
0907: E98F B7                     OR     A                    ; If there is a char waiting         ;
0908: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0909: E992         ;
0910: E992 CD 06 F6               CALL   bcConst              ; Get status                         ;
0911: E995 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0912: E997 C8                     RET    Z                    ; Return 00 No data pending          ;
0913: E998         ;
0914: E998 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0915: E99B         ;
0916: E99B FE 10                  CP     CTRL_P               ;
0917: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0918: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0919: E99F 21 BF EA               LD     HL,printEchoFlag     ;
0920: E9A2 3E FF                  LD     A,TRUE               ;
0921: E9A4 BE                     CP     (HL)                 ;
0922: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0923: E9A7 3E 00                  LD     A,FALSE              ;
0924: E9A9             ToggleFlag1:                      ;
0925: E9A9 77                     LD     (HL),A               ;
0926: E9AA 18 0C                  JR     NothingWaiting       ;
0927: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0928: E9AC             CheckCTL_S:                      ;
0929: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0930: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0931: E9B0         ;
0932: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0933: E9B3 FE 03                  CP     CTRL_C               ;
0934: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0935: E9B8             NothingWaiting:                      ;
0936: E9B8 AF                     XOR    A                    ;
0937: E9B9 C9                     RET                         ; Set ACC = 0 and return             ;
0938: E9BA             ConBreak0:                      ;
0939: E9BA 32 BE EA               LD     (keyboardByte),A     ; save the byte                      ;
0940: E9BD             ConBreak1:                      ;
0941: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0942: E9BF C9                     RET                         ;
0943: E9C0         ;--------------------  Check for Status and Control S or C ------------------;
0944: E9C0
0945: E9C0         ;------------------------  Console Output Utilities -------------------------;
0946: E9C0             showHashCRLF:                      ;
0947: E9C0 0E 23                  LD     C,HASH_TAG           ;
0948: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                  ;
0949: E9C5 CD D6 E9               CALL   showCRLF             ;
0950: E9C8             showHashCRLF1:                      ;
0951: E9C8 3E C1                  LD     A,columnPosition     ;
0952: E9CA 21 C0 EA               LD     HL,startingColumn    ;
0953: E9CD BF                     CP     A,M                  ;
0954: E9CE D0                     RET    NC                   ;
0955: E9CF 0E 20                  LD     C,SPACE              ;
0956: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0957: E9D4 18 F2                  JR     showHashCRLF1        ;
0958: E9D6         ;------------------------  Console Output Utilities -------------------------;
0959: E9D6
0960: E9D6         ;------------------------  Send Carriage Return and Line Feed ---------------;
0961: E9D6             showCRLF:                       ;
0962: E9D6 0E 0D                  LD     C,CR                 ;
0963: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0964: E9DB 0E 0A                  LD     C,LF                 ;
0965: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0966: E9E0         ;------------------------  Send Carriage Return and Line Feed ---------------;
0967: E9E0
0968: E9E0         ;------------------------- Read a $ terminated String -----------------------;
0969: E9E0         ;read to paramDE address (max length, current length, buffer)               ;
0970: E9E0             ReadString:                      ;
0971: E9E0 3A C1 EA               LD     A,(columnPosition)   ;
0972: E9E3 32 C0 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0973: E9E6 2A C3 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0974: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0975: E9EA 23                     INC    HL                   ; Point at actual bytes read         ;
0976: E9EB 06 00                  LD     B,0                  ; Initialize Current Count           ;
0977: E9ED         ;
0978: E9ED         ; B = Current Count                                                      ;
0979: E9ED         ; C = Maximum characters                                                 ;
0980: E9ED         ; HL= Insertion Pointer                                                  ;
0981: E9ED         ;
0982: E9ED         ; read next character, BC, HL active                                        ;
0983: E9ED             ReadNext:                       ;
0984: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0985: E9EE E5                     PUSH   HL                   ; Save pointer                       ;
0986: E9EF             ReadNext0:                      ;
0987: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character             ;
0988: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0989: E9F4 E1                     POP    HL                   ; Restore Pointer					 ;
0990: E9F5 C1                     POP    BC                   ; Restore Current Index and Max Count;
0991: E9F6         ;Is It Carriage Return                                                       ;
0992: E9F6 FE 0D                  CP     CR                   ;
0993: E9F8 CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0994: E9FB FE 0A                  CP     LF                   ;
0995: E9FD         ;Is It Linefeed                                                              ;
0996: E9FD CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0997: EA00         ;Is It BackSpace                                                             ;
0998: EA00 FE 08                  CP     CTRL_H               ;
0999: EA02 CA 48 EA               JP     Z,BSspaceBS          ;
1000: EA05             IsItRubout:                      ;
1001: EA05 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
1002: EA07 CA 52 EA               JP     Z,ItIsRubout         ;
1003: EA0A             IsPhysicalEOL:                      ;
1004: EA0A FE 05                  CP     CTRL_E               ;
1005: EA0C CA 5D EA               JP     Z,ItIsPhysicalEOL    ;
1006: EA0F             IsItPrintToggle:                      ;
1007: EA0F FE 10                  CP     CTRL_P               ;
1008: EA11 CA 65 EA               JP     Z,ItIsPrintToggle    ;
1009: EA14             IsItDeleteTheLineX:                      ;
1010: EA14 FE 18                  CP     CTRL_X               ;
1011: EA16 CA 8E EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1012: EA19             IsItDeleteTheLineU:                      ;
1013: EA19 FE 15                  CP     CTRL_U               ;
1014: EA1B CA AC EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1015: EA1E         ;Retype the line                                                             ;
1016: EA1E FE 12                  CP     CTRL_R               ;
1017: EA20 CA 75 EA               JP     Z,RepeatLine         ;
1018: EA23
1019: EA23         ;....................... Echo input back to the Console  ....................;
1020: EA23         ; Full Duplex								                                 ;
1021: EA23         ; A = Character to display	                                                 ;
1022: EA23         ; B = current char count                                                     ;
1023: EA23         ; C = maximum buffer length                                                  ;
1024: EA23         ; HL= buffer pointer                                                         ;
1025: EA23         ;ReadEcho                                                                    ;
1026: EA23 04                     INC    B                    ; Increment byte count		         ;
1027: EA24 23                     INC    HL                   ; Advance the Pointer                ;
1028: EA25 77                     LD     (HL),A               ; Put char in buffer                 ;
1029: EA26         ;
1030: EA26             ReadEchoRubOut:                      ;
1031: EA26 C5                     PUSH   BC                   ; Save index and length              ;
1032: EA27 E5                     PUSH   HL                   ; Save the Pointer                   ;
1033: EA28 4F                     LD     C,A                  ; Get char                           ;
1034: EA29 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1035: EA2C E1                     POP    HL                   ; Restore the Pointer                ;
1036: EA2D C1                     POP    BC                   ; Restore index and length           ;
1037: EA2E 7E                     LD     A,(HL)               ; Recall char                        ;
1038: EA2F         ; check for Warm Boot                                                        ;
1039: EA2F FE 03                  CP     CTRL_C               ;
1040: EA31 78                     LD     A,B                  ; Get Line position                  ;
1041: EA32 C2 3A EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1042: EA35 FE 01                  CP     1                    ; Beginning of the Line?             ;
1043: EA37 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1044: EA3A         ; Check to see if we are at the end of the buffer                            ;
1045: EA3A             AreWeAtEndOfBuffer:                      ;
1046: EA3A B9                     CP     C                    ; Over Max ?					     ;
1047: EA3B DA ED E9               JP     C,ReadNext           ;  no, Go for more				     ;
1048: EA3E         ;
1049: EA3E         ; At the end of read                                  					     ;
1050: EA3E             EndRead:                        ;
1051: EA3E         ; 	POP		HL                                                               ;
1052: EA3E 2A C3 EA               LD     HL,(paramDE)         ;
1053: EA41 23                     INC    HL                   ;
1054: EA42         ;
1055: EA42 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1056: EA43 0E 0D                  LD     C,CR                 ;
1057: EA45 C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1058: EA48         ;....................... Echo input back to the Console  ....................;
1059: EA48         ;.......................... Backspace SPACE BackSpace .......................;
1060: EA48             BSspaceBS:                      ;
1061: EA48 05                     DEC    B                    ;
1062: EA49 2B                     DEC    HL                   ;
1063: EA4A C5                     PUSH   BC                   ;
1064: EA4B E5                     PUSH   HL                   ;
1065: EA4C CD 9F EA               CALL   BackUp               ;
1066: EA4F C3 EF E9               JP     ReadNext0            ;
1067: EA52         ;.......................... Backspace SPACE BackSpace .......................;
1068: EA52         ;.......................... It is RubOut ....................................;
1069: EA52             ItIsRubout:                      ;
1070: EA52         ; RUBOUT if possible                                                         ;
1071: EA52 78                     LD     A,B                  ; Are we at the start of the line    ;
1072: EA53 B7                     OR     A                    ;
1073: EA54 CA ED E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1074: EA57         ;adjust pointers back one                                                    ;
1075: EA57 7E                     LD     A,(HL)               ; ACC = current character            ;
1076: EA58 05                     DEC    B                    ; Adjust the index			    	 ;
1077: EA59 2B                     DEC    HL                   ; Adjust the pointer                 ;
1078: EA5A C3 26 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1079: EA5D         ;.......................... It is RubOut ....................................;
1080: EA5D         ;.......................... It is PhysicalEOL ...............................;
1081: EA5D             ItIsPhysicalEOL:                      ;
1082: EA5D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1083: EA5E E5                     PUSH   HL                   ; Save pointer                       ;
1084: EA5F CD D6 E9               CALL   showCRLF             ; Make new line                      ;
1085: EA62 C3 EF E9               JP     ReadNext0            ;   and go for next char   			 ;
1086: EA65         ;.......................... It is PhysicalEOL ...............................;
1087: EA65         ;.......................... It is PrintToggle ...............................;
1088: EA65             ItIsPrintToggle:                      ;
1089: EA65 E5                     PUSH   HL                   ; Save pointer                       ;
1090: EA66         ; Toggle the printEcho Flag                                                  ;
1091: EA66 21 BF EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1092: EA69 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1093: EA6B BE                     CP     (HL)                 ; Is the flag true?                  ;
1094: EA6C 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1095: EA6E 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1096: EA70             IsItPrintToggle1:                      ;
1097: EA70 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1098: EA71 E1                     POP    HL                   ; Restore pointer                    ;
1099: EA72 C3 ED E9               JP     ReadNext             ;   and for another char             ;
1100: EA75         ;.......................... It is PrintToggle ...............................;
1101: EA75         ;.......................... RepeatLine ......................................;
1102: EA75             RepeatLine:                      ;
1103: EA75 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1104: EA76 E5                     PUSH   HL                   ;  for exit                          ;
1105: EA77 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1106: EA7A         ;
1107: EA7A 2A C3 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1108: EA7D 23                     INC    HL                   ; Skip past character count          ;
1109: EA7E         ;
1110: EA7E             LL1:                            ;
1111: EA7E 23                     INC    HL                   ; Point at next char to display      ;
1112: EA7F C5                     PUSH   BC                   ; Save counter, in B                 ;
1113: EA80 E5                     PUSH   HL                   ; Save buffer pointer                ;
1114: EA81 4E                     LD     C,M                  ; Get the next character             ;
1115: EA82 CD 48 E9               CALL   CaretOut             ; Display it                         ;
1116: EA85 E1                     POP    HL                   ; Restore                            ;
1117: EA86 C1                     POP    BC                   ;  the counter and pointer           ;
1118: EA87 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1119: EA89 E1                     POP    HL                   ; Restore values                     ;
1120: EA8A C1                     POP    BC                   ;  from routine entry                ;
1121: EA8B C3 ED E9               JP     ReadNext             ; Done here !                        ;
1122: EA8E         ;.......................... RepeatLine ......................................;
1123: EA8E         ;.......................... Delete The Line .................................;
1124: EA8E             DeleteTheLine:                      ;
1125: EA8E E1                     POP    HL                   ; Adjust Stack                       ;
1126: EA8F         ;                                             ;
1127: EA8F             DeleteTheLine1:                      ;
1128: EA8F 3A C0 EA               LD     A,(startingColumn)   ;
1129: EA92 21 C1 EA               LD     HL,columnPosition    ;
1130: EA95 BE                     CP     M                    ; Start of line ?                    ;
1131: EA96 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1132: EA99 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1133: EA9A CD 9F EA               CALL   BackUp               ; Clear 1 column                     ;
1134: EA9D 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1135: EA9F         ;.......................... Delete The Line .................................;
1136: EA9F         ;------------------------ Back-up one screen position -----------------------;
1137: EA9F             BackUp:                         ;
1138: EA9F CD A7 EA               CALL   BackUp1              ; Send Backspace                     ;
1139: EAA2 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1140: EAA4 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1141: EAA7         ;does not affect column count                                                ;
1142: EAA7             BackUp1:                        ;
1143: EAA7 0E 08                  LD     C,CTRL_H             ;
1144: EAA9 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1145: EAAC         ;------------------------ Back-up one screen position -----------------------;
1146: EAAC         ;.......................... Ignore The Line .................................;
1147: EAAC             IgnoreTheLine:                      ;
1148: EAAC CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1149: EAAF 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1150: EAB1 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1151: EAB4 0E 20                  LD     C,SPACE              ;
1152: EAB6 CD 0C F6               CALL   bcConout             ;
1153: EAB9 C3 E0 E9               JP     ReadString           ; Start all over                     ;
1154: EABC         ;.......................... Ignore The Line .................................;
1155: EABC
1156: EABC         ;------------------------- Read a $ terminated String -----------------------;
1157: EABC
1158: EABC         ;****************************************************************************
1159: EABC         ;                           DATA AREA                                       *
1160: EABC         ;****************************************************************************
1161: EABC
1162: EABC         ;------------------------------Non Disk Data Area ---------------------------;
1163: EABC             usersStack: DS     2                    ; entry stack pointer                ;
1164: EABE         ;
1165: EABE 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1166: EABF         ;
1167: EABF 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1168: EAC0         ;
1169: EAC0         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1170: EAC0 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1171: EAC1 00          columnPosition: DB     0                    ; Current Column position            ;
1172: EAC2         ;
1173: EAC2             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1174: EAC3             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1175: EAC5             exitParameterByte:                      ; Byte returned Value                ;
1176: EAC5             exitParameterWord: DS     WORD                 ; Word                           ;
1177: EAC7         ;
1178: EAC7         ;
1179: EAC7         ;------------------------------------ Data Area -----------------------------;
1180: EAC7
1181: EAC7
1182: EAC7
1183: EAC7         ;****************************************************************************;
1184: EAC7         ;								Disk I/O									 ;
1185: EAC7         ;****************************************************************************;
1186: EAC7
1187: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1188: EAC7         ;  This function requests CP/M to completely reset the disk file system.     ;
1189: EAC7         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1190: EAC7         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1191: EAC7         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1192: EAC7         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1193: EAC7         ; in each logical disk as each disk is accessed. This involves reading the   ;
1194: EAC7         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1195: EAC7         ; which keep track of which allocation blocks are free and which             ;
1196: EAC7         ; are used for file storage.                                                 ;
1197: EAC7         ;                                                                            ;
1198: EAC7         ;			Function Code	:	C = 0DH                                      ;
1199: EAC7         ;			Entry Parameters:	None										 ;
1200: EAC7         ;			Exit Parameters :	None										 ;
1201: EAC7         ;																			 ;
1202: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1203: EAC7             vResetSystem:
1204: EAC7 21 00 00               LD     HL,0
1205: EACA 22 68 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1206: EACD 22 6A F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1207: EAD0 AF                     XOR    A                    ; Clear the current disk
1208: EAD1 32 66 F5               LD     (currentDisk),A
1209: EAD4         ; note that currentUserNumber remains unchanged
1210: EAD4 21 80 00               LD     HL,DMABuffer
1211: EAD7 22 6C F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1212: EADA CD 53 EE               CALL   SetDataDMA           ; to data DMA address
1213: EADD C3 85 EC               JP     Select
1214: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1215: EAE0         ;  This function makes the logical disk named in register E the default disk;
1216: EAE0         ; All subsequent references to disk files that do not specify the disk will ;
1217: EAE0         ; use this default. When you reference a disk file that does have an        ;
1218: EAE0         ; explicit logical disk in its name you do not have to issue another        ;
1219: EAE0         ; Select Disk function; the BDOS will take care of that for you.            ;
1220: EAE0         ;                                                                           ;
1221: EAE0         ;  Notice the way in which the logical disk is specified in register E.     ;
1222: EAE0         ; It is not the same as the disk drive specification in the first byte of   ;
1223: EAE0         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1224: EAE0         ; "use the current default disk" (as specified in the last Select Disk      ;
1225: EAE0         ; call or by the operator on the console). With this function, a value      ;
1226: EAE0         ; of OOH in register A means that A is the selected drive, a value of       ;
1227: EAE0         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1228: EAE0         ; 16 drives in the system.                                                  ;
1229: EAE0         ;                                                                           ;
1230: EAE0         ;			Function Code	:	C = 0EH                                     ;
1231: EAE0         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1232: EAE0         ;			Exit Parameters :	None										;
1233: EAE0         ;																			;
1234: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1235: EAE0
1236: EAE0             vSelectDisk:
1237: EAE0 C3 79 EC               JP     SelectCurrent
1238: EAE3
1239: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1240: EAE3         ;  This function opens a specified file for reading or writing. The FCB,    ;
1241: EAE3         ; whose address must be in register DE, tells CP/M the user number,         ;
1242: EAE3         ; the logical disk, the file name, and the file type. All other bytes of    ;
1243: EAE3         ; the FCB will normally be set to O.                                        ;
1244: EAE3         ;  The code returned by the BDOS in register A indicates whether the file   ;
1245: EAE3         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1246: EAE3         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1247: EAE3         ; then the file has been opened.                                            ;
1248: EAE3         ;			Function Code	:	C  = 0FH                                    ;
1249: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1250: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1251: EAE3         ;																			;
1252: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1253: EAE3             vOpenFile:
1254: EAE3 CD 0B EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1255: EAE6 CD 8C EE               CALL   ReselectDisk         ; do we need to reselect disk?
1256: EAE9 C3 5C ED               JP     OpenFile
1257: EAEC
1258: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1259: EAEC         ;  This function terminates the processing of a file to which you have      ;
1260: EAEC         ; written information. Under CP/M you do not need to close a file that you  ;
1261: EAEC         ; have been reading. However, if you ever intend for your program to        ;
1262: EAEC         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1263: EAEC         ; should close all files regardless of their use.                           ;
1264: EAEC         ;  The Close File function, like Open File, returns a directory code in     ;
1265: EAEC         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1266: EAEC         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1267: EAEC         ; been closed.                                                              ;
1268: EAEC         ;                                                                           ;
1269: EAEC         ;  When the BDOS closes a file to which data has been written, it writes    ;
1270: EAEC         ; the current contents of the FCB out to the disk directory, updating       ;
1271: EAEC         ; an existing directory entry by matching the disk, name, type, and         ;
1272: EAEC         ; extent number in the same manner that the Open File function does.        ;
1273: EAEC         ; Note that the BDOS does not transfer the last record of the file to the   ;
1274: EAEC         ; disk during the close operation. It merely updates the file directory.    ;
1275: EAEC         ; You must arrange to flush any partly filled record to the disk. If the    ;
1276: EAEC         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1277: EAEC         ; arrange to fill the unused portion of the record with the standard lAH    ;
1278: EAEC         ; end-of-file characters as CP/M expects.                                   ;
1279: EAEC         ;                                                                           ;
1280: EAEC         ;			Function Code	:	C  = 10FH                                   ;
1281: EAEC         ;			Entry Parameters:	DE = Address of File Control Block			;
1282: EAEC         ;			Exit Parameters :	A  = Directory Code							;
1283: EAEC         ;																			;
1284: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1285: EAEC             vCloseFile:
1286: EAEC CD 8C EE               CALL   ReselectDisk
1287: EAEF C3 9F ED               JP     CloseDirEntry
1288: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1289: EAF2         ;  This function scans down the file directory for the first entry that     ;
1290: EAF2         ; matches the file name, type, and extent in the FCB addressed by DE.       ;
1291: EAF2         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
1292: EAF2         ; more character positions. Where a "?" occurs, the BDOS will match any     ;
1293: EAF2         ; character in the corresponding position in the file directory. This is    ;
1294: EAF2         ; known as ambiguous file name matching.                                    ;
1295: EAF2         ;  The first byte of an FCB normally contains the logical disk number code. ;
1296: EAF2         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
1297: EAF2         ; and so on up to a possible maximum of 16 for disk P. However, if this     ;
1298: EAF2         ; byte contains a "?", the BDOS will search the default logical disk and    ;
1299: EAF2         ; will match the file name and type regardless of the user number. This     ;
1300: EAF2         ; function is normally used in conjunction with the Search Next function.   ;
1301: EAF2         ; Search First, in the process of matching a file, leaves certain           ;
1302: EAF2         ; variables in the BDOS set, ready for a subsequent Search Next.            ;
1303: EAF2         ;  Both Search First and Search Next return a directory code in the         ;
1304: EAF2         ; A register. With Search First, A = OFFH when no files match the FCB,      ;
1305: EAF2         ; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
1306: EAF2         ;                                                                           ;
1307: EAF2         ;  To locate the particular directory entry that either the Search First    ;
1308: EAF2         ; or Search Next function matched, multiply the directory code returned     ;
1309: EAF2         ; in A by the length of a directory entry (32 bytes). This is easily done   ;
1310: EAF2         ; by adding the A register to itself five times. Then add the DMA address   ;
1311: EAF2         ; to get the actual address where the matched directory entry is stored.    ;
1312: EAF2         ;  There are many occasions when you may need to write a program that will  ;
1313: EAF2         ; accept an ambiguous file name and operate on all of the file names that   ;
1314: EAF2         ; match it. (The DIR and ERA commands built into the CCP are examples that  ;
1315: EAF2         ; use ambiguous file names.) To do this, you must use several BDOS          ;
1316: EAF2         ; functions: the Set DMA Address function (code 26), this function          ;
1317: EAF2         ; (Search First), and Search Next (code 18). All of this is shown in the    ;
1318: EAF2         ; subroutine given in Figure 5-17.                                          ;
1319: EAF2         ;                                                                           ;
1320: EAF2         ;                                                                           ;
1321: EAF2         ;			Function Code	:	C  = 11FH                                   ;
1322: EAF2         ;			Entry Parameters:	DE = Address of File Control Block			;
1323: EAF2         ;			Exit Parameters :	A  = Directory Code							;
1324: EAF2         ;																			;
1325: EAF2         ;---------------------Search for First Name Match - 11 (17) ----------------;
1326: EAF2             vFindFirst:
1327: EAF2 0E 00                  LD     C,0                  ; Length assuming '?' true
1328: EAF4 2A C3 EA               LD     HL,(paramDE)         ; Get the FCB
1329: EAF7 7E                     LD     A,(HL)               ; DIsk/User No
1330: EAF8 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1331: EAFA CA 05 EB               JP     Z,QMarkFind          ;  if Yes, skip disk reselect
1332: EAFD         ;  and reset of EXT
1333: EAFD
1334: EAFD CD 0B EF               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1335: EB00 CD 8C EE               CALL   ReselectDisk         ; Use FCB to set currentDisk
1336: EB03 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1337: EB05
1338: EB05             QMarkFind:
1339: EB05 CD 37 EF               CALL   SearchForDirectoryRecord ; Find the directory record
1340: EB08 C3 A2 F0               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1341: EB0B
1342: EB0B         ;-----------------------------------------------------------------
1343: EB0B
1344: EB0B         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1345: EB0B         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1346: EB0B         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1347: EB0B         ; This function returns a bit map, called the login vector, in register pair ;
1348: EB0B         ; HL, indicating which logical disk drives have been selected since the last ;
1349: EB0B         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1350: EB0B         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1351: EB0B         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1352: EB0B         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1353: EB0B         ;  Logical disks can be selected programmatically through any file operation ;
1354: EB0B         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1355: EB0B         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1356: EB0B         ; where "X" is equal to A, B, ... , P.                                       ;
1357: EB0B         ;                                                                            ;
1358: EB0B         ;			Function Code	:	C = 018H                                     ;
1359: EB0B         ;			Entry Parameters:	None										 ;
1360: EB0B         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1361: EB0B         ;																			 ;
1362: EB0B         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1363: EB0B             vGetLoginVector:
1364: EB0B 2A 6A F5               LD     HL,(loggedDisks)
1365: EB0E 22 C5 EA               LD     (exitParameterWord),HL
1366: EB11 C9                     RET
1367: EB12         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1368: EB12         ;   This function returns the current default disk set by the last Select    ;
1369: EB12         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1370: EB12         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1371: EB12         ;                                                                            ;
1372: EB12         ;  This function returns the current default disk in coded form.             ;
1373: EB12         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1374: EB12         ; If you need to convert this to the corresponding ASCII character, simply   ;
1375: EB12         ; add 41H to register A. Use this function when you convert a file name and  ;
1376: EB12         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1377: EB12         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1378: EB12         ; You must therefore use this function to determine the logical disk letter  ;
1379: EB12         ; for the default drive.                                                     ;
1380: EB12         ;                                                                            ;
1381: EB12         ;			Function Code	:	C = 019H                                     ;
1382: EB12         ;			Entry Parameters:	None										 ;
1383: EB12         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1384: EB12         ;																			 ;
1385: EB12         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1386: EB12             vGetCurrentDisk:
1387: EB12 3A 66 F5               LD     A,(currentDisk)
1388: EB15 32 C5 EA               LD     (exitParameterByte),A
1389: EB18 C9                     RET
1390: EB19         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1391: EB19         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1392: EB19         ; value. The name is an historic relic dating back to the Intel Development  ;
1393: EB19         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1394: EB19         ; its hardware, could read data from a diskette directly into memory or      ;
1395: EB19         ; write data to a diskette directly from memory. The name DMA address now    ;
1396: EB19         ; applies to the address of the buffer to and from which data is             ;
1397: EB19         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1398: EB19         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1399: EB19         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1400: EB19         ; value of 0080H.                                                            ;
1401: EB19         ;                                                                            ;
1402: EB19         ;			Function Code	:	C = 0A9H                                     ;
1403: EB19         ;			Entry Parameters:	DE = DMA Address							 ;
1404: EB19         ;			Exit Parameters :	None										 ;
1405: EB19         ;																			 ;
1406: EB19         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1407: EB19             vSetDMA:
1408: EB19 2A C3 EA               LD     HL,(paramDE)
1409: EB1C 22 6C F5               LD     (initDAMAddress),HL
1410: EB1F C3 53 EE               JP     SetDataDMA
1411: EB22
1412: EB22         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1413: EB22         ;  This function returns the base, or starting, address of the allocation    ;
1414: EB22         ; vector for the currently selected logical disk. This information,          ;
1415: EB22         ; indicating which parts of the disk are assigned, is used by utility        ;
1416: EB22         ; programs and the BDOS itself to determine how much unused space is on the  ;
1417: EB22         ; logical disk, to locate an unused allocation block in order to extend      ;
1418: EB22         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1419: EB22         ;                                                                            ;
1420: EB22         ;			Function Code	:	C = 01BH                                     ;
1421: EB22         ;			Entry Parameters:	None										 ;
1422: EB22         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1423: EB22         ;																			 ;
1424: EB22         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1425: EB22             vGetAllocAddr:
1426: EB22 2A 7A F5               LD     HL,(caAllocVector)
1427: EB25 22 C5 EA               LD     (exitParameterWord),HL
1428: EB28 C9                     RET
1429: EB29
1430: EB29         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1431: EB29         ;  This function logically sets the currently selected disk to a Read-Only   ;
1432: EB29         ; state. Any attempts to execute a Write Sequential or Write Random function ;
1433: EB29         ; to the selected disk will be intercepted by the BDOS, and the following    ;
1434: EB29         ; message will appear on the console:                                        ;
1435: EB29         ;	BDOS Err on X: R/O                                                       ;
1436: EB29         ;	where X: is the selected disk.                                           ;
1437: EB29         ;                                                                            ;
1438: EB29         ;  Once you have requested Read-Only status for the currently selected       ;
1439: EB29         ; logical disk, this status will persist even if you proceed to select       ;
1440: EB29         ; other logical disks. In fact, it will remain in force until the next warm  ;
1441: EB29         ; boot or Reset Disk System function call.                                   ;
1442: EB29         ;  Digital Research documentation refers to this function code as Disk Write ;
1443: EB29         ; Protect. The Read-Only description is used here because it corresponds     ;
1444: EB29         ; to the error message produced if your program attempts to write on         ;
1445: EB29         ; the disk.                                                                  ;
1446: EB29         ;                                                                            ;
1447: EB29         ;			Function Code	:	C = 01CH                                     ;
1448: EB29         ;			Entry Parameters:	None										 ;
1449: EB29         ;			Exit Parameters :	None										 ;
1450: EB29         ;																			 ;
1451: EB29         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1452: EB29         ;;write protect current disk
1453: EB29             vWriteProtectDisk:
1454: EB29 C3 69 EE               JP     SetDiskReadOnly
1455: EB2C
1456: EB2C         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1457: EB2C         ;  This function returns a bit map in registers H and L showing which logical;
1458: EB2C         ; disks in the system have been set to Read-Only status, either by the       ;
1459: EB2C         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1460: EB2C         ; BDOS itself, because it detected that a diskette had been changed.         ;
1461: EB2C         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1462: EB2C         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1463: EB2C         ; the specific logical disk is set to I if the disk has been set to          ;
1464: EB2C         ; Read-Only status.                                                          ;
1465: EB2C         ;                                                                            ;
1466: EB2C         ;			Function Code	:	C = 01DH                                     ;
1467: EB2C         ;			Entry Parameters:	None										 ;
1468: EB2C         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1469: EB2C         ;																			 ;
1470: EB2C         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1471: EB2C             vGetReadOnlyMap:
1472: EB2C 2A 68 F5               LD     HL,(readOnlyVector)
1473: EB2F 22 C5 EA               LD     (exitParameterWord),HL
1474: EB32 C9                     RET
1475: EB33
1476: EB33         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1477: EB33         ;  This function returns the address of the disk parameter block (DPB) for   ;
1478: EB33         ; the last selected logical disk. The DPB describes the physical             ;
1479: EB33         ; characteristics of a specific logical disk-information mainly of interest  ;
1480: EB33         ; for system utility programs.                                               ;
1481: EB33         ;                                                                            ;
1482: EB33         ;			Function Code	:	C = 1FH                                      ;
1483: EB33         ;			Entry Parameters:	None										 ;
1484: EB33         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1485: EB33         ;																			 ;
1486: EB33         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1487: EB33             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1488: EB33 2A 76 F5               LD     HL,(caDiskParamBlock)
1489: EB36 22 C5 EA               LD     (exitParameterWord),HL
1490: EB39 C9                     RET
1491: EB3A
1492: EB3A         ;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
1493: EB3A         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1494: EB3A         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1495: EB3A         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1496: EB3A
1497: EB3A         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1498: EB3A         ;  This function resets individual disk drives. It is a more precise version ;
1499: EB3A         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1500: EB3A         ; specific logical; disks rather than all of them.                           ;
1501: EB3A         ;  The bit map in DE shows which disks are to be reset. The least significant;
1502: EB3A         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1503: EB3A         ; The bits set to I indicate the disks to be reset.                          ;
1504: EB3A         ;  Note that this function returns a zero value in A in order to maintain    ;
1505: EB3A         ; compatibility with MP/ M.                                                  ;
1506: EB3A         ;                                                                            ;
1507: EB3A         ;			Function Code	:	C = 25H                                      ;
1508: EB3A         ;			Entry Parameters:	DE = Logical Drive Bit Vector					 ;
1509: EB3A         ;			Exit Parameters :	A = 00H										 ;
1510: EB3A         ;																			 ;
1511: EB3A         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1512: EB3A         ;Reset Drive
1513: EB3A         ;IN  - (DE) Drive Vector
1514: EB3A         ;OUT - (A) 00
1515: EB3A             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1516: EB3A         ; Not Yet Implemented   **************
1517: EB3A C9                     RET
1518: EB3B         ;*****************************************************************
1519: EB3B
1520: EB3B         ;-----------------------------------------------------------------
1521: EB3B
1522: EB3B         ;*****************************************************************
1523: EB3B         ;random disk read
1524: EB3B         ;IN  - (DE) FCB address
1525: EB3B         ;OUT - (A) 01 = Reading unwritten data
1526: EB3B         ;	 02 = N/U
1527: EB3B         ;	 03 = Cannot close current extent
1528: EB3B         ;	 04 = Seek to unwriten Extent
1529: EB3B         ;	 05 = N/U
1530: EB3B         ;	 06 = Seek past Physical end of Disk
1531: EB3B             vReadRandom:                      ; func33 (33 - 21) Read Random record
1532: EB3B CD 8C EE               CALL   ReselectDisk
1533: EB3E C3 51 EB               JP     RandomDiskRead       ; to perform the disk read
1534: EB41         ;*****************************************************************
1535: EB41         ;write random record
1536: EB41         ;IN  - (DE) FCB address
1537: EB41         ;OUT - (A) 01 = Reading unwritten data
1538: EB41         ;	 02 = N/U
1539: EB41         ;	 03 = Cannot close current extent
1540: EB41         ;	 04 = Seek to unwriten Extent
1541: EB41         ;	 05 = Cannot create new Extent because of directory overflow
1542: EB41         ;	 06 = Seek past Physical end of Disk
1543: EB41             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1544: EB41 CD 8C EE               CALL   ReselectDisk
1545: EB44 C3 5A EB               JP     RandomDiskWrite      ; to perform the disk write
1546: EB47         ;ret ;jmp goback
1547: EB47         ;*****************************************************************
1548: EB47         ;return file size (0-65536)
1549: EB47         ;IN  - (DE) FCB address
1550: EB47             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1551: EB47 CD 8C EE               CALL   ReselectDisk
1552: EB4A C3 07 EC               JP     GetFileSize
1553: EB4D         ;*****************************************************************
1554: EB4D         ;set random record
1555: EB4D         ;IN  - (DE) FCB address
1556: EB4D         ;OUT - Random Record Field is set
1557: EB4D             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1558: EB4D C3 F4 EB               JP     SetRandomRecord
1559: EB50         ;? ;*****************************************************************
1560: EB50         ;? ;Reset Drive
1561: EB50         ;? ;IN  - (DE) Drive Vector
1562: EB50         ;? ;OUT - (A) 00
1563: EB50         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
1564: EB50         ;? ; Not Yet Implemented   **************
1565: EB50         ;?	RET
1566: EB50         ;*****************************************************************
1567: EB50         ;*****************************************************************
1568: EB50         ;Write Random With Zero Fill
1569: EB50         ;IN  - (DE) FCB address
1570: EB50         ;OUT - (A) Return Code		see Function 34
1571: EB50             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1572: EB50         ; Not Yet Implemented   **************
1573: EB50 C9                     RET
1574: EB51         ;*****************************************************************
1575: EB51         ;******************< Random I/O Stuff ****************************
1576: EB51         ;*****************************************************************
1577: EB51         ;random disk read
1578: EB51             RandomDiskRead:                      ; randiskread
1579: EB51 0E FF                  LD     C,TRUE               ; marked as read operation
1580: EB53 CD 63 EB               CALL   RandomSeek
1581: EB56 CC 09 F2               CALL   Z,DiskRead           ; if seek successful
1582: EB59 C9                     RET
1583: EB5A         ;*****************************************************************
1584: EB5A         ;random disk write
1585: EB5A             RandomDiskWrite:                      ; randiskwrite
1586: EB5A 0E 00                  LD     C,FALSE              ; marked as read operation
1587: EB5C CD 63 EB               CALL   RandomSeek
1588: EB5F CC 4C F2               CALL   Z,DiskWrite          ; if seek successful
1589: EB62 C9                     RET
1590: EB63         ;*****************************************************************
1591: EB63         ;*****************************************************************
1592: EB63         ;random access seek operation, C=0ffh if read mode
1593: EB63         ;fcb is assumed to address an active file control block
1594: EB63         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1595: EB63             RandomSeek:
1596: EB63 AF                     XOR    A
1597: EB64 32 90 F5               LD     (seqReadFlag),A      ; marked as random access operation
1598: EB67 C5                     PUSH   BC                   ; save r/w flag
1599: EB68 2A C3 EA               LD     HL,(paramDE)
1600: EB6B EB                     EX     DE,HL                ; DE will hold base of fcb
1601: EB6C 21 21 00               LD     HL,RANDOM_REC_FIELD
1602: EB6F 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1603: EB70 7E                     LD     A,(HL)
1604: EB71 E6 7F                  AND    7FH
1605: EB73 F5                     PUSH   AF                   ; record number
1606: EB74 7E                     LD     A,(HL)
1607: EB75 17                     RLA                         ; cy=lsb of extent#
1608: EB76 23                     INC    HL
1609: EB77 7E                     LD     A,(HL)
1610: EB78 17                     RLA
1611: EB79 E6 1F                  AND    11111B               ; A=ext#
1612: EB7B 4F                     LD     C,A                  ; C holds extent number, record stacked
1613: EB7C 7E                     LD     A,(HL)
1614: EB7D 1F                     RRA
1615: EB7E 1F                     RRA
1616: EB7F 1F                     RRA
1617: EB80 1F                     RRA
1618: EB81 E6 0F                  AND    1111B                ; mod#
1619: EB83 47                     LD     B,A                  ; B holds module#, C holds ext#
1620: EB84 F1                     POP    AF                   ; recall sought record #
1621: EB85         ;check to insure that high byte of ran rec = 00
1622: EB85 23                     INC    HL
1623: EB86 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1624: EB87 2C                     INC    L
1625: EB88 2D                     DEC    L
1626: EB89 2E 06                  LD     L,06                 ; zero flag, l=6
1627: EB8B         ; produce error 6, seek past physical eod
1628: EB8B C2 EC EB               JP     NZ,RandomSeekError
1629: EB8E         ; otherwise, high byte = 0, A = sought record
1630: EB8E 21 20 00               LD     HL,NEXT_RECORD
1631: EB91 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1632: EB92 77                     LD     (HL),A               ; sought rec# stored away
1633: EB93         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1634: EB93         ; the r/w flag is still stacked.  compare fcb values
1635: EB93 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1636: EB96 19                     ADD    HL,DE
1637: EB97 79                     LD     A,C                  ; A=seek ext#
1638: EB98 96                     SUB    M
1639: EB99 C2 A7 EB               JP     NZ,RandomSeekClose   ; tests for = extents
1640: EB9C         ; extents match, check mod#
1641: EB9C 21 0E 00               LD     HL,fcbS2Index
1642: EB9F 19                     ADD    HL,DE
1643: EBA0 78                     LD     A,B                  ; B=seek mod#
1644: EBA1         ; could be overflow at eof, producing module#
1645: EBA1         ; of 90H or 10H, so compare all but fwf
1646: EBA1 96                     SUB    M
1647: EBA2 E6 7F                  AND    7FH
1648: EBA4 CA DF EB               JP     Z,RandomSeekExit     ; same?
1649: EBA7             RandomSeekClose:
1650: EBA7 C5                     PUSH   BC
1651: EBA8 D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1652: EBA9 CD 9F ED               CALL   CloseDirEntry        ; current extent closed
1653: EBAC D1                     POP    DE
1654: EBAD C1                     POP    BC                   ; recall parameters and fill
1655: EBAE 2E 03                  LD     L,03                 ; cannot close error #3
1656: EBB0 3A C5 EA               LD     A,(exitParameterByte)
1657: EBB3 3C                     INC    A
1658: EBB4 CA E5 EB               JP     Z,RandomSeekErrorBadSeek
1659: EBB7 21 0C 00               LD     HL,fcbExtIndex
1660: EBBA 19                     ADD    HL,DE
1661: EBBB 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1662: EBBC 21 0E 00               LD     HL,fcbS2Index
1663: EBBF 19                     ADD    HL,DE
1664: EBC0 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1665: EBC1 CD 5C ED               CALL   OpenFile             ; is the file present?
1666: EBC4 3A C5 EA               LD     A,(exitParameterByte)
1667: EBC7 3C                     INC    A
1668: EBC8 C2 DF EB               JP     NZ,RandomSeekExit    ; open successful?
1669: EBCB         ; cannot open the file, read mode?
1670: EBCB C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1671: EBCC C5                     PUSH   BC                   ; everyone expects this item stacked
1672: EBCD 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1673: EBCF 0C                     INC    C                    ; becomes 00 if read operation
1674: EBD0 CA E5 EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1675: EBD3 CD 97 F3               CALL   MakeNewFile          ; write operation, make new extent
1676: EBD6 2E 05                  LD     L,05                 ; cannot create new extent #5
1677: EBD8 3A C5 EA               LD     A,(exitParameterByte)
1678: EBDB 3C                     INC    A
1679: EBDC CA E5 EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1680: EBDF         ; file make operation successful
1681: EBDF             RandomSeekExit:                      ; seekok:
1682: EBDF C1                     POP    BC                   ; discard r/w flag
1683: EBE0 AF                     XOR    A
1684: EBE1 32 C5 EA               LD     (exitParameterByte),A
1685: EBE4 C9                     RET                         ; with zero set
1686: EBE5
1687: EBE5             RandomSeekErrorBadSeek:
1688: EBE5         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1689: EBE5         ; appears as overflow with file write flag set
1690: EBE5 E5                     PUSH   HL                   ; save error flag
1691: EBE6 CD 11 EF               CALL   GetExtentNumberMSB   ; HL = .fcbS2Index
1692: EBE9 36 C0                  LD     (HL),11000000B
1693: EBEB E1                     POP    HL                   ; and drop through
1694: EBEC             RandomSeekError:                      ; seekerr:
1695: EBEC C1                     POP    BC                   ; discard r/w flag
1696: EBED 7D                     LD     A,L
1697: EBEE 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1698: EBF1         ; SetFileWriteFlag returns non-zero accumulator for err
1699: EBF1 C3 1A EF               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1700: EBF4         ;ret
1701: EBF4         ;
1702: EBF4         ;*****************************************************************
1703: EBF4             SetRandomRecord:                      ; setrandom
1704: EBF4 2A C3 EA               LD     HL,(paramDE)
1705: EBF7 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1706: EBFA CD 43 EC               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1707: EBFD 21 21 00               LD     HL,RANDOM_REC_FIELD
1708: EC00 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1709: EC01 71                     LD     (HL),C
1710: EC02 23                     INC    HL
1711: EC03 70                     LD     (HL),B
1712: EC04 23                     INC    HL
1713: EC05 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1714: EC06 C9                     RET
1715: EC07         ;*****************************************************************
1716: EC07         ;compute logical file size for current fcb
1717: EC07             GetFileSize:                      ; getfilesize
1718: EC07 0E 0C                  LD     C,fcbExtIndex
1719: EC09 CD 37 EF               CALL   SearchForDirectoryRecord
1720: EC0C         ; zero the receiving Ramdom record field
1721: EC0C 2A C3 EA               LD     HL,(paramDE)
1722: EC0F 11 21 00               LD     DE,RANDOM_REC_FIELD
1723: EC12 19                     ADD    HL,DE
1724: EC13 E5                     PUSH   HL                   ; save position
1725: EC14 72                     LD     (HL),D
1726: EC15 23                     INC    HL
1727: EC16 72                     LD     (HL),D
1728: EC17 23                     INC    HL
1729: EC18 72                     LD     (HL),D               ; =00 00 00
1730: EC19             GetFileSize1:                      ; getsize:
1731: EC19 CD D3 EF               CALL   AtEndOfDirectory
1732: EC1C CA 41 EC               JP     Z,GetFileSizeExit
1733: EC1F         ; current fcb addressed by dptr
1734: EC1F CD DC EF               CALL   GetCurrentDirectoryRecord
1735: EC22 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1736: EC25 CD 43 EC               CALL   GetRandomRecordPosition
1737: EC28         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1738: EC28 E1                     POP    HL
1739: EC29 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1740: EC2A 5F                     LD     E,A                  ; save cy
1741: EC2B 79                     LD     A,C
1742: EC2C 96                     SUB    M
1743: EC2D 23                     INC    HL                   ; ls byte
1744: EC2E 78                     LD     A,B
1745: EC2F 9E                     SBC    A,(HL)
1746: EC30 23                     INC    HL                   ; middle byte
1747: EC31 7B                     LD     A,E
1748: EC32 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1749: EC33 DA 3B EC               JP     C,GetFileSize2       ; for another try
1750: EC36         ; fcb is less or equal, fill from directory
1751: EC36 73                     LD     (HL),E
1752: EC37 2B                     DEC    HL
1753: EC38 70                     LD     (HL),B
1754: EC39 2B                     DEC    HL
1755: EC3A 71                     LD     (HL),C
1756: EC3B             GetFileSize2:                      ; getnextsize:
1757: EC3B CD 4C EF               CALL   GetNextDirectoryRecord
1758: EC3E C3 19 EC               JP     GetFileSize1
1759: EC41             GetFileSizeExit:                      ; setsize:
1760: EC41 E1                     POP    HL                   ; discard .fcb(random record field)
1761: EC42 C9                     RET
1762: EC43         ;-----------------------------------------------------------------
1763: EC43         ;compute random record position
1764: EC43             GetRandomRecordPosition:                      ; compute$rr
1765: EC43 EB                     EX     DE,HL
1766: EC44 19                     ADD    HL,DE
1767: EC45         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1768: EC45 4E                     LD     C,(HL)
1769: EC46 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1770: EC48 21 0C 00               LD     HL,fcbExtIndex
1771: EC4B 19                     ADD    HL,DE
1772: EC4C 7E                     LD     A,(HL)
1773: EC4D 0F                     RRCA
1774: EC4E E6 80                  AND    80H                  ; A=e000 0000
1775: EC50 81                     ADD    A,C
1776: EC51 4F                     LD     C,A
1777: EC52 3E 00                  LD     A,0
1778: EC54 88                     ADC    A,B
1779: EC55 47                     LD     B,A
1780: EC56         ; BC = 0000 000? errrr rrrr
1781: EC56 7E                     LD     A,(HL)
1782: EC57 0F                     RRCA
1783: EC58 E6 0F                  AND    LO_NIBBLE_MASK
1784: EC5A 80                     ADD    A,B
1785: EC5B 47                     LD     B,A
1786: EC5C         ; BC = 000? eeee errrr rrrr
1787: EC5C 21 0E 00               LD     HL,fcbS2Index
1788: EC5F 19                     ADD    HL,DE
1789: EC60 7E                     LD     A,(HL)               ; A=XXX? mmmm
1790: EC61 87                     ADD    A,A
1791: EC62 87                     ADD    A,A
1792: EC63 87                     ADD    A,A
1793: EC64 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1794: EC65 F5                     PUSH   AF
1795: EC66 80                     ADD    A,B
1796: EC67 47                     LD     B,A
1797: EC68         ; cy=?, BC = mmmm eeee errr rrrr
1798: EC68 F5                     PUSH   AF                   ; possible second carry
1799: EC69 E1                     POP    HL                   ; cy = lsb of L
1800: EC6A 7D                     LD     A,L                  ; cy = lsb of A
1801: EC6B E1                     POP    HL                   ; cy = lsb of L
1802: EC6C B5                     OR     L                    ; cy/cy = lsb of A
1803: EC6D E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1804: EC6F C9                     RET
1805: EC70         ;-----------------------------------------------------------------
1806: EC70
1807: EC70
1808: EC70
1809: EC70         ;*****************************************************************
1810: EC70         ;********************** Disk  I/O ********************************
1811: EC70         ;*****************************************************************
1812: EC70         ;-----------------------------------------------------------------
1813: EC70         ;;set file Attributes
1814: EC70             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1815: EC70 CD 8C EE               CALL   ReselectDisk
1816: EC73 CD A2 F1               CALL   SetAttributes
1817: EC76 C3 1B F4               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1818: EC79         ;-----------------------------------------------------------------
1819: EC79         ;--------------------------- Select  Drive ---------------------------------;
1820: EC79         ; Establish the disk found in (paramE) as the current disk drive            ;
1821: EC79             SelectCurrent:                      ;
1822: EC79 3A C2 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
1823: EC7C 21 66 F5               LD     HL,currentDisk       ; Get the current disk              ;
1824: EC7F BE                     CP     M                    ; Are the the same ?                ;
1825: EC80 C8                     RET    Z                    ; Exit if yes, nothing to do        ;
1826: EC81 77                     LD     (HL),A               ;  else update curretDisk and       ;
1827: EC82 C3 85 EC               JP     Select               ;  select it                        ;
1828: EC85         ;--------------------------- Select  Drive ---------------------------------;
1829: EC85         ;--------------------------- Select Login Drive ----------------------------;
1830: EC85         ; select Login Drive                                                       ;
1831: EC85             Select:                         ;
1832: EC85 CD A6 EC               CALL   SelectDisk           ; Select the Disk                   ;
1833: EC88 CC D5 F4               CALL   Z,errSelect          ;
1834: EC8B 21 66 F5               LD     HL,currentDisk       ;
1835: EC8E 46                     LD     B,(HL)               ; Get Current Disk                  ;
1836: EC8F 2A 6A F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
1837: EC92 CD A7 F4               CALL   IsBitSet             ;
1838: EC95 C0                     RET    NZ                   ; Exit if already logged in         ;
1839: EC96         ;                                                                           ;
1840: EC96 21 66 F5               LD     HL,currentDisk       ;
1841: EC99 46                     LD     B,(HL)               ; Get Current Disk                  ;
1842: EC9A 2A 6A F5               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
1843: EC9D CD B7 F4               CALL   SetVectorBit         ;
1844: ECA0 22 6A F5               LD     (loggedDisks),HL     ; Update the Vector                 ;
1845: ECA3         ;
1846: ECA3 C3 EC EC               JP     InitDisk             ;
1847: ECA6         ;--------------------------- Select Login Drive ----------------------------;
1848: ECA6         ;--------------------------- Select Disk ------------------------------------;
1849: ECA6         ;*****************************************************************          ;
1850: ECA6         ; select the disk drive given by currentDisk, and fill the base addresses   ;
1851: ECA6         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
1852: ECA6             SelectDisk:                      ;
1853: ECA6 3A 66 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
1854: ECA9 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
1855: ECAA CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
1856: ECAD 7C                     LD     A,H                  ; Return Pointer to                  ;
1857: ECAE B5                     OR     L                    ;  Disk Parameter Header             ;
1858: ECAF C8                     RET    Z                    ; exit if error, with HL = 0000      ;
1859: ECB0         ;
1860: ECB0 5E                     LD     E,(HL)               ;
1861: ECB1 23                     INC    HL                   ;
1862: ECB2 56                     LD     D,(HL)               ; Skew Table in DE                   ;
1863: ECB3 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
1864: ECB4 ED 53 8B F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
1865: ECB8         ;
1866: ECB8 22 6E F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
1867: ECBB 23                     INC    HL                   ;
1868: ECBC 23                     INC    HL                   ; HL = Last Track #                  ;
1869: ECBD 22 70 F5               LD     (caTrack),HL         ; Move to Current Track #            ;
1870: ECC0 23                     INC    HL                   ;
1871: ECC1 23                     INC    HL                   ; HL = Last Sector #                 ;
1872: ECC2 22 72 F5               LD     (caSector),HL        ; Move to Current Sector #           ;
1873: ECC5 23                     INC    HL                   ;
1874: ECC6 23                     INC    HL                   ;
1875: ECC7 11 74 F5               LD     DE,caDirectoryDMA    ;
1876: ECCA 01 08 00               LD     BC,caListSize        ;
1877: ECCD ED B0                  LDIR                        ;
1878: ECCF         ;
1879: ECCF         ; finish filling in address list                                             ;
1880: ECCF 2A 76 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
1881: ECD2 11 7C F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
1882: ECD5 01 0F 00               LD     BC,dpbSize           ;
1883: ECD8 ED B0                  LDIR                        ; Move DPB to current                ;
1884: ECDA         ;
1885: ECDA         ; Determine if Byte or Word Allocation Table	                             ;
1886: ECDA 2A 81 F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
1887: ECDD 7C                     LD     A,H                  ; If  its 00 then < 255              ;
1888: ECDE 21 95 F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
1889: ECE1 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
1890: ECE3 B7                     OR     A                    ;  is the assumption confirmed ?     ;
1891: ECE4 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
1892: ECE6 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
1893: ECE8         ;
1894: ECE8         ; Set Sign, reset Carry and Zero to indicate success                         ;
1895: ECE8             SelectDisk1:                      ;
1896: ECE8 3E FF                  LD     A,TRUE               ;
1897: ECEA B7                     OR     A                    ;
1898: ECEB C9                     RET                         ;
1899: ECEC         ;--------------------------- Select Disk ------------------------------------;
1900: ECEC         ;--------------------------- Initialize Disk --------------------------------;
1901: ECEC             InitDisk:                       ;
1902: ECEC 2A 81 F5               LD     HL,(dpbDSM)          ; Maximum allocation value           ;
1903: ECEF CD BC F0               CALL   DivideHLby8          ; Length of Map                      ;
1904: ECF2 E5                     PUSH   HL                   ; Save Length                        ;
1905: ECF3 E5                     PUSH   HL                   ; Save for end of MAP                ;
1906: ECF4 C1                     POP    BC                   ; BC = dpbDSM/8                      ;
1907: ECF5         ; Clear the Allocation Vector	                                             ;
1908: ECF5 2A 7A F5               LD     HL,(caAllocVector)   ; Allocation vector Start            ;
1909: ECF8 36 00                  LD     (HL),0               ; Clear location                     ;
1910: ECFA ED 5B 7A F5               LD     DE,(caAllocVector)   ;
1911: ECFE 13                     INC    DE                   ; Allocation vector Start + 1        ;
1912: ECFF ED B0                  LDIR                        ; Cascade 00 thru Map                ;
1913: ED01         ; Force bits at End of Map                                                   ;
1914: ED01 EB                     EX     DE,HL                ; Put last Map byte into DE          ;
1915: ED02 E1                     POP    HL                   ;
1916: ED03 23                     INC    HL                   ;
1917: ED04 CD C6 F0               CALL   MultiplyHLby8        ; Blocks if all bits used            ;
1918: ED07 ED 4B 81 F5               LD     BC,(dpbDSM)          ; Actual block max                   ;
1919: ED0B 03                     INC    BC                   ; Now has size of the Map            ;
1920: ED0C AF                     XOR    A                    ; Clear CY                           ;
1921: ED0D ED 42                  SBC    HL,BC                ; Extra unused bits                  ;
1922: ED0F BD                     CP     L                    ;  are there any                     ;
1923: ED10 28 07                  JR     Z,Mark4Directory     ;
1924: ED12 45                     LD     B,L                  ; Number of bits to set              ;
1925: ED13 EB                     EX     DE,HL                ; Put last Map byte into HL          ;
1926: ED14             SetBitLoop:                      ;
1927: ED14 37                     SCF                         ;
1928: ED15 CB 16                  RL     (HL)                 ; Set LSB                            ;
1929: ED17 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                 ;
1930: ED19         ;
1931: ED19             Mark4Directory:                      ;
1932: ED19         ; Mark the reserved space for the directory                                  ;
1933: ED19 2A 85 F5               LD     HL,(dpbDABM)         ; Directory block reserved bits      ;
1934: ED1C EB                     EX     DE,HL                ;
1935: ED1D 2A 7A F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector      ;
1936: ED20 73                     LD     (HL),E               ;
1937: ED21 23                     INC    HL                   ;
1938: ED22 72                     LD     (HL),D               ; Put reserved blocks in Vector      ;
1939: ED23         ; end of Map                                                                 ;
1940: ED23         ; Home disk, and set current track and sector to 00                          ;
1941: ED23 CD 39 EE               CALL   Home                 ;
1942: ED26 2A 6E F5               LD     HL,(caDirMaxValue)   ;
1943: ED29 36 03                  LD     (HL),3               ;
1944: ED2B 23                     INC    HL                   ;
1945: ED2C 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003       ;
1946: ED2E CD CC EF               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)           ;
1947: ED31         ;
1948: ED31             InitDisk1:                      ;
1949: ED31         ; Process the directory                                                      ;
1950: ED31 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	     ;
1951: ED33 CD E7 F0               CALL   ReadDirectory        ; Get the directory Record           ;
1952: ED36 CD D3 EF               CALL   AtEndOfDirectory     ; Are we Done ?                      ;
1953: ED39 C8                     RET    Z                    ;  Exit if Yes                       ;
1954: ED3A         ; Not end of directory, valid entry?                                         ;
1955: ED3A CD DC EF               CALL   GetCurrentDirectoryRecord ; Calculate location of the element  ;
1956: ED3D 3E E5                  LD     A,emptyDir           ;
1957: ED3F BE                     CP     M                    ; Is it an Empty Dir Entry           ;
1958: ED40 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                 ;
1959: ED42         ; Not emptyDir, user code the same?                                          ;
1960: ED42 3A 65 F5               LD     A,(currentUserNumber) ;
1961: ED45 BE                     CP     M                    ;
1962: ED46 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users   ;
1963: ED48         ; Same user, check for '$' submit                                            ;
1964: ED48 23                     INC    HL                   ;
1965: ED49 7E                     LD     A,(HL)               ;
1966: ED4A D6 24                  SUB    DOLLAR               ; Is first Char a $                  ;
1967: ED4C 20 04                  JR     NZ,InitDisk2         ;
1968: ED4E         ; dollar file found, mark in exitParameterByte                               ;
1969: ED4E 3D                     DEC    A                    ; Set A to FFH                       ;
1970: ED4F 32 C5 EA               LD     (exitParameterByte),A ; Return it the exit parameter       ;
1971: ED52             InitDisk2:                      ;
1972: ED52         ; now scan the disk map for allocated blocks                                 ;
1973: ED52 0E FF                  LD     C,TRUE               ; set to allocated                   ;
1974: ED54 CD 00 F0               CALL   ScanDiskMap          ;
1975: ED57 CD EA EF               CALL   SetDirectoryEntry    ; Mark directory entry               ;
1976: ED5A 18 D5                  JR     InitDisk1            ; Loop for another entry             ;
1977: ED5C         ;--------------------------- Initialize Disk --------------------------------;
1978: ED5C         ;----------------------------- Open File -----------------------------------;
1979: ED5C         ;search for the directory entry matching FCB at paramDE						;
1980: ED5C             OpenFile:                       ;
1981: ED5C 0E 0F                  LD     C,nameLength         ;
1982: ED5E CD 37 EF               CALL   SearchForDirectoryRecord ;
1983: ED61 CD D3 EF               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
1984: ED64 C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
1985: ED65         ;
1986: ED65             CopyDirRecordToFCB:                      ;
1987: ED65 CD DD EE               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
1988: ED68 7E                     LD     A,(HL)               ; Get the EXT                      	;
1989: ED69 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
1990: ED6A E5                     PUSH   HL                   ;  also save FCB's pointer         	;
1991: ED6B CD DC EF               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
1992: ED6E E5                     PUSH   HL                   ; Save Directory Record address    	;
1993: ED6F         ;
1994: ED6F ED 5B C3 EA               LD     DE,(paramDE)         ;
1995: ED73 01 20 00               LD     BC,fcbLength         ;
1996: ED76 ED B0                  LDIR                        ; Move dir record to FCB           	;
1997: ED78         ;
1998: ED78         ; note that entire fcb is copied, including indicators                    	;
1999: ED78 CD 1A EF               CALL   SetFileWriteFlag     ; Set clean file flag				;
2000: ED7B D1                     POP    DE                   ; Get Directory Record address     	;
2001: ED7C 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
2002: ED7F 19                     ADD    HL,DE                ; Directory's EXT address          	;
2003: ED80 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
2004: ED81 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
2005: ED84 19                     ADD    HL,DE                ; Directory's RC address           	;
2006: ED85 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
2007: ED86 E1                     POP    HL                   ; Get FCB's Extent Address         	;
2008: ED87 F1                     POP    AF                   ; Get FCB's Extent Value           	;
2009: ED88 77                     LD     (HL),A               ; Restore Extent Value             	;
2010: ED89         ; if user ext < dir ext then user := 128 records                           	;
2011: ED89         ; if user ext = dir ext then user := dir records                           	;
2012: ED89         ; if user ext > dir ext then user := 0 records                             	;
2013: ED89 79                     LD     A,C                  ; Get the Dir's EXT                	;
2014: ED8A BE                     CP     M                    ; Does it match the FCB'd          	;
2015: ED8B 78                     LD     A,B                  ; Get the Dir's  record count      	;
2016: ED8C CA 96 ED               JP     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
2017: ED8F 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
2018: ED91 DA 96 ED               JP     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
2019: ED94 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
2020: ED96             OpenSetRecordCount:                      ;
2021: ED96 2A C3 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
2022: ED99 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
2023: ED9C 19                     ADD    HL,DE                ; FCB's record count               	;
2024: ED9D 77                     LD     (HL),A               ; Set the value                    	;
2025: ED9E C9                     RET                         ;
2026: ED9F         ;----------------------------- Open File -----------------------------------;
2027: ED9F         ;---------------------------- Close Directory Entry ------------------------;
2028: ED9F             CloseDirEntry:                      ;
2029: ED9F AF                     XOR    A                    ;
2030: EDA0 32 C5 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
2031: EDA3 CD 81 EE               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
2032: EDA6 C0                     RET    NZ                   ; Skip close if r/o disk            ;
2033: EDA7         ; check file write flag - 0 indicates written                               ;
2034: EDA7 CD 11 EF               CALL   GetWriteFileFlagValue ; Get file's WriteFileFlag          ;
2035: EDAA CB 7F                  BIT    7,A                  ;  Has it changed ?					;
2036: EDAC         ;	AND		writeFlagMask				; Apply the RO Flag for S2          ;
2037: EDAC C0                     RET    NZ                   ; Skip close if clean file          ;
2038: EDAD         ;
2039: EDAD 0E 0F                  LD     C,nameLength         ;
2040: EDAF CD 37 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
2041: EDB2 CD D3 EF               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
2042: EDB5 C8                     RET    Z                    ;  exit if at EOD                   ;
2043: EDB6         ;
2044: EDB6         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
2045: EDB6 CD DC EF               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
2046: EDB9 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
2047: EDBC 09                     ADD    HL,BC                ;
2048: EDBD EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
2049: EDBE 2A C3 EA               LD     HL,(paramDE)         ;
2050: EDC1 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
2051: EDC2 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
2052: EDC4         ;
2053: EDC4             MergeAllocationMaps:                      ;
2054: EDC4 3A 95 F5               LD     A,(byteAllocationFlag) ;
2055: EDC7 B7                     OR     A                    ;
2056: EDC8 CA DF ED               JP     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2057: EDCB         ; process byte size Map	                                                    ;
2058: EDCB 7E                     LD     A,(HL)               ; FCB Block number                  ;
2059: EDCC B7                     OR     A                    ; Is it 0 ?                         ;
2060: EDCD 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2061: EDCE C2 D2 ED               JP     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2062: EDD1 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2063: EDD2             MergeFCBisNot0:                      ;
2064: EDD2 B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2065: EDD3 C2 D8 ED               JP     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2066: EDD6 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2067: EDD7 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2068: EDD8             MergeDirEntryNot0:                      ;
2069: EDD8 BE                     CP     M                    ; Do FCB and Dir match values       ;
2070: EDD9 C2 1A EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2071: EDDC C3 F4 ED               JP     MergeMapLoop         ; Go see if there is more           ;
2072: EDDF         ;
2073: EDDF             MergeWordMaps:                      ;
2074: EDDF CD D0 F0               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2075: EDE2 EB                     EX     DE,HL                ;
2076: EDE3 CD D0 F0               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2077: EDE6 EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2078: EDE7 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2079: EDE8 BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2080: EDE9 C2 1A EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2081: EDEC 13                     INC    DE                   ;
2082: EDED 23                     INC    HL                   ; move on to the MSB                ;
2083: EDEE 1A                     LD     A,(DE)               ;
2084: EDEF BE                     CP     M                    ; do the check for equality         ;
2085: EDF0 C2 1A EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2086: EDF3 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2087: EDF4             MergeMapLoop:                      ;
2088: EDF4 13                     INC    DE                   ; Advance to the next positions     ;
2089: EDF5 23                     INC    HL                   ; in The Maps                       ;
2090: EDF6 0D                     DEC    C                    ; Are we done ?                     ;
2091: EDF7 C2 C4 ED               JP     NZ,MergeAllocationMaps ;  No, do it again                  ;
2092: EDFA         ;
2093: EDFA         ; Check the EXT                                                             ;
2094: EDFA 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2095: EDFD 09                     ADD    HL,BC                ;
2096: EDFE EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2097: EDFF 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2098: EE00 1A                     LD     A,(DE)               ; FCB's extent number               ;
2099: EE01 BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2100: EE02 DA 0E EE               JP     C,CloseDirEntryEnd   ;  we are done if yes               ;
2101: EE05 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2102: EE06         ; Update directory record count field                                       ;
2103: EE06 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2104: EE09 09                     ADD    HL,BC                ;
2105: EE0A EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2106: EE0B 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2107: EE0C 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2108: EE0D 12                     LD     (DE),A               ;  the Directory Record RC          ;
2109: EE0E         ;
2110: EE0E             CloseDirEntryEnd:                      ;
2111: EE0E 3E FF                  LD     A,TRUE               ;
2112: EE10 32 8D F5               LD     (fcbCopiedFlag),A    ;Set copied flag as true            ;
2113: EE13         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2114: EE13 CD 15 F1               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2115: EE16 C3 B4 EF               JP     WriteDir             ; Write the directory element       ;
2116: EE19 C9                     RET                         ;
2117: EE1A         ;
2118: EE1A             CloseDirEntryError:                      ;
2119: EE1A 21 C5 EA               LD     HL,exitParameterByte ;
2120: EE1D 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2121: EE1E C9                     RET                         ;
2122: EE1F         ;---------------------------- Close Directory Entry ------------------------;
2123: EE1F
2124: EE1F         ;  +++++ ;
2125: EE1F
2126: EE1F         ;---------------
2127: EE1F         ; set a "1" value in currentDisk position of BC
2128: EE1F         ; return in HL
2129: EE1F             SetCurrentDiskBit:
2130: EE1F C5                     PUSH   BC                   ; save input parameter
2131: EE20 3A 66 F5               LD     A,(currentDisk)
2132: EE23 4F                     LD     C,A                  ; ready parameter for shift
2133: EE24 21 01 00               LD     HL,1                 ; number to shift
2134: EE27 CD 96 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
2135: EE2A C1                     POP    BC                   ; original mask
2136: EE2B 79                     LD     A,C
2137: EE2C B5                     OR     L
2138: EE2D 6F                     LD     L,A
2139: EE2E 78                     LD     A,B
2140: EE2F B4                     OR     H
2141: EE30 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
2142: EE31 C9                     RET
2143: EE32         ;--------------
2144: EE32
2145: EE32         ;--------------------------- Scan      Map ----------------------------------;
2146: EE32         ;-----------------------------------
2147: EE32         ; byte value from ALLOC is in register A, with shift count
2148: EE32         ; in register C (to place bit back into position), and
2149: EE32         ; target ALLOC position in registers HL, rotate and replace
2150: EE32             RotateAndReplace:
2151: EE32 0F                     RRCA
2152: EE33 15                     DEC    D
2153: EE34 C2 32 EE               JP     NZ,RotateAndReplace  ; back into position
2154: EE37 77                     LD     (HL),A               ; back to ALLOC
2155: EE38 C9                     RET
2156: EE39         ;-----------------------------------
2157: EE39
2158: EE39         ;*****************************************************************
2159: EE39
2160: EE39         ;*****************************************************************
2161: EE39         ;=========================== Disk Utilities ================================;
2162: EE39         ;--------------------------- Home The Current Disk ------------------------;
2163: EE39         ;move to home position, then offset to start of dir                        ;
2164: EE39             Home:                           ;
2165: EE39 CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks      ;
2166: EE3C         ; if Buffer needs to be written    ;
2167: EE3C 21 89 F5               LD     HL,dpbOFF            ; Number of tracks before directory;
2168: EE3F 4E                     LD     C,(HL)               ;
2169: EE40 23                     INC    HL                   ;
2170: EE41 46                     LD     B,(HL)               ;
2171: EE42 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position  ;
2172: EE45         ;
2173: EE45         ; Set Current Track and Sector to 00                                       ;
2174: EE45 AF                     XOR    A                    ; set ACC to 00                    ;
2175: EE46 2A 70 F5               LD     HL,(caTrack)         ;
2176: EE49 77                     LD     (HL),A               ;
2177: EE4A 23                     INC    HL                   ;
2178: EE4B 77                     LD     (HL),A               ;
2179: EE4C 2A 72 F5               LD     HL,(caSector)        ;
2180: EE4F 77                     LD     (HL),A               ;
2181: EE50 23                     INC    HL                   ;
2182: EE51 77                     LD     (HL),A               ;
2183: EE52 C9                     RET                         ;
2184: EE53         ;
2185: EE53         ;--------------------------- Home The Current Disk ------------------------;
2186: EE53         ;--------------------------- Set DMAs -------------------------------------;
2187: EE53             SetDataDMA:                      ;
2188: EE53 21 6C F5               LD     HL,initDAMAddress    ;
2189: EE56 18 03                  JR     SetDMA               ; Skip to complete the call        ;
2190: EE58         ;	LD		BC,initDAMAddress                                              ;
2191: EE58         ;	JP		bcSetdma					; Call BIOS to set                 ;
2192: EE58         ;
2193: EE58             SetDirDMA:                      ;
2194: EE58 21 74 F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
2195: EE5B         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
2196: EE5B         ;	JP		bcSetdma					; Call BIOS to set                 ;
2197: EE5B         ;
2198: EE5B             SetDMA:                         ;
2199: EE5B 4E                     LD     C,(HL)               ;
2200: EE5C 23                     INC    HL                   ;
2201: EE5D 46                     LD     B,(HL)               ; parameter ready              ;
2202: EE5E C3 24 F6               JP     bcSetdma             ; call bios to set             ;
2203: EE61         ;--------------------------- Set DMAs -------------------------------------;
2204: EE61         ;--------------------------- Read Buffer ----------------------------------;
2205: EE61         ;reads into current DMA, using current Disk,Track and Sector               ;
2206: EE61             ReadBuffer:                      ;
2207: EE61 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
2208: EE64 B7                     OR     A                    ; Check status                     ;
2209: EE65 C2 FA F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2210: EE68 C9                     RET                         ;
2211: EE69         ;--------------------------- Read Buffer ----------------------------------;
2212: EE69         ;--------------------------- Set Current Disk Read Only --------------------;
2213: EE69         ;set current disk to read only                                              ;
2214: EE69             SetDiskReadOnly:                      ;
2215: EE69 2A 68 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2216: EE6C         ;
2217: EE6C 3A 66 F5               LD     A,(currentDisk)      ; Get the current disk              ;
2218: EE6F 47                     LD     B,A                  ; Move into B                       ;
2219: EE70 CD B7 F4               CALL   SetVectorBit         ; Set the bit	                    ;
2220: EE73 22 68 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2221: EE76         ;
2222: EE76 2A 83 F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2223: EE79 EB                     EX     DE,HL                ;
2224: EE7A 2A 6E F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2225: EE7D 73                     LD     (HL),E               ;
2226: EE7E 23                     INC    HL                   ;
2227: EE7F 72                     LD     (HL),D               ;
2228: EE80 C9                     RET                         ;
2229: EE81         ;--------------------------- Set disk Read Only ----------------------------;
2230: EE81         ;--------------------------- Is Disk Write Protected -----------------------;
2231: EE81         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2232: EE81         ;					= reset if Write Protected		(NZ)					;
2233: EE81             IsDiskWriteProtected:                      ;
2234: EE81 2A 68 F5               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2235: EE84 3A 66 F5               LD     A,(currentDisk)      ; Get current disk                  ;
2236: EE87 47                     LD     B,A                  ;
2237: EE88 CD A7 F4               CALL   IsBitSet             ; Check the bit                     ;
2238: EE8B C9                     RET                         ; NZ if Disk is RO                  ;
2239: EE8C         ;?	LD		HL,(readOnlyVector)			; Get Read Only Vector              ;
2240: EE8C         ;?	LD		A,(currentDisk)                                                 ;
2241: EE8C         ;?	LD		C,A                                                             ;
2242: EE8C         ;?	CALL	ShiftRightHLbyC                                                 ;
2243: EE8C         ;?	LD		A,L                                                             ;
2244: EE8C         ;?	AND		1BH								; 01BH                          ;
2245: EE8C         ;?	RET										; non zero if nowrite           ;
2246: EE8C         ;--------------------------- Is Disk Write Protected -----------------------;
2247: EE8C
2248: EE8C         ;------------------------- Reselect Disk if Necessary ----------------------;
2249: EE8C         ;check current fcb to see if reselection necessary                         ;
2250: EE8C             ReselectDisk:                      ;
2251: EE8C 3E FF                  LD     A,TRUE               ;
2252: EE8E 32 96 F5               LD     (fResel),A           ; Mark as possible reselect         ;
2253: EE91 2A C3 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2254: EE94 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2255: EE95 E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2256: EE97 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2257: EE98 32 C2 EA               LD     (paramE),A           ; Save drive code                   ;
2258: EE9B FE 1E                  CP     30                   ;
2259: EE9D D2 B0 EE               JP     NC,NoSelect          ; Skip drive >= 30                  ;
2260: EEA0         ;
2261: EEA0 3A 66 F5               LD     A,(currentDisk)      ; Determine the current drive       ;
2262: EEA3 32 97 F5               LD     (entryDisk),A        ; Save it                           ;
2263: EEA6 7E                     LD     A,(HL)               ;
2264: EEA7 32 98 F5               LD     (fcbDisk),A          ; Get calling disk                  ;
2265: EEAA E6 E0                  AND    11100000B            ;
2266: EEAC 77                     LD     (HL),A               ; Preserve User Number              ;
2267: EEAD CD 79 EC               CALL   SelectCurrent        ; Select the new disk               ;
2268: EEB0         ;
2269: EEB0             NoSelect:                       ;
2270: EEB0 3A 65 F5               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2271: EEB3 2A C3 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2272: EEB6 B6                     OR     M                    ; Combine                           ;
2273: EEB7 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2274: EEB8 C9                     RET                         ;
2275: EEB9         ;------------------------- Reselect Disk if Necessary ----------------------;
2276: EEB9
2277: EEB9
2278: EEB9         ;=========================== Disk Utilities ================================;
2279: EEB9
2280: EEB9         ;=========================== File Utilities ================================;
2281: EEB9         ;--------------------------- Set Record Variables -------------------------;
2282: EEB9         ;set variables from currently FCB - Current Record, RC, EXM                ;
2283: EEB9             SetRecordVars:                      ;
2284: EEB9 CD D0 EE               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2285: EEBC         ;  and HL => .CurrentRecord        ;
2286: EEBC 7E                     LD     A,(HL)               ;
2287: EEBD 32 9B F5               LD     (currentFileRecord),A ; Save current record              ;
2288: EEC0 EB                     EX     DE,HL                ;
2289: EEC1 7E                     LD     A,(HL)               ;
2290: EEC2 32 99 F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2291: EEC5 CD DD EE               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2292: EEC8 3A 80 F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2293: EECB A6                     AND    M                    ; Remove unwanted bits             ;
2294: EECC 32 9A F5               LD     (extentValue),A      ; Store the value                  ;
2295: EECF C9                     RET                         ;
2296: EED0         ;--------------------------- Set Record Variables -------------------------;
2297: EED0         ;----------------------Get File Record Count and Current Record------------;
2298: EED0         ; returns with DE pointing at RC from FCB                                  ;
2299: EED0         ;         with HL pointing at Current Record                               ;
2300: EED0             GetFcbRecordDetails:                      ;
2301: EED0 2A C3 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2302: EED3 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2303: EED6 19                     ADD    HL,DE                ;
2304: EED7 EB                     EX     DE,HL                ; DE Points to Record Count        ;
2305: EED8 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;
2306: EEDB 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2307: EEDC C9                     RET                         ;
2308: EEDD         ;----------------------Get File Record Count and Current Record------------;
2309: EEDD         ;----------------------Get FileExtent--------------------------------------;
2310: EEDD         ;get current extent field address to (HL)                                 ;
2311: EEDD             GetExtentAddress:                      ;
2312: EEDD 2A C3 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2313: EEE0 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2314: EEE3 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2315: EEE4 C9                     RET                         ;
2316: EEE5         ;----------------------Get FileExtent--------------------------------------;
2317: EEE5         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2318: EEE5         ; At Entry:	BC Contains to the Block to be modified                        ;
2319: EEE5         ;			E  = TRUE if bit is to be set                                  ;
2320: EEE5         ;			E  <> TRUE if bit is to be reset                               ;
2321: EEE5         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2322: EEE5             SetResetMapBit:                      ;
2323: EEE5         ;
2324: EEE5 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2325: EEE8 09                     ADD    HL,BC                ;  to HL                           ;
2326: EEE9 4B                     LD     C,E                  ; Move the flag to E               ;
2327: EEEA         ;
2328: EEEA 7D                     LD     A,L                  ; LSB of the Block Number          ;
2329: EEEB E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2330: EEED F5                     PUSH   AF                   ; Save the OctetBit                ;
2331: EEEE 06 03                  LD     B,3                  ;
2332: EEF0 CD BE F0               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2333: EEF3 ED 5B 7A F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2334: EEF7 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2335: EEF8 F1                     POP    AF                   ;
2336: EEF9 47                     LD     B,A                  ; Get the bit                      ;
2337: EEFA         ;
2338: EEFA 04                     INC    B                    ; Adjust for looping               ;
2339: EEFB C5                     PUSH   BC                   ; Will need this later             ;
2340: EEFC             Left:                           ;
2341: EEFC CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2342: EEFE 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2343: EF00 C1                     POP    BC                   ; Restore loop limit and           ;
2344: EF01 37                     SCF                         ;  set/reset flag                  ;
2345: EF02 0C                     INC    C                    ; was C = TRUE                     ;
2346: EF03 28 01                  JR     Z,Right              ; Skip if Set                      ;
2347: EF05 3F                     CCF                         ; Set for Reset                    ;
2348: EF06             Right:                          ;
2349: EF06 CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2350: EF08 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2351: EF0A C9                     RET                         ;
2352: EF0B         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2353: EF0B         ;--------------------- Initialize Extent Number MSB -----------------------;
2354: EF0B         ;clear the Extent number field for user open/make (S2)                    ;
2355: EF0B             InitializeExtentNumberMSB:                      ;
2356: EF0B CD 11 EF               CALL   GetExtentNumberMSB   ;
2357: EF0E 36 00                  LD     (HL),0               ; Set it to = 0            ;
2358: EF10 C9                     RET                         ;
2359: EF11         ;--------------------- Initialize Extent Number MSB -----------------------;
2360: EF11         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2361: EF11         ; Get S2 value                                                             ;
2362: EF11         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
2363: EF11         ;			HL = Address of S2 for the FCB pointed to by paramDE           ;
2364: EF11             GetWriteFileFlagValue:                      ; S2 bit 7                 ;
2365: EF11             GetExtentNumberMSB:                      ; S2 bits 0-6              ;
2366: EF11 2A C3 EA               LD     HL,(paramDE)         ; FCB address              ;
2367: EF14 11 0E 00               LD     DE,fcbS2Index        ; Index to value           ;
2368: EF17 19                     ADD    HL,DE                ; Address of value         ;
2369: EF18 7E                     LD     A,(HL)               ; load into ACC            ;
2370: EF19 C9                     RET                         ;
2371: EF1A         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2372: EF1A         ;--------------------------- Set File Write Flag----------------------------;
2373: EF1A         ;Set file write flag in FCB in (paramDE)									;
2374: EF1A         ; Used to indicate the FCB is clean. No need to write on close				;
2375: EF1A             SetFileWriteFlag:                      ;
2376: EF1A CD 11 EF               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2377: EF1D CB FE                  SET    7,(HL)               ; Set the FileWriteFlag				;
2378: EF1F C9                     RET                         ;
2379: EF20         ;?	OR		writeFlagMask				; Set the flag , bit 7 of S2        ;
2380: EF20         ;?	LD		(HL),A						; Put into FCB                      ;
2381: EF20         ;?	RET	                                                                    ;
2382: EF20         ;--------------------------- Set File Write Flag----------------------------;
2383: EF20         ;--------------------------- Reset File Write Flag--------------------------;
2384: EF20         ;Reset file write flag in FCB in (paramDE)									;
2385: EF20         ; Used to indicate the FCB is dirty. Need to write on close					;
2386: EF20             ResetFileWriteFlag:                      ;
2387: EF20 CD 11 EF               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2388: EF23 CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag			;
2389: EF25 C9                     RET                         ;
2390: EF26         ;?	AND		0FFH-writeFlagMask			; Remove the flag bit		        ;
2391: EF26         ;?	LD		(HL),A						; Put into FCB                      ;
2392: EF26         ;?	RET	                                                                    ;
2393: EF26         ;--------------------------- Reset File Write Flag--------------------------;
2394: EF26         ;-------------------------- Compare FCB Extents ----------------------------;
2395: EF26         ; Enters:	A containing Target FCB EXT value								;
2396: EF26         ;			HL Points at Possible FCB EXT value								;
2397: EF26         ;compare extent# in A with that in C, return nonzero if they do not match	;
2398: EF26             CompareExtents:                      ;
2399: EF26 C5                     PUSH   BC                   ; Save Callers Registers			;
2400: EF27 F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2401: EF28 3A 80 F5               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2402: EF2B 2F                     CPL                         ; Complement for And           		;
2403: EF2C 47                     LD     B,A                  ; Put negated Mask into B      		;
2404: EF2D 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2405: EF2E A0                     AND    B                    ; Apply the Mask               		;
2406: EF2F 4F                     LD     C,A                  ; Low bits removed from C      		;
2407: EF30 F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2408: EF31 A0                     AND    B                    ; Apply the Mask               		;
2409: EF32 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2410: EF33 E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2411: EF35 C1                     POP    BC                   ; Restore Callers Registers    		;
2412: EF36 C9                     RET                         ;
2413: EF37         ;-------------------------- Compare FCB Extents ----------------------------;
2414: EF37         ;---------------------Search for Directory Record --------------------------;
2415: EF37         ;        directoryFlag  ????????											;
2416: EF37         ;  Search for directory record of length C.									;
2417: EF37         ; Target is pointed to by paramDE. The whole directory is searched.			;
2418: EF37         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2419: EF37         ; matched directory record													;
2420: EF37         ; Entry:	C = Search Length                                               ;
2421: EF37         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2422: EF37         ;								-1 (EOD) if there is no match				;
2423: EF37             SearchForDirectoryRecord:                      ;
2424: EF37 3E FF                  LD     A,0FFH               ;
2425: EF39 32 8F F5               LD     (directoryFlag),A    ; Initialize directory Flag         ;
2426: EF3C 21 92 F5               LD     HL,searchLength      ;
2427: EF3F 71                     LD     (HL),C               ; Save Search Length                ;
2428: EF40 2A C3 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2429: EF43 22 93 F5               LD     (searchAddress),HL   ; Start of search                   ;
2430: EF46 CD CC EF               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2431: EF49 CD 39 EE               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2432: EF4C         ;
2433: EF4C             GetNextDirectoryRecord:                      ;
2434: EF4C 0E 00                  LD     C,FALSE              ;
2435: EF4E CD E7 F0               CALL   ReadDirectory        ; Read next Dir Record              ;
2436: EF51 CD D3 EF               CALL   AtEndOfDirectory     ;
2437: EF54 CA AB EF               JP     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2438: EF57         ;
2439: EF57 2A 93 F5               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2440: EF5A EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2441: EF5B 1A                     LD     A,(DE)               ; User Number                       ;
2442: EF5C FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2443: EF5E CA 69 EF               JP     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2444: EF61         ;
2445: EF61         ; Check to be sure we are sill in the Directory                             ;
2446: EF61 D5                     PUSH   DE                   ; Save search address               ;
2447: EF62 CD F3 EF               CALL   StillInDirectory     ; Still in the directorY            ;
2448: EF65 D1                     POP    DE                   ; Recall address                    ;
2449: EF66 D2 AB EF               JP     NC,NoDirRecordsMatch ; Get out if past directory			;
2450: EF69         ;
2451: EF69             GetNextDirectoryRecord1:                      ;
2452: EF69 CD DC EF               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2453: EF6C 3A 92 F5               LD     A,(searchLength)     ;
2454: EF6F 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2455: EF70 06 00                  LD     B,0                  ; Character Index (up)              ;
2456: EF72         ;
2457: EF72             TestNextPosition:                      ;
2458: EF72 1A                     LD     A,(DE)               ;
2459: EF73 FE 3F                  CP     QMARK                ; ? is always a char match          ;
2460: EF75 CA 93 EF               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2461: EF78         ;
2462: EF78 78                     LD     A,B                  ;
2463: EF79 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2464: EF7B CA 93 EF               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2465: EF7E         ; not the fcbS1Index field, extent field?                                  ;
2466: EF7E FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2467: EF80 1A                     LD     A,(DE)               ; Get next character                ;
2468: EF81 CA 8D EF               JP     Z,CheckExtents       ; Skip to search extent             ;
2469: EF84 96                     SUB    M                    ; Do they match ?                   ;
2470: EF85 E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2471: EF87 C2 4C EF               JP     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2472: EF8A C3 93 EF               JP     SetNextPosition      ; Matched the character             ;
2473: EF8D         ;                                                                           ;
2474: EF8D             CheckExtents:                      ;
2475: EF8D CD 26 EF               CALL   CompareExtents       ; Matching EXTs is work             ;
2476: EF90 C2 4C EF               JP     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2477: EF93         ;
2478: EF93             SetNextPosition:                      ;
2479: EF93 13                     INC    DE                   ; Pointer to Looking FOR            ;
2480: EF94 23                     INC    HL                   ; Pointer to Looking IN             ;
2481: EF95 04                     INC    B                    ; Character Index in FCB            ;
2482: EF96 0D                     DEC    C                    ; Length of search                  ;
2483: EF97 C2 72 EF               JP     NZ,TestNextPosition  ;
2484: EF9A         ; Match Found, entire name matches                                          ;
2485: EF9A 3A A0 F5               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2486: EF9D E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2487: EF9F 32 C5 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2488: EFA2         ;
2489: EFA2 21 8F F5               LD     HL,directoryFlag     ; Point at Directory Flag           ;
2490: EFA5 7E                     LD     A,(HL)               ; Get value                         ;
2491: EFA6 17                     RLA                         ; Set Carry if Flag = -1            ;
2492: EFA7 D0                     RET    NC                   ; Return with flag still -1         ;
2493: EFA8         ;
2494: EFA8 AF                     XOR    A                    ; Else Clear the flag               ;
2495: EFA9 77                     LD     (HL),A               ;
2496: EFAA C9                     RET                         ;  and exit                         ;
2497: EFAB         ;------                                                                     ;
2498: EFAB             NoDirRecordsMatch:                      ;
2499: EFAB CD CC EF               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2500: EFAE 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2501: EFB0 32 C5 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2502: EFB3 C9                     RET                         ;
2503: EFB4         ;---------------------Search for Directory Record --------------------------;
2504: EFB4         ;---------------------------- Write Current Directory Entry ----------------;
2505: EFB4             WriteDir:                       ;
2506: EFB4         ;	CALL	NewCheckSum						; initialize entry              ;
2507: EFB4 0E FF                  LD     C,TRUE               ;
2508: EFB6 CD 60 F1               CALL   CheckSumUtility      ; Set New CheckSum              ;
2509: EFB9         ;
2510: EFB9 CD 58 EE               CALL   SetDirDMA            ; Directory DMA                 ;
2511: EFBC 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
2512: EFBE CD C4 EF               CALL   WriteBuffer          ; Write the buffer              ;
2513: EFC1 C3 53 EE               JP     SetDataDMA           ; Reset DMA to default			;
2514: EFC4         ;
2515: EFC4         ;---------------------------- Write Current Directory Entry ----------------;
2516: EFC4         ;----------------------------------- Write Buffer --------------------------;
2517: EFC4         ; Write buffer and check condition. Current drive,Track, Sector and DMA     ;
2518: EFC4         ; Are set up prior to calling this routine                                  ;
2519: EFC4         ;                                                                           ;
2520: EFC4         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
2521: EFC4         ;				1 => directory write operation	WriteDirectory              ;
2522: EFC4         ;				2 => start of new block			WriteCleanBuffer			;
2523: EFC4             WriteBuffer:                      ;
2524: EFC4 CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
2525: EFC7 B7                     OR     A                    ; Get return code                   ;
2526: EFC8 C2 FA F4               JP     NZ,erPermanentNoWait ; Error if not 00                   ;
2527: EFCB C9                     RET                         ;
2528: EFCC         ;----------------------------------- Write Buffer --------------------------;
2529: EFCC
2530: EFCC         ;=========================== File Utilities ================================;
2531: EFCC
2532: EFCC         ;=========================== Directory Utilities ===========================;
2533: EFCC         ;--------------------------- Set End of Directory indicator ----------------;
2534: EFCC             SetEndDirectory:                      ;
2535: EFCC 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
2536: EFCF 22 A0 F5               LD     (dirEntryIndex),HL   ;
2537: EFD2 C9                     RET                         ;
2538: EFD3         ;--------------------------- Set End of Directory indicator ----------------;
2539: EFD3         ;--------------------------- Are we at End Of Directory --------------------;
2540: EFD3         ; Tests to see if we are at the End Of the Directory                        ;
2541: EFD3         ;                                                                           ;
2542: EFD3         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
2543: EFD3         ;			 Z Flag reset if still in directory                             ;
2544: EFD3         ;
2545: EFD3             AtEndOfDirectory:                      ;
2546: EFD3 21 A0 F5               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
2547: EFD6 7E                     LD     A,(HL)               ; Get it                            ;
2548: EFD7 23                     INC    HL                   ; Point at MSB	of Dir Index		;
2549: EFD8 BE                     CP     M                    ; LSB = MSB ?                       ;
2550: EFD9 C0                     RET    NZ                   ;  exit if not if different         ;
2551: EFDA         ; Same.  are they = 0ffh?           ;
2552: EFDA 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
2553: EFDB C9                     RET                         ;
2554: EFDC         ;--------------------------- Are we at End Of Directory --------------------;
2555: EFDC         ;--------------------------- Get Directory Element -------------------------;
2556: EFDC         ; compute the address of a directory element in Directory Buffer            ;
2557: EFDC         ; Returns:  HL = Address of the specific directory Record                   ;
2558: EFDC             GetCurrentDirectoryRecord:                      ;
2559: EFDC C5                     PUSH   BC                   ; Save BC                           ;
2560: EFDD 2A 74 F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
2561: EFE0 3A 9F F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
2562: EFE3 4F                     LD     C,A                  ;
2563: EFE4 AF                     XOR    A                    ; Set to Zero and reset CY          ;
2564: EFE5 47                     LD     B,A                  ;
2565: EFE6 ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
2566: EFE8 C1                     POP    BC                   ; Restore	                        ;
2567: EFE9 C9                     RET                         ;
2568: EFEA         ;--------------------------- Get Directory Element -------------------------;
2569: EFEA         ;--------------------------- Set Directory Entry ---------------------------;
2570: EFEA         ; Will update directory if not in the directory                             ;
2571: EFEA         ;
2572: EFEA             SetDirectoryEntry:                      ;
2573: EFEA CD F3 EF               CALL   StillInDirectory     ;
2574: EFED D8                     RET    C                    ; Exit if still in the Directory  	;
2575: EFEE         ;
2576: EFEE         ; StillInDirectory will return with:                                        ;
2577: EFEE         ;									DE = Directory entry number             ;
2578: EFEE         ;									HL = Address of entry number + 1        ;
2579: EFEE 13                     INC    DE                   ;
2580: EFEF 72                     LD     (HL),D               ;
2581: EFF0 2B                     DEC    HL                   ;
2582: EFF1 73                     LD     (HL),E               ;
2583: EFF2 C9                     RET                         ;
2584: EFF3         ;--------------------------- Set Directory Entry ---------------------------;
2585: EFF3         ;--------------------------- Are we sill in the Directory ------------------;
2586: EFF3         ;Returns	:                                                               ;
2587: EFF3         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
2588: EFF3         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
2589: EFF3         ;			HL = (address of Index Value) + 1                               ;
2590: EFF3         ;			DE = Directory Index Value                                      ;
2591: EFF3             StillInDirectory:                      ;
2592: EFF3 2A A0 F5               LD     HL,(dirEntryIndex)   ;
2593: EFF6 EB                     EX     DE,HL                ; DE = directory counter            ;
2594: EFF7 2A 6E F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
2595: EFFA 7B                     LD     A,E                  ;
2596: EFFB 96                     SUB    M                    ;
2597: EFFC 23                     INC    HL                   ;
2598: EFFD 7A                     LD     A,D                  ;
2599: EFFE 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
2600: EFFF C9                     RET                         ;  <= Directory Max Value       ;
2601: F000         ;--------------------------- Are we sill in the Directory ------------------;
2602: F000         ;--------------------------- Scan Disk Map ---------------------------------;
2603: F000         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
2604: F000         ;                                                                           ;
2605: F000         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
2606: F000         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
2607: F000         ;
2608: F000             ScanDiskMap:                      ;
2609: F000 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
2610: F001 CD DC EF               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
2611: F004 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
2612: F007 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
2613: F008 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
2614: F00A         ;
2615: F00A             ScanDiskMap0:                      ;
2616: F00A D1                     POP    DE                   ; Recall the set/reset Info         ;
2617: F00B 0D                     DEC    C                    ;
2618: F00C C8                     RET    Z                    ; Loop once for each disk map entry ;
2619: F00D         ;
2620: F00D D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
2621: F00E 3A 95 F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
2622: F011 B7                     OR     A                    ;
2623: F012 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
2624: F014         ;  Byte Allocation scan operation                                           ;
2625: F014 C5                     PUSH   BC                   ; Save counter                      ;
2626: F015 E5                     PUSH   HL                   ; Save map address                  ;
2627: F016 4E                     LD     C,(HL)               ;
2628: F017 06 00                  LD     B,0                  ; BC=block# for Byte                ;
2629: F019 18 06                  JR     ScanDiskMap2         ;
2630: F01B         ; Word scan operation                                                       ;
2631: F01B             ScanDiskMapWord:                      ;
2632: F01B 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
2633: F01C C5                     PUSH   BC                   ; Save counter                      ;
2634: F01D 46                     LD     B,(HL)               ;
2635: F01E 23                     INC    HL                   ;
2636: F01F 4E                     LD     C,(HL)               ; BC=block# for Word                ;
2637: F020 E5                     PUSH   HL                   ; Save map address                  ;
2638: F021         ;
2639: F021         ; Arrive here with BC=block#, E=0/1	                                        ;
2640: F021             ScanDiskMap2:                      ;
2641: F021 79                     LD     A,C                  ;
2642: F022 B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
2643: F023 C4 E5 EE               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
2644: F026 E1                     POP    HL                   ;
2645: F027 23                     INC    HL                   ; to next bit position              ;
2646: F028 C1                     POP    BC                   ; recall counter                    ;
2647: F029 C3 0A F0               JP     ScanDiskMap0         ; for another item                  ;
2648: F02C         ;
2649: F02C         ;--------------------------- Scan Disk Map ---------------------------------;
2650: F02C         ;--------------------------- Get Closest Disk Block ------------------------;
2651: F02C         ; Find the closest available disk block, and mark in Map as allocated       ;
2652: F02C         ; Enter	BC	= Block number to base the search on                            ;
2653: F02C         ; Exit	HL	= 0000 if There are no available open blocks                    ;
2654: F02C         ;			= block number of available and marked block                    ;
2655: F02C         ;
2656: F02C             GetClosestBlock:                      ;
2657: F02C C5                     PUSH   BC                   ; save the starting Block #         ;
2658: F02D         ;
2659: F02D 2A 81 F5               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
2660: F030 CD BC F0               CALL   DivideHLby8          ; Length of Map	                    ;
2661: F033 EB                     EX     DE,HL                ; put size into DE			        ;
2662: F034 E1                     POP    HL                   ; Block number into HL              ;
2663: F035 CD BC F0               CALL   DivideHLby8          ; Length of Map                     ;
2664: F038 EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
2665: F039 AF                     XOR    A                    ; Reset CY                          ;
2666: F03A ED 52                  SBC    HL,DE                ; Size for right                    ;
2667: F03C         ; DE = Start Index                                                          ;
2668: F03C         ; DE = Left Size                                                            ;
2669: F03C         ; HL	= Right Size                                                        ;
2670: F03C E5                     PUSH   HL                   ; Save right size                   ;
2671: F03D D5                     PUSH   DE                   ; Save left size & Start Index      ;
2672: F03E 3E FF                  LD     A,0FFH               ; Full Octet                        ;
2673: F040         ;
2674: F040 2A 7A F5               LD     HL,(caAllocVector)   ; Start of Map                      ;
2675: F043 19                     ADD    HL,DE                ; Determine initial Octet			;
2676: F044         ; Set up Left side                                                          ;
2677: F044 C1                     POP    BC                   ; Left size                         ;
2678: F045 03                     INC    BC                   ; adjust                            ;
2679: F046 E5                     PUSH   HL                   ; Save initial Octet                ;
2680: F047 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
2681: F04A         ; HL = Initial Octet                                                        ;
2682: F04A         ; BC = Left Size                                                            ;
2683: F04A D9                     EXX                         ; Use alternate registers           ;
2684: F04B 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
2685: F04E E1                     POP    HL                   ; Get Initial Octet                 ;
2686: F04F C1                     POP    BC                   ; Get Right Size                    ;
2687: F050 03                     INC    BC                   ; adjust                            ;
2688: F051             LookRight:                      ;
2689: F051 ED A1                  CPI                         ; UnSet Bit?                        ;
2690: F053 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2691: F055 E2 6E F0               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
2692: F058         ;
2693: F058 D9                     EXX                         ; Switch to the Left                ;
2694: F059 ED A9                  CPD                         ; UnSet Bit?                        ;
2695: F05B 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2696: F05D E2 63 F0               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
2697: F060 D9                     EXX                         ; switch to right                   ;
2698: F061 18 EE                  JR     LookRight            ; Keep on looking                   ;
2699: F063         ;			----------------			                                    ;
2700: F063             NoMoreLeft:                      ;
2701: F063 D9                     EXX                         ; Switch to Right                   ;
2702: F064             NoMoreLeftLoop:                      ;
2703: F064 ED A1                  CPI                         ;
2704: F066 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2705: F068 E2 79 F0               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
2706: F06B 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
2707: F06D 76                     HALT                        ;
2708: F06E             NoMoreRight:                      ;
2709: F06E D9                     EXX                         ; Switch to Left                    ;
2710: F06F             NoMoreRightLoop:                      ;
2711: F06F ED A9                  CPD                         ;
2712: F071 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2713: F073 E2 79 F0               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
2714: F076 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
2715: F078 76                     HALT                        ;
2716: F079             NoFreeBlocks:                      ;
2717: F079 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
2718: F07C C9                     RET                         ;
2719: F07D         ;			----------------			                                    ;
2720: F07D             FoundFreeOctet:                      ;
2721: F07D BB                     CP     E                    ; Left or Right                     ;
2722: F07E 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
2723: F080 2B                     DEC    HL                   ; Adjust for direction              ;
2724: F081 18 01                  JR     FoundFreeOctet2      ;
2725: F083         ;
2726: F083             FoundFreeOctet1:                      ;
2727: F083 23                     INC    HL                   ; Adjust for direction              ;
2728: F084             FoundFreeOctet2:                      ;
2729: F084 01 00 00               LD     BC,00                ; need to keep track of bit         ;
2730: F087             FoundFreeOctet3:                      ;
2731: F087 CB 06                  RLC    (HL)                 ;
2732: F089 03                     INC    BC                   ;
2733: F08A 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
2734: F08C CB C6                  SET    0,(HL)               ; Make map bit set                  ;
2735: F08E 41                     LD     B,C                  ; Put count in B                    ;
2736: F08F             FoundFreeOctet4:                      ;
2737: F08F CB 0E                  RRC    (HL)                 ;
2738: F091 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
2739: F093 0B                     DEC    BC                   ; adjust for Zero based value       ;
2740: F094 C5                     PUSH   BC                   ; Save the bit index                ;
2741: F095 ED 4B 7A F5               LD     BC,(caAllocVector)   ; Get Map start                     ;
2742: F099 AF                     XOR    A                    ; Clear CY                          ;
2743: F09A ED 42                  SBC    HL,BC                ; Get how far in the map            ;
2744: F09C CD C6 F0               CALL   MultiplyHLby8        ; Calculate the Octet           ;
2745: F09F C1                     POP    BC                   ; Restore index into Octet          ;
2746: F0A0 09                     ADD    HL,BC                ; This is the Block Number          ;
2747: F0A1 C9                     RET                         ;
2748: F0A2         ;--------------------------- Get Closest Disk Block ------------------------;
2749: F0A2         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
2750: F0A2             CopyDirEntryToUserDMA:                      ;
2751: F0A2 2A 74 F5               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer         ;
2752: F0A5 ED 5B 6C F5               LD     DE,(initDAMAddress)  ; Point at User's Buffer            ;
2753: F0A9 01 80 00               LD     BC,cpmRecordSize     ; The entire record                 ;
2754: F0AC ED B0                  LDIR                        ; Move it                           ;
2755: F0AE C9                     RET                         ;
2756: F0AF         ;?	LD		HL,(caDirectoryDMA)			; Get pointer to Directory buffer   ;
2757: F0AF         ;?	EX		DE,HL						; put it into DE                    ;
2758: F0AF         ;?	LD		HL,(initDAMAddress)			; destination is user dma address   ;
2759: F0AF         ;?	LD		C,cpmRecordSize					; copy entire record            ;
2760: F0AF         ;?	JP		MoveX                                                           ;
2761: F0AF         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
2762: F0AF
2763: F0AF         ;=========================== Directory Utilities ===========================;
2764: F0AF
2765: F0AF         ; GU
2766: F0AF
2767: F0AF         ;=========================== General   Utilities ===========================;
2768: F0AF
2769: F0AF         ;--------------------------- Rotate HL right by value in C ----------------;
2770: F0AF         ;
2771: F0AF         ; HL = Value to be rotated Right                                           ;
2772: F0AF         ;  B = Amount to shift                                                     ;
2773: F0AF             RotateRightHLbyB:                      ;
2774: F0AF 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
2775: F0B0 CB 45                  BIT    0,L                  ; is LSB set?                      ;
2776: F0B2 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
2777: F0B4 3F                     CCF                         ; else Clear Carry flag            ;
2778: F0B5             RotateRightHLbyB1:                      ;
2779: F0B5 CB 1C                  RR     H                    ; Shift thru CY                    ;
2780: F0B7 CB 1D                  RR     L                    ; ditto                            ;
2781: F0B9 10 F4                  DJNZ   RotateRightHLbyB     ;
2782: F0BB C9                     RET                         ;
2783: F0BC         ;
2784: F0BC         ;--------------------------- Rotate HL right by value in C ----------------;
2785: F0BC         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2786: F0BC         ; HL = Value to be shifted Right                                           ;
2787: F0BC             DivideHLby8:                      ;
2788: F0BC 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2789: F0BE         ;  B = Amount to shift                                                     ;
2790: F0BE             ShiftRightHLbyB:                      ;
2791: F0BE AF                     XOR    A                    ; else Clear Carry flag            ;
2792: F0BF CB 1C                  RR     H                    ; Shift thru CY                    ;
2793: F0C1 CB 1D                  RR     L                    ; ditto                            ;
2794: F0C3 10 F9                  DJNZ   ShiftRightHLbyB      ;
2795: F0C5 C9                     RET                         ;
2796: F0C6         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2797: F0C6         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2798: F0C6         ; HL = Value to be shifted Left                                            ;
2799: F0C6             MultiplyHLby8:                      ;
2800: F0C6 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2801: F0C8         ;  B = Amount to shift                                                     ;
2802: F0C8             ShiftLeftHLbyB:                      ;
2803: F0C8 AF                     XOR    A                    ; else Clear Carry flag            ;
2804: F0C9 CB 15                  RL     L                    ; Shift thru CY                    ;
2805: F0CB CB 14                  RL     H                    ; ditto                            ;
2806: F0CD 10 F9                  DJNZ   ShiftLeftHLbyB       ;
2807: F0CF C9                     RET                         ;
2808: F0D0         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2809: F0D0         ;----------------------------- Merge ---------------------------------------;
2810: F0D0         ; Merge Map Block Numbers between FCB and directory record                  ;
2811: F0D0         ; HL has pointer to map for either dir record or FCB,                       ;
2812: F0D0         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
2813: F0D0         ; it just returns, Else it copies the block number to where DE is pointing  ;
2814: F0D0         ;
2815: F0D0             Merge:                          ;
2816: F0D0 7E                     LD     A,(HL)               ; Get the first byte                ;
2817: F0D1 23                     INC    HL                   ;
2818: F0D2 B6                     OR     M                    ; OR it with the second byte        ;
2819: F0D3 2B                     DEC    HL                   ; Restore HL to start               ;
2820: F0D4 C0                     RET    NZ                   ; Exit if both are 0s               ;
2821: F0D5         ; HL points to a non Zero value	                                            ;
2822: F0D5 1A                     LD     A,(DE)               ; Get the first byte                ;
2823: F0D6 77                     LD     (HL),A               ; Move it                           ;
2824: F0D7 13                     INC    DE                   ;
2825: F0D8 23                     INC    HL                   ; Increment both pointers           ;
2826: F0D9 1A                     LD     A,(DE)               ; Get the second byte               ;
2827: F0DA 77                     LD     (HL),A               ; Move it                           ;
2828: F0DB 1B                     DEC    DE                   ;
2829: F0DC 2B                     DEC    HL                   ; Restore HL & DE to start          ;
2830: F0DD C9                     RET                         ;
2831: F0DE         ;----------------------------- Merge ---------------------------------------;
2832: F0DE
2833: F0DE
2834: F0DE         ;=========================== General   Utilities ===========================;
2835: F0DE
2836: F0DE         ;--------------------------- Read Directory Record -------------------------;
2837: F0DE         ; read a directory entry into the directory buffer                          ;
2838: F0DE             ReadDirRecord:                      ;
2839: F0DE CD 58 EE               CALL   SetDirDMA            ; System Assigned Buffer            ;
2840: F0E1 CD 61 EE               CALL   ReadBuffer           ; Go to BIOS for the read           ;
2841: F0E4 C3 53 EE               JP     SetDataDMA           ; Restore DMA                       ;
2842: F0E7         ;--------------------------- Read Directory Record -------------------------;
2843: F0E7
2844: F0E7         ;--------------------------- Read Directory --------------------------------;
2845: F0E7         ; Read next directory entry                                                 ;
2846: F0E7         ; Enter :                                                                   ;
2847: F0E7         ;		C =  TRUE initializing and setting CheckSum                         ;
2848: F0E7         ;		  <> TRUE Checking existing CheckSum                                ;
2849: F0E7             ReadDirectory:                      ;
2850: F0E7 ED 5B 83 F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
2851: F0EB 2A A0 F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
2852: F0EE 23                     INC    HL                   ; Increment the Index               ;
2853: F0EF 22 A0 F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
2854: F0F2 AF                     XOR    A                    ; Clear the CY flag                 ;
2855: F0F3 ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
2856: F0F5 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
2857: F0F7 CD CC EF               CALL   SetEndDirectory      ;  else we are done                 ;
2858: F0FA C9                     RET                         ;
2859: F0FB         ;
2860: F0FB         ; Calculate the entry index Position in Buffer                              ;
2861: F0FB             ReadDirectory0:                      ;
2862: F0FB 3A A0 F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
2863: F0FE E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
2864: F100 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
2865: F102             ReadDirectory1:                      ;
2866: F102 87                     ADD    A,A                  ;
2867: F103 10 FD                  DJNZ   ReadDirectory1       ;
2868: F105 32 9F F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
2869: F108 B7                     OR     A                    ; Is this the 1st entry?            ;
2870: F109 C0                     RET    NZ                   ;  return if not.                   ;
2871: F10A         ;
2872: F10A C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
2873: F10B CD 15 F1               CALL   SeekDir              ; Set up for Directory Read         ;
2874: F10E CD DE F0               CALL   ReadDirRecord        ; Read the directory record         ;
2875: F111 C1                     POP    BC                   ; Recall initialization flag        ;
2876: F112 C3 60 F1               JP     CheckSumUtility      ; Checksum the directory            ;
2877: F115         ;--------------------------- Read Directory --------------------------------;
2878: F115         ;--------------------------- Seek Directory --------------------------------;
2879: F115         ;seek the record containing the current directory entry					;
2880: F115             SeekDir:                        ;
2881: F115 2A A0 F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
2882: F118 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
2883: F11A CD BE F0               CALL   ShiftRightHLbyB      ;
2884: F11D 22 9D F5               LD     (absoluteCPMRecord),HL ;
2885: F120 22 A2 F5               LD     (dirRecord),HL       ; Save                              ;
2886: F123 C3 26 F1               JP     Seek                 ;
2887: F126         ;--------------------------- Seek Directory --------------------------------;
2888: F126         ;--------------------------- Seek ------------------------------------------;
2889: F126             Seek:                           ;
2890: F126 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
2891: F129 2A 9D F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
2892: F12C ED 5B 7C F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
2893: F130         ;
2894: F130             Seek0:                          ;
2895: F130 03                     INC    BC                   ; Divide the record                 ;
2896: F131 AF                     XOR    A                    ;  by the sectors per track         ;
2897: F132 ED 52                  SBC    HL,DE                ;
2898: F134 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
2899: F136         ;
2900: F136         ;
2901: F136 19                     ADD    HL,DE                ; Gets the sector in the track      ;
2902: F137 E5                     PUSH   HL                   ; Save Index Sector                 ;
2903: F138         ;
2904: F138 DD 2A 70 F5               LD     IX,(caTrack)         ;
2905: F13C DD 71 00               LD     (IX+0),C             ;
2906: F13F DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
2907: F142         ;
2908: F142 EB                     EX     DE,HL                ; Take the index from the record    ;
2909: F143 2A 9D F5               LD     HL,(absoluteCPMRecord) ;
2910: F146 AF                     XOR    A                    ;
2911: F147 ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
2912: F149         ;
2913: F149 DD 2A 72 F5               LD     IX,(caSector)        ;
2914: F14D DD 75 00               LD     (IX+0),L             ;
2915: F150 DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
2916: F153         ;
2917: F153 2A 89 F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
2918: F156 09                     ADD    HL,BC                ;  to add to the gross Track        ;
2919: F157 E5                     PUSH   HL                   ;  which yields the net or          ;
2920: F158 C1                     POP    BC                   ;  actual track for the record      ;
2921: F159 CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
2922: F15C         ;
2923: F15C C1                     POP    BC                   ; Get the sector within the track   ;
2924: F15D C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
2925: F160         ;
2926: F160         ;--------------------------- Seek ------------------------------------------;
2927: F160         ;--------------------------- Check Sum Utility -----------------------------;
2928: F160         ; At entry                                                                  ;
2929: F160         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
2930: F160         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
2931: F160         ;
2932: F160             CheckSumUtility:                      ;
2933: F160 2A 87 F5               LD     HL,(dpbCKS)          ;
2934: F163 ED 5B A2 F5               LD     DE,(dirRecord)       ;
2935: F167 AF                     XOR    A                    ;
2936: F168 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
2937: F16A D8                     RET    C                    ;  Entries                      ;
2938: F16B         ;
2939: F16B C5                     PUSH   BC                   ; Save New/Validate Flag        ;
2940: F16C         ;
2941: F16C         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
2942: F16C             ComputeCheckSum:                      ;
2943: F16C 06 80                  LD     B,cpmRecordSize      ;
2944: F16E 2A 74 F5               LD     HL,(caDirectoryDMA)  ;
2945: F171 EE 00                  XOR                         ;
2946: F173             ComputeCheckSum1:                      ;
2947: F173 86                     ADD    A,(HL)               ;
2948: F174 23                     INC    HL                   ;
2949: F175 10 FC                  DJNZ   ComputeCheckSum1     ;
2950: F177         ; Checksum is in ACC	                                                    ;
2951: F177         ;
2952: F177 2A 78 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
2953: F17A ED 5B A2 F5               LD     DE,(dirRecord)       ; Index to this record              ;
2954: F17E 19                     ADD    HL,DE                ; Address of this record in vector  ;
2955: F17F C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
2956: F180 0C                     INC    C                    ;
2957: F181 CA 8E F1               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
2958: F184         ;
2959: F184 BE                     CP     M                    ; Else we are checking the value    ;
2960: F185 C8                     RET    Z                    ; Exit if OK                        ;
2961: F186         ; possible checksum error, are we beyond the end of the disk?               ;
2962: F186 CD F3 EF               CALL   StillInDirectory     ;
2963: F189 D0                     RET    NC                   ; OK, if not in the directory       ;
2964: F18A CD 69 EE               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
2965: F18D C9                     RET                         ;  Set disk RO before returning     ;
2966: F18E         ;
2967: F18E         ;initializing the checksum                                                 ;
2968: F18E             SetNewCheckSum:                      ;
2969: F18E 77                     LD     (HL),A               ;
2970: F18F C9                     RET                         ;
2971: F190         ;--------------------------- Check Sum Utility -----------------------------;
2972: F190
2973: F190
2974: F190         ;---------------------
2975: F190         ;update variables from I/O in  fcb
2976: F190             UpdateRecordVars:
2977: F190 CD D0 EE               CALL   GetFcbRecordDetails  ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2978: F193 3A 90 F5               LD     A,(seqReadFlag)
2979: F196 4F                     LD     C,A                  ; =1 if sequential i/o
2980: F197 3A 9B F5               LD     A,(currentFileRecord) ; get NEXT_RECORD
2981: F19A 81                     ADD    A,C
2982: F19B 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=current File Record+seqReadFlag
2983: F19C EB                     EX     DE,HL
2984: F19D 3A 99 F5               LD     A,(fcbRecordCount)
2985: F1A0 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2986: F1A1 C9                     RET
2987: F1A2         ;---------------------
2988: F1A2         ;set file Attributes for current fcb
2989: F1A2             SetAttributes:
2990: F1A2 0E 0C                  LD     C,fcbExtIndex
2991: F1A4 CD 37 EF               CALL   SearchForDirectoryRecord ; through file type
2992: F1A7             SetAttributes1:
2993: F1A7 CD D3 EF               CALL   AtEndOfDirectory
2994: F1AA C8                     RET    Z                    ; exit at end of dir
2995: F1AB 0E 00                  LD     C,0
2996: F1AD 1E 0C                  LD     E,fcbExtIndex        ;copy name
2997: F1AF CD 2F F4               CALL   CopyDir
2998: F1B2 CD 4C EF               CALL   GetNextDirectoryRecord
2999: F1B5 C3 A7 F1               JP     SetAttributes1
3000: F1B8         ;
3001: F1B8         ;*****************************************************************
3002: F1B8
3003: F1B8         ;*****************************************************************
3004: F1B8         ;********************** File  Routines ***************************
3005: F1B8         ;*****************************************************************
3006: F1B8         ;search for next occurrence of a file name
3007: F1B8         ; OUT - (A)	Directory Code
3008: F1B8         ;	0-3 = success ; 0FFH = File Not Found
3009: F1B8             vFindNext:                      ; func18: (18 - 12) Search for next
3010: F1B8 2A 93 F5               LD     HL,(searchAddress)
3011: F1BB 22 C3 EA               LD     (paramDE),HL
3012: F1BE CD 8C EE               CALL   ReselectDisk
3013: F1C1 CD 4C EF               CALL   GetNextDirectoryRecord
3014: F1C4 C3 A2 F0               JP     CopyDirEntryToUserDMA ; copy directory entry to user
3015: F1C7         ;-----------------------------------------------------------------
3016: F1C7         ;search for next occurrence of a file name
3017: F1C7         ; OUT - (A)	Directory Code
3018: F1C7         ;delete a file
3019: F1C7             vDeleteFile:                      ; func18: (19 - 13) Delete File
3020: F1C7 CD 8C EE               CALL   ReselectDisk
3021: F1CA CD CD F3               CALL   DeleteFile
3022: F1CD C3 1B F4               JP     DirLocationToReturnLoc
3023: F1D0         ;-----------------------------------------------------------------
3024: F1D0         ;read sequential
3025: F1D0         ;IN  - (DE) FCB address
3026: F1D0         ;OUT - (A) 00 = success and data available. else no read and no data
3027: F1D0             vReadSeq:                       ; func20: (20 - 14) read sequential
3028: F1D0 CD 8C EE               CALL   ReselectDisk
3029: F1D3 CD 04 F2               CALL   ReadSeq
3030: F1D6 C9                     RET
3031: F1D7         ;-----------------------------------------------------------------
3032: F1D7         ;write sequential
3033: F1D7         ;IN  - (DE) FCB address
3034: F1D7         ;OUT - (A) 00 = success and data available. else no read and no data
3035: F1D7             vWriteSeq:                      ; func21 (21 - 15) write sequention
3036: F1D7 CD 8C EE               CALL   ReselectDisk
3037: F1DA CD 47 F2               CALL   DiskWriteSeq
3038: F1DD C9                     RET
3039: F1DE         ;-----------------------------------------------------------------
3040: F1DE         ; Make file
3041: F1DE         ; In - (DE)	FCB Address
3042: F1DE         ; OUT - (A)	Directory Code
3043: F1DE         ;	0-3 = success ; 0FFH = File Not Found
3044: F1DE             vMakeFile:                      ; func22 (22 - 16) Make file
3045: F1DE CD 0B EF               CALL   InitializeExtentNumberMSB ; set S2 to Zero
3046: F1E1 CD 8C EE               CALL   ReselectDisk
3047: F1E4 C3 97 F3               JP     MakeNewFile
3048: F1E7         ;-----------------------------------------------------------------
3049: F1E7         ; Rename file
3050: F1E7         ; In - (DE)	FCB Address
3051: F1E7         ; OUT - (A)	Directory Code
3052: F1E7         ;	0-3 = success ; 0FFH = File Not Found
3053: F1E7             vRenameFile:                      ; func23 (23 - 17) Rename File
3054: F1E7 CD 8C EE               CALL   ReselectDisk
3055: F1EA CD 72 F3               CALL   Rename
3056: F1ED C3 1B F4               JP     DirLocationToReturnLoc
3057: F1F0         ;-----------------------------------------------------------------
3058: F1F0         ;-----------------------------------------------------------------
3059: F1F0         ;*****************************************************************
3060: F1F0         ;-----------------------------------------------------------------
3061: F1F0         ;check current directory element for read/only status
3062: F1F0             CheckRODirectory:
3063: F1F0 CD DC EF               CALL   GetCurrentDirectoryRecord ; address of element
3064: F1F3         ;	JMP	CheckROFile
3065: F1F3         ;------------
3066: F1F3         ;check current buff(dptr) or fcb(0) for r/o status
3067: F1F3             CheckROFile:
3068: F1F3 11 09 00               LD     DE,fcbROfileIndex
3069: F1F6 19                     ADD    HL,DE                ; offset to ro bit
3070: F1F7 7E                     LD     A,(HL)
3071: F1F8 17                     RLA
3072: F1F9 D0                     RET    NC                   ; return if not set
3073: F1FA C3 E1 F4               JP     errReadOnlyFile      ; exit to read only disk message
3074: F1FD         ;-----------------------------------------------------------------
3075: F1FD         ;check for write protected disk
3076: F1FD             CheckWrite:
3077: F1FD CD 81 EE               CALL   IsDiskWriteProtected
3078: F200 C8                     RET    Z                    ; OK to write
3079: F201 C3 DB F4               JP     errReadOnlyDisk      ; read only disk error
3080: F204         ;-----------------------------------------------------------------
3081: F204         ;-----------------------------------------------------------------
3082: F204         ;sequential disk read operation
3083: F204             ReadSeq:
3084: F204 3E 01                  LD     A,1
3085: F206 32 90 F5               LD     (seqReadFlag),A      ; set flag for seqential read
3086: F209         ;---
3087: F209         ; read the disk
3088: F209         ; read the next record from the current fcb
3089: F209             DiskRead:
3090: F209 3E FF                  LD     A,TRUE
3091: F20B 32 8E F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
3092: F20E
3093: F20E CD B9 EE               CALL   SetRecordVars        ; sets current File Record, fcbRecordCount and EXM
3094: F211 3A 9B F5               LD     A,(currentFileRecord)
3095: F214 21 99 F5               LD     HL,fcbRecordCount
3096: F217 BE                     CP     M                    ; current File Record-fcbRecordCount
3097: F218         ; skip if  current File Record < fcbRecordCount
3098: F218 DA 2E F2               JP     C,RecordOK
3099: F21B         ; not enough records in the extent
3100: F21B FE 80                  CP     RecordsPerExtent     ; current File Record = 128?   *** Records in an Extent
3101: F21D C2 44 F2               JP     NZ,DiskEOF           ; skip if current File Record<>128
3102: F220 CD 0F F3               CALL   OpenNextExt          ; go to next extent if so
3103: F223 AF                     XOR    A
3104: F224 32 9B F5               LD     (currentFileRecord),A ; current File Record=00
3105: F227         ; now check for open ok
3106: F227 3A C5 EA               LD     A,(exitParameterByte)
3107: F22A B7                     OR     A
3108: F22B C2 44 F2               JP     NZ,DiskEOF
3109: F22E         ; stop at eof
3110: F22E         ; arrive with fcb addressing a record to read
3111: F22E             RecordOK:                       ; recordok:
3112: F22E CD EF F3               CALL   GetBlockNumber       ; save it in Absolute CPM Record
3113: F231 CD FC F3               CALL   IsAllocated          ; Absolute CPM Record=0000?
3114: F234 CA 44 F2               JP     Z,DiskEOF            ; get out if not allocated already
3115: F237
3116: F237 CD 02 F4               CALL   SetActualRecordAdd   ; Absolute CPM Record now a record value
3117: F23A CD 26 F1               CALL   Seek                 ; to proper track,sector
3118: F23D CD 61 EE               CALL   ReadBuffer           ; to dma address
3119: F240 CD 90 F1               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
3120: F243 C9                     RET
3121: F244             DiskEOF:                        ; diskeof:
3122: F244 C3 22 F4               JP     SetLowReturnTo1      ; exitParameterByte = 1
3123: F247         ;ret
3124: F247         ;-----------------------------------------------------------------
3125: F247         ;sequential disk write
3126: F247             DiskWriteSeq:
3127: F247 3E 01                  LD     A,1
3128: F249 32 90 F5               LD     (seqReadFlag),A
3129: F24C         ;--------
3130: F24C         ;disk write
3131: F24C             DiskWrite:
3132: F24C 3E 00                  LD     A,FALSE
3133: F24E 32 8E F5               LD     (readModeFlag),A
3134: F251         ; write record to currently selected file
3135: F251 CD FD F1               CALL   CheckWrite           ; in case write protected
3136: F254 2A C3 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
3137: F257 CD F3 F1               CALL   CheckROFile          ; may be a read-only file
3138: F25A CD B9 EE               CALL   SetRecordVars        ; set local Record parameters
3139: F25D 3A 9B F5               LD     A,(currentFileRecord)
3140: F260 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
3141: F262 DA 69 F2               JP     C,DiskWrite1         ; skip if in the same Extent
3142: F265 CD 22 F4               CALL   SetLowReturnTo1
3143: F268 C9                     RET                         ; Exit ???????????
3144: F269
3145: F269         ; can write the next record, so continue
3146: F269             DiskWrite1:
3147: F269 CD EF F3               CALL   GetBlockNumber       ; sets up actual block number
3148: F26C CD FC F3               CALL   IsAllocated
3149: F26F 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
3150: F271 C2 BF F2               JP     NZ,DiskWrite3
3151: F274         ; not allocated -
3152: F274         ; the argument to getblock is the starting position for the disk search
3153: F274         ; and should be the last allocated block for this file,
3154: F274         ; or the value 0 if no space has been allocated
3155: F274
3156: F274 CD 44 F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
3157: F277 32 91 F5               LD     (diskMapIndex),A     ; save for later
3158: F27A 01 00 00               LD     BC,0000h             ; may use block zero
3159: F27D B7                     OR     A
3160: F27E CA 88 F2               JP     Z,FirstBlock         ; skip if no previous block
3161: F281         ; previous block exists
3162: F281 4F                     LD     C,A
3163: F282 0B                     DEC    BC                   ; previous block # in BC
3164: F283 CD 64 F4               CALL   GetDiskMapValue      ; previous block # to HL
3165: F286 44                     LD     B,H
3166: F287 4D                     LD     C,L                  ; BC=prev block#
3167: F288         ; BC = 0000, or previous block #
3168: F288             FirstBlock:
3169: F288         ;	CALL	GetClosestBlockXX					; block # to HL
3170: F288 CD 2C F0               CALL   GetClosestBlock
3171: F28B         ; arrive here with block# or zero
3172: F28B 7D                     LD     A,L
3173: F28C B4                     OR     H
3174: F28D C2 96 F2               JP     NZ,BlockOK
3175: F290         ; cannot find a block to allocate
3176: F290 3E 02                  LD     A,2
3177: F292 32 C5 EA               LD     (exitParameterByte),A
3178: F295 C9                     RET                         ; exitParameterByte=2
3179: F296
3180: F296             BlockOK:
3181: F296 22 9D F5               LD     (absoluteCPMRecord),HL ; allocated block number is in HL
3182: F299 EB                     EX     DE,HL                ; block number to DE
3183: F29A 2A C3 EA               LD     HL,(paramDE)
3184: F29D 01 10 00               LD     BC,fcbDiskMapIndex
3185: F2A0 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
3186: F2A1 3A 95 F5               LD     A,(byteAllocationFlag)
3187: F2A4 B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
3188: F2A5 3A 91 F5               LD     A,(diskMapIndex)     ; recall dm index
3189: F2A8 CA B2 F2               JP     Z,Allocate16Bit      ; skip if allocating word
3190: F2AB         ; else allocate using a byte value
3191: F2AB CD 7D F4               CALL   AddAtoHL
3192: F2AE 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
3193: F2AF C3 BA F2               JP     DiskWrite2           ; to continue
3194: F2B2
3195: F2B2             Allocate16Bit:                      ; allocate a word value
3196: F2B2
3197: F2B2 4F                     LD     C,A
3198: F2B3 06 00                  LD     B,0                  ; double(diskMapIndex)
3199: F2B5 09                     ADD    HL,BC
3200: F2B6 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
3201: F2B7 72                     LD     (HL),D
3202: F2B8 23                     INC    HL
3203: F2B9 73                     LD     (HL),E               ; double wd
3204: F2BA         ; disk write to previously unallocated block
3205: F2BA             DiskWrite2:
3206: F2BA 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
3207: F2BC CD 20 EF               CALL   ResetFileWriteFlag
3208: F2BF         ; continue the write operation of no allocation error
3209: F2BF         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
3210: F2BF
3211: F2BF             DiskWrite3:
3212: F2BF 3A C5 EA               LD     A,(exitParameterByte)
3213: F2C2 B7                     OR     A
3214: F2C3 C0                     RET    NZ                   ; stop if non zero returned value
3215: F2C4
3216: F2C4 C5                     PUSH   BC                   ; save write flag ( in C see above)
3217: F2C5 CD 02 F4               CALL   SetActualRecordAdd   ; Absolute CPM Record set to actual record number
3218: F2C8 CD 26 F1               CALL   Seek                 ; to proper file position
3219: F2CB C1                     POP    BC                   ; get write flag
3220: F2CC C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
3221: F2CD CD C4 EF               CALL   WriteBuffer          ; written to disk
3222: F2D0 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
3223: F2D1         ; increment record count if fcbRecordCount<=current File Record
3224: F2D1 3A 9B F5               LD     A,(currentFileRecord)
3225: F2D4 21 99 F5               LD     HL,fcbRecordCount
3226: F2D7 BE                     CP     M                    ; current File Record-fcbRecordCount
3227: F2D8 DA DF F2               JP     C,DiskWrite4
3228: F2DB         ; fcbRecordCount <= current File Record
3229: F2DB 77                     LD     (HL),A
3230: F2DC 34                     INC    M                    ; fcbRecordCount = current File Record+1
3231: F2DD 0E 02                  LD     C,2                  ; mark as record count incremented
3232: F2DF             DiskWrite4:
3233: F2DF         ; A has current File Record, C=2 if new block or new record#
3234: F2DF 0D                     DEC    C
3235: F2E0 0D                     DEC    C
3236: F2E1 C2 EC F2               JP     NZ,DiskWrite5
3237: F2E4 F5                     PUSH   AF                   ; save current File Record value
3238: F2E5 CD 11 EF               CALL   GetExtentNumberMSB   ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3239: F2E8         ; reset the file write flag to mark as written fcb
3240: F2E8 E6 7F                  AND    7FH                  ; not writeFlagMask
3241: F2EA 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
3242: F2EB F1                     POP    AF                   ; restore current File Record
3243: F2EC             DiskWrite5:
3244: F2EC         ; check for end of extent, if found attempt to open next extent in preparation for next write
3245: F2EC FE 7F                  CP     highestRecordNumber  ; current File Record=highestRecordNumber?
3246: F2EE C2 0C F3               JP     NZ,DiskWrite7        ; skip if not
3247: F2F1         ; may be random access write, if so we are done
3248: F2F1 3A 90 F5               LD     A,(seqReadFlag)
3249: F2F4 B7                     OR     A
3250: F2F5 CA 0C F3               JP     Z,DiskWrite7         ; skip next extent open op
3251: F2F8         ; update current fcb before going to next extent
3252: F2F8 CD 90 F1               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
3253: F2FB CD 0F F3               CALL   OpenNextExt          ; readModeFlag=false
3254: F2FE         ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
3255: F2FE 21 C5 EA               LD     HL,exitParameterByte
3256: F301 7E                     LD     A,(HL)
3257: F302 B7                     OR     A
3258: F303 C2 0A F3               JP     NZ,DiskWrite6        ; no space
3259: F306         ; space available, set current File Record=255
3260: F306 3D                     DEC    A
3261: F307 32 9B F5               LD     (currentFileRecord),A ; goes to 00 next time
3262: F30A             DiskWrite6:
3263: F30A 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
3264: F30C             DiskWrite7:
3265: F30C C3 90 F1               JP     UpdateRecordVars     ; update variables from I/O in  fcb
3266: F30F         ;ret
3267: F30F         ;-----------------------------------------------------------------
3268: F30F         ;close the current extent  and open the next one if possible.
3269: F30F         ;readModeFlag is true if in read mode
3270: F30F             OpenNextExt:                      ; open$reel
3271: F30F AF                     XOR    A
3272: F310 32 8D F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
3273: F313 CD 9F ED               CALL   CloseDirEntry        ; close current extent
3274: F316         ; exitParameterByte remains at enddir if we cannot open the next ext
3275: F316 CD D3 EF               CALL   AtEndOfDirectory
3276: F319 C8                     RET    Z                    ; return if end
3277: F31A 2A C3 EA               LD     HL,(paramDE)         ; increment extent number
3278: F31D 01 0C 00               LD     BC,fcbExtIndex
3279: F320 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
3280: F321 7E                     LD     A,(HL)
3281: F322 3C                     INC    A
3282: F323 E6 1F                  AND    maxExtValue
3283: F325 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
3284: F326 CA 38 F3               JP     Z,OpenNextModule     ; move to next module if zero
3285: F329         ; may be in the same extent group
3286: F329 47                     LD     B,A
3287: F32A 3A 80 F5               LD     A,(dpbEXM)
3288: F32D A0                     AND    B
3289: F32E         ; if result is zero, then not in the same group
3290: F32E 21 8D F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
3291: F331 A6                     AND    M                    ; produces a 00 in accumulator if not written
3292: F332 CA 43 F3               JP     Z,OpenNextExt1       ; go to next physical extent
3293: F335         ; result is non zero, so we must be in same logical ext
3294: F335 C3 61 F3               JP     OpenNextExt2         ; to copy fcb information
3295: F338         ; extent number overflow, go to next module
3296: F338
3297: F338             OpenNextModule:
3298: F338 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
3299: F33B 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
3300: F33C 34                     INC    M                    ; fcb(fcbS2Index)=++1
3301: F33D         ; module number incremented, check for overflow
3302: F33D 7E                     LD     A,(HL)
3303: F33E E6 0F                  AND    moduleMask           ; mask high order bits
3304: F340 CA 6C F3               JP     Z,OpenNextExtError   ; cannot overflow to zero
3305: F343         ; otherwise, ok to continue with new module
3306: F343
3307: F343             OpenNextExt1:
3308: F343 0E 0F                  LD     C,nameLength
3309: F345 CD 37 EF               CALL   SearchForDirectoryRecord ; next extent found?
3310: F348 CD D3 EF               CALL   AtEndOfDirectory
3311: F34B C2 61 F3               JP     NZ,OpenNextExt2
3312: F34E         ; end of file encountered
3313: F34E 3A 8E F5               LD     A,(readModeFlag)
3314: F351 3C                     INC    A                    ; 0ffh becomes 00 if read
3315: F352 CA 6C F3               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
3316: F355         ; try to extend the current file
3317: F355 CD 97 F3               CALL   MakeNewFile
3318: F358         ; cannot be end of directory
3319: F358 CD D3 EF               CALL   AtEndOfDirectory
3320: F35B CA 6C F3               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
3321: F35E C3 64 F3               JP     OpenNextExt3
3322: F361
3323: F361         ; not end of file, open
3324: F361             OpenNextExt2:
3325: F361 CD 65 ED               CALL   CopyDirRecordToFCB
3326: F364             OpenNextExt3:
3327: F364 CD B9 EE               CALL   SetRecordVars        ; Set Record parameters
3328: F367 AF                     XOR    A
3329: F368 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
3330: F36B C9                     RET                         ; with exitParameterByte = 0
3331: F36C
3332: F36C         ; cannot move to next extent of this file
3333: F36C             OpenNextExtError:
3334: F36C CD 22 F4               CALL   SetLowReturnTo1      ; exitParameterByte = 1
3335: F36F C3 1A EF               JP     SetFileWriteFlag     ; ensure that it will not be closed
3336: F372         ;-----------------------------------------------------------------
3337: F372         ;rename the file described by the first half of the currently addressed FCB.
3338: F372         ;the new name is contained in the last half of the FCB. The file name and type
3339: F372         ;are changed, but the reel number is ignored.  the user number is identical
3340: F372             Rename:
3341: F372 CD FD F1               CALL   CheckWrite           ; may be write protected
3342: F375         ; search up to the extent field
3343: F375 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
3344: F377 CD 37 EF               CALL   SearchForDirectoryRecord
3345: F37A         ; copy position 0
3346: F37A 2A C3 EA               LD     HL,(paramDE)
3347: F37D 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
3348: F37E 11 10 00               LD     DE,fcbDiskMapIndex
3349: F381 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
3350: F382 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
3351: F383         ; assume the same disk drive for new named file
3352: F383             Rename1:
3353: F383 CD D3 EF               CALL   AtEndOfDirectory
3354: F386 C8                     RET    Z                    ; stop at end of dir
3355: F387         ; not end of directory, rename next element
3356: F387 CD F0 F1               CALL   CheckRODirectory     ; may be read-only file
3357: F38A 0E 10                  LD     C,fcbDiskMapIndex
3358: F38C 1E 0C                  LD     E,fcbExtIndex
3359: F38E CD 2F F4               CALL   CopyDir
3360: F391         ; element renamed, move to next
3361: F391 CD 4C EF               CALL   GetNextDirectoryRecord
3362: F394 C3 83 F3               JP     Rename1
3363: F397         ;-----------------------------------------------------------------
3364: F397         ;create a new file by creating a directory entry then opening the file
3365: F397             MakeNewFile:
3366: F397 CD FD F1               CALL   CheckWrite           ; may be write protected
3367: F39A 2A C3 EA               LD     HL,(paramDE)
3368: F39D E5                     PUSH   HL                   ; save fcb address, look for e5
3369: F39E 21 67 F5               LD     HL,emptyFCB
3370: F3A1 22 C3 EA               LD     (paramDE),HL         ; paramDE = .empty
3371: F3A4 0E 01                  LD     C,1
3372: F3A6 CD 37 EF               CALL   SearchForDirectoryRecord ; length 1 match on empty entry
3373: F3A9 CD D3 EF               CALL   AtEndOfDirectory     ; zero flag set if no space
3374: F3AC E1                     POP    HL                   ; recall paramDE address
3375: F3AD 22 C3 EA               LD     (paramDE),HL         ; in case we return here
3376: F3B0 C8                     RET    Z                    ; return with error condition 255 if not found
3377: F3B1 EB                     EX     DE,HL                ; DE = paramDE address
3378: F3B2         ; clear the remainder of the fcb
3379: F3B2 21 0F 00               LD     HL,nameLength
3380: F3B5 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
3381: F3B6 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
3382: F3B8 AF                     XOR    A                    ; clear accumulator to 00 for fill
3383: F3B9             MakeNewFile1:
3384: F3B9 77                     LD     (HL),A
3385: F3BA 23                     INC    HL
3386: F3BB 0D                     DEC    C
3387: F3BC C2 B9 F3               JP     NZ,MakeNewFile1
3388: F3BF 21 0D 00               LD     HL,fcbS1Index
3389: F3C2 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
3390: F3C3 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
3391: F3C4 CD EA EF               CALL   SetDirectoryEntry    ; may have extended the directory
3392: F3C7         ; now copy entry to the directory
3393: F3C7 CD 28 F4               CALL   CopyFCB
3394: F3CA         ; and set the file write flag to "1"
3395: F3CA C3 1A EF               JP     SetFileWriteFlag
3396: F3CD         ;-----------------------------------------------------------------
3397: F3CD         ;delete the currently addressed file
3398: F3CD             DeleteFile:
3399: F3CD CD FD F1               CALL   CheckWrite           ; write protected ?
3400: F3D0 0E 0C                  LD     C,fcbExtIndex        ; extent number field
3401: F3D2 CD 37 EF               CALL   SearchForDirectoryRecord ; search through file type
3402: F3D5             DeleteFile1:
3403: F3D5         ; loop while directory matches
3404: F3D5 CD D3 EF               CALL   AtEndOfDirectory
3405: F3D8 C8                     RET    Z                    ; exit if end
3406: F3D9         ; set each non zero disk map entry to 0 in the allocation vector
3407: F3D9 CD F0 F1               CALL   CheckRODirectory     ; ro disk error if found
3408: F3DC CD DC EF               CALL   GetCurrentDirectoryRecord ; HL=.buff(dptr)
3409: F3DF 36 E5                  LD     (HL),emptyDir
3410: F3E1 0E 00                  LD     C,FALSE
3411: F3E3 CD 00 F0               CALL   ScanDiskMap          ; alloc elts set to 0
3412: F3E6 CD B4 EF               CALL   WriteDir             ; write the directory
3413: F3E9 CD 4C EF               CALL   GetNextDirectoryRecord ; to next element
3414: F3EC C3 D5 F3               JP     DeleteFile1          ; for another record
3415: F3EF         ;-----------------------------------------------------------------
3416: F3EF
3417: F3EF         ;-----------------------------------------------------------------
3418: F3EF         ;? ;enter from CloseDirEntry to seek and copy current element
3419: F3EF         ;? SeekCopy:
3420: F3EF         ;?	CALL	SeekDir							; to the directory element
3421: F3EF         ;?	JP		WriteDir						; write the directory element
3422: F3EF         ;?	;ret
3423: F3EF         ;? ;-----------------------------------------------------------------
3424: F3EF         ;-----------------------------------------------------------------
3425: F3EF         ;-----------------------------------------------------------------
3426: F3EF
3427: F3EF
3428: F3EF         ;-----------------------------------------------------------------
3429: F3EF         ;compute disk block number from current fcb
3430: F3EF             GetBlockNumber:
3431: F3EF CD 44 F4               CALL   GetDiskMapIndex      ; 0...15 in register A
3432: F3F2 4F                     LD     C,A
3433: F3F3 06 00                  LD     B,0
3434: F3F5 CD 64 F4               CALL   GetDiskMapValue      ; return value in HL
3435: F3F8 22 9D F5               LD     (absoluteCPMRecord),HL ; save for later
3436: F3FB C9                     RET
3437: F3FC         ;-----------------------------------------------------------------
3438: F3FC         ;is  block allocated
3439: F3FC             IsAllocated:
3440: F3FC 2A 9D F5               LD     HL,(absoluteCPMRecord)
3441: F3FF 7D                     LD     A,L
3442: F400 B4                     OR     H
3443: F401 C9                     RET
3444: F402         ;-----------------------------------------------------------------
3445: F402         ;compute actual record address
3446: F402         ; result = absolute CPMRecord * ( 2**BSH)
3447: F402             SetActualRecordAdd:
3448: F402 3A 7E F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
3449: F405 2A 9D F5               LD     HL,(absoluteCPMRecord)
3450: F408
3451: F408             SetActualRecordAdd1:
3452: F408 29                     ADD    HL,HL
3453: F409 3D                     DEC    A                    ; shl(absolute CPMRecord,dpbBSH)
3454: F40A C2 08 F4               JP     NZ,SetActualRecordAdd1
3455: F40D         ; HL has Record number for start of the block;
3456: F40D 3A 7F F5               LD     A,(dpbBLM)           ; get block mask
3457: F410 4F                     LD     C,A                  ; to get current File Record mod Block
3458: F411 3A 9B F5               LD     A,(currentFileRecord) ; get index into block
3459: F414 A1                     AND    C                    ; masked value in A
3460: F415 B5                     OR     L
3461: F416 6F                     LD     L,A                  ; to HL
3462: F417 22 9D F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL or (current File Record and dpbBLM)
3463: F41A         ; *** Absolute CPM Record now has current record number - Starting record number + index into block
3464: F41A C9                     RET
3465: F41B         ;-----------------------------------------------------------------
3466: F41B         ;---------------------
3467: F41B         ;copy directory location to exitParameterByte
3468: F41B             DirLocationToReturnLoc:
3469: F41B 3A 8F F5               LD     A,(directoryFlag)
3470: F41E 32 C5 EA               LD     (exitParameterByte),A
3471: F421 C9                     RET
3472: F422         ;---------------------
3473: F422
3474: F422
3475: F422         ;---------------------
3476: F422         ;set exitParameterByte to 1
3477: F422             SetLowReturnTo1:
3478: F422 3E 01                  LD     A,1
3479: F424 32 C5 EA               LD     (exitParameterByte),A
3480: F427 C9                     RET
3481: F428         ;---------------------
3482: F428         ;---------------------
3483: F428         ;copy the whole file control block
3484: F428             CopyFCB:
3485: F428 0E 00                  LD     C,0
3486: F42A 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3487: F42C C3 2F F4               JP     CopyDir
3488: F42F         ;---------------------
3489: F42F         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3490: F42F             CopyDir:
3491: F42F D5                     PUSH   DE                   ; save length for later
3492: F430 06 00                  LD     B,0                  ; double index to BC
3493: F432 2A C3 EA               LD     HL,(paramDE)         ; HL = source for data
3494: F435 09                     ADD    HL,BC
3495: F436 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3496: F437 CD DC EF               CALL   GetCurrentDirectoryRecord ; HL=.buff(dptr), destination
3497: F43A C1                     POP    BC                   ; DE=source, HL=dest, C=length
3498: F43B CD 9D F4               CALL   MoveX                ; data moved
3499: F43E         ;enter from close to seek and copy current element
3500: F43E             SeekAndCopy:                      ; seek$copy:
3501: F43E CD 15 F1               CALL   SeekDir              ; seek$dir ;to the directory element
3502: F441 C3 B4 EF               JP     WriteDir             ; write the directory element
3503: F444         ;---------------------
3504: F444         ;Return the  disk map Index for current File Record in the ACC
3505: F444         ;  account for multiple extents in 1 physical Directory entry
3506: F444             GetDiskMapIndex:                      ; dm$position
3507: F444 21 7E F5               LD     HL,dpbBSH            ; get block shift value
3508: F447 4E                     LD     C,(HL)               ; shift count to C
3509: F448 3A 9B F5               LD     A,(currentFileRecord) ; current virtual record to A
3510: F44B             GetDiskMapIndex1:
3511: F44B B7                     OR     A                    ; reset the carry flag
3512: F44C 1F                     RRA
3513: F44D 0D                     DEC    C
3514: F44E C2 4B F4               JP     NZ,GetDiskMapIndex1
3515: F451         ; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
3516: F451         ; A has the relative position in the block.
3517: F451 47                     LD     B,A                  ; save it for later addition
3518: F452 3E 08                  LD     A,8
3519: F454 96                     SUB    M                    ; 8-dpbBSH to accumulator
3520: F455 4F                     LD     C,A                  ; extent shift count in register c
3521: F456 3A 9A F5               LD     A,(extentValue)      ; extent value ani extmsk
3522: F459             GetDiskMapIndex2:                      ; dmpos1:
3523: F459         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3524: F459         ; shift is 4,3,2,1,0
3525: F459 0D                     DEC    C
3526: F45A CA 62 F4               JP     Z,GetDiskMapIndex3
3527: F45D B7                     OR     A                    ; clear the carry flag
3528: F45E 17                     RLA
3529: F45F C3 59 F4               JP     GetDiskMapIndex2
3530: F462
3531: F462         ; The ACC has the Block Number for this record
3532: F462             GetDiskMapIndex3:
3533: F462         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3534: F462 80                     ADD    A,B                  ; add the previous shr(current File Record,dpbBSH) value
3535: F463         ; A is one of the following values, depending upon alloc
3536: F463         ; bks dpbBSH
3537: F463         ; 1k   3     v/8 + extentValue * 16
3538: F463         ; 2k   4     v/16+ extentValue * 8
3539: F463         ; 4k   5     v/32+ extentValue * 4
3540: F463         ; 8k   6     v/64+ extentValue * 2
3541: F463         ; 16k  7     v/128+extentValue * 1
3542: F463 C9                     RET                         ; with disk map position in A
3543: F464         ;---------------------
3544: F464         ; Enter with Disk Map Index in BG
3545: F464         ; Return disk map value  in HL
3546: F464             GetDiskMapValue:
3547: F464 2A C3 EA               LD     HL,(paramDE)         ; base address of file control block
3548: F467 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3549: F46A 19                     ADD    HL,DE                ; HL =.diskmap
3550: F46B 09                     ADD    HL,BC                ; index by a  byte value
3551: F46C 3A 95 F5               LD     A,(byteAllocationFlag) ;  byte map entry?
3552: F46F B7                     OR     A
3553: F470 CA 77 F4               JP     Z,GetDiskMap16Bit    ; get disk map  byte
3554: F473 6E                     LD     L,(HL)
3555: F474 26 00                  LD     H,0
3556: F476 C9                     RET                         ; with HL=00bb
3557: F477             GetDiskMap16Bit:                      ; getdmd:
3558: F477 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3559: F478         ; double precision value returned
3560: F478 56                     LD     D,(HL)
3561: F479 23                     INC    HL
3562: F47A 5E                     LD     E,(HL)
3563: F47B EB                     EX     DE,HL
3564: F47C C9                     RET
3565: F47D         ;---------------------
3566: F47D         ;---------------------
3567: F47D         ;*****************************************************************
3568: F47D         ;************************ Utilities ******************************
3569: F47D         ;*****************************************************************
3570: F47D             AddAtoHL:
3571: F47D 85                     ADD    A,L
3572: F47E 6F                     LD     L,A
3573: F47F D0                     RET    NC
3574: F480 24                     INC    H
3575: F481 C9                     RET
3576: F482         ;----------
3577: F482             DEminusHL2HL:
3578: F482 7B                     LD     A,E
3579: F483 95                     SUB    L
3580: F484 6F                     LD     L,A
3581: F485 7A                     LD     A,D
3582: F486 9C                     SBC    A,H
3583: F487 67                     LD     H,A
3584: F488 C9                     RET
3585: F489         ;-------------
3586: F489             ShiftRightHLbyC:
3587: F489 0C                     INC    C
3588: F48A             ShiftRightHLbyC0:
3589: F48A 0D                     DEC    C
3590: F48B C8                     RET    Z
3591: F48C 7C                     LD     A,H
3592: F48D B7                     OR     A
3593: F48E 1F                     RRA
3594: F48F 67                     LD     H,A
3595: F490 7D                     LD     A,L
3596: F491 1F                     RRA
3597: F492 6F                     LD     L,A
3598: F493 C3 8A F4               JP     ShiftRightHLbyC0
3599: F496         ;-------
3600: F496             ShiftLeftHLbyC:
3601: F496 0C                     INC    C
3602: F497             ShiftLeftHLbyC0:
3603: F497 0D                     DEC    C
3604: F498 C8                     RET    Z                    ; exit when done
3605: F499 29                     ADD    HL,HL
3606: F49A C3 97 F4               JP     ShiftLeftHLbyC0
3607: F49D         ;*****************************************************************
3608: F49D         ;move data length of length C from source DE to HL
3609: F49D             MoveX:
3610: F49D 0C                     INC    C
3611: F49E             MoveX0:
3612: F49E 0D                     DEC    C
3613: F49F C8                     RET    Z
3614: F4A0 1A                     LD     A,(DE)
3615: F4A1 77                     LD     (HL),A
3616: F4A2 13                     INC    DE
3617: F4A3 23                     INC    HL
3618: F4A4 C3 9E F4               JP     MoveX0
3619: F4A7
3620: F4A7         ;********** Console OUT Routines*******************??????
3621: F4A7
3622: F4A7         ;---------------------------------- Is Bit Set ------------------------------;
3623: F4A7         ; Enter HL  contains the bit map                                             ;
3624: F4A7         ;       B   Has the bit number (0...F)                                       ;
3625: F4A7         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3626: F4A7         ;              = 0 if bit is set (1)                                         ;
3627: F4A7             IsBitSet:                       ;
3628: F4A7 04                     INC    B                    ;
3629: F4A8             IsBitSetLoop:                      ;
3630: F4A8 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3631: F4A9 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3632: F4AB 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3633: F4AD 3F                     CCF                         ; else Clear Carry flag              ;
3634: F4AE             IsBitSet1:                      ;
3635: F4AE CB 1C                  RR     H                    ; Shift thru CY                      ;
3636: F4B0 CB 1D                  RR     L                    ; ditto                              ;
3637: F4B2 10 F4                  DJNZ   IsBitSetLoop         ;
3638: F4B4 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3639: F4B6 C9                     RET                         ;
3640: F4B7         ;---------------------------------- Is Bit Set ------------------------------;
3641: F4B7
3642: F4B7         ;============================ Set/Reset Vector Bit ==========================;
3643: F4B7         ;---------------------------------- Set Vector Bit -------------------------;;
3644: F4B7         ; Enter  HL  contains the bit map vector                                    ;;
3645: F4B7         ;        B   Has the bit number (0...F)                                     ;;
3646: F4B7         ; Return HL  Contains the modified bit map vector                           ;;
3647: F4B7             SetVectorBit:                      ;;
3648: F4B7 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3649: F4B8 CD A7 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3650: F4BB         ;;
3651: F4BB C1                     POP    BC                   ; Get the bit position              ;;
3652: F4BC CB FC                  SET    7,H                  ;;
3653: F4BE 18 07                  JR     ReAlignVector        ;                                    ;
3654: F4C0         ;---------------------------------- Set Vector Bit -------------------------;;
3655: F4C0         ;---------------------------------- Reset Vector Bit -----------------------;;
3656: F4C0         ; Enter  HL  contains the bit map vector                                    ;;
3657: F4C0         ;        B   Has the bit number (0...F)                                     ;;
3658: F4C0         ; Return HL  Contains the modified bit map vector                           ;;
3659: F4C0             ResetVectorBit:                      ;;
3660: F4C0 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3661: F4C1 CD A7 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3662: F4C4         ;;
3663: F4C4 C1                     POP    BC                   ; Get the bit position              ;;
3664: F4C5 CB BC                  RES    7,H                  ;;
3665: F4C7         ; Fall thru to ReAlignVector                                                 ;
3666: F4C7         ;---------------------------------- Reset Vector Bit -----------------------;;
3667: F4C7         ;---------------------------------- Set VectorBit --------------------------;;
3668: F4C7         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3669: F4C7         ;
3670: F4C7             ReAlignVector:                      ;
3671: F4C7 04                     INC    B                    ;
3672: F4C8             ReAlignMapLoop:                      ;
3673: F4C8 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3674: F4C9 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3675: F4CB 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3676: F4CD 3F                     CCF                         ; else Clear Carry flag              ;
3677: F4CE             ReAlignMap1:                      ;
3678: F4CE CB 15                  RL     L                    ; Shift thru CY                      ;
3679: F4D0 CB 14                  RL     H                    ; ditto                              ;
3680: F4D2 10 F4                  DJNZ   ReAlignMapLoop       ;
3681: F4D4 C9                     RET                         ;
3682: F4D5         ;============================ Set/Reset Vector Bit ==========================;
3683: F4D5         ;************Error message World*************************
3684: F4D5             errSelect:
3685: F4D5 21 F4 F4               LD     HL,evSelection
3686: F4D8 C3 ED F4               JP     GoToError
3687: F4DB             errReadOnlyDisk:
3688: F4DB 21 F6 F4               LD     HL,evReadOnlyDisk
3689: F4DE C3 ED F4               JP     GoToError
3690: F4E1             errReadOnlyFile:
3691: F4E1 21 F8 F4               LD     HL,evReadOnlyFile
3692: F4E4 C3 ED F4               JP     GoToError
3693: F4E7             errPermanent:
3694: F4E7 21 F2 F4               LD     HL,evPermanent
3695: F4EA C3 ED F4               JP     GoToError
3696: F4ED         ;************Error message handler **********************
3697: F4ED             GoToError:
3698: F4ED         ;HL = .errorhandler, call subroutine
3699: F4ED 5E                     LD     E,(HL)
3700: F4EE 23                     INC    HL
3701: F4EF 56                     LD     D,(HL)               ; address of routine in DE
3702: F4F0 EB                     EX     DE,HL
3703: F4F1 E9                     JP     (HL)                 ; vector to subroutine
3704: F4F2         ;************ Error Vectors *****************************
3705: F4F2 00 F5       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3706: F4F4 0C F5       evSelection: DW     erSelection          ; selerr select error subroutine
3707: F4F6 12 F5       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3708: F4F8 18 F5       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3709: F4FA         ;************Error Routines ******************************
3710: F4FA             erPermanentNoWait:
3711: F4FA 21 4A F5               LD     HL,emPermanent
3712: F4FD C3 ED F4               JP     GoToError
3713: F500             erPermanent:
3714: F500 21 4A F5               LD     HL,emPermanent
3715: F503 CD 21 F5               CALL   displayAndWait       ; to report the error
3716: F506 FE 03                  CP     CTRL_C
3717: F508 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3718: F50B C9                     RET                         ; and ignore the error
3719: F50C         ;
3720: F50C             erSelection:
3721: F50C 21 55 F5               LD     HL,emSelection
3722: F50F C3 1B F5               JP     waitB4boot           ; wait console before boot
3723: F512         ;
3724: F512             erReadOnlyDisk:
3725: F512 21 61 F5               LD     HL,emReadOnlyDisk
3726: F515 C3 1B F5               JP     waitB4boot           ; wait console before boot
3727: F518         ;
3728: F518             erReadOnlyFile:
3729: F518 21 5C F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3730: F51B         ;
3731: F51B         ; wait for response before boot
3732: F51B             waitB4boot:
3733: F51B CD 21 F5               CALL   displayAndWait
3734: F51E C3 00 00               JP     WarmBoot
3735: F521
3736: F521         ;report error to console, message address in HL
3737: F521             displayAndWait:
3738: F521 E5                     PUSH   HL                   ; save message pointer
3739: F522 CD D6 E9               CALL   showCRLF             ; stack mssg address, new line
3740: F525 3A 66 F5               LD     A,(currentDisk)
3741: F528 C6 41                  ADD    A,ASCII_A
3742: F52A 32 46 F5               LD     (emDisk),A           ; Problem disk name
3743: F52D 01 3A F5               LD     BC,emDisk0
3744: F530 CD 3B E9               CALL   Print                ; the error message
3745: F533 C1                     POP    BC
3746: F534 CD 3B E9               CALL   Print                ; error mssage tail
3747: F537 C3 21 E9               JP     ConIn                ; to get the input character
3748: F53A         ;ret
3749: F53A         ;**************Error Messages*******************************
3750: F53A 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3751: F546 20 3A 20 24     emDisk:    DB     ' : $'
3752: F54A 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3753: F555 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3754: F55C 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3755: F561 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3756: F565         ;*****************************************************************
3757: F565
3758: F565         ;********* file control block (fcb) constants ********************
3759: F565             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3760: F565             fcbROfileIndex EQU    09H                  ; high order of first type char
3761: F565             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3762: F565             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3763: F565             fcbS1Index EQU    0DH                  ;13				; S1 index
3764: F565             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3765: F565             fcbRCIndex EQU    0FH                  ;15				; record count field index
3766: F565             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3767: F565
3768: F565             fcbCurrentRecord EQU    21H                  ;33
3769: F565
3770: F565             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3771: F565
3772: F565             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3773: F565             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3774: F565             dirEntryMask EQU    dirEntriesPerRecord-1
3775: F565             fcbShift   EQU    5                    ; log2(fcbLength)
3776: F565         ;
3777: F565
3778: F565
3779: F565
3780: F565             maxExtValue EQU    31                   ; largest extent number
3781: F565             moduleMask EQU    15                   ; limits module number value
3782: F565             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3783: F565             nameLength EQU    15                   ; namlen name length
3784: F565
3785: F565             emptyDir   EQU    0E5H                 ; empty empty directory entry
3786: F565             NEXT_RECORD EQU    fcbLength            ; nxtrec
3787: F565             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3788: F565         ;
3789: F565         ;	reserved file indicators
3790: F565         ;	equ	11				; reserved
3791: F565         ;*****************************************************************
3792: F565         ;*****************************************************************
3793: F565
3794: F565         ;***common values shared between bdosi and bdos******************
3795: F565 00          currentUserNumber: DB     0                    ; usrcode current user number
3796: F566         ; paramDE:			DS	2					; ParamsDE information address
3797: F566         ; exitParameterByte:
3798: F566         ; exitParameterWord:	DS	2					; address value to return
3799: F566 FF          currentDisk: DB     -1                   ; curdsk current disk number
3800: F567         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3801: F567
3802: F567         ;********************* Local Variables ***************************
3803: F567         ;     ************************
3804: F567         ;     *** Initialized Data ***
3805: F567
3806: F567 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3807: F568 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
3808: F56A 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3809: F56C 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3810: F56E
3811: F56E         ;     *** Current Disk attributes ****
3812: F56E         ; These are set upon disk select
3813: F56E         ; data must be adjacent, do not insert variables
3814: F56E         ; address of translate vector, not used
3815: F56E         ; ca - currentAddress
3816: F56E
3817: F56E 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3818: F570 00 00       caTrack:   DW     0000H                ; curtrka current track address
3819: F572 00 00       caSector:  DW     0000H                ; current Sector
3820: F574             caListSizeStart:
3821: F574 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3822: F576 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3823: F578 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3824: F57A 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3825: F57C             caListSizeEnd:
3826: F57C             caListSize EQU    caListSizeEnd - caListSizeStart
3827: F57C
3828: F57C         ;     ***** Disk Parameter Block *******
3829: F57C         ; data must be adjacent, do not insert variables
3830: F57C         ; dpb - Disk Parameter Block
3831: F57C             dpbStart:
3832: F57C 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3833: F57E 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3834: F57F 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3835: F580 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3836: F581 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3837: F583 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3838: F585 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3839: F587 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3840: F589 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3841: F58B             dpbEnd:
3842: F58B             dpbSize    EQU    dpbEnd - dpbStart
3843: F58B         ;
3844: F58B
3845: F58B         ;     ************************
3846: F58B
3847: F58B 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3848: F58D 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3849: F58E 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3850: F58F 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3851: F590 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3852: F591 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3853: F592 00          searchLength: DB     00H                  ; searchl search length
3854: F593 00 00       searchAddress: DW     0000H                ; searcha search address
3855: F595         ;tinfo:	ds	word							; temp for info in "make"
3856: F595 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3857: F596 00          fResel:    DB     00H                  ; resel reselection flag
3858: F597 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3859: F598 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3860: F599 00          fcbRecordCount: DB     00H                  ; record count from current FCB
3861: F59A 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3862: F59B 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3863: F59D 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3864: F59F         ;
3865: F59F         ;	local variables for directory access
3866: F59F 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3867: F5A0 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3868: F5A2 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3869: F5A4
3870: F5A4         ;********************** data areas ******************************
3871: F5A4
3872: F5A4
3873: F5A4         ;---------------------------------- Stack Area--------------------------------;
3874: F5A4             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3875: F5E4             bdosStack:
3876: F5E4         ;
3877: F5E4         ;---------------------------------- Stack Area--------------------------------;
3878: F5E4         ;	end of Basic I/O System
3879: F5E4         ;-----------------------------------------------------------------;
3880: F5E4
3881: F5E4
3882: F5E4         ;
3883: F5E4             Z_HighestLocation:
3884: F5E4             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3885: F5E4
3886: F5E4
           ************************   Xref   ************************
0000: $               F5E4   0418 0448
3863: absoluteCPMRecord F59D   2884 2891 2909 3181 3435 3440 3449 3462
3570: AddAtoHL        F47D   3191
3195: Allocate16Bit   F2B2   3189
1045: AreWeAtEndOfBuffer EA3A   1041
0086: ASCII_A         0041   3741
0087: ASCII_C         0043
0088: ASCII_K         004B
0095: ASCII_LO_A      0061
0096: ASCII_LO_K      006B
0097: ASCII_LO_P      0070
0038: ASCII_MASK      007F   0988
0089: ASCII_N         004E
0090: ASCII_Q         0051
0091: ASCII_R         0052
0092: ASCII_W         0057
0093: ASCII_Y         0059
0073: ASCII_ZERO      0030
0067: ASTERISK        002A
2545: AtEndOfDirectory EFD3   1731 1952 1983 2041 2436 2993 3275 3310 3319 3353 3373 3404
1137: BackUp          EA9F   1065 1133
1142: BackUp1         EAA7   1138
0295: bcBoot          F600
0298: bcConin         F609   0618 0803 0914 0932
0299: bcConout        F60C   0610 0876 1140 1144 1150 1152
0297: bcConst         F606   0615 0910
0303: bcHome          F618   2165
0300: bcList          F60F   0583 0882
0310: bcListst        F62D
0301: bcPunch         F612   0568
0308: bcRead          F627   2207
0302: bcReader        F615   0549
0311: bcSectran       F630
0304: bcSeldsk        F61B   1855
0307: bcSetdma        F624   2202
0306: bcSetsec        F621   2924
0305: bcSettrk        F61E   2171 2921
0296: bcWboot         F603   0469
0309: bcWrite         F62A   2524
0153: BDOSBase        E800   0154 0156 0327
0122: BDOSE           0005   0123
0154: BDOSEntry       E800
0143: BDOSLength      0E00   0146 0156 0157
3875: bdosStack       F5E4   0343
0333: BdosStart       E800
0056: BELL            0007
0156: BIOSBase        F600
0144: BIOSLength      0A00   0146
0116: BIOSPAGE        0002
0157: BIOSStart       F600   0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 0311 3884
3180: BlockOK         F296   3174
0253: BlockSize       0800   0275
1060: BSspaceBS       EA48   0999
0034: BYTE            0001   1173
3856: byteAllocationFlag F595   1888 2054 2621 3186 3551
3824: caAllocVector   F57A   1426 1908 1910 1935 2333 2674 2741
3823: caCheckSum      F578   2952
3821: caDirectoryDMA  F574   1875 2194 2560 2751 2944
3817: caDirMaxValue   F56E   1866 1942 2224 2594
3822: caDiskParamBlock F576   1488 1880
3826: caListSize      0008   1876
3825: caListSizeEnd   F57C   3826
3820: caListSizeStart F574   3826
0094: CARET           005E   0842
0836: CaretOut        E948   1034 1115
3819: caSector        F572   1872 2179 2913
3847: caSkewTable     F58B   1864
3818: caTrack         F570   1869 2175 2904
0151: CCPEntry        E000   0153 0157
0142: CCPLength       0800   0146 0153 0157
0928: CheckCTL_S      E9AC   0917
2474: CheckExtents    EF8D   2468
3062: CheckRODirectory F1F0   3356 3407
3067: CheckROFile     F1F3   3137
2932: CheckSumUtility F160   2508 2876
3076: CheckWrite      F1FD   3135 3341 3366 3399
2028: CloseDirEntry   ED9F   1287 1652 3273
2110: CloseDirEntryEnd EE0E   2100
2118: CloseDirEntryError EE1A   2070 2080 2085
0074: COLON           003A
1171: columnPosition  EAC1   0861 0886 0951 0971 1129
0069: COMMA           002C
2398: CompareExtents  EF26   2475
2942: ComputeCheckSum F16C
2946: ComputeCheckSum1 F173   2949
0128: ComTail         0080   0129
0130: ComTailChars    0082
0129: ComTailCount    0081   0130
0905: ConBreak        E98C   0729 0872
0938: ConBreak0       E9BA   0930
0940: ConBreak1       E9BD   0908
0796: ConIn           E921   0501 0987 3747
0869: ConsoleOut      E96B   0843 0855 0860 0948 0956 0963 0965 1057
3490: CopyDir         F42F   2997 3359 3487
2750: CopyDirEntryToUserDMA F0A2   1340 3014
1986: CopyDirRecordToFCB ED65   3325
3484: CopyFCB         F428   3393
0230: cpmRecordSize   0080   0232 0235 0237 2753 2943 3772
0059: CR              000D   0809 0962 0992 1056
0042: CTRL_C          0003   0933 1039 3716
0043: CTRL_E          0005   1004
0044: CTRL_H          0008   0815 0998 1143
0045: CTRL_K          000B
0046: CTRL_L          000C
0047: CTRL_P          0010   0916 1007
0048: CTRL_R          0012   1016
0049: CTRL_S          0013   0929
0050: CTRL_U          0015   1013
0051: CTRL_X          0018   1010
0052: CTRL_Z          001A
3799: currentDisk     F566   1208 1387 1823 1834 1840 1853 2131 2217 2235 2261 3740
3862: currentFileRecord F59B   2287 2980 3094 3104 3139 3224 3261 3458 3509
3795: currentUserNumber F565   0780 0786 1960 2270
0070: DASH            002D
0264: DataBlocks      02C7   0274
0263: DataSectors     0B1C   0264
3398: DeleteFile      F3CD   3021
3402: DeleteFile1     F3D5   3414
1124: DeleteTheLine   EA8E   1011
1127: DeleteTheLine1  EA8F   1134
3577: DEminusHL2HL    F482
3866: dirBlockIndex   F59F   2561 2868
0235: DirBuffSize     0080
0250: DirectoryBlockCount 0002   0275
0237: DirectoryEntryPerRecord 0004   0278
3850: directoryFlag   F58F   2425 2489 3469
3772: dirEntriesPerRecord 0004   3774
3867: dirEntryIndex   F5A0   2485 2536 2546 2592 2851 2853 2862 2881
3774: dirEntryMask    0003   2486 2863
3773: dirEntryShift   0002   2882
0234: DirEntrySize    0020   0237 0275
3468: DirLocationToReturnLoc F41B   1817 3022 3056
3868: dirRecord       F5A2   2885 2934 2953
0222: DiskCommandBlock 0046
0221: DiskControlByte 0045
0224: DiskControlTable 0040
3121: DiskEOF         F244   3101 3108 3114
0418: diskf           000B
3852: diskMapIndex    F591   3157 3188
3089: DiskRead        F209   1581
0226: DiskReadCode    0001
0231: diskSectorSize  0200   0232 0253 0261
0220: DiskStatusLocation 0043
3131: DiskWrite       F24C   1588
3146: DiskWrite1      F269   3141
3205: DiskWrite2      F2BA   3193
3211: DiskWrite3      F2BF   3150
3232: DiskWrite4      F2DF   3227
3243: DiskWrite5      F2EC   3236
3262: DiskWrite6      F30A   3258
3264: DiskWrite7      F30C   3246 3250
0227: DiskWriteCode   0002
3126: DiskWriteSeq    F247   3037
3737: displayAndWait  F521   3715 3733
2787: DivideHLby8     F0BC   1903 2660 2663
0133: DMABuffer       0080   1210 3809
0063: DOLLAR          0024   0824 1966
0276: dpb3hdAL0       00C0
0277: dpb3hdAL1       0000
0272: dpb3hdBLM       000F
0271: dpb3hdBSH       0004
0278: dpb3hdCKS       0020
0275: dpb3hdDRM       007F   0278
0274: dpb3hdDSM       02C6
0273: dpb3hdEXM       0000
0280: dpb3hdNOH       0002
0279: dpb3hdOFF       0001
0270: dpb3hdSPT       0090
3834: dpbBLM          F57F   3456
3833: dpbBSH          F57E   3448 3507
3839: dpbCKS          F587   2933
3838: dpbDABM         F585   1933
3837: dpbDRM          F583   2222 2850
3836: dpbDSM          F581   1886 1902 1918 2659
3841: dpbEnd          F58B   3842
3835: dpbEXM          F580   2292 2401 3287
3840: dpbOFF          F589   2167 2917
3842: dpbSize         000F   1882
3832: dpbSPT          F57C   2892
3831: dpbStart        F57C   1881 3842
0450: DUMMY           E8A9   0445 0446
3751: emDisk          F546   3742
3750: emDisk0         F53A   3743
3752: emPermanent     F54A   3711 3714
3785: emptyDir        00E5   1956 2442 3409 3806
3806: emptyFCB        F567   3369
3755: emReadOnlyDisk  F561   3725
3754: emReadOnlyFile  F55C   3729
3753: emSelection     F555   3721
0137: END_OF_FILE     001A
0040: EndOfMessage    0000
1050: EndRead         EA3E   0993 0996
3858: entryDisk       F597   0391 2262
0292: EOD             FFFF   2535
0078: EQUAL_SIGN      003D
3713: erPermanent     F500   3705
3710: erPermanentNoWait F4FA   2209 2526
3724: erReadOnlyDisk  F512   3707
3728: erReadOnlyFile  F518   3708
3693: errPermanent    F4E7
3687: errReadOnlyDisk F4DB   3079
3690: errReadOnlyFile F4E1   3073
3684: errSelect       F4D5   1833
3720: erSelection     F50C   3706
3705: evPermanent     F4F2   3694
3707: evReadOnlyDisk  F4F6   3688
3708: evReadOnlyFile  F4F8   3691
3706: evSelection     F4F4   3685
0061: EXCLAIM_POINT   0021
1175: exitParameterByte EAC5   0510 0619 0730 0756 0781 1388 1656 1666 1677 1684 1697 1970 2030 2119 2487 2501 3106 3177 3212 3255 3329 3470 3479
1176: exitParameterWord EAC5   0347 0398 0550 0639 1365 1427 1473 1489
3861: extentValue     F59A   2294 3521
0029: FALSE           0000   0923 1095 1586 1892 2434 3132 3410
0125: FCB1            005C   0126
0126: FCB2            006C
3848: fcbCopiedFlag   F58D   2112 3272 3290
3768: fcbCurrentRecord 0021
3859: fcbDisk         F598   0349 0386 2264
3766: fcbDiskMapIndex 0010   2046 2051 2611 2613 3184 3348 3357 3548
3762: fcbExtIndex     000C   1635 1659 1718 1770 2001 2094 2103 2313 2466 2990 2996 3278 3298 3343 3358 3400
0015: fcbExtIndexLSB  000C
0016: fcbExtIndexMSB  000E
3761: fcbHiddenfileIndex 000A
3759: fcbLength       0020   1995 2051 2094 2613 3381 3486 3772 3786
3765: fcbRCIndex      000F   1735 2004 2022 2103 2302 2305
3860: fcbRecordCount  F599   2290 2984 3095 3225
3760: fcbROfileIndex  0009   3068
3763: fcbS1Index      000D   2463 3388
3764: fcbS2Index      000E   1641 1662 1787 2367 3298
3775: fcbShift        0005   2864
0170: fCloseFile      0010
0161: fConsoleIn      0001
0162: fConsoleOut     0002
0173: fDeleteFile     0013
0165: fGetConsoleStatus 000B
0179: fGetCurrentDisk 0019
0178: fGetLoginVector 0018
0181: fGetSetUserNumber 0020
0166: fGetVersion     000C
3168: FirstBlock      F288   3160
0176: fMakeFile       0016
0169: fOpenFile       000F
2720: FoundFreeOctet  F07D   2690 2695 2704 2712
2726: FoundFreeOctet1 F083   2722
2728: FoundFreeOctet2 F084   2724
2730: FoundFreeOctet3 F087   2733
2736: FoundFreeOctet4 F08F   2738
0163: fPrintString    0009
0174: fReadSeq        0014
0164: fReadString     000A
0177: fRenameFile     0017
3857: fResel          F596   0350 0380 2252
0167: fResetSystem    000D
0171: fSearchFirst    0011
0172: fSearchNext     0012
0168: fSelectDisk     000E
0180: fSetDMA         001A
0448: functionCount   0028   0359
0405: functionTable   E857   0364 0418 0448
0175: fWriteSeq       0015
3430: GetBlockNumber  F3EF   3112 3147
2656: GetClosestBlock F02C   3170
2558: GetCurrentDirectoryRecord EFDC   1734 1955 1991 2045 2452 2610 3063 3408 3496
3557: GetDiskMap16Bit F477   3553
3506: GetDiskMapIndex F444   3156 3431
3510: GetDiskMapIndex1 F44B   3514
3522: GetDiskMapIndex2 F459   3529
3532: GetDiskMapIndex3 F462   3526
3546: GetDiskMapValue F464   3164 3434
2311: GetExtentAddress EEDD   1987 2291
2365: GetExtentNumberMSB EF11   1691 2356 3238
2300: GetFcbRecordDetails EED0   2284 2977
1717: GetFileSize     EC07   1552
1730: GetFileSize1    EC19   1758
1756: GetFileSize2    EC3B   1749
1759: GetFileSizeExit EC41   1732
2433: GetNextDirectoryRecord EF4C   1757 2471 2476 2998 3013 3361 3413
2451: GetNextDirectoryRecord1 EF69   2443
1764: GetRandomRecordPosition EC43   1706 1736
2364: GetWriteFileFlagValue EF11   2034 2376 2387
3697: GoToError       F4ED   3686 3689 3692 3695 3712
0079: GREATER_THAN    003E
0062: HASH_TAG        0023   0947
3770: highestRecordNumber 007F   3140 3245
2164: Home            EE39   1941 2431
1147: IgnoreTheLine   EAAC   1014
3809: initDAMAddress  F56C   1211 1409 2188 2752
1901: InitDisk        ECEC   1846
1948: InitDisk1       ED31   1958 1976
1971: InitDisk2       ED52   1962 1967
2355: InitializeExtentNumberMSB EF0B   1254 1334 3045
0117: IOBYTE          0003   0638 0658
3439: IsAllocated     F3FC   3113 3148
3627: IsBitSet        F4A7   1837 2237 3649 3661
3634: IsBitSet1       F4AE   3632
3629: IsBitSetLoop    F4A8   3637
2233: IsDiskWriteProtected EE81   2031 3077
1012: IsItDeleteTheLineU EA19
1009: IsItDeleteTheLineX EA14
1006: IsItPrintToggle EA0F
1096: IsItPrintToggle1 EA70   1094
1000: IsItRubout      EA05
1003: IsPhysicalEOL   EA0A
0808: IsPrintableASCII E92C   0502 0838
1081: ItIsPhysicalEOL EA5D   1005
1088: ItIsPrintToggle EA65   1008
1069: ItIsRubout      EA52   1002
1165: keyboardByte    EABE   0797 0906 0939
0065: L_PAREN         0028
2340: Left            EEFC   2342
0082: LEFT_ARROW      005F
0098: LEFT_CURLY      007B
0146: LengthInBytes   2000   0147 0151 0261
0147: LengthInK       0009
0077: LESS_THAN       003C
0058: LF              000A   0811 0892 0964 0994
1110: LL1             EA7E   1118
0032: LO_NIBBLE_MASK  000F   0785 1783
3808: loggedDisks     F56A   1206 1364 1836 1842 1844
2688: LookRight       F051   2698
3365: MakeNewFile     F397   1675 3047 3317
3383: MakeNewFile1    F3B9   3387
1931: Mark4Directory  ED19   1923
3780: maxExtValue     001F   2410 3282
0149: MemorySize      0040   0151
2815: Merge           F0D0   2074 2076
2053: MergeAllocationMaps EDC4   2091
2068: MergeDirEntryNot0 EDD8   2065
2063: MergeFCBisNot0  EDD2   2061
2087: MergeMapLoop    EDF4   2071
2073: MergeWordMaps   EDDF   2056
3781: moduleMask      000F   3303
3609: MoveX           F49D   3498
3611: MoveX0          F49E   3618
2799: MultiplyHLby8   F0C6   1917 2744
0262: myOffset        0001   0263 0279
3783: nameLength      000F   1336 1981 2039 3308 3379 3381
3786: NEXT_RECORD     0020   1630 1705 2305 3787
2498: NoDirRecordsMatch EFAB   2437 2449
2716: NoFreeBlocks    F079   2705 2713
2700: NoMoreLeft      F063   2696
2702: NoMoreLeftLoop  F064   2706
2708: NoMoreRight     F06E   2691
2710: NoMoreRightLoop F06F   2714
2269: NoSelect        EEB0   2259
0935: NothingWaiting  E9B8   0926
0054: NULL            0000
0246: NumberOfHeads   0002   0257 0259 0270 0280
0243: NumberOfLogicalDisks 0004
0031: OFF             0000
0030: ON              FFFF
1980: OpenFile        ED5C   1256 1665
3270: OpenNextExt     F30F   3102 3253
3307: OpenNextExt1    F343   3292
3324: OpenNextExt2    F361   3294 3311
3326: OpenNextExt3    F364   3321
3333: OpenNextExtError F36C   3304 3315 3320
3297: OpenNextModule  F338   3284
2020: OpenSetRecordCount ED96   2016 2018
1174: paramDE         EAC3   0338 0384 0681 0973 1052 1107 1328 1408 1599 1704 1721 1994 2021 2049 2253 2271 2301 2312 2366 2428 3011 3136 3183 3277 3346 3367 3370 3375 3493 3547
1173: paramE          EAC2   0340 0392 0777 1822 2257
0064: PERCENT         0025
0071: PERIOD          002E
0120: Pg0CurentDisk   0004
0119: Pg0CurentUser   0004   0120
0068: PLUS_SIGN       002B
0822: Print           E93B   0684 0831 3744 3746
1167: printEchoFlag   EABF   0880 0919 1091
0080: QMARK           003F   1330 2459
1338: QMarkFind       EB05   1331
0066: R_PAREN         0029
0113: RAM             0000   0115 0116 0117 0119 0122 0125 0128 0133 0135
3787: RANDOM_REC_FIELD 0021   1601 1707 1722
1578: RandomDiskRead  EB51   1533
1585: RandomDiskWrite EB5A   1545
1595: RandomSeek      EB63   1580 1587
1649: RandomSeekClose EBA7   1639
1694: RandomSeekError EBEC   1628
1687: RandomSeekErrorBadSeek EBE5   1658 1674 1679
1681: RandomSeekExit  EBDF   1648 1668
2206: ReadBuffer      EE61   2840 3118
2849: ReadDirectory   F0E7   1951 2435
2861: ReadDirectory0  F0FB   2856
2865: ReadDirectory1  F102   2867
2838: ReadDirRecord   F0DE   2874
1030: ReadEchoRubOut  EA26   1078
3849: readModeFlag    F58E   3091 3133 3313
0983: ReadNext        E9ED   1047 1073 1099 1121
0986: ReadNext0       E9EF   1066 1085
3807: readOnlyVector  F568   1205 1472 2215 2220 2234
3083: ReadSeq         F204   3029
0970: ReadString      E9E0   0714 1131 1153
3677: ReAlignMap1     F4CE   3675
3672: ReAlignMapLoop  F4C8   3680
3670: ReAlignVector   F4C7   3653
3111: RecordOK        F22E   3098
0255: RecordsPerBlock 0010
0239: RecordsPerExtent 0080   2019 3100 3770
0232: recordsPerSector 0004   0255 0270
3340: Rename          F372   3055
3352: Rename1         F383   3362
1102: RepeatLine      EA75   1017
2250: ReselectDisk    EE8C   1255 1286 1335 1532 1544 1551 1815 3012 3020 3028 3036 3046 3054
2386: ResetFileWriteFlag EF20   3207
3659: ResetVectorBit  F4C0
0379: ReturnToCaller  E832   0353
0395: ReturnToCaller1 E84D   0382 0388 0617
2348: Right           EF06   2346 2350
2150: RotateAndReplace EE32   2153
2773: RotateRightHLbyB F0AF   2781
2778: RotateRightHLbyB1 F0B5   2776
0083: RUBOUT          007F   1001
2608: ScanDiskMap     F000   1974 3411
2615: ScanDiskMap0    F00A   2647
2640: ScanDiskMap2    F021   2629
2631: ScanDiskMapWord F01B   2623
3854: searchAddress   F593   2429 2439 3010
2423: SearchForDirectoryRecord EF37   1339 1719 1982 2040 2991 3309 3344 3372 3401
3853: searchLength    F592   2426 2453
0284: SectorMask      0003
0249: SectorsPerBlock 0004   0253 0255 0258 0264 0284
0259: SectorsPerCylinder 0024   0262 0263
0248: SectorsPerTrack 0012   0257 0259 0270
2889: Seek            F126   2886 3117 3218
2894: Seek0           F130   2898
3500: SeekAndCopy     F43E
2880: SeekDir         F115   2114 2873 3501
1831: Select          EC85   1213 1827
1821: SelectCurrent   EC79   0393 1237 2267
1852: SelectDisk      ECA6   1832
1895: SelectDisk1     ECE8   1891
0076: SEMICOLON       003B
3851: seqReadFlag     F590   1597 2978 3085 3128 3248
3447: SetActualRecordAdd F402   3116 3217
3451: SetActualRecordAdd1 F408   3454
2989: SetAttributes   F1A2   1816
2992: SetAttributes1  F1A7   2999
1926: SetBitLoop      ED14   1929
2129: SetCurrentDiskBit EE1F
2187: SetDataDMA      EE53   1212 1410 2513 2841
2193: SetDirDMA       EE58   2510 2839
2572: SetDirectoryEntry EFEA   1975 3391
2214: SetDiskReadOnly EE69   1454 2964
2198: SetDMA          EE5B   2189
2534: SetEndDirectory EFCC   1946 2430 2499 2857
2375: SetFileWriteFlag EF1A   1699 1999 3335 3395
3477: SetLowReturnTo1 F422   3122 3142 3334
2968: SetNewCheckSum  F18E   2957
2478: SetNextPosition EF93   2460 2464 2472
1703: SetRandomRecord EBF4   1558
2283: SetRecordVars   EEB9   3093 3138 3327
2322: SetResetMapBit  EEE5   2643
0784: SetUserNumber   E91B   0779
3647: SetVectorBit    F4B7   1843 2219
2802: ShiftLeftHLbyB  F0C8   2806
3600: ShiftLeftHLbyC  F496   2134
3602: ShiftLeftHLbyC0 F497   3606
2790: ShiftRightHLbyB F0BE   2332 2794 2883
3586: ShiftRightHLbyC F489
3588: ShiftRightHLbyC0 F48A   3598
0961: showCRLF        E9D6   0949 1084 3739
0946: showHashCRLF    E9C0   1105 1148
0950: showHashCRLF1   E9C8   0957
0072: SLASH           002F
0055: SOH             0001
0060: SPACE           0020   0817 0859 0889 0955 1139 1149 1151
0291: STACK_SIZE      0020   3874
3874: stackBottom     F5A4
1170: startingColumn  EAC0   0952 0972 1128
2591: StillInDirectory EFF3   2447 2573 2962
0261: SystemSectors   0011   0262
0057: TAB             0009   0813 0854
0852: TabOut          E958   0507 0529 0829 0839
0858: TabOut0         E95E   0863
2457: TestNextPosition EF72   2483
0924: ToggleFlag1     E9A9   0922
0123: TopRAM          0007
0258: TotalNumberOfBlocks 02D0
0257: TotalNumberOfSectors 0B40   0258 0263
0135: TPA             0100
0247: TracksPerHead   0050   0257
0028: TRUE            FFFF   0920 0941 1092 1579 1889 1896 1950 1973 2111 2251 2507 3090
0081: UNDER_SCORE     005F
2976: UpdateRecordVars F190   3119 3252 3265
1163: usersStack      EABC   0342 0396
1285: vCloseFile      EAEC   0423
1550: vComputeFileSize EB47   0442
0500: vConsoleIn      E8AD   0407
0528: vConsoleOut     E8BE   0408
3019: vDeleteFile     F1C7   0426
0605: vDirectConIO    E8D1   0412
0614: vDirectConIO1   E8D9   0608
0290: VERSION         0020   0755
1326: vFindFirst      EAF2   0424
3009: vFindNext       F1B8   0425
1425: vGetAllocAddr   EB22   0434
0728: vGetConsoleStatus E900   0417
1386: vGetCurrentDisk EB12   0432
1487: vGetDiskParamBlock EB33   0438
0637: vGetIOBYTE      E8E7   0413
1363: vGetLoginVector EB0B   0431
1471: vGetReadOnlyMap EB2C   0436
0776: vGetSetUserNumber E90D   0439
0754: vGetVersion     E907   0419
0582: vListOut        E8CD   0411
3044: vMakeFile       F1DE   0429
1253: vOpenFile       EAE3   0422
0680: vPrintString    E8F3   0415
0567: vPunchOut       E8C9   0410
0548: vReaderIn       E8C2   0409
1531: vReadRandom     EB3B   0440
3027: vReadSeq        F1D0   0427
0713: vReadString     E8FC   0416
3053: vRenameFile     F1E7   0430
1515: vResetDrive     EB3A   0444
1203: vResetSystem    EAC7   0420
1236: vSelectDisk     EAE0   0421
1407: vSetDMA         EB19   0433
1814: vSetFileAttributes EC70   0437
0657: vSetIOBYTE      E8EE   0414
1557: vSetRandomRecord EB4D   0443
0468: vSystemReset    E8AA   0406
1453: vWriteProtectDisk EB29   0435
1543: vWriteRandom    EB41   0441
1571: vWriteRandom0Fill EB50   0447
3035: vWriteSeq       F1D7   0428
3732: waitB4boot      F51B   3722 3726
0115: WarmBoot        0000   0934 1043 3717 3734
0035: WORD            0002   1174 1176
0195: WriteAllocated  0000   3149
2523: WriteBuffer     EFC4   2512 3221
0197: WriteCleanBuffer 0002   3206
2505: WriteDir        EFB4   2115 3412 3502
0196: WriteDirectory  0001   2511
3782: writeFlagMask   0080
3883: Z_HighestLocation F5E4   3884
3884: Z_MemoryLeft    001B
0039: ZERO            0000
