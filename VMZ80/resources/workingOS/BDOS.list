0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800
0005: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0006: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0007: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0008: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0009: E800         ; 2018-03-02 Refactored the CP/M Suite
0010: E800         ; 2018-02-12 fixed allocate 16 bit problem
0011: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0012: E800         ; 2014-03-14  :  Frank Martyn
0013: E800
0014: E800
0015: E800                        Include ./stdHeader.Z80
0016: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0017: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0018: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0019: E800         ; stdHeader.asm
0020: E800         ; standard equates
0021: E800
0022: E800         ; 2017-03-02 Refactored the CP/M Suite
0023: E800
0024: E800
0025: E800             TRUE       EQU    -1                   ; not false
0026: E800             FALSE      EQU    0000H
0027: E800             ON         EQU    -1
0028: E800             OFF        EQU    0000H
0029: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0030: E800
0031: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0032: E800             WORD       EQU    2                    ; number of bytes for "word" type
0033: E800
0034: E800
0035: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0036: E800             ZERO       EQU    00H                  ; Zero
0037: E800             EndOfMessage EQU    00H
0038: E800
0039: E800             CTRL_C     EQU    03H                  ; ETX
0040: E800             CTRL_E     EQU    05H                  ; physical eol
0041: E800             CTRL_H     EQU    08H                  ; backspace
0042: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0043: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0044: E800             CTRL_P     EQU    10H                  ; prnt toggle
0045: E800             CTRL_R     EQU    12H                  ; repeat line
0046: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0047: E800             CTRL_U     EQU    15H                  ; line delete
0048: E800             CTRL_X     EQU    18H                  ; =ctl-u
0049: E800             CTRL_Z     EQU    1AH                  ; end of file
0050: E800
0051: E800             NULL       EQU    00H                  ; Null
0052: E800             SOH        EQU    01H                  ; Start of Heading
0053: E800             BELL       EQU    07H                  ; Bell
0054: E800             TAB        EQU    09H                  ; Tab
0055: E800             LF         EQU    0AH                  ; Line Feed
0056: E800             CR         EQU    0DH                  ; Carriage Return
0057: E800             SPACE      EQU    20H                  ; Space
0058: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0059: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0060: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0061: E800             PERCENT    EQU    25H                  ; Percent Sign
0062: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0063: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0064: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0065: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0066: E800             COMMA      EQU    2CH                  ; Comma
0067: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0068: E800             PERIOD     EQU    2EH                  ; Period
0069: E800             SLASH      EQU    2FH                  ; /
0070: E800             ASCII_ZERO EQU    30H                  ; zero
0071: E800             COLON      EQU    3AH                  ; Colon
0072: E800
0073: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0074: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0075: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0076: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0077: E800             QMARK      EQU    3FH                  ; Question Mark
0078: E800             UNDER_SCORE EQU    5FH                  ; under score _
0079: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0080: E800             RUBOUT     EQU    7FH                  ; Delete Key
0081: E800
0082: E800
0083: E800             ASCII_A    EQU    'A'
0084: E800             ASCII_C    EQU    'C'
0085: E800             ASCII_K    EQU    'K'
0086: E800             ASCII_N    EQU    'N'
0087: E800             ASCII_Q    EQU    'Q'
0088: E800             ASCII_R    EQU    'R'
0089: E800             ASCII_W    EQU    'W'
0090: E800             ASCII_Y    EQU    'Y'
0091: E800             CARET      EQU    '^'
0092: E800             ASCII_LO_A EQU    'a'
0093: E800             ASCII_LO_K EQU    'k'
0094: E800             ASCII_LO_P EQU    'p'
0095: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0096: E800
0097: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0098: E800                        Include ./osHeader.Z80
0099: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0100: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0101: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0102: E800         ; osHeader.Z80
0103: E800
0104: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0105: E800         ; 2017-03-02 Refactored the CP/M Suite
0106: E800
0107: E800         ; Contains the Equates used by the CP/M system
0108: E800
0109: E800         ;------------------------Page Zero Constants ---------------------------------
0110: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0111: E800
0112: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0113: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0114: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0115: E800
0116: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0117: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0118: E800
0119: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0120: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0121: E800
0122: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0123: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0124: E800
0125: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0126: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0127: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0128: E800         ;-----------------------------------------------------------------------
0129: E800
0130: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0131: E800         ;-----------------------------------------------------------------------
0132: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0133: E800         ;-----------------------------------------------------------------------
0134: E800             END_OF_FILE EQU    1AH                  ; end of file
0135: E800         ;-----------------------------------------------------------------------
0136: E800
0137: E800         ;--------------- CP/M Constants -----------------------------------------
0138: E800
0139: E800             CCPLength  EQU    0800H                ; Constant
0140: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0141: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0142: E800
0143: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0144: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0145: E800
0146: E800             MemorySize EQU    64
0147: E800
0148: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0149: E800
0150: E800             BDOSBase   EQU    CCPEntry + CCPLength
0151: E800             BDOSEntry  EQU    BDOSBase
0152: E800
0153: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0154: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0155: E800         ;-----------------------------------------------------------------------
0156: E800
0157: E800         ;------------------- BDOS System Call Equates --------------------------
0158: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0159: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0160: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0161: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0162: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0163: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0164: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0165: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0166: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0167: E800             fCloseFile EQU    10H                  ; closef - Close File
0168: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0169: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0170: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0171: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0172: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0173: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0174: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0175: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0176: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0177: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0178: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0179: E800         ;-----------------------------------------------------------------------
0180: E800
0181: E800
0182: E800
0183: E800
0184: E800
0185: E800         ;*******************************************************************************
0186: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0187: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0188: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0189: E800         ; sector write) or to an allocation block that has already been allocated to a
0190: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0191: E800         ;*******************************************************************************
0192: E800             WriteAllocated EQU    00H
0193: E800             WriteDirectory EQU    01H
0194: E800             WriteCleanBuffer EQU    02H
0195: E800
0196: E800
0197: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0198: E800                        Include ./diskHeader.Z80
0199: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0200: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0201: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0202: E800         ; diskHeader.asm
0203: E800
0204: E800         ; 2017-03-02 Refactored the CP/M Suite
0205: E800
0206: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0207: E800
0208: E800         ; Contains the Equates used by the CP/M system to handle disks
0209: E800
0210: E800
0211: E800         ;*******************************************************************************
0212: E800         ;
0213: E800         ;     Disk related values
0214: E800         ;
0215: E800         ;
0216: E800         ;*******************************************************************************
0217: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0218: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0219: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0220: E800         ; for boot
0221: E800             DiskControlTable EQU    0040H
0222: E800
0223: E800             DiskReadCode EQU    01H                  ; Code for Read
0224: E800             DiskWriteCode EQU    02H                  ; Code for Write
0225: E800
0226: E800
0227: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0228: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0229: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0230: E800
0231: E800             DirEntrySize EQU    20H                  ; (32)
0232: E800             DirBuffSize EQU    cpmRecordSize
0233: E800
0234: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0235: E800
0236: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0237: E800
0238: E800
0239: E800         ;-------------------------------------------------------------------------------------
0240: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0241: E800
0242: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0243: E800             NumberOfHeads EQU    02H                  ; number of heads
0244: E800             TracksPerHead EQU    50H                  ; 80
0245: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0246: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0247: E800             DirectoryBlockCount EQU    02H                  ;
0248: E800         ;-----------------------------------------------------------------------
0249: E800
0250: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0251: E800
0252: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0253: E800
0254: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0255: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0256: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0257: E800
0258: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0259: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0260: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0261: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0262: E800
0263: E800         ;-----------------------------------------------------------------------
0264: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0265: E800         ;-----------------------------------------------------------------------
0266: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0267: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0268: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0269: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0270: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0271: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0272: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0273: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0274: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0275: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0276: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0277: E800             dpb3hdNOH  EQU    NumberOfHeads
0278: E800
0279: E800         ;*******************************************************************************
0280: E800
0281: E800             SectorMask EQU    SectorsPerBlock - 1
0282: E800
0283: E800         ;***************************************************************************
0284: E800
0285: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0286: E800
0287: E800             VERSION    EQU    20H                  ; Version 2.0
0288: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0289: E800             EOD        EQU    -1                   ; End of Directory
0290: E800
0291: E800         ;************************ BIOS Function Constants ***************************;
0292: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0293: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0294: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0295: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0296: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0297: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0298: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0299: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0300: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0301: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0302: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0303: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0304: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0305: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0306: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0307: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0308: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0309: E800         ;************************ BIOS Function Constants ***************************;
0310: E800
0311: E800         ;============================================================================;
0312: E800         ;	BDOS                                                                     ;
0313: E800         ; Calling into   :                                                           ;
0314: E800         ;					Register  C - Contains BDOS Function Code                ;
0315: E800         ;					Register  A - Holds the Byte argument if any             ;
0316: E800         ;					Register DE - Holds the Word argument if any             ;
0317: E800         ; Returning from :                                                           ;
0318: E800         ;					Register  A - The Byte return value if any               ;
0319: E800         ;					Register HL - The Word return value if any               ;
0320: E800         ;                   ( Register A=L and B=H)                                  ;
0321: E800         ;============================================================================;
0322: E800
0323: E800
0324: E800                        ORG    BDOSBase
0325: E800
0326: E800         ;===========================BDOS Entry=======================================;
0327: E800         ;BDOSEntry:                                                                  ;
0328: E800         ;
0329: E800         ;
0330: E800             BdosStart:                      ;
0331: E800         ;	LD		A,C                                                              ;
0332: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0333: E800         ;
0334: E800         ; Save Calling Arguments                                                     ;
0335: E800 ED 53 C0 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0336: E804 7B                     LD     A,E                  ;
0337: E805 32 BF EA               LD     (paramE),A           ; Save the Byte argument             ;
0338: E808         ; Save users Stack pointer                                                   ;
0339: E808 ED 73 B9 EA               LD     (usersStack),SP      ; We will use our own stack          ;
0340: E80C         ;
0341: E80C         ; initialize variables                                                       ;
0342: E80C 21 00 00               LD     HL,0000H             ;
0343: E80F 22 C2 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0344: E812 AF                     XOR    A                    ;
0345: E813 32 88 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0346: E816 32 86 F5               LD     (fResel),A           ; Clear re selection flag            ;
0347: E819         ;
0348: E819         ; Set up for return to caller when Function Completes                        ;
0349: E819 21 2F E8               LD     HL,ReturnToCaller    ;
0350: E81C E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0351: E81D         ;
0352: E81D         ; is it a valid function number ?	                                         ;
0353: E81D         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0354: E81D 79                     LD     A,C                  ;
0355: E81E FE 28                  CP     functionCount        ; make sure its a good number        ;
0356: E820 D0                     RET    NC                   ; exit if not a valid function       ;
0357: E821         ;
0358: E821         ; Calculate the index and get vector to go to	                             ;
0359: E821 4B                     LD     C,E                  ; Assume byte argument               ;
0360: E822 21 54 E8               LD     HL,functionTable     ; Get table base                     ;
0361: E825 5F                     LD     E,A                  ; Function number in E               ;
0362: E826 16 00                  LD     D,0                  ;
0363: E828 19                     ADD    HL,DE                ; Have byte location                 ;
0364: E829 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0365: E82A 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0366: E82B 23                     INC    HL                   ;
0367: E82C 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0368: E82D EB                     EX     DE,HL                ; Vector now in HL                   ;
0369: E82E         ;
0370: E82E         ; Vector to Function is in HL                                                ;
0371: E82E E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0372: E82F         ;===========================BDOS Entry=======================================;
0373: E82F         ;===========================BDOS Exit =======================================;
0374: E82F         ;arrive here at end of processing to return to user                          ;
0375: E82F             ReturnToCaller:                      ;
0376: E82F 3A 86 F5               LD     A,(fResel)           ; get re-selection flag              ;
0377: E832 B7                     OR     A                    ; is it set?                         ;
0378: E833 28 15                  JR     Z,ReturnToCaller1    ;
0379: E835         ;re-selection  may have taken place                                         ;
0380: E835 2A C0 EA               LD     HL,(paramDE)         ;
0381: E838 36 00                  LD     (HL),0               ;
0382: E83A 3A 88 F5               LD     A,(fcbDisk)          ;
0383: E83D B7                     OR     A                    ; Disk = 0?                          ;
0384: E83E 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0385: E840         ;
0386: E840 77                     LD     (HL),A               ;
0387: E841 3A 87 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0388: E844 32 BF EA               LD     (paramE),A           ; and select it                      ;
0389: E847 CD 4E EC               CALL   SelectCurrent        ;
0390: E84A         ;
0391: E84A             ReturnToCaller1:                      ;
0392: E84A 2A B9 EA               LD     HL,(usersStack)      ;
0393: E84D F9                     LD     SP,HL                ; restore callers stack              ;
0394: E84E 2A C2 EA               LD     HL,(exitParameterWord) ;
0395: E851 7D                     LD     A,L                  ;
0396: E852 44                     LD     B,H                  ; BA = exitParameterWord             ;
0397: E853 C9                     RET                         ;
0398: E854         ;===========================BDOS Exit =======================================;
0399: E854
0400: E854         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0401: E854             functionTable:                      ;
0402: E854 A7 E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0403: E856 AA E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0404: E858 BB E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0405: E85A BF E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0406: E85C C6 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0407: E85E CA E8                  DW     vListOut             ;   5 - List Output                  ;
0408: E860 CE E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0409: E862 E4 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0410: E864 EB E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0411: E866 F0 E8                  DW     vPrintString         ;   9 - Print String                 ;
0412: E868 F9 E8                  DW     vReadString          ;   A - Read Console String          ;
0413: E86A FD E8                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0414: E86C             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0415: E86C 04 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0416: E86E C4 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0417: E870 0A EB                  DW     vSelectDisk          ;   E - Select Disk                  ;
0418: E872 67 EF                  DW     vOpenFile            ;   F - Open File                    ;
0419: E874 70 EF                  DW     vCloseFile           ;  10 - Close File                   ;
0420: E876 76 EF                  DW     vFindFirst           ;  11 - Search For First             ;
0421: E878 8F EF                  DW     vFindNext            ;  12 - Search for Next              ;
0422: E87A 9E EF                  DW     vDeleteFile          ;  13 - Delete File                  ;
0423: E87C A7 EF                  DW     vReadSeq             ;  14 - Read Sequential              ;
0424: E87E AE EF                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0425: E880 B5 EF                  DW     vMakeFile            ;  16 - Make File                    ;
0426: E882 BE EF                  DW     vRenameFile          ;  17 - Rename File                  ;
0427: E884 DD EA                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0428: E886 E4 EA                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0429: E888 EB EA                  DW     vSetDMA              ;  1A - Set DMA address              ;
0430: E88A F4 EA                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0431: E88C 42 EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0432: E88E FB EA                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0433: E890 45 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0434: E892 02 EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0435: E894 0A E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0436: E896 0D EB                  DW     vReadRandom          ;  21 - Read Random                  ;
0437: E898 13 EB                  DW     vWriteRandom         ;  22 - Write Random                 ;
0438: E89A 19 EB                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0439: E89C 1F EB                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0440: E89E 09 EB                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0441: E8A0 A6 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0442: E8A2 A6 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0443: E8A4 22 EB                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0444: E8A6             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0445: E8A6         ;
0446: E8A6             DUMMY:                          ;
0447: E8A6 76                     HALT                        ;
0448: E8A7         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0449: E8A7
0450: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0451: E8A7         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0452: E8A7         ; same as the warm boot function invoked when you transfer control to the    ;
0453: E8A7         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0454: E8A7         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0455: E8A7         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0456: E8A7         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0457: E8A7         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0458: E8A7         ;																			 ;
0459: E8A7         ;			Function Code	 :	C = 00H                                      ;
0460: E8A7         ;			Entry Parameters:	None                                         ;
0461: E8A7         ;			Exit Parameters :	Does Not Return								 ;
0462: E8A7         ;																			 ;
0463: E8A7         ;-------------------------- System Reset - 0 (0) ----------------------------;
0464: E8A7             vSystemReset:
0465: E8A7 C3 03 F6               JP     bcWboot              ; do a Warm Boot
0466: E8AA
0467: E8AA         ;****************************************************************************;
0468: E8AA         ;								IOByte device I/O							 ;
0469: E8AA         ;****************************************************************************;
0470: E8AA
0471: E8AA
0472: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0473: E8AA         ;  This function reads the next byte of data from the console keyboard and   ;
0474: E8AA         ; puts it into register A. If the character input is a graphic character, it ;
0475: E8AA         ; will be echoed back to the console. The only control characters that are   ;
0476: E8AA         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0477: E8AA         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0478: E8AA         ; move the cursor to the next multiple of eight columns. All of the other    ;
0479: E8AA         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0480: E8AA         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0481: E8AA         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0482: E8AA         ; console output should also be sent to the list device. If CONTROL-S is     ;
0483: E8AA         ; found, further output will be suspended until you type another character.  ;
0484: E8AA         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0485: E8AA         ; pressed and disable it the second time. If there is no incoming data       ;
0486: E8AA         ; character, this function will wait until there is one.                     ;
0487: E8AA         ;                                                                            ;
0488: E8AA         ; This is a blocking function                                                ;
0489: E8AA         ;																			 ;
0490: E8AA         ;																			 ;
0491: E8AA         ;			Function Code	:	C = 01H                                      ;
0492: E8AA         ;			Entry Parameters:	None                                         ;
0493: E8AA         ;			Exit Parameters :	A = Data byte from console					 ;
0494: E8AA         ;																			 ;
0495: E8AA         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0496: E8AA             vConsoleIn:
0497: E8AA CD 1E E9               CALL   ConIn                ; Don't come back without input
0498: E8AD CD 29 E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0499: E8B0 D8                     RET    C                    ; return nothing to echo
0500: E8B1
0501: E8B1 F5                     PUSH   AF                   ; Save printable character
0502: E8B2 4F                     LD     C,A
0503: E8B3 CD 55 E9               CALL   TabOut               ; Send to console. if TAB expand
0504: E8B6 F1                     POP    AF                   ; retrieve exit value
0505: E8B7
0506: E8B7 32 C2 EA               LD     (exitParameterByte),A
0507: E8BA C9                     RET
0508: E8BB
0509: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0510: E8BB         ;  This function outputs the data byte in register E to the console. As with ;
0511: E8BB         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0512: E8BB         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0513: E8BB         ; checks to see if there is an incoming character, and if there is,          ;
0514: E8BB         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0515: E8BB         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0516: E8BB         ; printer is  toggled on or off                                              ;
0517: E8BB         ;																			 ;
0518: E8BB         ;			Function Code	:	C = 02H                                      ;
0519: E8BB         ;			Entry Parameters:	E = Data byte to be output					 ;
0520: E8BB         ;			Exit Parameters :	None										 ;
0521: E8BB         ;																			 ;
0522: E8BB         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0523: E8BB         ;BDOS put parameter in C before entering this routine
0524: E8BB             vConsoleOut:
0525: E8BB CD 55 E9               CALL   TabOut
0526: E8BE C9                     RET
0527: E8BF
0528: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0529: E8BF         ;   function reads the next character from the logical "reader" device into  ;
0530: E8BF         ; register A. In practice, the physical device that is accessed depends      ;
0531: E8BF         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0532: E8BF         ; reader at all; this function will return some arbitrary value such as lAH  ;
0533: E8BF         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0534: E8BF         ; Control is not returned to the calling program until a character has been  ;
0535: E8BF         ; read.                                                                      ;
0536: E8BF         ;                                                                            ;
0537: E8BF         ; This is a blocking function                                                ;
0538: E8BF         ;																			 ;
0539: E8BF         ;			Function Code	:	C = 03H                                      ;
0540: E8BF         ;			Entry Parameters:	None										 ;
0541: E8BF         ;			Exit Parameters :	A = Character Input							 ;
0542: E8BF         ;																			 ;
0543: E8BF         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0544: E8BF             vReaderIn:
0545: E8BF CD 15 F6               CALL   bcReader
0546: E8C2 32 C2 EA               LD     (exitParameterWord),A
0547: E8C5 C9                     RET
0548: E8C6
0549: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0550: E8C6         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0551: E8C6         ; specified character from register E to the logical punch device. Again,    ;
0552: E8C6         ; the actual physical device used, if any, is determined by the BIOS.        ;
0553: E8C6         ; There is no set standard for this device; in some systems the punch        ;
0554: E8C6         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0555: E8C6         ; output to it.                                                              ;
0556: E8C6         ;																			 ;
0557: E8C6         ;			Function Code	:	C = 04H                                      ;
0558: E8C6         ;			Entry Parameters:	E = Data byte to be output					 ;
0559: E8C6         ;			Exit Parameters :	None										 ;
0560: E8C6         ;																			 ;
0561: E8C6         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0562: E8C6         ;BDOS put parameter in C before entering this routine
0563: E8C6             vPunchOut:
0564: E8C6 CD 12 F6               CALL   bcPunch
0565: E8C9 C9                     RET
0566: E8CA
0567: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0568: E8CA         ;  This function outputs the specified byte in register E to the logical     ;
0569: E8CA         ; list device. As with the reader and the punch, the physical device used    ;
0570: E8CA         ; depends entirely on the BIOS.                                              ;
0571: E8CA         ;																			 ;
0572: E8CA         ;			Function Code	:	C = 05H                                      ;
0573: E8CA         ;			Entry Parameters:	E = Data byte to be output					 ;
0574: E8CA         ;			Exit Parameters :	None										 ;
0575: E8CA         ;																			 ;
0576: E8CA         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0577: E8CA         ;BDOS put parameter in C before entering this routine
0578: E8CA             vListOut:                       ; func5 (05 - 05) List Output
0579: E8CA CD 0F F6               CALL   bcList               ; direct call to BIOS
0580: E8CD C9                     RET
0581: E8CE
0582: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0583: E8CE         ;  This function serves double duty: it both inputs and outputs characters   ;
0584: E8CE         ; from the console. However, it bypasses the normal control characters and   ;
0585: E8CE         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0586: E8CE         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0587: E8CE         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0588: E8CE         ; then E contains a valid ASCII character that is output to the console.     ;
0589: E8CE         ;  This function works well provided you never have to send a value ofOFFH   ;
0590: E8CE         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0591: E8CE         ; binary data, you cannot use this function, since these values are likely   ;
0592: E8CE         ; to be part of the data stream.                                             ;
0593: E8CE         ;                                                                            ;
0594: E8CE         ;			Function Code	:	C = 06H                                      ;
0595: E8CE         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0596: E8CE         ;								E = Other than 0FFH for Output				 ;
0597: E8CE         ;			Exit Parameters :	A = Input byte or status					 ;
0598: E8CE         ;																			 ;
0599: E8CE         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0600: E8CE         ;BDOS put parameter in C before entering this routine
0601: E8CE             vDirectConIO:
0602: E8CE 79                     LD     A,C
0603: E8CF 3C                     INC    A
0604: E8D0 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0605: E8D2         ; send byte to console
0606: E8D2 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0607: E8D5 C9                     RET
0608: E8D6
0609: E8D6         ;read byte/status from console
0610: E8D6             vDirectConIO1:
0611: E8D6 CD 06 F6               CALL   bcConst              ; Check Status
0612: E8D9 B7                     OR     A                    ; 00 means not data ready
0613: E8DA CA 4A E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0614: E8DD CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0615: E8E0 32 C2 EA               LD     (exitParameterByte),A ; Save it
0616: E8E3 C9                     RET
0617: E8E4
0618: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0619: E8E4         ; This function places the current value of the IOBYTE in register A.        ;
0620: E8E4         ;                                                                            ;
0621: E8E4         ; The IOBYTE structure:                                                      ;
0622: E8E4         ;								+-------+-------+-------+-------+            ;
0623: E8E4         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0624: E8E4         ;								+-------+-------+-------+-------+            ;
0625: E8E4         ;				Logical Device     List | Punch | Reader|Console             ;
0626: E8E4         ;                                                                            ;
0627: E8E4         ;                                                                            ;
0628: E8E4         ;			Function Code	:	C = 07H                                      ;
0629: E8E4         ;			Entry Parameters:	None					  		  			 ;
0630: E8E4         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0631: E8E4         ;																			 ;
0632: E8E4         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0633: E8E4             vGetIOBYTE:
0634: E8E4 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0635: E8E7 32 C2 EA               LD     (exitParameterWord),A ; Return it to caller
0636: E8EA C9                     RET
0637: E8EB         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0638: E8EB         ; This function sets the IOBYTE         									 ;
0639: E8EB         ;                                                                            ;
0640: E8EB         ; The IOBYTE structure:                                                      ;
0641: E8EB         ;								+-------+-------+-------+-------+            ;
0642: E8EB         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0643: E8EB         ;								+-------+-------+-------+-------+            ;
0644: E8EB         ;				Logical Device     List | Punch | Reader|Console             ;
0645: E8EB         ;                                                                            ;
0646: E8EB         ;                                                                            ;
0647: E8EB         ;			Function Code	:	C = 08H                                      ;
0648: E8EB         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0649: E8EB         ;			Exit Parameters :	None                                         ;
0650: E8EB         ;																			 ;
0651: E8EB         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0652: E8EB         ;BDOS put parameter in C before entering this routine
0653: E8EB             vSetIOBYTE:
0654: E8EB 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0655: E8EE 71                     LD     (HL),C               ; Place new vale in it
0656: E8EF C9                     RET
0657: E8F0
0658: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0659: E8F0         ;  This function outputs a string of characters to the console device. The   ;
0660: E8F0         ; address of this string is in registers DE. You must make sure that the last;
0661: E8F0         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0662: E8F0         ; for the end of the string.                                                 ;
0663: E8F0         ;  The "$" itself does not get output to the console.                        ;
0664: E8F0         ;                                                                            ;
0665: E8F0         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0666: E8F0         ; described, checks to see if there is an incoming character, and checks for ;
0667: E8F0         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0668: E8F0         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0669: E8F0         ; the printer).                                                              ;
0670: E8F0         ;                                                                            ;
0671: E8F0         ;			Function Code	:	C = 09H                                      ;
0672: E8F0         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0673: E8F0         ;			Exit Parameters :	None							             ;
0674: E8F0         ;																			 ;
0675: E8F0         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0676: E8F0             vPrintString:
0677: E8F0 2A C0 EA               LD     HL,(paramDE)         ; Get address of the string
0678: E8F3 4D                     LD     C,L
0679: E8F4 44                     LD     B,H                  ; Put it into BC for call
0680: E8F5 CD 38 E9               CALL   Print                ; out to console
0681: E8F8 C9                     RET
0682: E8F9
0683: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0684: E8F9         ;  This function reads a string of characters from the console device        ;
0685: E8F9         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0686: E8F9         ; editing is possible: the operator can backspace, cancel the line and start ;
0687: E8F9         ; over, and use all the normal control functions. What you will ultimately   ;
0688: E8F9         ; see in the buffer is the final version of the character string entered,    ;
0689: E8F9         ; without any of the errors or control characters used to do the line editing;
0690: E8F9         ;                                                                            ;
0691: E8F9         ;  The buffer that you define has a special format. The first byte in the    ;
0692: E8F9         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0693: E8F9         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0694: E8F9         ; were actually placed in the buffer. The following bytes contain            ;
0695: E8F9         ; the characters of the string. Character input will cease either when a     ;
0696: E8F9         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0697: E8F9         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0698: E8F9         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0699: E8F9         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0700: E8F9         ; the "characters input" byte to O. If you attempt to input more than the    ;
0701: E8F9         ; maximum number of characters, the "characters input" count will be the     ;
0702: E8F9         ; same as the maximum value allowed.                                         ;
0703: E8F9         ;                                                                            ;
0704: E8F9         ;			Function Code	:	C = 0AH                                      ;
0705: E8F9         ;			Entry Parameters:	DE = Address string buffer					 ;
0706: E8F9         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0707: E8F9         ;																			 ;
0708: E8F9         ;-------------------------- Read Console String - A (10) --------------------;
0709: E8F9             vReadString:
0710: E8F9 CD DD E9               CALL   ReadString
0711: E8FC C9                     RET
0712: E8FD
0713: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0714: E8FD         ; This function tells you whether a console input character is waiting to be ;
0715: E8FD         ;processed. Unlike the Console Input functions, which will wait until there  ;
0716: E8FD         ;is input,this function simply checks and returns immediately.               ;
0717: E8FD         ;                                                                            ;
0718: E8FD         ;			Function Code	:	C = 0BH                                      ;
0719: E8FD         ;			Entry Parameters:	None										 ;
0720: E8FD         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0721: E8FD         ;								A = FFH	if incoming Data					 ;
0722: E8FD         ;																			 ;
0723: E8FD         ;------------------------- Read Console Status - B (11) ---------------------;
0724: E8FD             vGetConsoleStatus:
0725: E8FD CD 89 E9               CALL   ConBreak
0726: E900 32 C2 EA               LD     (exitParameterByte),A
0727: E903 C9                     RET
0728: E904
0729: E904         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0730: E904         ;  This function tells you which version of CP/M you are currently running.  ;
0731: E904         ; A two-byte value is returned:                                              ;
0732: E904         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0733: E904         ;	L = OOH for all releases before CP/M 2.0                                 ;
0734: E904         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0735: E904         ;		and so on for any subsequent releases.                               ;
0736: E904         ;                                                                            ;
0737: E904         ; This information is of interest only if your program has some version      ;
0738: E904         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0739: E904         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0740: E904         ; Therefore, if your program uses Random I/O, put this check at the          ;
0741: E904         ; beginning to ensure that it is indeed running under the appropriate        ;
0742: E904         ; version of CP/M.                                                           ;
0743: E904         ;                                                                            ;
0744: E904         ;			Function Code	:	C = 0CH                                      ;
0745: E904         ;			Entry Parameters:	None										 ;
0746: E904         ;			Exit Parameters :	HL =Version Number Code						 ;
0747: E904         ;								A = FFH	if incoming Data					 ;
0748: E904         ;																			 ;
0749: E904         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0750: E904             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0751: E904 3E 20                  LD     A,VERSION
0752: E906 32 C2 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0753: E909 C9                     RET
0754: E90A
0755: E90A         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0756: E90A         ;  This subroutine either sets or gets the current user number. The current  ;
0757: E90A         ; user number determines which file directory entries are matched during all ;
0758: E90A         ; disk file operations. When you call this function, the contents of the     ;
0759: E90A         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0760: E90A         ; will return the current user number in the A register. If you set E to a   ;
0761: E90A         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0762: E90A         ; will set the current user number to this value.                            ;
0763: E90A         ;                                                                            ;
0764: E90A         ;			Function Code	:	C = 0CH                                      ;
0765: E90A         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0766: E90A         ;								  = 0 to 15 to set User Number				 ;
0767: E90A         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0768: E90A         ;								A = FFH	if incoming Data					 ;
0769: E90A         ;																			 ;
0770: E90A         ;                                                                            ;
0771: E90A         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0772: E90A             vGetSetUserNumber:
0773: E90A 3A BF EA               LD     A,(paramE)
0774: E90D FE FF                  CP     0FFH
0775: E90F 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0776: E911 3A 55 F5               LD     A,(currentUserNumber)
0777: E914 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0778: E917 C9                     RET
0779: E918
0780: E918             SetUserNumber:
0781: E918 E6 0F                  AND    LO_NIBBLE_MASK
0782: E91A 32 55 F5               LD     (currentUserNumber),A
0783: E91D C9                     RET
0784: E91E
0785: E91E         ;****************************************************************************;
0786: E91E         ;								Character Support Routines					 ;
0787: E91E         ;****************************************************************************;
0788: E91E
0789: E91E
0790: E91E         ;-------------------- Return a Character from the console -------------------;
0791: E91E         ;return byte from buffer or read from the console                            ;
0792: E91E             ConIn:                          ;
0793: E91E 21 BB EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0794: E921 7E                     LD     A,(HL)               ;
0795: E922 36 00                  LD     (HL),0               ;
0796: E924 B7                     OR     A                    ;
0797: E925 C0                     RET    NZ                   ;
0798: E926         ;
0799: E926 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0800: E929         ;-------------------- Return a Character from the console -------------------;
0801: E929
0802: E929         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0803: E929         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0804: E929             IsPrintableASCII:                      ;
0805: E929 FE 0D                  CP     CR                   ;
0806: E92B C8                     RET    Z                    ; carriage return?                                                  ;
0807: E92C FE 0A                  CP     LF                   ;
0808: E92E C8                     RET    Z                    ; line feed?                                                        ;
0809: E92F FE 09                  CP     TAB                  ;
0810: E931 C8                     RET    Z                    ; TAB?                                                              ;
0811: E932 FE 08                  CP     CTRL_H               ;
0812: E934 C8                     RET    Z                    ; backspace?                                                        ;
0813: E935 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0814: E937 C9                     RET                         ;
0815: E938         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0816: E938
0817: E938         ;------------------ Print character from (BC) until  $ found ----------------;
0818: E938             Print:                          ;
0819: E938 0A                     LD     A,(BC)               ; Get the next character             ;
0820: E939 FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0821: E93B C8                     RET    Z                    ;  exit if yes                       ;
0822: E93C 03                     INC    BC                   ; Update the pointer                 ;
0823: E93D C5                     PUSH   BC                   ; Save it                            ;
0824: E93E 4F                     LD     C,A                  ; Does Byte require                  ;
0825: E93F CD 55 E9               CALL   TabOut               ;  special attention - check         ;
0826: E942 C1                     POP    BC                   ; Retrieve the pointer				 ;
0827: E943 18 F3                  JR     Print                ; Loop back                          ;
0828: E945         ;------------------ Print character from (BC) until  $ found ----------------;
0829: E945
0830: E945         ;-- Send printable character to console. Precede with Caret if needed -------;
0831: E945         ; character is in Reg C                                                      ;
0832: E945             CaretOut:                       ;
0833: E945 79                     LD     A,C                  ;
0834: E946 CD 29 E9               CALL   IsPrintableASCII     ;
0835: E949 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0836: E94B         ; send preceding up arrow                                                    ;
0837: E94B F5                     PUSH   AF                   ; Save the character                 ;
0838: E94C 0E 5E                  LD     C,CARET              ;
0839: E94E CD 68 E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0840: E951 F1                     POP    AF                   ; Get the character                  ;
0841: E952 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0842: E954 4F                     LD     C,A                  ; Set up to print                    ;
0843: E955         ; fall thru to TabbOut                                                       ;
0844: E955         ;-- Send printable character to console. Precede with Caret if needed -------;
0845: E955
0846: E955         ;------------- Send printable character to console. Expand if TAB -----------;
0847: E955         ; character is in Reg C                                                      ;
0848: E955             TabOut:                         ;
0849: E955 79                     LD     A,C                  ;
0850: E956 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0851: E958 C2 68 E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0852: E95B         ;
0853: E95B         ; TAB encountered                                                           ;
0854: E95B             TabOut0:                        ;
0855: E95B 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0856: E95D CD 68 E9               CALL   ConsoleOut           ; Send to Console                    ;
0857: E960 3A BE EA               LD     A,(columnPosition)   ; Get Column position                ;
0858: E963 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0859: E965 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0860: E967 C9                     RET                         ;
0861: E968         ;------------- Send printable character to console. Expand if TAB -----------;
0862: E968
0863: E968         ;-------------------------- Send character to console -----------------------;
0864: E968         ; C  = Character to be output                                                ;
0865: E968             ConsoleOut:                      ;
0866: E968         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0867: E968 C5                     PUSH   BC                   ; Save character and Count           ;
0868: E969 CD 89 E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0869: E96C C1                     POP    BC                   ;
0870: E96D C5                     PUSH   BC                   ; Get/save character                 ;
0871: E96E         ; Send character to Console	                                                 ;
0872: E96E CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0873: E971 C1                     POP    BC                   ;
0874: E972 C5                     PUSH   BC                   ; Get/save character                 ;
0875: E973         ; is the data to be output to print device?                                  ;
0876: E973 3A BC EA               LD     A,(printEchoFlag)    ;
0877: E976 B7                     OR     A                    ;
0878: E977 C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0879: E97A C1                     POP    BC                   ; Get the character                  ;
0880: E97B         ;
0881: E97B 79                     LD     A,C                  ; Put character to ACC               ;
0882: E97C 21 BE EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0883: E97F 34                     INC    M                    ; increment the ColumnPosition       ;
0884: E980         ;
0885: E980 FE 20                  CP     SPACE                ;
0886: E982 D0                     RET    NC                   ; Exit if ASCII printable            ;
0887: E983         ;
0888: E983 FE 0A                  CP     LF                   ;
0889: E985 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0890: E986         ;
0891: E986 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0892: E988 C9                     RET                         ;
0893: E989         ;-------------------------- Send character to console -----------------------;
0894: E989
0895: E989         ;--------------------  Check for Status and Control S or C ------------------;
0896: E989         ;  Returns:																	 ;
0897: E989         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0898: E989         ;			ACC = 00   No data Pending										 ;
0899: E989         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0900: E989         ;                                                                            ;
0901: E989             ConBreak:                       ;
0902: E989 3A BB EA               LD     A,(keyboardByte)     ;
0903: E98C B7                     OR     A                    ; If there is a char waiting         ;
0904: E98D 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0905: E98F         ;
0906: E98F CD 06 F6               CALL   bcConst              ; Get status                         ;
0907: E992 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0908: E994 C8                     RET    Z                    ; Return 00 No data pending          ;
0909: E995         ;
0910: E995 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0911: E998         ;
0912: E998 FE 10                  CP     CTRL_P               ;
0913: E99A 20 0D                  JR     NZ,CheckCTL_S        ;
0914: E99C         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0915: E99C 21 BC EA               LD     HL,printEchoFlag     ;
0916: E99F 3E FF                  LD     A,TRUE               ;
0917: E9A1 BE                     CP     (HL)                 ;
0918: E9A2 20 02                  JR     NZ,ToggleFlag1       ;
0919: E9A4 3E 00                  LD     A,FALSE              ;
0920: E9A6             ToggleFlag1:                      ;
0921: E9A6 77                     LD     (HL),A               ;
0922: E9A7 18 0C                  JR     NothingWaiting       ;
0923: E9A9         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0924: E9A9             CheckCTL_S:                      ;
0925: E9A9 FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0926: E9AB 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0927: E9AD         ;
0928: E9AD CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0929: E9B0 FE 03                  CP     CTRL_C               ;
0930: E9B2 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0931: E9B5             NothingWaiting:                      ;
0932: E9B5 AF                     XOR    A                    ;
0933: E9B6 C9                     RET                         ; Set ACC = 0 and return             ;
0934: E9B7             ConBreak0:                      ;
0935: E9B7 32 BB EA               LD     (keyboardByte),A     ; save the byte                      ;
0936: E9BA             ConBreak1:                      ;
0937: E9BA 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0938: E9BC C9                     RET                         ;
0939: E9BD         ;--------------------  Check for Status and Control S or C ------------------;
0940: E9BD
0941: E9BD         ;------------------------  Console Output Utilities -------------------------;
0942: E9BD             showHashCRLF:                      ;
0943: E9BD 0E 23                  LD     C,HASH_TAG           ;
0944: E9BF CD 68 E9               CALL   ConsoleOut           ; Send # to console                  ;
0945: E9C2 CD D3 E9               CALL   showCRLF             ;
0946: E9C5             showHashCRLF1:                      ;
0947: E9C5 3E BE                  LD     A,columnPosition     ;
0948: E9C7 21 BD EA               LD     HL,startingColumn    ;
0949: E9CA BF                     CP     A,M                  ;
0950: E9CB D0                     RET    NC                   ;
0951: E9CC 0E 20                  LD     C,SPACE              ;
0952: E9CE CD 68 E9               CALL   ConsoleOut           ;
0953: E9D1 18 F2                  JR     showHashCRLF1        ;
0954: E9D3         ;------------------------  Console Output Utilities -------------------------;
0955: E9D3
0956: E9D3         ;------------------------  Send Carriage Return and Line Feed ---------------;
0957: E9D3             showCRLF:                       ;
0958: E9D3 0E 0D                  LD     C,CR                 ;
0959: E9D5 CD 68 E9               CALL   ConsoleOut           ;
0960: E9D8 0E 0A                  LD     C,LF                 ;
0961: E9DA C3 68 E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0962: E9DD         ;------------------------  Send Carriage Return and Line Feed ---------------;
0963: E9DD
0964: E9DD         ;------------------------- Read a $ terminated String -----------------------;
0965: E9DD         ;read to paramDE address (max length, current length, buffer)               ;
0966: E9DD             ReadString:                      ;
0967: E9DD 3A BE EA               LD     A,(columnPosition)   ;
0968: E9E0 32 BD EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0969: E9E3 2A C0 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0970: E9E6 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0971: E9E7 23                     INC    HL                   ; Point at actual bytes read         ;
0972: E9E8 06 00                  LD     B,0                  ; Initialize Current Count           ;
0973: E9EA         ;
0974: E9EA         ; B = Current Count                                                      ;
0975: E9EA         ; C = Maximum characters                                                 ;
0976: E9EA         ; HL= Insertion Pointer                                                  ;
0977: E9EA         ;
0978: E9EA         ; read next character, BC, HL active                                        ;
0979: E9EA             ReadNext:                       ;
0980: E9EA C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0981: E9EB E5                     PUSH   HL                   ; Save pointer                       ;
0982: E9EC             ReadNext0:                      ;
0983: E9EC CD 1E E9               CALL   ConIn                ; Get the next Character             ;
0984: E9EF E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0985: E9F1 E1                     POP    HL                   ; Restore Pointer					 ;
0986: E9F2 C1                     POP    BC                   ; Restore Current Index and Max Count;
0987: E9F3         ;Is It Carriage Return                                                       ;
0988: E9F3 FE 0D                  CP     CR                   ;
0989: E9F5 CA 3B EA               JP     Z,EndRead            ; End the read if yes                ;
0990: E9F8 FE 0A                  CP     LF                   ;
0991: E9FA         ;Is It Linefeed                                                              ;
0992: E9FA CA 3B EA               JP     Z,EndRead            ; End the read if yes                ;
0993: E9FD         ;Is It BackSpace                                                             ;
0994: E9FD FE 08                  CP     CTRL_H               ;
0995: E9FF CA 45 EA               JP     Z,BSspaceBS          ;
0996: EA02             IsItRubout:                      ;
0997: EA02 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
0998: EA04 CA 4F EA               JP     Z,ItIsRubout         ;
0999: EA07             IsPhysicalEOL:                      ;
1000: EA07 FE 05                  CP     CTRL_E               ;
1001: EA09 CA 5A EA               JP     Z,ItIsPhysicalEOL    ;
1002: EA0C             IsItPrintToggle:                      ;
1003: EA0C FE 10                  CP     CTRL_P               ;
1004: EA0E CA 62 EA               JP     Z,ItIsPrintToggle    ;
1005: EA11             IsItDeleteTheLineX:                      ;
1006: EA11 FE 18                  CP     CTRL_X               ;
1007: EA13 CA 8B EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1008: EA16             IsItDeleteTheLineU:                      ;
1009: EA16 FE 15                  CP     CTRL_U               ;
1010: EA18 CA A9 EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1011: EA1B         ;Retype the line                                                             ;
1012: EA1B FE 12                  CP     CTRL_R               ;
1013: EA1D CA 72 EA               JP     Z,RepeatLine         ;
1014: EA20
1015: EA20         ;....................... Echo input back to the Console  ....................;
1016: EA20         ; Full Duplex								                                 ;
1017: EA20         ; A = Character to display	                                                 ;
1018: EA20         ; B = current char count                                                     ;
1019: EA20         ; C = maximum buffer length                                                  ;
1020: EA20         ; HL= buffer pointer                                                         ;
1021: EA20         ;ReadEcho                                                                    ;
1022: EA20 04                     INC    B                    ; Increment byte count		         ;
1023: EA21 23                     INC    HL                   ; Advance the Pointer                ;
1024: EA22 77                     LD     (HL),A               ; Put char in buffer                 ;
1025: EA23         ;
1026: EA23             ReadEchoRubOut:                      ;
1027: EA23 C5                     PUSH   BC                   ; Save index and length              ;
1028: EA24 E5                     PUSH   HL                   ; Save the Pointer                   ;
1029: EA25 4F                     LD     C,A                  ; Get char                           ;
1030: EA26 CD 45 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1031: EA29 E1                     POP    HL                   ; Restore the Pointer                ;
1032: EA2A C1                     POP    BC                   ; Restore index and length           ;
1033: EA2B 7E                     LD     A,(HL)               ; Recall char                        ;
1034: EA2C         ; check for Warm Boot                                                        ;
1035: EA2C FE 03                  CP     CTRL_C               ;
1036: EA2E 78                     LD     A,B                  ; Get Line position                  ;
1037: EA2F C2 37 EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1038: EA32 FE 01                  CP     1                    ; Beginning of the Line?             ;
1039: EA34 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1040: EA37         ; Check to see if we are at the end of the buffer                            ;
1041: EA37             AreWeAtEndOfBuffer:                      ;
1042: EA37 B9                     CP     C                    ; Over Max ?					     ;
1043: EA38 DA EA E9               JP     C,ReadNext           ;  no, Go for more				     ;
1044: EA3B         ;
1045: EA3B         ; At the end of read                                  					     ;
1046: EA3B             EndRead:                        ;
1047: EA3B         ; 	POP		HL                                                               ;
1048: EA3B 2A C0 EA               LD     HL,(paramDE)         ;
1049: EA3E 23                     INC    HL                   ;
1050: EA3F         ;
1051: EA3F 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1052: EA40 0E 0D                  LD     C,CR                 ;
1053: EA42 C3 68 E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1054: EA45         ;....................... Echo input back to the Console  ....................;
1055: EA45         ;.......................... Backspace SPACE BackSpace .......................;
1056: EA45             BSspaceBS:                      ;
1057: EA45 05                     DEC    B                    ;
1058: EA46 2B                     DEC    HL                   ;
1059: EA47 C5                     PUSH   BC                   ;
1060: EA48 E5                     PUSH   HL                   ;
1061: EA49 CD 9C EA               CALL   BackUp               ;
1062: EA4C C3 EC E9               JP     ReadNext0            ;
1063: EA4F         ;.......................... Backspace SPACE BackSpace .......................;
1064: EA4F         ;.......................... It is RubOut ....................................;
1065: EA4F             ItIsRubout:                      ;
1066: EA4F         ; RUBOUT if possible                                                         ;
1067: EA4F 78                     LD     A,B                  ; Are we at the start of the line    ;
1068: EA50 B7                     OR     A                    ;
1069: EA51 CA EA E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1070: EA54         ;adjust pointers back one                                                    ;
1071: EA54 7E                     LD     A,(HL)               ; ACC = current character            ;
1072: EA55 05                     DEC    B                    ; Adjust the index			    	 ;
1073: EA56 2B                     DEC    HL                   ; Adjust the pointer                 ;
1074: EA57 C3 23 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1075: EA5A         ;.......................... It is RubOut ....................................;
1076: EA5A         ;.......................... It is PhysicalEOL ...............................;
1077: EA5A             ItIsPhysicalEOL:                      ;
1078: EA5A C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1079: EA5B E5                     PUSH   HL                   ; Save pointer                       ;
1080: EA5C CD D3 E9               CALL   showCRLF             ; Make new line                      ;
1081: EA5F C3 EC E9               JP     ReadNext0            ;   and go for next char   			 ;
1082: EA62         ;.......................... It is PhysicalEOL ...............................;
1083: EA62         ;.......................... It is PrintToggle ...............................;
1084: EA62             ItIsPrintToggle:
1085: EA62 E5                     PUSH   HL                   ; Save pointer                       ;
1086: EA63         ; Toggle the printEcho Flag                                                  ;
1087: EA63 21 BC EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1088: EA66 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1089: EA68 BE                     CP     (HL)                 ; Is the flag true?                  ;
1090: EA69 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1091: EA6B 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1092: EA6D             IsItPrintToggle1:                      ;
1093: EA6D 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1094: EA6E E1                     POP    HL                   ; Restore pointer                    ;
1095: EA6F C3 EA E9               JP     ReadNext             ;   and for another char             ;
1096: EA72         ;.......................... It is PrintToggle ...............................;
1097: EA72         ;.......................... RepeatLine ......................................;
1098: EA72             RepeatLine:                      ;
1099: EA72 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1100: EA73 E5                     PUSH   HL                   ;  for exit                          ;
1101: EA74 CD BD E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1102: EA77         ;
1103: EA77 2A C0 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1104: EA7A 23                     INC    HL                   ; Skip past character count          ;
1105: EA7B         ;
1106: EA7B             LL1:                            ;
1107: EA7B 23                     INC    HL                   ; Point at next char to display      ;
1108: EA7C C5                     PUSH   BC                   ; Save counter, in B                 ;
1109: EA7D E5                     PUSH   HL                   ; Save buffer pointer                ;
1110: EA7E 4E                     LD     C,M                  ; Get the next character             ;
1111: EA7F CD 45 E9               CALL   CaretOut             ; Display it                         ;
1112: EA82 E1                     POP    HL                   ; Restore                            ;
1113: EA83 C1                     POP    BC                   ;  the counter and pointer           ;
1114: EA84 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1115: EA86 E1                     POP    HL                   ; Restore values                     ;
1116: EA87 C1                     POP    BC                   ;  from routine entry                ;
1117: EA88 C3 EA E9               JP     ReadNext             ; Done here !                        ;
1118: EA8B         ;.......................... RepeatLine ......................................;
1119: EA8B         ;.......................... Delete The Line .................................;
1120: EA8B             DeleteTheLine:                      ;
1121: EA8B E1                     POP    HL                   ; Adjust Stack                       ;
1122: EA8C         ;                                             ;
1123: EA8C             DeleteTheLine1:                      ;
1124: EA8C 3A BD EA               LD     A,(startingColumn)   ;
1125: EA8F 21 BE EA               LD     HL,columnPosition    ;
1126: EA92 BE                     CP     M                    ; Start of line ?                    ;
1127: EA93 D2 DD E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1128: EA96 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1129: EA97 CD 9C EA               CALL   BackUp               ; Clear 1 column                     ;
1130: EA9A 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1131: EA9C         ;.......................... Delete The Line .................................;
1132: EA9C         ;------------------------ Back-up one screen position -----------------------;
1133: EA9C             BackUp:                         ;
1134: EA9C CD A4 EA               CALL   BackUp1              ; Send Backspace                     ;
1135: EA9F 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1136: EAA1 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1137: EAA4         ;does not affect column count                                                ;
1138: EAA4             BackUp1:                        ;
1139: EAA4 0E 08                  LD     C,CTRL_H             ;
1140: EAA6 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1141: EAA9         ;------------------------ Back-up one screen position -----------------------;
1142: EAA9         ;.......................... Ignore The Line .................................;
1143: EAA9             IgnoreTheLine:                      ;
1144: EAA9 CD BD E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1145: EAAC 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1146: EAAE CD 0C F6               CALL   bcConout             ;  to the console                    ;
1147: EAB1 0E 20                  LD     C,SPACE              ;
1148: EAB3 CD 0C F6               CALL   bcConout             ;
1149: EAB6 C3 DD E9               JP     ReadString           ; Start all over                     ;
1150: EAB9         ;.......................... Ignore The Line .................................;
1151: EAB9
1152: EAB9         ;------------------------- Read a $ terminated String -----------------------;
1153: EAB9
1154: EAB9         ;****************************************************************************
1155: EAB9         ;                           DATA AREA                                       *
1156: EAB9         ;****************************************************************************
1157: EAB9
1158: EAB9         ;------------------------------Non Disk Data Area ---------------------------;
1159: EAB9             usersStack: DS     2                    ; entry stack pointer                ;
1160: EABB         ;
1161: EABB 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1162: EABC         ;
1163: EABC 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1164: EABD         ;
1165: EABD         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1166: EABD 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1167: EABE 00          columnPosition: DB     0                    ; Current Column position            ;
1168: EABF         ;
1169: EABF             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1170: EAC0             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1171: EAC2             exitParameterByte:                      ; Byte returned Value                ;
1172: EAC2             exitParameterWord: DS     WORD                 ; Word                           ;
1173: EAC4         ;
1174: EAC4         ;
1175: EAC4         ;------------------------------------ Data Area -----------------------------;
1176: EAC4
1177: EAC4
1178: EAC4
1179: EAC4         ;****************************************************************************;
1180: EAC4         ;								Disk I/O									 ;
1181: EAC4         ;****************************************************************************;
1182: EAC4
1183: EAC4         ;---------------------------- Reset Disk System - D (13) --------------------;
1184: EAC4         ;  This function requests CP/M to completely reset the disk file system.     ;
1185: EAC4         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1186: EAC4         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1187: EAC4         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1188: EAC4         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1189: EAC4         ; in each logical disk as each disk is accessed. This involves reading the   ;
1190: EAC4         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1191: EAC4         ; which keep track of which allocation blocks are free and which             ;
1192: EAC4         ; are used for file storage.                                                 ;
1193: EAC4         ;                                                                            ;
1194: EAC4         ;			Function Code	:	C = 0DH                                      ;
1195: EAC4         ;			Entry Parameters:	None										 ;
1196: EAC4         ;			Exit Parameters :	None										 ;
1197: EAC4         ;																			 ;
1198: EAC4         ;---------------------------- Reset Disk System - D (13) --------------------;
1199: EAC4             vResetSystem:
1200: EAC4 21 00 00               LD     HL,0
1201: EAC7 22 58 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1202: EACA 22 5A F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1203: EACD AF                     XOR    A                    ; Clear the current disk
1204: EACE 32 56 F5               LD     (currentDisk),A
1205: EAD1         ; note that currentUserNumber remains unchanged
1206: EAD1 21 80 00               LD     HL,DMABuffer
1207: EAD4 22 5C F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1208: EAD7 CD B8 ED               CALL   SetDataDMA           ; to data dma address
1209: EADA C3 5A EC               JP     Select
1210: EADD         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1211: EADD         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1212: EADD         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1213: EADD         ; This function returns a bit map, called the login vector, in register pair ;
1214: EADD         ; HL, indicating which logical disk drives have been selected since the last ;
1215: EADD         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1216: EADD         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1217: EADD         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1218: EADD         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1219: EADD         ;  Logical disks can be selected programmatically through any file operation ;
1220: EADD         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1221: EADD         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1222: EADD         ; where "X" is equal to A, B, ... , P.                                       ;
1223: EADD         ;                                                                            ;
1224: EADD         ;			Function Code	:	C = 018H                                     ;
1225: EADD         ;			Entry Parameters:	None										 ;
1226: EADD         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1227: EADD         ;																			 ;
1228: EADD         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1229: EADD             vGetLoginVector:
1230: EADD 2A 5A F5               LD     HL,(loggedDisks)
1231: EAE0 22 C2 EA               LD     (exitParameterWord),HL
1232: EAE3 C9                     RET
1233: EAE4         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1234: EAE4         ;   This function returns the current default disk set by the last Select    ;
1235: EAE4         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1236: EAE4         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1237: EAE4         ;                                                                            ;
1238: EAE4         ;  This function returns the current default disk in coded form.             ;
1239: EAE4         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1240: EAE4         ; If you need to convert this to the corresponding ASCII character, simply   ;
1241: EAE4         ; add 41H to register A. Use this function when you convert a file name and  ;
1242: EAE4         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1243: EAE4         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1244: EAE4         ; You must therefore use this function to determine the logical disk letter  ;
1245: EAE4         ; for the default drive.                                                     ;
1246: EAE4         ;                                                                            ;
1247: EAE4         ;			Function Code	:	C = 019H                                     ;
1248: EAE4         ;			Entry Parameters:	None										 ;
1249: EAE4         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1250: EAE4         ;																			 ;
1251: EAE4         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1252: EAE4             vGetCurrentDisk:
1253: EAE4 3A 56 F5               LD     A,(currentDisk)
1254: EAE7 32 C2 EA               LD     (exitParameterByte),A
1255: EAEA C9                     RET
1256: EAEB         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1257: EAEB         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1258: EAEB         ; value. The name is an historic relic dating back to the Intel Development  ;
1259: EAEB         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1260: EAEB         ; its hardware, could read data from a diskette directly into memory or      ;
1261: EAEB         ; write data to a diskette directly from memory. The name DMA address now    ;
1262: EAEB         ; applies to the address of the buffer to and from which data is             ;
1263: EAEB         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1264: EAEB         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1265: EAEB         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1266: EAEB         ; value of 0080H.                                                            ;
1267: EAEB         ;                                                                            ;
1268: EAEB         ;			Function Code	:	C = 0A9H                                     ;
1269: EAEB         ;			Entry Parameters:	DE = DMA Address							 ;
1270: EAEB         ;			Exit Parameters :	None										 ;
1271: EAEB         ;																			 ;
1272: EAEB         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1273: EAEB             vSetDMA:
1274: EAEB 2A C0 EA               LD     HL,(paramDE)
1275: EAEE 22 5C F5               LD     (initDAMAddress),HL
1276: EAF1 C3 B8 ED               JP     SetDataDMA
1277: EAF4         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1278: EAF4         ;  This function returns the base, or starting, address of the allocation    ;
1279: EAF4         ; vector for the currently selected logical disk. This information,          ;
1280: EAF4         ; indicating which parts of the disk are assigned, is used by utility        ;
1281: EAF4         ; programs and the BDOS itself to determine how much unused space is on the  ;
1282: EAF4         ; logical disk, to locate an unused allocation block in order to extend      ;
1283: EAF4         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1284: EAF4         ;                                                                            ;
1285: EAF4         ;			Function Code	:	C = 01BH                                     ;
1286: EAF4         ;			Entry Parameters:	None										 ;
1287: EAF4         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1288: EAF4         ;																			 ;
1289: EAF4         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1290: EAF4             vGetAllocAddr:
1291: EAF4 2A 6A F5               LD     HL,(caAllocVector)
1292: EAF7 22 C2 EA               LD     (exitParameterWord),HL
1293: EAFA C9                     RET
1294: EAFB         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1295: EAFB         ;  This function returns a bit map in registers H and L showing which logical;
1296: EAFB         ; disks in the system have been set to Read-Only status, either by the       ;
1297: EAFB         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1298: EAFB         ; BDOS itself, because it detected that a diskette had been changed.         ;
1299: EAFB         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1300: EAFB         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1301: EAFB         ; the specific logical disk is set to I if the disk has been set to          ;
1302: EAFB         ; Read-Only status.                                                          ;
1303: EAFB         ;                                                                            ;
1304: EAFB         ;			Function Code	:	C = 0DBH                                     ;
1305: EAFB         ;			Entry Parameters:	None										 ;
1306: EAFB         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1307: EAFB         ;																			 ;
1308: EAFB         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1309: EAFB             vGetReadOnlyMap:
1310: EAFB 2A 58 F5               LD     HL,(readOnlyVector)
1311: EAFE 22 C2 EA               LD     (exitParameterWord),HL
1312: EB01 C9                     RET
1313: EB02         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1314: EB02         ;  This function returns the address of the disk parameter block (DPB) for   ;
1315: EB02         ; the last selected logical disk. The DPB describes the physical             ;
1316: EB02         ; characteristics of a specific logical disk-information mainly of interest  ;
1317: EB02         ; for system utility programs.                                               ;
1318: EB02         ;                                                                            ;
1319: EB02         ;			Function Code	:	C = 1FH                                     ;
1320: EB02         ;			Entry Parameters:	None										 ;
1321: EB02         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1322: EB02         ;																			 ;
1323: EB02         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1324: EB02             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1325: EB02 2A 66 F5               LD     HL,(caDiskParamBlock)
1326: EB05 22 C2 EA               LD     (exitParameterWord),HL
1327: EB08 C9                     RET
1328: EB09
1329: EB09         ;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
1330: EB09         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1331: EB09         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1332: EB09         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1333: EB09
1334: EB09         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1335: EB09         ;  This function resets individual disk drives. It is a more precise version ;
1336: EB09         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1337: EB09         ; specific logical; disks rather than all of them.                           ;
1338: EB09         ;  The bit map in DE shows which disks are to be reset. The least significant;
1339: EB09         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1340: EB09         ; The bits set to I indicate the disks to be reset.                          ;
1341: EB09         ;  Note that this function returns a zero value in A in order to maintain    ;
1342: EB09         ; compatibility with MP/ M.                                                  ;
1343: EB09         ;                                                                            ;
1344: EB09         ;			Function Code	:	C = 25H                                      ;
1345: EB09         ;			Entry Parameters:	DE = Logical Drive Bit Vector					 ;
1346: EB09         ;			Exit Parameters :	A = 00H										 ;
1347: EB09         ;																			 ;
1348: EB09         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1349: EB09         ;Reset Drive
1350: EB09         ;IN  - (DE) Drive Vector
1351: EB09         ;OUT - (A) 00
1352: EB09             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1353: EB09         ; Not Yet Implemented   **************
1354: EB09 C9                     RET
1355: EB0A         ;*****************************************************************
1356: EB0A
1357: EB0A         ;-----------------------------------------------------------------
1358: EB0A         ;select disk in (E) paramDE
1359: EB0A         ; IN - (E) disk number -- 0=A  1=B ...15=P
1360: EB0A             vSelectDisk:                      ; func14 (14 - 0E)	Select Current Disk
1361: EB0A C3 4E EC               JP     SelectCurrent
1362: EB0D         ;ret ;jmp goba
1363: EB0D
1364: EB0D
1365: EB0D         ;*****************************************************************
1366: EB0D         ;random disk read
1367: EB0D         ;IN  - (DE) FCB address
1368: EB0D         ;OUT - (A) 01 = Reading unwritten data
1369: EB0D         ;	 02 = N/U
1370: EB0D         ;	 03 = Cannot close current extent
1371: EB0D         ;	 04 = Seek to unwriten Extent
1372: EB0D         ;	 05 = N/U
1373: EB0D         ;	 06 = Seek past Physical end of Disk
1374: EB0D             vReadRandom:                      ; func33 (33 - 21) Read Random record
1375: EB0D CD F6 F2               CALL   Reselect
1376: EB10 C3 23 EB               JP     RandomDiskRead       ; to perform the disk read
1377: EB13         ;*****************************************************************
1378: EB13         ;write random record
1379: EB13         ;IN  - (DE) FCB address
1380: EB13         ;OUT - (A) 01 = Reading unwritten data
1381: EB13         ;	 02 = N/U
1382: EB13         ;	 03 = Cannot close current extent
1383: EB13         ;	 04 = Seek to unwriten Extent
1384: EB13         ;	 05 = Cannot create new Extent because of directory overflow
1385: EB13         ;	 06 = Seek past Physical end of Disk
1386: EB13             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1387: EB13 CD F6 F2               CALL   Reselect
1388: EB16 C3 2C EB               JP     RandomDiskWrite      ; to perform the disk write
1389: EB19         ;ret ;jmp goback
1390: EB19         ;*****************************************************************
1391: EB19         ;return file size (0-65536)
1392: EB19         ;IN  - (DE) FCB address
1393: EB19             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1394: EB19 CD F6 F2               CALL   Reselect
1395: EB1C C3 D9 EB               JP     GetFileSize
1396: EB1F         ;*****************************************************************
1397: EB1F         ;set random record
1398: EB1F         ;IN  - (DE) FCB address
1399: EB1F         ;OUT - Random Record Field is set
1400: EB1F             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1401: EB1F C3 C6 EB               JP     SetRandomRecord
1402: EB22         ;? ;*****************************************************************
1403: EB22         ;? ;Reset Drive
1404: EB22         ;? ;IN  - (DE) Drive Vector
1405: EB22         ;? ;OUT - (A) 00
1406: EB22         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
1407: EB22         ;? ; Not Yet Implemented   **************
1408: EB22         ;?	RET
1409: EB22         ;*****************************************************************
1410: EB22         ;*****************************************************************
1411: EB22         ;Write Random With Zero Fill
1412: EB22         ;IN  - (DE) FCB address
1413: EB22         ;OUT - (A) Return Code		see Function 34
1414: EB22             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1415: EB22         ; Not Yet Implemented   **************
1416: EB22 C9                     RET
1417: EB23         ;*****************************************************************
1418: EB23         ;******************< Random I/O Stuff ****************************
1419: EB23         ;*****************************************************************
1420: EB23         ;random disk read
1421: EB23             RandomDiskRead:                      ; randiskread
1422: EB23 0E FF                  LD     C,TRUE               ; marked as read operation
1423: EB25 CD 35 EB               CALL   RandomSeek
1424: EB28 CC EE EF               CALL   Z,DiskRead           ; if seek successful
1425: EB2B C9                     RET
1426: EB2C         ;*****************************************************************
1427: EB2C         ;random disk write
1428: EB2C             RandomDiskWrite:                      ; randiskwrite
1429: EB2C 0E 00                  LD     C,FALSE              ; marked as read operation
1430: EB2E CD 35 EB               CALL   RandomSeek
1431: EB31 CC 31 F0               CALL   Z,DiskWrite          ; if seek successful
1432: EB34 C9                     RET
1433: EB35         ;*****************************************************************
1434: EB35         ;*****************************************************************
1435: EB35         ;random access seek operation, C=0ffh if read mode
1436: EB35         ;fcb is assumed to address an active file control block
1437: EB35         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1438: EB35             RandomSeek:
1439: EB35 AF                     XOR    A
1440: EB36 32 80 F5               LD     (seqReadFlag),A      ; marked as random access operation
1441: EB39 C5                     PUSH   BC                   ; save r/w flag
1442: EB3A 2A C0 EA               LD     HL,(paramDE)
1443: EB3D EB                     EX     DE,HL                ; DE will hold base of fcb
1444: EB3E 21 21 00               LD     HL,RANDOM_REC_FIELD
1445: EB41 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1446: EB42 7E                     LD     A,(HL)
1447: EB43 E6 7F                  AND    7FH
1448: EB45 F5                     PUSH   AF                   ; record number
1449: EB46 7E                     LD     A,(HL)
1450: EB47 17                     RLA                         ; cy=lsb of extent#
1451: EB48 23                     INC    HL
1452: EB49 7E                     LD     A,(HL)
1453: EB4A 17                     RLA
1454: EB4B E6 1F                  AND    11111B               ; A=ext#
1455: EB4D 4F                     LD     C,A                  ; C holds extent number, record stacked
1456: EB4E 7E                     LD     A,(HL)
1457: EB4F 1F                     RRA
1458: EB50 1F                     RRA
1459: EB51 1F                     RRA
1460: EB52 1F                     RRA
1461: EB53 E6 0F                  AND    1111B                ; mod#
1462: EB55 47                     LD     B,A                  ; B holds module#, C holds ext#
1463: EB56 F1                     POP    AF                   ; recall sought record #
1464: EB57         ;check to insure that high byte of ran rec = 00
1465: EB57 23                     INC    HL
1466: EB58 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1467: EB59 2C                     INC    L
1468: EB5A 2D                     DEC    L
1469: EB5B 2E 06                  LD     L,06                 ; zero flag, l=6
1470: EB5D         ; produce error 6, seek past physical eod
1471: EB5D C2 BE EB               JP     NZ,RandomSeekError
1472: EB60         ; otherwise, high byte = 0, A = sought record
1473: EB60 21 20 00               LD     HL,NEXT_RECORD
1474: EB63 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1475: EB64 77                     LD     (HL),A               ; sought rec# stored away
1476: EB65         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1477: EB65         ; the r/w flag is still stacked.  compare fcb values
1478: EB65 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1479: EB68 19                     ADD    HL,DE
1480: EB69 79                     LD     A,C                  ; A=seek ext#
1481: EB6A 96                     SUB    M
1482: EB6B C2 79 EB               JP     NZ,RandomSeekClose   ; tests for = extents
1483: EB6E         ; extents match, check mod#
1484: EB6E 21 0E 00               LD     HL,fcbS2Index
1485: EB71 19                     ADD    HL,DE
1486: EB72 78                     LD     A,B                  ; B=seek mod#
1487: EB73         ; could be overflow at eof, producing module#
1488: EB73         ; of 90H or 10H, so compare all but fwf
1489: EB73 96                     SUB    M
1490: EB74 E6 7F                  AND    7FH
1491: EB76 CA B1 EB               JP     Z,RandomSeekExit     ; same?
1492: EB79             RandomSeekClose:
1493: EB79 C5                     PUSH   BC
1494: EB7A D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1495: EB7B CD D1 F1               CALL   CloseDirEntry        ; current extent closed
1496: EB7E D1                     POP    DE
1497: EB7F C1                     POP    BC                   ; recall parameters and fill
1498: EB80 2E 03                  LD     L,03                 ; cannot close error #3
1499: EB82 3A C2 EA               LD     A,(exitParameterByte)
1500: EB85 3C                     INC    A
1501: EB86 CA B7 EB               JP     Z,RandomSeekErrorBadSeek
1502: EB89 21 0C 00               LD     HL,fcbExtIndex
1503: EB8C 19                     ADD    HL,DE
1504: EB8D 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1505: EB8E 21 0E 00               LD     HL,fcbS2Index
1506: EB91 19                     ADD    HL,DE
1507: EB92 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1508: EB93 CD 23 F3               CALL   OpenFile             ; is the file present?
1509: EB96 3A C2 EA               LD     A,(exitParameterByte)
1510: EB99 3C                     INC    A
1511: EB9A C2 B1 EB               JP     NZ,RandomSeekExit    ; open successful?
1512: EB9D         ; cannot open the file, read mode?
1513: EB9D C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1514: EB9E C5                     PUSH   BC                   ; everyone expects this item stacked
1515: EB9F 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1516: EBA1 0C                     INC    C                    ; becomes 00 if read operation
1517: EBA2 CA B7 EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1518: EBA5 CD 79 F1               CALL   MakeNewFile          ; write operation, make new extent
1519: EBA8 2E 05                  LD     L,05                 ; cannot create new extent #5
1520: EBAA 3A C2 EA               LD     A,(exitParameterByte)
1521: EBAD 3C                     INC    A
1522: EBAE CA B7 EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1523: EBB1         ; file make operation successful
1524: EBB1             RandomSeekExit:                      ; seekok:
1525: EBB1 C1                     POP    BC                   ; discard r/w flag
1526: EBB2 AF                     XOR    A
1527: EBB3 32 C2 EA               LD     (exitParameterByte),A
1528: EBB6 C9                     RET                         ; with zero set
1529: EBB7
1530: EBB7             RandomSeekErrorBadSeek:
1531: EBB7         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1532: EBB7         ; appears as overflow with file write flag set
1533: EBB7 E5                     PUSH   HL                   ; save error flag
1534: EBB8 CD ED F2               CALL   GetModuleNum         ; HL = .fcbS2Index
1535: EBBB 36 C0                  LD     (HL),11000000B
1536: EBBD E1                     POP    HL                   ; and drop through
1537: EBBE             RandomSeekError:                      ; seekerr:
1538: EBBE C1                     POP    BC                   ; discard r/w flag
1539: EBBF 7D                     LD     A,L
1540: EBC0 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1541: EBC3         ; SetFileWriteFlag returns non-zero accumulator for err
1542: EBC3 C3 EE F3               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1543: EBC6         ;ret
1544: EBC6         ;
1545: EBC6         ;*****************************************************************
1546: EBC6             SetRandomRecord:                      ; setrandom
1547: EBC6 2A C0 EA               LD     HL,(paramDE)
1548: EBC9 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1549: EBCC CD 15 EC               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1550: EBCF 21 21 00               LD     HL,RANDOM_REC_FIELD
1551: EBD2 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1552: EBD3 71                     LD     (HL),C
1553: EBD4 23                     INC    HL
1554: EBD5 70                     LD     (HL),B
1555: EBD6 23                     INC    HL
1556: EBD7 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1557: EBD8 C9                     RET
1558: EBD9         ;*****************************************************************
1559: EBD9         ;compute logical file size for current fcb
1560: EBD9             GetFileSize:                      ; getfilesize
1561: EBD9 0E 0C                  LD     C,fcbExtIndex
1562: EBDB CD 66 F3               CALL   Search4DirElement
1563: EBDE         ; zero the receiving Ramdom record field
1564: EBDE 2A C0 EA               LD     HL,(paramDE)
1565: EBE1 11 21 00               LD     DE,RANDOM_REC_FIELD
1566: EBE4 19                     ADD    HL,DE
1567: EBE5 E5                     PUSH   HL                   ; save position
1568: EBE6 72                     LD     (HL),D
1569: EBE7 23                     INC    HL
1570: EBE8 72                     LD     (HL),D
1571: EBE9 23                     INC    HL
1572: EBEA 72                     LD     (HL),D               ; =00 00 00
1573: EBEB             GetFileSize1:                      ; getsize:
1574: EBEB CD 84 EE               CALL   EndOfDirectory
1575: EBEE CA 13 EC               JP     Z,GetFileSizeExit
1576: EBF1         ; current fcb addressed by dptr
1577: EBF1 CD 3F EE               CALL   GetDirElementAddress
1578: EBF4 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1579: EBF7 CD 15 EC               CALL   GetRandomRecordPosition
1580: EBFA         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1581: EBFA E1                     POP    HL
1582: EBFB E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1583: EBFC 5F                     LD     E,A                  ; save cy
1584: EBFD 79                     LD     A,C
1585: EBFE 96                     SUB    M
1586: EBFF 23                     INC    HL                   ; ls byte
1587: EC00 78                     LD     A,B
1588: EC01 9E                     SBC    A,(HL)
1589: EC02 23                     INC    HL                   ; middle byte
1590: EC03 7B                     LD     A,E
1591: EC04 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1592: EC05 DA 0D EC               JP     C,GetFileSize2       ; for another try
1593: EC08         ; fcb is less or equal, fill from directory
1594: EC08 73                     LD     (HL),E
1595: EC09 2B                     DEC    HL
1596: EC0A 70                     LD     (HL),B
1597: EC0B 2B                     DEC    HL
1598: EC0C 71                     LD     (HL),C
1599: EC0D             GetFileSize2:                      ; getnextsize:
1600: EC0D CD 7E F3               CALL   Search4NextDirElement
1601: EC10 C3 EB EB               JP     GetFileSize1
1602: EC13             GetFileSizeExit:                      ; setsize:
1603: EC13 E1                     POP    HL                   ; discard .fcb(random record field)
1604: EC14 C9                     RET
1605: EC15         ;-----------------------------------------------------------------
1606: EC15         ;compute random record position
1607: EC15             GetRandomRecordPosition:                      ; compute$rr
1608: EC15 EB                     EX     DE,HL
1609: EC16 19                     ADD    HL,DE
1610: EC17         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1611: EC17 4E                     LD     C,(HL)
1612: EC18 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1613: EC1A 21 0C 00               LD     HL,fcbExtIndex
1614: EC1D 19                     ADD    HL,DE
1615: EC1E 7E                     LD     A,(HL)
1616: EC1F 0F                     RRCA
1617: EC20 E6 80                  AND    80H                  ; A=e000 0000
1618: EC22 81                     ADD    A,C
1619: EC23 4F                     LD     C,A
1620: EC24 3E 00                  LD     A,0
1621: EC26 88                     ADC    A,B
1622: EC27 47                     LD     B,A
1623: EC28         ; BC = 0000 000? errrr rrrr
1624: EC28 7E                     LD     A,(HL)
1625: EC29 0F                     RRCA
1626: EC2A E6 0F                  AND    LO_NIBBLE_MASK
1627: EC2C 80                     ADD    A,B
1628: EC2D 47                     LD     B,A
1629: EC2E         ; BC = 000? eeee errrr rrrr
1630: EC2E 21 0E 00               LD     HL,fcbS2Index
1631: EC31 19                     ADD    HL,DE
1632: EC32 7E                     LD     A,(HL)               ; A=XXX? mmmm
1633: EC33 87                     ADD    A,A
1634: EC34 87                     ADD    A,A
1635: EC35 87                     ADD    A,A
1636: EC36 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1637: EC37 F5                     PUSH   AF
1638: EC38 80                     ADD    A,B
1639: EC39 47                     LD     B,A
1640: EC3A         ; cy=?, BC = mmmm eeee errr rrrr
1641: EC3A F5                     PUSH   AF                   ; possible second carry
1642: EC3B E1                     POP    HL                   ; cy = lsb of L
1643: EC3C 7D                     LD     A,L                  ; cy = lsb of A
1644: EC3D E1                     POP    HL                   ; cy = lsb of L
1645: EC3E B5                     OR     L                    ; cy/cy = lsb of A
1646: EC3F E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1647: EC41 C9                     RET
1648: EC42         ;-----------------------------------------------------------------
1649: EC42
1650: EC42
1651: EC42
1652: EC42         ;*****************************************************************
1653: EC42         ;********************** Disk  I/O ********************************
1654: EC42         ;*****************************************************************
1655: EC42         ;-----------------------------------------------------------------
1656: EC42         ;;write protect current disk
1657: EC42             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1658: EC42 C3 CE ED               JP     SetDiskReadOnly
1659: EC45         ;-----------------------------------------------------------------
1660: EC45         ;;set file Attributes
1661: EC45             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1662: EC45 CD F6 F2               CALL   Reselect
1663: EC48 CD 51 EF               CALL   SetAttributes
1664: EC4B C3 E0 F2               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1665: EC4E         ;-----------------------------------------------------------------
1666: EC4E
1667: EC4E             SelectCurrent:                      ; curselect
1668: EC4E 3A BF EA               LD     A,(paramE)
1669: EC51 21 56 F5               LD     HL,currentDisk
1670: EC54 BE                     CP     M
1671: EC55 C8                     RET    Z                    ; exit if parame = Current disk
1672: EC56 77                     LD     (HL),A
1673: EC57 C3 5A EC               JP     Select
1674: EC5A         ;*****************************************************************
1675: EC5A         ;--------------------------- Select Login Drive -----------------------------;
1676: EC5A         ; select Login Drive                                                        ;
1677: EC5A             Select:                         ;
1678: EC5A CD 7B EC               CALL   SelectDisk           ; Select the Disk                    ;
1679: EC5D CC C5 F4               CALL   Z,errSelect          ;
1680: EC60 21 56 F5               LD     HL,currentDisk       ;
1681: EC63 46                     LD     B,(HL)               ; Get Current Disk                   ;
1682: EC64 2A 5A F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP               ;
1683: EC67 CD 97 F4               CALL   IsBitSet             ;
1684: EC6A C0                     RET    NZ                   ; Exit if already logged in          ;
1685: EC6B         ;                                                                            ;
1686: EC6B 21 56 F5               LD     HL,currentDisk       ;
1687: EC6E 46                     LD     B,(HL)               ; Get Current Disk                   ;
1688: EC6F 2A 5A F5               LD     HL,(loggedDisks)     ; else log in a different disk	     ;
1689: EC72 CD A7 F4               CALL   SetVectorBit         ;
1690: EC75 22 5A F5               LD     (loggedDisks),HL     ; Update the Vector                     ;
1691: EC78         ;
1692: EC78 C3 C1 EC               JP     InitDisk             ;
1693: EC7B         ;--------------------------- Select Login Drive -----------------------------;
1694: EC7B
1695: EC7B         ;--------------------------- Select Disk ------------------------------------;
1696: EC7B         ;*****************************************************************          ;
1697: EC7B         ; select the disk drive given by currentDisk, and fill the base addresses   ;
1698: EC7B         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
1699: EC7B             SelectDisk:                      ;
1700: EC7B 3A 56 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
1701: EC7E 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
1702: EC7F CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
1703: EC82 7C                     LD     A,H                  ; Return Pointer to                  ;
1704: EC83 B5                     OR     L                    ;  Disk Parameter Header             ;
1705: EC84 C8                     RET    Z                    ; exit if error, with HL = 0000      ;
1706: EC85         ;
1707: EC85 5E                     LD     E,(HL)               ;
1708: EC86 23                     INC    HL                   ;
1709: EC87 56                     LD     D,(HL)               ; Skew Table in DE                   ;
1710: EC88 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
1711: EC89 ED 53 7B F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
1712: EC8D         ;
1713: EC8D 22 5E F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
1714: EC90 23                     INC    HL                   ;
1715: EC91 23                     INC    HL                   ; HL = Last Track #                  ;
1716: EC92 22 60 F5               LD     (caTrack),HL         ; Move to Current Track #            ;
1717: EC95 23                     INC    HL                   ;
1718: EC96 23                     INC    HL                   ; HL = Last Sector #                 ;
1719: EC97 22 62 F5               LD     (caSector),HL        ; Move to Current Sector #           ;
1720: EC9A 23                     INC    HL                   ;
1721: EC9B 23                     INC    HL                   ;
1722: EC9C 11 64 F5               LD     DE,caDirectoryDMA    ;
1723: EC9F 01 08 00               LD     BC,caListSize        ;
1724: ECA2 ED B0                  LDIR                        ;
1725: ECA4         ;
1726: ECA4         ; finish filling in address list                                             ;
1727: ECA4 2A 66 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
1728: ECA7 11 6C F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
1729: ECAA 01 0F 00               LD     BC,dpbSize           ;
1730: ECAD ED B0                  LDIR                        ; Move DPB to current                ;
1731: ECAF         ;
1732: ECAF         ; Determine if Byte or Word Allocation Table	                             ;
1733: ECAF 2A 71 F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
1734: ECB2 7C                     LD     A,H                  ; If  its 00 then < 255              ;
1735: ECB3 21 85 F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
1736: ECB6 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
1737: ECB8 B7                     OR     A                    ;  is the assumption confirmed ?     ;
1738: ECB9 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
1739: ECBB 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
1740: ECBD         ;
1741: ECBD         ; Set Sign, reset Carry and Zero to indicate success                         ;
1742: ECBD             SelectDisk1:                      ;
1743: ECBD 3E FF                  LD     A,TRUE               ;
1744: ECBF B7                     OR     A                    ;
1745: ECC0 C9                     RET                         ;
1746: ECC1         ;--------------------------- Select Disk ------------------------------------;
1747: ECC1         ;--------------------------- Initialize Disk --------------------------------;
1748: ECC1             InitDisk:
1749: ECC1 2A 71 F5               LD     HL,(dpbDSM)          ; Maximum allocation value
1750: ECC4 CD 70 EE               CALL   DivideHLby8          ; Length of Map
1751: ECC7 E5                     PUSH   HL                   ; Save Length
1752: ECC8 E5                     PUSH   HL                   ; Save for end of MAP
1753: ECC9 C1                     POP    BC                   ; BC = dpbDSM/8
1754: ECCA         ; Clear the Allocation Vector
1755: ECCA 2A 6A F5               LD     HL,(caAllocVector)   ; Allocation vector Start
1756: ECCD 36 00                  LD     (HL),0               ; Clear location
1757: ECCF ED 5B 6A F5               LD     DE,(caAllocVector)
1758: ECD3 13                     INC    DE                   ; Allocation vector Start + 1
1759: ECD4 ED B0                  LDIR                        ; Cascade 00 thru Map
1760: ECD6         ; Force bits at End of Map
1761: ECD6 EB                     EX     DE,HL                ; Put last Map byte into DE
1762: ECD7 E1                     POP    HL
1763: ECD8 23                     INC    HL
1764: ECD9 CD 7A EE               CALL   MultiplyHLby8        ; Blocks if all bits used
1765: ECDC ED 4B 71 F5               LD     BC,(dpbDSM)          ; Actual block max
1766: ECE0 03                     INC    BC                   ; Now has size of the Map
1767: ECE1 AF                     XOR    A                    ; Clear CY
1768: ECE2 ED 42                  SBC    HL,BC                ; Extra unused bits
1769: ECE4 BD                     CP     L                    ;  are there any
1770: ECE5 28 07                  JR     Z,Mark4Directory
1771: ECE7 45                     LD     B,L                  ; Number of bits to set
1772: ECE8 EB                     EX     DE,HL                ; Put last Map byte into HL
1773: ECE9             SetBitLoop:
1774: ECE9 37                     SCF
1775: ECEA CB 16                  RL     (HL)                 ; Set LSB
1776: ECEC 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits
1777: ECEE
1778: ECEE             Mark4Directory:
1779: ECEE         ; Mark the reserved space for the directory
1780: ECEE 2A 75 F5               LD     HL,(dpbDABM)         ; Directory block reserved bits
1781: ECF1 EB                     EX     DE,HL
1782: ECF2 2A 6A F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector
1783: ECF5 73                     LD     (HL),E
1784: ECF6 23                     INC    HL
1785: ECF7 72                     LD     (HL),D               ; Put reserved blocks in Vector
1786: ECF8         ;---------------------------------
1787: ECF8         ; end of Map
1788: ECF8
1789: ECF8         ;---------------------------------
1790: ECF8         ; Home disk, and set current track and sector to 00
1791: ECF8 CD 9E ED               CALL   Home
1792: ECFB 2A 5E F5               LD     HL,(caDirMaxValue)
1793: ECFE 36 03                  LD     (HL),3
1794: ED00 23                     INC    HL
1795: ED01 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003
1796: ED03 CD 38 EE               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)
1797: ED06
1798: ED06             InitDisk1:
1799: ED06         ; Process the directory
1800: ED06 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum
1801: ED08 CD 96 EE               CALL   ReadDirectory        ; Get the directory Record
1802: ED0B CD 84 EE               CALL   EndOfDirectory       ; Are we Done ?
1803: ED0E C8                     RET    Z                    ;  Exit if Yes
1804: ED0F         ; Not end of directory, valid entry?
1805: ED0F CD 3F EE               CALL   GetDirElementAddress ; Calculate location of the element
1806: ED12 3E E5                  LD     A,emptyDir
1807: ED14 BE                     CP     M                    ; Is it an Empty Dir Entry
1808: ED15 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes
1809: ED17         ; Not emptyDir, user code the same?
1810: ED17 3A 55 F5               LD     A,(currentUserNumber)
1811: ED1A BE                     CP     M
1812: ED1B 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users
1813: ED1D         ; Same user, check for '$' submit
1814: ED1D 23                     INC    HL
1815: ED1E 7E                     LD     A,(HL)
1816: ED1F D6 24                  SUB    DOLLAR               ; Is first Char a $
1817: ED21 20 04                  JR     NZ,InitDisk2
1818: ED23         ; dollar file found, mark in exitParameterByte
1819: ED23 3D                     DEC    A                    ; Set A to FFH
1820: ED24 32 C2 EA               LD     (exitParameterByte),A ; Return it the exit parameter
1821: ED27             InitDisk2:
1822: ED27         ; now scan the disk map for allocated blocks
1823: ED27 0E FF                  LD     C,TRUE               ; set to allocated
1824: ED29 CD 44 ED               CALL   ScanDiskMap
1825: ED2C CD 4D EE               CALL   SetDirectoryEntry    ; set DirMaxVAlue to dirEntryIndex
1826: ED2F 18 D5                  JR     InitDisk1            ; for another entry
1827: ED31         ;--------------------------- Initialize Disk --------------------------------;
1828: ED31         ;---------------
1829: ED31         ; set a "1" value in currentDisk position of BC
1830: ED31         ; return in HL
1831: ED31             SetCurrentDiskBit:
1832: ED31 C5                     PUSH   BC                   ; save input parameter
1833: ED32 3A 56 F5               LD     A,(currentDisk)
1834: ED35 4F                     LD     C,A                  ; ready parameter for shift
1835: ED36 21 01 00               LD     HL,1                 ; number to shift
1836: ED39 CD 86 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1837: ED3C C1                     POP    BC                   ; original mask
1838: ED3D 79                     LD     A,C
1839: ED3E B5                     OR     L
1840: ED3F 6F                     LD     L,A
1841: ED40 78                     LD     A,B
1842: ED41 B4                     OR     H
1843: ED42 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1844: ED43 C9                     RET
1845: ED44         ;--------------
1846: ED44
1847: ED44         ;--------------------------- Scan Disk Map ----------------------------------;
1848: ED44
1849: ED44         ;--------------------------- Scan Disk Map ----------------------------------;
1850: ED44         ;-------------Scan the disk map for unallocated entry-----------------------------------
1851: ED44         ; scan the disk map addressed by dptr for non-zero entries.  The allocation
1852: ED44         ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
1853: ED44             ScanDiskMap:
1854: ED44 C5                     PUSH   BC                   ; Save the Set/Reset Info
1855: ED45 CD 3F EE               CALL   GetDirElementAddress ; HL points at the directory record
1856: ED48 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map
1857: ED4B 19                     ADD    HL,DE                ; HL is now at start of the MAP
1858: ED4C 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1
1859: ED4E
1860: ED4E
1861: ED4E             ScanDiskMap0:
1862: ED4E D1                     POP    DE                   ; Recall the set/reset Info
1863: ED4F 0D                     DEC    C
1864: ED50 C8                     RET    Z                    ; Loop once for each disk map entry
1865: ED51
1866: ED51 D5                     PUSH   DE                   ; Save the Set/Reset Info
1867: ED52 3A 85 F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized
1868: ED55 B7                     OR     A
1869: ED56 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized
1870: ED58         ;  Byte Allocation scan operation
1871: ED58 C5                     PUSH   BC                   ; Save counter
1872: ED59 E5                     PUSH   HL                   ; Save map address
1873: ED5A 4E                     LD     C,(HL)
1874: ED5B 06 00                  LD     B,0                  ; BC=block# for Byte
1875: ED5D 18 06                  JR     ScanDiskMap2
1876: ED5F         ; Word scan operation
1877: ED5F             ScanDiskMapWord:
1878: ED5F 0D                     DEC    C                    ; Adjust counter for 2 bytes
1879: ED60 C5                     PUSH   BC                   ; Save counter
1880: ED61 46                     LD     B,(HL)
1881: ED62 23                     INC    HL
1882: ED63 4E                     LD     C,(HL)               ; BC=block# for Word
1883: ED64 E5                     PUSH   HL                   ; Save map address
1884: ED65
1885: ED65         ; Arrive here with BC=block#, E=0/1
1886: ED65             ScanDiskMap2:
1887: ED65 79                     LD     A,C
1888: ED66 B0                     OR     B                    ; Skip if = 0000 (No Block)
1889: ED67 C4 12 EE               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C
1890: ED6A E1                     POP    HL
1891: ED6B 23                     INC    HL                   ; to next bit position
1892: ED6C C1                     POP    BC                   ; recall counter
1893: ED6D C3 4E ED               JP     ScanDiskMap0         ; for another item
1894: ED70
1895: ED70         ;--------------------------- Scan Disk Map ----------------------------------;
1896: ED70
1897: ED70         ;-----------------------------------
1898: ED70         ;given allocation vector position BC, return with byte
1899: ED70         ;containing BC shifted so that the least significant
1900: ED70         ;bit is in the low order accumulator position.  HL is
1901: ED70         ;the address of the byte for possible replacement in
1902: ED70         ;memory upon return, and D contains the number of shifts
1903: ED70         ;required to place the returned value back into position
1904: ED70
1905: ED70             GetAllocBit:                      ; getallocbit
1906: ED70 79                     LD     A,C
1907: ED71 E6 07                  AND    111b
1908: ED73 3C                     INC    A
1909: ED74 5F                     LD     E,A
1910: ED75 57                     LD     D,A
1911: ED76         ; d and e both contain the number of bit positions to shift
1912: ED76 79                     LD     A,C
1913: ED77 0F                     RRCA
1914: ED78 0F                     RRCA
1915: ED79 0F                     RRCA
1916: ED7A E6 1F                  AND    11111b
1917: ED7C 4F                     LD     C,A                  ; C shr 3 to C
1918: ED7D 78                     LD     A,B
1919: ED7E 87                     ADD    A,A
1920: ED7F 87                     ADD    A,A
1921: ED80 87                     ADD    A,A
1922: ED81 87                     ADD    A,A
1923: ED82 87                     ADD    A,A                  ; B shl 5
1924: ED83 B1                     OR     C
1925: ED84 4F                     LD     C,A                  ; bbbccccc to C
1926: ED85 78                     LD     A,B
1927: ED86 0F                     RRCA
1928: ED87 0F                     RRCA
1929: ED88 0F                     RRCA
1930: ED89 E6 1F                  AND    11111b
1931: ED8B 47                     LD     B,A                  ; BC shr 3 to BC
1932: ED8C 2A 6A F5               LD     HL,(caAllocVector)   ; base address of allocation vector
1933: ED8F 09                     ADD    HL,BC
1934: ED90 7E                     LD     A,(HL)               ; byte to A, hl = .alloc(BC shr 3)
1935: ED91         ;now move the bit to the low order position of A
1936: ED91             GetAllocBitl:
1937: ED91 07                     RLCA
1938: ED92 1D                     DEC    E
1939: ED93 C2 91 ED               JP     NZ,GetAllocBitl
1940: ED96 C9                     RET
1941: ED97
1942: ED97
1943: ED97         ;-----------------------------------
1944: ED97         ; byte value from ALLOC is in register A, with shift count
1945: ED97         ; in register C (to place bit back into position), and
1946: ED97         ; target ALLOC position in registers HL, rotate and replace
1947: ED97             RotateAndReplace:
1948: ED97 0F                     RRCA
1949: ED98 15                     DEC    D
1950: ED99 C2 97 ED               JP     NZ,RotateAndReplace  ; back into position
1951: ED9C 77                     LD     (HL),A               ; back to ALLOC
1952: ED9D C9                     RET
1953: ED9E         ;-----------------------------------
1954: ED9E         ;--------------------------- Home The Current Disk -------------------------;
1955: ED9E         ;move to home position, then offset to start of dir                         ;
1956: ED9E             Home:                           ;
1957: ED9E CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks       ;
1958: EDA1         ; if Buffer needs to be written     ;
1959: EDA1 21 79 F5               LD     HL,dpbOFF            ; Number of tracks before directory ;
1960: EDA4 4E                     LD     C,(HL)               ;
1961: EDA5 23                     INC    HL                   ;
1962: EDA6 46                     LD     B,(HL)               ;
1963: EDA7 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position   ;
1964: EDAA         ;
1965: EDAA         ; Set Current Track and Sector to 00                                        ;
1966: EDAA AF                     XOR    A                    ; set ACC to 00                     ;
1967: EDAB 2A 60 F5               LD     HL,(caTrack)         ;
1968: EDAE 77                     LD     (HL),A               ;
1969: EDAF 23                     INC    HL                   ;
1970: EDB0 77                     LD     (HL),A               ;
1971: EDB1 2A 62 F5               LD     HL,(caSector)        ;
1972: EDB4 77                     LD     (HL),A               ;
1973: EDB5 23                     INC    HL                   ;
1974: EDB6 77                     LD     (HL),A               ;
1975: EDB7 C9                     RET                         ;
1976: EDB8         ;
1977: EDB8         ;--------------------------- Home The Current Disk -------------------------;
1978: EDB8
1979: EDB8         ;*****************************************************************
1980: EDB8
1981: EDB8         ;*****************************************************************
1982: EDB8         ;=========================== Disk Utilities ================================;
1983: EDB8         ;--------------------------- Set DMAs -------------------------------------;
1984: EDB8             SetDataDMA:                      ;
1985: EDB8 21 5C F5               LD     HL,initDAMAddress    ;
1986: EDBB 18 03                  JR     SetDMA               ; Skip to complete the call        ;
1987: EDBD         ;	LD		BC,initDAMAddress                                              ;
1988: EDBD         ;	JP		bcSetdma					; Call BIOS to set                 ;
1989: EDBD         ;
1990: EDBD             SetDirDMA:                      ;
1991: EDBD 21 64 F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
1992: EDC0         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
1993: EDC0         ;	JP		bcSetdma					; Call BIOS to set                 ;
1994: EDC0         ;
1995: EDC0             SetDMA:                         ;
1996: EDC0 4E                     LD     C,(HL)               ;
1997: EDC1 23                     INC    HL                   ;
1998: EDC2 46                     LD     B,(HL)               ; parameter ready              ;
1999: EDC3 C3 24 F6               JP     bcSetdma             ; call bios to set             ;
2000: EDC6         ;--------------------------- Set DMAs -------------------------------------;
2001: EDC6         ;--------------------------- Read Buffer ----------------------------------;
2002: EDC6         ;reads into current DMA, using current Disk,Track and Sector               ;
2003: EDC6             ReadBuffer:                      ;
2004: EDC6 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
2005: EDC9 B7                     OR     A                    ; Check status                     ;
2006: EDCA C2 EA F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2007: EDCD C9                     RET                         ;
2008: EDCE         ;--------------------------- Read Buffer ----------------------------------;
2009: EDCE
2010: EDCE         ;--------------------------- Set Current Disk Read Only --------------------;
2011: EDCE         ;set current disk to read only                                              ;
2012: EDCE             SetDiskReadOnly:                      ;
2013: EDCE 2A 58 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2014: EDD1         ;
2015: EDD1 3A 56 F5               LD     A,(currentDisk)      ; Get the current disk              ;
2016: EDD4 47                     LD     B,A                  ; Move into B                       ;
2017: EDD5 CD A7 F4               CALL   SetVectorBit         ; Set the bit                       ;
2018: EDD8 22 58 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2019: EDDB         ;
2020: EDDB 2A 73 F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2021: EDDE EB                     EX     DE,HL                ;
2022: EDDF 2A 5E F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2023: EDE2 73                     LD     (HL),E               ;
2024: EDE3 23                     INC    HL                   ;
2025: EDE4 72                     LD     (HL),D               ;
2026: EDE5 C9                     RET                         ;
2027: EDE6         ;--------------------------- Set disk Read Only ----------------------------;
2028: EDE6
2029: EDE6
2030: EDE6         ;=========================== Disk Utilities ================================;
2031: EDE6
2032: EDE6         ;=========================== File Utilities ================================;
2033: EDE6         ;--------------------------- Set Record Variables -------------------------;
2034: EDE6         ;set variables from currently FCB - Current Record, RC, EXM                ;
2035: EDE6             SetRecordVars:                      ;
2036: EDE6 CD FD ED               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2037: EDE9         ;  and HL => .CurrentRecord        ;
2038: EDE9 7E                     LD     A,(HL)               ;
2039: EDEA 32 8B F5               LD     (currentFileRecord),A ; Save current record              ;
2040: EDED EB                     EX     DE,HL                ;
2041: EDEE 7E                     LD     A,(HL)               ;
2042: EDEF 32 89 F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2043: EDF2 CD 0A EE               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2044: EDF5 3A 70 F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2045: EDF8 A6                     AND    M                    ; Remove unwanted bits             ;
2046: EDF9 32 8A F5               LD     (extentValue),A      ; Store the value                  ;
2047: EDFC C9                     RET                         ;
2048: EDFD         ;--------------------------- Set Record Variables -------------------------;
2049: EDFD         ;----------------------Get File Record Count and Current Record------------;
2050: EDFD         ; returns with DE pointing at RC from FCB                                  ;
2051: EDFD         ;         with HL pointing at Current Record                               ;
2052: EDFD             GetFcbRecordDetails:                      ;
2053: EDFD 2A C0 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2054: EE00 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2055: EE03 19                     ADD    HL,DE                ;
2056: EE04 EB                     EX     DE,HL                ; DE Points to Record Count        ;
2057: EE05 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;
2058: EE08 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2059: EE09 C9                     RET                         ;
2060: EE0A         ;----------------------Get File Record Count and Current Record------------;
2061: EE0A         ;----------------------Get FileExtent--------------------------------------;
2062: EE0A         ;get current extent field address to (HL)                                 ;
2063: EE0A             GetExtentAddress:                      ;
2064: EE0A 2A C0 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2065: EE0D 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2066: EE10 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2067: EE11 C9                     RET                         ;
2068: EE12         ;----------------------Get FileExtent--------------------------------------;
2069: EE12         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2070: EE12         ; At Entry:	BC Contains to the Block to be modified                        ;
2071: EE12         ;			E  = TRUE if bit is to be set                                  ;
2072: EE12         ;			E  <> TRUE if bit is to be reset                               ;
2073: EE12         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2074: EE12             SetResetMapBit:                      ;
2075: EE12         ;
2076: EE12 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2077: EE15 09                     ADD    HL,BC                ;  to HL                           ;
2078: EE16 4B                     LD     C,E                  ; Move the flag to E               ;
2079: EE17         ;
2080: EE17 7D                     LD     A,L                  ; LSB of the Block Number          ;
2081: EE18 E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2082: EE1A F5                     PUSH   AF                   ; Save the OctetBit                ;
2083: EE1B 06 03                  LD     B,3                  ;
2084: EE1D CD 72 EE               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2085: EE20 ED 5B 6A F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2086: EE24 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2087: EE25 F1                     POP    AF                   ;
2088: EE26 47                     LD     B,A                  ; Get the bit                      ;
2089: EE27         ;
2090: EE27 04                     INC    B                    ; Adjust for looping               ;
2091: EE28 C5                     PUSH   BC                   ; Will need this later             ;
2092: EE29             Left:                           ;
2093: EE29 CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2094: EE2B 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2095: EE2D C1                     POP    BC                   ; Restore loop limit and           ;
2096: EE2E 37                     SCF                         ;  set/reset flag                  ;
2097: EE2F 0C                     INC    C                    ; was C = TRUE                     ;
2098: EE30 28 01                  JR     Z,Right              ; Skip if Set                      ;
2099: EE32 3F                     CCF                         ; Set for Reset                    ;
2100: EE33             Right:                          ;
2101: EE33 CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2102: EE35 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2103: EE37 C9                     RET                         ;
2104: EE38         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2105: EE38
2106: EE38         ;=========================== File Utilities ================================;
2107: EE38
2108: EE38         ;=========================== Directory Utilities ===========================;
2109: EE38         ;--------------------------- Set End of Directory indicator ----------------;
2110: EE38             SetEndDirectory:                      ;
2111: EE38 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
2112: EE3B 22 90 F5               LD     (dirEntryIndex),HL   ;
2113: EE3E C9                     RET                         ;
2114: EE3F         ;--------------------------- Set End of Directory indicator ----------------;
2115: EE3F         ;--------------------------- Get Directory Element -------------------------;
2116: EE3F         ; compute the address of a directory element in Directory Buffer            ;
2117: EE3F         ; Returns:  HL = Address of the specific directory Record                   ;
2118: EE3F             GetDirElementAddress:                      ;
2119: EE3F         ;	PUSH	BC							; Save BC
2120: EE3F         ;	LD		BC,(dirBlockIndex)
2121: EE3F         ;	LD		HL,(caDirectoryDMA)			; Get the Directory Buffer base     ;
2122: EE3F         ;	ADD		HL,BC
2123: EE3F         ;	POP		BC							; Restore
2124: EE3F
2125: EE3F C5                     PUSH   BC                   ; Save BC
2126: EE40 2A 64 F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
2127: EE43 3A 8F F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
2128: EE46 4F                     LD     C,A                  ;
2129: EE47 AF                     XOR    A                    ; Set to Zero and reset CY          ;
2130: EE48 47                     LD     B,A                  ;
2131: EE49 ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
2132: EE4B C1                     POP    BC                   ; Restore
2133: EE4C C9                     RET                         ;
2134: EE4D         ;--------------------------- Get Directory Element -------------------------;
2135: EE4D         ;--------------------------- Set Directory Entry ---------------------------;
2136: EE4D         ; Will update directory if not in the directory                             ;
2137: EE4D         ;
2138: EE4D             SetDirectoryEntry:                      ;
2139: EE4D CD 56 EE               CALL   StillInDirectory     ;
2140: EE50 D8                     RET    C                    ; Exit if still in the Directory  	;
2141: EE51         ;
2142: EE51         ; StillInDirectory will return with:                                        ;
2143: EE51         ;									DE = Directory entry number             ;
2144: EE51         ;									HL = Address of entry number + 1        ;
2145: EE51 13                     INC    DE                   ;
2146: EE52 72                     LD     (HL),D               ;
2147: EE53 2B                     DEC    HL                   ;
2148: EE54 73                     LD     (HL),E               ;
2149: EE55 C9                     RET                         ;
2150: EE56         ;--------------------------- Set Directory Entry ---------------------------;
2151: EE56
2152: EE56         ;--------------------------- Are we sill in the Directory ------------------;
2153: EE56         ;Returns	:                                                               ;
2154: EE56         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
2155: EE56         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
2156: EE56         ;			HL = (address of Index Value) + 1                               ;
2157: EE56         ;			DE = Directory Index Value                                      ;
2158: EE56             StillInDirectory:                      ;
2159: EE56 2A 90 F5               LD     HL,(dirEntryIndex)   ;
2160: EE59 EB                     EX     DE,HL                ; DE = directory counter            ;
2161: EE5A 2A 5E F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
2162: EE5D 7B                     LD     A,E                  ;
2163: EE5E 96                     SUB    M                    ;
2164: EE5F 23                     INC    HL                   ;
2165: EE60 7A                     LD     A,D                  ;
2166: EE61 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
2167: EE62 C9                     RET                         ;  <= Directory Max Value       ;
2168: EE63         ;--------------------------- Are we sill in the Directory ------------------;
2169: EE63
2170: EE63         ;=========================== Directory Utilities ===========================;
2171: EE63
2172: EE63         ;=========================== General   Utilities ===========================;
2173: EE63         ;--------------------------- Rotate HL right by value in C ----------------;
2174: EE63         ;
2175: EE63         ; HL = Value to be rotated Right                                           ;
2176: EE63         ;  B = Amount to shift                                                     ;
2177: EE63             RotateRightHLbyB:                      ;
2178: EE63 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
2179: EE64 CB 45                  BIT    0,L                  ; is LSB set?                      ;
2180: EE66 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
2181: EE68 3F                     CCF                         ; else Clear Carry flag            ;
2182: EE69             RotateRightHLbyB1:                      ;
2183: EE69 CB 1C                  RR     H                    ; Shift thru CY                    ;
2184: EE6B CB 1D                  RR     L                    ; ditto                            ;
2185: EE6D 10 F4                  DJNZ   RotateRightHLbyB     ;
2186: EE6F C9                     RET                         ;
2187: EE70         ;
2188: EE70         ;--------------------------- Rotate HL right by value in C ----------------;
2189: EE70         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2190: EE70         ; HL = Value to be shifted Right                                           ;
2191: EE70             DivideHLby8:                      ;
2192: EE70 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2193: EE72         ;  B = Amount to shift                                                     ;
2194: EE72             ShiftRightHLbyB:                      ;
2195: EE72 AF                     XOR    A                    ; else Clear Carry flag            ;
2196: EE73 CB 1C                  RR     H                    ; Shift thru CY                    ;
2197: EE75 CB 1D                  RR     L                    ; ditto                            ;
2198: EE77 10 F9                  DJNZ   ShiftRightHLbyB      ;
2199: EE79 C9                     RET                         ;
2200: EE7A         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2201: EE7A         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2202: EE7A         ; HL = Value to be shifted Left                                            ;
2203: EE7A             MultiplyHLby8:                      ;
2204: EE7A 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2205: EE7C         ;  B = Amount to shift                                                     ;
2206: EE7C             ShiftLeftHLbyB:                      ;
2207: EE7C AF                     XOR    A                    ; else Clear Carry flag            ;
2208: EE7D CB 15                  RL     L                    ; Shift thru CY                    ;
2209: EE7F CB 14                  RL     H                    ; ditto                            ;
2210: EE81 10 F9                  DJNZ   ShiftLeftHLbyB       ;
2211: EE83 C9                     RET                         ;
2212: EE84         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2213: EE84
2214: EE84         ;=========================== General   Utilities ===========================;
2215: EE84
2216: EE84         ;---------------
2217: EE84         ;---------------
2218: EE84         ;---------------
2219: EE84         ; return zero flag if at end of directory
2220: EE84         ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
2221: EE84             EndOfDirectory:
2222: EE84 21 90 F5               LD     HL,dirEntryIndex
2223: EE87 7E                     LD     A,(HL)               ; may be 0ffh
2224: EE88 23                     INC    HL
2225: EE89 BE                     CP     M                    ; low(dirEntryIndex) = high(dirEntryIndex)?
2226: EE8A C0                     RET    NZ                   ; non zero returned if different
2227: EE8B         ; high and low the same, = 0ffh?
2228: EE8B 3C                     INC    A                    ; 0ffh becomes 00 if so
2229: EE8C C9                     RET
2230: EE8D         ;---------------
2231: EE8D         ;--------------------------- Read Directory Record -------------------------;
2232: EE8D         ; read a directory entry into the directory buffer                          ;
2233: EE8D             ReadDirRecord:                      ;
2234: EE8D CD BD ED               CALL   SetDirDMA            ; System Assigned Buffer            ;
2235: EE90 CD C6 ED               CALL   ReadBuffer           ; Go to BIOS for the read           ;
2236: EE93 C3 B8 ED               JP     SetDataDMA           ; Restore DMA                       ;
2237: EE96         ;--------------------------- Read Directory Record -------------------------;
2238: EE96
2239: EE96         ;--------------------------- Read Directory --------------------------------;
2240: EE96         ; Read next directory entry                                                 ;
2241: EE96         ; Enter :                                                                   ;
2242: EE96         ;		C =  TRUE initializing and setting CheckSum                         ;
2243: EE96         ;		  <> TRUE Checking existing CheckSum                                ;
2244: EE96             ReadDirectory:                      ;
2245: EE96 ED 5B 73 F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
2246: EE9A 2A 90 F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
2247: EE9D 23                     INC    HL                   ; Increment the Index               ;
2248: EE9E 22 90 F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
2249: EEA1 AF                     XOR    A                    ; Clear the CY flag                 ;
2250: EEA2 ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
2251: EEA4 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
2252: EEA6 CD 38 EE               CALL   SetEndDirectory      ;  else we are done                 ;
2253: EEA9 C9                     RET                         ;
2254: EEAA         ;
2255: EEAA         ; Calculate the entry index Position in Buffer                              ;
2256: EEAA             ReadDirectory0:                      ;
2257: EEAA 3A 90 F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
2258: EEAD E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
2259: EEAF 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
2260: EEB1             ReadDirectory1:                      ;
2261: EEB1 87                     ADD    A,A                  ;
2262: EEB2 10 FD                  DJNZ   ReadDirectory1       ;
2263: EEB4 32 8F F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
2264: EEB7 B7                     OR     A                    ; Is this the 1st entry?            ;
2265: EEB8 C0                     RET    NZ                   ;  return if not.                   ;
2266: EEB9         ;
2267: EEB9 C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
2268: EEBA CD C4 EE               CALL   SeekDir              ; Set up for Directory Read         ;
2269: EEBD CD 8D EE               CALL   ReadDirRecord        ; Read the directory record         ;
2270: EEC0 C1                     POP    BC                   ; Recall initialization flag        ;
2271: EEC1 C3 0F EF               JP     CheckSumUtility      ; Checksum the directory            ;
2272: EEC4         ;--------------------------- Read Directory --------------------------------;
2273: EEC4         ;--------------------------- Seek Directory --------------------------------;
2274: EEC4         ;seek the record containing the current directory entry					;
2275: EEC4             SeekDir:                        ;
2276: EEC4 2A 90 F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
2277: EEC7 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
2278: EEC9 CD 72 EE               CALL   ShiftRightHLbyB      ;
2279: EECC 22 8D F5               LD     (absoluteCPMRecord),HL ;
2280: EECF 22 92 F5               LD     (dirRecord),HL       ; Save                              ;
2281: EED2 C3 D5 EE               JP     Seek                 ;
2282: EED5         ;--------------------------- Seek Directory --------------------------------;
2283: EED5         ;--------------------------- Seek ------------------------------------------;
2284: EED5             Seek:                           ;
2285: EED5 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
2286: EED8 2A 8D F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
2287: EEDB ED 5B 6C F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
2288: EEDF         ;
2289: EEDF             Seek0:                          ;
2290: EEDF 03                     INC    BC                   ; Divide the record                 ;
2291: EEE0 AF                     XOR    A                    ;  by the sectors per track         ;
2292: EEE1 ED 52                  SBC    HL,DE                ;
2293: EEE3 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
2294: EEE5         ;
2295: EEE5         ;
2296: EEE5 19                     ADD    HL,DE                ; Gets the sector in the track      ;
2297: EEE6 E5                     PUSH   HL                   ; Save Index Sector                 ;
2298: EEE7         ;
2299: EEE7 DD 2A 60 F5               LD     IX,(caTrack)         ;
2300: EEEB DD 71 00               LD     (IX+0),C             ;
2301: EEEE DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
2302: EEF1         ;
2303: EEF1 EB                     EX     DE,HL                ; Take the index from the record    ;
2304: EEF2 2A 8D F5               LD     HL,(absoluteCPMRecord) ;
2305: EEF5 AF                     XOR    A                    ;
2306: EEF6 ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
2307: EEF8         ;
2308: EEF8 DD 2A 62 F5               LD     IX,(caSector)        ;
2309: EEFC DD 75 00               LD     (IX+0),L             ;
2310: EEFF DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
2311: EF02         ;
2312: EF02 2A 79 F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
2313: EF05 09                     ADD    HL,BC                ;  to add to the gross Track        ;
2314: EF06 E5                     PUSH   HL                   ;  which yields the net or          ;
2315: EF07 C1                     POP    BC                   ;  actual track for the record      ;
2316: EF08 CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
2317: EF0B         ;
2318: EF0B C1                     POP    BC                   ; Get the sector within the track   ;
2319: EF0C C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
2320: EF0F         ;
2321: EF0F         ;--------------------------- Seek ------------------------------------------;
2322: EF0F         ;--------------------------- Check Sum Utility -----------------------------;
2323: EF0F         ; At entry                                                                  ;
2324: EF0F         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
2325: EF0F         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
2326: EF0F         ;
2327: EF0F             CheckSumUtility:                      ;
2328: EF0F 2A 77 F5               LD     HL,(dpbCKS)          ;
2329: EF12 ED 5B 92 F5               LD     DE,(dirRecord)       ;
2330: EF16 AF                     XOR    A                    ;
2331: EF17 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
2332: EF19 D8                     RET    C                    ;  Entries                      ;
2333: EF1A         ;
2334: EF1A C5                     PUSH   BC                   ; Save New/Validate Flag        ;
2335: EF1B         ;
2336: EF1B         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
2337: EF1B             ComputeCheckSum:                      ;
2338: EF1B 06 80                  LD     B,cpmRecordSize      ;
2339: EF1D 2A 64 F5               LD     HL,(caDirectoryDMA)  ;
2340: EF20 EE 00                  XOR                         ;
2341: EF22             ComputeCheckSum1:                      ;
2342: EF22 86                     ADD    A,(HL)               ;
2343: EF23 23                     INC    HL                   ;
2344: EF24 10 FC                  DJNZ   ComputeCheckSum1     ;
2345: EF26         ; Checksum is in ACC	                                                    ;
2346: EF26         ;
2347: EF26 2A 68 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
2348: EF29 ED 5B 92 F5               LD     DE,(dirRecord)       ; Index to this record              ;
2349: EF2D 19                     ADD    HL,DE                ; Address of this record in vector  ;
2350: EF2E C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
2351: EF2F 0C                     INC    C                    ;
2352: EF30 CA 3D EF               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
2353: EF33         ;
2354: EF33 BE                     CP     M                    ; Else we are checking the value    ;
2355: EF34 C8                     RET    Z                    ; Exit if OK                        ;
2356: EF35         ; possible checksum error, are we beyond the end of the disk?               ;
2357: EF35 CD 56 EE               CALL   StillInDirectory     ;
2358: EF38 D0                     RET    NC                   ; OK, if not in the directory       ;
2359: EF39 CD CE ED               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
2360: EF3C C9                     RET                         ;  Set disk RO before returning     ;
2361: EF3D         ;
2362: EF3D         ;initializing the checksum                                                 ;
2363: EF3D             SetNewCheckSum:                      ;
2364: EF3D 77                     LD     (HL),A               ;
2365: EF3E C9                     RET                         ;
2366: EF3F         ;--------------------------- Check Sum Utility -----------------------------;
2367: EF3F
2368: EF3F
2369: EF3F         ;---------------------
2370: EF3F         ;update variables from I/O in  fcb
2371: EF3F             UpdateRecordVars:
2372: EF3F CD FD ED               CALL   GetFcbRecordDetails  ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2373: EF42 3A 80 F5               LD     A,(seqReadFlag)
2374: EF45 4F                     LD     C,A                  ; =1 if sequential i/o
2375: EF46 3A 8B F5               LD     A,(currentFileRecord) ; get NEXT_RECORD
2376: EF49 81                     ADD    A,C
2377: EF4A 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=current File Record+seqReadFlag
2378: EF4B EB                     EX     DE,HL
2379: EF4C 3A 89 F5               LD     A,(fcbRecordCount)
2380: EF4F 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2381: EF50 C9                     RET
2382: EF51         ;---------------------
2383: EF51         ;set file Attributes for current fcb
2384: EF51             SetAttributes:
2385: EF51 0E 0C                  LD     C,fcbExtIndex
2386: EF53 CD 66 F3               CALL   Search4DirElement    ; through file type
2387: EF56             SetAttributes1:
2388: EF56 CD 84 EE               CALL   EndOfDirectory
2389: EF59 C8                     RET    Z                    ; exit at end of dir
2390: EF5A 0E 00                  LD     C,0
2391: EF5C 1E 0C                  LD     E,fcbExtIndex        ;copy name
2392: EF5E CD 1F F4               CALL   CopyDir
2393: EF61 CD 7E F3               CALL   Search4NextDirElement
2394: EF64 C3 56 EF               JP     SetAttributes1
2395: EF67         ;
2396: EF67         ;*****************************************************************
2397: EF67
2398: EF67         ;*****************************************************************
2399: EF67         ;********************** File  Routines ***************************
2400: EF67         ;*****************************************************************
2401: EF67         ;open file
2402: EF67         ; IN  - (DE)	FCB Address
2403: EF67         ; OUT - (A)	Directory Code
2404: EF67         ;	0-3 = success ; 0FFH = File Not Found
2405: EF67             vOpenFile:                      ;
2406: EF67 CD E7 F2               CALL   ClearModuleNum       ; clear the module number
2407: EF6A CD F6 F2               CALL   Reselect             ; do we need to reselect disk?
2408: EF6D C3 23 F3               JP     OpenFile
2409: EF70         ;ret ;jmp goback
2410: EF70         ;-----------------------------------------------------------------
2411: EF70         ;close file
2412: EF70             vCloseFile:                      ; func16: (16 - 10) Close File
2413: EF70 CD F6 F2               CALL   Reselect
2414: EF73 C3 D1 F1               JP     CloseDirEntry
2415: EF76         ;-----------------------------------------------------------------
2416: EF76         ;search for first occurrence of a file
2417: EF76         ; In - (DE)	FCB Address
2418: EF76         ; OUT - (A)	Directory Code
2419: EF76         ;	0-3 = success ; 0FFH = File Not Found
2420: EF76             vFindFirst:                      ; func17: (17 - 11) Search for first
2421: EF76 0E 00                  LD     C,0                  ; length assuming '?' true
2422: EF78 2A C0 EA               LD     HL,(paramDE)
2423: EF7B 7E                     LD     A,(HL)
2424: EF7C FE 3F                  CP     QMARK                ; no reselect if ?
2425: EF7E CA 89 EF               JP     Z,QMarkSelect        ; skip reselect if so
2426: EF81
2427: EF81 CD E7 F2               CALL   ClearModuleNum       ; module number zeroed
2428: EF84 CD F6 F2               CALL   Reselect
2429: EF87 0E 0F                  LD     C,nameLength
2430: EF89             QMarkSelect:                      ; qselect:
2431: EF89 CD 66 F3               CALL   Search4DirElement
2432: EF8C C3 0C F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2433: EF8F         ;-----------------------------------------------------------------
2434: EF8F         ;search for next occurrence of a file name
2435: EF8F         ; OUT - (A)	Directory Code
2436: EF8F         ;	0-3 = success ; 0FFH = File Not Found
2437: EF8F             vFindNext:                      ; func18: (18 - 12) Search for next
2438: EF8F 2A 83 F5               LD     HL,(searchAddress)
2439: EF92 22 C0 EA               LD     (paramDE),HL
2440: EF95 CD F6 F2               CALL   Reselect
2441: EF98 CD 7E F3               CALL   Search4NextDirElement
2442: EF9B C3 0C F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2443: EF9E         ;-----------------------------------------------------------------
2444: EF9E         ;search for next occurrence of a file name
2445: EF9E         ; OUT - (A)	Directory Code
2446: EF9E         ;delete a file
2447: EF9E             vDeleteFile:                      ; func18: (19 - 13) Delete File
2448: EF9E CD F6 F2               CALL   Reselect
2449: EFA1 CD AF F1               CALL   DeleteFile
2450: EFA4 C3 E0 F2               JP     DirLocationToReturnLoc
2451: EFA7         ;-----------------------------------------------------------------
2452: EFA7         ;read sequential
2453: EFA7         ;IN  - (DE) FCB address
2454: EFA7         ;OUT - (A) 00 = success and data available. else no read and no data
2455: EFA7             vReadSeq:                       ; func20: (20 - 14) read sequential
2456: EFA7 CD F6 F2               CALL   Reselect
2457: EFAA CD E9 EF               CALL   ReadSeq
2458: EFAD C9                     RET
2459: EFAE         ;-----------------------------------------------------------------
2460: EFAE         ;write sequential
2461: EFAE         ;IN  - (DE) FCB address
2462: EFAE         ;OUT - (A) 00 = success and data available. else no read and no data
2463: EFAE             vWriteSeq:                      ; func21 (21 - 15) write sequention
2464: EFAE CD F6 F2               CALL   Reselect
2465: EFB1 CD 2C F0               CALL   DiskWriteSeq
2466: EFB4 C9                     RET
2467: EFB5         ;-----------------------------------------------------------------
2468: EFB5         ; Make file
2469: EFB5         ; In - (DE)	FCB Address
2470: EFB5         ; OUT - (A)	Directory Code
2471: EFB5         ;	0-3 = success ; 0FFH = File Not Found
2472: EFB5             vMakeFile:                      ; func22 (22 - 16) Make file
2473: EFB5 CD E7 F2               CALL   ClearModuleNum       ; set S2 to Zero
2474: EFB8 CD F6 F2               CALL   Reselect
2475: EFBB C3 79 F1               JP     MakeNewFile
2476: EFBE         ;-----------------------------------------------------------------
2477: EFBE         ; Rename file
2478: EFBE         ; In - (DE)	FCB Address
2479: EFBE         ; OUT - (A)	Directory Code
2480: EFBE         ;	0-3 = success ; 0FFH = File Not Found
2481: EFBE             vRenameFile:                      ; func23 (23 - 17) Rename File
2482: EFBE CD F6 F2               CALL   Reselect
2483: EFC1 CD 54 F1               CALL   Rename
2484: EFC4 C3 E0 F2               JP     DirLocationToReturnLoc
2485: EFC7         ;-----------------------------------------------------------------
2486: EFC7         ;-----------------------------------------------------------------
2487: EFC7         ;*****************************************************************
2488: EFC7         ;-----------------------------------------------------------------
2489: EFC7         ;check current directory element for read/only status
2490: EFC7             CheckRODirectory:
2491: EFC7 CD 3F EE               CALL   GetDirElementAddress ; address of element
2492: EFCA         ;	JMP	CheckROFile
2493: EFCA         ;------------
2494: EFCA         ;check current buff(dptr) or fcb(0) for r/o status
2495: EFCA             CheckROFile:
2496: EFCA 11 09 00               LD     DE,fcbROfileIndex
2497: EFCD 19                     ADD    HL,DE                ; offset to ro bit
2498: EFCE 7E                     LD     A,(HL)
2499: EFCF 17                     RLA
2500: EFD0 D0                     RET    NC                   ; return if not set
2501: EFD1 C3 D1 F4               JP     errReadOnlyFile      ; exit to read only disk message
2502: EFD4         ;-----------------------------------------------------------------
2503: EFD4         ;check for write protected disk
2504: EFD4             CheckWrite:
2505: EFD4 CD DB EF               CALL   IsDiskWriteProtected
2506: EFD7 C8                     RET    Z                    ; OK to write
2507: EFD8 C3 CB F4               JP     errReadOnlyDisk      ; read only disk error
2508: EFDB         ;-----------------------------------------------------------------
2509: EFDB         ;return 0 if OK to write (NO)
2510: EFDB             IsDiskWriteProtected:
2511: EFDB 2A 58 F5               LD     HL,(readOnlyVector)
2512: EFDE 3A 56 F5               LD     A,(currentDisk)
2513: EFE1 4F                     LD     C,A
2514: EFE2 CD 79 F4               CALL   ShiftRightHLbyC
2515: EFE5 7D                     LD     A,L
2516: EFE6 E6 1B                  AND    1BH                  ; 01BH
2517: EFE8 C9                     RET                         ; non zero if nowrite
2518: EFE9         ;-----------------------------------------------------------------
2519: EFE9         ;sequential disk read operation
2520: EFE9             ReadSeq:
2521: EFE9 3E 01                  LD     A,1
2522: EFEB 32 80 F5               LD     (seqReadFlag),A      ; set flag for seqential read
2523: EFEE         ;---
2524: EFEE         ; read the disk
2525: EFEE         ; read the next record from the current fcb
2526: EFEE             DiskRead:
2527: EFEE 3E FF                  LD     A,TRUE
2528: EFF0 32 7E F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
2529: EFF3
2530: EFF3 CD E6 ED               CALL   SetRecordVars        ; sets current File Record, fcbRecordCount and EXM
2531: EFF6 3A 8B F5               LD     A,(currentFileRecord)
2532: EFF9 21 89 F5               LD     HL,fcbRecordCount
2533: EFFC BE                     CP     M                    ; current File Record-fcbRecordCount
2534: EFFD         ; skip if  current File Record < fcbRecordCount
2535: EFFD DA 13 F0               JP     C,RecordOK
2536: F000         ; not enough records in the extent
2537: F000 FE 80                  CP     RecordsPerExtent     ; current File Record = 128?   *** Records in an Extent
2538: F002 C2 29 F0               JP     NZ,DiskEOF           ; skip if current File Record<>128
2539: F005 CD F1 F0               CALL   OpenNextExt          ; go to next extent if so
2540: F008 AF                     XOR    A
2541: F009 32 8B F5               LD     (currentFileRecord),A ; current File Record=00
2542: F00C         ; now check for open ok
2543: F00C 3A C2 EA               LD     A,(exitParameterByte)
2544: F00F B7                     OR     A
2545: F010 C2 29 F0               JP     NZ,DiskEOF
2546: F013         ; stop at eof
2547: F013         ; arrive with fcb addressing a record to read
2548: F013             RecordOK:                       ; recordok:
2549: F013 CD B4 F2               CALL   GetBlockNumber       ; save it in Absolute CPM Record
2550: F016 CD C1 F2               CALL   IsAllocated          ; Absolute CPM Record=0000?
2551: F019 CA 29 F0               JP     Z,DiskEOF            ; get out if not allocated already
2552: F01C
2553: F01C CD C7 F2               CALL   SetActualRecordAdd   ; Absolute CPM Record now a record value
2554: F01F CD D5 EE               CALL   Seek                 ; to proper track,sector
2555: F022 CD C6 ED               CALL   ReadBuffer           ; to dma address
2556: F025 CD 3F EF               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
2557: F028 C9                     RET
2558: F029             DiskEOF:                        ; diskeof:
2559: F029 C3 F5 F3               JP     SetLowReturnTo1      ; exitParameterByte = 1
2560: F02C         ;ret
2561: F02C         ;-----------------------------------------------------------------
2562: F02C         ;sequential disk write
2563: F02C             DiskWriteSeq:
2564: F02C 3E 01                  LD     A,1
2565: F02E 32 80 F5               LD     (seqReadFlag),A
2566: F031         ;--------
2567: F031         ;disk write
2568: F031             DiskWrite:
2569: F031 3E 00                  LD     A,FALSE
2570: F033 32 7E F5               LD     (readModeFlag),A
2571: F036         ; write record to currently selected file
2572: F036 CD D4 EF               CALL   CheckWrite           ; in case write protected
2573: F039 2A C0 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
2574: F03C CD CA EF               CALL   CheckROFile          ; may be a read-only file
2575: F03F CD E6 ED               CALL   SetRecordVars        ; set local Record parameters
2576: F042 3A 8B F5               LD     A,(currentFileRecord)
2577: F045 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
2578: F047 DA 4E F0               JP     C,DiskWrite1         ; skip if in the same Extent
2579: F04A CD F5 F3               CALL   SetLowReturnTo1
2580: F04D C9                     RET                         ; Exit ???????????
2581: F04E
2582: F04E         ; can write the next record, so continue
2583: F04E             DiskWrite1:
2584: F04E CD B4 F2               CALL   GetBlockNumber       ; sets up actual block number
2585: F051 CD C1 F2               CALL   IsAllocated
2586: F054 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
2587: F056 C2 A1 F0               JP     NZ,DiskWrite3
2588: F059         ; not allocated -
2589: F059         ; the argument to getblock is the starting position for the disk search
2590: F059         ; and should be the last allocated block for this file,
2591: F059         ; or the value 0 if no space has been allocated
2592: F059
2593: F059 CD 34 F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
2594: F05C 32 81 F5               LD     (diskMapIndex),A     ; save for later
2595: F05F 01 00 00               LD     BC,0000h             ; may use block zero
2596: F062 B7                     OR     A
2597: F063 CA 6D F0               JP     Z,FirstBlock         ; skip if no previous block
2598: F066         ; previous block exists
2599: F066 4F                     LD     C,A
2600: F067 0B                     DEC    BC                   ; previous block # in BC
2601: F068 CD 54 F4               CALL   GetDiskMapValue      ; previous block # to HL
2602: F06B 44                     LD     B,H
2603: F06C 4D                     LD     C,L                  ; BC=prev block#
2604: F06D         ; BC = 0000, or previous block #
2605: F06D             FirstBlock:
2606: F06D CD 7A F2               CALL   GetClosestBlock      ; block # to HL
2607: F070         ; arrive here with block# or zero
2608: F070 7D                     LD     A,L
2609: F071 B4                     OR     H
2610: F072 C2 7B F0               JP     NZ,BlockOK
2611: F075         ; cannot find a block to allocate
2612: F075 3E 02                  LD     A,2
2613: F077 32 C2 EA               LD     (exitParameterByte),A
2614: F07A C9                     RET                         ; exitParameterByte=2
2615: F07B
2616: F07B             BlockOK:
2617: F07B 22 8D F5               LD     (absoluteCPMRecord),HL ; allocated block number is in HL
2618: F07E EB                     EX     DE,HL                ; block number to DE
2619: F07F 2A C0 EA               LD     HL,(paramDE)
2620: F082 01 10 00               LD     BC,fcbDiskMapIndex
2621: F085 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
2622: F086 3A 85 F5               LD     A,(byteAllocationFlag)
2623: F089 B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
2624: F08A 3A 81 F5               LD     A,(diskMapIndex)     ; recall dm index
2625: F08D CA 97 F0               JP     Z,Allocate16Bit      ; skip if allocating word
2626: F090         ; else allocate using a byte value
2627: F090 CD 6D F4               CALL   AddAtoHL
2628: F093 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
2629: F094 C3 9F F0               JP     DiskWrite2           ; to continue
2630: F097
2631: F097             Allocate16Bit:                      ; allocate a word value
2632: F097
2633: F097 4F                     LD     C,A
2634: F098 06 00                  LD     B,0                  ; double(diskMapIndex)
2635: F09A 09                     ADD    HL,BC
2636: F09B 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
2637: F09C 72                     LD     (HL),D
2638: F09D 23                     INC    HL
2639: F09E 73                     LD     (HL),E               ; double wd
2640: F09F         ; disk write to previously unallocated block
2641: F09F             DiskWrite2:
2642: F09F 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
2643: F0A1
2644: F0A1         ; continue the write operation of no allocation error
2645: F0A1         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
2646: F0A1
2647: F0A1             DiskWrite3:
2648: F0A1 3A C2 EA               LD     A,(exitParameterByte)
2649: F0A4 B7                     OR     A
2650: F0A5 C0                     RET    NZ                   ; stop if non zero returned value
2651: F0A6
2652: F0A6 C5                     PUSH   BC                   ; save write flag ( in C see above)
2653: F0A7 CD C7 F2               CALL   SetActualRecordAdd   ; Absolute CPM Record set to actual record number
2654: F0AA CD D5 EE               CALL   Seek                 ; to proper file position
2655: F0AD C1                     POP    BC                   ; get write flag
2656: F0AE C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
2657: F0AF CD 64 F2               CALL   WriteBuffer          ; written to disk
2658: F0B2 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
2659: F0B3         ; increment record count if fcbRecordCount<=current File Record
2660: F0B3 3A 8B F5               LD     A,(currentFileRecord)
2661: F0B6 21 89 F5               LD     HL,fcbRecordCount
2662: F0B9 BE                     CP     M                    ; current File Record-fcbRecordCount
2663: F0BA DA C1 F0               JP     C,DiskWrite4
2664: F0BD         ; fcbRecordCount <= current File Record
2665: F0BD 77                     LD     (HL),A
2666: F0BE 34                     INC    M                    ; fcbRecordCount = current File Record+1
2667: F0BF 0E 02                  LD     C,2                  ; mark as record count incremented
2668: F0C1             DiskWrite4:
2669: F0C1         ; A has current File Record, C=2 if new block or new record#
2670: F0C1 0D                     DEC    C
2671: F0C2 0D                     DEC    C
2672: F0C3 C2 CE F0               JP     NZ,DiskWrite5
2673: F0C6 F5                     PUSH   AF                   ; save current File Record value
2674: F0C7 CD ED F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2675: F0CA         ; reset the file write flag to mark as written fcb
2676: F0CA E6 7F                  AND    7FH                  ; not writeFlagMask
2677: F0CC 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2678: F0CD F1                     POP    AF                   ; restore current File Record
2679: F0CE             DiskWrite5:
2680: F0CE         ; check for end of extent, if found attempt to open next extent in preparation for next write
2681: F0CE FE 7F                  CP     highestRecordNumber  ; current File Record=highestRecordNumber?
2682: F0D0 C2 EE F0               JP     NZ,DiskWrite7        ; skip if not
2683: F0D3         ; may be random access write, if so we are done
2684: F0D3 3A 80 F5               LD     A,(seqReadFlag)
2685: F0D6 B7                     OR     A
2686: F0D7 CA EE F0               JP     Z,DiskWrite7         ; skip next extent open op
2687: F0DA         ; update current fcb before going to next extent
2688: F0DA CD 3F EF               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2689: F0DD CD F1 F0               CALL   OpenNextExt          ; readModeFlag=false
2690: F0E0         ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
2691: F0E0 21 C2 EA               LD     HL,exitParameterByte
2692: F0E3 7E                     LD     A,(HL)
2693: F0E4 B7                     OR     A
2694: F0E5 C2 EC F0               JP     NZ,DiskWrite6        ; no space
2695: F0E8         ; space available, set current File Record=255
2696: F0E8 3D                     DEC    A
2697: F0E9 32 8B F5               LD     (currentFileRecord),A ; goes to 00 next time
2698: F0EC             DiskWrite6:
2699: F0EC 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
2700: F0EE             DiskWrite7:
2701: F0EE C3 3F EF               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2702: F0F1         ;ret
2703: F0F1         ;-----------------------------------------------------------------
2704: F0F1         ;close the current extent  and open the next one if possible.
2705: F0F1         ;readModeFlag is true if in read mode
2706: F0F1             OpenNextExt:                      ; open$reel
2707: F0F1 AF                     XOR    A
2708: F0F2 32 7D F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
2709: F0F5 CD D1 F1               CALL   CloseDirEntry        ; close current extent
2710: F0F8         ; exitParameterByte remains at enddir if we cannot open the next ext
2711: F0F8 CD 84 EE               CALL   EndOfDirectory
2712: F0FB C8                     RET    Z                    ; return if end
2713: F0FC 2A C0 EA               LD     HL,(paramDE)         ; increment extent number
2714: F0FF 01 0C 00               LD     BC,fcbExtIndex
2715: F102 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
2716: F103 7E                     LD     A,(HL)
2717: F104 3C                     INC    A
2718: F105 E6 1F                  AND    maxExtValue
2719: F107 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
2720: F108 CA 1A F1               JP     Z,OpenNextModule     ; move to next module if zero
2721: F10B         ; may be in the same extent group
2722: F10B 47                     LD     B,A
2723: F10C 3A 70 F5               LD     A,(dpbEXM)
2724: F10F A0                     AND    B
2725: F110         ; if result is zero, then not in the same group
2726: F110 21 7D F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
2727: F113 A6                     AND    M                    ; produces a 00 in accumulator if not written
2728: F114 CA 25 F1               JP     Z,OpenNextExt1       ; go to next physical extent
2729: F117         ; result is non zero, so we must be in same logical ext
2730: F117 C3 43 F1               JP     OpenNextExt2         ; to copy fcb information
2731: F11A         ; extent number overflow, go to next module
2732: F11A
2733: F11A             OpenNextModule:
2734: F11A 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
2735: F11D 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
2736: F11E 34                     INC    M                    ; fcb(fcbS2Index)=++1
2737: F11F         ; module number incremented, check for overflow
2738: F11F 7E                     LD     A,(HL)
2739: F120 E6 0F                  AND    moduleMask           ; mask high order bits
2740: F122 CA 4E F1               JP     Z,OpenNextExtError   ; cannot overflow to zero
2741: F125         ; otherwise, ok to continue with new module
2742: F125
2743: F125             OpenNextExt1:
2744: F125 0E 0F                  LD     C,nameLength
2745: F127 CD 66 F3               CALL   Search4DirElement    ; next extent found?
2746: F12A CD 84 EE               CALL   EndOfDirectory
2747: F12D C2 43 F1               JP     NZ,OpenNextExt2
2748: F130         ; end of file encountered
2749: F130 3A 7E F5               LD     A,(readModeFlag)
2750: F133 3C                     INC    A                    ; 0ffh becomes 00 if read
2751: F134 CA 4E F1               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
2752: F137         ; try to extend the current file
2753: F137 CD 79 F1               CALL   MakeNewFile
2754: F13A         ; cannot be end of directory
2755: F13A CD 84 EE               CALL   EndOfDirectory
2756: F13D CA 4E F1               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
2757: F140 C3 46 F1               JP     OpenNextExt3
2758: F143
2759: F143         ; not end of file, open
2760: F143             OpenNextExt2:
2761: F143 CD 2C F3               CALL   OpenFileCopyFCB
2762: F146             OpenNextExt3:
2763: F146 CD E6 ED               CALL   SetRecordVars        ; Set Record parameters
2764: F149 AF                     XOR    A
2765: F14A 32 C2 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
2766: F14D C9                     RET                         ; with exitParameterByte = 0
2767: F14E
2768: F14E         ; cannot move to next extent of this file
2769: F14E             OpenNextExtError:
2770: F14E CD F5 F3               CALL   SetLowReturnTo1      ; exitParameterByte = 1
2771: F151 C3 EE F3               JP     SetFileWriteFlag     ; ensure that it will not be closed
2772: F154         ;-----------------------------------------------------------------
2773: F154         ;rename the file described by the first half of the currently addressed FCB.
2774: F154         ;the new name is contained in the last half of the FCB. The file name and type
2775: F154         ;are changed, but the reel number is ignored.  the user number is identical
2776: F154             Rename:
2777: F154 CD D4 EF               CALL   CheckWrite           ; may be write protected
2778: F157         ; search up to the extent field
2779: F157 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
2780: F159 CD 66 F3               CALL   Search4DirElement
2781: F15C         ; copy position 0
2782: F15C 2A C0 EA               LD     HL,(paramDE)
2783: F15F 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
2784: F160 11 10 00               LD     DE,fcbDiskMapIndex
2785: F163 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
2786: F164 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
2787: F165         ; assume the same disk drive for new named file
2788: F165             Rename1:
2789: F165 CD 84 EE               CALL   EndOfDirectory
2790: F168 C8                     RET    Z                    ; stop at end of dir
2791: F169         ; not end of directory, rename next element
2792: F169 CD C7 EF               CALL   CheckRODirectory     ; may be read-only file
2793: F16C 0E 10                  LD     C,fcbDiskMapIndex
2794: F16E 1E 0C                  LD     E,fcbExtIndex
2795: F170 CD 1F F4               CALL   CopyDir
2796: F173         ; element renamed, move to next
2797: F173 CD 7E F3               CALL   Search4NextDirElement
2798: F176 C3 65 F1               JP     Rename1
2799: F179         ;-----------------------------------------------------------------
2800: F179         ;create a new file by creating a directory entry then opening the file
2801: F179             MakeNewFile:
2802: F179 CD D4 EF               CALL   CheckWrite           ; may be write protected
2803: F17C 2A C0 EA               LD     HL,(paramDE)
2804: F17F E5                     PUSH   HL                   ; save fcb address, look for e5
2805: F180 21 57 F5               LD     HL,emptyFCB
2806: F183 22 C0 EA               LD     (paramDE),HL         ; paramDE = .empty
2807: F186 0E 01                  LD     C,1
2808: F188 CD 66 F3               CALL   Search4DirElement    ; length 1 match on empty entry
2809: F18B CD 84 EE               CALL   EndOfDirectory       ; zero flag set if no space
2810: F18E E1                     POP    HL                   ; recall paramDE address
2811: F18F 22 C0 EA               LD     (paramDE),HL         ; in case we return here
2812: F192 C8                     RET    Z                    ; return with error condition 255 if not found
2813: F193 EB                     EX     DE,HL                ; DE = paramDE address
2814: F194         ; clear the remainder of the fcb
2815: F194 21 0F 00               LD     HL,nameLength
2816: F197 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
2817: F198 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
2818: F19A AF                     XOR    A                    ; clear accumulator to 00 for fill
2819: F19B             MakeNewFile1:
2820: F19B 77                     LD     (HL),A
2821: F19C 23                     INC    HL
2822: F19D 0D                     DEC    C
2823: F19E C2 9B F1               JP     NZ,MakeNewFile1
2824: F1A1 21 0D 00               LD     HL,fcbS1Index
2825: F1A4 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
2826: F1A5 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
2827: F1A6 CD 4D EE               CALL   SetDirectoryEntry    ; may have extended the directory
2828: F1A9         ; now copy entry to the directory
2829: F1A9 CD 18 F4               CALL   CopyFCB
2830: F1AC         ; and set the file write flag to "1"
2831: F1AC C3 EE F3               JP     SetFileWriteFlag
2832: F1AF         ;-----------------------------------------------------------------
2833: F1AF         ;delete the currently addressed file
2834: F1AF             DeleteFile:
2835: F1AF CD D4 EF               CALL   CheckWrite           ; write protected ?
2836: F1B2 0E 0C                  LD     C,fcbExtIndex        ; extent number field
2837: F1B4 CD 66 F3               CALL   Search4DirElement    ; search through file type
2838: F1B7             DeleteFile1:
2839: F1B7         ; loop while directory matches
2840: F1B7 CD 84 EE               CALL   EndOfDirectory
2841: F1BA C8                     RET    Z                    ; exit if end
2842: F1BB         ; set each non zero disk map entry to 0 in the allocation vector
2843: F1BB CD C7 EF               CALL   CheckRODirectory     ; ro disk error if found
2844: F1BE CD 3F EE               CALL   GetDirElementAddress ; HL=.buff(dptr)
2845: F1C1 36 E5                  LD     (HL),emptyDir
2846: F1C3 0E 00                  LD     C,FALSE
2847: F1C5 CD 44 ED               CALL   ScanDiskMap          ; alloc elts set to 0
2848: F1C8 CD 54 F2               CALL   WriteDir             ; write the directory
2849: F1CB CD 7E F3               CALL   Search4NextDirElement ; to next element
2850: F1CE C3 B7 F1               JP     DeleteFile1          ; for another record
2851: F1D1         ;-----------------------------------------------------------------
2852: F1D1         ;locate the directory element and re-write it
2853: F1D1             CloseDirEntry:
2854: F1D1 AF                     XOR    A
2855: F1D2 32 C2 EA               LD     (exitParameterByte),A
2856: F1D5 CD DB EF               CALL   IsDiskWriteProtected ; return TRUE (0) if checksum change
2857: F1D8 C0                     RET    NZ                   ; skip close if r/o disk
2858: F1D9         ; check file write flag - 0 indicates written
2859: F1D9 CD ED F2               CALL   GetModuleNum         ; fcb(fcbS2Index) in A
2860: F1DC E6 80                  AND    writeFlagMask
2861: F1DE C0                     RET    NZ                   ; return if bit remains set
2862: F1DF 0E 0F                  LD     C,nameLength
2863: F1E1 CD 66 F3               CALL   Search4DirElement    ; locate file
2864: F1E4 CD 84 EE               CALL   EndOfDirectory
2865: F1E7 C8                     RET    Z                    ; return if not found
2866: F1E8         ; merge the disk map at paramDE with that at buff(dptr)
2867: F1E8 CD 3F EE               CALL   GetDirElementAddress
2868: F1EB 01 10 00               LD     BC,fcbDiskMapIndex
2869: F1EE 09                     ADD    HL,BC
2870: F1EF EB                     EX     DE,HL                ; DE is .buff(dptr+16)
2871: F1F0 2A C0 EA               LD     HL,(paramDE)
2872: F1F3 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
2873: F1F4 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of  byte Allocation Map
2874: F1F6             CloseDirEntry1:
2875: F1F6 3A 85 F5               LD     A,(byteAllocationFlag)
2876: F1F9 B7                     OR     A
2877: F1FA CA 11 F2               JP     Z,CloseDirEntry4     ; skip to double
2878: F1FD         ; this is a  byte map
2879: F1FD         ; if fcb(i) = 0 then fcb(i) = buff(i)
2880: F1FD         ; if buff(i) = 0 then buff(i) = fcb(i)
2881: F1FD         ; if fcb(i) <> buff(i) then error
2882: F1FD 7E                     LD     A,(HL)
2883: F1FE B7                     OR     A
2884: F1FF 1A                     LD     A,(DE)
2885: F200 C2 04 F2               JP     NZ,CloseDirEntry2
2886: F203         ; fcb(i) = 0
2887: F203 77                     LD     (HL),A               ; fcb(i) = buff(i)
2888: F204             CloseDirEntry2:
2889: F204 B7                     OR     A
2890: F205 C2 0A F2               JP     NZ,CloseDirEntry3
2891: F208         ; buff(i) = 0
2892: F208 7E                     LD     A,(HL)
2893: F209 12                     LD     (DE),AE              ; buff(i)=fcb(i)
2894: F20A             CloseDirEntry3:
2895: F20A BE                     CP     M
2896: F20B C2 49 F2               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
2897: F20E C3 26 F2               JP     CloseDirEntry5       ; if merge ok
2898: F211
2899: F211         ; this is a double byte merge operation
2900: F211             CloseDirEntry4:
2901: F211 CD 6C F2               CALL   Merge                ; buff = fcb if buff 0000
2902: F214 EB                     EX     DE,HL
2903: F215 CD 6C F2               CALL   Merge
2904: F218 EB                     EX     DE,HL                ; fcb = buff if fcb 0000
2905: F219         ; they should be identical at this point
2906: F219 1A                     LD     A,(DE)
2907: F21A BE                     CP     M
2908: F21B C2 49 F2               JP     NZ,CloseDirEntryError ; low same?
2909: F21E 13                     INC    DE
2910: F21F 23                     INC    HL                   ; to high byte
2911: F220 1A                     LD     A,(DE)
2912: F221 BE                     CP     M
2913: F222 C2 49 F2               JP     NZ,CloseDirEntryError ; high same?
2914: F225         ;	merge operation ok for this pair
2915: F225 0D                     DEC    C                    ; extra count for double byte
2916: F226             CloseDirEntry5:
2917: F226 13                     INC    DE
2918: F227 23                     INC    HL                   ; to next byte position
2919: F228 0D                     DEC    C
2920: F229 C2 F6 F1               JP     NZ,CloseDirEntry1    ; for more
2921: F22C         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
2922: F22C 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
2923: F22F 09                     ADD    HL,BC
2924: F230 EB                     EX     DE,HL
2925: F231 09                     ADD    HL,BC
2926: F232         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
2927: F232 1A                     LD     A,(DE)               ; current user extent number
2928: F233         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
2929: F233 BE                     CP     M
2930: F234 DA 40 F2               JP     C,CloseDirEntryEnd
2931: F237         ; fcb extent number >= dir extent number
2932: F237 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
2933: F238         ; update directory record count field
2934: F238 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
2935: F23B 09                     ADD    HL,BC
2936: F23C EB                     EX     DE,HL
2937: F23D 09                     ADD    HL,BC
2938: F23E         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
2939: F23E 7E                     LD     A,(HL)
2940: F23F 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
2941: F240             CloseDirEntryEnd:
2942: F240 3E FF                  LD     A,TRUE
2943: F242 32 7D F5               LD     (fcbCopiedFlag),A    ; mark as copied
2944: F245 CD 4E F2               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
2945: F248 C9                     RET
2946: F249
2947: F249         ; elements did not merge correctly
2948: F249             CloseDirEntryError:
2949: F249 21 C2 EA               LD     HL,exitParameterByte
2950: F24C 35                     DEC    M                    ; =255 non zero flag set
2951: F24D C9                     RET
2952: F24E         ;-----------------------------------------------------------------
2953: F24E         ;enter from CloseDirEntry to seek and copy current element
2954: F24E             SeekCopy:
2955: F24E CD C4 EE               CALL   SeekDir              ; to the directory element
2956: F251 C3 54 F2               JP     WriteDir             ; write the directory element
2957: F254         ;ret
2958: F254         ;-----------------------------------------------------------------
2959: F254         ;write the current directory entry, set checksum
2960: F254             WriteDir:
2961: F254         ;	CALL	NewCheckSum						; initialize entry
2962: F254 0E FF                  LD     C,TRUE
2963: F256 CD 0F EF               CALL   CheckSumUtility
2964: F259
2965: F259 CD BD ED               CALL   SetDirDMA            ; directory dma
2966: F25C 0E 01                  LD     C,1                  ; indicates a write directory operation
2967: F25E CD 64 F2               CALL   WriteBuffer          ; write the buffer
2968: F261 C3 B8 ED               JP     SetDataDMA           ; to data dma address
2969: F264         ;ret
2970: F264         ;-----------------------------------------------------------------
2971: F264         ;write buffer and check condition
2972: F264         ;write type (wrtype) is in register C
2973: F264         ;wrtype = 0 => normal write operation		WriteAllocated
2974: F264         ;wrtype = 1 => directory write operation	WriteDirectory
2975: F264         ;wrtype = 2 => start of new block			WriteCleanBuffer
2976: F264             WriteBuffer:
2977: F264 CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
2978: F267 B7                     OR     A
2979: F268 C2 EA F4               JP     NZ,erPermanentNoWait ; error if not 00
2980: F26B C9                     RET
2981: F26C         ;-----------------------------------------------------------------
2982: F26C
2983: F26C         ;HL = .fcb1(i), DE = .fcb2(i),
2984: F26C         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
2985: F26C             Merge:
2986: F26C 7E                     LD     A,(HL)
2987: F26D 23                     INC    HL
2988: F26E B6                     OR     M
2989: F26F 2B                     DEC    HL
2990: F270 C0                     RET    NZ                   ; return if = 0000
2991: F271 1A                     LD     A,(DE)
2992: F272 77                     LD     (HL),A
2993: F273 13                     INC    DE
2994: F274 23                     INC    HL                   ; low byte copied
2995: F275 1A                     LD     A,(DE)
2996: F276 77                     LD     (HL),A
2997: F277 1B                     DEC    DE
2998: F278 2B                     DEC    HL                   ; back to input form
2999: F279 C9                     RET
3000: F27A         ;-----------------------------------------------------------------
3001: F27A         ;compute closest disk block number from current block
3002: F27A         ;given allocation vector position BC, find the zero bit closest to this position
3003: F27A         ;by searching left and right.
3004: F27A         ;if found, set the bit to one and return the bit position in hl.
3005: F27A         ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
3006: F27A             GetClosestBlock:
3007: F27A 50                     LD     D,B
3008: F27B 59                     LD     E,C                  ; copy of starting position to de
3009: F27C             TestLeft:
3010: F27C 79                     LD     A,C
3011: F27D B0                     OR     B
3012: F27E CA 8D F2               JP     Z,TestRight          ; skip if left=0000
3013: F281         ; left not at position zero, bit zero?
3014: F281 0B                     DEC    BC
3015: F282 D5                     PUSH   DE
3016: F283 C5                     PUSH   BC                   ; left,right pushed
3017: F284 CD 70 ED               CALL   GetAllocBit
3018: F287 1F                     RRA
3019: F288 D2 A8 F2               JP     NC,ReturnBlockNumber ; return block number if zero
3020: F28B         ; bit is one, so try the right
3021: F28B C1                     POP    BC
3022: F28C D1                     POP    DE                   ; left, right restored
3023: F28D             TestRight:
3024: F28D 2A 71 F5               LD     HL,(dpbDSM)          ; value of maximum allocation#
3025: F290 7B                     LD     A,E
3026: F291 95                     SUB    L
3027: F292 7A                     LD     A,D
3028: F293 9C                     SBC    A,H                  ; right=dpbDSM?
3029: F294 D2 B0 F2               JP     NC,ReturnBlockZero   ; return block 0000 if so
3030: F297 13                     INC    DE
3031: F298 C5                     PUSH   BC
3032: F299 D5                     PUSH   DE                   ; left, right pushed
3033: F29A 42                     LD     B,D
3034: F29B 4B                     LD     C,E                  ; ready right for call
3035: F29C CD 70 ED               CALL   GetAllocBit
3036: F29F 1F                     RRA
3037: F2A0 D2 A8 F2               JP     NC,ReturnBlockNumber ; return block number if zero
3038: F2A3 D1                     POP    DE
3039: F2A4 C1                     POP    BC                   ; restore left and right pointers
3040: F2A5 C3 7C F2               JP     TestLeft             ; for another attempt
3041: F2A8             ReturnBlockNumber:
3042: F2A8 17                     RLA
3043: F2A9 3C                     INC    A                    ; bit back into position and set to 1
3044: F2AA         ; 	D contains the number of shifts required to reposition
3045: F2AA CD 97 ED               CALL   RotateAndReplace     ; move bit back to position and store
3046: F2AD E1                     POP    HL
3047: F2AE D1                     POP    DE                   ; HL returned value, DE discarded
3048: F2AF C9                     RET
3049: F2B0
3050: F2B0         ; cannot find an available bit, return 0000
3051: F2B0             ReturnBlockZero:
3052: F2B0 21 00 00               LD     HL,0000H
3053: F2B3 C9                     RET
3054: F2B4         ;-----------------------------------------------------------------
3055: F2B4         ;compute disk block number from current fcb
3056: F2B4             GetBlockNumber:
3057: F2B4 CD 34 F4               CALL   GetDiskMapIndex      ; 0...15 in register A
3058: F2B7 4F                     LD     C,A
3059: F2B8 06 00                  LD     B,0
3060: F2BA CD 54 F4               CALL   GetDiskMapValue      ; return value in HL
3061: F2BD 22 8D F5               LD     (absoluteCPMRecord),HL ; save for later
3062: F2C0 C9                     RET
3063: F2C1         ;-----------------------------------------------------------------
3064: F2C1         ;is  block allocated
3065: F2C1             IsAllocated:
3066: F2C1 2A 8D F5               LD     HL,(absoluteCPMRecord)
3067: F2C4 7D                     LD     A,L
3068: F2C5 B4                     OR     H
3069: F2C6 C9                     RET
3070: F2C7         ;-----------------------------------------------------------------
3071: F2C7         ;compute actual record address
3072: F2C7         ; result = absolute CPMRecord * ( 2**BSH)
3073: F2C7             SetActualRecordAdd:
3074: F2C7 3A 6E F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
3075: F2CA 2A 8D F5               LD     HL,(absoluteCPMRecord)
3076: F2CD
3077: F2CD             SetActualRecordAdd1:
3078: F2CD 29                     ADD    HL,HL
3079: F2CE 3D                     DEC    A                    ; shl(absolute CPMRecord,dpbBSH)
3080: F2CF C2 CD F2               JP     NZ,SetActualRecordAdd1
3081: F2D2         ; HL has Record number for start of the block;
3082: F2D2 3A 6F F5               LD     A,(dpbBLM)           ; get block mask
3083: F2D5 4F                     LD     C,A                  ; to get current File Record mod Block
3084: F2D6 3A 8B F5               LD     A,(currentFileRecord) ; get index into block
3085: F2D9 A1                     AND    C                    ; masked value in A
3086: F2DA B5                     OR     L
3087: F2DB 6F                     LD     L,A                  ; to HL
3088: F2DC 22 8D F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL or (current File Record and dpbBLM)
3089: F2DF         ; *** Absolute CPM Record now has current record number - Starting record number + index into block
3090: F2DF C9                     RET
3091: F2E0         ;-----------------------------------------------------------------
3092: F2E0         ;---------------------
3093: F2E0         ;copy directory location to exitParameterByte
3094: F2E0             DirLocationToReturnLoc:
3095: F2E0 3A 7F F5               LD     A,(directoryFlag)
3096: F2E3 32 C2 EA               LD     (exitParameterByte),A
3097: F2E6 C9                     RET
3098: F2E7         ;---------------------
3099: F2E7         ;clear the module number field for user open/make (S2)
3100: F2E7             ClearModuleNum:
3101: F2E7 CD ED F2               CALL   GetModuleNum
3102: F2EA 36 00                  LD     (HL),0               ; fcb(fcbS2Index)=0
3103: F2EC C9                     RET
3104: F2ED         ;---------------------
3105: F2ED         ;get data module number (high order bit is fwf -file write flag)
3106: F2ED             GetModuleNum:
3107: F2ED 2A C0 EA               LD     HL,(paramDE)
3108: F2F0 11 0E 00               LD     DE,fcbS2Index
3109: F2F3 19                     ADD    HL,DE                ; HL=.fcb(fcbS2Index)
3110: F2F4 7E                     LD     A,(HL)
3111: F2F5 C9                     RET                         ; A=fcb(fcbS2Index)
3112: F2F6         ;---------------------
3113: F2F6         ;check current fcb to see if reselection necessary
3114: F2F6             Reselect:
3115: F2F6 3E FF                  LD     A,TRUE
3116: F2F8 32 86 F5               LD     (fResel),A           ;mark possible reselect
3117: F2FB 2A C0 EA               LD     HL,(paramDE)
3118: F2FE 7E                     LD     A,(HL)               ; drive select code
3119: F2FF E6 1F                  AND    00011111B            ; non zero is auto drive select
3120: F301 3D                     DEC    A                    ; drive code normalized to 0..30, or 255
3121: F302 32 BF EA               LD     (paramE),A           ; save drive code
3122: F305 FE 1E                  CP     30
3123: F307 D2 1A F3               JP     NC,NoSelect
3124: F30A         ; auto select function, save currentDisk
3125: F30A 3A 56 F5               LD     A,(currentDisk)
3126: F30D 32 87 F5               LD     (entryDisk),A        ; entryDisk=currentDisk
3127: F310 7E                     LD     A,(HL)
3128: F311 32 88 F5               LD     (fcbDisk),A          ; save drive code
3129: F314 E6 E0                  AND    11100000B
3130: F316 77                     LD     (HL),A               ; preserve hi bits
3131: F317 CD 4E EC               CALL   SelectCurrent
3132: F31A             NoSelect:                       ; noselect:
3133: F31A
3134: F31A 3A 55 F5               LD     A,(currentUserNumber) ; set user code 0...31
3135: F31D 2A C0 EA               LD     HL,(paramDE)
3136: F320 B6                     OR     M
3137: F321 77                     LD     (HL),A
3138: F322 C9                     RET
3139: F323         ;---------------------
3140: F323         ;search for the directory entry, copy to fcb
3141: F323             OpenFile:
3142: F323 0E 0F                  LD     C,nameLength
3143: F325 CD 66 F3               CALL   Search4DirElement
3144: F328 CD 84 EE               CALL   EndOfDirectory
3145: F32B C8                     RET    Z                    ; return with exitParameterByte=255 if end
3146: F32C
3147: F32C         ; not end of directory, copy fcb information
3148: F32C             OpenFileCopyFCB:
3149: F32C CD 0A EE               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
3150: F32F 7E                     LD     A,(HL)
3151: F330 F5                     PUSH   AF
3152: F331 E5                     PUSH   HL                   ; save extent#
3153: F332 CD 3F EE               CALL   GetDirElementAddress
3154: F335 EB                     EX     DE,HL                ; DE = .buff(dptr)
3155: F336 2A C0 EA               LD     HL,(paramDE)         ; HL=.fcb(0)
3156: F339 0E 20                  LD     C,NEXT_RECORD        ; length of move operation
3157: F33B D5                     PUSH   DE                   ; save .buff(dptr)
3158: F33C CD 8D F4               CALL   Move                 ; from .buff(dptr) to .fcb(0)
3159: F33F         ; note that entire fcb is copied, including indicators
3160: F33F CD EE F3               CALL   SetFileWriteFlag     ; sets file write flag
3161: F342 D1                     POP    DE
3162: F343 21 0C 00               LD     HL,fcbExtIndex
3163: F346 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbExtIndex)
3164: F347 4E                     LD     C,(HL)               ; C = directory extent number
3165: F348 21 0F 00               LD     HL,fcbRCIndex        ; point at the record Count field
3166: F34B 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbRCIndex)
3167: F34C 46                     LD     B,(HL)               ; B holds directory record count
3168: F34D E1                     POP    HL
3169: F34E F1                     POP    AF
3170: F34F 77                     LD     (HL),A               ; restore extent number
3171: F350         ; HL = .user extent#, B = dir rec cnt, C = dir extent#
3172: F350         ; if user ext < dir ext then user := 128 records
3173: F350         ; if user ext = dir ext then user := dir records
3174: F350         ; if user ext > dir ext then user := 0 records
3175: F350 79                     LD     A,C
3176: F351 BE                     CP     M
3177: F352 78                     LD     A,B                  ; ready dir fcbRCIndex
3178: F353 CA 5D F3               JP     Z,OpenRecordCount    ; if same, user gets dir fcbRCIndex
3179: F356 3E 00                  LD     A,0
3180: F358 DA 5D F3               JP     C,OpenRecordCount    ; user is larger
3181: F35B 3E 80                  LD     A,RecordsPerExtent   ; directory is larger >>>RecordsPerExtent
3182: F35D             OpenRecordCount:                      ;Acc has record count to fill
3183: F35D 2A C0 EA               LD     HL,(paramDE)
3184: F360 11 0F 00               LD     DE,fcbRCIndex
3185: F363 19                     ADD    HL,DE
3186: F364 77                     LD     (HL),A
3187: F365 C9                     RET
3188: F366
3189: F366         ;---------------------
3190: F366         ;search for directory element of length C at info
3191: F366             Search4DirElement:
3192: F366 3E FF                  LD     A,0FFH
3193: F368 32 7F F5               LD     (directoryFlag),A    ; changed if actually found
3194: F36B 21 82 F5               LD     HL,searchLength
3195: F36E 71                     LD     (HL),C               ; searchLength = C
3196: F36F 2A C0 EA               LD     HL,(paramDE)
3197: F372 22 83 F5               LD     (searchAddress),HL   ; searchAddress = paramDE
3198: F375 CD 38 EE               CALL   SetEndDirectory      ; dirEntryIndex = enddir
3199: F378 CD 9E ED               CALL   Home                 ; to start at the beginning
3200: F37B C3 7E F3               JP     Search4NextDirElement
3201: F37E         ;---------------------
3202: F37E         ;search for the next directory element, assuming a previous
3203: F37E         ;call on search which sets searchAddress and searchLength
3204: F37E             Search4NextDirElement:
3205: F37E 0E 00                  LD     C,FALSE
3206: F380 CD 96 EE               CALL   ReadDirectory        ; read next dir element
3207: F383 CD 84 EE               CALL   EndOfDirectory
3208: F386 CA E5 F3               JP     Z,SearchDone         ; skip to end if so
3209: F389         ; not end of directory, scan for match
3210: F389 2A 83 F5               LD     HL,(searchAddress)
3211: F38C EB                     EX     DE,HL                ; DE=beginning of user fcb
3212: F38D 1A                     LD     A,(DE)               ; first character
3213: F38E FE E5                  CP     emptyDir             ; keep scanning if Dir entry is empty
3214: F390 CA 9B F3               JP     Z,Search4NextDirElement1
3215: F393         ; not emptyDir, may be end of logical directory
3216: F393 D5                     PUSH   DE                   ; save search address
3217: F394 CD 56 EE               CALL   StillInDirectory     ; past logical end?
3218: F397 D1                     POP    DE                   ; recall address
3219: F398 D2 E5 F3               JP     NC,SearchDone        ; artificial stop
3220: F39B             Search4NextDirElement1:
3221: F39B CD 3F EE               CALL   GetDirElementAddress ; HL = buffa+dptr
3222: F39E 3A 82 F5               LD     A,(searchLength)
3223: F3A1 4F                     LD     C,A                  ; length of search to c
3224: F3A2 06 00                  LD     B,0                  ; bcounts up, c counts down
3225: F3A4             Search4NextLoop:
3226: F3A4 79                     LD     A,C
3227: F3A5 B7                     OR     A
3228: F3A6 CA D4 F3               JP     Z,EndDirElementSearch
3229: F3A9 1A                     LD     A,(DE)
3230: F3AA FE 3F                  CP     QMARK
3231: F3AC CA CD F3               JP     Z,Search4NextOK      ; ? matches all
3232: F3AF         ; scan next character if not fcbS1Index
3233: F3AF 78                     LD     A,B
3234: F3B0 FE 0D                  CP     fcbS1Index
3235: F3B2 CA CD F3               JP     Z,Search4NextOK
3236: F3B5         ; not the fcbS1Index field, extent field?
3237: F3B5 FE 0C                  CP     fcbExtIndex          ; may be extent field
3238: F3B7 1A                     LD     A,(DE)               ; fcb character
3239: F3B8 CA C4 F3               JP     Z,Search4Ext         ; skip to search extent
3240: F3BB 96                     SUB    M
3241: F3BC E6 7F                  AND    07FH                 ; mask-out flags/extent modulus
3242: F3BE C2 7E F3               JP     NZ,Search4NextDirElement ; skip if not matched
3243: F3C1 C3 CD F3               JP     Search4NextOK        ;matched character
3244: F3C4
3245: F3C4         ; A has fcb character attempt an extent # match
3246: F3C4             Search4Ext:
3247: F3C4 C5                     PUSH   BC                   ; save counters
3248: F3C5 4E                     LD     C,(HL)               ; directory character to c
3249: F3C6 CD FB F3               CALL   CompareExtents       ; compare user/dir char
3250: F3C9 C1                     POP    BC                   ; recall counters
3251: F3CA C2 7E F3               JP     NZ,Search4NextDirElement ; skip if no match
3252: F3CD
3253: F3CD         ; current character matches
3254: F3CD             Search4NextOK:
3255: F3CD 13                     INC    DE
3256: F3CE 23                     INC    HL
3257: F3CF 04                     INC    B
3258: F3D0 0D                     DEC    C
3259: F3D1 C3 A4 F3               JP     Search4NextLoop
3260: F3D4
3261: F3D4         ; entire name matches, return dir position
3262: F3D4             EndDirElementSearch:
3263: F3D4 3A 90 F5               LD     A,(dirEntryIndex)
3264: F3D7 E6 03                  AND    dirEntryMask
3265: F3D9 32 C2 EA               LD     (exitParameterByte),A
3266: F3DC         ; exitParameterByte = low(dirEntryIndex) and 11b
3267: F3DC 21 7F F5               LD     HL,directoryFlag
3268: F3DF 7E                     LD     A,(HL)
3269: F3E0 17                     RLA
3270: F3E1 D0                     RET    NC                   ; directoryFlag=0ffh?
3271: F3E2         ; yes, change it to 0 to mark as found
3272: F3E2 AF                     XOR    A
3273: F3E3 77                     LD     (HL),A               ; directoryFlag=0
3274: F3E4 C9                     RET
3275: F3E5
3276: F3E5         ; end of directory, or empty name
3277: F3E5             SearchDone:
3278: F3E5 CD 38 EE               CALL   SetEndDirectory      ; may be artifical end
3279: F3E8 3E FF                  LD     A,0FFH
3280: F3EA 32 C2 EA               LD     (exitParameterByte),A
3281: F3ED C9                     RET
3282: F3EE         ;---------------------
3283: F3EE         ;Set file write flag
3284: F3EE             SetFileWriteFlag:
3285: F3EE CD ED F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3286: F3F1 F6 80                  OR     writeFlagMask        ; set fwf (file write flag) to "1"
3287: F3F3 77                     LD     (HL),A               ; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
3288: F3F4 C9                     RET                         ; also returns non zero in accumulator
3289: F3F5         ;---------------------
3290: F3F5         ;set exitParameterByte to 1
3291: F3F5             SetLowReturnTo1:
3292: F3F5 3E 01                  LD     A,1
3293: F3F7 32 C2 EA               LD     (exitParameterByte),A
3294: F3FA C9                     RET
3295: F3FB         ;---------------------
3296: F3FB         ;compare extent# in A with that in C, return nonzero if they do not match
3297: F3FB             CompareExtents:
3298: F3FB C5                     PUSH   BC                   ; save C's original value
3299: F3FC F5                     PUSH   AF
3300: F3FD 3A 70 F5               LD     A,(dpbEXM)
3301: F400 2F                     CPL
3302: F401 47                     LD     B,A
3303: F402         ; B has negated form of extent mask
3304: F402 79                     LD     A,C
3305: F403 A0                     AND    B
3306: F404 4F                     LD     C,A                  ; low bits removed from C
3307: F405 F1                     POP    AF
3308: F406 A0                     AND    B                    ; low bits removed from A
3309: F407 91                     SUB    C
3310: F408 E6 1F                  AND    maxExtValue          ; set flags
3311: F40A C1                     POP    BC                   ; restore original values
3312: F40B C9                     RET
3313: F40C         ;---------------------
3314: F40C         ;copy the directory entry to the user buffer
3315: F40C             CopyDirEntryToUser:
3316: F40C 2A 64 F5               LD     HL,(caDirectoryDMA)
3317: F40F EB                     EX     DE,HL                ; source is directory buffer
3318: F410 2A 5C F5               LD     HL,(initDAMAddress)  ; destination is user dma address
3319: F413 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3320: F415 C3 8D F4               JP     Move
3321: F418         ;---------------------
3322: F418         ;copy the whole file control block
3323: F418             CopyFCB:
3324: F418 0E 00                  LD     C,0
3325: F41A 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3326: F41C C3 1F F4               JP     CopyDir
3327: F41F         ;---------------------
3328: F41F         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3329: F41F             CopyDir:
3330: F41F D5                     PUSH   DE                   ; save length for later
3331: F420 06 00                  LD     B,0                  ; double index to BC
3332: F422 2A C0 EA               LD     HL,(paramDE)         ; HL = source for data
3333: F425 09                     ADD    HL,BC
3334: F426 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3335: F427 CD 3F EE               CALL   GetDirElementAddress ; HL=.buff(dptr), destination
3336: F42A C1                     POP    BC                   ; DE=source, HL=dest, C=length
3337: F42B CD 8D F4               CALL   Move                 ; data moved
3338: F42E         ;enter from close to seek and copy current element
3339: F42E             SeekAndCopy:                      ; seek$copy:
3340: F42E CD C4 EE               CALL   SeekDir              ; seek$dir ;to the directory element
3341: F431 C3 54 F2               JP     WriteDir             ; write the directory element
3342: F434         ;---------------------
3343: F434         ;Return the  disk map Index for current File Record in the ACC
3344: F434         ;  account for multiple extents in 1 physical Directory entry
3345: F434             GetDiskMapIndex:                      ; dm$position
3346: F434 21 6E F5               LD     HL,dpbBSH            ; get block shift value
3347: F437 4E                     LD     C,(HL)               ; shift count to C
3348: F438 3A 8B F5               LD     A,(currentFileRecord) ; current virtual record to A
3349: F43B             GetDiskMapIndex1:
3350: F43B B7                     OR     A                    ; reset the carry flag
3351: F43C 1F                     RRA
3352: F43D 0D                     DEC    C
3353: F43E C2 3B F4               JP     NZ,GetDiskMapIndex1
3354: F441         ; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
3355: F441         ; A has the relative position in the block.
3356: F441 47                     LD     B,A                  ; save it for later addition
3357: F442 3E 08                  LD     A,8
3358: F444 96                     SUB    M                    ; 8-dpbBSH to accumulator
3359: F445 4F                     LD     C,A                  ; extent shift count in register c
3360: F446 3A 8A F5               LD     A,(extentValue)      ; extent value ani extmsk
3361: F449             GetDiskMapIndex2:                      ; dmpos1:
3362: F449         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3363: F449         ; shift is 4,3,2,1,0
3364: F449 0D                     DEC    C
3365: F44A CA 52 F4               JP     Z,GetDiskMapIndex3
3366: F44D B7                     OR     A                    ; clear the carry flag
3367: F44E 17                     RLA
3368: F44F C3 49 F4               JP     GetDiskMapIndex2
3369: F452
3370: F452         ; The ACC has the Block Number for this record
3371: F452             GetDiskMapIndex3:
3372: F452         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3373: F452 80                     ADD    A,B                  ; add the previous shr(current File Record,dpbBSH) value
3374: F453         ; A is one of the following values, depending upon alloc
3375: F453         ; bks dpbBSH
3376: F453         ; 1k   3     v/8 + extentValue * 16
3377: F453         ; 2k   4     v/16+ extentValue * 8
3378: F453         ; 4k   5     v/32+ extentValue * 4
3379: F453         ; 8k   6     v/64+ extentValue * 2
3380: F453         ; 16k  7     v/128+extentValue * 1
3381: F453 C9                     RET                         ; with disk map position in A
3382: F454         ;---------------------
3383: F454         ; Enter with Disk Map Index in BG
3384: F454         ; Return disk map value  in HL
3385: F454             GetDiskMapValue:
3386: F454 2A C0 EA               LD     HL,(paramDE)         ; base address of file control block
3387: F457 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3388: F45A 19                     ADD    HL,DE                ; HL =.diskmap
3389: F45B 09                     ADD    HL,BC                ; index by a  byte value
3390: F45C 3A 85 F5               LD     A,(byteAllocationFlag) ;  byte map entry?
3391: F45F B7                     OR     A
3392: F460 CA 67 F4               JP     Z,GetDiskMap16Bit    ; get disk map  byte
3393: F463 6E                     LD     L,(HL)
3394: F464 26 00                  LD     H,0
3395: F466 C9                     RET                         ; with HL=00bb
3396: F467             GetDiskMap16Bit:                      ; getdmd:
3397: F467 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3398: F468         ; double precision value returned
3399: F468 56                     LD     D,(HL)
3400: F469 23                     INC    HL
3401: F46A 5E                     LD     E,(HL)
3402: F46B EB                     EX     DE,HL
3403: F46C C9                     RET
3404: F46D         ;---------------------
3405: F46D         ;---------------------
3406: F46D         ;*****************************************************************
3407: F46D         ;************************ Utilities ******************************
3408: F46D         ;*****************************************************************
3409: F46D             AddAtoHL:
3410: F46D 85                     ADD    A,L
3411: F46E 6F                     LD     L,A
3412: F46F D0                     RET    NC
3413: F470 24                     INC    H
3414: F471 C9                     RET
3415: F472         ;----------
3416: F472             DEminusHL2HL:
3417: F472 7B                     LD     A,E
3418: F473 95                     SUB    L
3419: F474 6F                     LD     L,A
3420: F475 7A                     LD     A,D
3421: F476 9C                     SBC    A,H
3422: F477 67                     LD     H,A
3423: F478 C9                     RET
3424: F479         ;-------------
3425: F479             ShiftRightHLbyC:
3426: F479 0C                     INC    C
3427: F47A             ShiftRightHLbyC0:
3428: F47A 0D                     DEC    C
3429: F47B C8                     RET    Z
3430: F47C 7C                     LD     A,H
3431: F47D B7                     OR     A
3432: F47E 1F                     RRA
3433: F47F 67                     LD     H,A
3434: F480 7D                     LD     A,L
3435: F481 1F                     RRA
3436: F482 6F                     LD     L,A
3437: F483 C3 7A F4               JP     ShiftRightHLbyC0
3438: F486         ;-------
3439: F486             ShiftLeftHLbyC:
3440: F486 0C                     INC    C
3441: F487             ShiftLeftHLbyC0:
3442: F487 0D                     DEC    C
3443: F488 C8                     RET    Z                    ; exit when done
3444: F489 29                     ADD    HL,HL
3445: F48A C3 87 F4               JP     ShiftLeftHLbyC0
3446: F48D         ;*****************************************************************
3447: F48D         ;move data length of length C from source DE to HL
3448: F48D             Move:
3449: F48D 0C                     INC    C
3450: F48E             Move0:
3451: F48E 0D                     DEC    C
3452: F48F C8                     RET    Z
3453: F490 1A                     LD     A,(DE)
3454: F491 77                     LD     (HL),A
3455: F492 13                     INC    DE
3456: F493 23                     INC    HL
3457: F494 C3 8E F4               JP     Move0
3458: F497
3459: F497         ;********** Console OUT Routines*******************??????
3460: F497
3461: F497         ;---------------------------------- Is Bit Set ------------------------------;
3462: F497         ; Enter HL  contains the bit map                                             ;
3463: F497         ;       B   Has the bit number (0...F)                                       ;
3464: F497         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3465: F497         ;              = 0 if bit is set (1)                                         ;
3466: F497             IsBitSet:                       ;
3467: F497 04                     INC    B                    ;
3468: F498             IsBitSetLoop:                      ;
3469: F498 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3470: F499 CB 45                  BIT    0,L                  ; is LSB set?                        ;
3471: F49B 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3472: F49D 3F                     CCF                         ; else Clear Carry flag              ;
3473: F49E             IsBitSet1:                      ;
3474: F49E CB 1C                  RR     H                    ; Shift thru CY                      ;
3475: F4A0 CB 1D                  RR     L                    ; ditto                              ;
3476: F4A2 10 F4                  DJNZ   IsBitSetLoop         ;
3477: F4A4 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3478: F4A6 C9                     RET                         ;
3479: F4A7         ;---------------------------------- Is Bit Set ------------------------------;
3480: F4A7
3481: F4A7         ;============================ Set/Reset Vector Bit ==========================;
3482: F4A7         ;---------------------------------- Set Vector Bit -------------------------;;
3483: F4A7         ; Enter  HL  contains the bit map vector                                    ;;
3484: F4A7         ;        B   Has the bit number (0...F)                                     ;;
3485: F4A7         ; Return HL  Contains the modified bit map vector                                  ;;
3486: F4A7             SetVectorBit:                      ;;
3487: F4A7 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3488: F4A8 CD 97 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3489: F4AB         ;;
3490: F4AB C1                     POP    BC                   ; Get the bit position              ;;
3491: F4AC CB FC                  SET    7,H                  ;;
3492: F4AE 18 07                  JR     ReAlignVector        ;                                    ;
3493: F4B0         ;---------------------------------- Set Vector Bit -------------------------;;
3494: F4B0         ;---------------------------------- Reset Vector Bit -----------------------;;
3495: F4B0         ; Enter  HL  contains the bit map vector                                    ;;
3496: F4B0         ;        B   Has the bit number (0...F)                                     ;;
3497: F4B0         ; Return HL  Contains the modified bit map vector                           ;;
3498: F4B0             ResetVectorBit:                      ;;
3499: F4B0 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3500: F4B1 CD 97 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3501: F4B4         ;;
3502: F4B4 C1                     POP    BC                   ; Get the bit position              ;;
3503: F4B5 CB BC                  RES    7,H                  ;;
3504: F4B7         ; Fall thru to ReAlignVector                                                 ;
3505: F4B7         ;---------------------------------- Reset Vector Bit -----------------------;;
3506: F4B7         ;---------------------------------- Set VectorBit --------------------------;;
3507: F4B7         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3508: F4B7         ;
3509: F4B7             ReAlignVector:                      ;
3510: F4B7 04                     INC    B                    ;
3511: F4B8             ReAlignMapLoop:                      ;
3512: F4B8 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3513: F4B9 CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3514: F4BB 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3515: F4BD 3F                     CCF                         ; else Clear Carry flag              ;
3516: F4BE             ReAlignMap1:                      ;
3517: F4BE CB 15                  RL     L                    ; Shift thru CY                      ;
3518: F4C0 CB 14                  RL     H                    ; ditto                              ;
3519: F4C2 10 F4                  DJNZ   ReAlignMapLoop       ;
3520: F4C4 C9                     RET                         ;
3521: F4C5         ;============================ Set/Reset Vector Bit ==========================;
3522: F4C5
3523: F4C5
3524: F4C5         ;? ;********************************************************
3525: F4C5         ;? ;return version number
3526: F4C5         ;? vGetVersion:								; func12 (12 - 0C)	 Get Verson
3527: F4C5         ;?	LD		A,VERSION
3528: F4C5         ;?	LD		(exitParameterByte),A 				;exitParameterByte = VERSION (high = 00)
3529: F4C5         ;?	RET
3530: F4C5         ;************Error message World*************************
3531: F4C5             errSelect:
3532: F4C5 21 E4 F4               LD     HL,evSelection
3533: F4C8 C3 DD F4               JP     GoToError
3534: F4CB             errReadOnlyDisk:
3535: F4CB 21 E6 F4               LD     HL,evReadOnlyDisk
3536: F4CE C3 DD F4               JP     GoToError
3537: F4D1             errReadOnlyFile:
3538: F4D1 21 E8 F4               LD     HL,evReadOnlyFile
3539: F4D4 C3 DD F4               JP     GoToError
3540: F4D7             errPermanent:
3541: F4D7 21 E2 F4               LD     HL,evPermanent
3542: F4DA C3 DD F4               JP     GoToError
3543: F4DD         ;************Error message handler **********************
3544: F4DD             GoToError:
3545: F4DD         ;HL = .errorhandler, call subroutine
3546: F4DD 5E                     LD     E,(HL)
3547: F4DE 23                     INC    HL
3548: F4DF 56                     LD     D,(HL)               ; address of routine in DE
3549: F4E0 EB                     EX     DE,HL
3550: F4E1 E9                     JP     (HL)                 ; vector to subroutine
3551: F4E2         ;************ Error Vectors *****************************
3552: F4E2 F0 F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3553: F4E4 FC F4       evSelection: DW     erSelection          ; selerr select error subroutine
3554: F4E6 02 F5       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3555: F4E8 08 F5       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3556: F4EA         ;************Error Routines ******************************
3557: F4EA             erPermanentNoWait:
3558: F4EA 21 3A F5               LD     HL,emPermanent
3559: F4ED C3 DD F4               JP     GoToError
3560: F4F0             erPermanent:
3561: F4F0 21 3A F5               LD     HL,emPermanent
3562: F4F3 CD 11 F5               CALL   displayAndWait       ; to report the error
3563: F4F6 FE 03                  CP     CTRL_C
3564: F4F8 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3565: F4FB C9                     RET                         ; and ignore the error
3566: F4FC         ;
3567: F4FC             erSelection:
3568: F4FC 21 45 F5               LD     HL,emSelection
3569: F4FF C3 0B F5               JP     waitB4boot           ; wait console before boot
3570: F502         ;
3571: F502             erReadOnlyDisk:
3572: F502 21 51 F5               LD     HL,emReadOnlyDisk
3573: F505 C3 0B F5               JP     waitB4boot           ; wait console before boot
3574: F508         ;
3575: F508             erReadOnlyFile:
3576: F508 21 4C F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3577: F50B         ;
3578: F50B         ; wait for response before boot
3579: F50B             waitB4boot:
3580: F50B CD 11 F5               CALL   displayAndWait
3581: F50E C3 00 00               JP     WarmBoot
3582: F511
3583: F511         ;report error to console, message address in HL
3584: F511             displayAndWait:
3585: F511 E5                     PUSH   HL                   ; save message pointer
3586: F512 CD D3 E9               CALL   showCRLF             ; stack mssg address, new line
3587: F515 3A 56 F5               LD     A,(currentDisk)
3588: F518 C6 41                  ADD    A,ASCII_A
3589: F51A 32 36 F5               LD     (emDisk),A           ; Problem disk name
3590: F51D 01 2A F5               LD     BC,emDisk0
3591: F520 CD 38 E9               CALL   Print                ; the error message
3592: F523 C1                     POP    BC
3593: F524 CD 38 E9               CALL   Print                ; error mssage tail
3594: F527 C3 1E E9               JP     ConIn                ; to get the input character
3595: F52A         ;ret
3596: F52A         ;**************Error Messages*******************************
3597: F52A 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3598: F536 20 3A 20 24     emDisk:    DB     ' : $'
3599: F53A 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3600: F545 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3601: F54C 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3602: F551 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3603: F555         ;*****************************************************************
3604: F555
3605: F555         ;********* file control block (fcb) constants ********************
3606: F555             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3607: F555             fcbROfileIndex EQU    09H                  ; high order of first type char
3608: F555             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3609: F555             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3610: F555             fcbS1Index EQU    0DH                  ;13				; S1 index
3611: F555             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3612: F555             fcbRCIndex EQU    0FH                  ;15				; record count field index
3613: F555             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3614: F555
3615: F555             fcbCurrentRecord EQU    21H                  ;33
3616: F555
3617: F555             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3618: F555
3619: F555             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3620: F555             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3621: F555             dirEntryMask EQU    dirEntriesPerRecord-1
3622: F555             fcbShift   EQU    5                    ; log2(fcbLength)
3623: F555         ;
3624: F555
3625: F555
3626: F555
3627: F555             maxExtValue EQU    31                   ; largest extent number
3628: F555             moduleMask EQU    15                   ; limits module number value
3629: F555             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3630: F555             nameLength EQU    15                   ; namlen name length
3631: F555
3632: F555             emptyDir   EQU    0E5H                 ; empty empty directory entry
3633: F555             NEXT_RECORD EQU    fcbLength            ; nxtrec
3634: F555             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3635: F555         ;
3636: F555         ;	reserved file indicators
3637: F555         ;	equ	11				; reserved
3638: F555         ;*****************************************************************
3639: F555         ;*****************************************************************
3640: F555
3641: F555         ;***common values shared between bdosi and bdos******************
3642: F555 00          currentUserNumber: DB     0                    ; usrcode current user number
3643: F556         ; paramDE:			DS	2					; ParamsDE information address
3644: F556         ; exitParameterByte:
3645: F556         ; exitParameterWord:	DS	2					; address value to return
3646: F556 FF          currentDisk: DB     -1                   ; curdsk current disk number
3647: F557         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3648: F557
3649: F557         ;********************* Local Variables ***************************
3650: F557         ;     ************************
3651: F557         ;     *** Initialized Data ***
3652: F557
3653: F557 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3654: F558 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
3655: F55A 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3656: F55C 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3657: F55E
3658: F55E         ;     *** Current Disk attributes ****
3659: F55E         ; These are set upon disk select
3660: F55E         ; data must be adjacent, do not insert variables
3661: F55E         ; address of translate vector, not used
3662: F55E         ; ca - currentAddress
3663: F55E
3664: F55E 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3665: F560 00 00       caTrack:   DW     0000H                ; curtrka current track address
3666: F562 00 00       caSector:  DW     0000H                ; current Sector
3667: F564             caListSizeStart:
3668: F564 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3669: F566 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3670: F568 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3671: F56A 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3672: F56C             caListSizeEnd:
3673: F56C             caListSize EQU    caListSizeEnd - caListSizeStart
3674: F56C
3675: F56C         ;     ***** Disk Parameter Block *******
3676: F56C         ; data must be adjacent, do not insert variables
3677: F56C         ; dpb - Disk Parameter Block
3678: F56C             dpbStart:
3679: F56C 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3680: F56E 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3681: F56F 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3682: F570 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3683: F571 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3684: F573 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3685: F575 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3686: F577 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3687: F579 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3688: F57B             dpbEnd:
3689: F57B             dpbSize    EQU    dpbEnd - dpbStart
3690: F57B         ;
3691: F57B
3692: F57B         ;     ************************
3693: F57B
3694: F57B 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3695: F57D 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3696: F57E 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3697: F57F 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3698: F580 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3699: F581 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3700: F582 00          searchLength: DB     00H                  ; searchl search length
3701: F583 00 00       searchAddress: DW     0000H                ; searcha search address
3702: F585         ;tinfo:	ds	word							; temp for info in "make"
3703: F585 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3704: F586 00          fResel:    DB     00H                  ; resel reselection flag
3705: F587 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3706: F588 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3707: F589 00          fcbRecordCount: DB     00H                  ; record count from current FCB
3708: F58A 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3709: F58B 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3710: F58D 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3711: F58F         ;
3712: F58F         ;	local variables for directory access
3713: F58F 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3714: F590 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3715: F592 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3716: F594
3717: F594         ;********************** data areas ******************************
3718: F594
3719: F594
3720: F594         ;---------------------------------- Stack Area--------------------------------;
3721: F594             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3722: F5D4             bdosStack:
3723: F5D4         ;
3724: F5D4         ;---------------------------------- Stack Area--------------------------------;
3725: F5D4         ;	end of Basic I/O System
3726: F5D4         ;-----------------------------------------------------------------;
3727: F5D4
3728: F5D4
3729: F5D4         ;
3730: F5D4             Z_HighestLocation:
3731: F5D4             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3732: F5D4
3733: F5D4
           ************************   Xref   ************************
0000: $               F5D4   0414 0444
3710: absoluteCPMRecord F58D   2279 2286 2304 2617 3061 3066 3075 3088
3409: AddAtoHL        F46D   2627
2631: Allocate16Bit   F097   2625
1041: AreWeAtEndOfBuffer EA37   1037
0083: ASCII_A         0041   3588
0084: ASCII_C         0043
0085: ASCII_K         004B
0092: ASCII_LO_A      0061
0093: ASCII_LO_K      006B
0094: ASCII_LO_P      0070
0035: ASCII_MASK      007F   0984
0086: ASCII_N         004E
0087: ASCII_Q         0051
0088: ASCII_R         0052
0089: ASCII_W         0057
0090: ASCII_Y         0059
0070: ASCII_ZERO      0030
0064: ASTERISK        002A
1133: BackUp          EA9C   1061 1129
1138: BackUp1         EAA4   1134
0292: bcBoot          F600
0295: bcConin         F609   0614 0799 0910 0928
0296: bcConout        F60C   0606 0872 1136 1140 1146 1148
0294: bcConst         F606   0611 0906
0300: bcHome          F618   1957
0297: bcList          F60F   0579 0878
0307: bcListst        F62D
0298: bcPunch         F612   0564
0305: bcRead          F627   2004
0299: bcReader        F615   0545
0308: bcSectran       F630
0301: bcSeldsk        F61B   1702
0304: bcSetdma        F624   1999
0303: bcSetsec        F621   2319
0302: bcSettrk        F61E   1963 2316
0293: bcWboot         F603   0465
0306: bcWrite         F62A   2977
0150: BDOSBase        E800   0151 0153 0324
0119: BDOSE           0005   0120
0151: BDOSEntry       E800
0140: BDOSLength      0E00   0143 0153 0154
3722: bdosStack       F5D4
0330: BdosStart       E800
0053: BELL            0007
0153: BIOSBase        F600
0141: BIOSLength      0A00   0143
0113: BIOSPAGE        0002
0154: BIOSStart       F600   0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 3731
2616: BlockOK         F07B   2610
0250: BlockSize       0800   0272
1056: BSspaceBS       EA45   0995
0031: BYTE            0001   1169
3703: byteAllocationFlag F585   1735 1867 2622 2875 3390
3671: caAllocVector   F56A   1291 1755 1757 1782 1932 2085
3670: caCheckSum      F568   2347
3668: caDirectoryDMA  F564   1722 1991 2126 2339 3316
3664: caDirMaxValue   F55E   1713 1792 2022 2161
3669: caDiskParamBlock F566   1325 1727
3673: caListSize      0008   1723
3672: caListSizeEnd   F56C   3673
3667: caListSizeStart F564   3673
0091: CARET           005E   0838
0832: CaretOut        E945   1030 1111
3666: caSector        F562   1719 1971 2308
3694: caSkewTable     F57B   1711
3665: caTrack         F560   1716 1967 2299
0148: CCPEntry        E000   0150 0154
0139: CCPLength       0800   0143 0150 0154
0924: CheckCTL_S      E9A9   0913
2490: CheckRODirectory EFC7   2792 2843
2495: CheckROFile     EFCA   2574
2327: CheckSumUtility EF0F   2271 2963
2504: CheckWrite      EFD4   2572 2777 2802 2835
3100: ClearModuleNum  F2E7   2406 2427 2473
2853: CloseDirEntry   F1D1   1495 2414 2709
2874: CloseDirEntry1  F1F6   2920
2888: CloseDirEntry2  F204   2885
2894: CloseDirEntry3  F20A   2890
2900: CloseDirEntry4  F211   2877
2916: CloseDirEntry5  F226   2897
2941: CloseDirEntryEnd F240   2930
2948: CloseDirEntryError F249   2896 2908 2913
0071: COLON           003A
1167: columnPosition  EABE   0857 0882 0947 0967 1125
0066: COMMA           002C
3297: CompareExtents  F3FB   3249
2337: ComputeCheckSum EF1B
2341: ComputeCheckSum1 EF22   2344
0125: ComTail         0080   0126
0127: ComTailChars    0082
0126: ComTailCount    0081   0127
0901: ConBreak        E989   0725 0868
0934: ConBreak0       E9B7   0926
0936: ConBreak1       E9BA   0904
0792: ConIn           E91E   0497 0983 3594
0865: ConsoleOut      E968   0839 0851 0856 0944 0952 0959 0961 1053
3329: CopyDir         F41F   2392 2795 3326
3315: CopyDirEntryToUser F40C   2432 2442
3323: CopyFCB         F418   2829
0227: cpmRecordSize   0080   0229 0232 0234 2338 3319 3619
0056: CR              000D   0805 0958 0988 1052
0039: CTRL_C          0003   0929 1035 3563
0040: CTRL_E          0005   1000
0041: CTRL_H          0008   0811 0994 1139
0042: CTRL_K          000B
0043: CTRL_L          000C
0044: CTRL_P          0010   0912 1003
0045: CTRL_R          0012   1012
0046: CTRL_S          0013   0925
0047: CTRL_U          0015   1009
0048: CTRL_X          0018   1006
0049: CTRL_Z          001A
3646: currentDisk     F556   1204 1253 1669 1680 1686 1700 1833 2015 2512 3125 3587
3709: currentFileRecord F58B   2039 2375 2531 2541 2576 2660 2697 3084 3348
3642: currentUserNumber F555   0776 0782 1810 3134
0067: DASH            002D
0261: DataBlocks      02C7   0271
0260: DataSectors     0B1C   0261
2834: DeleteFile      F1AF   2449
2838: DeleteFile1     F1B7   2850
1120: DeleteTheLine   EA8B   1007
1123: DeleteTheLine1  EA8C   1130
3416: DEminusHL2HL    F472
3713: dirBlockIndex   F58F   2127 2263
0232: DirBuffSize     0080
0247: DirectoryBlockCount 0002   0272
0234: DirectoryEntryPerRecord 0004   0275
3697: directoryFlag   F57F   3095 3193 3267
3619: dirEntriesPerRecord 0004   3621
3714: dirEntryIndex   F590   2112 2159 2222 2246 2248 2257 2276 3263
3621: dirEntryMask    0003   2258 3264
3620: dirEntryShift   0002   2277
0231: DirEntrySize    0020   0234 0272
3094: DirLocationToReturnLoc F2E0   1664 2450 2484
3715: dirRecord       F592   2280 2329 2348
0219: DiskCommandBlock 0046
0218: DiskControlByte 0045
0221: DiskControlTable 0040
2558: DiskEOF         F029   2538 2545 2551
0414: diskf           000B
3699: diskMapIndex    F581   2594 2624
2526: DiskRead        EFEE   1424
0223: DiskReadCode    0001
0228: diskSectorSize  0200   0229 0250 0258
0217: DiskStatusLocation 0043
2568: DiskWrite       F031   1431
2583: DiskWrite1      F04E   2578
2641: DiskWrite2      F09F   2629
2647: DiskWrite3      F0A1   2587
2668: DiskWrite4      F0C1   2663
2679: DiskWrite5      F0CE   2672
2698: DiskWrite6      F0EC   2694
2700: DiskWrite7      F0EE   2682 2686
0224: DiskWriteCode   0002
2563: DiskWriteSeq    F02C   2465
3584: displayAndWait  F511   3562 3580
2191: DivideHLby8     EE70   1750
0130: DMABuffer       0080   1206 3656
0060: DOLLAR          0024   0820 1816
0273: dpb3hdAL0       00C0
0274: dpb3hdAL1       0000
0269: dpb3hdBLM       000F
0268: dpb3hdBSH       0004
0275: dpb3hdCKS       0020
0272: dpb3hdDRM       007F   0275
0271: dpb3hdDSM       02C6
0270: dpb3hdEXM       0000
0277: dpb3hdNOH       0002
0276: dpb3hdOFF       0001
0267: dpb3hdSPT       0090
3681: dpbBLM          F56F   3082
3680: dpbBSH          F56E   3074 3346
3686: dpbCKS          F577   2328
3685: dpbDABM         F575   1780
3684: dpbDRM          F573   2020 2245
3683: dpbDSM          F571   1733 1749 1765 3024
3688: dpbEnd          F57B   3689
3682: dpbEXM          F570   2044 2723 3300
3687: dpbOFF          F579   1959 2312
3689: dpbSize         000F   1729
3679: dpbSPT          F56C   2287
3678: dpbStart        F56C   1728 3689
0446: DUMMY           E8A6   0441 0442
3598: emDisk          F536   3589
3597: emDisk0         F52A   3590
3599: emPermanent     F53A   3558 3561
3632: emptyDir        00E5   1806 2845 3213 3653
3653: emptyFCB        F557   2805
3602: emReadOnlyDisk  F551   3572
3601: emReadOnlyFile  F54C   3576
3600: emSelection     F545   3568
0134: END_OF_FILE     001A
3262: EndDirElementSearch F3D4   3228
2221: EndOfDirectory  EE84   1574 1802 2388 2711 2746 2755 2789 2809 2840 2864 3144 3207
0037: EndOfMessage    0000
1046: EndRead         EA3B   0989 0992
3705: entryDisk       F587   0387 3126
0289: EOD             FFFF   2111
0075: EQUAL_SIGN      003D
3560: erPermanent     F4F0   3552
3557: erPermanentNoWait F4EA   2006 2979
3571: erReadOnlyDisk  F502   3554
3575: erReadOnlyFile  F508   3555
3540: errPermanent    F4D7
3534: errReadOnlyDisk F4CB   2507
3537: errReadOnlyFile F4D1   2501
3531: errSelect       F4C5   1679
3567: erSelection     F4FC   3553
3552: evPermanent     F4E2   3541
3554: evReadOnlyDisk  F4E6   3535
3555: evReadOnlyFile  F4E8   3538
3553: evSelection     F4E4   3532
0058: EXCLAIM_POINT   0021
1171: exitParameterByte EAC2   0506 0615 0726 0752 0777 1254 1499 1509 1520 1527 1540 1820 2543 2613 2648 2691 2765 2855 2949 3096 3265 3280 3293
1172: exitParameterWord EAC2   0343 0394 0546 0635 1231 1292 1311 1326
3708: extentValue     F58A   2046 3360
0026: FALSE           0000   0919 1091 1429 1739 2569 2846 3205
0122: FCB1            005C   0123
0123: FCB2            006C
3695: fcbCopiedFlag   F57D   2708 2726 2943
3615: fcbCurrentRecord 0021
3706: fcbDisk         F588   0345 0382 3128
3613: fcbDiskMapIndex 0010   1856 1858 2620 2784 2793 2868 2873 3387
3609: fcbExtIndex     000C   1478 1502 1561 1613 2065 2385 2391 2714 2734 2779 2794 2836 2922 2934 3162 3237
3608: fcbHiddenfileIndex 000A
3606: fcbLength       0020   1858 2817 2873 2922 3325 3619 3633
3612: fcbRCIndex      000F   1578 2054 2057 2934 3165 3184
3707: fcbRecordCount  F589   2042 2379 2532 2661
3607: fcbROfileIndex  0009   2496
3610: fcbS1Index      000D   2824 3234
3611: fcbS2Index      000E   1484 1505 1630 2734 3108
3622: fcbShift        0005   2259
0167: fCloseFile      0010
0158: fConsoleIn      0001
0159: fConsoleOut     0002
0170: fDeleteFile     0013
0162: fGetConsoleStatus 000B
0176: fGetCurrentDisk 0019
0175: fGetLoginVector 0018
0178: fGetSetUserNumber 0020
0163: fGetVersion     000C
2605: FirstBlock      F06D   2597
0173: fMakeFile       0016
0166: fOpenFile       000F
0160: fPrintString    0009
0171: fReadSeq        0014
0161: fReadString     000A
0174: fRenameFile     0017
3704: fResel          F586   0346 0376 3116
0164: fResetSystem    000D
0168: fSearchFirst    0011
0169: fSearchNext     0012
0165: fSelectDisk     000E
0177: fSetDMA         001A
0444: functionCount   0028   0355
0401: functionTable   E854   0360 0414 0444
0172: fWriteSeq       0015
1905: GetAllocBit     ED70   3017 3035
1936: GetAllocBitl    ED91   1939
3056: GetBlockNumber  F2B4   2549 2584
3006: GetClosestBlock F27A   2606
2118: GetDirElementAddress EE3F   1577 1805 1855 2491 2844 2867 3153 3221 3335
3396: GetDiskMap16Bit F467   3392
3345: GetDiskMapIndex F434   2593 3057
3349: GetDiskMapIndex1 F43B   3353
3361: GetDiskMapIndex2 F449   3368
3371: GetDiskMapIndex3 F452   3365
3385: GetDiskMapValue F454   2601 3060
2063: GetExtentAddress EE0A   2043 3149
2052: GetFcbRecordDetails EDFD   2036 2372
1560: GetFileSize     EBD9   1395
1573: GetFileSize1    EBEB   1601
1599: GetFileSize2    EC0D   1592
1602: GetFileSizeExit EC13   1575
3106: GetModuleNum    F2ED   1534 2674 2859 3101 3285
1607: GetRandomRecordPosition EC15   1549 1579
3544: GoToError       F4DD   3533 3536 3539 3542 3559
0076: GREATER_THAN    003E
0059: HASH_TAG        0023   0943
3617: highestRecordNumber 007F   2577 2681
1956: Home            ED9E   1791 3199
1143: IgnoreTheLine   EAA9   1010
3656: initDAMAddress  F55C   1207 1275 1985 3318
1748: InitDisk        ECC1   1692
1798: InitDisk1       ED06   1808 1826
1821: InitDisk2       ED27   1812 1817
0114: IOBYTE          0003   0634 0654
3065: IsAllocated     F2C1   2550 2585
3466: IsBitSet        F497   1683 3488 3500
3473: IsBitSet1       F49E   3471
3468: IsBitSetLoop    F498   3476
2510: IsDiskWriteProtected EFDB   2505 2856
1008: IsItDeleteTheLineU EA16
1005: IsItDeleteTheLineX EA11
1002: IsItPrintToggle EA0C
1092: IsItPrintToggle1 EA6D   1090
0996: IsItRubout      EA02
0999: IsPhysicalEOL   EA07
0804: IsPrintableASCII E929   0498 0834
1077: ItIsPhysicalEOL EA5A   1001
1084: ItIsPrintToggle EA62   1004
1065: ItIsRubout      EA4F   0998
1161: keyboardByte    EABB   0793 0902 0935
0062: L_PAREN         0028
2092: Left            EE29   2094
0079: LEFT_ARROW      005F
0095: LEFT_CURLY      007B
0143: LengthInBytes   2000   0144 0148 0258
0144: LengthInK       0009
0074: LESS_THAN       003C
0055: LF              000A   0807 0888 0960 0990
1106: LL1             EA7B   1114
0029: LO_NIBBLE_MASK  000F   0781 1626
3655: loggedDisks     F55A   1202 1230 1682 1688 1690
2801: MakeNewFile     F179   1518 2475 2753
2819: MakeNewFile1    F19B   2823
1778: Mark4Directory  ECEE   1770
3627: maxExtValue     001F   2718 3310
0146: MemorySize      0040   0148
2985: Merge           F26C   2901 2903
3628: moduleMask      000F   2739
3448: Move            F48D   3158 3320 3337
3450: Move0           F48E   3457
2203: MultiplyHLby8   EE7A   1764
0259: myOffset        0001   0260 0276
3630: nameLength      000F   2429 2744 2815 2817 2862 3142
3633: NEXT_RECORD     0020   1473 1548 2057 3156 3634
3132: NoSelect        F31A   3123
0931: NothingWaiting  E9B5   0922
0051: NULL            0000
0243: NumberOfHeads   0002   0254 0256 0267 0277
0240: NumberOfLogicalDisks 0004
0028: OFF             0000
0027: ON              FFFF
3141: OpenFile        F323   1508 2408
3148: OpenFileCopyFCB F32C   2761
2706: OpenNextExt     F0F1   2539 2689
2743: OpenNextExt1    F125   2728
2760: OpenNextExt2    F143   2730 2747
2762: OpenNextExt3    F146   2757
2769: OpenNextExtError F14E   2740 2751 2756
2733: OpenNextModule  F11A   2720
3182: OpenRecordCount F35D   3178 3180
1170: paramDE         EAC0   0335 0380 0677 0969 1048 1103 1274 1442 1547 1564 2053 2064 2422 2439 2573 2619 2713 2782 2803 2806 2811 2871 3107 3117 3135 3155 3183 3196 3332 3386
1169: paramE          EABF   0337 0388 0773 1668 3121
0061: PERCENT         0025
0068: PERIOD          002E
0117: Pg0CurentDisk   0004
0116: Pg0CurentUser   0004   0117
0065: PLUS_SIGN       002B
0818: Print           E938   0680 0827 3591 3593
1163: printEchoFlag   EABC   0876 0915 1087
0077: QMARK           003F   2424 3230
2430: QMarkSelect     EF89   2425
0063: R_PAREN         0029
0110: RAM             0000   0112 0113 0114 0116 0119 0122 0125 0130 0132
3634: RANDOM_REC_FIELD 0021   1444 1550 1565
1421: RandomDiskRead  EB23   1376
1428: RandomDiskWrite EB2C   1388
1438: RandomSeek      EB35   1423 1430
1492: RandomSeekClose EB79   1482
1537: RandomSeekError EBBE   1471
1530: RandomSeekErrorBadSeek EBB7   1501 1517 1522
1524: RandomSeekExit  EBB1   1491 1511
2003: ReadBuffer      EDC6   2235 2555
2244: ReadDirectory   EE96   1801 3206
2256: ReadDirectory0  EEAA   2251
2260: ReadDirectory1  EEB1   2262
2233: ReadDirRecord   EE8D   2269
1026: ReadEchoRubOut  EA23   1074
3696: readModeFlag    F57E   2528 2570 2749
0979: ReadNext        E9EA   1043 1069 1095 1117
0982: ReadNext0       E9EC   1062 1081
3654: readOnlyVector  F558   1201 1310 2013 2018 2511
2520: ReadSeq         EFE9   2457
0966: ReadString      E9DD   0710 1127 1149
3516: ReAlignMap1     F4BE   3514
3511: ReAlignMapLoop  F4B8   3519
3509: ReAlignVector   F4B7   3492
2548: RecordOK        F013   2535
0252: RecordsPerBlock 0010
0236: RecordsPerExtent 0080   2537 3181 3617
0229: recordsPerSector 0004   0252 0267
2776: Rename          F154   2483
2788: Rename1         F165   2798
1098: RepeatLine      EA72   1013
3114: Reselect        F2F6   1375 1387 1394 1662 2407 2413 2428 2440 2448 2456 2464 2474 2482
3498: ResetVectorBit  F4B0
3041: ReturnBlockNumber F2A8   3019 3037
3051: ReturnBlockZero F2B0   3029
0375: ReturnToCaller  E82F   0349
0391: ReturnToCaller1 E84A   0378 0384 0613
2100: Right           EE33   2098 2102
1947: RotateAndReplace ED97   1950 3045
2177: RotateRightHLbyB EE63   2185
2182: RotateRightHLbyB1 EE69   2180
0080: RUBOUT          007F   0997
1853: ScanDiskMap     ED44   1824 2847
1861: ScanDiskMap0    ED4E   1893
1886: ScanDiskMap2    ED65   1875
1877: ScanDiskMapWord ED5F   1869
3191: Search4DirElement F366   1562 2386 2431 2745 2780 2808 2837 2863 3143
3246: Search4Ext      F3C4   3239
3204: Search4NextDirElement F37E   1600 2393 2441 2797 2849 3200 3242 3251
3220: Search4NextDirElement1 F39B   3214
3225: Search4NextLoop F3A4   3259
3254: Search4NextOK   F3CD   3231 3235 3243
3701: searchAddress   F583   2438 3197 3210
3277: SearchDone      F3E5   3208 3219
3700: searchLength    F582   3194 3222
0281: SectorMask      0003
0246: SectorsPerBlock 0004   0250 0252 0255 0261 0281
0256: SectorsPerCylinder 0024   0259 0260
0245: SectorsPerTrack 0012   0254 0256 0267
2284: Seek            EED5   2281 2554 2654
2289: Seek0           EEDF   2293
3339: SeekAndCopy     F42E
2954: SeekCopy        F24E   2944
2275: SeekDir         EEC4   2268 2955 3340
1677: Select          EC5A   1209 1673
1667: SelectCurrent   EC4E   0389 1361 3131
1699: SelectDisk      EC7B   1678
1742: SelectDisk1     ECBD   1738
0073: SEMICOLON       003B
3698: seqReadFlag     F580   1440 2373 2522 2565 2684
3073: SetActualRecordAdd F2C7   2553 2653
3077: SetActualRecordAdd1 F2CD   3080
2384: SetAttributes   EF51   1663
2387: SetAttributes1  EF56   2394
1773: SetBitLoop      ECE9   1776
1831: SetCurrentDiskBit ED31
1984: SetDataDMA      EDB8   1208 1276 2236 2968
1990: SetDirDMA       EDBD   2234 2965
2138: SetDirectoryEntry EE4D   1825 2827
2012: SetDiskReadOnly EDCE   1658 2359
1995: SetDMA          EDC0   1986
2110: SetEndDirectory EE38   1796 2252 3198 3278
3284: SetFileWriteFlag F3EE   1542 2771 2831 3160
3291: SetLowReturnTo1 F3F5   2559 2579 2770
2363: SetNewCheckSum  EF3D   2352
1546: SetRandomRecord EBC6   1401
2035: SetRecordVars   EDE6   2530 2575 2763
2074: SetResetMapBit  EE12   1889
0780: SetUserNumber   E918   0775
3486: SetVectorBit    F4A7   1689 2017
2206: ShiftLeftHLbyB  EE7C   2210
3439: ShiftLeftHLbyC  F486   1836
3441: ShiftLeftHLbyC0 F487   3445
2194: ShiftRightHLbyB EE72   2084 2198 2278
3425: ShiftRightHLbyC F479   2514
3427: ShiftRightHLbyC0 F47A   3437
0957: showCRLF        E9D3   0945 1080 3586
0942: showHashCRLF    E9BD   1101 1144
0946: showHashCRLF1   E9C5   0953
0069: SLASH           002F
0052: SOH             0001
0057: SPACE           0020   0813 0855 0885 0951 1135 1145 1147
0288: STACK_SIZE      0020   3721
3721: stackBottom     F594
1166: startingColumn  EABD   0948 0968 1124
2158: StillInDirectory EE56   2139 2357 3217
0258: SystemSectors   0011   0259
0054: TAB             0009   0809 0850
0848: TabOut          E955   0503 0525 0825 0835
0854: TabOut0         E95B   0859
3009: TestLeft        F27C   3040
3023: TestRight       F28D   3012
0920: ToggleFlag1     E9A6   0918
0120: TopRAM          0007
0255: TotalNumberOfBlocks 02D0
0254: TotalNumberOfSectors 0B40   0255 0260
0132: TPA             0100
0244: TracksPerHead   0050   0254
0025: TRUE            FFFF   0916 0937 1088 1422 1736 1743 1800 1823 2527 2942 2962 3115
0078: UNDER_SCORE     005F
2371: UpdateRecordVars EF3F   2556 2688 2701
1159: usersStack      EAB9   0339 0392
2412: vCloseFile      EF70   0419
1393: vComputeFileSize EB19   0438
0496: vConsoleIn      E8AA   0403
0524: vConsoleOut     E8BB   0404
2447: vDeleteFile     EF9E   0422
0601: vDirectConIO    E8CE   0408
0610: vDirectConIO1   E8D6   0604
0287: VERSION         0020   0751
2420: vFindFirst      EF76   0420
2437: vFindNext       EF8F   0421
1290: vGetAllocAddr   EAF4   0430
0724: vGetConsoleStatus E8FD   0413
1252: vGetCurrentDisk EAE4   0428
1324: vGetDiskParamBlock EB02   0434
0633: vGetIOBYTE      E8E4   0409
1229: vGetLoginVector EADD   0427
1309: vGetReadOnlyMap EAFB   0432
0772: vGetSetUserNumber E90A   0435
0750: vGetVersion     E904   0415
0578: vListOut        E8CA   0407
2472: vMakeFile       EFB5   0425
2405: vOpenFile       EF67   0418
0676: vPrintString    E8F0   0411
0563: vPunchOut       E8C6   0406
0544: vReaderIn       E8BF   0405
1374: vReadRandom     EB0D   0436
2455: vReadSeq        EFA7   0423
0709: vReadString     E8F9   0412
2481: vRenameFile     EFBE   0426
1352: vResetDrive     EB09   0440
1199: vResetSystem    EAC4   0416
1360: vSelectDisk     EB0A   0417
1273: vSetDMA         EAEB   0429
1661: vSetFileAttributes EC45   0433
0653: vSetIOBYTE      E8EB   0410
1400: vSetRandomRecord EB1F   0439
0464: vSystemReset    E8A7   0402
1657: vWriteProtectDisk EC42   0431
1386: vWriteRandom    EB13   0437
1414: vWriteRandom0Fill EB22   0443
2463: vWriteSeq       EFAE   0424
3579: waitB4boot      F50B   3569 3573
0112: WarmBoot        0000   0930 1039 3564 3581
0032: WORD            0002   1170 1172
0192: WriteAllocated  0000   2586
2976: WriteBuffer     F264   2657 2967
0194: WriteCleanBuffer 0002   2642
2960: WriteDir        F254   2848 2956 3341
0193: WriteDirectory  0001
3629: writeFlagMask   0080   2860 3286
3730: Z_HighestLocation F5D4   3731
3731: Z_MemoryLeft    002B
0036: ZERO            0000
