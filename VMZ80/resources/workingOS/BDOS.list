0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process Search For first (11H)
0005: E800
0006: E800         ; 2019-02-04 Fixed bdosStack problem
0007: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0008: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0009: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0010: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0011: E800         ; 2018-03-02 Refactored the CP/M Suite
0012: E800         ; 2018-02-12 fixed allocate 16 bit problem
0013: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0014: E800         ; 2014-03-14  :  Frank Martyn
0015: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0016: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.asm
0023: E800         ; standard equates
0024: E800
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; not false
0029: E800             FALSE      EQU    0000H
0030: E800             ON         EQU    -1
0031: E800             OFF        EQU    0000H
0032: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0033: E800
0034: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0035: E800             WORD       EQU    2                    ; number of bytes for "word" type
0036: E800
0037: E800
0038: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0039: E800             ZERO       EQU    00H                  ; Zero
0040: E800             EndOfMessage EQU    00H
0041: E800
0042: E800             CTRL_C     EQU    03H                  ; ETX
0043: E800             CTRL_E     EQU    05H                  ; physical eol
0044: E800             CTRL_H     EQU    08H                  ; backspace
0045: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0046: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0047: E800             CTRL_P     EQU    10H                  ; prnt toggle
0048: E800             CTRL_R     EQU    12H                  ; repeat line
0049: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0050: E800             CTRL_U     EQU    15H                  ; line delete
0051: E800             CTRL_X     EQU    18H                  ; =ctl-u
0052: E800             CTRL_Z     EQU    1AH                  ; end of file
0053: E800
0054: E800             NULL       EQU    00H                  ; Null
0055: E800             SOH        EQU    01H                  ; Start of Heading
0056: E800             BELL       EQU    07H                  ; Bell
0057: E800             TAB        EQU    09H                  ; Tab
0058: E800             LF         EQU    0AH                  ; Line Feed
0059: E800             CR         EQU    0DH                  ; Carriage Return
0060: E800             SPACE      EQU    20H                  ; Space
0061: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0062: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0064: E800             PERCENT    EQU    25H                  ; Percent Sign
0065: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0066: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0067: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0068: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0069: E800             COMMA      EQU    2CH                  ; Comma
0070: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0071: E800             PERIOD     EQU    2EH                  ; Period
0072: E800             SLASH      EQU    2FH                  ; /
0073: E800             ASCII_ZERO EQU    30H                  ; zero
0074: E800             COLON      EQU    3AH                  ; Colon
0075: E800
0076: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0077: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0078: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0079: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0080: E800             QMARK      EQU    3FH                  ; Question Mark
0081: E800             UNDER_SCORE EQU    5FH                  ; under score _
0082: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0083: E800             RUBOUT     EQU    7FH                  ; Delete Key
0084: E800
0085: E800
0086: E800             ASCII_A    EQU    'A'
0087: E800             ASCII_C    EQU    'C'
0088: E800             ASCII_K    EQU    'K'
0089: E800             ASCII_N    EQU    'N'
0090: E800             ASCII_Q    EQU    'Q'
0091: E800             ASCII_R    EQU    'R'
0092: E800             ASCII_W    EQU    'W'
0093: E800             ASCII_Y    EQU    'Y'
0094: E800             CARET      EQU    '^'
0095: E800             ASCII_LO_A EQU    'a'
0096: E800             ASCII_LO_K EQU    'k'
0097: E800             ASCII_LO_P EQU    'p'
0098: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0099: E800
0100: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E800                        Include ./osHeader.Z80
0102: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0103: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0104: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0105: E800         ; osHeader.Z80
0106: E800
0107: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0108: E800         ; 2017-03-02 Refactored the CP/M Suite
0109: E800
0110: E800         ; Contains the Equates used by the CP/M system
0111: E800
0112: E800         ;------------------------Page Zero Constants ---------------------------------
0113: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0114: E800
0115: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0116: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0117: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0118: E800
0119: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0120: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0121: E800
0122: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0123: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0124: E800
0125: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0126: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0127: E800
0128: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0129: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0130: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0131: E800         ;-----------------------------------------------------------------------
0132: E800
0133: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0134: E800         ;-----------------------------------------------------------------------
0135: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0136: E800         ;-----------------------------------------------------------------------
0137: E800             END_OF_FILE EQU    1AH                  ; end of file
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;--------------- CP/M Constants -----------------------------------------
0141: E800
0142: E800             CCPLength  EQU    0800H                ; Constant
0143: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0144: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0145: E800
0146: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0147: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0148: E800
0149: E800             MemorySize EQU    64
0150: E800
0151: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0152: E800
0153: E800             BDOSBase   EQU    CCPEntry + CCPLength
0154: E800             BDOSEntry  EQU    BDOSBase
0155: E800
0156: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0157: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0158: E800         ;-----------------------------------------------------------------------
0159: E800
0160: E800         ;------------------- BDOS System Call Equates --------------------------
0161: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0162: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0163: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0164: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0165: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0166: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0167: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0168: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0169: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0170: E800             fCloseFile EQU    10H                  ; closef - Close File
0171: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0172: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0173: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0174: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0175: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0176: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0177: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0178: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0179: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0180: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0181: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0182: E800         ;-----------------------------------------------------------------------
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800
0188: E800         ;*******************************************************************************
0189: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0190: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0191: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0192: E800         ; sector write) or to an allocation block that has already been allocated to a
0193: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0194: E800         ;*******************************************************************************
0195: E800             WriteAllocated EQU    00H
0196: E800             WriteDirectory EQU    01H
0197: E800             WriteCleanBuffer EQU    02H
0198: E800
0199: E800
0200: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E800                        Include ./diskHeader.Z80
0202: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0203: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0204: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0205: E800         ; diskHeader.asm
0206: E800
0207: E800         ; 2017-03-02 Refactored the CP/M Suite
0208: E800
0209: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0210: E800
0211: E800         ; Contains the Equates used by the CP/M system to handle disks
0212: E800
0213: E800
0214: E800         ;*******************************************************************************
0215: E800         ;
0216: E800         ;     Disk related values
0217: E800         ;
0218: E800         ;
0219: E800         ;*******************************************************************************
0220: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0221: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0222: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0223: E800         ; for boot
0224: E800             DiskControlTable EQU    0040H
0225: E800
0226: E800             DiskReadCode EQU    01H                  ; Code for Read
0227: E800             DiskWriteCode EQU    02H                  ; Code for Write
0228: E800
0229: E800
0230: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0231: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0232: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0233: E800
0234: E800             DirEntrySize EQU    20H                  ; (32)
0235: E800             DirBuffSize EQU    cpmRecordSize
0236: E800
0237: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0238: E800
0239: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0240: E800
0241: E800
0242: E800         ;-------------------------------------------------------------------------------------
0243: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0244: E800
0245: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0246: E800             NumberOfHeads EQU    02H                  ; number of heads
0247: E800             TracksPerHead EQU    50H                  ; 80
0248: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0249: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0250: E800             DirectoryBlockCount EQU    02H                  ;
0251: E800         ;-----------------------------------------------------------------------
0252: E800
0253: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0254: E800
0255: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0256: E800
0257: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0258: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0259: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0260: E800
0261: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0262: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0263: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0264: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0265: E800
0266: E800         ;-----------------------------------------------------------------------
0267: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0268: E800         ;-----------------------------------------------------------------------
0269: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0270: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0271: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0272: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0273: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0274: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0275: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0276: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0277: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0278: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0279: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0280: E800             dpb3hdNOH  EQU    NumberOfHeads
0281: E800
0282: E800         ;*******************************************************************************
0283: E800
0284: E800             SectorMask EQU    SectorsPerBlock - 1
0285: E800
0286: E800         ;***************************************************************************
0287: E800
0288: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0289: E800
0290: E800             VERSION    EQU    20H                  ; Version 2.0
0291: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0292: E800             EOD        EQU    -1                   ; End of Directory
0293: E800
0294: E800         ;************************ BIOS Function Constants ***************************;
0295: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	             ;
0296: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                 ;
0297: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function            ;
0298: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function             ;
0299: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function            ;
0300: E800             bcList     EQU    BIOSStart+3*5        ; List Output function               ;
0301: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function              ;
0302: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function              ;
0303: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                 ;
0304: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function               ;
0305: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                 ;
0306: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function                ;
0307: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                   ;
0308: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                 ;
0309: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function                ;
0310: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function               ;
0311: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                   ;
0312: E800         ;************************ BIOS Function Constants ***************************;
0313: E800
0314: E800         ;============================================================================;
0315: E800         ;	BDOS                                                                     ;
0316: E800         ; Calling into   :                                                           ;
0317: E800         ;					Register  C - Contains BDOS Function Code                ;
0318: E800         ;					Register  A - Holds the Byte argument if any             ;
0319: E800         ;					Register DE - Holds the Word argument if any             ;
0320: E800         ; Returning from :                                                           ;
0321: E800         ;					Register  A - The Byte return value if any               ;
0322: E800         ;					Register HL - The Word return value if any               ;
0323: E800         ;                   ( Register A=L and B=H)                                  ;
0324: E800         ;============================================================================;
0325: E800
0326: E800
0327: E800                        ORG    BDOSBase
0328: E800
0329: E800         ;===========================BDOS Entry=======================================;
0330: E800         ;BDOSEntry:                                                                  ;
0331: E800         ;
0332: E800         ;
0333: E800             BdosStart:                      ;
0334: E800         ;	LD		A,C                                                              ;
0335: E800         ; 	LD		(FunctionValue),A			; Save the function number           ;
0336: E800         ;
0337: E800         ; Save Calling Arguments                                                     ;
0338: E800 ED 53 C3 EA               LD     (paramDE),DE         ; Save the Word Argument             ;
0339: E804 7B                     LD     A,E                  ;
0340: E805 32 C2 EA               LD     (paramE),A           ; Save the Byte argument             ;
0341: E808         ; Save users Stack pointer                                                   ;
0342: E808 ED 73 BC EA               LD     (usersStack),SP      ; Save the User's stack				 ;
0343: E80C 31 E5 F5               LD     SP,bdosStack         ; We will use our own stack			 ;
0344: E80F         ;
0345: E80F         ; initialize variables                                                       ;
0346: E80F 21 00 00               LD     HL,0000H             ;
0347: E812 22 C5 EA               LD     (exitParameterWord),HL ; Assume all is well for return      ;
0348: E815 AF                     XOR    A                    ;
0349: E816 32 99 F5               LD     (fcbDisk),A          ; Initialize to 00                   ;
0350: E819 32 97 F5               LD     (fResel),A           ; Clear re selection flag            ;
0351: E81C         ;
0352: E81C         ; Set up for return to caller when Function Completes                        ;
0353: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0354: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller            ;
0355: E820         ;
0356: E820         ; is it a valid function number ?	                                         ;
0357: E820         ;	LD		A,(FunctionValue)			; Get the Function Number            ;
0358: E820 79                     LD     A,C                  ;
0359: E821 FE 28                  CP     functionCount        ; make sure its a good number        ;
0360: E823 D0                     RET    NC                   ; exit if not a valid function       ;
0361: E824         ;
0362: E824         ; Calculate the index and get vector to go to	                             ;
0363: E824 4B                     LD     C,E                  ; Assume byte argument               ;
0364: E825 21 57 E8               LD     HL,functionTable     ; Get table base                     ;
0365: E828 5F                     LD     E,A                  ; Function number in E               ;
0366: E829 16 00                  LD     D,0                  ;
0367: E82B 19                     ADD    HL,DE                ; Have byte location                 ;
0368: E82C 19                     ADD    HL,DE                ;  but we want a Word offset         ;
0369: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                  ;
0370: E82E 23                     INC    HL                   ;
0371: E82F 56                     LD     D,(HL)               ; Get MSB of vector                  ;
0372: E830 EB                     EX     DE,HL                ; Vector now in HL                   ;
0373: E831         ;
0374: E831         ; Vector to Function is in HL                                                ;
0375: E831 E9                     JP     (HL)                 ; Put it into the Program Counter    ;
0376: E832         ;===========================BDOS Entry=======================================;
0377: E832         ;===========================BDOS Exit =======================================;
0378: E832         ;arrive here at end of processing to return to user                          ;
0379: E832             ReturnToCaller:                      ;
0380: E832 3A 97 F5               LD     A,(fResel)           ; get re-selection flag              ;
0381: E835 B7                     OR     A                    ; is it set?                         ;
0382: E836 28 15                  JR     Z,ReturnToCaller1    ;
0383: E838         ;re-selection  may have taken place                                         ;
0384: E838 2A C3 EA               LD     HL,(paramDE)         ;
0385: E83B 36 00                  LD     (HL),0               ;
0386: E83D 3A 99 F5               LD     A,(fcbDisk)          ;
0387: E840 B7                     OR     A                    ; Disk = 0?                          ;
0388: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		 ;
0389: E843         ;
0390: E843 77                     LD     (HL),A               ;
0391: E844 3A 98 F5               LD     A,(entryDisk)        ; get back original Disk             ;
0392: E847 32 C2 EA               LD     (paramE),A           ; and select it                      ;
0393: E84A CD 60 EC               CALL   SelectCurrent        ;
0394: E84D         ;
0395: E84D             ReturnToCaller1:                      ;
0396: E84D 2A BC EA               LD     HL,(usersStack)      ;
0397: E850 F9                     LD     SP,HL                ; restore callers stack              ;
0398: E851 2A C5 EA               LD     HL,(exitParameterWord) ;
0399: E854 7D                     LD     A,L                  ;
0400: E855 44                     LD     B,H                  ; BA = exitParameterWord             ;
0401: E856 C9                     RET                         ;
0402: E857         ;===========================BDOS Exit =======================================;
0403: E857
0404: E857         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0405: E857             functionTable:                      ;
0406: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                 ;
0407: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input                ;
0408: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output               ;
0409: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                 ;
0410: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                 ;
0411: E861 CD E8                  DW     vListOut             ;   5 - List Output                  ;
0412: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O           ;
0413: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                 ;
0414: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                 ;
0415: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                 ;
0416: E86B FC E8                  DW     vReadString          ;   A - Read Console String          ;
0417: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status           ;
0418: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                     ;
0419: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number        ;
0420: E871 C7 EA                  DW     vResetSystem         ;   D - Reset Disk System            ;
0421: E873 E0 EA                  DW     vSelectDisk          ;   E - Select Disk                  ;
0422: E875 E3 EA                  DW     vOpenFile            ;   F - Open File                    ;
0423: E877 EC EA                  DW     vCloseFile           ;  10 - Close File                   ;
0424: E879 94 F1                  DW     vFindFirst           ;  11 - Search For First             ;
0425: E87B AD F1                  DW     vFindNext            ;  12 - Search for Next              ;
0426: E87D BC F1                  DW     vDeleteFile          ;  13 - Delete File                  ;
0427: E87F C5 F1                  DW     vReadSeq             ;  14 - Read Sequential              ;
0428: E881 CC F1                  DW     vWriteSeq            ;  15 - Write Sequential             ;
0429: E883 D3 F1                  DW     vMakeFile            ;  16 - Make File                    ;
0430: E885 DC F1                  DW     vRenameFile          ;  17 - Rename File                  ;
0431: E887 F2 EA                  DW     vGetLoginVector      ;  18 - Return Login Vector          ;
0432: E889 F9 EA                  DW     vGetCurrentDisk      ;  19 - Return Current Disk          ;
0433: E88B 00 EB                  DW     vSetDMA              ;  1A - Set DMA address              ;
0434: E88D 09 EB                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)             ;
0435: E88F 10 EB                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk           ;
0436: E891 13 EB                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	         ;
0437: E893 57 EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??       ;
0438: E895 1A EB                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)   ;
0439: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code            ;
0440: E899 22 EB                  DW     vReadRandom          ;  21 - Read Random                  ;
0441: E89B 28 EB                  DW     vWriteRandom         ;  22 - Write Random                 ;
0442: E89D 2E EB                  DW     vComputeFileSize     ;  23 - Compute File Size            ;
0443: E89F 34 EB                  DW     vSetRandomRecord     ;  24 - Set Random Record            ;
0444: E8A1 21 EB                  DW     vResetDrive          ;  25 - Reset Drive                  ;
0445: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported) ;
0446: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)   ;
0447: E8A7 37 EB                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill          ;
0448: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions               ;
0449: E8A9         ;
0450: E8A9             DUMMY:                          ;
0451: E8A9 76                     HALT                        ;
0452: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table +++++++++++++++++++++++++;
0453: E8AA
0454: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0455: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the     ;
0456: E8AA         ; same as the warm boot function invoked when you transfer control to the    ;
0457: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads   ;
0458: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,   ;
0459: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)   ;
0460: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control  ;
0461: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.               ;
0462: E8AA         ;																			 ;
0463: E8AA         ;			Function Code	 :	C = 00H                                      ;
0464: E8AA         ;			Entry Parameters:	None                                         ;
0465: E8AA         ;			Exit Parameters :	Does Not Return								 ;
0466: E8AA         ;																			 ;
0467: E8AA         ;-------------------------- System Reset - 0 (0) ----------------------------;
0468: E8AA             vSystemReset:
0469: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0470: E8AD
0471: E8AD         ;****************************************************************************;
0472: E8AD         ;								IOByte device I/O							 ;
0473: E8AD         ;****************************************************************************;
0474: E8AD
0475: E8AD
0476: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0477: E8AD         ;  This function reads the next byte of data from the console keyboard and   ;
0478: E8AD         ; puts it into register A. If the character input is a graphic character, it ;
0479: E8AD         ; will be echoed back to the console. The only control characters that are   ;
0480: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case    ;
0481: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to     ;
0482: E8AD         ; move the cursor to the next multiple of eight columns. All of the other    ;
0483: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.     ;
0484: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output   ;
0485: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if     ;
0486: E8AD         ; console output should also be sent to the list device. If CONTROL-S is     ;
0487: E8AD         ; found, further output will be suspended until you type another character.  ;
0488: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is   ;
0489: E8AD         ; pressed and disable it the second time. If there is no incoming data       ;
0490: E8AD         ; character, this function will wait until there is one.                     ;
0491: E8AD         ;                                                                            ;
0492: E8AD         ; This is a blocking function                                                ;
0493: E8AD         ;																			 ;
0494: E8AD         ;																			 ;
0495: E8AD         ;			Function Code	:	C = 01H                                      ;
0496: E8AD         ;			Entry Parameters:	None                                         ;
0497: E8AD         ;			Exit Parameters :	A = Data byte from console					 ;
0498: E8AD         ;																			 ;
0499: E8AD         ;-------------------------- Read Console Byte - 1 (1) -----------------------;
0500: E8AD             vConsoleIn:
0501: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0502: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0503: E8B3 D8                     RET    C                    ; return nothing to echo
0504: E8B4
0505: E8B4 F5                     PUSH   AF                   ; Save printable character
0506: E8B5 4F                     LD     C,A
0507: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0508: E8B9 F1                     POP    AF                   ; retrieve exit value
0509: E8BA
0510: E8BA 32 C5 EA               LD     (exitParameterByte),A
0511: E8BD C9                     RET
0512: E8BE
0513: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0514: E8BE         ;  This function outputs the data byte in register E to the console. As with ;
0515: E8BE         ; function 1, if the data byte is a TAB character, it will be expanded by    ;
0516: E8BE         ; the BDOS to the next column that is a multiple of eight. The BDOS also     ;
0517: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0518: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0519: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0520: E8BE         ; printer is  toggled on or off                                              ;
0521: E8BE         ;																			 ;
0522: E8BE         ;			Function Code	:	C = 02H                                      ;
0523: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0524: E8BE         ;			Exit Parameters :	None										 ;
0525: E8BE         ;																			 ;
0526: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0527: E8BE         ;BDOS put parameter in C before entering this routine
0528: E8BE             vConsoleOut:
0529: E8BE CD 58 E9               CALL   TabOut
0530: E8C1 C9                     RET
0531: E8C2
0532: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0533: E8C2         ;   function reads the next character from the logical "reader" device into  ;
0534: E8C2         ; register A. In practice, the physical device that is accessed depends      ;
0535: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no      ;
0536: E8C2         ; reader at all; this function will return some arbitrary value such as lAH  ;
0537: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').     ;
0538: E8C2         ; Control is not returned to the calling program until a character has been  ;
0539: E8C2         ; read.                                                                      ;
0540: E8C2         ;                                                                            ;
0541: E8C2         ; This is a blocking function                                                ;
0542: E8C2         ;																			 ;
0543: E8C2         ;			Function Code	:	C = 03H                                      ;
0544: E8C2         ;			Entry Parameters:	None										 ;
0545: E8C2         ;			Exit Parameters :	A = Character Input							 ;
0546: E8C2         ;																			 ;
0547: E8C2         ;--------------------------- Read Reader Byte - 3 (3) -----------------------;
0548: E8C2             vReaderIn:
0549: E8C2 CD 15 F6               CALL   bcReader
0550: E8C5 32 C5 EA               LD     (exitParameterWord),A
0551: E8C8 C9                     RET
0552: E8C9
0553: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0554: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the   ;
0555: E8C9         ; specified character from register E to the logical punch device. Again,    ;
0556: E8C9         ; the actual physical device used, if any, is determined by the BIOS.        ;
0557: E8C9         ; There is no set standard for this device; in some systems the punch        ;
0558: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you   ;
0559: E8C9         ; output to it.                                                              ;
0560: E8C9         ;																			 ;
0561: E8C9         ;			Function Code	:	C = 04H                                      ;
0562: E8C9         ;			Entry Parameters:	E = Data byte to be output					 ;
0563: E8C9         ;			Exit Parameters :	None										 ;
0564: E8C9         ;																			 ;
0565: E8C9         ;--------------------------- Write Punch Byte - 4 (4) -----------------------;
0566: E8C9         ;BDOS put parameter in C before entering this routine
0567: E8C9             vPunchOut:
0568: E8C9 CD 12 F6               CALL   bcPunch
0569: E8CC C9                     RET
0570: E8CD
0571: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0572: E8CD         ;  This function outputs the specified byte in register E to the logical     ;
0573: E8CD         ; list device. As with the reader and the punch, the physical device used    ;
0574: E8CD         ; depends entirely on the BIOS.                                              ;
0575: E8CD         ;																			 ;
0576: E8CD         ;			Function Code	:	C = 05H                                      ;
0577: E8CD         ;			Entry Parameters:	E = Data byte to be output					 ;
0578: E8CD         ;			Exit Parameters :	None										 ;
0579: E8CD         ;																			 ;
0580: E8CD         ;---------------------------- Write List Byte - 5 (5) -----------------------;
0581: E8CD         ;BDOS put parameter in C before entering this routine
0582: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0583: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0584: E8D0 C9                     RET
0585: E8D1
0586: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0587: E8D1         ;  This function serves double duty: it both inputs and outputs characters   ;
0588: E8D1         ; from the console. However, it bypasses the normal control characters and   ;
0589: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally           ;
0590: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as   ;
0591: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,    ;
0592: E8D1         ; then E contains a valid ASCII character that is output to the console.     ;
0593: E8D1         ;  This function works well provided you never have to send a value ofOFFH   ;
0594: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive pure ;
0595: E8D1         ; binary data, you cannot use this function, since these values are likely   ;
0596: E8D1         ; to be part of the data stream.                                             ;
0597: E8D1         ;                                                                            ;
0598: E8D1         ;			Function Code	:	C = 06H                                      ;
0599: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		 ;
0600: E8D1         ;								E = Other than 0FFH for Output				 ;
0601: E8D1         ;			Exit Parameters :	A = Input byte or status					 ;
0602: E8D1         ;																			 ;
0603: E8D1         ;--------------------------- Direct Console I/O - 6 (6) ---------------------;
0604: E8D1         ;BDOS put parameter in C before entering this routine
0605: E8D1             vDirectConIO:
0606: E8D1 79                     LD     A,C
0607: E8D2 3C                     INC    A
0608: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0609: E8D5         ; send byte to console
0610: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0611: E8D8 C9                     RET
0612: E8D9
0613: E8D9         ;read byte/status from console
0614: E8D9             vDirectConIO1:
0615: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0616: E8DC B7                     OR     A                    ; 00 means not data ready
0617: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0618: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0619: E8E3 32 C5 EA               LD     (exitParameterByte),A ; Save it
0620: E8E6 C9                     RET
0621: E8E7
0622: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0623: E8E7         ; This function places the current value of the IOBYTE in register A.        ;
0624: E8E7         ;                                                                            ;
0625: E8E7         ; The IOBYTE structure:                                                      ;
0626: E8E7         ;								+-------+-------+-------+-------+            ;
0627: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0628: E8E7         ;								+-------+-------+-------+-------+            ;
0629: E8E7         ;				Logical Device     List | Punch | Reader|Console             ;
0630: E8E7         ;                                                                            ;
0631: E8E7         ;                                                                            ;
0632: E8E7         ;			Function Code	:	C = 07H                                      ;
0633: E8E7         ;			Entry Parameters:	None					  		  			 ;
0634: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					 ;
0635: E8E7         ;																			 ;
0636: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) ---------------------;
0637: E8E7             vGetIOBYTE:
0638: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0639: E8EA 32 C5 EA               LD     (exitParameterWord),A ; Return it to caller
0640: E8ED C9                     RET
0641: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) ---------------------;
0642: E8EE         ; This function sets the IOBYTE         									 ;
0643: E8EE         ;                                                                            ;
0644: E8EE         ; The IOBYTE structure:                                                      ;
0645: E8EE         ;								+-------+-------+-------+-------+            ;
0646: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |            ;
0647: E8EE         ;								+-------+-------+-------+-------+            ;
0648: E8EE         ;				Logical Device     List | Punch | Reader|Console             ;
0649: E8EE         ;                                                                            ;
0650: E8EE         ;                                                                            ;
0651: E8EE         ;			Function Code	:	C = 08H                                      ;
0652: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			 ;
0653: E8EE         ;			Exit Parameters :	None                                         ;
0654: E8EE         ;																			 ;
0655: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) ---------------------;
0656: E8EE         ;BDOS put parameter in C before entering this routine
0657: E8EE             vSetIOBYTE:
0658: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0659: E8F1 71                     LD     (HL),C               ; Place new vale in it
0660: E8F2 C9                     RET
0661: E8F3
0662: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0663: E8F3         ;  This function outputs a string of characters to the console device. The   ;
0664: E8F3         ; address of this string is in registers DE. You must make sure that the last;
0665: E8F3         ; character of the string is "$"; the BDOS uses this character as a marker   ;
0666: E8F3         ; for the end of the string.                                                 ;
0667: E8F3         ;  The "$" itself does not get output to the console.                        ;
0668: E8F3         ;                                                                            ;
0669: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously     ;
0670: E8F3         ; described, checks to see if there is an incoming character, and checks for ;
0671: E8F3         ; CONTROL-S (XOFF, which stops the output until another character is entered);
0672: E8F3         ; or CONTROL-P (which turns on or off echoing of console characters to       ;
0673: E8F3         ; the printer).                                                              ;
0674: E8F3         ;                                                                            ;
0675: E8F3         ;			Function Code	:	C = 09H                                      ;
0676: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string ;
0677: E8F3         ;			Exit Parameters :	None							             ;
0678: E8F3         ;																			 ;
0679: E8F3         ;---------------------- Display $ terminated String - 9 (9) -----------------;
0680: E8F3             vPrintString:
0681: E8F3 2A C3 EA               LD     HL,(paramDE)         ; Get address of the string
0682: E8F6 4D                     LD     C,L
0683: E8F7 44                     LD     B,H                  ; Put it into BC for call
0684: E8F8 CD 3B E9               CALL   Print                ; out to console
0685: E8FB C9                     RET
0686: E8FC
0687: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0688: E8FC         ;  This function reads a string of characters from the console device        ;
0689: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line     ;
0690: E8FC         ; editing is possible: the operator can backspace, cancel the line and start ;
0691: E8FC         ; over, and use all the normal control functions. What you will ultimately   ;
0692: E8FC         ; see in the buffer is the final version of the character string entered,    ;
0693: E8FC         ; without any of the errors or control characters used to do the line editing;
0694: E8FC         ;                                                                            ;
0695: E8FC         ;  The buffer that you define has a special format. The first byte in the    ;
0696: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.     ;
0697: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters   ;
0698: E8FC         ; were actually placed in the buffer. The following bytes contain            ;
0699: E8FC         ; the characters of the string. Character input will cease either when a     ;
0700: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,       ;
0701: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not  ;
0702: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If     ;
0703: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets       ;
0704: E8FC         ; the "characters input" byte to O. If you attempt to input more than the    ;
0705: E8FC         ; maximum number of characters, the "characters input" count will be the     ;
0706: E8FC         ; same as the maximum value allowed.                                         ;
0707: E8FC         ;                                                                            ;
0708: E8FC         ;			Function Code	:	C = 0AH                                      ;
0709: E8FC         ;			Entry Parameters:	DE = Address string buffer					 ;
0710: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it       ;
0711: E8FC         ;																			 ;
0712: E8FC         ;-------------------------- Read Console String - A (10) --------------------;
0713: E8FC             vReadString:
0714: E8FC CD E0 E9               CALL   ReadString
0715: E8FF C9                     RET
0716: E900
0717: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0718: E900         ; This function tells you whether a console input character is waiting to be ;
0719: E900         ;processed. Unlike the Console Input functions, which will wait until there  ;
0720: E900         ;is input,this function simply checks and returns immediately.               ;
0721: E900         ;                                                                            ;
0722: E900         ;			Function Code	:	C = 0BH                                      ;
0723: E900         ;			Entry Parameters:	None										 ;
0724: E900         ;			Exit Parameters :	A = 00H if no incoming Data					 ;
0725: E900         ;								A = FFH	if incoming Data					 ;
0726: E900         ;																			 ;
0727: E900         ;------------------------- Read Console Status - B (11) ---------------------;
0728: E900             vGetConsoleStatus:
0729: E900 CD 8C E9               CALL   ConBreak
0730: E903 32 C5 EA               LD     (exitParameterByte),A
0731: E906 C9                     RET
0732: E907
0733: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0734: E907         ;  This function tells you which version of CP/M you are currently running.  ;
0735: E907         ; A two-byte value is returned:                                              ;
0736: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                       ;
0737: E907         ;	L = OOH for all releases before CP/M 2.0                                 ;
0738: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                          ;
0739: E907         ;		and so on for any subsequent releases.                               ;
0740: E907         ;                                                                            ;
0741: E907         ; This information is of interest only if your program has some version      ;
0742: E907         ; specific logic built into it. For example, CP/M version 1.4 does not       ;
0743: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does.  ;
0744: E907         ; Therefore, if your program uses Random I/O, put this check at the          ;
0745: E907         ; beginning to ensure that it is indeed running under the appropriate        ;
0746: E907         ; version of CP/M.                                                           ;
0747: E907         ;                                                                            ;
0748: E907         ;			Function Code	:	C = 0CH                                      ;
0749: E907         ;			Entry Parameters:	None										 ;
0750: E907         ;			Exit Parameters :	HL =Version Number Code						 ;
0751: E907         ;								A = FFH	if incoming Data					 ;
0752: E907         ;																			 ;
0753: E907         ;--------------------------- Get CP/M Version - C (12) ----------------------;
0754: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0755: E907 3E 20                  LD     A,VERSION
0756: E909 32 C5 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0757: E90C C9                     RET
0758: E90D
0759: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0760: E90D         ;  This subroutine either sets or gets the current user number. The current  ;
0761: E90D         ; user number determines which file directory entries are matched during all ;
0762: E90D         ; disk file operations. When you call this function, the contents of the     ;
0763: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function ;
0764: E90D         ; will return the current user number in the A register. If you set E to a   ;
0765: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function   ;
0766: E90D         ; will set the current user number to this value.                            ;
0767: E90D         ;                                                                            ;
0768: E90D         ;			Function Code	:	C = 0CH                                      ;
0769: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				 ;
0770: E90D         ;								  = 0 to 15 to set User Number				 ;
0771: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH ;
0772: E90D         ;								A = FFH	if incoming Data					 ;
0773: E90D         ;																			 ;
0774: E90D         ;                                                                            ;
0775: E90D         ;--------------------------- Get/Set User Number - 20 (32) ------------------;
0776: E90D             vGetSetUserNumber:
0777: E90D 3A C2 EA               LD     A,(paramE)
0778: E910 FE FF                  CP     0FFH
0779: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0780: E914 3A 66 F5               LD     A,(currentUserNumber)
0781: E917 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0782: E91A C9                     RET
0783: E91B
0784: E91B             SetUserNumber:
0785: E91B E6 0F                  AND    LO_NIBBLE_MASK
0786: E91D 32 66 F5               LD     (currentUserNumber),A
0787: E920 C9                     RET
0788: E921
0789: E921         ;****************************************************************************;
0790: E921         ;								Character Support Routines					 ;
0791: E921         ;****************************************************************************;
0792: E921
0793: E921
0794: E921         ;-------------------- Return a Character from the console -------------------;
0795: E921         ;return byte from buffer or read from the console                            ;
0796: E921             ConIn:                          ;
0797: E921 21 BE EA               LD     HL,keyboardByte      ; is there a Byte waiting?           ;
0798: E924 7E                     LD     A,(HL)               ;
0799: E925 36 00                  LD     (HL),0               ;
0800: E927 B7                     OR     A                    ;
0801: E928 C0                     RET    NZ                   ;
0802: E929         ;
0803: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console           ;
0804: E92C         ;-------------------- Return a Character from the console -------------------;
0805: E92C
0806: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0807: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE      ;
0808: E92C             IsPrintableASCII:                      ;
0809: E92C FE 0D                  CP     CR                   ;
0810: E92E C8                     RET    Z                    ; carriage return?                                                  ;
0811: E92F FE 0A                  CP     LF                   ;
0812: E931 C8                     RET    Z                    ; line feed?                                                        ;
0813: E932 FE 09                  CP     TAB                  ;
0814: E934 C8                     RET    Z                    ; TAB?                                                              ;
0815: E935 FE 08                  CP     CTRL_H               ;
0816: E937 C8                     RET    Z                    ; backspace?                                                        ;
0817: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable         ;
0818: E93A C9                     RET                         ;
0819: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ----------;
0820: E93B
0821: E93B         ;------------------ Print character from (BC) until  $ found ----------------;
0822: E93B             Print:                          ;
0823: E93B 0A                     LD     A,(BC)               ; Get the next character             ;
0824: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                    ;
0825: E93E C8                     RET    Z                    ;  exit if yes                       ;
0826: E93F 03                     INC    BC                   ; Update the pointer                 ;
0827: E940 C5                     PUSH   BC                   ; Save it                            ;
0828: E941 4F                     LD     C,A                  ; Does Byte require                  ;
0829: E942 CD 58 E9               CALL   TabOut               ;  special attention - check         ;
0830: E945 C1                     POP    BC                   ; Retrieve the pointer				 ;
0831: E946 18 F3                  JR     Print                ; Loop back                          ;
0832: E948         ;------------------ Print character from (BC) until  $ found ----------------;
0833: E948
0834: E948         ;-- Send printable character to console. Precede with Caret if needed -------;
0835: E948         ; character is in Reg C                                                      ;
0836: E948             CaretOut:                       ;
0837: E948 79                     LD     A,C                  ;
0838: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0839: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed           ;
0840: E94E         ; send preceding up arrow                                                    ;
0841: E94E F5                     PUSH   AF                   ; Save the character                 ;
0842: E94F 0E 5E                  LD     C,CARET              ;
0843: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console              ;
0844: E954 F1                     POP    AF                   ; Get the character                  ;
0845: E955 F6 40                  OR     40H                  ; Make the graphic a letter          ;
0846: E957 4F                     LD     C,A                  ; Set up to print                    ;
0847: E958         ; fall thru to TabbOut                                                       ;
0848: E958         ;-- Send printable character to console. Precede with Caret if needed -------;
0849: E958
0850: E958         ;------------- Send printable character to console. Expand if TAB -----------;
0851: E958         ; character is in Reg C                                                      ;
0852: E958             TabOut:                         ;
0853: E958 79                     LD     A,C                  ;
0854: E959 FE 09                  CP     TAB                  ; Is it a TAB                        ;
0855: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not   ;
0856: E95E         ;
0857: E95E         ; TAB encountered                                                           ;
0858: E95E             TabOut0:                        ;
0859: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs            ;
0860: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                    ;
0861: E963 3A C1 EA               LD     A,(columnPosition)   ; Get Column position                ;
0862: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?       ;
0863: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                    ;
0864: E96A C9                     RET                         ;
0865: E96B         ;------------- Send printable character to console. Expand if TAB -----------;
0866: E96B
0867: E96B         ;-------------------------- Send character to console -----------------------;
0868: E96B         ; C  = Character to be output                                                ;
0869: E96B             ConsoleOut:                      ;
0870: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                  ;
0871: E96B C5                     PUSH   BC                   ; Save character and Count           ;
0872: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke   ;
0873: E96F C1                     POP    BC                   ;
0874: E970 C5                     PUSH   BC                   ; Get/save character                 ;
0875: E971         ; Send character to Console	                                                 ;
0876: E971 CD 0C F6               CALL   bcConout             ; Send character to the console      ;
0877: E974 C1                     POP    BC                   ;
0878: E975 C5                     PUSH   BC                   ; Get/save character                 ;
0879: E976         ; is the data to be output to print device?                                  ;
0880: E976 3A BF EA               LD     A,(printEchoFlag)    ;
0881: E979 B7                     OR     A                    ;
0882: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so          ;
0883: E97D C1                     POP    BC                   ; Get the character                  ;
0884: E97E         ;
0885: E97E 79                     LD     A,C                  ; Put character to ACC               ;
0886: E97F 21 C1 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition     ;
0887: E982 34                     INC    M                    ; increment the ColumnPosition       ;
0888: E983         ;
0889: E983 FE 20                  CP     SPACE                ;
0890: E985 D0                     RET    NC                   ; Exit if ASCII printable            ;
0891: E986         ;
0892: E986 FE 0A                  CP     LF                   ;
0893: E988 C0                     RET    NZ                   ; Exit if not a Line Feed            ;
0894: E989         ;
0895: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0     ;
0896: E98B C9                     RET                         ;
0897: E98C         ;-------------------------- Send character to console -----------------------;
0898: E98C
0899: E98C         ;--------------------  Check for Status and Control S or C ------------------;
0900: E98C         ;  Returns:																	 ;
0901: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console ;
0902: E98C         ;			ACC = 00   No data Pending										 ;
0903: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard           ;
0904: E98C         ;                                                                            ;
0905: E98C             ConBreak:                       ;
0906: E98C 3A BE EA               LD     A,(keyboardByte)     ;
0907: E98F B7                     OR     A                    ; If there is a char waiting         ;
0908: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC             ;
0909: E992         ;
0910: E992 CD 06 F6               CALL   bcConst              ; Get status                         ;
0911: E995 FE 00                  CP     00H                  ; If 00 => No data pending	         ;
0912: E997 C8                     RET    Z                    ; Return 00 No data pending          ;
0913: E998         ;
0914: E998 CD 09 F6               CALL   bcConin              ; Read the byte                      ;
0915: E99B         ;
0916: E99B FE 10                  CP     CTRL_P               ;
0917: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0918: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0919: E99F 21 BF EA               LD     HL,printEchoFlag     ;
0920: E9A2 3E FF                  LD     A,TRUE               ;
0921: E9A4 BE                     CP     (HL)                 ;
0922: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0923: E9A7 3E 00                  LD     A,FALSE              ;
0924: E9A9             ToggleFlag1:                      ;
0925: E9A9 77                     LD     (HL),A               ;
0926: E9AA 18 0C                  JR     NothingWaiting       ;
0927: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>             ;
0928: E9AC             CheckCTL_S:                      ;
0929: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save     ;
0930: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH              ;
0931: E9B0         ;
0932: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte                ;
0933: E9B3 FE 03                  CP     CTRL_C               ;
0934: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C             ;
0935: E9B8             NothingWaiting:                      ;
0936: E9B8 AF                     XOR    A                    ;
0937: E9B9 C9                     RET                         ; Set ACC = 0 and return             ;
0938: E9BA             ConBreak0:                      ;
0939: E9BA 32 BE EA               LD     (keyboardByte),A     ; save the byte                      ;
0940: E9BD             ConBreak1:                      ;
0941: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC        ;
0942: E9BF C9                     RET                         ;
0943: E9C0         ;--------------------  Check for Status and Control S or C ------------------;
0944: E9C0
0945: E9C0         ;------------------------  Console Output Utilities -------------------------;
0946: E9C0             showHashCRLF:                      ;
0947: E9C0 0E 23                  LD     C,HASH_TAG           ;
0948: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                  ;
0949: E9C5 CD D6 E9               CALL   showCRLF             ;
0950: E9C8             showHashCRLF1:                      ;
0951: E9C8 3E C1                  LD     A,columnPosition     ;
0952: E9CA 21 C0 EA               LD     HL,startingColumn    ;
0953: E9CD BF                     CP     A,M                  ;
0954: E9CE D0                     RET    NC                   ;
0955: E9CF 0E 20                  LD     C,SPACE              ;
0956: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0957: E9D4 18 F2                  JR     showHashCRLF1        ;
0958: E9D6         ;------------------------  Console Output Utilities -------------------------;
0959: E9D6
0960: E9D6         ;------------------------  Send Carriage Return and Line Feed ---------------;
0961: E9D6             showCRLF:                       ;
0962: E9D6 0E 0D                  LD     C,CR                 ;
0963: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0964: E9DB 0E 0A                  LD     C,LF                 ;
0965: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET           ;
0966: E9E0         ;------------------------  Send Carriage Return and Line Feed ---------------;
0967: E9E0
0968: E9E0         ;------------------------- Read a $ terminated String -----------------------;
0969: E9E0         ;read to paramDE address (max length, current length, buffer)               ;
0970: E9E0             ReadString:                      ;
0971: E9E0 3A C1 EA               LD     A,(columnPosition)   ;
0972: E9E3 32 C0 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R   ;
0973: E9E6 2A C3 EA               LD     HL,(paramDE)         ; Get the start of the String        ;
0974: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					 ;
0975: E9EA 23                     INC    HL                   ; Point at actual bytes read         ;
0976: E9EB 06 00                  LD     B,0                  ; Initialize Current Count           ;
0977: E9ED         ;
0978: E9ED         ; B = Current Count                                                      ;
0979: E9ED         ; C = Maximum characters                                                 ;
0980: E9ED         ; HL= Insertion Pointer                                                  ;
0981: E9ED         ;
0982: E9ED         ; read next character, BC, HL active                                        ;
0983: E9ED             ReadNext:                       ;
0984: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
0985: E9EE E5                     PUSH   HL                   ; Save pointer                       ;
0986: E9EF             ReadNext0:                      ;
0987: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character             ;
0988: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                    ;
0989: E9F4 E1                     POP    HL                   ; Restore Pointer					 ;
0990: E9F5 C1                     POP    BC                   ; Restore Current Index and Max Count;
0991: E9F6         ;Is It Carriage Return                                                       ;
0992: E9F6 FE 0D                  CP     CR                   ;
0993: E9F8 CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0994: E9FB FE 0A                  CP     LF                   ;
0995: E9FD         ;Is It Linefeed                                                              ;
0996: E9FD CA 3E EA               JP     Z,EndRead            ; End the read if yes                ;
0997: EA00         ;Is It BackSpace                                                             ;
0998: EA00 FE 08                  CP     CTRL_H               ;
0999: EA02 CA 48 EA               JP     Z,BSspaceBS          ;
1000: EA05             IsItRubout:                      ;
1001: EA05 FE 7F                  CP     RUBOUT               ; Non destructive delete             ;
1002: EA07 CA 52 EA               JP     Z,ItIsRubout         ;
1003: EA0A             IsPhysicalEOL:                      ;
1004: EA0A FE 05                  CP     CTRL_E               ;
1005: EA0C CA 5D EA               JP     Z,ItIsPhysicalEOL    ;
1006: EA0F             IsItPrintToggle:                      ;
1007: EA0F FE 10                  CP     CTRL_P               ;
1008: EA11 CA 65 EA               JP     Z,ItIsPrintToggle    ;
1009: EA14             IsItDeleteTheLineX:                      ;
1010: EA14 FE 18                  CP     CTRL_X               ;
1011: EA16 CA 8E EA               JP     Z,DeleteTheLine      ; If CTRL_X go delete the line       ;
1012: EA19             IsItDeleteTheLineU:                      ;
1013: EA19 FE 15                  CP     CTRL_U               ;
1014: EA1B CA AC EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line          ;
1015: EA1E         ;Retype the line                                                             ;
1016: EA1E FE 12                  CP     CTRL_R               ;
1017: EA20 CA 75 EA               JP     Z,RepeatLine         ;
1018: EA23
1019: EA23         ;....................... Echo input back to the Console  ....................;
1020: EA23         ; Full Duplex								                                 ;
1021: EA23         ; A = Character to display	                                                 ;
1022: EA23         ; B = current char count                                                     ;
1023: EA23         ; C = maximum buffer length                                                  ;
1024: EA23         ; HL= buffer pointer                                                         ;
1025: EA23         ;ReadEcho                                                                    ;
1026: EA23 04                     INC    B                    ; Increment byte count		         ;
1027: EA24 23                     INC    HL                   ; Advance the Pointer                ;
1028: EA25 77                     LD     (HL),A               ; Put char in buffer                 ;
1029: EA26         ;
1030: EA26             ReadEchoRubOut:                      ;
1031: EA26 C5                     PUSH   BC                   ; Save index and length              ;
1032: EA27 E5                     PUSH   HL                   ; Save the Pointer                   ;
1033: EA28 4F                     LD     C,A                  ; Get char                           ;
1034: EA29 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)    ;
1035: EA2C E1                     POP    HL                   ; Restore the Pointer                ;
1036: EA2D C1                     POP    BC                   ; Restore index and length           ;
1037: EA2E 7E                     LD     A,(HL)               ; Recall char                        ;
1038: EA2F         ; check for Warm Boot                                                        ;
1039: EA2F FE 03                  CP     CTRL_C               ;
1040: EA31 78                     LD     A,B                  ; Get Line position                  ;
1041: EA32 C2 3A EA               JP     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                 ;
1042: EA35 FE 01                  CP     1                    ; Beginning of the Line?             ;
1043: EA37 CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot               ;
1044: EA3A         ; Check to see if we are at the end of the buffer                            ;
1045: EA3A             AreWeAtEndOfBuffer:                      ;
1046: EA3A B9                     CP     C                    ; Over Max ?					     ;
1047: EA3B DA ED E9               JP     C,ReadNext           ;  no, Go for more				     ;
1048: EA3E         ;
1049: EA3E         ; At the end of read                                  					     ;
1050: EA3E             EndRead:                        ;
1051: EA3E         ; 	POP		HL                                                               ;
1052: EA3E 2A C3 EA               LD     HL,(paramDE)         ;
1053: EA41 23                     INC    HL                   ;
1054: EA42         ;
1055: EA42 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer   ;
1056: EA43 0E 0D                  LD     C,CR                 ;
1057: EA45 C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			 ;
1058: EA48         ;....................... Echo input back to the Console  ....................;
1059: EA48         ;.......................... Backspace SPACE BackSpace .......................;
1060: EA48             BSspaceBS:                      ;
1061: EA48 05                     DEC    B                    ;
1062: EA49 2B                     DEC    HL                   ;
1063: EA4A C5                     PUSH   BC                   ;
1064: EA4B E5                     PUSH   HL                   ;
1065: EA4C CD 9F EA               CALL   BackUp               ;
1066: EA4F C3 EF E9               JP     ReadNext0            ;
1067: EA52         ;.......................... Backspace SPACE BackSpace .......................;
1068: EA52         ;.......................... It is RubOut ....................................;
1069: EA52             ItIsRubout:                      ;
1070: EA52         ; RUBOUT if possible                                                         ;
1071: EA52 78                     LD     A,B                  ; Are we at the start of the line    ;
1072: EA53 B7                     OR     A                    ;
1073: EA54 CA ED E9               JP     Z,ReadNext           ; then ignore and go for next char   ;
1074: EA57         ;adjust pointers back one                                                    ;
1075: EA57 7E                     LD     A,(HL)               ; ACC = current character            ;
1076: EA58 05                     DEC    B                    ; Adjust the index			    	 ;
1077: EA59 2B                     DEC    HL                   ; Adjust the pointer                 ;
1078: EA5A C3 26 EA               JP     ReadEchoRubOut       ; Echo back - Full Duplex            ;
1079: EA5D         ;.......................... It is RubOut ....................................;
1080: EA5D         ;.......................... It is PhysicalEOL ...............................;
1081: EA5D             ItIsPhysicalEOL:                      ;
1082: EA5D C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1083: EA5E E5                     PUSH   HL                   ; Save pointer                       ;
1084: EA5F CD D6 E9               CALL   showCRLF             ; Make new line                      ;
1085: EA62 C3 EF E9               JP     ReadNext0            ;   and go for next char   			 ;
1086: EA65         ;.......................... It is PhysicalEOL ...............................;
1087: EA65         ;.......................... It is PrintToggle ...............................;
1088: EA65             ItIsPrintToggle:                      ;
1089: EA65 E5                     PUSH   HL                   ; Save pointer                       ;
1090: EA66         ; Toggle the printEcho Flag                                                  ;
1091: EA66 21 BF EA               LD     HL,printEchoFlag     ; Point at the flag                  ;
1092: EA69 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                 ;
1093: EA6B BE                     CP     (HL)                 ; Is the flag true?                  ;
1094: EA6C 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                        ;
1095: EA6E 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE        ;
1096: EA70             IsItPrintToggle1:                      ;
1097: EA70 77                     LD     (HL),A               ; Set the Flags new Value	         ;
1098: EA71 E1                     POP    HL                   ; Restore pointer                    ;
1099: EA72 C3 ED E9               JP     ReadNext             ;   and for another char             ;
1100: EA75         ;.......................... It is PrintToggle ...............................;
1101: EA75         ;.......................... RepeatLine ......................................;
1102: EA75             RepeatLine:                      ;
1103: EA75 C5                     PUSH   BC                   ; Save Current Index and Max Count   ;
1104: EA76 E5                     PUSH   HL                   ;  for exit                          ;
1105: EA77 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1106: EA7A         ;
1107: EA7A 2A C3 EA               LD     HL,(paramDE)         ; Get start of Buffer                ;
1108: EA7D 23                     INC    HL                   ; Skip past character count          ;
1109: EA7E         ;
1110: EA7E             LL1:                            ;
1111: EA7E 23                     INC    HL                   ; Point at next char to display      ;
1112: EA7F C5                     PUSH   BC                   ; Save counter, in B                 ;
1113: EA80 E5                     PUSH   HL                   ; Save buffer pointer                ;
1114: EA81 4E                     LD     C,M                  ; Get the next character             ;
1115: EA82 CD 48 E9               CALL   CaretOut             ; Display it                         ;
1116: EA85 E1                     POP    HL                   ; Restore                            ;
1117: EA86 C1                     POP    BC                   ;  the counter and pointer           ;
1118: EA87 10 F5                  DJNZ   LL1                  ; loop if still more to show         ;
1119: EA89 E1                     POP    HL                   ; Restore values                     ;
1120: EA8A C1                     POP    BC                   ;  from routine entry                ;
1121: EA8B C3 ED E9               JP     ReadNext             ; Done here !                        ;
1122: EA8E         ;.......................... RepeatLine ......................................;
1123: EA8E         ;.......................... Delete The Line .................................;
1124: EA8E             DeleteTheLine:                      ;
1125: EA8E E1                     POP    HL                   ; Adjust Stack                       ;
1126: EA8F         ;                                             ;
1127: EA8F             DeleteTheLine1:                      ;
1128: EA8F 3A C0 EA               LD     A,(startingColumn)   ;
1129: EA92 21 C1 EA               LD     HL,columnPosition    ;
1130: EA95 BE                     CP     M                    ; Start of line ?                    ;
1131: EA96 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more    ;
1132: EA99 35                     DEC    M                    ; Adjust the ColumnPosition          ;
1133: EA9A CD 9F EA               CALL   BackUp               ; Clear 1 column                     ;
1134: EA9D 18 F0                  JR     DeleteTheLine1       ; Loop for more                      ;
1135: EA9F         ;.......................... Delete The Line .................................;
1136: EA9F         ;------------------------ Back-up one screen position -----------------------;
1137: EA9F             BackUp:                         ;
1138: EA9F CD A7 EA               CALL   BackUp1              ; Send Backspace                     ;
1139: EAA2 0E 20                  LD     C,SPACE              ; Overwrite with SPACE               ;
1140: EAA4 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				 ;
1141: EAA7         ;does not affect column count                                                ;
1142: EAA7             BackUp1:                        ;
1143: EAA7 0E 08                  LD     C,CTRL_H             ;
1144: EAA9 C3 0C F6               JP     bcConout             ; Send Backspace                     ;
1145: EAAC         ;------------------------ Back-up one screen position -----------------------;
1146: EAAC         ;.......................... Ignore The Line .................................;
1147: EAAC             IgnoreTheLine:                      ;
1148: EAAC CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			 ;
1149: EAAF 0E 20                  LD     C,SPACE              ; We want to add a few spaces        ;
1150: EAB1 CD 0C F6               CALL   bcConout             ;  to the console                    ;
1151: EAB4 0E 20                  LD     C,SPACE              ;
1152: EAB6 CD 0C F6               CALL   bcConout             ;
1153: EAB9 C3 E0 E9               JP     ReadString           ; Start all over                     ;
1154: EABC         ;.......................... Ignore The Line .................................;
1155: EABC
1156: EABC         ;------------------------- Read a $ terminated String -----------------------;
1157: EABC
1158: EABC         ;****************************************************************************
1159: EABC         ;                           DATA AREA                                       *
1160: EABC         ;****************************************************************************
1161: EABC
1162: EABC         ;------------------------------Non Disk Data Area ---------------------------;
1163: EABC             usersStack: DS     2                    ; entry stack pointer                ;
1164: EABE         ;
1165: EABE 00          keyboardByte: DB     00                   ; Saved keyboard character           ;
1166: EABF         ;
1167: EABF 00          printEchoFlag: DB     00                   ; Controlled by ^P                   ;
1168: EAC0         ;
1169: EAC0         ; FunctionValue:DB	00H					; Reg C on BDOS Entry                ;
1170: EAC0 00          startingColumn: DB     0                    ; Starting col pos after read        ;
1171: EAC1 00          columnPosition: DB     0                    ; Current Column position            ;
1172: EAC2         ;
1173: EAC2             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call        ;
1174: EAC3             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	     ;
1175: EAC5             exitParameterByte:                      ; Byte returned Value                ;
1176: EAC5             exitParameterWord: DS     WORD                 ; Word                           ;
1177: EAC7         ;
1178: EAC7         ;
1179: EAC7         ;------------------------------------ Data Area -----------------------------;
1180: EAC7
1181: EAC7
1182: EAC7
1183: EAC7         ;****************************************************************************;
1184: EAC7         ;								Disk I/O									 ;
1185: EAC7         ;****************************************************************************;
1186: EAC7
1187: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1188: EAC7         ;  This function requests CP/M to completely reset the disk file system.     ;
1189: EAC7         ; CP/M then resets its internal tables, selects logical disk A as the        ;
1190: EAC7         ; default disk, resets the DMAaddress back to 0080H (the address of the      ;
1191: EAC7         ; buffer used by the BDOS to read and write to the disk), and marks all      ;
1192: EAC7         ; logical disks as having Read/Write status. The BDOS will then have to log  ;
1193: EAC7         ; in each logical disk as each disk is accessed. This involves reading the   ;
1194: EAC7         ; entire file directory for the disk and rebuilding the allocation vectors   ;
1195: EAC7         ; which keep track of which allocation blocks are free and which             ;
1196: EAC7         ; are used for file storage.                                                 ;
1197: EAC7         ;                                                                            ;
1198: EAC7         ;			Function Code	:	C = 0DH                                      ;
1199: EAC7         ;			Entry Parameters:	None										 ;
1200: EAC7         ;			Exit Parameters :	None										 ;
1201: EAC7         ;																			 ;
1202: EAC7         ;---------------------------- Reset Disk System - D (13) --------------------;
1203: EAC7             vResetSystem:
1204: EAC7 21 00 00               LD     HL,0
1205: EACA 22 69 F5               LD     (readOnlyVector),HL  ; Clear the vectors for
1206: EACD 22 6B F5               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1207: EAD0 AF                     XOR    A                    ; Clear the current disk
1208: EAD1 32 67 F5               LD     (currentDisk),A
1209: EAD4         ; note that currentUserNumber remains unchanged
1210: EAD4 21 80 00               LD     HL,DMABuffer
1211: EAD7 22 6D F5               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1212: EADA CD 3A EE               CALL   SetDataDMA           ; to data DMA address
1213: EADD C3 6C EC               JP     Select
1214: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1215: EAE0         ;  This function makes the logical disk named in register E the default disk;
1216: EAE0         ; All subsequent references to disk files that do not specify the disk will ;
1217: EAE0         ; use this default. When you reference a disk file that does have an        ;
1218: EAE0         ; explicit logical disk in its name you do not have to issue another        ;
1219: EAE0         ; Select Disk function; the BDOS will take care of that for you.            ;
1220: EAE0         ;                                                                           ;
1221: EAE0         ;  Notice the way in which the logical disk is specified in register E.     ;
1222: EAE0         ; It is not the same as the disk drive specification in the first byte of   ;
1223: EAE0         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1224: EAE0         ; "use the current default disk" (as specified in the last Select Disk      ;
1225: EAE0         ; call or by the operator on the console). With this function, a value      ;
1226: EAE0         ; of OOH in register A means that A is the selected drive, a value of       ;
1227: EAE0         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1228: EAE0         ; 16 drives in the system.                                                  ;
1229: EAE0         ;                                                                           ;
1230: EAE0         ;			Function Code	:	C = 0EH                                     ;
1231: EAE0         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1232: EAE0         ;			Exit Parameters :	None										;
1233: EAE0         ;																			;
1234: EAE0         ;---------------------------- Select Disk - E (14) -------------------------;
1235: EAE0
1236: EAE0             vSelectDisk:
1237: EAE0 C3 60 EC               JP     SelectCurrent
1238: EAE3
1239: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1240: EAE3         ;  This function opens a specified file for reading or writing. The FCB,    ;
1241: EAE3         ; whose address must be in register DE, tells CP/M the user number,         ;
1242: EAE3         ; the logical disk, the file name, and the file type. All other bytes of    ;
1243: EAE3         ; the FCB will normally be set to O.                                        ;
1244: EAE3         ;  The code returned by the BDOS in register A indicates whether the file   ;
1245: EAE3         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1246: EAE3         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1247: EAE3         ; then the file has been opened.                                            ;
1248: EAE3         ;			Function Code	:	C  = 0FH                                    ;
1249: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1250: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1251: EAE3         ;																			;
1252: EAE3         ;---------------------------- Open File - F (15) ---------------------------;
1253: EAE3             vOpenFile:
1254: EAE3 CD F2 EE               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1255: EAE6 CD 73 EE               CALL   ReselectDisk         ; do we need to reselect disk?
1256: EAE9 C3 43 ED               JP     OpenFile
1257: EAEC
1258: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1259: EAEC         ;  This function terminates the processing of a file to which you have      ;
1260: EAEC         ; written information. Under CP/M you do not need to close a file that you  ;
1261: EAEC         ; have been reading. However, if you ever intend for your program to        ;
1262: EAEC         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1263: EAEC         ; should close all files regardless of their use.                           ;
1264: EAEC         ;  The Close File function, like Open File, returns a directory code in     ;
1265: EAEC         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1266: EAEC         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1267: EAEC         ; been closed.                                                              ;
1268: EAEC         ;                                                                           ;
1269: EAEC         ;  When the BDOS closes a file to which data has been written, it writes    ;
1270: EAEC         ; the current contents of the FCB out to the disk directory, updating       ;
1271: EAEC         ; an existing directory entry by matching the disk, name, type, and         ;
1272: EAEC         ; extent number in the same manner that the Open File function does.        ;
1273: EAEC         ; Note that the BDOS does not transfer the last record of the file to the   ;
1274: EAEC         ; disk during the close operation. It merely updates the file directory.    ;
1275: EAEC         ; You must arrange to flush any partly filled record to the disk. If the    ;
1276: EAEC         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1277: EAEC         ; arrange to fill the unused portion of the record with the standard lAH    ;
1278: EAEC         ; end-of-file characters as CP/M expects.                                   ;
1279: EAEC         ;                                                                           ;
1280: EAEC         ;			Function Code	:	C  = 10FH                                   ;
1281: EAEC         ;			Entry Parameters:	DE = Address of File Control Block			;
1282: EAEC         ;			Exit Parameters :	A  = Directory Code							;
1283: EAEC         ;																			;
1284: EAEC         ;---------------------------- Close File - 10 (16) -------------------------;
1285: EAEC             vCloseFile:
1286: EAEC CD 73 EE               CALL   ReselectDisk
1287: EAEF C3 86 ED               JP     CloseDirEntry
1288: EAF2
1289: EAF2         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1290: EAF2         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1291: EAF2         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1292: EAF2         ; This function returns a bit map, called the login vector, in register pair ;
1293: EAF2         ; HL, indicating which logical disk drives have been selected since the last ;
1294: EAF2         ; warm boot or Reset Disk function (code 13, ODH). The least significant bit ;
1295: EAF2         ; of L corresponds to disk A, while the highest order bit in H maps disk P.  ;
1296: EAF2         ; The bit corresponding to the specific logical disk is set to 1 if the      ;
1297: EAF2         ; disk has been selected or to 0 if the disk is not currently on-line.       ;
1298: EAF2         ;  Logical disks can be selected programmatically through any file operation ;
1299: EAF2         ; that sets the drive field to a nonzero value, through the Select Disk      ;
1300: EAF2         ; function (code 14, OEH), or by the operator entering an "X:" command       ;
1301: EAF2         ; where "X" is equal to A, B, ... , P.                                       ;
1302: EAF2         ;                                                                            ;
1303: EAF2         ;			Function Code	:	C = 018H                                     ;
1304: EAF2         ;			Entry Parameters:	None										 ;
1305: EAF2         ;			Exit Parameters :	HL = Active disk map (login vector)			 ;
1306: EAF2         ;																			 ;
1307: EAF2         ;---------------------------- Get Active Disks - 18 (24) --------------------;
1308: EAF2             vGetLoginVector:
1309: EAF2 2A 6B F5               LD     HL,(loggedDisks)
1310: EAF5 22 C5 EA               LD     (exitParameterWord),HL
1311: EAF8 C9                     RET
1312: EAF9         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1313: EAF9         ;   This function returns the current default disk set by the last Select    ;
1314: EAF9         ; Disk function call (code 14, OEH) or by the operator entering the          ;
1315: EAF9         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                        ;
1316: EAF9         ;                                                                            ;
1317: EAF9         ;  This function returns the current default disk in coded form.             ;
1318: EAF9         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.    ;
1319: EAF9         ; If you need to convert this to the corresponding ASCII character, simply   ;
1320: EAF9         ; add 41H to register A. Use this function when you convert a file name and  ;
1321: EAF9         ; type in an FCB to an ASCII string in order to display it. If the first     ;
1322: EAF9         ; byte of the FCB is OOH, the current default drive is to be used.           ;
1323: EAF9         ; You must therefore use this function to determine the logical disk letter  ;
1324: EAF9         ; for the default drive.                                                     ;
1325: EAF9         ;                                                                            ;
1326: EAF9         ;			Function Code	:	C = 019H                                     ;
1327: EAF9         ;			Entry Parameters:	None										 ;
1328: EAF9         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			 ;
1329: EAF9         ;																			 ;
1330: EAF9         ;---------------------------- Get Current Disk- 19 (25) ---------------------;
1331: EAF9             vGetCurrentDisk:
1332: EAF9 3A 67 F5               LD     A,(currentDisk)
1333: EAFC 32 C5 EA               LD     (exitParameterByte),A
1334: EAFF C9                     RET
1335: EB00         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1336: EB00         ;  This function sets the BDOS's direct memory access (DMA) address to a new ;
1337: EB00         ; value. The name is an historic relic dating back to the Intel Development  ;
1338: EB00         ; System on which CP/M was originally developed. This machine, by virtue of  ;
1339: EB00         ; its hardware, could read data from a diskette directly into memory or      ;
1340: EB00         ; write data to a diskette directly from memory. The name DMA address now    ;
1341: EB00         ; applies to the address of the buffer to and from which data is             ;
1342: EB00         ; transferred whenever a diskette Read, Write, or directory operation is     ;
1343: EB00         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or      ;
1344: EB00         ; Reset Disk operation occurs, the DMA address is reset to its default       ;
1345: EB00         ; value of 0080H.                                                            ;
1346: EB00         ;                                                                            ;
1347: EB00         ;			Function Code	:	C = 0A9H                                     ;
1348: EB00         ;			Entry Parameters:	DE = DMA Address							 ;
1349: EB00         ;			Exit Parameters :	None										 ;
1350: EB00         ;																			 ;
1351: EB00         ;---------------------------- Set DMA Address - 1A (26) ---------------------;
1352: EB00             vSetDMA:
1353: EB00 2A C3 EA               LD     HL,(paramDE)
1354: EB03 22 6D F5               LD     (initDAMAddress),HL
1355: EB06 C3 3A EE               JP     SetDataDMA
1356: EB09
1357: EB09         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1358: EB09         ;  This function returns the base, or starting, address of the allocation    ;
1359: EB09         ; vector for the currently selected logical disk. This information,          ;
1360: EB09         ; indicating which parts of the disk are assigned, is used by utility        ;
1361: EB09         ; programs and the BDOS itself to determine how much unused space is on the  ;
1362: EB09         ; logical disk, to locate an unused allocation block in order to extend      ;
1363: EB09         ; a file, or to relinquish an allocation block when a file is deleted.       ;
1364: EB09         ;                                                                            ;
1365: EB09         ;			Function Code	:	C = 01BH                                     ;
1366: EB09         ;			Entry Parameters:	None										 ;
1367: EB09         ;			Exit Parameters :	HL = Address of allocation vector			 ;
1368: EB09         ;																			 ;
1369: EB09         ;---------------------------- Get Allocation Vector - 1B (27) ---------------;
1370: EB09             vGetAllocAddr:
1371: EB09 2A 7B F5               LD     HL,(caAllocVector)
1372: EB0C 22 C5 EA               LD     (exitParameterWord),HL
1373: EB0F C9                     RET
1374: EB10
1375: EB10         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1376: EB10         ;  This function logically sets the currently selected disk to a Read-Only   ;
1377: EB10         ; state. Any attempts to execute a Write Sequential or Write Random function ;
1378: EB10         ; to the selected disk will be intercepted by the BDOS, and the following    ;
1379: EB10         ; message will appear on the console:                                        ;
1380: EB10         ;	BDOS Err on X: R/O                                                       ;
1381: EB10         ;	where X: is the selected disk.                                           ;
1382: EB10         ;                                                                            ;
1383: EB10         ;  Once you have requested Read-Only status for the currently selected       ;
1384: EB10         ; logical disk, this status will persist even if you proceed to select       ;
1385: EB10         ; other logical disks. In fact, it will remain in force until the next warm  ;
1386: EB10         ; boot or Reset Disk System function call.                                   ;
1387: EB10         ;  Digital Research documentation refers to this function code as Disk Write ;
1388: EB10         ; Protect. The Read-Only description is used here because it corresponds     ;
1389: EB10         ; to the error message produced if your program attempts to write on         ;
1390: EB10         ; the disk.                                                                  ;
1391: EB10         ;                                                                            ;
1392: EB10         ;			Function Code	:	C = 01CH                                     ;
1393: EB10         ;			Entry Parameters:	None										 ;
1394: EB10         ;			Exit Parameters :	None										 ;
1395: EB10         ;																			 ;
1396: EB10         ;---------------------------- Write Protect Disk - 1C (28) ------------------;
1397: EB10         ;;write protect current disk
1398: EB10             vWriteProtectDisk:
1399: EB10 C3 50 EE               JP     SetDiskReadOnly
1400: EB13
1401: EB13         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1402: EB13         ;  This function returns a bit map in registers H and L showing which logical;
1403: EB13         ; disks in the system have been set to Read-Only status, either by the       ;
1404: EB13         ; Set Logical Disk to Read-Only function call (code 28, ICH), or by the      ;
1405: EB13         ; BDOS itself, because it detected that a diskette had been changed.         ;
1406: EB13         ;  The least significant bit of L corresponds to logical disk A, while the   ;
1407: EB13         ; most significant bit of H corresponds to disk P. The bit corresponding to  ;
1408: EB13         ; the specific logical disk is set to I if the disk has been set to          ;
1409: EB13         ; Read-Only status.                                                          ;
1410: EB13         ;                                                                            ;
1411: EB13         ;			Function Code	:	C = 01DH                                     ;
1412: EB13         ;			Entry Parameters:	None										 ;
1413: EB13         ;			Exit Parameters :	HL = Read-Only Vector						 ;
1414: EB13         ;																			 ;
1415: EB13         ;---------------------------- Get Read-Only Map - 1D (29) -------------------;
1416: EB13             vGetReadOnlyMap:
1417: EB13 2A 69 F5               LD     HL,(readOnlyVector)
1418: EB16 22 C5 EA               LD     (exitParameterWord),HL
1419: EB19 C9                     RET
1420: EB1A
1421: EB1A         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1422: EB1A         ;  This function returns the address of the disk parameter block (DPB) for   ;
1423: EB1A         ; the last selected logical disk. The DPB describes the physical             ;
1424: EB1A         ; characteristics of a specific logical disk-information mainly of interest  ;
1425: EB1A         ; for system utility programs.                                               ;
1426: EB1A         ;                                                                            ;
1427: EB1A         ;			Function Code	:	C = 1FH                                      ;
1428: EB1A         ;			Entry Parameters:	None										 ;
1429: EB1A         ;			Exit Parameters :	HL = Address of Disk Parameter Block		 ;
1430: EB1A         ;																			 ;
1431: EB1A         ;------------------ Get Disk Parameter Block Address - 1F (31) --------------;
1432: EB1A             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1433: EB1A 2A 77 F5               LD     HL,(caDiskParamBlock)
1434: EB1D 22 C5 EA               LD     (exitParameterWord),HL
1435: EB20 C9                     RET
1436: EB21
1437: EB21         ;---------------------------- XXXXX YYYY ZZZZZZ - x (nn) --------------------;
1438: EB21         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1439: EB21         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1440: EB21         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1441: EB21
1442: EB21         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1443: EB21         ;  This function resets individual disk drives. It is a more precise version ;
1444: EB21         ; of the Reset Disk System function (code 13,ODH), in that you can set       ;
1445: EB21         ; specific logical; disks rather than all of them.                           ;
1446: EB21         ;  The bit map in DE shows which disks are to be reset. The least significant;
1447: EB21         ; bit of; E represents disk A, and the most significant bit of D, disk P.    ;
1448: EB21         ; The bits set to I indicate the disks to be reset.                          ;
1449: EB21         ;  Note that this function returns a zero value in A in order to maintain    ;
1450: EB21         ; compatibility with MP/ M.                                                  ;
1451: EB21         ;                                                                            ;
1452: EB21         ;			Function Code	:	C = 25H                                      ;
1453: EB21         ;			Entry Parameters:	DE = Logical Drive Bit Vector					 ;
1454: EB21         ;			Exit Parameters :	A = 00H										 ;
1455: EB21         ;																			 ;
1456: EB21         ;------------------------ Reset Logical Disk Drive - 25 (37) ----------------;
1457: EB21         ;Reset Drive
1458: EB21         ;IN  - (DE) Drive Vector
1459: EB21         ;OUT - (A) 00
1460: EB21             vResetDrive:                      ; func37 (37 - 25) Reset Drive
1461: EB21         ; Not Yet Implemented   **************
1462: EB21 C9                     RET
1463: EB22         ;*****************************************************************
1464: EB22
1465: EB22         ;-----------------------------------------------------------------
1466: EB22
1467: EB22         ;*****************************************************************
1468: EB22         ;random disk read
1469: EB22         ;IN  - (DE) FCB address
1470: EB22         ;OUT - (A) 01 = Reading unwritten data
1471: EB22         ;	 02 = N/U
1472: EB22         ;	 03 = Cannot close current extent
1473: EB22         ;	 04 = Seek to unwriten Extent
1474: EB22         ;	 05 = N/U
1475: EB22         ;	 06 = Seek past Physical end of Disk
1476: EB22             vReadRandom:                      ; func33 (33 - 21) Read Random record
1477: EB22 CD 73 EE               CALL   ReselectDisk
1478: EB25 C3 38 EB               JP     RandomDiskRead       ; to perform the disk read
1479: EB28         ;*****************************************************************
1480: EB28         ;write random record
1481: EB28         ;IN  - (DE) FCB address
1482: EB28         ;OUT - (A) 01 = Reading unwritten data
1483: EB28         ;	 02 = N/U
1484: EB28         ;	 03 = Cannot close current extent
1485: EB28         ;	 04 = Seek to unwriten Extent
1486: EB28         ;	 05 = Cannot create new Extent because of directory overflow
1487: EB28         ;	 06 = Seek past Physical end of Disk
1488: EB28             vWriteRandom:                      ; func34 (34 - 22) Write Random record
1489: EB28 CD 73 EE               CALL   ReselectDisk
1490: EB2B C3 41 EB               JP     RandomDiskWrite      ; to perform the disk write
1491: EB2E         ;ret ;jmp goback
1492: EB2E         ;*****************************************************************
1493: EB2E         ;return file size (0-65536)
1494: EB2E         ;IN  - (DE) FCB address
1495: EB2E             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
1496: EB2E CD 73 EE               CALL   ReselectDisk
1497: EB31 C3 EE EB               JP     GetFileSize
1498: EB34         ;*****************************************************************
1499: EB34         ;set random record
1500: EB34         ;IN  - (DE) FCB address
1501: EB34         ;OUT - Random Record Field is set
1502: EB34             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
1503: EB34 C3 DB EB               JP     SetRandomRecord
1504: EB37         ;? ;*****************************************************************
1505: EB37         ;? ;Reset Drive
1506: EB37         ;? ;IN  - (DE) Drive Vector
1507: EB37         ;? ;OUT - (A) 00
1508: EB37         ;? vResetDrive:								; func37 (37 - 25) Reset Drive
1509: EB37         ;? ; Not Yet Implemented   **************
1510: EB37         ;?	RET
1511: EB37         ;*****************************************************************
1512: EB37         ;*****************************************************************
1513: EB37         ;Write Random With Zero Fill
1514: EB37         ;IN  - (DE) FCB address
1515: EB37         ;OUT - (A) Return Code		see Function 34
1516: EB37             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
1517: EB37         ; Not Yet Implemented   **************
1518: EB37 C9                     RET
1519: EB38         ;*****************************************************************
1520: EB38         ;******************< Random I/O Stuff ****************************
1521: EB38         ;*****************************************************************
1522: EB38         ;random disk read
1523: EB38             RandomDiskRead:                      ; randiskread
1524: EB38 0E FF                  LD     C,TRUE               ; marked as read operation
1525: EB3A CD 4A EB               CALL   RandomSeek
1526: EB3D CC FE F1               CALL   Z,DiskRead           ; if seek successful
1527: EB40 C9                     RET
1528: EB41         ;*****************************************************************
1529: EB41         ;random disk write
1530: EB41             RandomDiskWrite:                      ; randiskwrite
1531: EB41 0E 00                  LD     C,FALSE              ; marked as read operation
1532: EB43 CD 4A EB               CALL   RandomSeek
1533: EB46 CC 41 F2               CALL   Z,DiskWrite          ; if seek successful
1534: EB49 C9                     RET
1535: EB4A         ;*****************************************************************
1536: EB4A         ;*****************************************************************
1537: EB4A         ;random access seek operation, C=0ffh if read mode
1538: EB4A         ;fcb is assumed to address an active file control block
1539: EB4A         ;(fcbS2Index has been set to 11000000b if previous bad seek)
1540: EB4A             RandomSeek:
1541: EB4A AF                     XOR    A
1542: EB4B 32 91 F5               LD     (seqReadFlag),A      ; marked as random access operation
1543: EB4E C5                     PUSH   BC                   ; save r/w flag
1544: EB4F 2A C3 EA               LD     HL,(paramDE)
1545: EB52 EB                     EX     DE,HL                ; DE will hold base of fcb
1546: EB53 21 21 00               LD     HL,RANDOM_REC_FIELD
1547: EB56 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
1548: EB57 7E                     LD     A,(HL)
1549: EB58 E6 7F                  AND    7FH
1550: EB5A F5                     PUSH   AF                   ; record number
1551: EB5B 7E                     LD     A,(HL)
1552: EB5C 17                     RLA                         ; cy=lsb of extent#
1553: EB5D 23                     INC    HL
1554: EB5E 7E                     LD     A,(HL)
1555: EB5F 17                     RLA
1556: EB60 E6 1F                  AND    11111B               ; A=ext#
1557: EB62 4F                     LD     C,A                  ; C holds extent number, record stacked
1558: EB63 7E                     LD     A,(HL)
1559: EB64 1F                     RRA
1560: EB65 1F                     RRA
1561: EB66 1F                     RRA
1562: EB67 1F                     RRA
1563: EB68 E6 0F                  AND    1111B                ; mod#
1564: EB6A 47                     LD     B,A                  ; B holds module#, C holds ext#
1565: EB6B F1                     POP    AF                   ; recall sought record #
1566: EB6C         ;check to insure that high byte of ran rec = 00
1567: EB6C 23                     INC    HL
1568: EB6D 6E                     LD     L,(HL)               ; l=high byte (must be 00)
1569: EB6E 2C                     INC    L
1570: EB6F 2D                     DEC    L
1571: EB70 2E 06                  LD     L,06                 ; zero flag, l=6
1572: EB72         ; produce error 6, seek past physical eod
1573: EB72 C2 D3 EB               JP     NZ,RandomSeekError
1574: EB75         ; otherwise, high byte = 0, A = sought record
1575: EB75 21 20 00               LD     HL,NEXT_RECORD
1576: EB78 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
1577: EB79 77                     LD     (HL),A               ; sought rec# stored away
1578: EB7A         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
1579: EB7A         ; the r/w flag is still stacked.  compare fcb values
1580: EB7A 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
1581: EB7D 19                     ADD    HL,DE
1582: EB7E 79                     LD     A,C                  ; A=seek ext#
1583: EB7F 96                     SUB    M
1584: EB80 C2 8E EB               JP     NZ,RandomSeekClose   ; tests for = extents
1585: EB83         ; extents match, check mod#
1586: EB83 21 0E 00               LD     HL,fcbS2Index
1587: EB86 19                     ADD    HL,DE
1588: EB87 78                     LD     A,B                  ; B=seek mod#
1589: EB88         ; could be overflow at eof, producing module#
1590: EB88         ; of 90H or 10H, so compare all but fwf
1591: EB88 96                     SUB    M
1592: EB89 E6 7F                  AND    7FH
1593: EB8B CA C6 EB               JP     Z,RandomSeekExit     ; same?
1594: EB8E             RandomSeekClose:
1595: EB8E C5                     PUSH   BC
1596: EB8F D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
1597: EB90 CD 86 ED               CALL   CloseDirEntry        ; current extent closed
1598: EB93 D1                     POP    DE
1599: EB94 C1                     POP    BC                   ; recall parameters and fill
1600: EB95 2E 03                  LD     L,03                 ; cannot close error #3
1601: EB97 3A C5 EA               LD     A,(exitParameterByte)
1602: EB9A 3C                     INC    A
1603: EB9B CA CC EB               JP     Z,RandomSeekErrorBadSeek
1604: EB9E 21 0C 00               LD     HL,fcbExtIndex
1605: EBA1 19                     ADD    HL,DE
1606: EBA2 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
1607: EBA3 21 0E 00               LD     HL,fcbS2Index
1608: EBA6 19                     ADD    HL,DE
1609: EBA7 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
1610: EBA8 CD 43 ED               CALL   OpenFile             ; is the file present?
1611: EBAB 3A C5 EA               LD     A,(exitParameterByte)
1612: EBAE 3C                     INC    A
1613: EBAF C2 C6 EB               JP     NZ,RandomSeekExit    ; open successful?
1614: EBB2         ; cannot open the file, read mode?
1615: EBB2 C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
1616: EBB3 C5                     PUSH   BC                   ; everyone expects this item stacked
1617: EBB4 2E 04                  LD     L,04                 ; seek to unwritten extent #4
1618: EBB6 0C                     INC    C                    ; becomes 00 if read operation
1619: EBB7 CA CC EB               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
1620: EBBA CD 8C F3               CALL   MakeNewFile          ; write operation, make new extent
1621: EBBD 2E 05                  LD     L,05                 ; cannot create new extent #5
1622: EBBF 3A C5 EA               LD     A,(exitParameterByte)
1623: EBC2 3C                     INC    A
1624: EBC3 CA CC EB               JP     Z,RandomSeekErrorBadSeek ; no dir space
1625: EBC6         ; file make operation successful
1626: EBC6             RandomSeekExit:                      ; seekok:
1627: EBC6 C1                     POP    BC                   ; discard r/w flag
1628: EBC7 AF                     XOR    A
1629: EBC8 32 C5 EA               LD     (exitParameterByte),A
1630: EBCB C9                     RET                         ; with zero set
1631: EBCC
1632: EBCC             RandomSeekErrorBadSeek:
1633: EBCC         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
1634: EBCC         ; appears as overflow with file write flag set
1635: EBCC E5                     PUSH   HL                   ; save error flag
1636: EBCD CD F8 EE               CALL   GetExtentNumberMSB   ; HL = .fcbS2Index
1637: EBD0 36 C0                  LD     (HL),11000000B
1638: EBD2 E1                     POP    HL                   ; and drop through
1639: EBD3             RandomSeekError:                      ; seekerr:
1640: EBD3 C1                     POP    BC                   ; discard r/w flag
1641: EBD4 7D                     LD     A,L
1642: EBD5 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte=#, nonzero
1643: EBD8         ; SetFileWriteFlag returns non-zero accumulator for err
1644: EBD8 C3 01 EF               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
1645: EBDB         ;ret
1646: EBDB         ;
1647: EBDB         ;*****************************************************************
1648: EBDB             SetRandomRecord:                      ; setrandom
1649: EBDB 2A C3 EA               LD     HL,(paramDE)
1650: EBDE 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
1651: EBE1 CD 2A EC               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
1652: EBE4 21 21 00               LD     HL,RANDOM_REC_FIELD
1653: EBE7 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
1654: EBE8 71                     LD     (HL),C
1655: EBE9 23                     INC    HL
1656: EBEA 70                     LD     (HL),B
1657: EBEB 23                     INC    HL
1658: EBEC 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
1659: EBED C9                     RET
1660: EBEE         ;*****************************************************************
1661: EBEE         ;compute logical file size for current fcb
1662: EBEE             GetFileSize:                      ; getfilesize
1663: EBEE 0E 0C                  LD     C,fcbExtIndex
1664: EBF0 CD 20 EF               CALL   SearchForDirectoryRecord
1665: EBF3         ; zero the receiving Ramdom record field
1666: EBF3 2A C3 EA               LD     HL,(paramDE)
1667: EBF6 11 21 00               LD     DE,RANDOM_REC_FIELD
1668: EBF9 19                     ADD    HL,DE
1669: EBFA E5                     PUSH   HL                   ; save position
1670: EBFB 72                     LD     (HL),D
1671: EBFC 23                     INC    HL
1672: EBFD 72                     LD     (HL),D
1673: EBFE 23                     INC    HL
1674: EBFF 72                     LD     (HL),D               ; =00 00 00
1675: EC00             GetFileSize1:                      ; getsize:
1676: EC00 CD BC EF               CALL   AtEndOfDirectory
1677: EC03 CA 28 EC               JP     Z,GetFileSizeExit
1678: EC06         ; current fcb addressed by dptr
1679: EC06 CD C5 EF               CALL   GetCurrentDirectoryRecord
1680: EC09 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
1681: EC0C CD 2A EC               CALL   GetRandomRecordPosition
1682: EC0F         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
1683: EC0F E1                     POP    HL
1684: EC10 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
1685: EC11 5F                     LD     E,A                  ; save cy
1686: EC12 79                     LD     A,C
1687: EC13 96                     SUB    M
1688: EC14 23                     INC    HL                   ; ls byte
1689: EC15 78                     LD     A,B
1690: EC16 9E                     SBC    A,(HL)
1691: EC17 23                     INC    HL                   ; middle byte
1692: EC18 7B                     LD     A,E
1693: EC19 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
1694: EC1A DA 22 EC               JP     C,GetFileSize2       ; for another try
1695: EC1D         ; fcb is less or equal, fill from directory
1696: EC1D 73                     LD     (HL),E
1697: EC1E 2B                     DEC    HL
1698: EC1F 70                     LD     (HL),B
1699: EC20 2B                     DEC    HL
1700: EC21 71                     LD     (HL),C
1701: EC22             GetFileSize2:                      ; getnextsize:
1702: EC22 CD 35 EF               CALL   GetNextDirectoryRecord
1703: EC25 C3 00 EC               JP     GetFileSize1
1704: EC28             GetFileSizeExit:                      ; setsize:
1705: EC28 E1                     POP    HL                   ; discard .fcb(random record field)
1706: EC29 C9                     RET
1707: EC2A         ;-----------------------------------------------------------------
1708: EC2A         ;compute random record position
1709: EC2A             GetRandomRecordPosition:                      ; compute$rr
1710: EC2A EB                     EX     DE,HL
1711: EC2B 19                     ADD    HL,DE
1712: EC2C         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
1713: EC2C 4E                     LD     C,(HL)
1714: EC2D 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
1715: EC2F 21 0C 00               LD     HL,fcbExtIndex
1716: EC32 19                     ADD    HL,DE
1717: EC33 7E                     LD     A,(HL)
1718: EC34 0F                     RRCA
1719: EC35 E6 80                  AND    80H                  ; A=e000 0000
1720: EC37 81                     ADD    A,C
1721: EC38 4F                     LD     C,A
1722: EC39 3E 00                  LD     A,0
1723: EC3B 88                     ADC    A,B
1724: EC3C 47                     LD     B,A
1725: EC3D         ; BC = 0000 000? errrr rrrr
1726: EC3D 7E                     LD     A,(HL)
1727: EC3E 0F                     RRCA
1728: EC3F E6 0F                  AND    LO_NIBBLE_MASK
1729: EC41 80                     ADD    A,B
1730: EC42 47                     LD     B,A
1731: EC43         ; BC = 000? eeee errrr rrrr
1732: EC43 21 0E 00               LD     HL,fcbS2Index
1733: EC46 19                     ADD    HL,DE
1734: EC47 7E                     LD     A,(HL)               ; A=XXX? mmmm
1735: EC48 87                     ADD    A,A
1736: EC49 87                     ADD    A,A
1737: EC4A 87                     ADD    A,A
1738: EC4B 87                     ADD    A,A                  ; cy=? A=mmmm 0000
1739: EC4C F5                     PUSH   AF
1740: EC4D 80                     ADD    A,B
1741: EC4E 47                     LD     B,A
1742: EC4F         ; cy=?, BC = mmmm eeee errr rrrr
1743: EC4F F5                     PUSH   AF                   ; possible second carry
1744: EC50 E1                     POP    HL                   ; cy = lsb of L
1745: EC51 7D                     LD     A,L                  ; cy = lsb of A
1746: EC52 E1                     POP    HL                   ; cy = lsb of L
1747: EC53 B5                     OR     L                    ; cy/cy = lsb of A
1748: EC54 E6 01                  AND    1                    ; A = 0000 000? possible carry-out
1749: EC56 C9                     RET
1750: EC57         ;-----------------------------------------------------------------
1751: EC57
1752: EC57
1753: EC57
1754: EC57         ;*****************************************************************
1755: EC57         ;********************** Disk  I/O ********************************
1756: EC57         ;*****************************************************************
1757: EC57         ;-----------------------------------------------------------------
1758: EC57         ;;set file Attributes
1759: EC57             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1760: EC57 CD 73 EE               CALL   ReselectDisk
1761: EC5A CD 7E F1               CALL   SetAttributes
1762: EC5D C3 10 F4               JP     DirLocationToReturnLoc ; exitParameterByte=dirloc
1763: EC60         ;-----------------------------------------------------------------
1764: EC60         ;--------------------------- Select  Drive ---------------------------------;
1765: EC60         ; Establish the disk found in (paramE) as the current disk drive            ;
1766: EC60             SelectCurrent:                      ;
1767: EC60 3A C2 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
1768: EC63 21 67 F5               LD     HL,currentDisk       ; Get the current disk              ;
1769: EC66 BE                     CP     M                    ; Are the the same ?                ;
1770: EC67 C8                     RET    Z                    ; Exit if yes, nothing to do        ;
1771: EC68 77                     LD     (HL),A               ;  else update curretDisk and       ;
1772: EC69 C3 6C EC               JP     Select               ;  select it                        ;
1773: EC6C         ;--------------------------- Select  Drive ---------------------------------;
1774: EC6C         ;--------------------------- Select Login Drive ----------------------------;
1775: EC6C         ; select Login Drive                                                       ;
1776: EC6C             Select:                         ;
1777: EC6C CD 8D EC               CALL   SelectDisk           ; Select the Disk                   ;
1778: EC6F CC D6 F4               CALL   Z,errSelect          ;
1779: EC72 21 67 F5               LD     HL,currentDisk       ;
1780: EC75 46                     LD     B,(HL)               ; Get Current Disk                  ;
1781: EC76 2A 6B F5               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
1782: EC79 CD A8 F4               CALL   IsBitSet             ;
1783: EC7C C0                     RET    NZ                   ; Exit if already logged in         ;
1784: EC7D         ;                                                                           ;
1785: EC7D 21 67 F5               LD     HL,currentDisk       ;
1786: EC80 46                     LD     B,(HL)               ; Get Current Disk                  ;
1787: EC81 2A 6B F5               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
1788: EC84 CD B8 F4               CALL   SetVectorBit         ;
1789: EC87 22 6B F5               LD     (loggedDisks),HL     ; Update the Vector                 ;
1790: EC8A         ;
1791: EC8A C3 D3 EC               JP     InitDisk             ;
1792: EC8D         ;--------------------------- Select Login Drive ----------------------------;
1793: EC8D         ;--------------------------- Select Disk ------------------------------------;
1794: EC8D         ;*****************************************************************          ;
1795: EC8D         ; select the disk drive given by currentDisk, and fill the base addresses   ;
1796: EC8D         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
1797: EC8D             SelectDisk:                      ;
1798: EC8D 3A 67 F5               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)      ;
1799: EC90 4F                     LD     C,A                  ; Prepare for BIOS Call              ;
1800: EC91 CD 1B F6               CALL   bcSeldsk             ; Select the disk                    ;
1801: EC94 7C                     LD     A,H                  ; Return Pointer to                  ;
1802: EC95 B5                     OR     L                    ;  Disk Parameter Header             ;
1803: EC96 C8                     RET    Z                    ; exit if error, with HL = 0000      ;
1804: EC97         ;
1805: EC97 5E                     LD     E,(HL)               ;
1806: EC98 23                     INC    HL                   ;
1807: EC99 56                     LD     D,(HL)               ; Skew Table in DE                   ;
1808: EC9A 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File     ;
1809: EC9B ED 53 8C F5               LD     (caSkewTable),DE     ; Move to Current Skew Table         ;
1810: EC9F         ;
1811: EC9F 22 6F F5               LD     (caDirMaxValue),HL   ; Move to Current Dir max            ;
1812: ECA2 23                     INC    HL                   ;
1813: ECA3 23                     INC    HL                   ; HL = Last Track #                  ;
1814: ECA4 22 71 F5               LD     (caTrack),HL         ; Move to Current Track #            ;
1815: ECA7 23                     INC    HL                   ;
1816: ECA8 23                     INC    HL                   ; HL = Last Sector #                 ;
1817: ECA9 22 73 F5               LD     (caSector),HL        ; Move to Current Sector #           ;
1818: ECAC 23                     INC    HL                   ;
1819: ECAD 23                     INC    HL                   ;
1820: ECAE 11 75 F5               LD     DE,caDirectoryDMA    ;
1821: ECB1 01 08 00               LD     BC,caListSize        ;
1822: ECB4 ED B0                  LDIR                        ;
1823: ECB6         ;
1824: ECB6         ; finish filling in address list                                             ;
1825: ECB6 2A 77 F5               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block         ;
1826: ECB9 11 7D F5               LD     DE,dpbStart          ; Point at BIOS DPB                  ;
1827: ECBC 01 0F 00               LD     BC,dpbSize           ;
1828: ECBF ED B0                  LDIR                        ; Move DPB to current                ;
1829: ECC1         ;
1830: ECC1         ; Determine if Byte or Word Allocation Table	                             ;
1831: ECC1 2A 82 F5               LD     HL,(dpbDSM)          ; Get max entry number               ;
1832: ECC4 7C                     LD     A,H                  ; If  its 00 then < 255              ;
1833: ECC5 21 96 F5               LD     HL,byteAllocationFlag ; Point at the  flag				 ;
1834: ECC8 36 FF                  LD     (HL),TRUE            ; Assume its less than 255           ;
1835: ECCA B7                     OR     A                    ;  is the assumption confirmed ?     ;
1836: ECCB 28 02                  JR     Z,SelectDisk1        ;  skip if yes                       ;
1837: ECCD 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false   ;
1838: ECCF         ;
1839: ECCF         ; Set Sign, reset Carry and Zero to indicate success                         ;
1840: ECCF             SelectDisk1:                      ;
1841: ECCF 3E FF                  LD     A,TRUE               ;
1842: ECD1 B7                     OR     A                    ;
1843: ECD2 C9                     RET                         ;
1844: ECD3         ;--------------------------- Select Disk ------------------------------------;
1845: ECD3         ;--------------------------- Initialize Disk --------------------------------;
1846: ECD3             InitDisk:                       ;
1847: ECD3 2A 82 F5               LD     HL,(dpbDSM)          ; Maximum allocation value           ;
1848: ECD6 CD 98 F0               CALL   DivideHLby8          ; Length of Map                      ;
1849: ECD9 E5                     PUSH   HL                   ; Save Length                        ;
1850: ECDA E5                     PUSH   HL                   ; Save for end of MAP                ;
1851: ECDB C1                     POP    BC                   ; BC = dpbDSM/8                      ;
1852: ECDC         ; Clear the Allocation Vector	                                             ;
1853: ECDC 2A 7B F5               LD     HL,(caAllocVector)   ; Allocation vector Start            ;
1854: ECDF 36 00                  LD     (HL),0               ; Clear location                     ;
1855: ECE1 ED 5B 7B F5               LD     DE,(caAllocVector)   ;
1856: ECE5 13                     INC    DE                   ; Allocation vector Start + 1        ;
1857: ECE6 ED B0                  LDIR                        ; Cascade 00 thru Map                ;
1858: ECE8         ; Force bits at End of Map                                                   ;
1859: ECE8 EB                     EX     DE,HL                ; Put last Map byte into DE          ;
1860: ECE9 E1                     POP    HL                   ;
1861: ECEA 23                     INC    HL                   ;
1862: ECEB CD A2 F0               CALL   MultiplyHLby8        ; Blocks if all bits used            ;
1863: ECEE ED 4B 82 F5               LD     BC,(dpbDSM)          ; Actual block max                   ;
1864: ECF2 03                     INC    BC                   ; Now has size of the Map            ;
1865: ECF3 AF                     XOR    A                    ; Clear CY                           ;
1866: ECF4 ED 42                  SBC    HL,BC                ; Extra unused bits                  ;
1867: ECF6 BD                     CP     L                    ;  are there any                     ;
1868: ECF7 28 07                  JR     Z,Mark4Directory     ;
1869: ECF9 45                     LD     B,L                  ; Number of bits to set              ;
1870: ECFA EB                     EX     DE,HL                ; Put last Map byte into HL          ;
1871: ECFB             SetBitLoop:                      ;
1872: ECFB 37                     SCF                         ;
1873: ECFC CB 16                  RL     (HL)                 ; Set LSB                            ;
1874: ECFE 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                 ;
1875: ED00         ;
1876: ED00             Mark4Directory:                      ;
1877: ED00         ; Mark the reserved space for the directory                                  ;
1878: ED00 2A 86 F5               LD     HL,(dpbDABM)         ; Directory block reserved bits      ;
1879: ED03 EB                     EX     DE,HL                ;
1880: ED04 2A 7B F5               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector      ;
1881: ED07 73                     LD     (HL),E               ;
1882: ED08 23                     INC    HL                   ;
1883: ED09 72                     LD     (HL),D               ; Put reserved blocks in Vector      ;
1884: ED0A         ; end of Map                                                                 ;
1885: ED0A         ; Home disk, and set current track and sector to 00                          ;
1886: ED0A CD 20 EE               CALL   Home                 ;
1887: ED0D 2A 6F F5               LD     HL,(caDirMaxValue)   ;
1888: ED10 36 03                  LD     (HL),3               ;
1889: ED12 23                     INC    HL                   ;
1890: ED13 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003       ;
1891: ED15 CD B5 EF               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)           ;
1892: ED18         ;
1893: ED18             InitDisk1:                      ;
1894: ED18         ; Process the directory                                                      ;
1895: ED18 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	     ;
1896: ED1A CD C3 F0               CALL   ReadDirectory        ; Get the directory Record           ;
1897: ED1D CD BC EF               CALL   AtEndOfDirectory     ; Are we Done ?                      ;
1898: ED20 C8                     RET    Z                    ;  Exit if Yes                       ;
1899: ED21         ; Not end of directory, valid entry?                                         ;
1900: ED21 CD C5 EF               CALL   GetCurrentDirectoryRecord ; Calculate location of the element  ;
1901: ED24 3E E5                  LD     A,emptyDir           ;
1902: ED26 BE                     CP     M                    ; Is it an Empty Dir Entry           ;
1903: ED27 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                 ;
1904: ED29         ; Not emptyDir, user code the same?                                          ;
1905: ED29 3A 66 F5               LD     A,(currentUserNumber) ;
1906: ED2C BE                     CP     M                    ;
1907: ED2D 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users   ;
1908: ED2F         ; Same user, check for '$' submit                                            ;
1909: ED2F 23                     INC    HL                   ;
1910: ED30 7E                     LD     A,(HL)               ;
1911: ED31 D6 24                  SUB    DOLLAR               ; Is first Char a $                  ;
1912: ED33 20 04                  JR     NZ,InitDisk2         ;
1913: ED35         ; dollar file found, mark in exitParameterByte                               ;
1914: ED35 3D                     DEC    A                    ; Set A to FFH                       ;
1915: ED36 32 C5 EA               LD     (exitParameterByte),A ; Return it the exit parameter       ;
1916: ED39             InitDisk2:                      ;
1917: ED39         ; now scan the disk map for allocated blocks                                 ;
1918: ED39 0E FF                  LD     C,TRUE               ; set to allocated                   ;
1919: ED3B CD E9 EF               CALL   ScanDiskMap          ;
1920: ED3E CD D3 EF               CALL   SetDirectoryEntry    ; Mark directory entry               ;
1921: ED41 18 D5                  JR     InitDisk1            ; Loop for another entry             ;
1922: ED43         ;--------------------------- Initialize Disk --------------------------------;
1923: ED43         ;----------------------------- Open File -----------------------------------;
1924: ED43         ;search for the directory entry matching FCB at paramDE						;
1925: ED43             OpenFile:                       ;
1926: ED43 0E 0F                  LD     C,nameLength         ;
1927: ED45 CD 20 EF               CALL   SearchForDirectoryRecord ;
1928: ED48 CD BC EF               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
1929: ED4B C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
1930: ED4C         ;
1931: ED4C             CopyDirRecordToFCB:                      ;
1932: ED4C CD C4 EE               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
1933: ED4F 7E                     LD     A,(HL)               ; Get the EXT                      	;
1934: ED50 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
1935: ED51 E5                     PUSH   HL                   ;  also save FCB's pointer         	;
1936: ED52 CD C5 EF               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
1937: ED55 E5                     PUSH   HL                   ; Save Directory Record address    	;
1938: ED56         ;
1939: ED56 ED 5B C3 EA               LD     DE,(paramDE)         ;
1940: ED5A 01 20 00               LD     BC,fcbLength         ;
1941: ED5D ED B0                  LDIR                        ; Move dir record to FCB           	;
1942: ED5F         ;
1943: ED5F         ; note that entire fcb is copied, including indicators                    	;
1944: ED5F CD 01 EF               CALL   SetFileWriteFlag     ; Set clean file flag				;
1945: ED62 D1                     POP    DE                   ; Get Directory Record address     	;
1946: ED63 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
1947: ED66 19                     ADD    HL,DE                ; Directory's EXT address          	;
1948: ED67 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
1949: ED68 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
1950: ED6B 19                     ADD    HL,DE                ; Directory's RC address           	;
1951: ED6C 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
1952: ED6D E1                     POP    HL                   ; Get FCB's Extent Address         	;
1953: ED6E F1                     POP    AF                   ; Get FCB's Extent Value           	;
1954: ED6F 77                     LD     (HL),A               ; Restore Extent Value             	;
1955: ED70         ; if user ext < dir ext then user := 128 records                           	;
1956: ED70         ; if user ext = dir ext then user := dir records                           	;
1957: ED70         ; if user ext > dir ext then user := 0 records                             	;
1958: ED70 79                     LD     A,C                  ; Get the Dir's EXT                	;
1959: ED71 BE                     CP     M                    ; Does it match the FCB'd          	;
1960: ED72 78                     LD     A,B                  ; Get the Dir's  record count      	;
1961: ED73 CA 7D ED               JP     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
1962: ED76 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
1963: ED78 DA 7D ED               JP     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
1964: ED7B 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
1965: ED7D             OpenSetRecordCount:                      ;
1966: ED7D 2A C3 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
1967: ED80 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
1968: ED83 19                     ADD    HL,DE                ; FCB's record count               	;
1969: ED84 77                     LD     (HL),A               ; Set the value                    	;
1970: ED85 C9                     RET                         ;
1971: ED86         ;----------------------------- Open File -----------------------------------;
1972: ED86         ;---------------------------- Close Directory Entry ------------------------;
1973: ED86             CloseDirEntry:                      ;
1974: ED86 AF                     XOR    A                    ;
1975: ED87 32 C5 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
1976: ED8A CD 68 EE               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
1977: ED8D C0                     RET    NZ                   ; Skip close if r/o disk            ;
1978: ED8E         ; check file write flag - 0 indicates written                               ;
1979: ED8E CD F8 EE               CALL   GetWriteProtectValue ; Get file's RO flag                ;
1980: ED91 E6 80                  AND    writeFlagMask        ; Apply the RO Flag for S2          ;
1981: ED93 C0                     RET    NZ                   ; Skip close if r/o file            ;
1982: ED94         ;
1983: ED94 0E 0F                  LD     C,nameLength         ;
1984: ED96 CD 20 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
1985: ED99 CD BC EF               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
1986: ED9C C8                     RET    Z                    ;  exit if at EOD                   ;
1987: ED9D         ;
1988: ED9D         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
1989: ED9D CD C5 EF               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
1990: EDA0 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
1991: EDA3 09                     ADD    HL,BC                ;
1992: EDA4 EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
1993: EDA5 2A C3 EA               LD     HL,(paramDE)         ;
1994: EDA8 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
1995: EDA9 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
1996: EDAB         ;
1997: EDAB             MergeAllocationMaps:                      ;
1998: EDAB 3A 96 F5               LD     A,(byteAllocationFlag) ;
1999: EDAE B7                     OR     A                    ;
2000: EDAF CA C6 ED               JP     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2001: EDB2         ; process byte size Map	                                                    ;
2002: EDB2 7E                     LD     A,(HL)               ; FCB Block number                  ;
2003: EDB3 B7                     OR     A                    ; Is it 0 ?                         ;
2004: EDB4 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2005: EDB5 C2 B9 ED               JP     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2006: EDB8 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2007: EDB9             MergeFCBisNot0:                      ;
2008: EDB9 B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2009: EDBA C2 BF ED               JP     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2010: EDBD 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2011: EDBE 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2012: EDBF             MergeDirEntryNot0:                      ;
2013: EDBF BE                     CP     M                    ; Do FCB and Dir match values       ;
2014: EDC0 C2 01 EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2015: EDC3 C3 DB ED               JP     MergeMapLoop         ; Go see if there is more           ;
2016: EDC6         ;
2017: EDC6             MergeWordMaps:                      ;
2018: EDC6 CD AC F0               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2019: EDC9 EB                     EX     DE,HL                ;
2020: EDCA CD AC F0               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2021: EDCD EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2022: EDCE 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2023: EDCF BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2024: EDD0 C2 01 EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2025: EDD3 13                     INC    DE                   ;
2026: EDD4 23                     INC    HL                   ; move on to the MSB                ;
2027: EDD5 1A                     LD     A,(DE)               ;
2028: EDD6 BE                     CP     M                    ; do the check for equality         ;
2029: EDD7 C2 01 EE               JP     NZ,CloseDirEntryError ;  If not then report error         ;
2030: EDDA 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2031: EDDB             MergeMapLoop:                      ;
2032: EDDB 13                     INC    DE                   ; Advance to the next positions     ;
2033: EDDC 23                     INC    HL                   ; in The Maps                       ;
2034: EDDD 0D                     DEC    C                    ; Are we done ?                     ;
2035: EDDE C2 AB ED               JP     NZ,MergeAllocationMaps ;  No, do it again                  ;
2036: EDE1         ;
2037: EDE1         ; Check the EXT                                                             ;
2038: EDE1 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2039: EDE4 09                     ADD    HL,BC                ;
2040: EDE5 EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2041: EDE6 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2042: EDE7 1A                     LD     A,(DE)               ; FCB's extent number               ;
2043: EDE8 BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2044: EDE9 DA F5 ED               JP     C,CloseDirEntryEnd   ;  we are done if yes               ;
2045: EDEC 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2046: EDED         ; Update directory record count field                                       ;
2047: EDED 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2048: EDF0 09                     ADD    HL,BC                ;
2049: EDF1 EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2050: EDF2 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2051: EDF3 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2052: EDF4 12                     LD     (DE),A               ;  the Directory Record RC          ;
2053: EDF5         ;
2054: EDF5             CloseDirEntryEnd:                      ;
2055: EDF5 3E FF                  LD     A,TRUE               ;
2056: EDF7 32 8E F5               LD     (fcbCopiedFlag),A    ;Set copied flag as true            ;
2057: EDFA         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2058: EDFA CD F1 F0               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2059: EDFD C3 9D EF               JP     WriteDir             ; Write the directory element       ;
2060: EE00 C9                     RET                         ;
2061: EE01         ;
2062: EE01             CloseDirEntryError:                      ;
2063: EE01 21 C5 EA               LD     HL,exitParameterByte ;
2064: EE04 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2065: EE05 C9                     RET                         ;
2066: EE06         ;---------------------------- Close Directory Entry ------------------------;
2067: EE06
2068: EE06         ;  +++++ ;
2069: EE06
2070: EE06         ;---------------
2071: EE06         ; set a "1" value in currentDisk position of BC
2072: EE06         ; return in HL
2073: EE06             SetCurrentDiskBit:
2074: EE06 C5                     PUSH   BC                   ; save input parameter
2075: EE07 3A 67 F5               LD     A,(currentDisk)
2076: EE0A 4F                     LD     C,A                  ; ready parameter for shift
2077: EE0B 21 01 00               LD     HL,1                 ; number to shift
2078: EE0E CD 97 F4               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
2079: EE11 C1                     POP    BC                   ; original mask
2080: EE12 79                     LD     A,C
2081: EE13 B5                     OR     L
2082: EE14 6F                     LD     L,A
2083: EE15 78                     LD     A,B
2084: EE16 B4                     OR     H
2085: EE17 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
2086: EE18 C9                     RET
2087: EE19         ;--------------
2088: EE19
2089: EE19         ;--------------------------- Scan      Map ----------------------------------;
2090: EE19         ;-----------------------------------
2091: EE19         ; byte value from ALLOC is in register A, with shift count
2092: EE19         ; in register C (to place bit back into position), and
2093: EE19         ; target ALLOC position in registers HL, rotate and replace
2094: EE19             RotateAndReplace:
2095: EE19 0F                     RRCA
2096: EE1A 15                     DEC    D
2097: EE1B C2 19 EE               JP     NZ,RotateAndReplace  ; back into position
2098: EE1E 77                     LD     (HL),A               ; back to ALLOC
2099: EE1F C9                     RET
2100: EE20         ;-----------------------------------
2101: EE20
2102: EE20         ;*****************************************************************
2103: EE20
2104: EE20         ;*****************************************************************
2105: EE20         ;=========================== Disk Utilities ================================;
2106: EE20         ;--------------------------- Home The Current Disk ------------------------;
2107: EE20         ;move to home position, then offset to start of dir                        ;
2108: EE20             Home:                           ;
2109: EE20 CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks      ;
2110: EE23         ; if Buffer needs to be written    ;
2111: EE23 21 8A F5               LD     HL,dpbOFF            ; Number of tracks before directory;
2112: EE26 4E                     LD     C,(HL)               ;
2113: EE27 23                     INC    HL                   ;
2114: EE28 46                     LD     B,(HL)               ;
2115: EE29 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position  ;
2116: EE2C         ;
2117: EE2C         ; Set Current Track and Sector to 00                                       ;
2118: EE2C AF                     XOR    A                    ; set ACC to 00                    ;
2119: EE2D 2A 71 F5               LD     HL,(caTrack)         ;
2120: EE30 77                     LD     (HL),A               ;
2121: EE31 23                     INC    HL                   ;
2122: EE32 77                     LD     (HL),A               ;
2123: EE33 2A 73 F5               LD     HL,(caSector)        ;
2124: EE36 77                     LD     (HL),A               ;
2125: EE37 23                     INC    HL                   ;
2126: EE38 77                     LD     (HL),A               ;
2127: EE39 C9                     RET                         ;
2128: EE3A         ;
2129: EE3A         ;--------------------------- Home The Current Disk ------------------------;
2130: EE3A         ;--------------------------- Set DMAs -------------------------------------;
2131: EE3A             SetDataDMA:                      ;
2132: EE3A 21 6D F5               LD     HL,initDAMAddress    ;
2133: EE3D 18 03                  JR     SetDMA               ; Skip to complete the call        ;
2134: EE3F         ;	LD		BC,initDAMAddress                                              ;
2135: EE3F         ;	JP		bcSetdma					; Call BIOS to set                 ;
2136: EE3F         ;
2137: EE3F             SetDirDMA:                      ;
2138: EE3F 21 75 F5               LD     HL,caDirectoryDMA    ; Load current directory Buffer    ;
2139: EE42         ;	LD		BC,caDirectoryDMA			; Load current directory Buffer    ;
2140: EE42         ;	JP		bcSetdma					; Call BIOS to set                 ;
2141: EE42         ;
2142: EE42             SetDMA:                         ;
2143: EE42 4E                     LD     C,(HL)               ;
2144: EE43 23                     INC    HL                   ;
2145: EE44 46                     LD     B,(HL)               ; parameter ready              ;
2146: EE45 C3 24 F6               JP     bcSetdma             ; call bios to set             ;
2147: EE48         ;--------------------------- Set DMAs -------------------------------------;
2148: EE48         ;--------------------------- Read Buffer ----------------------------------;
2149: EE48         ;reads into current DMA, using current Disk,Track and Sector               ;
2150: EE48             ReadBuffer:                      ;
2151: EE48 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level    ;
2152: EE4B B7                     OR     A                    ; Check status                     ;
2153: EE4C C2 FB F4               JP     NZ,erPermanentNoWait ; Report if Status not OK          ;
2154: EE4F C9                     RET                         ;
2155: EE50         ;--------------------------- Read Buffer ----------------------------------;
2156: EE50         ;--------------------------- Set Current Disk Read Only --------------------;
2157: EE50         ;set current disk to read only                                              ;
2158: EE50             SetDiskReadOnly:                      ;
2159: EE50 2A 69 F5               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2160: EE53         ;
2161: EE53 3A 67 F5               LD     A,(currentDisk)      ; Get the current disk              ;
2162: EE56 47                     LD     B,A                  ; Move into B                       ;
2163: EE57 CD B8 F4               CALL   SetVectorBit         ; Set the bit	                    ;
2164: EE5A 22 69 F5               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2165: EE5D         ;
2166: EE5D 2A 84 F5               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2167: EE60 EB                     EX     DE,HL                ;
2168: EE61 2A 6F F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2169: EE64 73                     LD     (HL),E               ;
2170: EE65 23                     INC    HL                   ;
2171: EE66 72                     LD     (HL),D               ;
2172: EE67 C9                     RET                         ;
2173: EE68         ;--------------------------- Set disk Read Only ----------------------------;
2174: EE68         ;--------------------------- Is Disk Write Protected -----------------------;
2175: EE68         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2176: EE68         ;					= reset if Write Protected		(NZ)					;
2177: EE68             IsDiskWriteProtected:                      ;
2178: EE68 2A 69 F5               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2179: EE6B 3A 67 F5               LD     A,(currentDisk)      ; Get current disk                  ;
2180: EE6E 47                     LD     B,A                  ;
2181: EE6F CD A8 F4               CALL   IsBitSet             ; Check the bit                     ;
2182: EE72 C9                     RET                         ; NZ if Disk is RO                  ;
2183: EE73         ;?	LD		HL,(readOnlyVector)			; Get Read Only Vector              ;
2184: EE73         ;?	LD		A,(currentDisk)                                                 ;
2185: EE73         ;?	LD		C,A                                                             ;
2186: EE73         ;?	CALL	ShiftRightHLbyC                                                 ;
2187: EE73         ;?	LD		A,L                                                             ;
2188: EE73         ;?	AND		1BH								; 01BH                          ;
2189: EE73         ;?	RET										; non zero if nowrite           ;
2190: EE73         ;--------------------------- Is Disk Write Protected -----------------------;
2191: EE73
2192: EE73         ;------------------------- Reselect Disk if Necessary ----------------------;
2193: EE73         ;check current fcb to see if reselection necessary                         ;
2194: EE73             ReselectDisk:                      ;
2195: EE73 3E FF                  LD     A,TRUE               ;
2196: EE75 32 97 F5               LD     (fResel),A           ; Mark as possible reselect         ;
2197: EE78 2A C3 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2198: EE7B 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2199: EE7C E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2200: EE7E 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2201: EE7F 32 C2 EA               LD     (paramE),A           ; Save drive code                   ;
2202: EE82 FE 1E                  CP     30                   ;
2203: EE84 D2 97 EE               JP     NC,NoSelect          ; Skip drive >= 30                  ;
2204: EE87         ;
2205: EE87 3A 67 F5               LD     A,(currentDisk)      ; Determine the current drive       ;
2206: EE8A 32 98 F5               LD     (entryDisk),A        ; Save it                           ;
2207: EE8D 7E                     LD     A,(HL)               ;
2208: EE8E 32 99 F5               LD     (fcbDisk),A          ; Get calling disk                  ;
2209: EE91 E6 E0                  AND    11100000B            ;
2210: EE93 77                     LD     (HL),A               ; Preserve User Number              ;
2211: EE94 CD 60 EC               CALL   SelectCurrent        ; Select the new disk               ;
2212: EE97         ;
2213: EE97             NoSelect:                       ;
2214: EE97 3A 66 F5               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2215: EE9A 2A C3 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2216: EE9D B6                     OR     M                    ; Combine                           ;
2217: EE9E 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2218: EE9F C9                     RET                         ;
2219: EEA0         ;------------------------- Reselect Disk if Necessary ----------------------;
2220: EEA0
2221: EEA0
2222: EEA0         ;=========================== Disk Utilities ================================;
2223: EEA0
2224: EEA0         ;=========================== File Utilities ================================;
2225: EEA0         ;--------------------------- Set Record Variables -------------------------;
2226: EEA0         ;set variables from currently FCB - Current Record, RC, EXM                ;
2227: EEA0             SetRecordVars:                      ;
2228: EEA0 CD B7 EE               CALL   GetFcbRecordDetails  ; DE = .RecordCount                ;
2229: EEA3         ;  and HL => .CurrentRecord        ;
2230: EEA3 7E                     LD     A,(HL)               ;
2231: EEA4 32 9C F5               LD     (currentFileRecord),A ; Save current record              ;
2232: EEA7 EB                     EX     DE,HL                ;
2233: EEA8 7E                     LD     A,(HL)               ;
2234: EEA9 32 9A F5               LD     (fcbRecordCount),A   ; Save the FCBs RC                 ;
2235: EEAC CD C4 EE               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)             ;
2236: EEAF 3A 81 F5               LD     A,(dpbEXM)           ; Extent mask                      ;
2237: EEB2 A6                     AND    M                    ; Remove unwanted bits             ;
2238: EEB3 32 9B F5               LD     (extentValue),A      ; Store the value                  ;
2239: EEB6 C9                     RET                         ;
2240: EEB7         ;--------------------------- Set Record Variables -------------------------;
2241: EEB7         ;----------------------Get File Record Count and Current Record------------;
2242: EEB7         ; returns with DE pointing at RC from FCB                                  ;
2243: EEB7         ;         with HL pointing at Current Record                               ;
2244: EEB7             GetFcbRecordDetails:                      ;
2245: EEB7 2A C3 EA               LD     HL,(paramDE)         ; Get FCB start                    ;
2246: EEBA 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count           ;
2247: EEBD 19                     ADD    HL,DE                ;
2248: EEBE EB                     EX     DE,HL                ; DE Points to Record Count        ;
2249: EEBF 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;
2250: EEC2 19                     ADD    HL,DE                ; HL Points to Current Record      ;
2251: EEC3 C9                     RET                         ;
2252: EEC4         ;----------------------Get File Record Count and Current Record------------;
2253: EEC4         ;----------------------Get FileExtent--------------------------------------;
2254: EEC4         ;get current extent field address to (HL)                                 ;
2255: EEC4             GetExtentAddress:                      ;
2256: EEC4 2A C3 EA               LD     HL,(paramDE)         ; Get FCB                          ;
2257: EEC7 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                   ;
2258: EECA 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)             ;
2259: EECB C9                     RET                         ;
2260: EECC         ;----------------------Get FileExtent--------------------------------------;
2261: EECC         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2262: EECC         ; At Entry:	BC Contains to the Block to be modified                        ;
2263: EECC         ;			E  = TRUE if bit is to be set                                  ;
2264: EECC         ;			E  <> TRUE if bit is to be reset                               ;
2265: EECC         ; At Exit:  The target bit in the target Octet will be set/reset	       ;
2266: EECC             SetResetMapBit:                      ;
2267: EECC         ;
2268: EECC 21 00 00               LD     HL,0000H             ; Move the block number from BC    ;
2269: EECF 09                     ADD    HL,BC                ;  to HL                           ;
2270: EED0 4B                     LD     C,E                  ; Move the flag to E               ;
2271: EED1         ;
2272: EED1 7D                     LD     A,L                  ; LSB of the Block Number          ;
2273: EED2 E6 07                  AND    07H                  ; Calculate Mod(Block,8)           ;
2274: EED4 F5                     PUSH   AF                   ; Save the OctetBit                ;
2275: EED5 06 03                  LD     B,3                  ;
2276: EED7 CD 9A F0               CALL   ShiftRightHLbyB      ; Calculate Block / 8              ;
2277: EEDA ED 5B 7B F5               LD     DE,(caAllocVector)   ; Start Of Map                     ;
2278: EEDE 19                     ADD    HL,DE                ; Address of targeted Octet        ;
2279: EEDF F1                     POP    AF                   ;
2280: EEE0 47                     LD     B,A                  ; Get the bit                      ;
2281: EEE1         ;
2282: EEE1 04                     INC    B                    ; Adjust for looping               ;
2283: EEE2 C5                     PUSH   BC                   ; Will need this later             ;
2284: EEE3             Left:                           ;
2285: EEE3 CB 16                  RL     (HL)                 ; Rotate the Octet                 ;
2286: EEE5 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0     ;
2287: EEE7 C1                     POP    BC                   ; Restore loop limit and           ;
2288: EEE8 37                     SCF                         ;  set/reset flag                  ;
2289: EEE9 0C                     INC    C                    ; was C = TRUE                     ;
2290: EEEA 28 01                  JR     Z,Right              ; Skip if Set                      ;
2291: EEEC 3F                     CCF                         ; Set for Reset                    ;
2292: EEED             Right:                          ;
2293: EEED CB 1E                  RR     (HL)                 ; Move the Octet back              ;
2294: EEEF 10 FC                  DJNZ   Right                ;  to its original alignment       ;
2295: EEF1 C9                     RET                         ;
2296: EEF2         ;--------------------- Set/Reset Disk Map Allocation Bit ------------------;
2297: EEF2         ;--------------------- Initialize Extent Number MSB -----------------------;
2298: EEF2         ;clear the Extent number field for user open/make (S2)                    ;
2299: EEF2             InitializeExtentNumberMSB:                      ;
2300: EEF2 CD F8 EE               CALL   GetExtentNumberMSB   ;
2301: EEF5 36 00                  LD     (HL),0               ; Set it to = 0            ;
2302: EEF7 C9                     RET                         ;
2303: EEF8         ;--------------------- Initialize Extent Number MSB -----------------------;
2304: EEF8         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2305: EEF8         ; Get S2 value                                                             ;
2306: EEF8         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)           ;
2307: EEF8         ;			HL = Address of S2 for the FCB pointed to by paramDE           ;
2308: EEF8             GetWriteProtectValue:                      ; S2 bit 7                 ;
2309: EEF8             GetExtentNumberMSB:                      ; S2 bits 0-6              ;
2310: EEF8 2A C3 EA               LD     HL,(paramDE)         ; FCB address              ;
2311: EEFB 11 0E 00               LD     DE,fcbS2Index        ; Index to value           ;
2312: EEFE 19                     ADD    HL,DE                ; Address of value         ;
2313: EEFF 7E                     LD     A,(HL)               ; load into ACC            ;
2314: EF00 C9                     RET                         ;
2315: EF01         ;--------------------- Get Extent Number MSB| Write Protect ---------------;
2316: EF01         ;--------------------------- Set File Write Flag----------------------------;
2317: EF01         ;Set file write flag in FCB in (paramDE)									;
2318: EF01         ; Used to indicate the FCB is clean. No need to write on close				;
2319: EF01             SetFileWriteFlag:                      ;
2320: EF01 CD F8 EE               CALL   GetWriteProtectValue ; A= Value, HL = Address of fcbS2   ;
2321: EF04 F6 80                  OR     writeFlagMask        ; Set the flag , bit 7 of S2        ;
2322: EF06 77                     LD     (HL),A               ; Put into FCB                      ;
2323: EF07 C9                     RET                         ;
2324: EF08         ;--------------------------- Set File Write Flag----------------------------;
2325: EF08         ;--------------------------- Reset File Write Flag--------------------------;
2326: EF08         ;Reset file write flag in FCB in (paramDE)									;
2327: EF08         ; Used to indicate the FCB is dirty. Need to write on close					;
2328: EF08             ResetFileWriteFlag:                      ;
2329: EF08 CD F8 EE               CALL   GetWriteProtectValue ; A= Value, HL = Address of fcbS2   ;
2330: EF0B E6 7F                  AND    0FFH-writeFlagMask   ; Remove the flag bit		        ;
2331: EF0D 77                     LD     (HL),A               ; Put into FCB                      ;
2332: EF0E C9                     RET                         ;
2333: EF0F         ;--------------------------- Reset File Write Flag--------------------------;
2334: EF0F         ;-------------------------- Compare FCB Extents ----------------------------;
2335: EF0F         ; Enters:	A containing Target FCB EXT value								;
2336: EF0F         ;			HL Points at Possible FCB EXT value								;
2337: EF0F         ;compare extent# in A with that in C, return nonzero if they do not match	;
2338: EF0F             CompareExtents:                      ;
2339: EF0F C5                     PUSH   BC                   ; Save Callers Registers			;
2340: EF10 F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2341: EF11 3A 81 F5               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2342: EF14 2F                     CPL                         ; Complement for And           		;
2343: EF15 47                     LD     B,A                  ; Put negated Mask into B      		;
2344: EF16 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2345: EF17 A0                     AND    B                    ; Apply the Mask               		;
2346: EF18 4F                     LD     C,A                  ; Low bits removed from C      		;
2347: EF19 F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2348: EF1A A0                     AND    B                    ; Apply the Mask               		;
2349: EF1B 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2350: EF1C E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2351: EF1E C1                     POP    BC                   ; Restore Callers Registers    		;
2352: EF1F C9                     RET                         ;
2353: EF20         ;-------------------------- Compare FCB Extents ----------------------------;
2354: EF20         ;---------------------Search for Directory Record --------------------------;
2355: EF20         ;        directoryFlag  ????????											;
2356: EF20         ;  Search for directory record of length C.									;
2357: EF20         ; Target is pointed to by paramDE. The whole directory is searched.			;
2358: EF20         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2359: EF20         ; matched directory record													;
2360: EF20         ; Entry:	C = Search Length                                               ;
2361: EF20         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2362: EF20         ;								-1 (EOD) if there is no match				;
2363: EF20             SearchForDirectoryRecord:                      ;
2364: EF20 3E FF                  LD     A,0FFH               ;
2365: EF22 32 90 F5               LD     (directoryFlag),A    ; Initialize directory Flag         ;
2366: EF25 21 93 F5               LD     HL,searchLength      ;
2367: EF28 71                     LD     (HL),C               ; Save Search Length                ;
2368: EF29 2A C3 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2369: EF2C 22 94 F5               LD     (searchAddress),HL   ; Start of search                   ;
2370: EF2F CD B5 EF               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2371: EF32 CD 20 EE               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2372: EF35         ;
2373: EF35             GetNextDirectoryRecord:                      ;
2374: EF35 0E 00                  LD     C,FALSE              ;
2375: EF37 CD C3 F0               CALL   ReadDirectory        ; Read next Dir Record              ;
2376: EF3A CD BC EF               CALL   AtEndOfDirectory     ;
2377: EF3D CA 94 EF               JP     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2378: EF40         ;
2379: EF40 2A 94 F5               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2380: EF43 EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2381: EF44 1A                     LD     A,(DE)               ; User Number                       ;
2382: EF45 FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2383: EF47 CA 52 EF               JP     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2384: EF4A         ;
2385: EF4A         ; Check to be sure we are sill in the Directory                             ;
2386: EF4A D5                     PUSH   DE                   ; Save search address               ;
2387: EF4B CD DC EF               CALL   StillInDirectory     ; Still in the directorY            ;
2388: EF4E D1                     POP    DE                   ; Recall address                    ;
2389: EF4F D2 94 EF               JP     NC,NoDirRecordsMatch ; Get out if past directory			;
2390: EF52         ;
2391: EF52             GetNextDirectoryRecord1:                      ;
2392: EF52 CD C5 EF               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2393: EF55 3A 93 F5               LD     A,(searchLength)     ;
2394: EF58 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2395: EF59 06 00                  LD     B,0                  ; Character Index (up)              ;
2396: EF5B         ;
2397: EF5B             TestNextPosition:                      ;
2398: EF5B 1A                     LD     A,(DE)               ;
2399: EF5C FE 3F                  CP     QMARK                ; ? is always a char match          ;
2400: EF5E CA 7C EF               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2401: EF61         ;
2402: EF61 78                     LD     A,B                  ;
2403: EF62 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2404: EF64 CA 7C EF               JP     Z,SetNextPosition    ; Done with this if it is ?		;
2405: EF67         ; not the fcbS1Index field, extent field?                                  ;
2406: EF67 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2407: EF69 1A                     LD     A,(DE)               ; Get next character                ;
2408: EF6A CA 76 EF               JP     Z,CheckExtents       ; Skip to search extent             ;
2409: EF6D 96                     SUB    M                    ; Do they match ?                   ;
2410: EF6E E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2411: EF70 C2 35 EF               JP     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2412: EF73 C3 7C EF               JP     SetNextPosition      ; Matched the character             ;
2413: EF76         ;                                                                           ;
2414: EF76             CheckExtents:                      ;
2415: EF76 CD 0F EF               CALL   CompareExtents       ; Matching EXTs is work             ;
2416: EF79 C2 35 EF               JP     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2417: EF7C         ;
2418: EF7C             SetNextPosition:                      ;
2419: EF7C 13                     INC    DE                   ; Pointer to Looking FOR            ;
2420: EF7D 23                     INC    HL                   ; Pointer to Looking IN             ;
2421: EF7E 04                     INC    B                    ; Character Index in FCB            ;
2422: EF7F 0D                     DEC    C                    ; Length of search                  ;
2423: EF80 C2 5B EF               JP     NZ,TestNextPosition  ;
2424: EF83         ; Match Found, entire name matches                                          ;
2425: EF83 3A A1 F5               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2426: EF86 E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2427: EF88 32 C5 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2428: EF8B         ;
2429: EF8B 21 90 F5               LD     HL,directoryFlag     ; Point at Directory Flag           ;
2430: EF8E 7E                     LD     A,(HL)               ; Get value                         ;
2431: EF8F 17                     RLA                         ; Set Carry if Flag = -1            ;
2432: EF90 D0                     RET    NC                   ; Return with flag still -1         ;
2433: EF91         ;
2434: EF91 AF                     XOR    A                    ; Else Clear the flag               ;
2435: EF92 77                     LD     (HL),A               ;
2436: EF93 C9                     RET                         ;  and exit                         ;
2437: EF94         ;------                                                                     ;
2438: EF94             NoDirRecordsMatch:                      ;
2439: EF94 CD B5 EF               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2440: EF97 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2441: EF99 32 C5 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2442: EF9C C9                     RET                         ;
2443: EF9D         ;---------------------Search for Directory Record --------------------------;
2444: EF9D         ;---------------------------- Write Current Directory Entry ----------------;
2445: EF9D             WriteDir:                       ;
2446: EF9D         ;	CALL	NewCheckSum						; initialize entry              ;
2447: EF9D 0E FF                  LD     C,TRUE               ;
2448: EF9F CD 3C F1               CALL   CheckSumUtility      ; Set New CheckSum              ;
2449: EFA2         ;
2450: EFA2 CD 3F EE               CALL   SetDirDMA            ; Directory DMA                 ;
2451: EFA5 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
2452: EFA7 CD AD EF               CALL   WriteBuffer          ; Write the buffer              ;
2453: EFAA C3 3A EE               JP     SetDataDMA           ; Reset DMA to default			;
2454: EFAD         ;
2455: EFAD         ;---------------------------- Write Current Directory Entry ----------------;
2456: EFAD         ;----------------------------------- Write Buffer --------------------------;
2457: EFAD         ; Write buffer and check condition. Current drive,Track, Sector and DMA     ;
2458: EFAD         ; Are set up prior to calling this routine                                  ;
2459: EFAD         ;                                                                           ;
2460: EFAD         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
2461: EFAD         ;				1 => directory write operation	WriteDirectory              ;
2462: EFAD         ;				2 => start of new block			WriteCleanBuffer			;
2463: EFAD             WriteBuffer:                      ;
2464: EFAD CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
2465: EFB0 B7                     OR     A                    ; Get return code                   ;
2466: EFB1 C2 FB F4               JP     NZ,erPermanentNoWait ; Error if not 00                   ;
2467: EFB4 C9                     RET                         ;
2468: EFB5         ;----------------------------------- Write Buffer --------------------------;
2469: EFB5
2470: EFB5         ;=========================== File Utilities ================================;
2471: EFB5
2472: EFB5         ;=========================== Directory Utilities ===========================;
2473: EFB5         ;--------------------------- Set End of Directory indicator ----------------;
2474: EFB5             SetEndDirectory:                      ;
2475: EFB5 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
2476: EFB8 22 A1 F5               LD     (dirEntryIndex),HL   ;
2477: EFBB C9                     RET                         ;
2478: EFBC         ;--------------------------- Set End of Directory indicator ----------------;
2479: EFBC         ;--------------------------- Are we at End Of Directory --------------------;
2480: EFBC         ; Tests to see if we are at the End Of the Directory                        ;
2481: EFBC         ;                                                                           ;
2482: EFBC         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
2483: EFBC         ;			 Z Flag reset if still in directory                             ;
2484: EFBC         ;
2485: EFBC             AtEndOfDirectory:                      ;
2486: EFBC 21 A1 F5               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
2487: EFBF 7E                     LD     A,(HL)               ; Get it                            ;
2488: EFC0 23                     INC    HL                   ; Point at MSB	of Dir Index		;
2489: EFC1 BE                     CP     M                    ; LSB = MSB ?                       ;
2490: EFC2 C0                     RET    NZ                   ;  exit if not if different         ;
2491: EFC3         ; Same.  are they = 0ffh?           ;
2492: EFC3 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
2493: EFC4 C9                     RET                         ;
2494: EFC5         ;--------------------------- Are we at End Of Directory --------------------;
2495: EFC5         ;--------------------------- Get Directory Element -------------------------;
2496: EFC5         ; compute the address of a directory element in Directory Buffer            ;
2497: EFC5         ; Returns:  HL = Address of the specific directory Record                   ;
2498: EFC5             GetCurrentDirectoryRecord:                      ;
2499: EFC5 C5                     PUSH   BC                   ; Save BC                           ;
2500: EFC6 2A 75 F5               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
2501: EFC9 3A A0 F5               LD     A,(dirBlockIndex)    ; Get the index value               ;
2502: EFCC 4F                     LD     C,A                  ;
2503: EFCD AF                     XOR    A                    ; Set to Zero and reset CY          ;
2504: EFCE 47                     LD     B,A                  ;
2505: EFCF ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
2506: EFD1 C1                     POP    BC                   ; Restore	                        ;
2507: EFD2 C9                     RET                         ;
2508: EFD3         ;--------------------------- Get Directory Element -------------------------;
2509: EFD3         ;--------------------------- Set Directory Entry ---------------------------;
2510: EFD3         ; Will update directory if not in the directory                             ;
2511: EFD3         ;
2512: EFD3             SetDirectoryEntry:                      ;
2513: EFD3 CD DC EF               CALL   StillInDirectory     ;
2514: EFD6 D8                     RET    C                    ; Exit if still in the Directory  	;
2515: EFD7         ;
2516: EFD7         ; StillInDirectory will return with:                                        ;
2517: EFD7         ;									DE = Directory entry number             ;
2518: EFD7         ;									HL = Address of entry number + 1        ;
2519: EFD7 13                     INC    DE                   ;
2520: EFD8 72                     LD     (HL),D               ;
2521: EFD9 2B                     DEC    HL                   ;
2522: EFDA 73                     LD     (HL),E               ;
2523: EFDB C9                     RET                         ;
2524: EFDC         ;--------------------------- Set Directory Entry ---------------------------;
2525: EFDC
2526: EFDC         ;--------------------------- Are we sill in the Directory ------------------;
2527: EFDC         ;Returns	:                                                               ;
2528: EFDC         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
2529: EFDC         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
2530: EFDC         ;			HL = (address of Index Value) + 1                               ;
2531: EFDC         ;			DE = Directory Index Value                                      ;
2532: EFDC             StillInDirectory:                      ;
2533: EFDC 2A A1 F5               LD     HL,(dirEntryIndex)   ;
2534: EFDF EB                     EX     DE,HL                ; DE = directory counter            ;
2535: EFE0 2A 6F F5               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
2536: EFE3 7B                     LD     A,E                  ;
2537: EFE4 96                     SUB    M                    ;
2538: EFE5 23                     INC    HL                   ;
2539: EFE6 7A                     LD     A,D                  ;
2540: EFE7 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
2541: EFE8 C9                     RET                         ;  <= Directory Max Value       ;
2542: EFE9         ;--------------------------- Are we sill in the Directory ------------------;
2543: EFE9         ;--------------------------- Scan Disk Map ---------------------------------;
2544: EFE9         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
2545: EFE9         ;                                                                           ;
2546: EFE9         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
2547: EFE9         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
2548: EFE9         ;
2549: EFE9             ScanDiskMap:                      ;
2550: EFE9 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
2551: EFEA CD C5 EF               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
2552: EFED 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
2553: EFF0 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
2554: EFF1 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
2555: EFF3         ;
2556: EFF3             ScanDiskMap0:                      ;
2557: EFF3 D1                     POP    DE                   ; Recall the set/reset Info         ;
2558: EFF4 0D                     DEC    C                    ;
2559: EFF5 C8                     RET    Z                    ; Loop once for each disk map entry ;
2560: EFF6         ;
2561: EFF6 D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
2562: EFF7 3A 96 F5               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
2563: EFFA B7                     OR     A                    ;
2564: EFFB 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
2565: EFFD         ;  Byte Allocation scan operation                                           ;
2566: EFFD C5                     PUSH   BC                   ; Save counter                      ;
2567: EFFE E5                     PUSH   HL                   ; Save map address                  ;
2568: EFFF 4E                     LD     C,(HL)               ;
2569: F000 06 00                  LD     B,0                  ; BC=block# for Byte                ;
2570: F002 18 06                  JR     ScanDiskMap2         ;
2571: F004         ; Word scan operation                                                       ;
2572: F004             ScanDiskMapWord:                      ;
2573: F004 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
2574: F005 C5                     PUSH   BC                   ; Save counter                      ;
2575: F006 46                     LD     B,(HL)               ;
2576: F007 23                     INC    HL                   ;
2577: F008 4E                     LD     C,(HL)               ; BC=block# for Word                ;
2578: F009 E5                     PUSH   HL                   ; Save map address                  ;
2579: F00A         ;
2580: F00A         ; Arrive here with BC=block#, E=0/1	                                        ;
2581: F00A             ScanDiskMap2:                      ;
2582: F00A 79                     LD     A,C                  ;
2583: F00B B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
2584: F00C C4 CC EE               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
2585: F00F E1                     POP    HL                   ;
2586: F010 23                     INC    HL                   ; to next bit position              ;
2587: F011 C1                     POP    BC                   ; recall counter                    ;
2588: F012 C3 F3 EF               JP     ScanDiskMap0         ; for another item                  ;
2589: F015         ;
2590: F015         ;--------------------------- Scan Disk Map ---------------------------------;
2591: F015         ;--------------------------- Get Closest Disk Block ------------------------;
2592: F015         ; Find the closest available disk block, and mark in Map as allocated       ;
2593: F015         ; Enter	BC	= Block number to base the search on                            ;
2594: F015         ; Exit	HL	= 0000 if There are no available open blocks                    ;
2595: F015         ;			= block number of available and marked block                    ;
2596: F015         ;
2597: F015             GetClosestBlock:                      ;
2598: F015 C5                     PUSH   BC                   ; save the starting Block #         ;
2599: F016         ;
2600: F016 2A 82 F5               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
2601: F019 CD 98 F0               CALL   DivideHLby8          ; Length of Map	                    ;
2602: F01C EB                     EX     DE,HL                ; put size into DE			        ;
2603: F01D E1                     POP    HL                   ; Block number into HL              ;
2604: F01E CD 98 F0               CALL   DivideHLby8          ; Length of Map                     ;
2605: F021 EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
2606: F022 AF                     XOR    A                    ; Reset CY                          ;
2607: F023 ED 52                  SBC    HL,DE                ; Size for right                    ;
2608: F025         ; DE = Start Index                                                          ;
2609: F025         ; DE = Left Size                                                            ;
2610: F025         ; HL	= Right Size                                                        ;
2611: F025 E5                     PUSH   HL                   ; Save right size                   ;
2612: F026 D5                     PUSH   DE                   ; Save left size & Start Index      ;
2613: F027 3E FF                  LD     A,0FFH               ; Full Octet                        ;
2614: F029         ;
2615: F029 2A 7B F5               LD     HL,(caAllocVector)   ; Start of Map                      ;
2616: F02C 19                     ADD    HL,DE                ; Determine initial Octet			;
2617: F02D         ; Set up Left side                                                          ;
2618: F02D C1                     POP    BC                   ; Left size                         ;
2619: F02E 03                     INC    BC                   ; adjust                            ;
2620: F02F E5                     PUSH   HL                   ; Save initial Octet                ;
2621: F030 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
2622: F033         ; HL = Initial Octet                                                        ;
2623: F033         ; BC = Left Size                                                            ;
2624: F033 D9                     EXX                         ; Use alternate registers           ;
2625: F034 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
2626: F037 E1                     POP    HL                   ; Get Initial Octet                 ;
2627: F038 C1                     POP    BC                   ; Get Right Size                    ;
2628: F039 03                     INC    BC                   ; adjust                            ;
2629: F03A             LookRight:                      ;
2630: F03A ED A1                  CPI                         ; UnSet Bit?                        ;
2631: F03C 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2632: F03E E2 57 F0               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
2633: F041         ;
2634: F041 D9                     EXX                         ; Switch to the Left                ;
2635: F042 ED A9                  CPD                         ; UnSet Bit?                        ;
2636: F044 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2637: F046 E2 4C F0               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
2638: F049 D9                     EXX                         ; switch to right                   ;
2639: F04A 18 EE                  JR     LookRight            ; Keep on looking                   ;
2640: F04C         ;			----------------			                                    ;
2641: F04C             NoMoreLeft:                      ;
2642: F04C D9                     EXX                         ; Switch to Right                   ;
2643: F04D             NoMoreLeftLoop:                      ;
2644: F04D ED A1                  CPI                         ;
2645: F04F 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2646: F051 E2 62 F0               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
2647: F054 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
2648: F056 76                     HALT                        ;
2649: F057             NoMoreRight:                      ;
2650: F057 D9                     EXX                         ; Switch to Left                    ;
2651: F058             NoMoreRightLoop:                      ;
2652: F058 ED A9                  CPD                         ;
2653: F05A 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
2654: F05C E2 62 F0               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
2655: F05F 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
2656: F061 76                     HALT                        ;
2657: F062             NoFreeBlocks:                      ;
2658: F062 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
2659: F065 C9                     RET                         ;
2660: F066         ;			----------------			                                    ;
2661: F066             FoundFreeOctet:                      ;
2662: F066 BB                     CP     E                    ; Left or Right                     ;
2663: F067 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
2664: F069 2B                     DEC    HL                   ; Adjust for direction              ;
2665: F06A 18 01                  JR     FoundFreeOctet2      ;
2666: F06C         ;
2667: F06C             FoundFreeOctet1:                      ;
2668: F06C 23                     INC    HL                   ; Adjust for direction              ;
2669: F06D             FoundFreeOctet2:                      ;
2670: F06D 01 00 00               LD     BC,00                ; need to keep track of bit         ;
2671: F070             FoundFreeOctet3:                      ;
2672: F070 CB 06                  RLC    (HL)                 ;
2673: F072 03                     INC    BC                   ;
2674: F073 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
2675: F075 CB C6                  SET    0,(HL)               ; Make map bit set                  ;
2676: F077 41                     LD     B,C                  ; Put count in B                    ;
2677: F078             FoundFreeOctet4:                      ;
2678: F078 CB 0E                  RRC    (HL)                 ;
2679: F07A 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
2680: F07C 0B                     DEC    BC                   ; adjust for Zero based value       ;
2681: F07D C5                     PUSH   BC                   ; Save the bit index                ;
2682: F07E ED 4B 7B F5               LD     BC,(caAllocVector)   ; Get Map start                     ;
2683: F082 AF                     XOR    A                    ; Clear CY                          ;
2684: F083 ED 42                  SBC    HL,BC                ; Get how far in the map            ;
2685: F085 CD A2 F0               CALL   MultiplyHLby8        ; Calculate the Octet           ;
2686: F088 C1                     POP    BC                   ; Restore index into Octet          ;
2687: F089 09                     ADD    HL,BC                ; This is the Block Number          ;
2688: F08A C9                     RET                         ;
2689: F08B         ;--------------------------- Get Closest Disk Block ------------------------;
2690: F08B
2691: F08B         ;=========================== Directory Utilities ===========================;
2692: F08B
2693: F08B         ; GU
2694: F08B
2695: F08B         ;=========================== General   Utilities ===========================;
2696: F08B         ;--------------------------- Rotate HL right by value in C ----------------;
2697: F08B         ;
2698: F08B         ; HL = Value to be rotated Right                                           ;
2699: F08B         ;  B = Amount to shift                                                     ;
2700: F08B             RotateRightHLbyB:                      ;
2701: F08B 37                     SCF                         ; Set carry flag, expect LSBit = 1 ;
2702: F08C CB 45                  BIT    0,L                  ; is LSB set?                      ;
2703: F08E 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set              ;
2704: F090 3F                     CCF                         ; else Clear Carry flag            ;
2705: F091             RotateRightHLbyB1:                      ;
2706: F091 CB 1C                  RR     H                    ; Shift thru CY                    ;
2707: F093 CB 1D                  RR     L                    ; ditto                            ;
2708: F095 10 F4                  DJNZ   RotateRightHLbyB     ;
2709: F097 C9                     RET                         ;
2710: F098         ;
2711: F098         ;--------------------------- Rotate HL right by value in C ----------------;
2712: F098         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2713: F098         ; HL = Value to be shifted Right                                           ;
2714: F098             DivideHLby8:                      ;
2715: F098 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2716: F09A         ;  B = Amount to shift                                                     ;
2717: F09A             ShiftRightHLbyB:                      ;
2718: F09A AF                     XOR    A                    ; else Clear Carry flag            ;
2719: F09B CB 1C                  RR     H                    ; Shift thru CY                    ;
2720: F09D CB 1D                  RR     L                    ; ditto                            ;
2721: F09F 10 F9                  DJNZ   ShiftRightHLbyB      ;
2722: F0A1 C9                     RET                         ;
2723: F0A2         ;---------Divide HL by 8  &&  Shift HL right by value in C ----------------;
2724: F0A2         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2725: F0A2         ; HL = Value to be shifted Left                                            ;
2726: F0A2             MultiplyHLby8:                      ;
2727: F0A2 06 03                  LD     B,3                  ; 8 = 2**3						   ;
2728: F0A4         ;  B = Amount to shift                                                     ;
2729: F0A4             ShiftLeftHLbyB:                      ;
2730: F0A4 AF                     XOR    A                    ; else Clear Carry flag            ;
2731: F0A5 CB 15                  RL     L                    ; Shift thru CY                    ;
2732: F0A7 CB 14                  RL     H                    ; ditto                            ;
2733: F0A9 10 F9                  DJNZ   ShiftLeftHLbyB       ;
2734: F0AB C9                     RET                         ;
2735: F0AC         ;---------Multiply HL by 8  &&  Shift HL left by value in C ---------------;
2736: F0AC         ;----------------------------- Merge ---------------------------------------;
2737: F0AC         ; Merge Map Block Numbers between FCB and directory record                  ;
2738: F0AC         ; HL has pointer to map for either dir record or FCB,                       ;
2739: F0AC         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
2740: F0AC         ; it just returns, Else it copies the block number to where DE is pointing  ;
2741: F0AC         ;
2742: F0AC             Merge:                          ;
2743: F0AC 7E                     LD     A,(HL)               ; Get the first byte                ;
2744: F0AD 23                     INC    HL                   ;
2745: F0AE B6                     OR     M                    ; OR it with the second byte        ;
2746: F0AF 2B                     DEC    HL                   ; Restore HL to start               ;
2747: F0B0 C0                     RET    NZ                   ; Exit if both are 0s               ;
2748: F0B1         ; HL points to a non Zero value	                                            ;
2749: F0B1 1A                     LD     A,(DE)               ; Get the first byte                ;
2750: F0B2 77                     LD     (HL),A               ; Move it                           ;
2751: F0B3 13                     INC    DE                   ;
2752: F0B4 23                     INC    HL                   ; Increment both pointers           ;
2753: F0B5 1A                     LD     A,(DE)               ; Get the second byte               ;
2754: F0B6 77                     LD     (HL),A               ; Move it                           ;
2755: F0B7 1B                     DEC    DE                   ;
2756: F0B8 2B                     DEC    HL                   ; Restore HL & DE to start          ;
2757: F0B9 C9                     RET                         ;
2758: F0BA         ;----------------------------- Merge ---------------------------------------;
2759: F0BA
2760: F0BA
2761: F0BA         ;=========================== General   Utilities ===========================;
2762: F0BA
2763: F0BA         ;--------------------------- Read Directory Record -------------------------;
2764: F0BA         ; read a directory entry into the directory buffer                          ;
2765: F0BA             ReadDirRecord:                      ;
2766: F0BA CD 3F EE               CALL   SetDirDMA            ; System Assigned Buffer            ;
2767: F0BD CD 48 EE               CALL   ReadBuffer           ; Go to BIOS for the read           ;
2768: F0C0 C3 3A EE               JP     SetDataDMA           ; Restore DMA                       ;
2769: F0C3         ;--------------------------- Read Directory Record -------------------------;
2770: F0C3
2771: F0C3         ;--------------------------- Read Directory --------------------------------;
2772: F0C3         ; Read next directory entry                                                 ;
2773: F0C3         ; Enter :                                                                   ;
2774: F0C3         ;		C =  TRUE initializing and setting CheckSum                         ;
2775: F0C3         ;		  <> TRUE Checking existing CheckSum                                ;
2776: F0C3             ReadDirectory:                      ;
2777: F0C3 ED 5B 84 F5               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
2778: F0C7 2A A1 F5               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
2779: F0CA 23                     INC    HL                   ; Increment the Index               ;
2780: F0CB 22 A1 F5               LD     (dirEntryIndex),HL   ; Save current directory index      ;
2781: F0CE AF                     XOR    A                    ; Clear the CY flag                 ;
2782: F0CF ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
2783: F0D1 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
2784: F0D3 CD B5 EF               CALL   SetEndDirectory      ;  else we are done                 ;
2785: F0D6 C9                     RET                         ;
2786: F0D7         ;
2787: F0D7         ; Calculate the entry index Position in Buffer                              ;
2788: F0D7             ReadDirectory0:                      ;
2789: F0D7 3A A1 F5               LD     A,(dirEntryIndex)    ; Get the index                     ;
2790: F0DA E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
2791: F0DC 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
2792: F0DE             ReadDirectory1:                      ;
2793: F0DE 87                     ADD    A,A                  ;
2794: F0DF 10 FD                  DJNZ   ReadDirectory1       ;
2795: F0E1 32 A0 F5               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
2796: F0E4 B7                     OR     A                    ; Is this the 1st entry?            ;
2797: F0E5 C0                     RET    NZ                   ;  return if not.                   ;
2798: F0E6         ;
2799: F0E6 C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
2800: F0E7 CD F1 F0               CALL   SeekDir              ; Set up for Directory Read         ;
2801: F0EA CD BA F0               CALL   ReadDirRecord        ; Read the directory record         ;
2802: F0ED C1                     POP    BC                   ; Recall initialization flag        ;
2803: F0EE C3 3C F1               JP     CheckSumUtility      ; Checksum the directory            ;
2804: F0F1         ;--------------------------- Read Directory --------------------------------;
2805: F0F1         ;--------------------------- Seek Directory --------------------------------;
2806: F0F1         ;seek the record containing the current directory entry					;
2807: F0F1             SeekDir:                        ;
2808: F0F1 2A A1 F5               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
2809: F0F4 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
2810: F0F6 CD 9A F0               CALL   ShiftRightHLbyB      ;
2811: F0F9 22 9E F5               LD     (absoluteCPMRecord),HL ;
2812: F0FC 22 A3 F5               LD     (dirRecord),HL       ; Save                              ;
2813: F0FF C3 02 F1               JP     Seek                 ;
2814: F102         ;--------------------------- Seek Directory --------------------------------;
2815: F102         ;--------------------------- Seek ------------------------------------------;
2816: F102             Seek:                           ;
2817: F102 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
2818: F105 2A 9E F5               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
2819: F108 ED 5B 7D F5               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
2820: F10C         ;
2821: F10C             Seek0:                          ;
2822: F10C 03                     INC    BC                   ; Divide the record                 ;
2823: F10D AF                     XOR    A                    ;  by the sectors per track         ;
2824: F10E ED 52                  SBC    HL,DE                ;
2825: F110 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
2826: F112         ;
2827: F112         ;
2828: F112 19                     ADD    HL,DE                ; Gets the sector in the track      ;
2829: F113 E5                     PUSH   HL                   ; Save Index Sector                 ;
2830: F114         ;
2831: F114 DD 2A 71 F5               LD     IX,(caTrack)         ;
2832: F118 DD 71 00               LD     (IX+0),C             ;
2833: F11B DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
2834: F11E         ;
2835: F11E EB                     EX     DE,HL                ; Take the index from the record    ;
2836: F11F 2A 9E F5               LD     HL,(absoluteCPMRecord) ;
2837: F122 AF                     XOR    A                    ;
2838: F123 ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
2839: F125         ;
2840: F125 DD 2A 73 F5               LD     IX,(caSector)        ;
2841: F129 DD 75 00               LD     (IX+0),L             ;
2842: F12C DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
2843: F12F         ;
2844: F12F 2A 8A F5               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
2845: F132 09                     ADD    HL,BC                ;  to add to the gross Track        ;
2846: F133 E5                     PUSH   HL                   ;  which yields the net or          ;
2847: F134 C1                     POP    BC                   ;  actual track for the record      ;
2848: F135 CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
2849: F138         ;
2850: F138 C1                     POP    BC                   ; Get the sector within the track   ;
2851: F139 C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
2852: F13C         ;
2853: F13C         ;--------------------------- Seek ------------------------------------------;
2854: F13C         ;--------------------------- Check Sum Utility -----------------------------;
2855: F13C         ; At entry                                                                  ;
2856: F13C         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
2857: F13C         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
2858: F13C         ;
2859: F13C             CheckSumUtility:                      ;
2860: F13C 2A 88 F5               LD     HL,(dpbCKS)          ;
2861: F13F ED 5B A3 F5               LD     DE,(dirRecord)       ;
2862: F143 AF                     XOR    A                    ;
2863: F144 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
2864: F146 D8                     RET    C                    ;  Entries                      ;
2865: F147         ;
2866: F147 C5                     PUSH   BC                   ; Save New/Validate Flag        ;
2867: F148         ;
2868: F148         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
2869: F148             ComputeCheckSum:                      ;
2870: F148 06 80                  LD     B,cpmRecordSize      ;
2871: F14A 2A 75 F5               LD     HL,(caDirectoryDMA)  ;
2872: F14D EE 00                  XOR                         ;
2873: F14F             ComputeCheckSum1:                      ;
2874: F14F 86                     ADD    A,(HL)               ;
2875: F150 23                     INC    HL                   ;
2876: F151 10 FC                  DJNZ   ComputeCheckSum1     ;
2877: F153         ; Checksum is in ACC	                                                    ;
2878: F153         ;
2879: F153 2A 79 F5               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
2880: F156 ED 5B A3 F5               LD     DE,(dirRecord)       ; Index to this record              ;
2881: F15A 19                     ADD    HL,DE                ; Address of this record in vector  ;
2882: F15B C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
2883: F15C 0C                     INC    C                    ;
2884: F15D CA 6A F1               JP     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
2885: F160         ;
2886: F160 BE                     CP     M                    ; Else we are checking the value    ;
2887: F161 C8                     RET    Z                    ; Exit if OK                        ;
2888: F162         ; possible checksum error, are we beyond the end of the disk?               ;
2889: F162 CD DC EF               CALL   StillInDirectory     ;
2890: F165 D0                     RET    NC                   ; OK, if not in the directory       ;
2891: F166 CD 50 EE               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
2892: F169 C9                     RET                         ;  Set disk RO before returning     ;
2893: F16A         ;
2894: F16A         ;initializing the checksum                                                 ;
2895: F16A             SetNewCheckSum:                      ;
2896: F16A 77                     LD     (HL),A               ;
2897: F16B C9                     RET                         ;
2898: F16C         ;--------------------------- Check Sum Utility -----------------------------;
2899: F16C
2900: F16C
2901: F16C         ;---------------------
2902: F16C         ;update variables from I/O in  fcb
2903: F16C             UpdateRecordVars:
2904: F16C CD B7 EE               CALL   GetFcbRecordDetails  ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
2905: F16F 3A 91 F5               LD     A,(seqReadFlag)
2906: F172 4F                     LD     C,A                  ; =1 if sequential i/o
2907: F173 3A 9C F5               LD     A,(currentFileRecord) ; get NEXT_RECORD
2908: F176 81                     ADD    A,C
2909: F177 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=current File Record+seqReadFlag
2910: F178 EB                     EX     DE,HL
2911: F179 3A 9A F5               LD     A,(fcbRecordCount)
2912: F17C 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
2913: F17D C9                     RET
2914: F17E         ;---------------------
2915: F17E         ;set file Attributes for current fcb
2916: F17E             SetAttributes:
2917: F17E 0E 0C                  LD     C,fcbExtIndex
2918: F180 CD 20 EF               CALL   SearchForDirectoryRecord ; through file type
2919: F183             SetAttributes1:
2920: F183 CD BC EF               CALL   AtEndOfDirectory
2921: F186 C8                     RET    Z                    ; exit at end of dir
2922: F187 0E 00                  LD     C,0
2923: F189 1E 0C                  LD     E,fcbExtIndex        ;copy name
2924: F18B CD 30 F4               CALL   CopyDir
2925: F18E CD 35 EF               CALL   GetNextDirectoryRecord
2926: F191 C3 83 F1               JP     SetAttributes1
2927: F194         ;
2928: F194         ;*****************************************************************
2929: F194
2930: F194         ;*****************************************************************
2931: F194         ;********************** File  Routines ***************************
2932: F194         ;*****************************************************************
2933: F194         ;-----------------------------------------------------------------
2934: F194         ;search for first occurrence of a file
2935: F194         ; In - (DE)	FCB Address
2936: F194         ; OUT - (A)	Directory Code
2937: F194         ;	0-3 = success ; 0FFH = File Not Found
2938: F194             vFindFirst:                      ; func17: (17 - 11) Search for first
2939: F194 0E 00                  LD     C,0                  ; length assuming '?' true
2940: F196 2A C3 EA               LD     HL,(paramDE)
2941: F199 7E                     LD     A,(HL)
2942: F19A FE 3F                  CP     QMARK                ; no reselect if ?
2943: F19C CA A7 F1               JP     Z,QMarkSelect        ; skip reselect if so
2944: F19F
2945: F19F CD F2 EE               CALL   InitializeExtentNumberMSB ; module number zeroed
2946: F1A2 CD 73 EE               CALL   ReselectDisk
2947: F1A5 0E 0F                  LD     C,nameLength
2948: F1A7             QMarkSelect:                      ; qselect:
2949: F1A7 CD 20 EF               CALL   SearchForDirectoryRecord
2950: F1AA C3 1D F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2951: F1AD         ;-----------------------------------------------------------------
2952: F1AD         ;search for next occurrence of a file name
2953: F1AD         ; OUT - (A)	Directory Code
2954: F1AD         ;	0-3 = success ; 0FFH = File Not Found
2955: F1AD             vFindNext:                      ; func18: (18 - 12) Search for next
2956: F1AD 2A 94 F5               LD     HL,(searchAddress)
2957: F1B0 22 C3 EA               LD     (paramDE),HL
2958: F1B3 CD 73 EE               CALL   ReselectDisk
2959: F1B6 CD 35 EF               CALL   GetNextDirectoryRecord
2960: F1B9 C3 1D F4               JP     CopyDirEntryToUser   ; copy directory entry to user
2961: F1BC         ;-----------------------------------------------------------------
2962: F1BC         ;search for next occurrence of a file name
2963: F1BC         ; OUT - (A)	Directory Code
2964: F1BC         ;delete a file
2965: F1BC             vDeleteFile:                      ; func18: (19 - 13) Delete File
2966: F1BC CD 73 EE               CALL   ReselectDisk
2967: F1BF CD C2 F3               CALL   DeleteFile
2968: F1C2 C3 10 F4               JP     DirLocationToReturnLoc
2969: F1C5         ;-----------------------------------------------------------------
2970: F1C5         ;read sequential
2971: F1C5         ;IN  - (DE) FCB address
2972: F1C5         ;OUT - (A) 00 = success and data available. else no read and no data
2973: F1C5             vReadSeq:                       ; func20: (20 - 14) read sequential
2974: F1C5 CD 73 EE               CALL   ReselectDisk
2975: F1C8 CD F9 F1               CALL   ReadSeq
2976: F1CB C9                     RET
2977: F1CC         ;-----------------------------------------------------------------
2978: F1CC         ;write sequential
2979: F1CC         ;IN  - (DE) FCB address
2980: F1CC         ;OUT - (A) 00 = success and data available. else no read and no data
2981: F1CC             vWriteSeq:                      ; func21 (21 - 15) write sequention
2982: F1CC CD 73 EE               CALL   ReselectDisk
2983: F1CF CD 3C F2               CALL   DiskWriteSeq
2984: F1D2 C9                     RET
2985: F1D3         ;-----------------------------------------------------------------
2986: F1D3         ; Make file
2987: F1D3         ; In - (DE)	FCB Address
2988: F1D3         ; OUT - (A)	Directory Code
2989: F1D3         ;	0-3 = success ; 0FFH = File Not Found
2990: F1D3             vMakeFile:                      ; func22 (22 - 16) Make file
2991: F1D3 CD F2 EE               CALL   InitializeExtentNumberMSB ; set S2 to Zero
2992: F1D6 CD 73 EE               CALL   ReselectDisk
2993: F1D9 C3 8C F3               JP     MakeNewFile
2994: F1DC         ;-----------------------------------------------------------------
2995: F1DC         ; Rename file
2996: F1DC         ; In - (DE)	FCB Address
2997: F1DC         ; OUT - (A)	Directory Code
2998: F1DC         ;	0-3 = success ; 0FFH = File Not Found
2999: F1DC             vRenameFile:                      ; func23 (23 - 17) Rename File
3000: F1DC CD 73 EE               CALL   ReselectDisk
3001: F1DF CD 67 F3               CALL   Rename
3002: F1E2 C3 10 F4               JP     DirLocationToReturnLoc
3003: F1E5         ;-----------------------------------------------------------------
3004: F1E5         ;-----------------------------------------------------------------
3005: F1E5         ;*****************************************************************
3006: F1E5         ;-----------------------------------------------------------------
3007: F1E5         ;check current directory element for read/only status
3008: F1E5             CheckRODirectory:
3009: F1E5 CD C5 EF               CALL   GetCurrentDirectoryRecord ; address of element
3010: F1E8         ;	JMP	CheckROFile
3011: F1E8         ;------------
3012: F1E8         ;check current buff(dptr) or fcb(0) for r/o status
3013: F1E8             CheckROFile:
3014: F1E8 11 09 00               LD     DE,fcbROfileIndex
3015: F1EB 19                     ADD    HL,DE                ; offset to ro bit
3016: F1EC 7E                     LD     A,(HL)
3017: F1ED 17                     RLA
3018: F1EE D0                     RET    NC                   ; return if not set
3019: F1EF C3 E2 F4               JP     errReadOnlyFile      ; exit to read only disk message
3020: F1F2         ;-----------------------------------------------------------------
3021: F1F2         ;check for write protected disk
3022: F1F2             CheckWrite:
3023: F1F2 CD 68 EE               CALL   IsDiskWriteProtected
3024: F1F5 C8                     RET    Z                    ; OK to write
3025: F1F6 C3 DC F4               JP     errReadOnlyDisk      ; read only disk error
3026: F1F9         ;-----------------------------------------------------------------
3027: F1F9         ;-----------------------------------------------------------------
3028: F1F9         ;sequential disk read operation
3029: F1F9             ReadSeq:
3030: F1F9 3E 01                  LD     A,1
3031: F1FB 32 91 F5               LD     (seqReadFlag),A      ; set flag for seqential read
3032: F1FE         ;---
3033: F1FE         ; read the disk
3034: F1FE         ; read the next record from the current fcb
3035: F1FE             DiskRead:
3036: F1FE 3E FF                  LD     A,TRUE
3037: F200 32 8F F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
3038: F203
3039: F203 CD A0 EE               CALL   SetRecordVars        ; sets current File Record, fcbRecordCount and EXM
3040: F206 3A 9C F5               LD     A,(currentFileRecord)
3041: F209 21 9A F5               LD     HL,fcbRecordCount
3042: F20C BE                     CP     M                    ; current File Record-fcbRecordCount
3043: F20D         ; skip if  current File Record < fcbRecordCount
3044: F20D DA 23 F2               JP     C,RecordOK
3045: F210         ; not enough records in the extent
3046: F210 FE 80                  CP     RecordsPerExtent     ; current File Record = 128?   *** Records in an Extent
3047: F212 C2 39 F2               JP     NZ,DiskEOF           ; skip if current File Record<>128
3048: F215 CD 04 F3               CALL   OpenNextExt          ; go to next extent if so
3049: F218 AF                     XOR    A
3050: F219 32 9C F5               LD     (currentFileRecord),A ; current File Record=00
3051: F21C         ; now check for open ok
3052: F21C 3A C5 EA               LD     A,(exitParameterByte)
3053: F21F B7                     OR     A
3054: F220 C2 39 F2               JP     NZ,DiskEOF
3055: F223         ; stop at eof
3056: F223         ; arrive with fcb addressing a record to read
3057: F223             RecordOK:                       ; recordok:
3058: F223 CD E4 F3               CALL   GetBlockNumber       ; save it in Absolute CPM Record
3059: F226 CD F1 F3               CALL   IsAllocated          ; Absolute CPM Record=0000?
3060: F229 CA 39 F2               JP     Z,DiskEOF            ; get out if not allocated already
3061: F22C
3062: F22C CD F7 F3               CALL   SetActualRecordAdd   ; Absolute CPM Record now a record value
3063: F22F CD 02 F1               CALL   Seek                 ; to proper track,sector
3064: F232 CD 48 EE               CALL   ReadBuffer           ; to dma address
3065: F235 CD 6C F1               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
3066: F238 C9                     RET
3067: F239             DiskEOF:                        ; diskeof:
3068: F239 C3 17 F4               JP     SetLowReturnTo1      ; exitParameterByte = 1
3069: F23C         ;ret
3070: F23C         ;-----------------------------------------------------------------
3071: F23C         ;sequential disk write
3072: F23C             DiskWriteSeq:
3073: F23C 3E 01                  LD     A,1
3074: F23E 32 91 F5               LD     (seqReadFlag),A
3075: F241         ;--------
3076: F241         ;disk write
3077: F241             DiskWrite:
3078: F241 3E 00                  LD     A,FALSE
3079: F243 32 8F F5               LD     (readModeFlag),A
3080: F246         ; write record to currently selected file
3081: F246 CD F2 F1               CALL   CheckWrite           ; in case write protected
3082: F249 2A C3 EA               LD     HL,(paramDE)         ; HL = .fcb(0)
3083: F24C CD E8 F1               CALL   CheckROFile          ; may be a read-only file
3084: F24F CD A0 EE               CALL   SetRecordVars        ; set local Record parameters
3085: F252 3A 9C F5               LD     A,(currentFileRecord)
3086: F255 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
3087: F257 DA 5E F2               JP     C,DiskWrite1         ; skip if in the same Extent
3088: F25A CD 17 F4               CALL   SetLowReturnTo1
3089: F25D C9                     RET                         ; Exit ???????????
3090: F25E
3091: F25E         ; can write the next record, so continue
3092: F25E             DiskWrite1:
3093: F25E CD E4 F3               CALL   GetBlockNumber       ; sets up actual block number
3094: F261 CD F1 F3               CALL   IsAllocated
3095: F264 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
3096: F266 C2 B4 F2               JP     NZ,DiskWrite3
3097: F269         ; not allocated -
3098: F269         ; the argument to getblock is the starting position for the disk search
3099: F269         ; and should be the last allocated block for this file,
3100: F269         ; or the value 0 if no space has been allocated
3101: F269
3102: F269 CD 45 F4               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
3103: F26C 32 92 F5               LD     (diskMapIndex),A     ; save for later
3104: F26F 01 00 00               LD     BC,0000h             ; may use block zero
3105: F272 B7                     OR     A
3106: F273 CA 7D F2               JP     Z,FirstBlock         ; skip if no previous block
3107: F276         ; previous block exists
3108: F276 4F                     LD     C,A
3109: F277 0B                     DEC    BC                   ; previous block # in BC
3110: F278 CD 65 F4               CALL   GetDiskMapValue      ; previous block # to HL
3111: F27B 44                     LD     B,H
3112: F27C 4D                     LD     C,L                  ; BC=prev block#
3113: F27D         ; BC = 0000, or previous block #
3114: F27D             FirstBlock:
3115: F27D         ;	CALL	GetClosestBlockXX					; block # to HL
3116: F27D CD 15 F0               CALL   GetClosestBlock
3117: F280         ; arrive here with block# or zero
3118: F280 7D                     LD     A,L
3119: F281 B4                     OR     H
3120: F282 C2 8B F2               JP     NZ,BlockOK
3121: F285         ; cannot find a block to allocate
3122: F285 3E 02                  LD     A,2
3123: F287 32 C5 EA               LD     (exitParameterByte),A
3124: F28A C9                     RET                         ; exitParameterByte=2
3125: F28B
3126: F28B             BlockOK:
3127: F28B 22 9E F5               LD     (absoluteCPMRecord),HL ; allocated block number is in HL
3128: F28E EB                     EX     DE,HL                ; block number to DE
3129: F28F 2A C3 EA               LD     HL,(paramDE)
3130: F292 01 10 00               LD     BC,fcbDiskMapIndex
3131: F295 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
3132: F296 3A 96 F5               LD     A,(byteAllocationFlag)
3133: F299 B7                     OR     A                    ; set flags for byteAllocationFlag byte dm
3134: F29A 3A 92 F5               LD     A,(diskMapIndex)     ; recall dm index
3135: F29D CA A7 F2               JP     Z,Allocate16Bit      ; skip if allocating word
3136: F2A0         ; else allocate using a byte value
3137: F2A0 CD 7E F4               CALL   AddAtoHL
3138: F2A3 73                     LD     (HL),E               ; byteAllocationFlag byte alloc
3139: F2A4 C3 AF F2               JP     DiskWrite2           ; to continue
3140: F2A7
3141: F2A7             Allocate16Bit:                      ; allocate a word value
3142: F2A7
3143: F2A7 4F                     LD     C,A
3144: F2A8 06 00                  LD     B,0                  ; double(diskMapIndex)
3145: F2AA 09                     ADD    HL,BC
3146: F2AB 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
3147: F2AC 72                     LD     (HL),D
3148: F2AD 23                     INC    HL
3149: F2AE 73                     LD     (HL),E               ; double wd
3150: F2AF         ; disk write to previously unallocated block
3151: F2AF             DiskWrite2:
3152: F2AF 0E 02                  LD     C,WriteCleanBuffer   ; marked as unallocated write
3153: F2B1 CD 08 EF               CALL   ResetFileWriteFlag
3154: F2B4         ; continue the write operation of no allocation error
3155: F2B4         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
3156: F2B4
3157: F2B4             DiskWrite3:
3158: F2B4 3A C5 EA               LD     A,(exitParameterByte)
3159: F2B7 B7                     OR     A
3160: F2B8 C0                     RET    NZ                   ; stop if non zero returned value
3161: F2B9
3162: F2B9 C5                     PUSH   BC                   ; save write flag ( in C see above)
3163: F2BA CD F7 F3               CALL   SetActualRecordAdd   ; Absolute CPM Record set to actual record number
3164: F2BD CD 02 F1               CALL   Seek                 ; to proper file position
3165: F2C0 C1                     POP    BC                   ; get write flag
3166: F2C1 C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
3167: F2C2 CD AD EF               CALL   WriteBuffer          ; written to disk
3168: F2C5 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
3169: F2C6         ; increment record count if fcbRecordCount<=current File Record
3170: F2C6 3A 9C F5               LD     A,(currentFileRecord)
3171: F2C9 21 9A F5               LD     HL,fcbRecordCount
3172: F2CC BE                     CP     M                    ; current File Record-fcbRecordCount
3173: F2CD DA D4 F2               JP     C,DiskWrite4
3174: F2D0         ; fcbRecordCount <= current File Record
3175: F2D0 77                     LD     (HL),A
3176: F2D1 34                     INC    M                    ; fcbRecordCount = current File Record+1
3177: F2D2 0E 02                  LD     C,2                  ; mark as record count incremented
3178: F2D4             DiskWrite4:
3179: F2D4         ; A has current File Record, C=2 if new block or new record#
3180: F2D4 0D                     DEC    C
3181: F2D5 0D                     DEC    C
3182: F2D6 C2 E1 F2               JP     NZ,DiskWrite5
3183: F2D9 F5                     PUSH   AF                   ; save current File Record value
3184: F2DA CD F8 EE               CALL   GetExtentNumberMSB   ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
3185: F2DD         ; reset the file write flag to mark as written fcb
3186: F2DD E6 7F                  AND    7FH                  ; not writeFlagMask
3187: F2DF 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
3188: F2E0 F1                     POP    AF                   ; restore current File Record
3189: F2E1             DiskWrite5:
3190: F2E1         ; check for end of extent, if found attempt to open next extent in preparation for next write
3191: F2E1 FE 7F                  CP     highestRecordNumber  ; current File Record=highestRecordNumber?
3192: F2E3 C2 01 F3               JP     NZ,DiskWrite7        ; skip if not
3193: F2E6         ; may be random access write, if so we are done
3194: F2E6 3A 91 F5               LD     A,(seqReadFlag)
3195: F2E9 B7                     OR     A
3196: F2EA CA 01 F3               JP     Z,DiskWrite7         ; skip next extent open op
3197: F2ED         ; update current fcb before going to next extent
3198: F2ED CD 6C F1               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
3199: F2F0 CD 04 F3               CALL   OpenNextExt          ; readModeFlag=false
3200: F2F3         ; current File Record remains at highestRecordNumber causing eof if no more directory space is available
3201: F2F3 21 C5 EA               LD     HL,exitParameterByte
3202: F2F6 7E                     LD     A,(HL)
3203: F2F7 B7                     OR     A
3204: F2F8 C2 FF F2               JP     NZ,DiskWrite6        ; no space
3205: F2FB         ; space available, set current File Record=255
3206: F2FB 3D                     DEC    A
3207: F2FC 32 9C F5               LD     (currentFileRecord),A ; goes to 00 next time
3208: F2FF             DiskWrite6:
3209: F2FF 36 00                  LD     (HL),0               ; exitParameterByte = 00 for returned value
3210: F301             DiskWrite7:
3211: F301 C3 6C F1               JP     UpdateRecordVars     ; update variables from I/O in  fcb
3212: F304         ;ret
3213: F304         ;-----------------------------------------------------------------
3214: F304         ;close the current extent  and open the next one if possible.
3215: F304         ;readModeFlag is true if in read mode
3216: F304             OpenNextExt:                      ; open$reel
3217: F304 AF                     XOR    A
3218: F305 32 8E F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
3219: F308 CD 86 ED               CALL   CloseDirEntry        ; close current extent
3220: F30B         ; exitParameterByte remains at enddir if we cannot open the next ext
3221: F30B CD BC EF               CALL   AtEndOfDirectory
3222: F30E C8                     RET    Z                    ; return if end
3223: F30F 2A C3 EA               LD     HL,(paramDE)         ; increment extent number
3224: F312 01 0C 00               LD     BC,fcbExtIndex
3225: F315 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
3226: F316 7E                     LD     A,(HL)
3227: F317 3C                     INC    A
3228: F318 E6 1F                  AND    maxExtValue
3229: F31A 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
3230: F31B CA 2D F3               JP     Z,OpenNextModule     ; move to next module if zero
3231: F31E         ; may be in the same extent group
3232: F31E 47                     LD     B,A
3233: F31F 3A 81 F5               LD     A,(dpbEXM)
3234: F322 A0                     AND    B
3235: F323         ; if result is zero, then not in the same group
3236: F323 21 8E F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
3237: F326 A6                     AND    M                    ; produces a 00 in accumulator if not written
3238: F327 CA 38 F3               JP     Z,OpenNextExt1       ; go to next physical extent
3239: F32A         ; result is non zero, so we must be in same logical ext
3240: F32A C3 56 F3               JP     OpenNextExt2         ; to copy fcb information
3241: F32D         ; extent number overflow, go to next module
3242: F32D
3243: F32D             OpenNextModule:
3244: F32D 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
3245: F330 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
3246: F331 34                     INC    M                    ; fcb(fcbS2Index)=++1
3247: F332         ; module number incremented, check for overflow
3248: F332 7E                     LD     A,(HL)
3249: F333 E6 0F                  AND    moduleMask           ; mask high order bits
3250: F335 CA 61 F3               JP     Z,OpenNextExtError   ; cannot overflow to zero
3251: F338         ; otherwise, ok to continue with new module
3252: F338
3253: F338             OpenNextExt1:
3254: F338 0E 0F                  LD     C,nameLength
3255: F33A CD 20 EF               CALL   SearchForDirectoryRecord ; next extent found?
3256: F33D CD BC EF               CALL   AtEndOfDirectory
3257: F340 C2 56 F3               JP     NZ,OpenNextExt2
3258: F343         ; end of file encountered
3259: F343 3A 8F F5               LD     A,(readModeFlag)
3260: F346 3C                     INC    A                    ; 0ffh becomes 00 if read
3261: F347 CA 61 F3               JP     Z,OpenNextExtError   ; sets exitParameterByte = 1
3262: F34A         ; try to extend the current file
3263: F34A CD 8C F3               CALL   MakeNewFile
3264: F34D         ; cannot be end of directory
3265: F34D CD BC EF               CALL   AtEndOfDirectory
3266: F350 CA 61 F3               JP     Z,OpenNextExtError   ; with exitParameterByte = 1
3267: F353 C3 59 F3               JP     OpenNextExt3
3268: F356
3269: F356         ; not end of file, open
3270: F356             OpenNextExt2:
3271: F356 CD 4C ED               CALL   CopyDirRecordToFCB
3272: F359             OpenNextExt3:
3273: F359 CD A0 EE               CALL   SetRecordVars        ; Set Record parameters
3274: F35C AF                     XOR    A
3275: F35D 32 C5 EA               LD     (exitParameterByte),A ; exitParameterByte = 0
3276: F360 C9                     RET                         ; with exitParameterByte = 0
3277: F361
3278: F361         ; cannot move to next extent of this file
3279: F361             OpenNextExtError:
3280: F361 CD 17 F4               CALL   SetLowReturnTo1      ; exitParameterByte = 1
3281: F364 C3 01 EF               JP     SetFileWriteFlag     ; ensure that it will not be closed
3282: F367         ;-----------------------------------------------------------------
3283: F367         ;rename the file described by the first half of the currently addressed FCB.
3284: F367         ;the new name is contained in the last half of the FCB. The file name and type
3285: F367         ;are changed, but the reel number is ignored.  the user number is identical
3286: F367             Rename:
3287: F367 CD F2 F1               CALL   CheckWrite           ; may be write protected
3288: F36A         ; search up to the extent field
3289: F36A 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
3290: F36C CD 20 EF               CALL   SearchForDirectoryRecord
3291: F36F         ; copy position 0
3292: F36F 2A C3 EA               LD     HL,(paramDE)
3293: F372 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
3294: F373 11 10 00               LD     DE,fcbDiskMapIndex
3295: F376 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
3296: F377 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
3297: F378         ; assume the same disk drive for new named file
3298: F378             Rename1:
3299: F378 CD BC EF               CALL   AtEndOfDirectory
3300: F37B C8                     RET    Z                    ; stop at end of dir
3301: F37C         ; not end of directory, rename next element
3302: F37C CD E5 F1               CALL   CheckRODirectory     ; may be read-only file
3303: F37F 0E 10                  LD     C,fcbDiskMapIndex
3304: F381 1E 0C                  LD     E,fcbExtIndex
3305: F383 CD 30 F4               CALL   CopyDir
3306: F386         ; element renamed, move to next
3307: F386 CD 35 EF               CALL   GetNextDirectoryRecord
3308: F389 C3 78 F3               JP     Rename1
3309: F38C         ;-----------------------------------------------------------------
3310: F38C         ;create a new file by creating a directory entry then opening the file
3311: F38C             MakeNewFile:
3312: F38C CD F2 F1               CALL   CheckWrite           ; may be write protected
3313: F38F 2A C3 EA               LD     HL,(paramDE)
3314: F392 E5                     PUSH   HL                   ; save fcb address, look for e5
3315: F393 21 68 F5               LD     HL,emptyFCB
3316: F396 22 C3 EA               LD     (paramDE),HL         ; paramDE = .empty
3317: F399 0E 01                  LD     C,1
3318: F39B CD 20 EF               CALL   SearchForDirectoryRecord ; length 1 match on empty entry
3319: F39E CD BC EF               CALL   AtEndOfDirectory     ; zero flag set if no space
3320: F3A1 E1                     POP    HL                   ; recall paramDE address
3321: F3A2 22 C3 EA               LD     (paramDE),HL         ; in case we return here
3322: F3A5 C8                     RET    Z                    ; return with error condition 255 if not found
3323: F3A6 EB                     EX     DE,HL                ; DE = paramDE address
3324: F3A7         ; clear the remainder of the fcb
3325: F3A7 21 0F 00               LD     HL,nameLength
3326: F3AA 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
3327: F3AB 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
3328: F3AD AF                     XOR    A                    ; clear accumulator to 00 for fill
3329: F3AE             MakeNewFile1:
3330: F3AE 77                     LD     (HL),A
3331: F3AF 23                     INC    HL
3332: F3B0 0D                     DEC    C
3333: F3B1 C2 AE F3               JP     NZ,MakeNewFile1
3334: F3B4 21 0D 00               LD     HL,fcbS1Index
3335: F3B7 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
3336: F3B8 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
3337: F3B9 CD D3 EF               CALL   SetDirectoryEntry    ; may have extended the directory
3338: F3BC         ; now copy entry to the directory
3339: F3BC CD 29 F4               CALL   CopyFCB
3340: F3BF         ; and set the file write flag to "1"
3341: F3BF C3 01 EF               JP     SetFileWriteFlag
3342: F3C2         ;-----------------------------------------------------------------
3343: F3C2         ;delete the currently addressed file
3344: F3C2             DeleteFile:
3345: F3C2 CD F2 F1               CALL   CheckWrite           ; write protected ?
3346: F3C5 0E 0C                  LD     C,fcbExtIndex        ; extent number field
3347: F3C7 CD 20 EF               CALL   SearchForDirectoryRecord ; search through file type
3348: F3CA             DeleteFile1:
3349: F3CA         ; loop while directory matches
3350: F3CA CD BC EF               CALL   AtEndOfDirectory
3351: F3CD C8                     RET    Z                    ; exit if end
3352: F3CE         ; set each non zero disk map entry to 0 in the allocation vector
3353: F3CE CD E5 F1               CALL   CheckRODirectory     ; ro disk error if found
3354: F3D1 CD C5 EF               CALL   GetCurrentDirectoryRecord ; HL=.buff(dptr)
3355: F3D4 36 E5                  LD     (HL),emptyDir
3356: F3D6 0E 00                  LD     C,FALSE
3357: F3D8 CD E9 EF               CALL   ScanDiskMap          ; alloc elts set to 0
3358: F3DB CD 9D EF               CALL   WriteDir             ; write the directory
3359: F3DE CD 35 EF               CALL   GetNextDirectoryRecord ; to next element
3360: F3E1 C3 CA F3               JP     DeleteFile1          ; for another record
3361: F3E4         ;-----------------------------------------------------------------
3362: F3E4
3363: F3E4         ;-----------------------------------------------------------------
3364: F3E4         ;? ;enter from CloseDirEntry to seek and copy current element
3365: F3E4         ;? SeekCopy:
3366: F3E4         ;?	CALL	SeekDir							; to the directory element
3367: F3E4         ;?	JP		WriteDir						; write the directory element
3368: F3E4         ;?	;ret
3369: F3E4         ;? ;-----------------------------------------------------------------
3370: F3E4         ;-----------------------------------------------------------------
3371: F3E4         ;-----------------------------------------------------------------
3372: F3E4
3373: F3E4
3374: F3E4         ;-----------------------------------------------------------------
3375: F3E4         ;compute disk block number from current fcb
3376: F3E4             GetBlockNumber:
3377: F3E4 CD 45 F4               CALL   GetDiskMapIndex      ; 0...15 in register A
3378: F3E7 4F                     LD     C,A
3379: F3E8 06 00                  LD     B,0
3380: F3EA CD 65 F4               CALL   GetDiskMapValue      ; return value in HL
3381: F3ED 22 9E F5               LD     (absoluteCPMRecord),HL ; save for later
3382: F3F0 C9                     RET
3383: F3F1         ;-----------------------------------------------------------------
3384: F3F1         ;is  block allocated
3385: F3F1             IsAllocated:
3386: F3F1 2A 9E F5               LD     HL,(absoluteCPMRecord)
3387: F3F4 7D                     LD     A,L
3388: F3F5 B4                     OR     H
3389: F3F6 C9                     RET
3390: F3F7         ;-----------------------------------------------------------------
3391: F3F7         ;compute actual record address
3392: F3F7         ; result = absolute CPMRecord * ( 2**BSH)
3393: F3F7             SetActualRecordAdd:
3394: F3F7 3A 7F F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
3395: F3FA 2A 9E F5               LD     HL,(absoluteCPMRecord)
3396: F3FD
3397: F3FD             SetActualRecordAdd1:
3398: F3FD 29                     ADD    HL,HL
3399: F3FE 3D                     DEC    A                    ; shl(absolute CPMRecord,dpbBSH)
3400: F3FF C2 FD F3               JP     NZ,SetActualRecordAdd1
3401: F402         ; HL has Record number for start of the block;
3402: F402 3A 80 F5               LD     A,(dpbBLM)           ; get block mask
3403: F405 4F                     LD     C,A                  ; to get current File Record mod Block
3404: F406 3A 9C F5               LD     A,(currentFileRecord) ; get index into block
3405: F409 A1                     AND    C                    ; masked value in A
3406: F40A B5                     OR     L
3407: F40B 6F                     LD     L,A                  ; to HL
3408: F40C 22 9E F5               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL or (current File Record and dpbBLM)
3409: F40F         ; *** Absolute CPM Record now has current record number - Starting record number + index into block
3410: F40F C9                     RET
3411: F410         ;-----------------------------------------------------------------
3412: F410         ;---------------------
3413: F410         ;copy directory location to exitParameterByte
3414: F410             DirLocationToReturnLoc:
3415: F410 3A 90 F5               LD     A,(directoryFlag)
3416: F413 32 C5 EA               LD     (exitParameterByte),A
3417: F416 C9                     RET
3418: F417         ;---------------------
3419: F417
3420: F417
3421: F417         ;---------------------
3422: F417         ;set exitParameterByte to 1
3423: F417             SetLowReturnTo1:
3424: F417 3E 01                  LD     A,1
3425: F419 32 C5 EA               LD     (exitParameterByte),A
3426: F41C C9                     RET
3427: F41D         ;---------------------
3428: F41D         ;---------------------
3429: F41D         ;copy the directory entry to the user buffer
3430: F41D             CopyDirEntryToUser:
3431: F41D 2A 75 F5               LD     HL,(caDirectoryDMA)
3432: F420 EB                     EX     DE,HL                ; source is directory buffer
3433: F421 2A 6D F5               LD     HL,(initDAMAddress)  ; destination is user dma address
3434: F424 0E 80                  LD     C,cpmRecordSize      ; copy entire record
3435: F426 C3 9E F4               JP     MoveX
3436: F429         ;---------------------
3437: F429         ;copy the whole file control block
3438: F429             CopyFCB:
3439: F429 0E 00                  LD     C,0
3440: F42B 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
3441: F42D C3 30 F4               JP     CopyDir
3442: F430         ;---------------------
3443: F430         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
3444: F430             CopyDir:
3445: F430 D5                     PUSH   DE                   ; save length for later
3446: F431 06 00                  LD     B,0                  ; double index to BC
3447: F433 2A C3 EA               LD     HL,(paramDE)         ; HL = source for data
3448: F436 09                     ADD    HL,BC
3449: F437 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
3450: F438 CD C5 EF               CALL   GetCurrentDirectoryRecord ; HL=.buff(dptr), destination
3451: F43B C1                     POP    BC                   ; DE=source, HL=dest, C=length
3452: F43C CD 9E F4               CALL   MoveX                ; data moved
3453: F43F         ;enter from close to seek and copy current element
3454: F43F             SeekAndCopy:                      ; seek$copy:
3455: F43F CD F1 F0               CALL   SeekDir              ; seek$dir ;to the directory element
3456: F442 C3 9D EF               JP     WriteDir             ; write the directory element
3457: F445         ;---------------------
3458: F445         ;Return the  disk map Index for current File Record in the ACC
3459: F445         ;  account for multiple extents in 1 physical Directory entry
3460: F445             GetDiskMapIndex:                      ; dm$position
3461: F445 21 7F F5               LD     HL,dpbBSH            ; get block shift value
3462: F448 4E                     LD     C,(HL)               ; shift count to C
3463: F449 3A 9C F5               LD     A,(currentFileRecord) ; current virtual record to A
3464: F44C             GetDiskMapIndex1:
3465: F44C B7                     OR     A                    ; reset the carry flag
3466: F44D 1F                     RRA
3467: F44E 0D                     DEC    C
3468: F44F C2 4C F4               JP     NZ,GetDiskMapIndex1
3469: F452         ; A = shr(current File Record,dpbBSH) = current File Record/2**(sect/block)
3470: F452         ; A has the relative position in the block.
3471: F452 47                     LD     B,A                  ; save it for later addition
3472: F453 3E 08                  LD     A,8
3473: F455 96                     SUB    M                    ; 8-dpbBSH to accumulator
3474: F456 4F                     LD     C,A                  ; extent shift count in register c
3475: F457 3A 9B F5               LD     A,(extentValue)      ; extent value ani extmsk
3476: F45A             GetDiskMapIndex2:                      ; dmpos1:
3477: F45A         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
3478: F45A         ; shift is 4,3,2,1,0
3479: F45A 0D                     DEC    C
3480: F45B CA 63 F4               JP     Z,GetDiskMapIndex3
3481: F45E B7                     OR     A                    ; clear the carry flag
3482: F45F 17                     RLA
3483: F460 C3 5A F4               JP     GetDiskMapIndex2
3484: F463
3485: F463         ; The ACC has the Block Number for this record
3486: F463             GetDiskMapIndex3:
3487: F463         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
3488: F463 80                     ADD    A,B                  ; add the previous shr(current File Record,dpbBSH) value
3489: F464         ; A is one of the following values, depending upon alloc
3490: F464         ; bks dpbBSH
3491: F464         ; 1k   3     v/8 + extentValue * 16
3492: F464         ; 2k   4     v/16+ extentValue * 8
3493: F464         ; 4k   5     v/32+ extentValue * 4
3494: F464         ; 8k   6     v/64+ extentValue * 2
3495: F464         ; 16k  7     v/128+extentValue * 1
3496: F464 C9                     RET                         ; with disk map position in A
3497: F465         ;---------------------
3498: F465         ; Enter with Disk Map Index in BG
3499: F465         ; Return disk map value  in HL
3500: F465             GetDiskMapValue:
3501: F465 2A C3 EA               LD     HL,(paramDE)         ; base address of file control block
3502: F468 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
3503: F46B 19                     ADD    HL,DE                ; HL =.diskmap
3504: F46C 09                     ADD    HL,BC                ; index by a  byte value
3505: F46D 3A 96 F5               LD     A,(byteAllocationFlag) ;  byte map entry?
3506: F470 B7                     OR     A
3507: F471 CA 78 F4               JP     Z,GetDiskMap16Bit    ; get disk map  byte
3508: F474 6E                     LD     L,(HL)
3509: F475 26 00                  LD     H,0
3510: F477 C9                     RET                         ; with HL=00bb
3511: F478             GetDiskMap16Bit:                      ; getdmd:
3512: F478 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
3513: F479         ; double precision value returned
3514: F479 56                     LD     D,(HL)
3515: F47A 23                     INC    HL
3516: F47B 5E                     LD     E,(HL)
3517: F47C EB                     EX     DE,HL
3518: F47D C9                     RET
3519: F47E         ;---------------------
3520: F47E         ;---------------------
3521: F47E         ;*****************************************************************
3522: F47E         ;************************ Utilities ******************************
3523: F47E         ;*****************************************************************
3524: F47E             AddAtoHL:
3525: F47E 85                     ADD    A,L
3526: F47F 6F                     LD     L,A
3527: F480 D0                     RET    NC
3528: F481 24                     INC    H
3529: F482 C9                     RET
3530: F483         ;----------
3531: F483             DEminusHL2HL:
3532: F483 7B                     LD     A,E
3533: F484 95                     SUB    L
3534: F485 6F                     LD     L,A
3535: F486 7A                     LD     A,D
3536: F487 9C                     SBC    A,H
3537: F488 67                     LD     H,A
3538: F489 C9                     RET
3539: F48A         ;-------------
3540: F48A             ShiftRightHLbyC:
3541: F48A 0C                     INC    C
3542: F48B             ShiftRightHLbyC0:
3543: F48B 0D                     DEC    C
3544: F48C C8                     RET    Z
3545: F48D 7C                     LD     A,H
3546: F48E B7                     OR     A
3547: F48F 1F                     RRA
3548: F490 67                     LD     H,A
3549: F491 7D                     LD     A,L
3550: F492 1F                     RRA
3551: F493 6F                     LD     L,A
3552: F494 C3 8B F4               JP     ShiftRightHLbyC0
3553: F497         ;-------
3554: F497             ShiftLeftHLbyC:
3555: F497 0C                     INC    C
3556: F498             ShiftLeftHLbyC0:
3557: F498 0D                     DEC    C
3558: F499 C8                     RET    Z                    ; exit when done
3559: F49A 29                     ADD    HL,HL
3560: F49B C3 98 F4               JP     ShiftLeftHLbyC0
3561: F49E         ;*****************************************************************
3562: F49E         ;move data length of length C from source DE to HL
3563: F49E             MoveX:
3564: F49E 0C                     INC    C
3565: F49F             MoveX0:
3566: F49F 0D                     DEC    C
3567: F4A0 C8                     RET    Z
3568: F4A1 1A                     LD     A,(DE)
3569: F4A2 77                     LD     (HL),A
3570: F4A3 13                     INC    DE
3571: F4A4 23                     INC    HL
3572: F4A5 C3 9F F4               JP     MoveX0
3573: F4A8
3574: F4A8         ;********** Console OUT Routines*******************??????
3575: F4A8
3576: F4A8         ;---------------------------------- Is Bit Set ------------------------------;
3577: F4A8         ; Enter HL  contains the bit map                                             ;
3578: F4A8         ;       B   Has the bit number (0...F)                                       ;
3579: F4A8         ; Return ZFlag = 1 if bit is reset (0)                                       ;
3580: F4A8         ;              = 0 if bit is set (1)                                         ;
3581: F4A8             IsBitSet:                       ;
3582: F4A8 04                     INC    B                    ;
3583: F4A9             IsBitSetLoop:                      ;
3584: F4A9 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3585: F4AA CB 45                  BIT    0,L                  ; is LSB set?                        ;
3586: F4AC 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set                ;
3587: F4AE 3F                     CCF                         ; else Clear Carry flag              ;
3588: F4AF             IsBitSet1:                      ;
3589: F4AF CB 1C                  RR     H                    ; Shift thru CY                      ;
3590: F4B1 CB 1D                  RR     L                    ; ditto                              ;
3591: F4B3 10 F4                  DJNZ   IsBitSetLoop         ;
3592: F4B5 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	 ;
3593: F4B7 C9                     RET                         ;
3594: F4B8         ;---------------------------------- Is Bit Set ------------------------------;
3595: F4B8
3596: F4B8         ;============================ Set/Reset Vector Bit ==========================;
3597: F4B8         ;---------------------------------- Set Vector Bit -------------------------;;
3598: F4B8         ; Enter  HL  contains the bit map vector                                    ;;
3599: F4B8         ;        B   Has the bit number (0...F)                                     ;;
3600: F4B8         ; Return HL  Contains the modified bit map vector                           ;;
3601: F4B8             SetVectorBit:                      ;;
3602: F4B8 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3603: F4B9 CD A8 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3604: F4BC         ;;
3605: F4BC C1                     POP    BC                   ; Get the bit position              ;;
3606: F4BD CB FC                  SET    7,H                  ;;
3607: F4BF 18 07                  JR     ReAlignVector        ;                                    ;
3608: F4C1         ;---------------------------------- Set Vector Bit -------------------------;;
3609: F4C1         ;---------------------------------- Reset Vector Bit -----------------------;;
3610: F4C1         ; Enter  HL  contains the bit map vector                                    ;;
3611: F4C1         ;        B   Has the bit number (0...F)                                     ;;
3612: F4C1         ; Return HL  Contains the modified bit map vector                           ;;
3613: F4C1             ResetVectorBit:                      ;;
3614: F4C1 C5                     PUSH   BC                   ; Save the Bit Number               ;;
3615: F4C2 CD A8 F4               CALL   IsBitSet             ; Put the bit in the LSBit          ;;
3616: F4C5         ;;
3617: F4C5 C1                     POP    BC                   ; Get the bit position              ;;
3618: F4C6 CB BC                  RES    7,H                  ;;
3619: F4C8         ; Fall thru to ReAlignVector                                                 ;
3620: F4C8         ;---------------------------------- Reset Vector Bit -----------------------;;
3621: F4C8         ;---------------------------------- Set VectorBit --------------------------;;
3622: F4C8         ; Adjusts the HL register to its Original Alignment after IsBitSet           ;
3623: F4C8         ;
3624: F4C8             ReAlignVector:                      ;
3625: F4C8 04                     INC    B                    ;
3626: F4C9             ReAlignMapLoop:                      ;
3627: F4C9 37                     SCF                         ; Set carry flag, expect LSBit = 1   ;
3628: F4CA CB 7C                  BIT    7,H                  ; is LSB set?                        ;
3629: F4CC 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set                ;
3630: F4CE 3F                     CCF                         ; else Clear Carry flag              ;
3631: F4CF             ReAlignMap1:                      ;
3632: F4CF CB 15                  RL     L                    ; Shift thru CY                      ;
3633: F4D1 CB 14                  RL     H                    ; ditto                              ;
3634: F4D3 10 F4                  DJNZ   ReAlignMapLoop       ;
3635: F4D5 C9                     RET                         ;
3636: F4D6         ;============================ Set/Reset Vector Bit ==========================;
3637: F4D6         ;************Error message World*************************
3638: F4D6             errSelect:
3639: F4D6 21 F5 F4               LD     HL,evSelection
3640: F4D9 C3 EE F4               JP     GoToError
3641: F4DC             errReadOnlyDisk:
3642: F4DC 21 F7 F4               LD     HL,evReadOnlyDisk
3643: F4DF C3 EE F4               JP     GoToError
3644: F4E2             errReadOnlyFile:
3645: F4E2 21 F9 F4               LD     HL,evReadOnlyFile
3646: F4E5 C3 EE F4               JP     GoToError
3647: F4E8             errPermanent:
3648: F4E8 21 F3 F4               LD     HL,evPermanent
3649: F4EB C3 EE F4               JP     GoToError
3650: F4EE         ;************Error message handler **********************
3651: F4EE             GoToError:
3652: F4EE         ;HL = .errorhandler, call subroutine
3653: F4EE 5E                     LD     E,(HL)
3654: F4EF 23                     INC    HL
3655: F4F0 56                     LD     D,(HL)               ; address of routine in DE
3656: F4F1 EB                     EX     DE,HL
3657: F4F2 E9                     JP     (HL)                 ; vector to subroutine
3658: F4F3         ;************ Error Vectors *****************************
3659: F4F3 01 F5       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
3660: F4F5 0D F5       evSelection: DW     erSelection          ; selerr select error subroutine
3661: F4F7 13 F5       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
3662: F4F9 19 F5       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
3663: F4FB         ;************Error Routines ******************************
3664: F4FB             erPermanentNoWait:
3665: F4FB 21 4B F5               LD     HL,emPermanent
3666: F4FE C3 EE F4               JP     GoToError
3667: F501             erPermanent:
3668: F501 21 4B F5               LD     HL,emPermanent
3669: F504 CD 22 F5               CALL   displayAndWait       ; to report the error
3670: F507 FE 03                  CP     CTRL_C
3671: F509 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
3672: F50C C9                     RET                         ; and ignore the error
3673: F50D         ;
3674: F50D             erSelection:
3675: F50D 21 56 F5               LD     HL,emSelection
3676: F510 C3 1C F5               JP     waitB4boot           ; wait console before boot
3677: F513         ;
3678: F513             erReadOnlyDisk:
3679: F513 21 62 F5               LD     HL,emReadOnlyDisk
3680: F516 C3 1C F5               JP     waitB4boot           ; wait console before boot
3681: F519         ;
3682: F519             erReadOnlyFile:
3683: F519 21 5D F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3684: F51C         ;
3685: F51C         ; wait for response before boot
3686: F51C             waitB4boot:
3687: F51C CD 22 F5               CALL   displayAndWait
3688: F51F C3 00 00               JP     WarmBoot
3689: F522
3690: F522         ;report error to console, message address in HL
3691: F522             displayAndWait:
3692: F522 E5                     PUSH   HL                   ; save message pointer
3693: F523 CD D6 E9               CALL   showCRLF             ; stack mssg address, new line
3694: F526 3A 67 F5               LD     A,(currentDisk)
3695: F529 C6 41                  ADD    A,ASCII_A
3696: F52B 32 47 F5               LD     (emDisk),A           ; Problem disk name
3697: F52E 01 3B F5               LD     BC,emDisk0
3698: F531 CD 3B E9               CALL   Print                ; the error message
3699: F534 C1                     POP    BC
3700: F535 CD 3B E9               CALL   Print                ; error mssage tail
3701: F538 C3 21 E9               JP     ConIn                ; to get the input character
3702: F53B         ;ret
3703: F53B         ;**************Error Messages*******************************
3704: F53B 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3705: F547 20 3A 20 24     emDisk:    DB     ' : $'
3706: F54B 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3707: F556 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3708: F55D 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3709: F562 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3710: F566         ;*****************************************************************
3711: F566
3712: F566         ;********* file control block (fcb) constants ********************
3713: F566             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3714: F566             fcbROfileIndex EQU    09H                  ; high order of first type char
3715: F566             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3716: F566             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3717: F566             fcbS1Index EQU    0DH                  ;13				; S1 index
3718: F566             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3719: F566             fcbRCIndex EQU    0FH                  ;15				; record count field index
3720: F566             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3721: F566
3722: F566             fcbCurrentRecord EQU    21H                  ;33
3723: F566
3724: F566             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3725: F566
3726: F566             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3727: F566             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3728: F566             dirEntryMask EQU    dirEntriesPerRecord-1
3729: F566             fcbShift   EQU    5                    ; log2(fcbLength)
3730: F566         ;
3731: F566
3732: F566
3733: F566
3734: F566             maxExtValue EQU    31                   ; largest extent number
3735: F566             moduleMask EQU    15                   ; limits module number value
3736: F566             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3737: F566             nameLength EQU    15                   ; namlen name length
3738: F566
3739: F566             emptyDir   EQU    0E5H                 ; empty empty directory entry
3740: F566             NEXT_RECORD EQU    fcbLength            ; nxtrec
3741: F566             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3742: F566         ;
3743: F566         ;	reserved file indicators
3744: F566         ;	equ	11				; reserved
3745: F566         ;*****************************************************************
3746: F566         ;*****************************************************************
3747: F566
3748: F566         ;***common values shared between bdosi and bdos******************
3749: F566 00          currentUserNumber: DB     0                    ; usrcode current user number
3750: F567         ; paramDE:			DS	2					; ParamsDE information address
3751: F567         ; exitParameterByte:
3752: F567         ; exitParameterWord:	DS	2					; address value to return
3753: F567 FF          currentDisk: DB     -1                   ; curdsk current disk number
3754: F568         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3755: F568
3756: F568         ;********************* Local Variables ***************************
3757: F568         ;     ************************
3758: F568         ;     *** Initialized Data ***
3759: F568
3760: F568 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3761: F569 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
3762: F56B 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3763: F56D 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3764: F56F
3765: F56F         ;     *** Current Disk attributes ****
3766: F56F         ; These are set upon disk select
3767: F56F         ; data must be adjacent, do not insert variables
3768: F56F         ; address of translate vector, not used
3769: F56F         ; ca - currentAddress
3770: F56F
3771: F56F 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3772: F571 00 00       caTrack:   DW     0000H                ; curtrka current track address
3773: F573 00 00       caSector:  DW     0000H                ; current Sector
3774: F575             caListSizeStart:
3775: F575 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3776: F577 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3777: F579 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3778: F57B 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3779: F57D             caListSizeEnd:
3780: F57D             caListSize EQU    caListSizeEnd - caListSizeStart
3781: F57D
3782: F57D         ;     ***** Disk Parameter Block *******
3783: F57D         ; data must be adjacent, do not insert variables
3784: F57D         ; dpb - Disk Parameter Block
3785: F57D             dpbStart:
3786: F57D 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3787: F57F 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3788: F580 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3789: F581 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3790: F582 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3791: F584 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3792: F586 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3793: F588 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3794: F58A 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3795: F58C             dpbEnd:
3796: F58C             dpbSize    EQU    dpbEnd - dpbStart
3797: F58C         ;
3798: F58C
3799: F58C         ;     ************************
3800: F58C
3801: F58C 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3802: F58E 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3803: F58F 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3804: F590 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3805: F591 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3806: F592 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3807: F593 00          searchLength: DB     00H                  ; searchl search length
3808: F594 00 00       searchAddress: DW     0000H                ; searcha search address
3809: F596         ;tinfo:	ds	word							; temp for info in "make"
3810: F596 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3811: F597 00          fResel:    DB     00H                  ; resel reselection flag
3812: F598 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3813: F599 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3814: F59A 00          fcbRecordCount: DB     00H                  ; record count from current FCB
3815: F59B 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3816: F59C 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3817: F59E 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3818: F5A0         ;
3819: F5A0         ;	local variables for directory access
3820: F5A0 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3821: F5A1 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3822: F5A3 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3823: F5A5
3824: F5A5         ;********************** data areas ******************************
3825: F5A5
3826: F5A5
3827: F5A5         ;---------------------------------- Stack Area--------------------------------;
3828: F5A5             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3829: F5E5             bdosStack:
3830: F5E5         ;
3831: F5E5         ;---------------------------------- Stack Area--------------------------------;
3832: F5E5         ;	end of Basic I/O System
3833: F5E5         ;-----------------------------------------------------------------;
3834: F5E5
3835: F5E5
3836: F5E5         ;
3837: F5E5             Z_HighestLocation:
3838: F5E5             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3839: F5E5
3840: F5E5
           ************************   Xref   ************************
0000: $               F5E5   0418 0448
3817: absoluteCPMRecord F59E   2811 2818 2836 3127 3381 3386 3395 3408
3524: AddAtoHL        F47E   3137
3141: Allocate16Bit   F2A7   3135
1045: AreWeAtEndOfBuffer EA3A   1041
0086: ASCII_A         0041   3695
0087: ASCII_C         0043
0088: ASCII_K         004B
0095: ASCII_LO_A      0061
0096: ASCII_LO_K      006B
0097: ASCII_LO_P      0070
0038: ASCII_MASK      007F   0988
0089: ASCII_N         004E
0090: ASCII_Q         0051
0091: ASCII_R         0052
0092: ASCII_W         0057
0093: ASCII_Y         0059
0073: ASCII_ZERO      0030
0067: ASTERISK        002A
2485: AtEndOfDirectory EFBC   1676 1897 1928 1985 2376 2920 3221 3256 3265 3299 3319 3350
1137: BackUp          EA9F   1065 1133
1142: BackUp1         EAA7   1138
0295: bcBoot          F600
0298: bcConin         F609   0618 0803 0914 0932
0299: bcConout        F60C   0610 0876 1140 1144 1150 1152
0297: bcConst         F606   0615 0910
0303: bcHome          F618   2109
0300: bcList          F60F   0583 0882
0310: bcListst        F62D
0301: bcPunch         F612   0568
0308: bcRead          F627   2151
0302: bcReader        F615   0549
0311: bcSectran       F630
0304: bcSeldsk        F61B   1800
0307: bcSetdma        F624   2146
0306: bcSetsec        F621   2851
0305: bcSettrk        F61E   2115 2848
0296: bcWboot         F603   0469
0309: bcWrite         F62A   2464
0153: BDOSBase        E800   0154 0156 0327
0122: BDOSE           0005   0123
0154: BDOSEntry       E800
0143: BDOSLength      0E00   0146 0156 0157
3829: bdosStack       F5E5   0343
0333: BdosStart       E800
0056: BELL            0007
0156: BIOSBase        F600
0144: BIOSLength      0A00   0146
0116: BIOSPAGE        0002
0157: BIOSStart       F600   0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 0311 3838
3126: BlockOK         F28B   3120
0253: BlockSize       0800   0275
1060: BSspaceBS       EA48   0999
0034: BYTE            0001   1173
3810: byteAllocationFlag F596   1833 1998 2562 3132 3505
3778: caAllocVector   F57B   1371 1853 1855 1880 2277 2615 2682
3777: caCheckSum      F579   2879
3775: caDirectoryDMA  F575   1820 2138 2500 2871 3431
3771: caDirMaxValue   F56F   1811 1887 2168 2535
3776: caDiskParamBlock F577   1433 1825
3780: caListSize      0008   1821
3779: caListSizeEnd   F57D   3780
3774: caListSizeStart F575   3780
0094: CARET           005E   0842
0836: CaretOut        E948   1034 1115
3773: caSector        F573   1817 2123 2840
3801: caSkewTable     F58C   1809
3772: caTrack         F571   1814 2119 2831
0151: CCPEntry        E000   0153 0157
0142: CCPLength       0800   0146 0153 0157
0928: CheckCTL_S      E9AC   0917
2414: CheckExtents    EF76   2408
3008: CheckRODirectory F1E5   3302 3353
3013: CheckROFile     F1E8   3083
2859: CheckSumUtility F13C   2448 2803
3022: CheckWrite      F1F2   3081 3287 3312 3345
1973: CloseDirEntry   ED86   1287 1597 3219
2054: CloseDirEntryEnd EDF5   2044
2062: CloseDirEntryError EE01   2014 2024 2029
0074: COLON           003A
1171: columnPosition  EAC1   0861 0886 0951 0971 1129
0069: COMMA           002C
2338: CompareExtents  EF0F   2415
2869: ComputeCheckSum F148
2873: ComputeCheckSum1 F14F   2876
0128: ComTail         0080   0129
0130: ComTailChars    0082
0129: ComTailCount    0081   0130
0905: ConBreak        E98C   0729 0872
0938: ConBreak0       E9BA   0930
0940: ConBreak1       E9BD   0908
0796: ConIn           E921   0501 0987 3701
0869: ConsoleOut      E96B   0843 0855 0860 0948 0956 0963 0965 1057
3444: CopyDir         F430   2924 3305 3441
3430: CopyDirEntryToUser F41D   2950 2960
1931: CopyDirRecordToFCB ED4C   3271
3438: CopyFCB         F429   3339
0230: cpmRecordSize   0080   0232 0235 0237 2870 3434 3726
0059: CR              000D   0809 0962 0992 1056
0042: CTRL_C          0003   0933 1039 3670
0043: CTRL_E          0005   1004
0044: CTRL_H          0008   0815 0998 1143
0045: CTRL_K          000B
0046: CTRL_L          000C
0047: CTRL_P          0010   0916 1007
0048: CTRL_R          0012   1016
0049: CTRL_S          0013   0929
0050: CTRL_U          0015   1013
0051: CTRL_X          0018   1010
0052: CTRL_Z          001A
3753: currentDisk     F567   1208 1332 1768 1779 1785 1798 2075 2161 2179 2205 3694
3816: currentFileRecord F59C   2231 2907 3040 3050 3085 3170 3207 3404 3463
3749: currentUserNumber F566   0780 0786 1905 2214
0070: DASH            002D
0264: DataBlocks      02C7   0274
0263: DataSectors     0B1C   0264
3344: DeleteFile      F3C2   2967
3348: DeleteFile1     F3CA   3360
1124: DeleteTheLine   EA8E   1011
1127: DeleteTheLine1  EA8F   1134
3531: DEminusHL2HL    F483
3820: dirBlockIndex   F5A0   2501 2795
0235: DirBuffSize     0080
0250: DirectoryBlockCount 0002   0275
0237: DirectoryEntryPerRecord 0004   0278
3804: directoryFlag   F590   2365 2429 3415
3726: dirEntriesPerRecord 0004   3728
3821: dirEntryIndex   F5A1   2425 2476 2486 2533 2778 2780 2789 2808
3728: dirEntryMask    0003   2426 2790
3727: dirEntryShift   0002   2809
0234: DirEntrySize    0020   0237 0275
3414: DirLocationToReturnLoc F410   1762 2968 3002
3822: dirRecord       F5A3   2812 2861 2880
0222: DiskCommandBlock 0046
0221: DiskControlByte 0045
0224: DiskControlTable 0040
3067: DiskEOF         F239   3047 3054 3060
0418: diskf           000B
3806: diskMapIndex    F592   3103 3134
3035: DiskRead        F1FE   1526
0226: DiskReadCode    0001
0231: diskSectorSize  0200   0232 0253 0261
0220: DiskStatusLocation 0043
3077: DiskWrite       F241   1533
3092: DiskWrite1      F25E   3087
3151: DiskWrite2      F2AF   3139
3157: DiskWrite3      F2B4   3096
3178: DiskWrite4      F2D4   3173
3189: DiskWrite5      F2E1   3182
3208: DiskWrite6      F2FF   3204
3210: DiskWrite7      F301   3192 3196
0227: DiskWriteCode   0002
3072: DiskWriteSeq    F23C   2983
3691: displayAndWait  F522   3669 3687
2714: DivideHLby8     F098   1848 2601 2604
0133: DMABuffer       0080   1210 3763
0063: DOLLAR          0024   0824 1911
0276: dpb3hdAL0       00C0
0277: dpb3hdAL1       0000
0272: dpb3hdBLM       000F
0271: dpb3hdBSH       0004
0278: dpb3hdCKS       0020
0275: dpb3hdDRM       007F   0278
0274: dpb3hdDSM       02C6
0273: dpb3hdEXM       0000
0280: dpb3hdNOH       0002
0279: dpb3hdOFF       0001
0270: dpb3hdSPT       0090
3788: dpbBLM          F580   3402
3787: dpbBSH          F57F   3394 3461
3793: dpbCKS          F588   2860
3792: dpbDABM         F586   1878
3791: dpbDRM          F584   2166 2777
3790: dpbDSM          F582   1831 1847 1863 2600
3795: dpbEnd          F58C   3796
3789: dpbEXM          F581   2236 2341 3233
3794: dpbOFF          F58A   2111 2844
3796: dpbSize         000F   1827
3786: dpbSPT          F57D   2819
3785: dpbStart        F57D   1826 3796
0450: DUMMY           E8A9   0445 0446
3705: emDisk          F547   3696
3704: emDisk0         F53B   3697
3706: emPermanent     F54B   3665 3668
3739: emptyDir        00E5   1901 2382 3355 3760
3760: emptyFCB        F568   3315
3709: emReadOnlyDisk  F562   3679
3708: emReadOnlyFile  F55D   3683
3707: emSelection     F556   3675
0137: END_OF_FILE     001A
0040: EndOfMessage    0000
1050: EndRead         EA3E   0993 0996
3812: entryDisk       F598   0391 2206
0292: EOD             FFFF   2475
0078: EQUAL_SIGN      003D
3667: erPermanent     F501   3659
3664: erPermanentNoWait F4FB   2153 2466
3678: erReadOnlyDisk  F513   3661
3682: erReadOnlyFile  F519   3662
3647: errPermanent    F4E8
3641: errReadOnlyDisk F4DC   3025
3644: errReadOnlyFile F4E2   3019
3638: errSelect       F4D6   1778
3674: erSelection     F50D   3660
3659: evPermanent     F4F3   3648
3661: evReadOnlyDisk  F4F7   3642
3662: evReadOnlyFile  F4F9   3645
3660: evSelection     F4F5   3639
0061: EXCLAIM_POINT   0021
1175: exitParameterByte EAC5   0510 0619 0730 0756 0781 1333 1601 1611 1622 1629 1642 1915 1975 2063 2427 2441 3052 3123 3158 3201 3275 3416 3425
1176: exitParameterWord EAC5   0347 0398 0550 0639 1310 1372 1418 1434
3815: extentValue     F59B   2238 3475
0029: FALSE           0000   0923 1095 1531 1837 2374 3078 3356
0125: FCB1            005C   0126
0126: FCB2            006C
3802: fcbCopiedFlag   F58E   2056 3218 3236
3722: fcbCurrentRecord 0021
3813: fcbDisk         F599   0349 0386 2208
3720: fcbDiskMapIndex 0010   1990 1995 2552 2554 3130 3294 3303 3502
3716: fcbExtIndex     000C   1580 1604 1663 1715 1946 2038 2047 2257 2406 2917 2923 3224 3244 3289 3304 3346
0015: fcbExtIndexLSB  000C
0016: fcbExtIndexMSB  000E
3715: fcbHiddenfileIndex 000A
3713: fcbLength       0020   1940 1995 2038 2554 3327 3440 3726 3740
3719: fcbRCIndex      000F   1680 1949 1967 2047 2246 2249
3814: fcbRecordCount  F59A   2234 2911 3041 3171
3714: fcbROfileIndex  0009   3014
3717: fcbS1Index      000D   2403 3334
3718: fcbS2Index      000E   1586 1607 1732 2311 3244
3729: fcbShift        0005   2791
0170: fCloseFile      0010
0161: fConsoleIn      0001
0162: fConsoleOut     0002
0173: fDeleteFile     0013
0165: fGetConsoleStatus 000B
0179: fGetCurrentDisk 0019
0178: fGetLoginVector 0018
0181: fGetSetUserNumber 0020
0166: fGetVersion     000C
3114: FirstBlock      F27D   3106
0176: fMakeFile       0016
0169: fOpenFile       000F
2661: FoundFreeOctet  F066   2631 2636 2645 2653
2667: FoundFreeOctet1 F06C   2663
2669: FoundFreeOctet2 F06D   2665
2671: FoundFreeOctet3 F070   2674
2677: FoundFreeOctet4 F078   2679
0163: fPrintString    0009
0174: fReadSeq        0014
0164: fReadString     000A
0177: fRenameFile     0017
3811: fResel          F597   0350 0380 2196
0167: fResetSystem    000D
0171: fSearchFirst    0011
0172: fSearchNext     0012
0168: fSelectDisk     000E
0180: fSetDMA         001A
0448: functionCount   0028   0359
0405: functionTable   E857   0364 0418 0448
0175: fWriteSeq       0015
3376: GetBlockNumber  F3E4   3058 3093
2597: GetClosestBlock F015   3116
2498: GetCurrentDirectoryRecord EFC5   1679 1900 1936 1989 2392 2551 3009 3354 3450
3511: GetDiskMap16Bit F478   3507
3460: GetDiskMapIndex F445   3102 3377
3464: GetDiskMapIndex1 F44C   3468
3476: GetDiskMapIndex2 F45A   3483
3486: GetDiskMapIndex3 F463   3480
3500: GetDiskMapValue F465   3110 3380
2255: GetExtentAddress EEC4   1932 2235
2309: GetExtentNumberMSB EEF8   1636 2300 3184
2244: GetFcbRecordDetails EEB7   2228 2904
1662: GetFileSize     EBEE   1497
1675: GetFileSize1    EC00   1703
1701: GetFileSize2    EC22   1694
1704: GetFileSizeExit EC28   1677
2373: GetNextDirectoryRecord EF35   1702 2411 2416 2925 2959 3307 3359
2391: GetNextDirectoryRecord1 EF52   2383
1709: GetRandomRecordPosition EC2A   1651 1681
2308: GetWriteProtectValue EEF8   1979 2320 2329
3651: GoToError       F4EE   3640 3643 3646 3649 3666
0079: GREATER_THAN    003E
0062: HASH_TAG        0023   0947
3724: highestRecordNumber 007F   3086 3191
2108: Home            EE20   1886 2371
1147: IgnoreTheLine   EAAC   1014
3763: initDAMAddress  F56D   1211 1354 2132 3433
1846: InitDisk        ECD3   1791
1893: InitDisk1       ED18   1903 1921
1916: InitDisk2       ED39   1907 1912
2299: InitializeExtentNumberMSB EEF2   1254 2945 2991
0117: IOBYTE          0003   0638 0658
3385: IsAllocated     F3F1   3059 3094
3581: IsBitSet        F4A8   1782 2181 3603 3615
3588: IsBitSet1       F4AF   3586
3583: IsBitSetLoop    F4A9   3591
2177: IsDiskWriteProtected EE68   1976 3023
1012: IsItDeleteTheLineU EA19
1009: IsItDeleteTheLineX EA14
1006: IsItPrintToggle EA0F
1096: IsItPrintToggle1 EA70   1094
1000: IsItRubout      EA05
1003: IsPhysicalEOL   EA0A
0808: IsPrintableASCII E92C   0502 0838
1081: ItIsPhysicalEOL EA5D   1005
1088: ItIsPrintToggle EA65   1008
1069: ItIsRubout      EA52   1002
1165: keyboardByte    EABE   0797 0906 0939
0065: L_PAREN         0028
2284: Left            EEE3   2286
0082: LEFT_ARROW      005F
0098: LEFT_CURLY      007B
0146: LengthInBytes   2000   0147 0151 0261
0147: LengthInK       0009
0077: LESS_THAN       003C
0058: LF              000A   0811 0892 0964 0994
1110: LL1             EA7E   1118
0032: LO_NIBBLE_MASK  000F   0785 1728
3762: loggedDisks     F56B   1206 1309 1781 1787 1789
2629: LookRight       F03A   2639
3311: MakeNewFile     F38C   1620 2993 3263
3329: MakeNewFile1    F3AE   3333
1876: Mark4Directory  ED00   1868
3734: maxExtValue     001F   2350 3228
0149: MemorySize      0040   0151
2742: Merge           F0AC   2018 2020
1997: MergeAllocationMaps EDAB   2035
2012: MergeDirEntryNot0 EDBF   2009
2007: MergeFCBisNot0  EDB9   2005
2031: MergeMapLoop    EDDB   2015
2017: MergeWordMaps   EDC6   2000
3735: moduleMask      000F   3249
3563: MoveX           F49E   3435 3452
3565: MoveX0          F49F   3572
2726: MultiplyHLby8   F0A2   1862 2685
0262: myOffset        0001   0263 0279
3737: nameLength      000F   1926 1983 2947 3254 3325 3327
3740: NEXT_RECORD     0020   1575 1650 2249 3741
2438: NoDirRecordsMatch EF94   2377 2389
2657: NoFreeBlocks    F062   2646 2654
2641: NoMoreLeft      F04C   2637
2643: NoMoreLeftLoop  F04D   2647
2649: NoMoreRight     F057   2632
2651: NoMoreRightLoop F058   2655
2213: NoSelect        EE97   2203
0935: NothingWaiting  E9B8   0926
0054: NULL            0000
0246: NumberOfHeads   0002   0257 0259 0270 0280
0243: NumberOfLogicalDisks 0004
0031: OFF             0000
0030: ON              FFFF
1925: OpenFile        ED43   1256 1610
3216: OpenNextExt     F304   3048 3199
3253: OpenNextExt1    F338   3238
3270: OpenNextExt2    F356   3240 3257
3272: OpenNextExt3    F359   3267
3279: OpenNextExtError F361   3250 3261 3266
3243: OpenNextModule  F32D   3230
1965: OpenSetRecordCount ED7D   1961 1963
1174: paramDE         EAC3   0338 0384 0681 0973 1052 1107 1353 1544 1649 1666 1939 1966 1993 2197 2215 2245 2256 2310 2368 2940 2957 3082 3129 3223 3292 3313 3316 3321 3447 3501
1173: paramE          EAC2   0340 0392 0777 1767 2201
0064: PERCENT         0025
0071: PERIOD          002E
0120: Pg0CurentDisk   0004
0119: Pg0CurentUser   0004   0120
0068: PLUS_SIGN       002B
0822: Print           E93B   0684 0831 3698 3700
1167: printEchoFlag   EABF   0880 0919 1091
0080: QMARK           003F   2399 2942
2948: QMarkSelect     F1A7   2943
0066: R_PAREN         0029
0113: RAM             0000   0115 0116 0117 0119 0122 0125 0128 0133 0135
3741: RANDOM_REC_FIELD 0021   1546 1652 1667
1523: RandomDiskRead  EB38   1478
1530: RandomDiskWrite EB41   1490
1540: RandomSeek      EB4A   1525 1532
1594: RandomSeekClose EB8E   1584
1639: RandomSeekError EBD3   1573
1632: RandomSeekErrorBadSeek EBCC   1603 1619 1624
1626: RandomSeekExit  EBC6   1593 1613
2150: ReadBuffer      EE48   2767 3064
2776: ReadDirectory   F0C3   1896 2375
2788: ReadDirectory0  F0D7   2783
2792: ReadDirectory1  F0DE   2794
2765: ReadDirRecord   F0BA   2801
1030: ReadEchoRubOut  EA26   1078
3803: readModeFlag    F58F   3037 3079 3259
0983: ReadNext        E9ED   1047 1073 1099 1121
0986: ReadNext0       E9EF   1066 1085
3761: readOnlyVector  F569   1205 1417 2159 2164 2178
3029: ReadSeq         F1F9   2975
0970: ReadString      E9E0   0714 1131 1153
3631: ReAlignMap1     F4CF   3629
3626: ReAlignMapLoop  F4C9   3634
3624: ReAlignVector   F4C8   3607
3057: RecordOK        F223   3044
0255: RecordsPerBlock 0010
0239: RecordsPerExtent 0080   1964 3046 3724
0232: recordsPerSector 0004   0255 0270
3286: Rename          F367   3001
3298: Rename1         F378   3308
1102: RepeatLine      EA75   1017
2194: ReselectDisk    EE73   1255 1286 1477 1489 1496 1760 2946 2958 2966 2974 2982 2992 3000
2328: ResetFileWriteFlag EF08   3153
3613: ResetVectorBit  F4C1
0379: ReturnToCaller  E832   0353
0395: ReturnToCaller1 E84D   0382 0388 0617
2292: Right           EEED   2290 2294
2094: RotateAndReplace EE19   2097
2700: RotateRightHLbyB F08B   2708
2705: RotateRightHLbyB1 F091   2703
0083: RUBOUT          007F   1001
2549: ScanDiskMap     EFE9   1919 3357
2556: ScanDiskMap0    EFF3   2588
2581: ScanDiskMap2    F00A   2570
2572: ScanDiskMapWord F004   2564
3808: searchAddress   F594   2369 2379 2956
2363: SearchForDirectoryRecord EF20   1664 1927 1984 2918 2949 3255 3290 3318 3347
3807: searchLength    F593   2366 2393
0284: SectorMask      0003
0249: SectorsPerBlock 0004   0253 0255 0258 0264 0284
0259: SectorsPerCylinder 0024   0262 0263
0248: SectorsPerTrack 0012   0257 0259 0270
2816: Seek            F102   2813 3063 3164
2821: Seek0           F10C   2825
3454: SeekAndCopy     F43F
2807: SeekDir         F0F1   2058 2800 3455
1776: Select          EC6C   1213 1772
1766: SelectCurrent   EC60   0393 1237 2211
1797: SelectDisk      EC8D   1777
1840: SelectDisk1     ECCF   1836
0076: SEMICOLON       003B
3805: seqReadFlag     F591   1542 2905 3031 3074 3194
3393: SetActualRecordAdd F3F7   3062 3163
3397: SetActualRecordAdd1 F3FD   3400
2916: SetAttributes   F17E   1761
2919: SetAttributes1  F183   2926
1871: SetBitLoop      ECFB   1874
2073: SetCurrentDiskBit EE06
2131: SetDataDMA      EE3A   1212 1355 2453 2768
2137: SetDirDMA       EE3F   2450 2766
2512: SetDirectoryEntry EFD3   1920 3337
2158: SetDiskReadOnly EE50   1399 2891
2142: SetDMA          EE42   2133
2474: SetEndDirectory EFB5   1891 2370 2439 2784
2319: SetFileWriteFlag EF01   1644 1944 3281 3341
3423: SetLowReturnTo1 F417   3068 3088 3280
2895: SetNewCheckSum  F16A   2884
2418: SetNextPosition EF7C   2400 2404 2412
1648: SetRandomRecord EBDB   1503
2227: SetRecordVars   EEA0   3039 3084 3273
2266: SetResetMapBit  EECC   2584
0784: SetUserNumber   E91B   0779
3601: SetVectorBit    F4B8   1788 2163
2729: ShiftLeftHLbyB  F0A4   2733
3554: ShiftLeftHLbyC  F497   2078
3556: ShiftLeftHLbyC0 F498   3560
2717: ShiftRightHLbyB F09A   2276 2721 2810
3540: ShiftRightHLbyC F48A
3542: ShiftRightHLbyC0 F48B   3552
0961: showCRLF        E9D6   0949 1084 3693
0946: showHashCRLF    E9C0   1105 1148
0950: showHashCRLF1   E9C8   0957
0072: SLASH           002F
0055: SOH             0001
0060: SPACE           0020   0817 0859 0889 0955 1139 1149 1151
0291: STACK_SIZE      0020   3828
3828: stackBottom     F5A5
1170: startingColumn  EAC0   0952 0972 1128
2532: StillInDirectory EFDC   2387 2513 2889
0261: SystemSectors   0011   0262
0057: TAB             0009   0813 0854
0852: TabOut          E958   0507 0529 0829 0839
0858: TabOut0         E95E   0863
2397: TestNextPosition EF5B   2423
0924: ToggleFlag1     E9A9   0922
0123: TopRAM          0007
0258: TotalNumberOfBlocks 02D0
0257: TotalNumberOfSectors 0B40   0258 0263
0135: TPA             0100
0247: TracksPerHead   0050   0257
0028: TRUE            FFFF   0920 0941 1092 1524 1834 1841 1895 1918 2055 2195 2447 3036
0081: UNDER_SCORE     005F
2903: UpdateRecordVars F16C   3065 3198 3211
1163: usersStack      EABC   0342 0396
1285: vCloseFile      EAEC   0423
1495: vComputeFileSize EB2E   0442
0500: vConsoleIn      E8AD   0407
0528: vConsoleOut     E8BE   0408
2965: vDeleteFile     F1BC   0426
0605: vDirectConIO    E8D1   0412
0614: vDirectConIO1   E8D9   0608
0290: VERSION         0020   0755
2938: vFindFirst      F194   0424
2955: vFindNext       F1AD   0425
1370: vGetAllocAddr   EB09   0434
0728: vGetConsoleStatus E900   0417
1331: vGetCurrentDisk EAF9   0432
1432: vGetDiskParamBlock EB1A   0438
0637: vGetIOBYTE      E8E7   0413
1308: vGetLoginVector EAF2   0431
1416: vGetReadOnlyMap EB13   0436
0776: vGetSetUserNumber E90D   0439
0754: vGetVersion     E907   0419
0582: vListOut        E8CD   0411
2990: vMakeFile       F1D3   0429
1253: vOpenFile       EAE3   0422
0680: vPrintString    E8F3   0415
0567: vPunchOut       E8C9   0410
0548: vReaderIn       E8C2   0409
1476: vReadRandom     EB22   0440
2973: vReadSeq        F1C5   0427
0713: vReadString     E8FC   0416
2999: vRenameFile     F1DC   0430
1460: vResetDrive     EB21   0444
1203: vResetSystem    EAC7   0420
1236: vSelectDisk     EAE0   0421
1352: vSetDMA         EB00   0433
1759: vSetFileAttributes EC57   0437
0657: vSetIOBYTE      E8EE   0414
1502: vSetRandomRecord EB34   0443
0468: vSystemReset    E8AA   0406
1398: vWriteProtectDisk EB10   0435
1488: vWriteRandom    EB28   0441
1516: vWriteRandom0Fill EB37   0447
2981: vWriteSeq       F1CC   0428
3686: waitB4boot      F51C   3676 3680
0115: WarmBoot        0000   0934 1043 3671 3688
0035: WORD            0002   1174 1176
0195: WriteAllocated  0000   3095
2463: WriteBuffer     EFAD   2452 3167
0197: WriteCleanBuffer 0002   3152
2445: WriteDir        EF9D   2059 3358 3456
0196: WriteDirectory  0001   2451
3736: writeFlagMask   0080   1980 2321 2330
3837: Z_HighestLocation F5E5   3838
3838: Z_MemoryLeft    001A
0039: ZERO            0000
