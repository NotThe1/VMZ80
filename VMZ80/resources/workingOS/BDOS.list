0001: E800         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: E800         ; BDOS.Z80
0004: E800         ;  in process Clean up
0005: E800
0006: E800         ; 2019-02-04 Fixed bdosStack problem
0007: E800         ; 2019-01-10	Last rev before remaking  FInd nearest Block
0008: E800         ; 2019-01-11 - BDOS 0.B  - Function 0-A Refactored to Z80 idiom
0009: E800         ; 2018-12-28 Started to refactor to Z80 idiom
0010: E800         ; 2018-03-31 added vector for BDOS Call 5 -ListOut
0011: E800         ; 2018-03-02 Refactored the CP/M Suite
0012: E800         ; 2018-02-12 fixed allocate 16 bit problem
0013: E800         ; 2014-01-16 extended from part of newOS (newBDOS)
0014: E800         ; 2014-03-14  :  Frank Martyn
0015: E800             fcbExtIndexLSB EQU    0CH                  ; 12
0016: E800             fcbExtIndexMSB EQU    0EH                  ; 14   Bit 7 = Write protected
0017: E800
0018: E800                        Include ./stdHeader.Z80
0019: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0020: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0021: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0022: E800         ; stdHeader.asm
0023: E800         ; standard equates
0024: E800
0025: E800         ; 2017-03-02 Refactored the CP/M Suite
0026: E800
0027: E800
0028: E800             TRUE       EQU    -1                   ; not false
0029: E800             FALSE      EQU    0000H
0030: E800             ON         EQU    -1
0031: E800             OFF        EQU    0000H
0032: E800             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0033: E800
0034: E800             BYTE       EQU    1                    ; number of bytes for "byte" type
0035: E800             WORD       EQU    2                    ; number of bytes for "word" type
0036: E800
0037: E800
0038: E800             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0039: E800             ZERO       EQU    00H                  ; Zero
0040: E800             EndOfMessage EQU    00H
0041: E800
0042: E800             CTRL_C     EQU    03H                  ; ETX
0043: E800             CTRL_E     EQU    05H                  ; physical eol
0044: E800             CTRL_H     EQU    08H                  ; backspace
0045: E800             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0046: E800             CTRL_L     EQU    0CH                  ; FF - Form feed
0047: E800             CTRL_P     EQU    10H                  ; prnt toggle
0048: E800             CTRL_R     EQU    12H                  ; repeat line
0049: E800             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0050: E800             CTRL_U     EQU    15H                  ; line delete
0051: E800             CTRL_X     EQU    18H                  ; =ctl-u
0052: E800             CTRL_Z     EQU    1AH                  ; end of file
0053: E800
0054: E800             NULL       EQU    00H                  ; Null
0055: E800             SOH        EQU    01H                  ; Start of Heading
0056: E800             BELL       EQU    07H                  ; Bell
0057: E800             TAB        EQU    09H                  ; Tab
0058: E800             LF         EQU    0AH                  ; Line Feed
0059: E800             CR         EQU    0DH                  ; Carriage Return
0060: E800             SPACE      EQU    20H                  ; Space
0061: E800             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0062: E800             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: E800             DOLLAR     EQU    24H                  ; Dollar Sign
0064: E800             PERCENT    EQU    25H                  ; Percent Sign
0065: E800             L_PAREN    EQU    28H                  ; Left Paenthesis (
0066: E800             R_PAREN    EQU    29H                  ; Right Paenthesis )
0067: E800             ASTERISK   EQU    2AH                  ; Asterisk *
0068: E800             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0069: E800             COMMA      EQU    2CH                  ; Comma
0070: E800             DASH       EQU    2DH                  ; Dash Hyphen -
0071: E800             PERIOD     EQU    2EH                  ; Period
0072: E800             SLASH      EQU    2FH                  ; /
0073: E800             ASCII_ZERO EQU    30H                  ; zero
0074: E800             COLON      EQU    3AH                  ; Colon
0075: E800
0076: E800             SEMICOLON  EQU    3BH                  ; Semi Colon
0077: E800             LESS_THAN  EQU    3CH                  ; Less Than <
0078: E800             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0079: E800             GREATER_THAN EQU    3EH                  ; Greater Than >
0080: E800             QMARK      EQU    3FH                  ; Question Mark
0081: E800             UNDER_SCORE EQU    5FH                  ; under score _
0082: E800             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0083: E800             RUBOUT     EQU    7FH                  ; Delete Key
0084: E800
0085: E800
0086: E800             ASCII_A    EQU    'A'
0087: E800             ASCII_C    EQU    'C'
0088: E800             ASCII_K    EQU    'K'
0089: E800             ASCII_N    EQU    'N'
0090: E800             ASCII_Q    EQU    'Q'
0091: E800             ASCII_R    EQU    'R'
0092: E800             ASCII_W    EQU    'W'
0093: E800             ASCII_Y    EQU    'Y'
0094: E800             CARET      EQU    '^'
0095: E800             ASCII_LO_A EQU    'a'
0096: E800             ASCII_LO_K EQU    'k'
0097: E800             ASCII_LO_P EQU    'p'
0098: E800             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0099: E800
0100: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0101: E800                        Include ./osHeader.Z80
0102: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0103: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0104: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0105: E800         ; osHeader.Z80
0106: E800
0107: E800         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0108: E800         ; 2017-03-02 Refactored the CP/M Suite
0109: E800
0110: E800         ; Contains the Equates used by the CP/M system
0111: E800
0112: E800         ;------------------------Page Zero Constants ---------------------------------
0113: E800             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0114: E800
0115: E800             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0116: E800             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0117: E800             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0118: E800
0119: E800             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0120: E800             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0121: E800
0122: E800             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0123: E800             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0124: E800
0125: E800             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0126: E800             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0127: E800
0128: E800             ComTail    EQU    RAM + 080H           ; Complete command tail
0129: E800             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0130: E800             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0131: E800         ;-----------------------------------------------------------------------
0132: E800
0133: E800             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0134: E800         ;-----------------------------------------------------------------------
0135: E800             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0136: E800         ;-----------------------------------------------------------------------
0137: E800             END_OF_FILE EQU    1AH                  ; end of file
0138: E800         ;-----------------------------------------------------------------------
0139: E800
0140: E800         ;--------------- CP/M Constants -----------------------------------------
0141: E800
0142: E800             CCPLength  EQU    0800H                ; Constant
0143: E800             BDOSLength EQU    0E00H                ; Constant 0E00H
0144: E800             BIOSLength EQU    0A00H                ; Constant 0900H
0145: E800
0146: E800             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0147: E800             LengthInK  EQU    (LengthInBytes/1024) + 1
0148: E800
0149: E800             MemorySize EQU    64
0150: E800
0151: E800             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0152: E800
0153: E800             BDOSBase   EQU    CCPEntry + CCPLength
0154: E800             BDOSEntry  EQU    BDOSBase
0155: E800
0156: E800             BIOSBase   EQU    BDOSBase + BDOSLength
0157: E800             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0158: E800         ;-----------------------------------------------------------------------
0159: E800
0160: E800         ;------------------- BDOS System Call Equates --------------------------
0161: E800             fConsoleIn EQU    01H                  ; rcharf - Console Input
0162: E800             fConsoleOut EQU    02H                  ; pcharf - Console Output
0163: E800             fPrintString EQU    09H                  ; pbuff	- Print String
0164: E800             fReadString EQU    0AH                  ; rbuff	- Read Console String
0165: E800             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0166: E800             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0167: E800             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0168: E800             fSelectDisk EQU    0EH                  ; self	- Select Disk
0169: E800             fOpenFile  EQU    0FH                  ; openf	- Open File
0170: E800             fCloseFile EQU    10H                  ; closef - Close File
0171: E800             fSearchFirst EQU    11H                  ; searf	- Search For First
0172: E800             fSearchNext EQU    12H                  ; searnf - Search for Next
0173: E800             fDeleteFile EQU    13H                  ; delf - Delete File
0174: E800             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0175: E800             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0176: E800             fMakeFile  EQU    16H                  ; makef	- Make File
0177: E800             fRenameFile EQU    17H                  ; renf	- Rename File
0178: E800             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0179: E800             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0180: E800             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0181: E800             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0182: E800         ;-----------------------------------------------------------------------
0183: E800
0184: E800
0185: E800
0186: E800
0187: E800
0188: E800         ;*******************************************************************************
0189: E800         ; These are the values handed over by the BDOS when it calls the Writer operation
0190: E800         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0191: E800         ; unallocated allocation block (it only indicates this for the first 128 byte
0192: E800         ; sector write) or to an allocation block that has already been allocated to a
0193: E800         ; file. The BDOS also indicates if it is set to write to the file directory
0194: E800         ;*******************************************************************************
0195: E800             WriteAllocated EQU    00H
0196: E800             WriteDirectory EQU    01H
0197: E800             WriteCleanBuffer EQU    02H
0198: E800
0199: E800
0200: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0201: E800                        Include ./diskHeader.Z80
0202: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0203: E800         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0204: E800         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0205: E800         ; diskHeader.asm
0206: E800
0207: E800         ; 2017-03-02 Refactored the CP/M Suite
0208: E800
0209: E800         ; needs osHeader.asm declared before this is used !!!!!!!
0210: E800
0211: E800         ; Contains the Equates used by the CP/M system to handle disks
0212: E800
0213: E800
0214: E800         ;*******************************************************************************
0215: E800         ;
0216: E800         ;     Disk related values
0217: E800         ;
0218: E800         ;
0219: E800         ;*******************************************************************************
0220: E800             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0221: E800             DiskControlByte EQU    045H                 ; control byte for disk I/O
0222: E800             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0223: E800         ; for boot
0224: E800             DiskControlTable EQU    0040H
0225: E800
0226: E800             DiskReadCode EQU    01H                  ; Code for Read
0227: E800             DiskWriteCode EQU    02H                  ; Code for Write
0228: E800
0229: E800
0230: E800             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0231: E800             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0232: E800             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0233: E800
0234: E800             DirEntrySize EQU    20H                  ; (32)
0235: E800             DirBuffSize EQU    cpmRecordSize
0236: E800
0237: E800             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0238: E800
0239: E800             RecordsPerExtent EQU    080H                 ; extent Record capacity
0240: E800
0241: E800
0242: E800         ;-------------------------------------------------------------------------------------
0243: E800             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0244: E800
0245: E800         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0246: E800             NumberOfHeads EQU    02H                  ; number of heads
0247: E800             TracksPerHead EQU    50H                  ; 80
0248: E800             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0249: E800             SectorsPerBlock EQU    04H                  ; 2048 bytes
0250: E800             DirectoryBlockCount EQU    02H                  ;
0251: E800         ;-----------------------------------------------------------------------
0252: E800
0253: E800             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0254: E800
0255: E800             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0256: E800
0257: E800             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0258: E800             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0259: E800             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0260: E800
0261: E800             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0262: E800             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0263: E800             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0264: E800             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0265: E800
0266: E800         ;-----------------------------------------------------------------------
0267: E800         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0268: E800         ;-----------------------------------------------------------------------
0269: E800         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0270: E800             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0271: E800             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0272: E800             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0273: E800             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0274: E800             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0275: E800             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0276: E800             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0277: E800             dpb3hdAL1  EQU    00H                  ;  for each file directory
0278: E800             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0279: E800             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0280: E800             dpb3hdNOH  EQU    NumberOfHeads
0281: E800
0282: E800         ;*******************************************************************************
0283: E800
0284: E800             SectorMask EQU    SectorsPerBlock - 1
0285: E800
0286: E800         ;***************************************************************************
0287: E800
0288: E800         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0289: E800
0290: E800             VERSION    EQU    20H                  ; Version 2.0
0291: E800             STACK_SIZE EQU    20H                  ; Make stack big enough
0292: E800             EOD        EQU    -1                   ; End of Directory
0293: E800
0294: E800         ;************************ BIOS Function Constants **************************;
0295: E800             bcBoot     EQU    BIOSStart+3*0        ; Cold Boot function	            ;
0296: E800             bcWboot    EQU    BIOSStart+3*1        ; Warm Boot function                ;
0297: E800             bcConst    EQU    BIOSStart+3*2        ; Console Status function           ;
0298: E800             bcConin    EQU    BIOSStart+3*3        ; Console Input function            ;
0299: E800             bcConout   EQU    BIOSStart+3*4        ; Console Output function           ;
0300: E800             bcList     EQU    BIOSStart+3*5        ; List Output function              ;
0301: E800             bcPunch    EQU    BIOSStart+3*6        ; Punch Output function             ;
0302: E800             bcReader   EQU    BIOSStart+3*7        ; Reader Input function             ;
0303: E800             bcHome     EQU    BIOSStart+3*8        ; Disk Home function                ;
0304: E800             bcSeldsk   EQU    BIOSStart+3*9        ; Select Disk function              ;
0305: E800             bcSettrk   EQU    BIOSStart+3*10       ; Set Track function                ;
0306: E800             bcSetsec   EQU    BIOSStart+3*11       ; Set Sector function               ;
0307: E800             bcSetdma   EQU    BIOSStart+3*12       ; Set DMA function                  ;
0308: E800             bcRead     EQU    BIOSStart+3*13       ; Read Disk function                ;
0309: E800             bcWrite    EQU    BIOSStart+3*14       ; Write Disk function               ;
0310: E800             bcListst   EQU    BIOSStart+3*15       ; List Status function              ;
0311: E800             bcSectran  EQU    BIOSStart+3*16       ; Sector Translate                  ;
0312: E800         ;************************ BIOS Function Constants **************************;
0313: E800         ;===========================================================================;
0314: E800         ;	BDOS                                                                    ;
0315: E800         ; Calling into   :                                                          ;
0316: E800         ;					Register  C - Contains BDOS Function Code               ;
0317: E800         ;					Register  A - Holds the Byte argument if any            ;
0318: E800         ;					Register DE - Holds the Word argument if any            ;
0319: E800         ; Returning from :                                                          ;
0320: E800         ;					Register  A - The Byte return value if any              ;
0321: E800         ;					Register HL - The Word return value if any              ;
0322: E800         ;                   ( Register A=L and B=H)                                 ;
0323: E800         ;===========================================================================;
0324: E800
0325: E800
0326: E800                        ORG    BDOSBase
0327: E800
0328: E800         ;===========================BDOS Entry======================================;
0329: E800         ;BDOSEntry:                                                                 ;
0330: E800         ;
0331: E800         ;
0332: E800             BdosStart:                      ;
0333: E800         ;	LD		A,C                                                             ;
0334: E800         ; 	LD		(FunctionValue),A			; Save the function number          ;
0335: E800         ;
0336: E800         ; Save Calling Arguments                                                    ;
0337: E800 ED 53 B4 EA               LD     (paramDE),DE         ; Save the Word Argument            ;
0338: E804 7B                     LD     A,E                  ;
0339: E805 32 B3 EA               LD     (paramE),A           ; Save the Byte argument            ;
0340: E808         ; Save users Stack pointer                                                  ;
0341: E808 ED 73 AD EA               LD     (usersStack),SP      ; Save the User's stack				;
0342: E80C 31 F8 F4               LD     SP,bdosStack         ; We will use our own stack			;
0343: E80F         ;
0344: E80F         ; initialize variables                                                      ;
0345: E80F 21 00 00               LD     HL,0000H             ;
0346: E812 22 B6 EA               LD     (exitParameterWord),HL ; Assume all is well for return     ;
0347: E815 AF                     XOR    A                    ;
0348: E816 32 AC F4               LD     (fcbDisk),A          ; Initialize to 00                  ;
0349: E819 32 AA F4               LD     (fResel),A           ; Clear re selection flag           ;
0350: E81C         ;
0351: E81C         ; Set up for return to caller when Function Completes                       ;
0352: E81C 21 32 E8               LD     HL,ReturnToCaller    ;
0353: E81F E5                     PUSH   HL                   ;Set up to ReturnToCaller           ;
0354: E820         ;
0355: E820         ; is it a valid function number ?	                                        ;
0356: E820         ;	LD		A,(FunctionValue)			; Get the Function Number           ;
0357: E820 79                     LD     A,C                  ;
0358: E821 FE 28                  CP     functionCount        ; make sure its a good number       ;
0359: E823 D0                     RET    NC                   ; exit if not a valid function      ;
0360: E824         ;
0361: E824         ; Calculate the index and get vector to go to	                            ;
0362: E824 4B                     LD     C,E                  ; Assume byte argument              ;
0363: E825 21 57 E8               LD     HL,functionTable     ; Get table base                    ;
0364: E828 5F                     LD     E,A                  ; Function number in E              ;
0365: E829 16 00                  LD     D,0                  ;
0366: E82B 19                     ADD    HL,DE                ; Have byte location                ;
0367: E82C 19                     ADD    HL,DE                ;  but we want a Word offset        ;
0368: E82D 5E                     LD     E,(HL)               ; Get LSB of vector                 ;
0369: E82E 23                     INC    HL                   ;
0370: E82F 56                     LD     D,(HL)               ; Get MSB of vector                 ;
0371: E830 EB                     EX     DE,HL                ; Vector now in HL                  ;
0372: E831         ;
0373: E831         ; Vector to Function is in HL                                               ;
0374: E831 E9                     JP     (HL)                 ; Put it into the Program Counter   ;
0375: E832         ;===========================BDOS Entry======================================;
0376: E832         ;===========================BDOS Exit ======================================;
0377: E832         ;arrive here at end of processing to return to user                         ;
0378: E832             ReturnToCaller:                      ;
0379: E832 3A AA F4               LD     A,(fResel)           ; get re-selection flag             ;
0380: E835 B7                     OR     A                    ; is it set?                        ;
0381: E836 28 15                  JR     Z,ReturnToCaller1    ;
0382: E838         ;re-selection  may have taken place                                        ;
0383: E838 2A B4 EA               LD     HL,(paramDE)         ;
0384: E83B 36 00                  LD     (HL),0               ;
0385: E83D 3A AC F4               LD     A,(fcbDisk)          ;
0386: E840 B7                     OR     A                    ; Disk = 0?                         ;
0387: E841 28 0A                  JR     Z,ReturnToCaller1    ; exit if yes                  		;
0388: E843         ;
0389: E843 77                     LD     (HL),A               ;
0390: E844 3A AB F4               LD     A,(entryDisk)        ; get back original Disk            ;
0391: E847 32 B3 EA               LD     (paramE),A           ; and select it                     ;
0392: E84A CD 16 ED               CALL   SelectCurrent        ;
0393: E84D         ;
0394: E84D             ReturnToCaller1:                      ;
0395: E84D 2A AD EA               LD     HL,(usersStack)      ;
0396: E850 F9                     LD     SP,HL                ; restore callers stack             ;
0397: E851 2A B6 EA               LD     HL,(exitParameterWord) ;
0398: E854 7D                     LD     A,L                  ;
0399: E855 44                     LD     B,H                  ; BA = exitParameterWord            ;
0400: E856 C9                     RET                         ;
0401: E857         ;===========================BDOS Exit ======================================;
0402: E857
0403: E857         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++;
0404: E857             functionTable:                      ;
0405: E857 AA E8                  DW     vSystemReset         ;   0 - System Reset                ;
0406: E859 AD E8                  DW     vConsoleIn           ;   1 - Console Input               ;
0407: E85B BE E8                  DW     vConsoleOut          ;   2 - Console Output              ;
0408: E85D C2 E8                  DW     vReaderIn            ;   3 - Reader Input                ;
0409: E85F C9 E8                  DW     vPunchOut            ;   4 - Punch Output                ;
0410: E861 CD E8                  DW     vListOut             ;   5 - List Output                 ;
0411: E863 D1 E8                  DW     vDirectConIO         ;   6 - Direct Console I/O          ;
0412: E865 E7 E8                  DW     vGetIOBYTE           ;   7 - Get I/O Byte                ;
0413: E867 EE E8                  DW     vSetIOBYTE           ;   8 - Set I/O Byte                ;
0414: E869 F3 E8                  DW     vPrintString         ;   9 - Print String                ;
0415: E86B FC E8                  DW     vReadString          ;   A - Read Console String         ;
0416: E86D 00 E9                  DW     vGetConsoleStatus    ;   B - Get Console Status          ;
0417: E86F             diskf      EQU    ($-functionTable)/2  ; disk functions                    ;
0418: E86F 07 E9                  DW     vGetVersion          ;   C - Return Version Number       ;
0419: E871 B8 EA                  DW     vResetSystem         ;   D - Reset Disk System           ;
0420: E873 D1 EA                  DW     vSelectDisk          ;   E - Select Disk                 ;
0421: E875 D4 EA                  DW     vOpenFile            ;   F - Open File                   ;
0422: E877 DD EA                  DW     vCloseFile           ;  10 - Close File                  ;
0423: E879 E3 EA                  DW     vFindFirst           ;  11 - Search For First            ;
0424: E87B FB EA                  DW     vFindNext            ;  12 - Search for Next             ;
0425: E87D 0A EB                  DW     vDeleteFile          ;  13 - Delete File                 ;
0426: E87F 31 EB                  DW     vReadSeq             ;  14 - Read Sequential             ;
0427: E881 74 EB                  DW     vWriteSeq            ;  15 - Write Sequential            ;
0428: E883 30 EC                  DW     vMakeFile            ;  16 - Make File                   ;
0429: E885 39 EC                  DW     vRenameFile          ;  17 - Rename File                 ;
0430: E887 62 EC                  DW     vGetLoginVector      ;  18 - Return Login Vector         ;
0431: E889 69 EC                  DW     vGetCurrentDisk      ;  19 - Return Current Disk         ;
0432: E88B 70 EC                  DW     vSetDMA              ;  1A - Set DMA address             ;
0433: E88D 79 EC                  DW     vGetAllocAddr        ;  1B - Get ADDR (ALLOC)            ;
0434: E88F 80 EC                  DW     vWriteProtectDisk    ;  1C - Write Protect Disk          ;
0435: E891 83 EC                  DW     vGetReadOnlyMap      ;  1D - Get Read/Only MAP	        ;
0436: E893 8A EC                  DW     vSetFileAttributes   ;  1E - Set File Attributes ??      ;
0437: E895 A4 EC                  DW     vGetDiskParamBlock   ;  1F - Get ADDR (Disk Parameters)  ;
0438: E897 0D E9                  DW     vGetSetUserNumber    ;  20 - Set/Get User Code           ;
0439: E899 AB EC                  DW     vReadRandom          ;  21 - Read Random                 ;
0440: E89B B7 EC                  DW     vWriteRandom         ;  22 - Write Random                ;
0441: E89D C3 EC                  DW     vComputeFileSize     ;  23 - Compute File Size           ;
0442: E89F FF EC                  DW     vSetRandomRecord     ;  24 - Set Random Record           ;
0443: E8A1 12 ED                  DW     vResetDrive          ;  25 - Reset Drive                 ;
0444: E8A3 A9 E8                  DW     DUMMY                ;  26 - Access Drive (not supported);
0445: E8A5 A9 E8                  DW     DUMMY                ;  27 - Free Drive (not supported)  ;
0446: E8A7 15 ED                  DW     vWriteRandom0Fill    ;  28 - Write random w/Fill         ;
0447: E8A9             functionCount EQU    ($-functionTable)/2  ; Number of  functions              ;
0448: E8A9         ;
0449: E8A9             DUMMY:                          ;
0450: E8A9 76                     HALT                        ;
0451: E8AA         ;++++++++++++++++++++++++++++ Function Vector Table ++++++++++++++++++++++++;
0452: E8AA
0453: E8AA         ;-------------------------- System Reset - 0 (0) ---------------------------;
0454: E8AA         ;  The system reset function makes CP/M do a complete reset, exactly the    ;
0455: E8AA         ; same as the warm boot function invoked when you transfer control to the   ;
0456: E8AA         ; WARMBOOT point. In addition to resetting the BDOS, this function reloads  ;
0457: E8AA         ; the CCP, rebuilds the allocation vectors for the currently logged disks,  ;
0458: E8AA         ; sets the DMA address (used byCP/M to address the disk read/write buffer)  ;
0459: E8AA         ; to 80H, marks all disks as being Read/Write status, and transfers control ;
0460: E8AA         ; to the  CCP. The CCP then outputs its prompt to the console.              ;
0461: E8AA         ;																			;
0462: E8AA         ;			Function Code	 :	C = 00H                                     ;
0463: E8AA         ;			Entry Parameters:	None                                        ;
0464: E8AA         ;			Exit Parameters :	Does Not Return								;
0465: E8AA         ;																			;
0466: E8AA         ;-------------------------- System Reset - 0 (0) ---------------------------;
0467: E8AA             vSystemReset:
0468: E8AA C3 03 F6               JP     bcWboot              ; do a Warm Boot
0469: E8AD
0470: E8AD         ;***************************************************************************;
0471: E8AD         ;								IOByte device I/O							;
0472: E8AD         ;***************************************************************************;
0473: E8AD
0474: E8AD
0475: E8AD         ;-------------------------- Read Console Byte - 1 (1) ----------------------;
0476: E8AD         ;  This function reads the next byte of data from the console keyboard and  ;
0477: E8AD         ; puts it into register A. If the character input is a graphic character, it;
0478: E8AD         ; will be echoed back to the console. The only control characters that are  ;
0479: E8AD         ; echoed are  CARRIAGE RETURN, LINE FEED, BACKSPACE, and TAB. In the case   ;
0480: E8AD         ; of a TAB character, the BDOS outputs as many spaces as are required to    ;
0481: E8AD         ; move the cursor to the next multiple of eight columns. All of the other   ;
0482: E8AD         ; control characters, including CONTROL-C, are input but are not echoed.    ;
0483: E8AD         ;  This function also checks for CONTROL-S (XOFF) to see if console output  ;
0484: E8AD         ; should be suspended, and for CONTROL-P (printer echo toggle) to see if    ;
0485: E8AD         ; console output should also be sent to the list device. If CONTROL-S is    ;
0486: E8AD         ; found, further output will be suspended until you type another character. ;
0487: E8AD         ; CONTROL-P will enable the echoing of console output the first time it is  ;
0488: E8AD         ; pressed and disable it the second time. If there is no incoming data      ;
0489: E8AD         ; character, this function will wait until there is one.                    ;
0490: E8AD         ;                                                                           ;
0491: E8AD         ; This is a blocking function                                               ;
0492: E8AD         ;																			;
0493: E8AD         ;																			;
0494: E8AD         ;			Function Code	:	C = 01H                                     ;
0495: E8AD         ;			Entry Parameters:	None                                        ;
0496: E8AD         ;			Exit Parameters :	A = Data byte from console					;
0497: E8AD         ;																			;
0498: E8AD         ;-------------------------- Read Console Byte - 1 (1) ----------------------;
0499: E8AD             vConsoleIn:
0500: E8AD CD 21 E9               CALL   ConIn                ; Don't come back without input
0501: E8B0 CD 2C E9               CALL   IsPrintableASCII     ; CR,LF,TAB,BACK_SPACE or GE SPACE
0502: E8B3 D8                     RET    C                    ; return nothing to echo
0503: E8B4
0504: E8B4 F5                     PUSH   AF                   ; Save printable character
0505: E8B5 4F                     LD     C,A
0506: E8B6 CD 58 E9               CALL   TabOut               ; Send to console. if TAB expand
0507: E8B9 F1                     POP    AF                   ; retrieve exit value
0508: E8BA
0509: E8BA 32 B6 EA               LD     (exitParameterByte),A
0510: E8BD C9                     RET
0511: E8BE
0512: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0513: E8BE         ;  This function outputs the data byte in register E to the console. As      ;
0514: E8BE         ; with function 1, if the data byte is a TAB character, it will be expanded  ;
0515: E8BE         ; by the BDOS to the next column that is a multiple of eight. The BDOS also  ;
0516: E8BE         ; checks to see if there is an incoming character, and if there is,          ;
0517: E8BE         ; checks to see if it is a CONTROL-S ,in which case console output is        ;
0518: E8BE         ; suspended or CONTROL-P, in which case echoing of console output to the     ;
0519: E8BE         ; printer is  toggled on or off                                              ;
0520: E8BE         ;																			 ;
0521: E8BE         ;			Function Code	:	C = 02H                                      ;
0522: E8BE         ;			Entry Parameters:	E = Data byte to be output					 ;
0523: E8BE         ;			Exit Parameters :	None										 ;
0524: E8BE         ;																			 ;
0525: E8BE         ;------------------------- Write Console Byte - 2 (2) -----------------------;
0526: E8BE         ;BDOS put parameter in C before entering this routine
0527: E8BE             vConsoleOut:
0528: E8BE CD 58 E9               CALL   TabOut
0529: E8C1 C9                     RET
0530: E8C2
0531: E8C2         ;--------------------------- Read Reader Byte - 3 (3) ----------------------;
0532: E8C2         ;   function reads the next character from the logical "reader" device into ;
0533: E8C2         ; register A. In practice, the physical device that is accessed depends     ;
0534: E8C2         ; entirely on how your BIOS is configured. In some systems, there is no     ;
0535: E8C2         ; reader at all; this function will return some arbitrary value such as lAH ;
0536: E8C2         ; (the ASCII CONTROL-Z character, used by CP/M to denote "End of File').    ;
0537: E8C2         ; Control is not returned to the calling program until a character has been ;
0538: E8C2         ; read.                                                                     ;
0539: E8C2         ;                                                                           ;
0540: E8C2         ; This is a blocking function                                               ;
0541: E8C2         ;																			;
0542: E8C2         ;			Function Code	:	C = 03H                                     ;
0543: E8C2         ;			Entry Parameters:	None										;
0544: E8C2         ;			Exit Parameters :	A = Character Input							;
0545: E8C2         ;																			;
0546: E8C2         ;--------------------------- Read Reader Byte - 3 (3) ----------------------;
0547: E8C2             vReaderIn:
0548: E8C2 CD 15 F6               CALL   bcReader
0549: E8C5 32 B6 EA               LD     (exitParameterWord),A
0550: E8C8 C9                     RET
0551: E8C9
0552: E8C9         ;--------------------------- Write Punch Byte - 4 (4) ----------------------;
0553: E8C9         ;  This function is a counterpart to the Read "Reader" Byte It outputs the  ;
0554: E8C9         ; specified character from register E to the logical punch device. Again,   ;
0555: E8C9         ; the actual physical device used, if any, is determined by the BIOS.       ;
0556: E8C9         ; There is no set standard for this device; in some systems the punch       ;
0557: E8C9         ; device is a "bit bucket," so called because it absorbs all data that you  ;
0558: E8C9         ; output to it.                                                             ;
0559: E8C9         ;																			;
0560: E8C9         ;			Function Code	:	C = 04H                                     ;
0561: E8C9         ;			Entry Parameters:	E = Data byte to be output					;
0562: E8C9         ;			Exit Parameters :	None										;
0563: E8C9         ;																			;
0564: E8C9         ;--------------------------- Write Punch Byte - 4 (4) ----------------------;
0565: E8C9         ;BDOS put parameter in C before entering this routine
0566: E8C9             vPunchOut:
0567: E8C9 CD 12 F6               CALL   bcPunch
0568: E8CC C9                     RET
0569: E8CD
0570: E8CD         ;---------------------------- Write List Byte - 5 (5) ----------------------;
0571: E8CD         ;  This function outputs the specified byte in register E to the logical    ;
0572: E8CD         ; list device. As with the reader and the punch, the physical device used   ;
0573: E8CD         ; depends entirely on the BIOS.                                             ;
0574: E8CD         ;																			;
0575: E8CD         ;			Function Code	:	C = 05H                                     ;
0576: E8CD         ;			Entry Parameters:	E = Data byte to be output					;
0577: E8CD         ;			Exit Parameters :	None										;
0578: E8CD         ;																			;
0579: E8CD         ;---------------------------- Write List Byte - 5 (5) ----------------------;
0580: E8CD         ;BDOS put parameter in C before entering this routine
0581: E8CD             vListOut:                       ; func5 (05 - 05) List Output
0582: E8CD CD 0F F6               CALL   bcList               ; direct call to BIOS
0583: E8D0 C9                     RET
0584: E8D1
0585: E8D1         ;--------------------------- Direct Console I/O - 6 (6) --------------------;
0586: E8D1         ;  This function serves double duty: it both inputs and outputs characters  ;
0587: E8D1         ; from the console. However, it bypasses the normal control characters and  ;
0588: E8D1         ; line editing features (such as CONTROL-P and CONTROL-S) normally          ;
0589: E8D1         ; associated with console I( O. Hence the name "direct" (or "unadorned" as  ;
0590: E8D1         ; Digital Research describes it). If the value in register E is not OFFH,   ;
0591: E8D1         ; then E contains a valid ASCII character that is output to the console.    ;
0592: E8D1         ;  This function works well provided you never have to send a value ofOFFH  ;
0593: E8D1         ; or expect to receive a value ofOOH. If you do need to send or receive     ;
0594: E8D1         ;  pure binary data, you cannot use this function, since these values are   ;
0595: E8D1         ;  likely to be part of the data stream.                                    ;
0596: E8D1         ;                                                                           ;
0597: E8D1         ;			Function Code	:	C = 06H                                     ;
0598: E8D1         ;			Entry Parameters:	E = 0FFH for Input					  		;
0599: E8D1         ;								E = Other than 0FFH for Output				;
0600: E8D1         ;			Exit Parameters :	A = Input byte or status					;
0601: E8D1         ;																			;
0602: E8D1         ;--------------------------- Direct Console I/O - 6 (6) --------------------;
0603: E8D1         ;BDOS put parameter in C before entering this routine
0604: E8D1             vDirectConIO:
0605: E8D1 79                     LD     A,C
0606: E8D2 3C                     INC    A
0607: E8D3 28 04                  JR     Z,vDirectConIO1      ; 0ffh => 00h, means input mode
0608: E8D5         ; send byte to console
0609: E8D5 CD 0C F6               CALL   bcConout             ; Send the byte to the console
0610: E8D8 C9                     RET
0611: E8D9
0612: E8D9         ;read byte/status from console
0613: E8D9             vDirectConIO1:
0614: E8D9 CD 06 F6               CALL   bcConst              ; Check Status
0615: E8DC B7                     OR     A                    ; 00 means not data ready
0616: E8DD CA 4D E8               JP     Z,ReturnToCaller1    ; If no data return  00 to caller
0617: E8E0 CD 09 F6               CALL   bcConin              ; Data is available, get it to A
0618: E8E3 32 B6 EA               LD     (exitParameterByte),A ; Save it
0619: E8E6 C9                     RET
0620: E8E7
0621: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) --------------------;
0622: E8E7         ; This function places the current value of the IOBYTE in register A.       ;
0623: E8E7         ;                                                                           ;
0624: E8E7         ; The IOBYTE structure:                                                     ;
0625: E8E7         ;								+-------+-------+-------+-------+           ;
0626: E8E7         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |           ;
0627: E8E7         ;								+-------+-------+-------+-------+           ;
0628: E8E7         ;				Logical Device     List | Punch | Reader|Console            ;
0629: E8E7         ;                                                                           ;
0630: E8E7         ;                                                                           ;
0631: E8E7         ;			Function Code	:	C = 07H                                     ;
0632: E8E7         ;			Entry Parameters:	None					  		  			;
0633: E8E7         ;			Exit Parameters :	A = Current IOBYTE value					;
0634: E8E7         ;																			;
0635: E8E7         ;--------------------------- Get IOBYTE Setting - 7 (7) --------------------;
0636: E8E7             vGetIOBYTE:
0637: E8E7 3A 03 00               LD     A,(IOBYTE)           ; Get the IOBYTE
0638: E8EA 32 B6 EA               LD     (exitParameterWord),A ; Return it to caller
0639: E8ED C9                     RET
0640: E8EE         ;--------------------------- Set IOBYTE Setting - 8 (8) --------------------;
0641: E8EE         ; This function sets the IOBYTE         									;
0642: E8EE         ;                                                                           ;
0643: E8EE         ; The IOBYTE structure:                                                     ;
0644: E8EE         ;								+-------+-------+-------+-------+           ;
0645: E8EE         ;						Bit No. | 7 : 6 | 5 : 4 | 3 : 2 | 1 : 0 |           ;
0646: E8EE         ;								+-------+-------+-------+-------+           ;
0647: E8EE         ;				Logical Device     List | Punch | Reader|Console            ;
0648: E8EE         ;                                                                           ;
0649: E8EE         ;                                                                           ;
0650: E8EE         ;			Function Code	:	C = 08H                                     ;
0651: E8EE         ;			Entry Parameters:	E = New IOBYTE value	  		  			;
0652: E8EE         ;			Exit Parameters :	None                                        ;
0653: E8EE         ;																			;
0654: E8EE         ;--------------------------- Get IOBYTE Setting - 8 (8) --------------------;
0655: E8EE         ;BDOS put parameter in C before entering this routine
0656: E8EE             vSetIOBYTE:
0657: E8EE 21 03 00               LD     HL,IOBYTE            ; point at The IOBYTE
0658: E8F1 71                     LD     (HL),C               ; Place new vale in it
0659: E8F2 C9                     RET
0660: E8F3
0661: E8F3         ;---------------------- Display $ terminated String - 9 (9) ----------------;
0662: E8F3         ;  This function outputs a string of characters to the console device. The  ;
0663: E8F3         ; address of this string is in registers DE. You must make sure that the    ;
0664: E8F3         ; last character of the string is "$"; the BDOS uses this character as a    ;
0665: E8F3         ; marker for the end of the string. The "$" itself does not get output to   ;
0666: E8F3         ; the console.                                                              ;
0667: E8F3         ;                                                                           ;
0668: E8F3         ; While the BDOS is outputting the string, it expands tabs as previously    ;
0669: E8F3         ; described, checks to see if there is an incoming character, and checks    ;
0670: E8F3         ; for  CONTROL-S (XOFF, which stops the output until another character is   ;
0671: E8F3         ; entered) or CONTROL-P (which turns on or off echoing of console characters;
0672: E8F3         ; to  the printer).                                                         ;
0673: E8F3         ;                                                                           ;
0674: E8F3         ;			Function Code	:	C = 09H                                     ;
0675: E8F3         ;			Entry Parameters:	DE = Address of the first byte of the string;
0676: E8F3         ;			Exit Parameters :	None							            ;
0677: E8F3         ;																			;
0678: E8F3         ;---------------------- Display $ terminated String - 9 (9) ----------------;
0679: E8F3             vPrintString:
0680: E8F3 2A B4 EA               LD     HL,(paramDE)         ; Get address of the string
0681: E8F6 4D                     LD     C,L
0682: E8F7 44                     LD     B,H                  ; Put it into BC for call
0683: E8F8 CD 3B E9               CALL   Print                ; out to console
0684: E8FB C9                     RET
0685: E8FC
0686: E8FC         ;-------------------------- Read Console String - A (10) -------------------;
0687: E8FC         ;  This function reads a string of characters from the console device       ;
0688: E8FC         ; and stores them in a buffer (address in DE) that you define. Full line    ;
0689: E8FC         ; editing is possible: the operator can backspace, cancel the line and      ;
0690: E8FC         ; start over, and use all the normal control functions. What you will       ;
0691: E8FC         ; ultimately see in the buffer is the final version of the character string ;
0692: E8FC         ; entered, without any of the errors or control characters used to do the   ;
0693: E8FC         ; line editing;                                                             ;
0694: E8FC         ;                                                                           ;
0695: E8FC         ;  The buffer that you define has a special format. The first byte in the   ;
0696: E8FC         ; buffer tells the BDOS the maximum number of characters to be accepted.    ;
0697: E8FC         ; The second byte is reserved for the BDOS to tell you how many characters  ;
0698: E8FC         ; were actually placed in the buffer. The following bytes contain           ;
0699: E8FC         ; the characters of the string. Character input will cease either when a    ;
0700: E8FC         ; CARRIAGE RETURN is entered or when the maximum number of characters,      ;
0701: E8FC         ; as specified in the buffer, has been received. The CARRIAGE RETURN is not ;
0702: E8FC         ; stored in the buffer as a character-it just serves as a terminator. If    ;
0703: E8FC         ; the first character entered is a CARRIAGE RETURN, then the BDOS sets      ;
0704: E8FC         ; the "characters input" byte to O. If you attempt to input more than the   ;
0705: E8FC         ; maximum number of characters, the "characters input" count will be the    ;
0706: E8FC         ; same as the maximum value allowed.                                        ;
0707: E8FC         ;                                                                           ;
0708: E8FC         ;			Function Code	:	C = 0AH                                     ;
0709: E8FC         ;			Entry Parameters:	DE = Address string buffer					;
0710: E8FC         ;			Exit Parameters :	String Buffer with console bytes in it      ;
0711: E8FC         ;																			;
0712: E8FC         ;-------------------------- Read Console String - A (10) -------------------;
0713: E8FC             vReadString:
0714: E8FC CD E0 E9               CALL   ReadString
0715: E8FF C9                     RET
0716: E900
0717: E900         ;------------------------- Read Console Status - B (11) --------------------;
0718: E900         ; This function tells you whether a console input character is waiting to   ;
0719: E900         ; be processed. Unlike the Console Input functions, which will wait until   ;
0720: E900         ; there is input,this function simply checks and returns immediately.       ;
0721: E900         ;                                                                           ;
0722: E900         ;			Function Code	:	C = 0BH                                     ;
0723: E900         ;			Entry Parameters:	None										;
0724: E900         ;			Exit Parameters :	A = 00H if no incoming Data					;
0725: E900         ;								A = FFH	if incoming Data					;
0726: E900         ;																			;
0727: E900         ;------------------------- Read Console Status - B (11) --------------------;
0728: E900             vGetConsoleStatus:
0729: E900 CD 8C E9               CALL   ConBreak
0730: E903 32 B6 EA               LD     (exitParameterByte),A
0731: E906 C9                     RET
0732: E907
0733: E907         ;--------------------------- Get CP/M Version - C (12) ---------------------;
0734: E907         ;  This function tells you which version of CP/M you are currently running. ;
0735: E907         ; A two-byte value is returned:                                             ;
0736: E907         ;	H = OOH for CP/M, H = OlH for MP/M                                      ;
0737: E907         ;	L = OOH for all releases before CP/M 2.0                                ;
0738: E907         ;	L = 20H for CP/M 2.0,21 H for 2.1, 22H for 2.2,                         ;
0739: E907         ;		and so on for any subsequent releases.                              ;
0740: E907         ;                                                                           ;
0741: E907         ; This information is of interest only if your program has some version     ;
0742: E907         ; specific logic built into it. For example, CP/M version 1.4 does not      ;
0743: E907         ; support the same Random File Input/ Output operations that CP/M 2.2 does. ;
0744: E907         ; Therefore, if your program uses Random I/O, put this check at the         ;
0745: E907         ; beginning to ensure that it is indeed running under the appropriate       ;
0746: E907         ; version of CP/M.                                                          ;
0747: E907         ;                                                                           ;
0748: E907         ;			Function Code	:	C = 0CH                                     ;
0749: E907         ;			Entry Parameters:	None										;
0750: E907         ;			Exit Parameters :	HL =Version Number Code						;
0751: E907         ;								A = FFH	if incoming Data					;
0752: E907         ;																			;
0753: E907         ;--------------------------- Get CP/M Version - C (12) ---------------------;
0754: E907             vGetVersion:                      ; func12 (12 - 0C)	 Get Version
0755: E907 3E 20                  LD     A,VERSION
0756: E909 32 B6 EA               LD     (exitParameterByte),A ;exitParameterByte = VERSION
0757: E90C C9                     RET
0758: E90D
0759: E90D         ;--------------------------- Get/Set User Number - 20 (32) -----------------;
0760: E90D         ;  This subroutine either sets or gets the current user number. The current ;
0761: E90D         ; user number determines which file directory entries are matched during all;
0762: E90D         ; disk file operations. When you call this function, the contents of the    ;
0763: E90D         ; E register specify what action is to be taken. IfE=OFFH, then the function;
0764: E90D         ; will return the current user number in the A register. If you set E to a  ;
0765: E90D         ; number in the range 0 to 15 (that is, a valid user number), the function  ;
0766: E90D         ; will set the current user number to this value.                           ;
0767: E90D         ;                                                                           ;
0768: E90D         ;			Function Code	:	C = 0CH                                     ;
0769: E90D         ;			Entry Parameters:	E = 0FFH to get User Number  				;
0770: E90D         ;								  = 0 to 15 to set User Number				;
0771: E90D         ;			Exit Parameters :	A = Current user Number if E was set to 0FFH;
0772: E90D         ;								A = FFH	if incoming Data					;
0773: E90D         ;																			;
0774: E90D         ;                                                                           ;
0775: E90D         ;--------------------------- Get/Set User Number - 20 (32) -----------------;
0776: E90D             vGetSetUserNumber:
0777: E90D 3A B3 EA               LD     A,(paramE)
0778: E910 FE FF                  CP     0FFH
0779: E912 20 07                  JR     NZ,SetUserNumber     ; interrogate user code instead
0780: E914 3A 79 F4               LD     A,(currentUserNumber)
0781: E917 32 B6 EA               LD     (exitParameterByte),A ; exitParameterByte=currentUserNumber
0782: E91A C9                     RET
0783: E91B
0784: E91B             SetUserNumber:
0785: E91B E6 0F                  AND    LO_NIBBLE_MASK
0786: E91D 32 79 F4               LD     (currentUserNumber),A
0787: E920 C9                     RET
0788: E921
0789: E921         ;***************************************************************************;
0790: E921         ;								Character Support Routines					;
0791: E921         ;***************************************************************************;
0792: E921
0793: E921
0794: E921         ;-------------------- Return a Character from the console ------------------;
0795: E921         ;return byte from buffer or read from the console                           ;
0796: E921             ConIn:                          ;
0797: E921 21 AF EA               LD     HL,keyboardByte      ; is there a Byte waiting?          ;
0798: E924 7E                     LD     A,(HL)               ;
0799: E925 36 00                  LD     (HL),0               ;
0800: E927 B7                     OR     A                    ;
0801: E928 C0                     RET    NZ                   ;
0802: E929         ;
0803: E929 C3 09 F6               JP     bcConin              ; Go get byte from Console          ;
0804: E92C         ;-------------------- Return a Character from the console ------------------;
0805: E92C
0806: E92C         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ---------;
0807: E92C         ; Resets Carry Flag if ASCII Printable, CR,LF,TAB,BackSpace or GE SPACE     ;
0808: E92C             IsPrintableASCII:                      ;
0809: E92C FE 0D                  CP     CR                   ;
0810: E92E C8                     RET    Z                    ; carriage return?                                                 ;
0811: E92F FE 0A                  CP     LF                   ;
0812: E931 C8                     RET    Z                    ; line feed?                                                       ;
0813: E932 FE 09                  CP     TAB                  ;
0814: E934 C8                     RET    Z                    ; TAB?                                                             ;
0815: E935 FE 08                  CP     CTRL_H               ;
0816: E937 C8                     RET    Z                    ; backspace?                                                       ;
0817: E938 FE 20                  CP     SPACE                ; Reset Carry if ASCII printable        ;
0818: E93A C9                     RET                         ;
0819: E93B         ;----------- Is the Character ASCII printable, CR,LF,TAB,BACKSPACE ---------;
0820: E93B
0821: E93B         ;------------------ Print character from (BC) until  $ found ---------------;
0822: E93B             Print:                          ;
0823: E93B 0A                     LD     A,(BC)               ; Get the next character            ;
0824: E93C FE 24                  CP     DOLLAR               ; Is it the end ?                   ;
0825: E93E C8                     RET    Z                    ;  exit if yes                      ;
0826: E93F 03                     INC    BC                   ; Update the pointer                ;
0827: E940 C5                     PUSH   BC                   ; Save it                           ;
0828: E941 4F                     LD     C,A                  ; Does Byte require                 ;
0829: E942 CD 58 E9               CALL   TabOut               ;  special attention - check        ;
0830: E945 C1                     POP    BC                   ; Retrieve the pointer				;
0831: E946 18 F3                  JR     Print                ; Loop back                         ;
0832: E948         ;------------------ Print character from (BC) until  $ found ---------------;
0833: E948
0834: E948         ;-- Send printable character to console. Precede with Caret if needed ------;
0835: E948         ; character is in Reg C                                                     ;
0836: E948             CaretOut:                       ;
0837: E948 79                     LD     A,C                  ;
0838: E949 CD 2C E9               CALL   IsPrintableASCII     ;
0839: E94C 30 0A                  JR     NC,TabOut            ; Skip if Caret not needed          ;
0840: E94E         ; send preceding up arrow                                                   ;
0841: E94E F5                     PUSH   AF                   ; Save the character                ;
0842: E94F 0E 5E                  LD     C,CARET              ;
0843: E951 CD 6B E9               CALL   ConsoleOut           ; Send Caret to Console             ;
0844: E954 F1                     POP    AF                   ; Get the character                 ;
0845: E955 F6 40                  OR     40H                  ; Make the graphic a letter         ;
0846: E957 4F                     LD     C,A                  ; Set up to print                   ;
0847: E958         ; fall thru to TabbOut                                                      ;
0848: E958         ;-- Send printable character to console. Precede with Caret if needed ------;
0849: E958
0850: E958         ;------------- Send printable character to console. Expand if TAB ----------;
0851: E958         ; character is in Reg C                                                     ;
0852: E958             TabOut:                         ;
0853: E958 79                     LD     A,C                  ;
0854: E959 FE 09                  CP     TAB                  ; Is it a TAB                       ;
0855: E95B C2 6B E9               JP     NZ,ConsoleOut        ; Go directly to ConsoleOut if not  ;
0856: E95E         ;
0857: E95E         ; TAB encountered                                                          ;
0858: E95E             TabOut0:                        ;
0859: E95E 0E 20                  LD     C,SPACE              ; Expand TABs with SPACEs           ;
0860: E960 CD 6B E9               CALL   ConsoleOut           ; Send to Console                   ;
0861: E963 3A B2 EA               LD     A,(columnPosition)   ; Get Column position               ;
0862: E966 E6 07                  AND    111b                 ; (ColumnPosition mod 8) = 0 ?      ;
0863: E968 20 F4                  JR     NZ,TabOut0           ; Do again if not                   ;
0864: E96A C9                     RET                         ;
0865: E96B         ;------------- Send printable character to console. Expand if TAB ----------;
0866: E96B
0867: E96B         ;-------------------------- Send character to console ----------------------;
0868: E96B         ; C  = Character to be output                                               ;
0869: E96B             ConsoleOut:                      ;
0870: E96B         ; Look for CNTL_S from keyboard and save it in keyboardByte                 ;
0871: E96B C5                     PUSH   BC                   ; Save character and Count          ;
0872: E96C CD 8C E9               CALL   ConBreak             ; Check for screen stop key stroke  ;
0873: E96F C1                     POP    BC                   ;
0874: E970 C5                     PUSH   BC                   ; Get/save character                ;
0875: E971         ; Send character to Console	                                                ;
0876: E971 CD 0C F6               CALL   bcConout             ; Send character to the console     ;
0877: E974 C1                     POP    BC                   ;
0878: E975 C5                     PUSH   BC                   ; Get/save character                ;
0879: E976         ; is the data to be output to print device?                                 ;
0880: E976 3A B0 EA               LD     A,(printEchoFlag)    ;
0881: E979 B7                     OR     A                    ;
0882: E97A C4 0F F6               CALL   NZ,bcList            ; Send it to printer, if so         ;
0883: E97D C1                     POP    BC                   ; Get the character                 ;
0884: E97E         ;
0885: E97E 79                     LD     A,C                  ; Put character to ACC              ;
0886: E97F 21 B2 EA               LD     HL,columnPosition    ; A = char, HL = .columnPosition    ;
0887: E982 34                     INC    M                    ; increment the ColumnPosition      ;
0888: E983         ;
0889: E983 FE 20                  CP     SPACE                ;
0890: E985 D0                     RET    NC                   ; Exit if ASCII printable           ;
0891: E986         ;
0892: E986 FE 0A                  CP     LF                   ;
0893: E988 C0                     RET    NZ                   ; Exit if not a Line Feed           ;
0894: E989         ;
0895: E989 36 00                  LD     (HL),0               ;  else force columnPosition = 0    ;
0896: E98B C9                     RET                         ;
0897: E98C         ;-------------------------- Send character to console ----------------------;
0898: E98C
0899: E98C         ;--------------------  Check for Status and Control S or C -----------------;
0900: E98C         ;  Returns:																	;
0901: E98C         ;			ACC = 0FFH if Saved keyboard byte or CNTL_S entered from console;
0902: E98C         ;			ACC = 00   No data Pending										;
0903: E98C         ;			DOES NOT RETURN if CTRL_C is entered from the keyboard          ;
0904: E98C         ;                                                                           ;
0905: E98C             ConBreak:                       ;
0906: E98C 3A AF EA               LD     A,(keyboardByte)     ;
0907: E98F B7                     OR     A                    ; If there is a char waiting        ;
0908: E990 20 2B                  JR     NZ,ConBreak1         ;  return with FF in ACC            ;
0909: E992         ;
0910: E992 CD 06 F6               CALL   bcConst              ; Get status                        ;
0911: E995 FE 00                  CP     00H                  ; If 00 => No data pending	        ;
0912: E997 C8                     RET    Z                    ; Return 00 No data pending         ;
0913: E998         ;
0914: E998 CD 09 F6               CALL   bcConin              ; Read the byte                     ;
0915: E99B         ;
0916: E99B FE 10                  CP     CTRL_P               ;
0917: E99D 20 0D                  JR     NZ,CheckCTL_S        ;
0918: E99F         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>            ;
0919: E99F 21 B0 EA               LD     HL,printEchoFlag     ;
0920: E9A2 3E FF                  LD     A,TRUE               ;
0921: E9A4 BE                     CP     (HL)                 ;
0922: E9A5 20 02                  JR     NZ,ToggleFlag1       ;
0923: E9A7 3E 00                  LD     A,FALSE              ;
0924: E9A9             ToggleFlag1:                      ;
0925: E9A9 77                     LD     (HL),A               ;
0926: E9AA 18 0C                  JR     NothingWaiting       ;
0927: E9AC         ;<><><><><><><><><><><><><> Toggle Print Echo Flag<><><><><><><>            ;
0928: E9AC             CheckCTL_S:                      ;
0929: E9AC FE 13                  CP     CTRL_S               ; If it is not Stop Screen, save    ;
0930: E9AE 20 0A                  JR     NZ,ConBreak0         ;   and and return 0FFH             ;
0931: E9B0         ;
0932: E9B0 CD 09 F6               CALL   bcConin              ; Else Read next byte               ;
0933: E9B3 FE 03                  CP     CTRL_C               ;
0934: E9B5 CA 00 00               JP     Z,WarmBoot           ; do WarmBoot if  CTRL_C            ;
0935: E9B8             NothingWaiting:                      ;
0936: E9B8 AF                     XOR    A                    ;
0937: E9B9 C9                     RET                         ; Set ACC = 0 and return            ;
0938: E9BA             ConBreak0:                      ;
0939: E9BA 32 AF EA               LD     (keyboardByte),A     ; save the byte                     ;
0940: E9BD             ConBreak1:                      ;
0941: E9BD 3E FF                  LD     A,TRUE               ; return with true set in ACC       ;
0942: E9BF C9                     RET                         ;
0943: E9C0         ;--------------------  Check for Status and Control S or C -----------------;
0944: E9C0
0945: E9C0         ;------------------------  Console Output Utilities ------------------------;
0946: E9C0             showHashCRLF:                      ;
0947: E9C0 0E 23                  LD     C,HASH_TAG           ;
0948: E9C2 CD 6B E9               CALL   ConsoleOut           ; Send # to console                 ;
0949: E9C5 CD D6 E9               CALL   showCRLF             ;
0950: E9C8             showHashCRLF1:                      ;
0951: E9C8 3E B2                  LD     A,columnPosition     ;
0952: E9CA 21 B1 EA               LD     HL,startingColumn    ;
0953: E9CD BF                     CP     A,M                  ;
0954: E9CE D0                     RET    NC                   ;
0955: E9CF 0E 20                  LD     C,SPACE              ;
0956: E9D1 CD 6B E9               CALL   ConsoleOut           ;
0957: E9D4 18 F2                  JR     showHashCRLF1        ;
0958: E9D6         ;------------------------  Console Output Utilities ------------------------;
0959: E9D6
0960: E9D6         ;------------------------  Send Carriage Return and Line Feed --------------;
0961: E9D6             showCRLF:                       ;
0962: E9D6 0E 0D                  LD     C,CR                 ;
0963: E9D8 CD 6B E9               CALL   ConsoleOut           ;
0964: E9DB 0E 0A                  LD     C,LF                 ;
0965: E9DD C3 6B E9               JP     ConsoleOut           ; exit via ConsoleOuts RET          ;
0966: E9E0         ;------------------------  Send Carriage Return and Line Feed --------------;
0967: E9E0
0968: E9E0         ;------------------------- Read a $ terminated String ----------------------;
0969: E9E0         ;read to paramDE address (max length, current length, buffer)              ;
0970: E9E0             ReadString:                      ;
0971: E9E0 3A B2 EA               LD     A,(columnPosition)   ;
0972: E9E3 32 B1 EA               LD     (startingColumn),A   ; Save start for CTRL_X and CTRL_R  ;
0973: E9E6 2A B4 EA               LD     HL,(paramDE)         ; Get the start of the String       ;
0974: E9E9 4E                     LD     C,(HL)               ; Get Max Count  					;
0975: E9EA 23                     INC    HL                   ; Point at actual bytes read        ;
0976: E9EB 06 00                  LD     B,0                  ; Initialize Current Count          ;
0977: E9ED         ;
0978: E9ED         ; B = Current Count                                                     ;
0979: E9ED         ; C = Maximum characters                                                ;
0980: E9ED         ; HL= Insertion Pointer                                                 ;
0981: E9ED         ;
0982: E9ED         ; read next character, BC, HL active                                       ;
0983: E9ED             ReadNext:                       ;
0984: E9ED C5                     PUSH   BC                   ; Save Current Index and Max Count  ;
0985: E9EE E5                     PUSH   HL                   ; Save pointer                      ;
0986: E9EF             ReadNext0:                      ;
0987: E9EF CD 21 E9               CALL   ConIn                ; Get the next Character            ;
0988: E9F2 E6 7F                  AND    ASCII_MASK           ; Mask parity bit                   ;
0989: E9F4 E1                     POP    HL                   ; Restore Pointer					;
0990: E9F5 C1                     POP    BC                   ; Current Index and Max Count		;
0991: E9F6         ;Is It Carriage Return                                                      ;
0992: E9F6 FE 0D                  CP     CR                   ;
0993: E9F8 28 3A                  JR     Z,EndRead            ; End the read if yes               ;
0994: E9FA FE 0A                  CP     LF                   ;
0995: E9FC         ;Is It Linefeed                                                             ;
0996: E9FC 28 36                  JR     Z,EndRead            ; End the read if yes               ;
0997: E9FE         ;Is It BackSpace                                                            ;
0998: E9FE FE 08                  CP     CTRL_H               ;
0999: EA00 28 3C                  JR     Z,BSspaceBS          ;
1000: EA02             IsItRubout:                      ;
1001: EA02 FE 7F                  CP     RUBOUT               ; Non destructive delete            ;
1002: EA04 28 41                  JR     Z,ItIsRubout         ;
1003: EA06             IsPhysicalEOL:                      ;
1004: EA06 FE 05                  CP     CTRL_E               ;
1005: EA08 28 46                  JR     Z,ItIsPhysicalEOL    ;
1006: EA0A             IsItPrintToggle:                      ;
1007: EA0A FE 10                  CP     CTRL_P               ;
1008: EA0C 28 49                  JR     Z,ItIsPrintToggle    ;
1009: EA0E             IsItDeleteTheLineX:                      ;
1010: EA0E FE 18                  CP     CTRL_X               ;
1011: EA10 28 6D                  JR     Z,DeleteTheLine      ; If CTRL_X go delete the line      ;
1012: EA12             IsItDeleteTheLineU:                      ;
1013: EA12 FE 15                  CP     CTRL_U               ;
1014: EA14 CA 9D EA               JP     Z,IgnoreTheLine      ; If CTRL_U ignore the line         ;
1015: EA17         ;Retype the line                                                            ;
1016: EA17 FE 12                  CP     CTRL_R               ;
1017: EA19 28 4B                  JR     Z,RepeatLine         ;
1018: EA1B
1019: EA1B         ;....................... Echo input back to the Console  ...................;
1020: EA1B         ; Full Duplex								                                ;
1021: EA1B         ; A = Character to display	                                                ;
1022: EA1B         ; B = current char count                                                    ;
1023: EA1B         ; C = maximum buffer length                                                 ;
1024: EA1B         ; HL= buffer pointer                                                        ;
1025: EA1B         ;ReadEcho                                                                   ;
1026: EA1B 04                     INC    B                    ; Increment byte count		        ;
1027: EA1C 23                     INC    HL                   ; Advance the Pointer               ;
1028: EA1D 77                     LD     (HL),A               ; Put char in buffer                ;
1029: EA1E         ;
1030: EA1E             ReadEchoRubOut:                      ;
1031: EA1E C5                     PUSH   BC                   ; Save index and length             ;
1032: EA1F E5                     PUSH   HL                   ; Save the Pointer                  ;
1033: EA20 4F                     LD     C,A                  ; Get char                          ;
1034: EA21 CD 48 E9               CALL   CaretOut             ; Output to Console (^ if needed)   ;
1035: EA24 E1                     POP    HL                   ; Restore the Pointer               ;
1036: EA25 C1                     POP    BC                   ; Restore index and length          ;
1037: EA26 7E                     LD     A,(HL)               ; Recall char                       ;
1038: EA27         ; check for Warm Boot                                                       ;
1039: EA27 FE 03                  CP     CTRL_C               ;
1040: EA29 78                     LD     A,B                  ; Get Line position                 ;
1041: EA2A 20 05                  JR     NZ,AreWeAtEndOfBuffer ; Skip if not CTRL_C                ;
1042: EA2C FE 01                  CP     1                    ; Beginning of the Line?            ;
1043: EA2E CA 00 00               JP     Z,WarmBoot           ;   if yes do the Boot              ;
1044: EA31         ; Check to see if we are at the end of the buffer                           ;
1045: EA31             AreWeAtEndOfBuffer:                      ;
1046: EA31 B9                     CP     C                    ; Over Max ?					    ;
1047: EA32 38 B9                  JR     C,ReadNext           ;  no, Go for more				    ;
1048: EA34         ;
1049: EA34         ; At the end of read                                  					    ;
1050: EA34             EndRead:                        ;
1051: EA34         ; 	POP		HL                                                              ;
1052: EA34 2A B4 EA               LD     HL,(paramDE)         ;
1053: EA37 23                     INC    HL                   ;
1054: EA38         ;
1055: EA38 70                     LD     (HL),B               ; Actual length at Pos 0 of Buffer  ;
1056: EA39 0E 0D                  LD     C,CR                 ;
1057: EA3B C3 6B E9               JP     ConsoleOut           ; Send CR to the Console			;
1058: EA3E         ;....................... Echo input back to the Console  ...................;
1059: EA3E         ;.......................... Backspace SPACE BackSpace ......................;
1060: EA3E             BSspaceBS:                      ;
1061: EA3E 05                     DEC    B                    ;
1062: EA3F 2B                     DEC    HL                   ;
1063: EA40 C5                     PUSH   BC                   ;
1064: EA41 E5                     PUSH   HL                   ;
1065: EA42 CD 90 EA               CALL   BackUp               ;
1066: EA45 18 A8                  JR     ReadNext0            ;
1067: EA47         ;.......................... Backspace SPACE BackSpace ......................;
1068: EA47         ;.......................... It is RubOut ...................................;
1069: EA47             ItIsRubout:                      ;
1070: EA47         ; RUBOUT if possible                                                        ;
1071: EA47 78                     LD     A,B                  ; Are we at the start of the line   ;
1072: EA48 B7                     OR     A                    ;
1073: EA49 28 A2                  JR     Z,ReadNext           ; then ignore and go for next char  ;
1074: EA4B         ;adjust pointers back one                                                   ;
1075: EA4B 7E                     LD     A,(HL)               ; ACC = current character           ;
1076: EA4C 05                     DEC    B                    ; Adjust the index			    	;
1077: EA4D 2B                     DEC    HL                   ; Adjust the pointer                ;
1078: EA4E 18 CE                  JR     ReadEchoRubOut       ; Echo back - Full Duplex           ;
1079: EA50         ;.......................... It is RubOut ...................................;
1080: EA50         ;.......................... It is PhysicalEOL ..............................;
1081: EA50             ItIsPhysicalEOL:                      ;
1082: EA50 C5                     PUSH   BC                   ; Save Current Index and Max Count  ;
1083: EA51 E5                     PUSH   HL                   ; Save pointer                      ;
1084: EA52 CD D6 E9               CALL   showCRLF             ; Make new line                     ;
1085: EA55 18 98                  JR     ReadNext0            ;   and go for next char   			;
1086: EA57         ;.......................... It is PhysicalEOL ..............................;
1087: EA57         ;.......................... It is PrintToggle ..............................;
1088: EA57             ItIsPrintToggle:                      ;
1089: EA57 E5                     PUSH   HL                   ; Save pointer                      ;
1090: EA58         ; Toggle the printEcho Flag                                                 ;
1091: EA58 21 B0 EA               LD     HL,printEchoFlag     ; Point at the flag                 ;
1092: EA5B 3E FF                  LD     A,TRUE               ; Load ACC with TRUE                ;
1093: EA5D BE                     CP     (HL)                 ; Is the flag true?                 ;
1094: EA5E 20 02                  JR     NZ,IsItPrintToggle1  ; Skip if not                       ;
1095: EA60 3E 00                  LD     A,FALSE              ;   else. load ACC with FALSE       ;
1096: EA62             IsItPrintToggle1:                      ;
1097: EA62 77                     LD     (HL),A               ; Set the Flags new Value	        ;
1098: EA63 E1                     POP    HL                   ; Restore pointer                   ;
1099: EA64 18 87                  JR     ReadNext             ;   and for another char            ;
1100: EA66         ;.......................... It is PrintToggle ..............................;
1101: EA66         ;.......................... RepeatLine .....................................;
1102: EA66             RepeatLine:                      ;
1103: EA66 C5                     PUSH   BC                   ; Save Current Index and Max Count  ;
1104: EA67 E5                     PUSH   HL                   ;  for exit                         ;
1105: EA68 CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			;
1106: EA6B         ;
1107: EA6B 2A B4 EA               LD     HL,(paramDE)         ; Get start of Buffer               ;
1108: EA6E 23                     INC    HL                   ; Skip past character count         ;
1109: EA6F         ;
1110: EA6F             LL1:                            ;
1111: EA6F 23                     INC    HL                   ; Point at next char to display     ;
1112: EA70 C5                     PUSH   BC                   ; Save counter, in B                ;
1113: EA71 E5                     PUSH   HL                   ; Save buffer pointer               ;
1114: EA72 4E                     LD     C,M                  ; Get the next character            ;
1115: EA73 CD 48 E9               CALL   CaretOut             ; Display it                        ;
1116: EA76 E1                     POP    HL                   ; Restore                           ;
1117: EA77 C1                     POP    BC                   ;  the counter and pointer          ;
1118: EA78 10 F5                  DJNZ   LL1                  ; loop if still more to show        ;
1119: EA7A E1                     POP    HL                   ; Restore values                    ;
1120: EA7B C1                     POP    BC                   ;  from routine entry               ;
1121: EA7C C3 ED E9               JP     ReadNext             ; Done here !                       ;
1122: EA7F         ;.......................... RepeatLine .....................................;
1123: EA7F         ;.......................... Delete The Line ................................;
1124: EA7F             DeleteTheLine:                      ;
1125: EA7F E1                     POP    HL                   ; Adjust Stack                      ;
1126: EA80         ;                                            ;
1127: EA80             DeleteTheLine1:                      ;
1128: EA80 3A B1 EA               LD     A,(startingColumn)   ;
1129: EA83 21 B2 EA               LD     HL,columnPosition    ;
1130: EA86 BE                     CP     M                    ; Start of line ?                   ;
1131: EA87 D2 E0 E9               JP     NC,ReadString        ;  If yes get out and go for more   ;
1132: EA8A 35                     DEC    M                    ; Adjust the ColumnPosition         ;
1133: EA8B CD 90 EA               CALL   BackUp               ; Clear 1 column                    ;
1134: EA8E 18 F0                  JR     DeleteTheLine1       ; Loop for more                     ;
1135: EA90         ;.......................... Delete The Line ................................;
1136: EA90         ;------------------------ Back-up one screen position ----------------------;
1137: EA90             BackUp:                         ;
1138: EA90 CD 98 EA               CALL   BackUp1              ; Send Backspace                    ;
1139: EA93 0E 20                  LD     C,SPACE              ; Overwrite with SPACE              ;
1140: EA95 CD 0C F6               CALL   bcConout             ; Overwrite with SPACE				;
1141: EA98         ;does not affect column count                                               ;
1142: EA98             BackUp1:                        ;
1143: EA98 0E 08                  LD     C,CTRL_H             ;
1144: EA9A C3 0C F6               JP     bcConout             ; Send Backspace                    ;
1145: EA9D         ;------------------------ Back-up one screen position ----------------------;
1146: EA9D         ;.......................... Ignore The Line ................................;
1147: EA9D             IgnoreTheLine:                      ;
1148: EA9D CD C0 E9               CALL   showHashCRLF         ; Display Hash, new Line			;
1149: EAA0 0E 20                  LD     C,SPACE              ; We want to add a few spaces       ;
1150: EAA2 CD 0C F6               CALL   bcConout             ;  to the console                   ;
1151: EAA5 0E 20                  LD     C,SPACE              ;
1152: EAA7 CD 0C F6               CALL   bcConout             ;
1153: EAAA C3 E0 E9               JP     ReadString           ; Start all over                    ;
1154: EAAD         ;.......................... Ignore The Line ................................;
1155: EAAD
1156: EAAD         ;------------------------- Read a $ terminated String ----------------------;
1157: EAAD
1158: EAAD         ;****************************************************************************
1159: EAAD         ;                           DATA AREA                                       *
1160: EAAD         ;****************************************************************************
1161: EAAD
1162: EAAD         ;------------------------------Non Disk Data Area --------------------------;
1163: EAAD             usersStack: DS     2                    ; entry stack pointer               ;
1164: EAAF         ;
1165: EAAF 00          keyboardByte: DB     00                   ; Saved keyboard character          ;
1166: EAB0         ;
1167: EAB0 00          printEchoFlag: DB     00                   ; Controlled by ^P                  ;
1168: EAB1         ;
1169: EAB1         ; FunctionValue:DB	00H					; Reg C on BDOS Entry               ;
1170: EAB1 00          startingColumn: DB     0                    ; Starting col pos after read       ;
1171: EAB2 00          columnPosition: DB     0                    ; Current Column position           ;
1172: EAB3         ;
1173: EAB3             paramE:    DS     BYTE                 ; Byte Argument for BDOS Call       ;
1174: EAB4             paramDE:   DS     WORD                 ; Word Argument for BDOS Call	    ;
1175: EAB6             exitParameterByte:                      ; Byte returned Value               ;
1176: EAB6             exitParameterWord: DS     WORD                 ; Word                          ;
1177: EAB8         ;
1178: EAB8         ;
1179: EAB8         ;------------------------------------ Data Area ----------------------------;
1180: EAB8
1181: EAB8
1182: EAB8
1183: EAB8         ;***************************************************************************;
1184: EAB8         ;								Disk I/O									;
1185: EAB8         ;***************************************************************************;
1186: EAB8
1187: EAB8         ;---------------------------- Reset Disk System - D (13) -------------------;
1188: EAB8         ;  This function requests CP/M to completely reset the disk file system.    ;
1189: EAB8         ; CP/M then resets its internal tables, selects logical disk A as the       ;
1190: EAB8         ; default disk, resets the DMAaddress back to 0080H (the address of the     ;
1191: EAB8         ; buffer used by the BDOS to read and write to the disk), and marks all     ;
1192: EAB8         ; logical disks as having Read/Write status. The BDOS will then have to log ;
1193: EAB8         ; in each logical disk as each disk is accessed. This involves reading the  ;
1194: EAB8         ; entire file directory for the disk and rebuilding the allocation vectors  ;
1195: EAB8         ; which keep track of which allocation blocks are free and which            ;
1196: EAB8         ; are used for file storage.                                                ;
1197: EAB8         ;                                                                           ;
1198: EAB8         ;			Function Code	:	C = 0DH                                     ;
1199: EAB8         ;			Entry Parameters:	None										;
1200: EAB8         ;			Exit Parameters :	None										;
1201: EAB8         ;																			;
1202: EAB8         ;---------------------------- Reset Disk System - D (13) -------------------;
1203: EAB8             vResetSystem:
1204: EAB8 21 00 00               LD     HL,0
1205: EABB 22 7C F4               LD     (readOnlyVector),HL  ; Clear the vectors for
1206: EABE 22 7E F4               LD     (loggedDisks),HL     ;   R/O and Logged Disks
1207: EAC1 AF                     XOR    A                    ; Clear the current disk
1208: EAC2 32 7A F4               LD     (currentDisk),A
1209: EAC5         ; note that currentUserNumber remains unchanged
1210: EAC5 21 80 00               LD     HL,DMABuffer
1211: EAC8 22 80 F4               LD     (initDAMAddress),HL  ; initDAMAddress = DMABuffer
1212: EACB CD 04 EF               CALL   SetDataDMA           ; to data DMA address
1213: EACE C3 21 ED               JP     Select
1214: EAD1         ;---------------------------- Select Disk - E (14) -------------------------;
1215: EAD1         ;  This function makes the logical disk named in register E the default disk;
1216: EAD1         ; All subsequent references to disk files that do not specify the disk will ;
1217: EAD1         ; use this default. When you reference a disk file that does have an        ;
1218: EAD1         ; explicit logical disk in its name you do not have to issue another        ;
1219: EAD1         ; Select Disk function; the BDOS will take care of that for you.            ;
1220: EAD1         ;                                                                           ;
1221: EAD1         ;  Notice the way in which the logical disk is specified in register E.     ;
1222: EAD1         ; It is not the same as the disk drive specification in the first byte of   ;
1223: EAD1         ; the file control block. In the FeB, a value ofOOH is used to mean         ;
1224: EAD1         ; "use the current default disk" (as specified in the last Select Disk      ;
1225: EAD1         ; call or by the operator on the console). With this function, a value      ;
1226: EAD1         ; of OOH in register A means that A is the selected drive, a value of       ;
1227: EAD1         ; 01H means drive B, and so on to OFR for drive P, allowing                 ;
1228: EAD1         ; 16 drives in the system.                                                  ;
1229: EAD1         ;                                                                           ;
1230: EAD1         ;			Function Code	:	C = 0EH                                     ;
1231: EAD1         ;			Entry Parameters:	E = Logical Disk Code (00H = A,01H = B ..)	;
1232: EAD1         ;			Exit Parameters :	None										;
1233: EAD1         ;																			;
1234: EAD1         ;---------------------------- Select Disk - E (14) -------------------------;
1235: EAD1
1236: EAD1             vSelectDisk:
1237: EAD1 C3 16 ED               JP     SelectCurrent
1238: EAD4
1239: EAD4         ;---------------------------- Open File - F (15) ---------------------------;
1240: EAD4         ;  This function opens a specified file for reading or writing. The FCB,    ;
1241: EAD4         ; whose address must be in register DE, tells CP/M the user number,         ;
1242: EAD4         ; the logical disk, the file name, and the file type. All other bytes of    ;
1243: EAD4         ; the FCB will normally be set to O.                                        ;
1244: EAD4         ;  The code returned by the BDOS in register A indicates whether the file   ;
1245: EAD4         ; has been opened successfully. If A contains OFFH, then the BOOS was       ;
1246: EAD4         ; unable to find the correct entry in the directory. If A= 0,1,2, or 3,     ;
1247: EAD4         ; then the file has been opened.                                            ;
1248: EAD4         ;			Function Code	:	C  = 0FH                                    ;
1249: EAD4         ;			Entry Parameters:	DE = Address of File Control Block			;
1250: EAD4         ;			Exit Parameters :	A  = Directory Code							;
1251: EAD4         ;																			;
1252: EAD4         ;---------------------------- Open File - F (15) ---------------------------;
1253: EAD4             vOpenFile:
1254: EAD4 CD BB EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1255: EAD7 CD 3D EF               CALL   ReselectDisk         ; do we need to reselect disk?
1256: EADA C3 F8 ED               JP     OpenFile
1257: EADD
1258: EADD         ;---------------------------- Close File - 10 (16) -------------------------;
1259: EADD         ;  This function terminates the processing of a file to which you have      ;
1260: EADD         ; written information. Under CP/M you do not need to close a file that you  ;
1261: EADD         ; have been reading. However, if you ever intend for your program to        ;
1262: EADD         ; function correctly under MP/M (the multi-user version of CP/M) you        ;
1263: EADD         ; should close all files regardless of their use.                           ;
1264: EADD         ;  The Close File function, like Open File, returns a directory code in     ;
1265: EADD         ; the A register. Register A will contain OFFH if the BOOS could not        ;
1266: EADD         ; close the file successfully. If A is 0, 1, 2, or 3, then the file has     ;
1267: EADD         ; been closed.                                                              ;
1268: EADD         ;                                                                           ;
1269: EADD         ;  When the BDOS closes a file to which data has been written, it writes    ;
1270: EADD         ; the current contents of the FCB out to the disk directory, updating       ;
1271: EADD         ; an existing directory entry by matching the disk, name, type, and         ;
1272: EADD         ; extent number in the same manner that the Open File function does.        ;
1273: EADD         ; Note that the BDOS does not transfer the last record of the file to the   ;
1274: EADD         ; disk during the close operation. It merely updates the file directory.    ;
1275: EADD         ; You must arrange to flush any partly filled record to the disk. If the    ;
1276: EADD         ; file that you have created is a standard CP/M ASCII text file, you must   ;
1277: EADD         ; arrange to fill the unused portion of the record with the standard lAH    ;
1278: EADD         ; end-of-file characters as CP/M expects.                                   ;
1279: EADD         ;                                                                           ;
1280: EADD         ;			Function Code	:	C  = 10H                                    ;
1281: EADD         ;			Entry Parameters:	DE = Address of File Control Block			;
1282: EADD         ;			Exit Parameters :	A  = Directory Code							;
1283: EADD         ;																			;
1284: EADD         ;---------------------------- Close File - 10 (16) -------------------------;
1285: EADD             vCloseFile:
1286: EADD CD 3D EF               CALL   ReselectDisk
1287: EAE0 C3 39 EE               JP     CloseDirEntry
1288: EAE3         ;---------------------Search for First Name Match - 11 (17) ----------------;
1289: EAE3         ;  This function scans down the file directory for the first entry that     ;
1290: EAE3         ; matches the file name, type, and extent in the FCB addressed by DE.       ;
1291: EAE3         ; The file name, type, and extent may contain a "?" (ASCII 3FH) in one or   ;
1292: EAE3         ; more character positions. Where a "?" occurs, the BDOS will match any     ;
1293: EAE3         ; character in the corresponding position in the file directory. This is    ;
1294: EAE3         ; known as ambiguous file name matching.                                    ;
1295: EAE3         ;  The first byte of an FCB normally contains the logical disk number code. ;
1296: EAE3         ; A value of 0 indicates the default disk, while 1 means disk A, 2 is B,    ;
1297: EAE3         ; and so on up to a possible maximum of 16 for disk P. However, if this     ;
1298: EAE3         ; byte contains a "?", the BDOS will search the default logical disk and    ;
1299: EAE3         ; will match the file name and type regardless of the user number. This     ;
1300: EAE3         ; function is normally used in conjunction with the Search Next function.   ;
1301: EAE3         ; Search First, in the process of matching a file, leaves certain           ;
1302: EAE3         ; variables in the BDOS set, ready for a subsequent Search Next.            ;
1303: EAE3         ;  Both Search First and Search Next return a directory code in the         ;
1304: EAE3         ; A register. With Search First, A = OFFH when no files match the FCB,      ;
1305: EAE3         ; if a file match is found, A will have a value of 0, I, 2, or 3.           ;
1306: EAE3         ;                                                                           ;
1307: EAE3         ;  To locate the particular directory entry that either the Search First    ;
1308: EAE3         ; or Search Next function matched, multiply the directory code returned     ;
1309: EAE3         ; in A by the length of a directory entry (32 bytes). This is easily done   ;
1310: EAE3         ; by adding the A register to itself five times. Then add the DMA address   ;
1311: EAE3         ; to get the actual address where the matched directory entry is stored.    ;
1312: EAE3         ;  There are many occasions when you may need to write a program that will  ;
1313: EAE3         ; accept an ambiguous file name and operate on all of the file names that   ;
1314: EAE3         ; match it. (The DIR and ERA commands built into the CCP are examples that  ;
1315: EAE3         ; use ambiguous file names.) To do this, you must use several BDOS          ;
1316: EAE3         ; functions: the Set DMA Address function (code 26), this function          ;
1317: EAE3         ; (Search First), and Search Next (code 18). All of this is shown in the    ;
1318: EAE3         ; subroutine given in Figure 5-17.                                          ;
1319: EAE3         ;                                                                           ;
1320: EAE3         ;                                                                           ;
1321: EAE3         ;			Function Code	:	C  = 11H                                    ;
1322: EAE3         ;			Entry Parameters:	DE = Address of File Control Block			;
1323: EAE3         ;			Exit Parameters :	A  = Directory Code							;
1324: EAE3         ;																			;
1325: EAE3         ;---------------------Search for First Name Match - 11 (17) ----------------;
1326: EAE3             vFindFirst:
1327: EAE3 0E 00                  LD     C,0                  ; Length assuming '?' true
1328: EAE5 2A B4 EA               LD     HL,(paramDE)         ; Get the FCB
1329: EAE8 7E                     LD     A,(HL)               ; DIsk/User No
1330: EAE9 FE 3F                  CP     QMARK                ; Does it contain '?' ?
1331: EAEB 28 08                  JR     Z,QMarkFind          ;  if Yes, skip disk reselect
1332: EAED         ;  and reset of EXT
1333: EAED
1334: EAED CD BB EF               CALL   InitializeExtentNumberMSB ; Set Ext to 0
1335: EAF0 CD 3D EF               CALL   ReselectDisk         ; Use FCB to set currentDisk
1336: EAF3 0E 0F                  LD     C,nameLength         ; Match name,type and extent
1337: EAF5
1338: EAF5             QMarkFind:
1339: EAF5 CD E7 EF               CALL   SearchForDirectoryRecord ; Find the directory record
1340: EAF8 C3 06 F2               JP     CopyDirEntryToUserDMA ; Move it to the User's buffer
1341: EAFB
1342: EAFB         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1343: EAFB         ;	This function searches down the file directory for the next file name,  ;
1344: EAFB         ; type, and extent that match the FCB specified in a previous Search First  ;
1345: EAFB         ; function call. Search First and Search Next are the only BDOS functions   ;
1346: EAFB         ; that must be used together. As you can see, the Search Next function      ;
1347: EAFB         ; does not require an FCB address as an input parameter-all the necessary   ;
1348: EAFB         ; information will have been left in the BDOS on the Search First call.     ;
1349: EAFB         ; Like Search First, Search Next returns a directory code in the A register,;
1350: EAFB         ; in this case, if A = OFFH, it means that there are no more files that     ;
1351: EAFB         ; match the file control block. If A is not OFFH, it will be a value of     ;
1352: EAFB         ; 0, 1, 2, or 3, indicating the relative directory entry number.            ;
1353: EAFB         ;                                                                           ;
1354: EAFB         ;  There are two ways of using the Search First/ Next calls. Consider a     ;
1355: EAFB         ; simple file copying program that takes as input an ambiguous file name.   ;
1356: EAFB         ; You could scan the file directory, matching all of the possible file      ;
1357: EAFB         ; names, possibly displaying them on the console, and storing the names of  ;
1358: EAFB         ; the files to be copied in a table inside your program. This would have    ;
1359: EAFB         ; the advantage of enabling you to present the file names to the operator   ;
1360: EAFB         ; before any copying occurred. You could even arrange for the operator to   ;
1361: EAFB         ; select which files to copy on a file-by-file basis. One disadvantage      ;
1362: EAFB         ; would be that you could not accurately predict how many files might be    ;
1363: EAFB         ; selected. On some hard disk systems you might have to accommodate several ;
1364: EAFB         ; thousand file names.                                                      ;
1365: EAFB         ;  The alternative way of handling the problem would be to match one file   ;
1366: EAFB         ; name, copy it, then match the next file name, copy it, and so on. If you  ;
1367: EAFB         ; gave the operator the choice of selecting which files to copy, this person;
1368: EAFB         ; would have to wait at the terminal as each file was being copied, but the ;
1369: EAFB         ; program would not need to have large table areas set aside to hold file   ;
1370: EAFB         ; names. This solution to the problem is slightly more complicated, as you  ;
1371: EAFB         ; can see from the logic in Figure 5-17.                                    ;
1372: EAFB         ;  The subroutine in Figure 5-17, Get Next File (GNF), contains all of the  ;
1373: EAFB         ; necessary logic to search down a directory for both alternatives described;
1374: EAFB         ; It does require that you indicate on entry whether it should search for   ;
1375: EAFB         ; the first or next file match, by setting A to zero or some nonzero value  ;
1376: EAFB         ; respectively.                                                             ;
1377: EAFB         ;  You can see from Figure 5-17 that whenever the subroutine is called to   ;
1378: EAFB         ; get the next file, you must execute a Search First function to re-find    ;
1379: EAFB         ; the  previous file. Only then can a Search Next be issued. As with all    ;
1380: EAFB         ; functions that return a directory code in A, if this value is not OFFH, it;
1381: EAFB         ; will be the relative directory entry number in the directory record       ;
1382: EAFB         ; currently in memory. This directory record will have been read into memory;
1383: EAFB         ; at whatever address was specified at the last Set DMA Address function    ;
1384: EAFB         ; call. Notwithstanding its odd name, the DMA Address is simply the address ;
1385: EAFB         ; into which any record input from disk will be placed. If the Set DMA      ;
1386: EAFB         ; Address function has not been used to change the value, then the CP/M     ;
1387: EAFB         ; default DMA address, location 0080H, will be used to hold the directory   ;
1388: EAFB         ; record.                                                                   ;
1389: EAFB         ;  The actual code for locating the address of the particular directory     ;
1390: EAFB         ;  entry matched by the Search First/ Next functions is shown in Figure 5-17;
1391: EAFB         ;  near the label GNFC. The method involves multiplying the directory code  ;
1392: EAFB         ;  by 32 and then adding this product to the current DMA address.	        ;
1393: EAFB         ;                                                                           ;
1394: EAFB         ;                                                                           ;
1395: EAFB         ;			Function Code	:	C  = 12H                                    ;
1396: EAFB         ;			Entry Parameters:	None , Assume previous Search First Call	;
1397: EAFB         ;			Exit Parameters :	A  = Directory Code							;
1398: EAFB         ;																			;
1399: EAFB         ;---------------------Search for Next Name Match - 12 (18) -----------------;
1400: EAFB             vFindNext:
1401: EAFB 2A A7 F4               LD     HL,(searchAddress)   ; Get Current Dir Entry
1402: EAFE 22 B4 EA               LD     (paramDE),HL         ; Get the user's FCB
1403: EB01 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1404: EB04 CD FC EF               CALL   GetNextDirectoryRecord ; Go find the next directory record
1405: EB07 C3 06 F2               JP     CopyDirEntryToUserDMA ; Copy directory entry to user
1406: EB0A
1407: EB0A         ;--------------------------------Delete File - 13 (19) ---------------------;
1408: EB0A         ; This function logically deletes from the file directory files that match  ;
1409: EB0A         ; the FCB addressed by DE. It does so by replacing the first byte of each   ;
1410: EB0A         ; relevant directory entry (remember, a single file can have several        ;
1411: EB0A         ; entries, one for each extent) by the value OE5H. This flags the directory ;
1412: EB0A         ; entry as being available for use.                                         ;
1413: EB0A         ;                                                                           ;
1414: EB0A         ;  Like the previous two functions, Search First and Search Next, this      ;
1415: EB0A         ; function can take an ambiguous file name and type as part of the          ;
1416: EB0A         ; File Control Block, but unlike those functions, the logical disk select   ;
1417: EB0A         ; code cannot be a"?". This function returns a directory code in A in the   ;
1418: EB0A         ; same way as the previous file operations.                                 ;
1419: EB0A         ;                                                                           ;
1420: EB0A         ;                                                                           ;
1421: EB0A         ;			Function Code	:	C  = 13H                                    ;
1422: EB0A         ;			Entry Parameters:	DE = Address of File Control Block			;
1423: EB0A         ;			Exit Parameters :	A  = Directory Code							;
1424: EB0A         ;																			;
1425: EB0A         ;--------------------------------Delete File - 13 (19) ---------------------;
1426: EB0A             vDeleteFile:
1427: EB0A CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1428: EB0D CD 1A F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1429: EB10 0E 0C                  LD     C,fcbExtIndex        ; Load the extent number field
1430: EB12 CD E7 EF               CALL   SearchForDirectoryRecord ; Look for directory entry
1431: EB15
1432: EB15             DeleteFileLoop:
1433: EB15 CD 38 F1               CALL   AtEndOfDirectory     ; Have we worked thru all entries
1434: EB18 CA 13 F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1435: EB1B
1436: EB1B         ; set each non zero disk map entry to 0 in the allocation vector
1437: EB1B CD 21 F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1438: EB1E CD 41 F1               CALL   GetCurrentDirectoryRecord ; Point to Directory Entry
1439: EB21 36 E5                  LD     (HL),emptyDir        ; Mark as Empty
1440: EB23 0E 00                  LD     C,FALSE              ; Set flag for remove
1441: EB25 CD 65 F1               CALL   ScanDiskMap          ; Reclaim Bisk Blocks, set to 0
1442: EB28 CD 5A F0               CALL   WriteDir             ; Update the directory
1443: EB2B CD FC EF               CALL   GetNextDirectoryRecord ; Look for more
1444: EB2E C3 15 EB               JP     DeleteFileLoop       ; Loop
1445: EB31
1446: EB31         ;----------------------------Read Sequential - 14 (20) ---------------------;
1447: EB31         ;  This function reads the next record (l28-byte sector) from the designated;
1448: EB31         ; file into memory at the address set by the last Set DMA function call     ;
1449: EB31         ; (code 26, lAH). The record read is specified by the FCB's sequential      ;
1450: EB31         ; record field. This field is incremented by 1 so that a subsequent call    ;
1451: EB31         ; to Read Sequential will get the next record from the file. If the end of  ;
1452: EB31         ; the current extent is reached, then the BDOS will automatically open the  ;
1453: EB31         ; next extent and reset the sequential record field to 0, ready for the     ;
1454: EB31         ; next Read function call.                                                  ;
1455: EB31         ;  The file specified in the FCB must have been readied for input by        ;
1456: EB31         ; issuing an Open File (code 15, OFH) or a Create File (code 22, 16H)       ;
1457: EB31         ; BDOS call. The value OOH is returned in A to indicate a successful Read   ;
1458: EB31         ; Sequential operation, while a nonzero value shows that the Read could     ;
1459: EB31         ; not be completed because there was no data in the next record, as at the  ;
1460: EB31         ; end of file.                                                              ;
1461: EB31         ;                                                                           ;
1462: EB31         ;  Although it is not immediately obvious, you can change the sequential    ;
1463: EB31         ; record number, FCB$SEQREC, and within a given extent, read a record at    ;
1464: EB31         ; random. If you want to access any given record within a file, you must    ;
1465: EB31         ; compute which extent that record would be in and set the extent field in  ;
1466: EB31         ; the file control block (FCB$EXTENT) before you open the file. Thus,       ;
1467: EB31         ; although the function name implies sequential access, in practice you can ;
1468: EB31         ; use it to perform a simple type of random access. If you need to do true  ;
1469: EB31         ; random access, look ahead to the Random Read function (code 33), which    ;
1470: EB31         ; takes care of opening the correct extent automatically.                   ;
1471: EB31         ;  When you read data from a CP/M text file, the normal convention is to    ;
1472: EB31         ; fill the last record of the file with lAH characters (CONTROL-Z).         ;
1473: EB31         ; Therefore, two possible conditions can indicate end-of-file: either       ;
1474: EB31         ; encountering a IAH, or receiving a return code from the BDOS function     ;
1475: EB31         ; (in the A register) of OFFH. However, if the file that you are reading    ;
1476: EB31         ; is not an ASCII text file, then a IAH character has no special meaning,   ;
1477: EB31         ; it is just a normal data byte in the body of the file.	                ;
1478: EB31         ;                                                                           ;
1479: EB31         ;			Function Code	:	C  = 14H                                    ;
1480: EB31         ;			Entry Parameters:	DE = Address of File Control Block			;
1481: EB31         ;			Exit Parameters :	A  = 0  => Success							;
1482: EB31         ;								  <> 0  => No data read, Probably EOF		;
1483: EB31         ;																			;
1484: EB31         ;----------------------------Read Sequential - 14 (20) ---------------------;
1485: EB31             vReadSeq:
1486: EB31 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1487: EB34         ;ReadSeq:
1488: EB34 3E 01                  LD     A,SEQ_ACCESS
1489: EB36 32 9F F4               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1490: EB39
1491: EB39             DiskRead:
1492: EB39 3E FF                  LD     A,TRUE
1493: EB3B 32 A3 F4               LD     (readModeFlag),A     ; Set Flag for read
1494: EB3E
1495: EB3E CD 69 EF               CALL   SetRecordVars        ; Set variables for current FCB
1496: EB41 3A AF F4               LD     A,(currentFileRecord)
1497: EB44 21 AD F4               LD     HL,fcbRecordCount
1498: EB47 BE                     CP     M                    ; is File Record < fcbRecordCount
1499: EB48 DA 5C EB               JP     C,RecordOK           ; skip if  yes
1500: EB4B         ; not enough records in the extent
1501: EB4B FE 80                  CP     RecordsPerExtent     ; Is record count the Max ?
1502: EB4D 20 22                  JR     NZ,NothingRead       ;  No, Exit with EOF
1503: EB4F
1504: EB4F CD 99 F2               CALL   OpenNextExt          ; Need to open the next extent
1505: EB52 AF                     XOR    A
1506: EB53 32 AF F4               LD     (currentFileRecord),A ; Reset the record count
1507: EB56 3A B6 EA               LD     A,(exitParameterByte) ; Was it a good Open
1508: EB59 B7                     OR     A
1509: EB5A 20 15                  JR     NZ,NothingRead       ;  exit if No
1510: EB5C
1511: EB5C             RecordOK:
1512: EB5C CD 49 F2               CALL   GetBlockNumber       ; Put it in absoluteCPMRecord
1513: EB5F CD 7B F2               CALL   WasBlockAllocated    ; Was it a good Allocation ?
1514: EB62 28 0D                  JR     Z,NothingRead        ; get out if not allocated
1515: EB64
1516: EB64 CD 81 F2               CALL   SetActualRecordAdd   ; Absolute CPM Record
1517: EB67 CD 6D F3               CALL   Seek                 ; Go to proper track,sector
1518: EB6A CD 12 EF               CALL   ReadBuffer           ; Read into DMA address
1519: EB6D CD 72 F0               CALL   UpdateRecordVariables ; update Record info
1520: EB70 C9                     RET
1521: EB71
1522: EB71             NothingRead:
1523: EB71 C3 1F F3               JP     SetExitParamTo1      ; No Data read
1524: EB74
1525: EB74         ;----------------------------Write Sequential - 15 (21) --------------------;
1526: EB74         ;	This function writes a record from the address specified in the last Set;
1527: EB74         ; DMA (code 26, lAH) function call to the file defined in the FCB. The      ;
1528: EB74         ; sequential record number in the FCB (RC) is updated by 1 so that          ;
1529: EB74         ; the next call to Write Sequential will write to the next record position  ;
1530: EB74         ; in the file. If necessary, a new extent will be opened to receive the new ;
1531: EB74         ; record.                                                                   ;
1532: EB74         ;  This function is directly analogous to the Read Sequential function,     ;
1533: EB74         ; writing instead of reading. The file specified in the FCB must first be   ;
1534: EB74         ; activated by an Open File (code 15,OFH) or create File call (code 22,16H).;
1535: EB74         ;  A directory code of OOH is returned in A to indicate that the Write was  ;
1536: EB74         ; successful, a nonzero value is returned if the Write could not be         ;
1537: EB74         ; completed because the disk was full.                                      ;
1538: EB74         ;                                                                           ;
1539: EB74         ;  As with the Read Sequential function (code 20, 14H), you can achieve     ;
1540: EB74         ; a simple form of random writing to the file by manipulating the           ;
1541: EB74         ; sequential record number (RC). However, you can only overwrite existing   ;
1542: EB74         ; records in the file, and if you want to move to another extent, you       ;
1543: EB74         ; must close the file and reopen it with the FCB$EXTENT field set to the    ;
1544: EB74         ; correct value.                                                            ;
1545: EB74         ;  The only logical error condition that can occur when writing to a file   ;
1546: EB74         ; is insufficient room on the disk to accommodate the next extent of the    ;
1547: EB74         ; file. Any hardware errors detected will be handled by the disk driver     ;
1548: EB74         ; built into the BIOS or BDOS.                                              ;
1549: EB74         ;                                                                           ;
1550: EB74         ;                                                                           ;
1551: EB74         ;			Function Code	:	C  = 15H                                    ;
1552: EB74         ;			Entry Parameters:	DE = Address of File Control Block			;
1553: EB74         ;			Exit Parameters :	A  = 0  => Success							;
1554: EB74         ;								  <> 0  => No data read, Probably EOF		;
1555: EB74         ;																			;
1556: EB74         ;----------------------------Write Sequential - 15 (21) --------------------;
1557: EB74
1558: EB74             vWriteSeq:
1559: EB74 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1560: EB77         ;	CALL	DiskWriteSeq
1561: EB77         ;	RET
1562: EB77         ;====================
1563: EB77         ;sequential disk write
1564: EB77             DiskWriteSeq:
1565: EB77 3E 01                  LD     A,SEQ_ACCESS
1566: EB79 32 9F F4               LD     (diskAccessType),A   ; Set flag as sequential Disk I/O
1567: EB7C
1568: EB7C             DiskWrite:
1569: EB7C 3E 00                  LD     A,FALSE
1570: EB7E 32 A3 F4               LD     (readModeFlag),A     ; Set Flag for Write
1571: EB81
1572: EB81 CD 1A F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1573: EB84 2A B4 EA               LD     HL,(paramDE)         ; Put FCB in HL
1574: EB87 CD 24 F2               CALL   CheckROFile          ; Terminate with error if File R/O
1575: EB8A CD 69 EF               CALL   SetRecordVars        ; Set variables for current FCB
1576: EB8D 3A AF F4               LD     A,(currentFileRecord) ; Get current record number
1577: EB90 FE 80                  CP     highestRecordNumber+1 ; Is it still in the same extent?
1578: EB92 D2 1F F3               JP     NC,SetExitParamTo1   ; Exit with NO WRITE set
1579: EB95
1580: EB95 CD 49 F2               CALL   GetBlockNumber       ; Compute disk block number
1581: EB98 CD 7B F2               CALL   WasBlockAllocated    ; Is it really allocated ?
1582: EB9B 0E 00                  LD     C,WriteAllocated     ; Assume a normal write operation
1583: EB9D C2 E6 EB               JP     NZ,HaveWriteBlock    ;  Skip if block already allocated
1584: EBA0         ; not allocated -
1585: EBA0         ; the argument to getblock is the starting position for the disk search
1586: EBA0         ; and should be the last allocated block for this file,
1587: EBA0         ; or the value 0 if no space has been allocated
1588: EBA0
1589: EBA0 CD 56 F2               CALL   GetDiskMapIndex      ; Disk Map Index in ACC
1590: EBA3 32 A5 F4               LD     (diskMapIndex),A     ; Save it
1591: EBA6 01 00 00               LD     BC,0000h             ; Anticipate using 0000
1592: EBA9 B7                     OR     A                    ; Is it block 0?
1593: EBAA 28 07                  JR     Z,FindAvailableBlock ;  skip if yes
1594: EBAC
1595: EBAC 4F                     LD     C,A                  ;  else a previous block exists
1596: EBAD 0B                     DEC    BC                   ; Adjust the index
1597: EBAE CD 63 F2               CALL   GetDiskMapValue      ; Put previous block # into HL
1598: EBB1 44                     LD     B,H                  ; Move previous block
1599: EBB2 4D                     LD     C,L                  ;  number into BC
1600: EBB3
1601: EBB3             FindAvailableBlock:
1602: EBB3 CD 90 F1               CALL   GetClosestBlock      ; Block number in HL
1603: EBB6 7D                     LD     A,L                  ; If no available blocks HL
1604: EBB7 B4                     OR     H                    ;  HL set to 0000H
1605: EBB8 20 06                  JR     NZ,FoundAvailableBlock ; Skip if found
1606: EBBA
1607: EBBA 3E 02                  LD     A,2                  ; Load return value
1608: EBBC 32 B6 EA               LD     (exitParameterByte),A ; Save for caller
1609: EBBF C9                     RET                         ; Exit with exitParameterByte=2
1610: EBC0
1611: EBC0             FoundAvailableBlock:
1612: EBC0 22 B1 F4               LD     (absoluteCPMRecord),HL ; Save the block number
1613: EBC3 EB                     EX     DE,HL                ; block number to DE (E)
1614: EBC4 2A B4 EA               LD     HL,(paramDE)         ; HL at FCB
1615: EBC7 01 10 00               LD     BC,fcbDiskMapIndex   ; Index to start of FCB Map
1616: EBCA 09                     ADD    HL,BC                ; HL=.start of FCB Map
1617: EBCB
1618: EBCB
1619: EBCB 3A A5 F4               LD     A,(diskMapIndex)     ; Get target block index
1620: EBCE 4F                     LD     C,A                  ; Map index to C
1621: EBCF 06 00                  LD     B,0                  ; Set MSB to 00
1622: EBD1 09                     ADD    HL,BC                ; Calculate 8 bit block's location
1623: EBD2 3A A9 F4               LD     A,(byteAllocationFlag) ; Get allocation size flag
1624: EBD5 B7                     OR     A                    ; Test it
1625: EBD6 28 03                  JR     Z,Allocate16Bit      ; Skip if allocating word
1626: EBD8
1627: EBD8 73                     LD     (HL),E               ; Update the Map
1628: EBD9 18 04                  JR     MarkNewBlock         ; Skip 16 bit calculations
1629: EBDB
1630: EBDB             Allocate16Bit:
1631: EBDB 09                     ADD    HL,BC                ; Adjust for 16 bit value
1632: EBDC 72                     LD     (HL),D               ; Save MSB
1633: EBDD 23                     INC    HL
1634: EBDE 73                     LD     (HL),E               ; SAVE LSB
1635: EBDF             MarkNewBlock:
1636: EBDF         ;	CALL	ResetFileWriteFlag
1637: EBDF CD C1 EF               CALL   GetWriteFileFlagValue ; HL = Address of fcbS2
1638: EBE2 CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag
1639: EBE4 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1640: EBE6
1641: EBE6             HaveWriteBlock:
1642: EBE6 3A B6 EA               LD     A,(exitParameterByte)
1643: EBE9 B7                     OR     A
1644: EBEA C0                     RET    NZ                   ; Exit if non zero returned value ??
1645: EBEB
1646: EBEB C5                     PUSH   BC                   ; Write flag (in C)
1647: EBEC CD 81 F2               CALL   SetActualRecordAdd   ; Set absoluteCPMRecord
1648: EBEF CD 6D F3               CALL   Seek                 ; Seek to o proper file position
1649: EBF2 C1                     POP    BC                   ; Write flag (in C)
1650: EBF3 C5                     PUSH   BC                   ; Write flag (in C)
1651: EBF4 CD 6A F0               CALL   WriteBuffer          ; Write buffer and check result
1652: EBF7 C1                     POP    BC                   ; Write flag (in C)
1653: EBF8
1654: EBF8 3A AF F4               LD     A,(currentFileRecord) ; Get the current record
1655: EBFB 21 AD F4               LD     HL,fcbRecordCount    ; Get the starting FCB record count
1656: EBFE BE                     CP     M                    ; Current File Record > fcbRecordCount
1657: EBFF 38 04                  JR     C,DiskWrite1         ;  skip if yes
1658: EC01 77                     LD     (HL),A               ; update the FCB RC
1659: EC02 34                     INC    M                    ; fcbRecordCount = current File Record+1
1660: EC03 0E 02                  LD     C,WriteCleanBuffer   ; Marked as unallocated write
1661: EC05             DiskWrite1:
1662: EC05         ; A has current File Record, C=2 if new block or new record#
1663: EC05 0D                     DEC    C
1664: EC06 0D                     DEC    C                    ; Check if C = unallocated write
1665: EC07 20 07                  JR     NZ,DiskWrite2        ; Skip if C not unallocated write
1666: EC09 F5                     PUSH   AF                   ; currentFileRecord
1667: EC0A CD C1 EF               CALL   GetWriteFileFlagValue ; HL points to FCB s2
1668: EC0D CB BE                  RES    7,(HL)               ; Reset WriteFileFlag
1669: EC0F F1                     POP    AF                   ; currentFileRecord
1670: EC10             DiskWrite2:
1671: EC10         ; check for end of extent, if found attempt
1672: EC10         ; to open next extent in preparation for next write
1673: EC10 FE 7F                  CP     highestRecordNumber  ; Space for more records ?
1674: EC12 20 19                  JR     NZ,DiskWriteCleanup  ;  finish up if Yes
1675: EC14
1676: EC14 3A 9F F4               LD     A,(diskAccessType)   ; Is this using Random Access
1677: EC17 B7                     OR     A
1678: EC18 28 13                  JR     Z,DiskWriteCleanup   ;  finish up if Yes
1679: EC1A
1680: EC1A CD 72 F0               CALL   UpdateRecordVariables ; Update variables from I/O in  FCB
1681: EC1D CD 99 F2               CALL   OpenNextExt          ; Acc = 0 OK, Acc = 1 Failed
1682: EC20 21 B6 EA               LD     HL,exitParameterByte
1683: EC23 7E                     LD     A,(HL)               ; Put Open  result in parameter
1684: EC24 B7                     OR     A                    ; Is it 00
1685: EC25 20 04                  JR     NZ,DiskWriteCleanup0 ;  no, skip currentRecord update
1686: EC27 3D                     DEC    A                    ; A gets FF
1687: EC28 32 AF F4               LD     (currentFileRecord),A ; Update currentFileRecord
1688: EC2B
1689: EC2B             DiskWriteCleanup0:
1690: EC2B 36 00                  LD     (HL),0               ; Set exitParameterByte
1691: EC2D             DiskWriteCleanup:
1692: EC2D C3 72 F0               JP     UpdateRecordVariables ; update variables from I/O in  FCB
1693: EC30
1694: EC30
1695: EC30         ;--------------------------------- Make File - 16 (22) ---------------------;
1696: EC30         ;  This function creates a new file of the specified name and type. You must;
1697: EC30         ; first ensure that no file of the same name and type already exists on the ;
1698: EC30         ; same logical disk, either by trying to open the file (if this succeeds,   ;
1699: EC30         ; the file already exists) or by unconditionally erasing the file.          ;
1700: EC30         ;  In addition to creating the file and its associated file directory entry,;
1701: EC30         ; this function also effectively opens the file so that it is ready for     ;
1702: EC30         ; records to be written to it.                                              ;
1703: EC30         ;  This function returns a normal directory code if the file creation has   ;
1704: EC30         ; completed successfully or a value of OFFH if there is insufficient        ;
1705: EC30         ; disk or directory space.                                                  ;
1706: EC30         ;  Note that this function cannot accept an ambiguous file name in the FCB. ;
1707: EC30         ;                                                                           ;
1708: EC30         ;                                                                           ;
1709: EC30         ;			Function Code	:	C  = 16H                                    ;
1710: EC30         ;			Entry Parameters:	DE = Address of File Control Block			;
1711: EC30         ;			Exit Parameters :	A  = Directory Code							;
1712: EC30         ;																			;
1713: EC30         ;---------------------------- Make File - 16 (22) --------------------------;
1714: EC30             vMakeFile:
1715: EC30 CD BB EF               CALL   InitializeExtentNumberMSB ; Clear the Extent number
1716: EC33 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1717: EC36 C3 B0 EE               JP     MakeNewFile          ; Go Make it
1718: EC39
1719: EC39         ;-------------------------- Rename File - 17 (23) --------------------------;
1720: EC39         ;  This function renames an existing file name and type to a new name and   ;
1721: EC39         ; type. It is unusual in that it uses a single FCB to store both the old    ;
1722: EC39         ; file name and type (in the first 16 bytes) and the new file name and type ;
1723: EC39         ; (in the second 16 bytes).                                                 ;
1724: EC39         ;  This function returns a normal directory code if the file rename was     ;
1725: EC39         ; completed successfully or a value of OFFH if the old file name could not  ;
1726: EC39         ; be found.                                                                 ;
1727: EC39         ;                                                                           ;
1728: EC39         ;  The Rename File function only checks that the old file name and type     ;
1729: EC39         ; exist; it makes no check to ensure that the new name and type combination ;
1730: EC39         ; does not already exist. Therefore, you should try to open the new file    ;
1731: EC39         ; name and type. If you succeed, do not attempt the rename operation.       ;
1732: EC39         ; CP/M will create more than one file of the same name and type, and you    ;
1733: EC39         ; stand to lose the information in both files as you attempt to sort out    ;
1734: EC39         ; the problem.                                                              ;
1735: EC39         ;  Never use ambiguous file names in a rename operation; it produces strange;
1736: EC39         ; effects and may result in files being irreparably damaged. This function  ;
1737: EC39         ; will change all occurrences of the old file name to the new name.         ;
1738: EC39         ;                                                                           ;
1739: EC39         ;                                                                           ;
1740: EC39         ;			Function Code	:	C  = 17H									;
1741: EC39         ;			Entry Parameters:	DE = Address of File Control Block			;
1742: EC39         ;			Exit Parameters :	A  = Directory Code							;
1743: EC39         ;																			;
1744: EC39         ;-------------------------- Rename File - 17 (23) --------------------------;
1745: EC39             vRenameFile:
1746: EC39 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1747: EC3C CD 1A F2               CALL   CheckWrite           ; Terminate with error if Disk R/O
1748: EC3F 0E 0C                  LD     C,fcbExtIndex        ; Match user#, Name & Type only
1749: EC41 CD E7 EF               CALL   SearchForDirectoryRecord
1750: EC44
1751: EC44         ; Move the old use number to the new entry (2nd half of FCB)
1752: EC44 2A B4 EA               LD     HL,(paramDE)         ; FCB pointer
1753: EC47 7E                     LD     A,(HL)               ; First byte of Dir entry
1754: EC48 11 10 00               LD     DE,fcbDiskMapIndex   ; Use second half of FCB
1755: EC4B 19                     ADD    HL,DE                ; Point at the second half of FCB
1756: EC4C 77                     LD     (HL),A               ; Put into new name user position
1757: EC4D
1758: EC4D             RenameLoop:
1759: EC4D CD 38 F1               CALL   AtEndOfDirectory     ; If have we checked the whole dir
1760: EC50 CA 13 F2               JP     Z,DirLocationToReturnLoc ;  return directory Index to caller
1761: EC53         ; process this match
1762: EC53 CD 21 F2               CALL   CheckRODirectory     ; Terminate with error if File R/O
1763: EC56 0E 10                  LD     C,fcbDiskMapIndex    ; Set starting position
1764: EC58 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1765: EC5A CD 32 F2               CALL   CopyDir              ; copy from FCB to dir entry
1766: EC5D         ; element renamed, look for more
1767: EC5D CD FC EF               CALL   GetNextDirectoryRecord ; Look for more dir entries
1768: EC60 18 EB                  JR     RenameLoop           ; Loop
1769: EC62
1770: EC62         ;---------------------------- Get Active Disks - 18 (24) -------------------;
1771: EC62         ; This function returns a bit map, called the login vector, in register     ;
1772: EC62         ; pair  HL, indicating which logical disk drives have been selected since   ;
1773: EC62         ; the last  warm boot or Reset Disk function (code 13, ODH). The least      ;
1774: EC62         ; significant bit of L corresponds to disk A, while the highest order bit   ;
1775: EC62         ; in H maps disk P. The bit corresponding to the specific logical disk is   ;
1776: EC62         ; set to 1 if the disk has been selected or to 0 if the disk is not         ;
1777: EC62         ; currently on-line.                                                        ;
1778: EC62         ;  Logical disks can be selected programmatically through any file          ;
1779: EC62         ; operation  that sets the drive field to a nonzero value, through the      ;
1780: EC62         ; Select Disk function (code 14, OEH), or by the operator entering an       ;
1781: EC62         ; "X:" command where "X" is equal to A, B, ... , P.                         ;
1782: EC62         ;                                                                           ;
1783: EC62         ;			Function Code	:	C = 018H                                    ;
1784: EC62         ;			Entry Parameters:	None										;
1785: EC62         ;			Exit Parameters :	HL = Active disk map (login vector)			;
1786: EC62         ;																			;
1787: EC62         ;---------------------------- Get Active Disks - 18 (24) -------------------;
1788: EC62             vGetLoginVector:
1789: EC62 2A 7E F4               LD     HL,(loggedDisks)
1790: EC65 22 B6 EA               LD     (exitParameterWord),HL
1791: EC68 C9                     RET
1792: EC69
1793: EC69         ;---------------------------- Get Current Disk- 19 (25) --------------------;
1794: EC69         ;   This function returns the current default disk set by the last Select   ;
1795: EC69         ; Disk function call (code 14, OEH) or by the operator entering the         ;
1796: EC69         ; "X:"command (where "X" is A, B, ..., P) to the CCP.                       ;
1797: EC69         ;                                                                           ;
1798: EC69         ;  This function returns the current default disk in coded form.            ;
1799: EC69         ; Register A= 0 if drive A is the current drive, I if drive B, and so on.   ;
1800: EC69         ; If you need to convert this to the corresponding ASCII character, simply  ;
1801: EC69         ; add 41H to register A. Use this function when you convert a file name and ;
1802: EC69         ; type in an FCB to an ASCII string in order to display it. If the first    ;
1803: EC69         ; byte of the FCB is OOH, the current default drive is to be used.          ;
1804: EC69         ; You must therefore use this function to determine the logical disk letter ;
1805: EC69         ; for the default drive.                                                    ;
1806: EC69         ;                                                                           ;
1807: EC69         ;			Function Code	:	C = 019H                                    ;
1808: EC69         ;			Entry Parameters:	None										;
1809: EC69         ;			Exit Parameters :	A = Current Disk (0=A,1=B...,F=P)			;
1810: EC69         ;																			;
1811: EC69         ;---------------------------- Get Current Disk- 19 (25) --------------------;
1812: EC69             vGetCurrentDisk:
1813: EC69 3A 7A F4               LD     A,(currentDisk)
1814: EC6C 32 B6 EA               LD     (exitParameterByte),A
1815: EC6F C9                     RET
1816: EC70
1817: EC70         ;---------------------------- Set DMA Address - 1A (26) --------------------;
1818: EC70         ;  This function sets the BDOS's direct memory access (DMA) address to a new;
1819: EC70         ; value. The name is an historic relic dating back to the Intel Development ;
1820: EC70         ; System on which CP/M was originally developed. This machine, by virtue of ;
1821: EC70         ; its hardware, could read data from a diskette directly into memory or     ;
1822: EC70         ; write data to a diskette directly from memory. The name DMA address now   ;
1823: EC70         ; applies to the address of the buffer to and from which data is            ;
1824: EC70         ; transferred whenever a diskette Read, Write, or directory operation is    ;
1825: EC70         ; performed. Whenever CP/M first starts up (cold boot) m a warm boot or     ;
1826: EC70         ; Reset Disk operation occurs, the DMA address is reset to its default      ;
1827: EC70         ; value of 0080H.                                                           ;
1828: EC70         ;                                                                           ;
1829: EC70         ;			Function Code	:	C = 0A9H                                    ;
1830: EC70         ;			Entry Parameters:	DE = DMA Address							;
1831: EC70         ;			Exit Parameters :	None										;
1832: EC70         ;																			;
1833: EC70         ;---------------------------- Set DMA Address - 1A (26) --------------------;
1834: EC70             vSetDMA:
1835: EC70 2A B4 EA               LD     HL,(paramDE)
1836: EC73 22 80 F4               LD     (initDAMAddress),HL
1837: EC76 C3 04 EF               JP     SetDataDMA
1838: EC79
1839: EC79         ;---------------------------- Get Allocation Vector - 1B (27) --------------;
1840: EC79         ;  This function returns the base, or starting, address of the allocation   ;
1841: EC79         ; vector for the currently selected logical disk. This information,         ;
1842: EC79         ; indicating which parts of the disk are assigned, is used by utility       ;
1843: EC79         ; programs and the BDOS itself to determine how much unused space is on the ;
1844: EC79         ; logical disk, to locate an unused allocation block in order to extend     ;
1845: EC79         ; a file, or to relinquish an allocation block when a file is deleted.      ;
1846: EC79         ;                                                                           ;
1847: EC79         ;			Function Code	:	C = 01BH                                    ;
1848: EC79         ;			Entry Parameters:	None										;
1849: EC79         ;			Exit Parameters :	HL = Address of allocation vector			;
1850: EC79         ;																			;
1851: EC79         ;---------------------------- Get Allocation Vector - 1B (27) --------------;
1852: EC79             vGetAllocAddr:
1853: EC79 2A 8E F4               LD     HL,(caAllocVector)
1854: EC7C 22 B6 EA               LD     (exitParameterWord),HL
1855: EC7F C9                     RET
1856: EC80
1857: EC80         ;---------------------------- Write Protect Disk - 1C (28) -----------------;
1858: EC80         ;  This function logically sets the currently selected disk to a Read-Only  ;
1859: EC80         ; state. Any attempts to execute a Write Sequential or Write Random function;
1860: EC80         ; to the selected disk will be intercepted by the BDOS, and the following   ;
1861: EC80         ; message will appear on the console:                                       ;
1862: EC80         ;	BDOS Err on X: R/O                                                      ;
1863: EC80         ;	where X: is the selected disk.                                          ;
1864: EC80         ;                                                                           ;
1865: EC80         ;  Once you have requested Read-Only status for the currently selected      ;
1866: EC80         ; logical disk, this status will persist even if you proceed to select      ;
1867: EC80         ; other logical disks. In fact, it will remain in force until the next warm ;
1868: EC80         ; boot or Reset Disk System function call.                                  ;
1869: EC80         ;  Digital Research documentation refers to this function code as Disk Write;
1870: EC80         ; Protect. The Read-Only description is used here because it corresponds    ;
1871: EC80         ; to the error message produced if your program attempts to write on        ;
1872: EC80         ; the disk.                                                                 ;
1873: EC80         ;                                                                           ;
1874: EC80         ;			Function Code	:	C = 01CH                                    ;
1875: EC80         ;			Entry Parameters:	None										;
1876: EC80         ;			Exit Parameters :	None										;
1877: EC80         ;																			;
1878: EC80         ;---------------------------- Write Protect Disk - 1C (28) -----------------;
1879: EC80         ;;write protect current disk
1880: EC80             vWriteProtectDisk:
1881: EC80 C3 1A EF               JP     SetDiskReadOnly
1882: EC83
1883: EC83         ;---------------------------- Get Read-Only Map - 1D (29) ------------------;
1884: EC83         ;  This function returns a bit map in registers H and L showing which       ;
1885: EC83         ; logical disks in the system have been set to Read-Only status, either by  ;
1886: EC83         ; the Set Logical Disk to Read-Only function call (code 28, ICH), or by     ;
1887: EC83         ; the BDOS itself, because it detected that a diskette had been changed.    ;
1888: EC83         ;  The least significant bit of L corresponds to logical disk A, while the  ;
1889: EC83         ; most significant bit of H corresponds to disk P. The bit corresponding to ;
1890: EC83         ; the specific logical disk is set to I if the disk has been set to         ;
1891: EC83         ; Read-Only status.                                                         ;
1892: EC83         ;                                                                           ;
1893: EC83         ;			Function Code	:	C = 01DH                                    ;
1894: EC83         ;			Entry Parameters:	None										;
1895: EC83         ;			Exit Parameters :	HL = Read-Only Vector						;
1896: EC83         ;																			;
1897: EC83         ;---------------------------- Get Read-Only Map - 1D (29) ------------------;
1898: EC83             vGetReadOnlyMap:
1899: EC83 2A 7C F4               LD     HL,(readOnlyVector)
1900: EC86 22 B6 EA               LD     (exitParameterWord),HL
1901: EC89 C9                     RET
1902: EC8A
1903: EC8A         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1904: EC8A         ;  This function sets the bits that describe attributes of a file in the    ;
1905: EC8A         ; relevant directory entries for the specified file. Each file can be       ;
1906: EC8A         ; assigned up to 11 file attributes. Of these 11, two have predefined       ;
1907: EC8A         ; meanings, four others are available for you to use, and the remaining     ;
1908: EC8A         ; five are reserved for future use by CP/M.                                 ;
1909: EC8A         ;  Each attribute consists of a single bit. The most significant bit of     ;
1910: EC8A         ; each byte of the file name and type is used to store the attributes.      ;
1911: EC8A         ; The file attributes are known by a code consisting of the letter "f"      ;
1912: EC8A         ; (for file name) or "t" (for file type), followed by the number of the     ;
1913: EC8A         ; character position and a single quotation mark. For example, the Read-Only;
1914: EC8A         ; attribute is tl'.                                                         ;
1915: EC8A         ;	The significance of the attributes is as follows:                       ;
1916: EC8A         ;			fl' to f4' Available for you to use                             ;
1917: EC8A         ;			f5' to fS' Reserved for future CP/M use                         ;
1918: EC8A         ;			tl' Read-Only File attribute                                    ;
1919: EC8A         ;			t2' System File attribute                                       ;
1920: EC8A         ;			t3' Reserved for future CP/M use                                ;
1921: EC8A         ;			                                                                ;
1922: EC8A         ;  Attributes are set by presenting this function with an FCB in which the  ;
1923: EC8A         ; unambiguous file name has been preset with the most significant bits      ;
1924: EC8A         ; set appropriately. This function then searches the directory for a match  ;
1925: EC8A         ; and changes the matched entries to contain the attributes which have been ;
1926: EC8A         ; set in the FCB.                                                           ;
1927: EC8A         ;  The BDOS will intercept any attempt to write on a file that has the      ;
1928: EC8A         ; Read-Only attribute set. The DIR command in the CCP does not display any  ;
1929: EC8A         ; file with System status.                                                  ;
1930: EC8A         ;                                                                           ;
1931: EC8A         ;  You can use the four attributes available to you to set up a file        ;
1932: EC8A         ; security system, or perhaps to flag certain files that must be backed up  ;
1933: EC8A         ; to other disks. The Search First and Search Next functions allow you to   ;
1934: EC8A         ; view the complete file directory entry, so your programs can test the     ;
1935: EC8A         ; attributes easily.                                                        ;
1936: EC8A         ;                                                                           ;
1937: EC8A         ;                                                                           ;
1938: EC8A         ;			Function Code	:	C  = 1EH                                    ;
1939: EC8A         ;			Entry Parameters:	DE = Address of File Control Block			;
1940: EC8A         ;			Exit Parameters :	A  = Directory Code							;
1941: EC8A         ;																			;
1942: EC8A         ;---------------------- Set File Attributes - 1E (30) ----------------------;
1943: EC8A             vSetFileAttributes:
1944: EC8A CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
1945: EC8D 0E 0C                  LD     C,fcbExtIndex        ; Size of search/match
1946: EC8F CD E7 EF               CALL   SearchForDirectoryRecord ; Find a match
1947: EC92
1948: EC92             SetAttributesLoop:
1949: EC92 CD 38 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
1950: EC95 CA 13 F2               JP     Z,DirLocationToReturnLoc ; Return directory Index to caller
1951: EC98         ; Directory entry found
1952: EC98 0E 00                  LD     C,0                  ; Set starting position
1953: EC9A 1E 0C                  LD     E,fcbExtIndex        ; Set Length
1954: EC9C CD 32 F2               CALL   CopyDir              ; copy from FCB to dir entry
1955: EC9F CD FC EF               CALL   GetNextDirectoryRecord ; Go find the next directory record
1956: ECA2 18 EE                  JR     SetAttributesLoop    ; Loop
1957: ECA4
1958: ECA4         ;------------------ Get Disk Parameter Block Address - 1F (31) -------------;
1959: ECA4         ;  This function returns the address of the disk parameter block (DPB) for  ;
1960: ECA4         ; the last selected logical disk. The DPB describes the physical            ;
1961: ECA4         ; characteristics of a specific logical disk-information mainly of interest ;
1962: ECA4         ; for system utility programs.                                              ;
1963: ECA4         ;                                                                           ;
1964: ECA4         ;			Function Code	:	C = 1FH                                     ;
1965: ECA4         ;			Entry Parameters:	None										;
1966: ECA4         ;			Exit Parameters :	HL = Address of Disk Parameter Block		;
1967: ECA4         ;																			;
1968: ECA4         ;------------------ Get Disk Parameter Block Address - 1F (31) -------------;
1969: ECA4             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1970: ECA4 2A 8A F4               LD     HL,(caDiskParamBlock)
1971: ECA7 22 B6 EA               LD     (exitParameterWord),HL
1972: ECAA C9                     RET
1973: ECAB
1974: ECAB         ;------------------------- Read Random - 21 (33) ---------------------------;
1975: ECAB         ; This function reads a specific CP/M record (128 bytes) from a random file ;
1976: ECAB         ; that is, a file in which records can be accessed directly. It assumes that;
1977: ECAB         ; you have already opened the file, set the DMA address using the BDOS      ;
1978: ECAB         ; Set DMA function, and set the specific record to be read into the random  ;
1979: ECAB         ; record number in the FCB. This function computes the extent of the        ;
1980: ECAB         ; specified record number and attempts to open it and read the correct CP/M ;
1981: ECAB         ; record into the DMA address.                                              ;
1982: ECAB         ;  The random record number in the FCB is three bytes long (at relative     ;
1983: ECAB         ; bytes 33, 34, and 35). Byte 33 is the least significant byte, 34 is the   ;
1984: ECAB         ; middle byte, and 35 the most significant. CP/M uses only the most         ;
1985: ECAB         ; significant byte (35) for computing the overall file size (function 35).  ;
1986: ECAB         ; You must set this byte to 0 when setting up the FCB. Bytes 33 and 34      ;
1987: ECAB         ; are used together for the Read Random, so you can access from record      ;
1988: ECAB         ; 0 to 65535 (a maximum file size of 8,388,480 bytes).                      ;
1989: ECAB         ;  This function returns with A set to 0 to indicate that the operation has ;
1990: ECAB         ; been completed successfully, or A set to a nonzero value if an error has  ;
1991: ECAB         ; occurred. The error codes are as follows:                                 ;
1992: ECAB         ;		A = 01 (attempt to read unwritten record)                           ;
1993: ECAB         ;		A = 03 (CP/M could not close current extent)                        ;
1994: ECAB         ;		A = 04 (attempt to read unwritten extent)                           ;
1995: ECAB         ;		A = 06 (attempt to read beyond end of disk)                         ;
1996: ECAB         ;		                                                                    ;
1997: ECAB         ;  Unlike the Read Sequential BOOS function (code 20, l4H), which updates   ;
1998: ECAB         ; the current (sequential) record number in the FCB, the Read Random        ;
1999: ECAB         ; function leaves the record number unchanged, so that a subsequent Write   ;
2000: ECAB         ; Random will replace the record just read.                                 ;
2001: ECAB         ;  You can follow a Read Random with a Write Sequential (code 21, l5H).     ;
2002: ECAB         ; This will rewrite the record just read, but will then update the          ;
2003: ECAB         ; sequential record number. Or you may choose to use a Read Sequential after;
2004: ECAB         ; the Read Random. In this case, the same record will be reread and the     ;
2005: ECAB         ; sequential record number will be incremented. In short, the file can be   ;
2006: ECAB         ; sequentially read or written once the Read Random has been used to        ;
2007: ECAB         ; position to the required place in the file.                               ;
2008: ECAB         ;                                                                           ;
2009: ECAB         ; To use the Read Random function, you must first open the base extent of   ;
2010: ECAB         ; the file, that is, extent O. Even though there may be no actual data      ;
2011: ECAB         ; records in this extent, opening permits the file to be processed          ;
2012: ECAB         ; correctly.                                                                ;
2013: ECAB         ;  One problem that is not immediately obvious with random files is that    ;
2014: ECAB         ; they can easily be created with gaps in the file. If you were to create   ;
2015: ECAB         ; the file with record number 0 and record number 5000, there would be no   ;
2016: ECAB         ; intervening file extents. Should you attempt to read or copy the file     ;
2017: ECAB         ; sequentially, even using CP/M's file copy utility, only the first extent  ;
2018: ECAB         ; (and in this case, record 0) would get copied. A Read Sequential function ;
2019: ECAB         ; would return an "end of file" error after reading record O. You must      ;
2020: ECAB         ; therefore be conscious of the type of the file that you try and read.     ;
2021: ECAB         ;                                                                           ;
2022: ECAB         ;                                                                           ;
2023: ECAB         ;                                                                           ;
2024: ECAB         ;			Function Code	:   C  = 21H                                    ;
2025: ECAB         ;			Entry Parameters:  DE = Address of File Control Block			;
2026: ECAB         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)   ;
2027: ECAB         ;								A = 03 (CP/M could not close current extent);
2028: ECAB         ;								A = 04 (attempt to read unwritten extent)   ;
2029: ECAB         ;								A = 06 (attempt to read beyond end of disk) ;
2030: ECAB         ;																			;
2031: ECAB         ;------------------------- Read Random - 21 (33) ---------------------------;
2032: ECAB             vReadRandom:
2033: ECAB CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
2034: ECAE
2035: ECAE 0E FF                  LD     C,TRUE               ; Identify as a Read
2036: ECB0 CD 84 F0               CALL   RandomSeek           ; Set up correct Dir entry etc.
2037: ECB3 CC 39 EB               CALL   Z,DiskRead           ; Go Read
2038: ECB6 C9                     RET
2039: ECB7         ;------------------------- Write Random - 22 (34) --------------------------;
2040: ECB7         ; This function writes a specific CP/M record (128 bytes) into a random     ;
2041: ECB7         ; file. It is initiated in much the same way as the companion function,     ;
2042: ECB7         ; Read Random (code 33,21H). It assumes that you have already opened the    ;
2043: ECB7         ; file, set the DMAaddress to the address in memory containing the record to;
2044: ECB7         ; be written to disk, and set the random record number in the FCB to the    ;
2045: ECB7         ; specified record being written. This function also computes the extent in ;
2046: ECB7         ; which the specified record number lies and opens the extent (creating it  ;
2047: ECB7         ; if it does not already exist). The error codes returned in A by this call ;
2048: ECB7         ; are the same as those for Read Random, with the addition of error         ;
2049: ECB7         ; code 05, which indicates a full directory.                                ;
2050: ECB7         ;  Like the Read Random (but unlike the Write Sequential), this function    ;
2051: ECB7         ; does not update the logical extent and sequential (current) record number ;
2052: ECB7         ; in the FCB. Therefore, any subsequent sequential operation will access    ;
2053: ECB7         ; the record just written by the Read Random call, but these functions will ;
2054: ECB7         ; update the sequential record number. The Write Random can therefore be    ;
2055: ECB7         ; used to position to the required place in the file, which can then be     ;
2056: ECB7         ; accessed sequentially.                                                    ;
2057: ECB7         ;                                                                           ;
2058: ECB7         ;  In order to use the Write Random, you must first open the base extent    ;
2059: ECB7         ; (extent 0) of the file. Even though there may be no data records in this  ;
2060: ECB7         ; extent, opening permits the file to be processed correctly.               ;
2061: ECB7         ;  As explained in the notes for the Read Random function, you can easily   ;
2062: ECB7         ; create a random file with gaps in it. If you were to create a file with   ;
2063: ECB7         ; record number 0 and record number 5000, there would be no intervening     ;
2064: ECB7         ; file extents.                                                             ;
2065: ECB7         ;                                                                           ;
2066: ECB7         ;			Function Code	:   C  = 24H                                    ;
2067: ECB7         ;			Entry Parameters:  DE = Address of File Control Block			;
2068: ECB7         ;			Exit Parameters :	A = 01 (attempt to read unwritten record)   ;
2069: ECB7         ;								A = 03 (CP/M could not close current extent);
2070: ECB7         ;								A = 04 (attempt to read unwritten extent)   ;
2071: ECB7         ;								A = 05 (CP/M cannot create new extent)		;
2072: ECB7         ;								A = 06 (attempt to read beyond end of disk) ;
2073: ECB7         ;																			;
2074: ECB7         ;------------------------- Write Random - 22 (34) --------------------------;
2075: ECB7             vWriteRandom:
2076: ECB7 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
2077: ECBA
2078: ECBA 0E 00                  LD     C,FALSE              ; Identify as a Write
2079: ECBC CD 84 F0               CALL   RandomSeek
2080: ECBF CC 7C EB               CALL   Z,DiskWrite          ; Go Write
2081: ECC2 C9                     RET
2082: ECC3
2083: ECC3         ;------------------------- Get File Size - 23 (35) -------------------------;
2084: ECC3         ;  This function returns the virtual size of the specified file. It does so ;
2085: ECC3         ; by setting the random record number (bytes 33-35) in the specified FCB to ;
2086: ECC3         ; the maximum 128-byte record number in the file. The virtual file size is  ;
2087: ECC3         ; calculated from the record address of the record following the end of the ;
2088: ECC3         ; file. Bytes 33 and 34 form a 16-bit value that contains the record number,;
2089: ECC3         ; with overflow indicated in byte 35. If byte 35 is 01, this means that the ;
2090: ECC3         ; file has the maximum record count of 65,536.                              ;
2091: ECC3         ;  If the function cannot find the file specified by the FCB, it returns    ;
2092: ECC3         ; with the random record field set to O.                                    ;
2093: ECC3         ;  You can use this function when you want to add data to the end of an     ;
2094: ECC3         ; existing file. By calling this function first, the random record bytes    ;
2095: ECC3         ; will be set to the end of file. Subsequent Write Random calls will write  ;
2096: ECC3         ; out records to this preset address.                                       ;
2097: ECC3         ;                                                                           ;
2098: ECC3         ;  Do not confuse the virtual file size with the actual file size. In a     ;
2099: ECC3         ; random file, if you write just a single CP/M record to record number      ;
2100: ECC3         ; 1000 and then call this function, it will return with the random record   ;
2101: ECC3         ; number field set in the FCB to 1000, even though only a single record     ;
2102: ECC3         ; exists in the file. For sequential files, this function returns the       ;
2103: ECC3         ; number of records in the file. In this case, the virtual and actual file  ;
2104: ECC3         ; sizes coincide.                                                           ;
2105: ECC3         ;                                                                           ;
2106: ECC3         ;                                                                           ;
2107: ECC3         ;			Function Code	:	C  = 23H                                    ;
2108: ECC3         ;			Entry Parameters:	DE = Address of File Control Block			;
2109: ECC3         ;			Exit Parameters :	Random record field set in FCB				;
2110: ECC3         ;																			;
2111: ECC3         ;------------------------- Get File Size - 23 (35) -------------------------;
2112: ECC3             vComputeFileSize:
2113: ECC3 CD 3D EF               CALL   ReselectDisk         ; Reselect if needed
2114: ECC6
2115: ECC6 0E 0C                  LD     C,fcbExtIndex        ; Set search/match length
2116: ECC8 CD E7 EF               CALL   SearchForDirectoryRecord ; Set directoryIndex
2117: ECCB         ; zero the receiving FCB Random Record field
2118: ECCB 2A B4 EA               LD     HL,(paramDE)         ; Point at FCB
2119: ECCE 11 21 00               LD     DE,recordRandom      ; Random Record index
2120: ECD1 19                     ADD    HL,DE                ; Point at Random Record
2121: ECD2 E5                     PUSH   HL                   ; Random Record LSB pointer
2122: ECD3 72                     LD     (HL),D               ; Set Random Record LSB = 0
2123: ECD4 23                     INC    HL                   ; Random Record MSB pointer
2124: ECD5 72                     LD     (HL),D               ; Set Random Record MSB = 0
2125: ECD6 23                     INC    HL                   ; Random Record overflow pointer
2126: ECD7 72                     LD     (HL),D               ; Set Random Record overflow = 0
2127: ECD8
2128: ECD8             GetFileSize1:
2129: ECD8 CD 38 F1               CALL   AtEndOfDirectory     ; Any more dir entries ?
2130: ECDB 28 20                  JR     Z,GetFileSizeExit    ;  exit if no
2131: ECDD
2132: ECDD CD 41 F1               CALL   GetCurrentDirectoryRecord ; HL points at Directory entry
2133: ECE0 11 0F 00               LD     DE,fcbRCIndex        ; FCB Record Count index
2134: ECE3 CD 04 F1               CALL   GetRandomRecordPosition
2135: ECE6         ;???????????????????????????????????????????????????????????????????????????;
2136: ECE6         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
2137: ECE6 E1                     POP    HL
2138: ECE7 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
2139: ECE8 5F                     LD     E,A                  ; save cy
2140: ECE9 79                     LD     A,C
2141: ECEA 96                     SUB    M
2142: ECEB 23                     INC    HL                   ; ls byte
2143: ECEC 78                     LD     A,B
2144: ECED 9E                     SBC    A,(HL)
2145: ECEE 23                     INC    HL                   ; middle byte
2146: ECEF 7B                     LD     A,E
2147: ECF0 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
2148: ECF1 38 05                  JR     C,GetFileSize2       ; for another try
2149: ECF3         ; fcb is less or equal, fill from directory
2150: ECF3 73                     LD     (HL),E
2151: ECF4 2B                     DEC    HL
2152: ECF5 70                     LD     (HL),B
2153: ECF6 2B                     DEC    HL
2154: ECF7 71                     LD     (HL),C
2155: ECF8             GetFileSize2:                      ; getnextsize:
2156: ECF8 CD FC EF               CALL   GetNextDirectoryRecord
2157: ECFB 18 DB                  JR     GetFileSize1
2158: ECFD             GetFileSizeExit:                      ; setsize:
2159: ECFD E1                     POP    HL                   ; discard .fcb(random record field)
2160: ECFE C9                     RET
2161: ECFF
2162: ECFF         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2163: ECFF         ;  This function sets the random record number in the FCB to the correct    ;
2164: ECFF         ; value for the last record read or written sequentially to the file.       ;
2165: ECFF         ;                                                                           ;
2166: ECFF         ;  This function provides you with a convenient way to build an index file  ;
2167: ECFF         ; so that you can randomly access a sequential file. Open the sequential    ;
2168: ECFF         ; file, and as you read each record, extract the appropriate key field from ;
2169: ECFF         ; the data record. Make the BDOS Set Random Record request and create a new ;
2170: ECFF         ; data record with just the key field and the random record number. Write   ;
2171: ECFF         ; the new data record out to the index file.                                ;
2172: ECFF         ;  Once you have done this for each record in the file, your index file     ;
2173: ECFF         ; provides a convenient method, given a search key value, of finding the    ;
2174: ECFF         ; appropriate CP/M record in which the data lies.                           ;
2175: ECFF         ;  You can also use this function as a means of finding out where you are   ;
2176: ECFF         ; currently positioned in a sequential file-either to relate a CP/M record  ;
2177: ECFF         ; number to the position, or simply as a place-marker to allow a            ;
2178: ECFF         ; repositioning to the same place later.                                    ;
2179: ECFF         ;                                                                           ;
2180: ECFF         ;                                                                           ;
2181: ECFF         ;			Function Code	:	C  = 24H                                    ;
2182: ECFF         ;			Entry Parameters:	DE = Address of File Control Block			;
2183: ECFF         ;			Exit Parameters :	Random record field set in FCB				;
2184: ECFF         ;																			;
2185: ECFF         ;------------------ Set Random Record Number - 24 (36) ---------------------;
2186: ECFF             vSetRandomRecord:
2187: ECFF 2A B4 EA               LD     HL,(paramDE)         ; FCB
2188: ED02 11 20 00               LD     DE,recordSeq         ; Sequential record index
2189: ED05 CD 04 F1               CALL   GetRandomRecordPosition
2190: ED08         ; A = Overflow, B = randomRecord MSB, C = randomRecord LSB
2191: ED08 21 21 00               LD     HL,recordRandom
2192: ED0B 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
2193: ED0C 71                     LD     (HL),C
2194: ED0D 23                     INC    HL
2195: ED0E 70                     LD     (HL),B
2196: ED0F 23                     INC    HL
2197: ED10 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
2198: ED11 C9                     RET
2199: ED12
2200: ED12         ;------------------------ Reset Logical Disk Drive - 25 (37) ---------------;
2201: ED12         ;  This function resets individual disk drives. It is a more precise        ;
2202: ED12         ; version of the Reset Disk System function (code 13,ODH), in that you      ;
2203: ED12         ; can set specific logical; disks rather than all of them.                  ;
2204: ED12         ;  The bit map in DE shows which disks are to be reset. The least           ;
2205: ED12         ; significant bit of E represents disk A, and the most significant bit of   ;
2206: ED12         ; D, disk P. The bits set to 1 indicate the disks to be reset.              ;
2207: ED12         ;  Note that this function returns a zero value in A in order to maintain   ;
2208: ED12         ; compatibility with MP/ M.                                                 ;
2209: ED12         ;                                                  ;                        ;
2210: ED12         ;  Use this function when only specific diskettes need to be changed.       ;
2211: ED12         ; Changing a diskette without requesting CP/M to log it in will cause the   ;
2212: ED12         ; BDOS to assume that an error has occurred and to set the new diskette to  ;
2213: ED12         ; Read-Only status as a protective measure                                  ;
2214: ED12         ;                                                                           ;
2215: ED12         ;			Function Code	:	C = 25H                                     ;
2216: ED12         ;			Entry Parameters:	DE = Logical Drive Bit Vector				;
2217: ED12         ;			Exit Parameters :	A = 00H										;
2218: ED12         ;																			;
2219: ED12         ;------------------------ Reset Logical Disk Drive - 25 (37) ---------------;
2220: ED12         ;  **************  Not Yet Implemented   **************
2221: ED12             vResetDrive:
2222: ED12 3E FF                  LD     A,-1                 ; Error return
2223: ED14 C9                     RET
2224: ED15
2225: ED15         ;------------------------------ Access Drive - 26 (38) ---------------------;
2226: ED15         ;								NOT SUPPORTED								;
2227: ED15         ;------------------------------ Access Drive - 26 (38) ---------------------;
2228: ED15
2229: ED15         ;------------------------------ Free   Drive - 27 (39) ---------------------;
2230: ED15         ;								NOT SUPPORTED								;
2231: ED15         ;------------------------------ Free   Drive - 27 (39) ---------------------;
2232: ED15
2233: ED15         ;---------------- Write Random with Zero Fill - 28 (40) --------------------;
2234: ED15         ;  This function is an extension to the Write Random function described     ;
2235: ED15         ; previously. In addition to performing the Write Random, it will also fill ;
2236: ED15         ; each new allocation block with OOH's. Digital Research added this function;
2237: ED15         ; to assist Microsoft with the production of its COBOL compiler-it makes the;
2238: ED15         ; logic of the file handling code easier. It also is an economical way to   ;
2239: ED15         ; completely fill a random file with OOH's. You need only write one record  ;
2240: ED15         ; per allocation block, the BDOS will clear the rest of the block for you.  ;
2241: ED15         ;                                                                           ;
2242: ED15         ;                                                                           ;
2243: ED15         ;			Function Code	:	C  = 24H                                    ;
2244: ED15         ;			Entry Parameters:	DE = Address of File Control Block			;
2245: ED15         ;			Exit Parameters :	A = Return Code								;
2246: ED15         ;																			;
2247: ED15         ;---------------- Write Random with Zero Fill - 28 (40) --------------------;
2248: ED15             vWriteRandom0Fill:
2249: ED15         ; Not Yet Implemented   **************
2250: ED15 C9                     RET
2251: ED16         ;--------------------------- Select  Drive ---------------------------------;
2252: ED16         ; Establish the disk found in (paramE) as the current disk drive            ;
2253: ED16             SelectCurrent:                      ;
2254: ED16 3A B3 EA               LD     A,(paramE)           ; Get Disk (00H = A,01H = B ..)     ;
2255: ED19 21 7A F4               LD     HL,currentDisk       ; Get the current disk              ;
2256: ED1C BE                     CP     M                    ; Are the the same ?                ;
2257: ED1D C8                     RET    Z                    ; Exit if yes, nothing to do        ;
2258: ED1E 77                     LD     (HL),A               ;  else update curretDisk and       ;
2259: ED1F 18 00                  JR     Select               ;  select it                        ;
2260: ED21         ;--------------------------- Select  Drive ---------------------------------;
2261: ED21         ;--------------------------- Select Login Drive ----------------------------;
2262: ED21         ; select Login Drive                                                       ;
2263: ED21             Select:                         ;
2264: ED21 CD 42 ED               CALL   SelectDisk           ; Select the Disk                   ;
2265: ED24 CC 08 F4               CALL   Z,Error_Select       ;
2266: ED27 21 7A F4               LD     HL,currentDisk       ;
2267: ED2A 46                     LD     B,(HL)               ; Get Current Disk                  ;
2268: ED2B 2A 7E F4               LD     HL,(loggedDisks)     ; Load Logged Disk MAP              ;
2269: ED2E CD DA F3               CALL   IsBitSet             ;
2270: ED31 C0                     RET    NZ                   ; Exit if already logged in         ;
2271: ED32         ;                                                                           ;
2272: ED32 21 7A F4               LD     HL,currentDisk       ;
2273: ED35 46                     LD     B,(HL)               ; Get Current Disk                  ;
2274: ED36 2A 7E F4               LD     HL,(loggedDisks)     ; else log in a different disk	    ;
2275: ED39 CD EA F3               CALL   SetVectorBit         ;
2276: ED3C 22 7E F4               LD     (loggedDisks),HL     ; Update the Vector                 ;
2277: ED3F         ;
2278: ED3F C3 88 ED               JP     InitDisk             ;
2279: ED42         ;--------------------------- Select Login Drive ----------------------------;
2280: ED42         ;--------------------------- Select Disk -----------------------------------;
2281: ED42         ; select the disk drive given by currentDisk, and fill the base addresses   ;
2282: ED42         ; caTrack - caAllocVector, then fill the values of the disk parameter block ;
2283: ED42             SelectDisk:                      ;
2284: ED42 3A 7A F4               LD     A,(currentDisk)      ; Get current disk (0=A,1=B...)     ;
2285: ED45 4F                     LD     C,A                  ; Prepare for BIOS Call             ;
2286: ED46 CD 1B F6               CALL   bcSeldsk             ; Select the disk                   ;
2287: ED49 7C                     LD     A,H                  ; Return Pointer to                 ;
2288: ED4A B5                     OR     L                    ;  Disk Parameter Header            ;
2289: ED4B C8                     RET    Z                    ; exit if error, with HL = 0000     ;
2290: ED4C         ;
2291: ED4C 5E                     LD     E,(HL)               ;
2292: ED4D 23                     INC    HL                   ;
2293: ED4E 56                     LD     D,(HL)               ; Skew Table in DE                  ;
2294: ED4F 23                     INC    HL                   ; HL = DPH + 2, Rel Pos for File    ;
2295: ED50 ED 53 A0 F4               LD     (caSkewTable),DE     ; Move to Current Skew Table        ;
2296: ED54         ;
2297: ED54 22 82 F4               LD     (caDirMaxValue),HL   ; Move to Current Dir max           ;
2298: ED57 23                     INC    HL                   ;
2299: ED58 23                     INC    HL                   ; HL = Last Track #                 ;
2300: ED59 22 84 F4               LD     (caTrack),HL         ; Move to Current Track #           ;
2301: ED5C 23                     INC    HL                   ;
2302: ED5D 23                     INC    HL                   ; HL = Last Sector #                ;
2303: ED5E 22 86 F4               LD     (caSector),HL        ; Move to Current Sector #          ;
2304: ED61 23                     INC    HL                   ;
2305: ED62 23                     INC    HL                   ;
2306: ED63 11 88 F4               LD     DE,caDirectoryDMA    ;
2307: ED66 01 08 00               LD     BC,caListSize        ;
2308: ED69 ED B0                  LDIR                        ;
2309: ED6B         ;
2310: ED6B         ; finish filling in address list                                            ;
2311: ED6B 2A 8A F4               LD     HL,(caDiskParamBlock) ; Point Disk Parameter Block        ;
2312: ED6E 11 90 F4               LD     DE,dpbStart          ; Point at BIOS DPB                 ;
2313: ED71 01 0F 00               LD     BC,dpbSize           ;
2314: ED74 ED B0                  LDIR                        ; Move DPB to current               ;
2315: ED76         ;
2316: ED76         ; Determine if Byte or Word Allocation Table	                            ;
2317: ED76 2A 95 F4               LD     HL,(dpbDSM)          ; Get max entry number              ;
2318: ED79 7C                     LD     A,H                  ; If  its 00 then < 255             ;
2319: ED7A 21 A9 F4               LD     HL,byteAllocationFlag ; Point at the  flag				;
2320: ED7D 36 FF                  LD     (HL),TRUE            ; Assume its less than 255          ;
2321: ED7F B7                     OR     A                    ;  is the assumption confirmed ?    ;
2322: ED80 28 02                  JR     Z,SelectDisk1        ;  skip if yes                      ;
2323: ED82 36 00                  LD     (HL),FALSE           ; Fix assumption,set flag to false  ;
2324: ED84         ;
2325: ED84         ; Set Sign, reset Carry and Zero to indicate success                        ;
2326: ED84             SelectDisk1:                      ;
2327: ED84 3E FF                  LD     A,TRUE               ;
2328: ED86 B7                     OR     A                    ;
2329: ED87 C9                     RET                         ;
2330: ED88         ;--------------------------- Select Disk -----------------------------------;
2331: ED88         ;--------------------------- Initialize Disk -------------------------------;
2332: ED88             InitDisk:                       ;
2333: ED88 2A 95 F4               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
2334: ED8B CD FD F2               CALL   DivideHLby8          ; Length of Map                     ;
2335: ED8E E5                     PUSH   HL                   ; Save Length                       ;
2336: ED8F E5                     PUSH   HL                   ; Save for end of MAP               ;
2337: ED90 C1                     POP    BC                   ; BC = dpbDSM/8                     ;
2338: ED91         ; Clear the Allocation Vector	                                            ;
2339: ED91 2A 8E F4               LD     HL,(caAllocVector)   ; Allocation vector Start           ;
2340: ED94 36 00                  LD     (HL),0               ; Clear location                    ;
2341: ED96 ED 5B 8E F4               LD     DE,(caAllocVector)   ;
2342: ED9A 13                     INC    DE                   ; Allocation vector Start + 1       ;
2343: ED9B ED B0                  LDIR                        ; Cascade 00 thru Map               ;
2344: ED9D         ; Force bits at End of Map                                                  ;
2345: ED9D EB                     EX     DE,HL                ; Put last Map byte into DE         ;
2346: ED9E E1                     POP    HL                   ;
2347: ED9F 23                     INC    HL                   ;
2348: EDA0 CD 07 F3               CALL   MultiplyHLby8        ; Blocks if all bits used           ;
2349: EDA3 ED 4B 95 F4               LD     BC,(dpbDSM)          ; Actual block max                  ;
2350: EDA7 03                     INC    BC                   ; Now has size of the Map           ;
2351: EDA8 AF                     XOR    A                    ; Clear CY                          ;
2352: EDA9 ED 42                  SBC    HL,BC                ; Extra unused bits                 ;
2353: EDAB BD                     CP     L                    ;  are there any                    ;
2354: EDAC 28 07                  JR     Z,Mark4Directory     ;
2355: EDAE 45                     LD     B,L                  ; Number of bits to set             ;
2356: EDAF EB                     EX     DE,HL                ; Put last Map byte into HL         ;
2357: EDB0             SetBitLoop:                      ;
2358: EDB0 37                     SCF                         ;
2359: EDB1 CB 16                  RL     (HL)                 ; Set LSB                           ;
2360: EDB3 10 FB                  DJNZ   SetBitLoop           ; Loop thru the bits                ;
2361: EDB5         ;
2362: EDB5             Mark4Directory:                      ;
2363: EDB5         ; Mark the reserved space for the directory                                 ;
2364: EDB5 2A 99 F4               LD     HL,(dpbDABM)         ; Directory block reserved bits     ;
2365: EDB8 EB                     EX     DE,HL                ;
2366: EDB9 2A 8E F4               LD     HL,(caAllocVector)   ; HL Start of Allocation Vector     ;
2367: EDBC 73                     LD     (HL),E               ;
2368: EDBD 23                     INC    HL                   ;
2369: EDBE 72                     LD     (HL),D               ; Put reserved blocks in Vector     ;
2370: EDBF         ; end of Map                                                                ;
2371: EDBF         ; Home disk, and set current track and sector to 00                         ;
2372: EDBF CD EA EE               CALL   Home                 ;
2373: EDC2 2A 82 F4               LD     HL,(caDirMaxValue)   ;
2374: EDC5 36 03                  LD     (HL),3               ;
2375: EDC7 23                     INC    HL                   ;
2376: EDC8 36 00                  LD     (HL),0               ; Current Max Dir Value = 0003      ;
2377: EDCA CD 31 F1               CALL   SetEndDirectory      ; dirEntryIndex = EOD (-1)          ;
2378: EDCD         ;
2379: EDCD             InitDisk1:                      ;
2380: EDCD         ; Process the directory                                                     ;
2381: EDCD 0E FF                  LD     C,TRUE               ; Set flag for setting CheckSum	    ;
2382: EDCF CD 2E F3               CALL   ReadDirectory        ; Get the directory Record          ;
2383: EDD2 CD 38 F1               CALL   AtEndOfDirectory     ; Are we Done ?                     ;
2384: EDD5 C8                     RET    Z                    ;  Exit if Yes                      ;
2385: EDD6         ; Not end of directory, valid entry?                                        ;
2386: EDD6 CD 41 F1               CALL   GetCurrentDirectoryRecord ; Calculate location of the element ;
2387: EDD9 3E E5                  LD     A,emptyDir           ;
2388: EDDB BE                     CP     M                    ; Is it an Empty Dir Entry          ;
2389: EDDC 28 EF                  JR     Z,InitDisk1          ;   Loop back if yes                ;
2390: EDDE         ; Not emptyDir, user code the same?                                         ;
2391: EDDE 3A 79 F4               LD     A,(currentUserNumber) ;
2392: EDE1 BE                     CP     M                    ;
2393: EDE2 20 0A                  JR     NZ,InitDisk2         ; Skip if this entry not the users  ;
2394: EDE4         ; Same user, check for '$' submit                                           ;
2395: EDE4 23                     INC    HL                   ;
2396: EDE5 7E                     LD     A,(HL)               ;
2397: EDE6 D6 24                  SUB    DOLLAR               ; Is first Char a $                 ;
2398: EDE8 20 04                  JR     NZ,InitDisk2         ;
2399: EDEA         ; dollar file found, mark in exitParameterByte                              ;
2400: EDEA 3D                     DEC    A                    ; Set A to FFH                      ;
2401: EDEB 32 B6 EA               LD     (exitParameterByte),A ; Return it the exit parameter      ;
2402: EDEE             InitDisk2:                      ;
2403: EDEE         ; now scan the disk map for allocated blocks                                ;
2404: EDEE 0E FF                  LD     C,TRUE               ; set to allocated                  ;
2405: EDF0 CD 65 F1               CALL   ScanDiskMap          ;
2406: EDF3 CD 4F F1               CALL   SetDirectoryEntry    ; Mark directory entry              ;
2407: EDF6 18 D5                  JR     InitDisk1            ; Loop for another entry            ;
2408: EDF8         ;--------------------------- Initialize Disk -------------------------------;
2409: EDF8         ;----------------------------- Open File -----------------------------------;
2410: EDF8         ;search for the directory entry matching FCB at paramDE						;
2411: EDF8             OpenFile:                       ;
2412: EDF8 0E 0F                  LD     C,nameLength         ;
2413: EDFA CD E7 EF               CALL   SearchForDirectoryRecord ;
2414: EDFD CD 38 F1               CALL   AtEndOfDirectory     ; Have we gone thru all the dir    	;
2415: EE00 C8                     RET    Z                    ; Exit exitParameterByte=255 if yes	;
2416: EE01         ;
2417: EE01             CopyDirRecordToFCB:                      ;
2418: EE01 CD 8D EF               CALL   GetExtentAddress     ; HL points to FCB's EXT           	;
2419: EE04 7E                     LD     A,(HL)               ; Get the EXT                      	;
2420: EE05 F5                     PUSH   AF                   ; Save the FCB's EXT value         	;
2421: EE06 E5                     PUSH   HL                   ;  also save FCB's pointer         	;
2422: EE07 CD 41 F1               CALL   GetCurrentDirectoryRecord ; Get pointer to Dir record in HL  	;
2423: EE0A E5                     PUSH   HL                   ; Save Directory Record address    	;
2424: EE0B         ;
2425: EE0B ED 5B B4 EA               LD     DE,(paramDE)         ;
2426: EE0F 01 20 00               LD     BC,fcbLength         ;
2427: EE12 ED B0                  LDIR                        ; Move dir record to FCB           	;
2428: EE14         ;
2429: EE14         ; note that entire fcb is copied, including indicators                    	;
2430: EE14 CD CA EF               CALL   SetFileWriteFlag     ; Set clean file flag				;
2431: EE17 D1                     POP    DE                   ; Get Directory Record address     	;
2432: EE18 21 0C 00               LD     HL,fcbExtIndex       ; Extent Index                     	;
2433: EE1B 19                     ADD    HL,DE                ; Directory's EXT address          	;
2434: EE1C 4E                     LD     C,(HL)               ; Dir's EXT is in B		           	;
2435: EE1D 21 0F 00               LD     HL,fcbRCIndex        ; Get Record Count Index           	;
2436: EE20 19                     ADD    HL,DE                ; Directory's RC address           	;
2437: EE21 46                     LD     B,(HL)               ; B holds Dir's  record count      	;
2438: EE22 E1                     POP    HL                   ; Get FCB's Extent Address         	;
2439: EE23 F1                     POP    AF                   ; Get FCB's Extent Value           	;
2440: EE24 77                     LD     (HL),A               ; Restore Extent Value             	;
2441: EE25         ; if user ext < dir ext then user := 128 records                           	;
2442: EE25         ; if user ext = dir ext then user := dir records                           	;
2443: EE25         ; if user ext > dir ext then user := 0 records                             	;
2444: EE25 79                     LD     A,C                  ; Get the Dir's EXT                	;
2445: EE26 BE                     CP     M                    ; Does it match the FCB'd          	;
2446: EE27 78                     LD     A,B                  ; Get the Dir's  record count      	;
2447: EE28 28 06                  JR     Z,OpenSetRecordCount ; If same EXT value, use it.       	;
2448: EE2A 3E 00                  LD     A,0                  ;   else prepare for RC = 0        	;
2449: EE2C 38 02                  JR     C,OpenSetRecordCount ; If FCB EXT > Dir EXTr            	;
2450: EE2E 3E 80                  LD     A,RecordsPerExtent   ;   else max record count out      	;
2451: EE30             OpenSetRecordCount:                      ;
2452: EE30 2A B4 EA               LD     HL,(paramDE)         ; Get FCB's address                	;
2453: EE33 11 0F 00               LD     DE,fcbRCIndex        ; Get record count index           	;
2454: EE36 19                     ADD    HL,DE                ; FCB's record count               	;
2455: EE37 77                     LD     (HL),A               ; Set the value                    	;
2456: EE38 C9                     RET                         ;
2457: EE39         ;----------------------------- Open File -----------------------------------;
2458: EE39         ;---------------------------- Close Directory Entry ------------------------;
2459: EE39             CloseDirEntry:                      ;
2460: EE39 AF                     XOR    A                    ;
2461: EE3A 32 B6 EA               LD     (exitParameterByte),A ; Clear exit parameter              ;
2462: EE3D CD 32 EF               CALL   IsDiskWriteProtected ; Return Z set if writable          ;
2463: EE40 C0                     RET    NZ                   ; Skip close if r/o disk            ;
2464: EE41         ; check file write flag - 0 indicates written                               ;
2465: EE41 CD C1 EF               CALL   GetWriteFileFlagValue ; Get file's WriteFileFlag          ;
2466: EE44 CB 7F                  BIT    7,A                  ;  Has it changed ?					;
2467: EE46         ;	AND		writeFlagMask				; Apply the RO Flag for S2          ;
2468: EE46 C0                     RET    NZ                   ; Skip close if clean file          ;
2469: EE47         ;
2470: EE47 0E 0F                  LD     C,nameLength         ;
2471: EE49 CD E7 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
2472: EE4C CD 38 F1               CALL   AtEndOfDirectory     ; If EOD then there is no more      ;
2473: EE4F C8                     RET    Z                    ;  exit if at EOD                   ;
2474: EE50         ;
2475: EE50         ; merge the FCB's Disk Map with the Directory record Disk Map               ;
2476: EE50 CD 41 F1               CALL   GetCurrentDirectoryRecord ; HL points to directory record     ;
2477: EE53 01 10 00               LD     BC,fcbDiskMapIndex   ; Disk Alloc block map index        ;
2478: EE56 09                     ADD    HL,BC                ;
2479: EE57 EB                     EX     DE,HL                ; DE = Directory Entry Map pointer  ;
2480: EE58 2A B4 EA               LD     HL,(paramDE)         ;
2481: EE5B 09                     ADD    HL,BC                ; HL = FCB Map Pointer              ;
2482: EE5C 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; Size Allocation Map              ;
2483: EE5E         ;
2484: EE5E             MergeAllocationMaps:                      ;
2485: EE5E 3A A9 F4               LD     A,(byteAllocationFlag) ;
2486: EE61 B7                     OR     A                    ;
2487: EE62 28 10                  JR     Z,MergeWordMaps      ; Process Word size Block Numbers   ;
2488: EE64         ; process byte size Map	                                                    ;
2489: EE64 7E                     LD     A,(HL)               ; FCB Block number                  ;
2490: EE65 B7                     OR     A                    ; Is it 0 ?                         ;
2491: EE66 1A                     LD     A,(DE)               ;  anticipate yes                   ;
2492: EE67 20 01                  JR     NZ,MergeFCBisNot0    ;  Skip if no	                    ;
2493: EE69 77                     LD     (HL),A               ; Move Dir Entry Value to FCB		;
2494: EE6A             MergeFCBisNot0:                      ;
2495: EE6A B7                     OR     A                    ; Is Dir Entry Value = 0 ?          ;
2496: EE6B 20 02                  JR     NZ,MergeDirEntryNot0 ; Skip if no                        ;
2497: EE6D 7E                     LD     A,(HL)               ;  else move FCB map value          ;
2498: EE6E 12                     LD     (DE),A               ;  to Dir Entry Value 	            ;
2499: EE6F             MergeDirEntryNot0:                      ;
2500: EE6F BE                     CP     M                    ; Do FCB and Dir match values       ;
2501: EE70 20 39                  JR     NZ,CloseDirEntryError ;  If not then report error         ;
2502: EE72 18 13                  JR     MergeMapLoop         ; Go see if there is more           ;
2503: EE74         ;
2504: EE74             MergeWordMaps:                      ;
2505: EE74 CD 11 F3               CALL   Merge                ; If FCB map value = 0 move Dir's   ;
2506: EE77 EB                     EX     DE,HL                ;
2507: EE78 CD 11 F3               CALL   Merge                ; IF Dir Map value = 0 move FCB's   ;
2508: EE7B EB                     EX     DE,HL                ; HL = FCB Map pointer, DE = Dir's  ;
2509: EE7C 1A                     LD     A,(DE)               ; Does the FCB Map value            ;
2510: EE7D BE                     CP     M                    ;  = Dir record Map pointer ?       ;
2511: EE7E 20 2B                  JR     NZ,CloseDirEntryError ;  If not then report error         ;
2512: EE80 13                     INC    DE                   ;
2513: EE81 23                     INC    HL                   ; move on to the MSB                ;
2514: EE82 1A                     LD     A,(DE)               ;
2515: EE83 BE                     CP     M                    ; do the check for equality         ;
2516: EE84 20 25                  JR     NZ,CloseDirEntryError ;  If not then report error         ;
2517: EE86 0D                     DEC    C                    ; Extra count for 2 bytes           ;
2518: EE87             MergeMapLoop:                      ;
2519: EE87 13                     INC    DE                   ; Advance to the next positions     ;
2520: EE88 23                     INC    HL                   ; in The Maps                       ;
2521: EE89 0D                     DEC    C                    ; Are we done ?                     ;
2522: EE8A 20 D2                  JR     NZ,MergeAllocationMaps ;  No, do it again                  ;
2523: EE8C         ;
2524: EE8C         ; Check the EXT                                                             ;
2525: EE8C 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;Adjust to get Ext pointer          ;
2526: EE8F 09                     ADD    HL,BC                ;
2527: EE90 EB                     EX     DE,HL                ; HL = Directory Entry EXT pointer  ;
2528: EE91 09                     ADD    HL,BC                ; DE = FCB EXT Pointer              ;
2529: EE92 1A                     LD     A,(DE)               ; FCB's extent number               ;
2530: EE93 BE                     CP     M                    ; Is it < Dir Record EXT ?          ;
2531: EE94 38 09                  JR     C,CloseDirEntryEnd   ;  we are done if yes               ;
2532: EE96 77                     LD     (HL),A               ; Else replace the Dir Record EXT   ;
2533: EE97         ; Update directory record count field                                       ;
2534: EE97 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ; Need to adjust to the record Count;
2535: EE9A 09                     ADD    HL,BC                ;
2536: EE9B EB                     EX     DE,HL                ; DE = = Directory Entry EXT pointer;
2537: EE9C 09                     ADD    HL,BC                ; HL = FCB EXT Pointer              ;
2538: EE9D 7E                     LD     A,(HL)               ; Copy the FCB RC to                ;
2539: EE9E 12                     LD     (DE),A               ;  the Directory Record RC          ;
2540: EE9F         ;
2541: EE9F             CloseDirEntryEnd:                      ;
2542: EE9F 3E FF                  LD     A,TRUE               ;
2543: EEA1 32 A2 F4               LD     (fcbCopiedFlag),A    ; Set copied flag as true           ;
2544: EEA4         ;/	CALL	SeekCopy					; ok to "Write Dir" here            ;
2545: EEA4 CD 5C F3               CALL   SeekDir              ; Set up parameters for a Disk I/O  ;
2546: EEA7 C3 5A F0               JP     WriteDir             ; Write the directory element       ;
2547: EEAA C9                     RET                         ;
2548: EEAB         ;
2549: EEAB             CloseDirEntryError:                      ;
2550: EEAB 21 B6 EA               LD     HL,exitParameterByte ;
2551: EEAE 35                     DEC    M                    ; Set Exit value to 0FFH            ;
2552: EEAF C9                     RET                         ;
2553: EEB0         ;---------------------------- Close Directory Entry ------------------------;
2554: EEB0         ;----------------------------------- Make new File -------------------------;
2555: EEB0         ;create a new file by creating a directory entry then opening the file      ;
2556: EEB0             MakeNewFile:                      ;
2557: EEB0 CD 1A F2               CALL   CheckWrite           ; Terminate with error if Disk R/O  ;
2558: EEB3 2A B4 EA               LD     HL,(paramDE)         ; Get the FCB                       ;
2559: EEB6 E5                     PUSH   HL                   ; FCB                               ;
2560: EEB7 21 7B F4               LD     HL,emptyFCB          ;
2561: EEBA 22 B4 EA               LD     (paramDE),HL         ; Find the first empty dir record   ;
2562: EEBD 0E 01                  LD     C,1                  ;
2563: EEBF CD E7 EF               CALL   SearchForDirectoryRecord ; 0F5H in first position            ;
2564: EEC2 CD 38 F1               CALL   AtEndOfDirectory     ; Check if at end of directory      ;
2565: EEC5 E1                     POP    HL                   ; Recall the FCB pointer            ;
2566: EEC6 22 B4 EA               LD     (paramDE),HL         ;  in case we return here           ;
2567: EEC9 C8                     RET    Z                    ; Exit with No Dir space error      ;
2568: EECA         ; fill Allocation Map with Zeros	                                        ;
2569: EECA 11 0F 00               LD     DE,nameLength        ;
2570: EECD 19                     ADD    HL,DE                ; Start of fill                     ;
2571: EECE 36 00                  LD     (HL),00              ; Prime the values                  ;
2572: EED0 E5                     PUSH   HL                   ;
2573: EED1 D1                     POP    DE                   ; Copy to DE                        ;
2574: EED2 13                     INC    DE                   ; adjust the to pointer             ;
2575: EED3 01 10 00               LD     BC,fcbLength-nameLength-1 ; number of bytes to fill           ;
2576: EED6 ED B0                  LDIR                        ;
2577: EED8         ;
2578: EED8 2A B4 EA               LD     HL,(paramDE)         ; get FCB                           ;
2579: EEDB 11 0D 00               LD     DE,fcbS1Index        ; Get the S1 index                  ;
2580: EEDE 19                     ADD    HL,DE                ; Point to S1                       ;
2581: EEDF 36 00                  LD     (HL),0               ; Set to 0                          ;
2582: EEE1 CD 4F F1               CALL   SetDirectoryEntry    ; Update directory entry            ;
2583: EEE4 CD 2E F2               CALL   CopyFCB              ; Update dir entry to Disk          ;
2584: EEE7         ; and set the file write flag to "1"                                        ;
2585: EEE7 C3 CA EF               JP     SetFileWriteFlag     ; Set the clean entry flag          ;
2586: EEEA         ;----------------------------------- Make new File -------------------------;
2587: EEEA
2588: EEEA         ;=========================== Disk Utilities ================================;
2589: EEEA
2590: EEEA         ;--------------------------- Home The Current Disk -------------------------;
2591: EEEA         ;move to home position, then offset to start of dir                         ;
2592: EEEA             Home:                           ;
2593: EEEA CD 18 F6               CALL   bcHome               ; Sets Track to 0, and checks       ;
2594: EEED         ; if Buffer needs to be written     ;
2595: EEED 21 9D F4               LD     HL,dpbOFF            ; Number of tracks before directory ;
2596: EEF0 4E                     LD     C,(HL)               ;
2597: EEF1 23                     INC    HL                   ;
2598: EEF2 46                     LD     B,(HL)               ;
2599: EEF3 CD 1E F6               CALL   bcSettrk             ; Point at 1st directory position   ;
2600: EEF6         ;
2601: EEF6         ; Set Current Track and Sector to 00                                        ;
2602: EEF6 AF                     XOR    A                    ; set ACC to 00                     ;
2603: EEF7 2A 84 F4               LD     HL,(caTrack)         ;
2604: EEFA 77                     LD     (HL),A               ;
2605: EEFB 23                     INC    HL                   ;
2606: EEFC 77                     LD     (HL),A               ;
2607: EEFD 2A 86 F4               LD     HL,(caSector)        ;
2608: EF00 77                     LD     (HL),A               ;
2609: EF01 23                     INC    HL                   ;
2610: EF02 77                     LD     (HL),A               ;
2611: EF03 C9                     RET                         ;
2612: EF04         ;
2613: EF04         ;--------------------------- Home The Current Disk -------------------------;
2614: EF04         ;--------------------------- Set DMAs --------------------------------------;
2615: EF04             SetDataDMA:                      ;
2616: EF04 21 80 F4               LD     HL,initDAMAddress    ;
2617: EF07 18 03                  JR     SetDMA               ; Skip to complete the call         ;
2618: EF09         ;
2619: EF09             SetDirDMA:                      ;
2620: EF09 21 88 F4               LD     HL,caDirectoryDMA    ; Load current directory Buffer     ;
2621: EF0C         ;
2622: EF0C             SetDMA:                         ;
2623: EF0C 4E                     LD     C,(HL)               ;
2624: EF0D 23                     INC    HL                   ;
2625: EF0E 46                     LD     B,(HL)               ; parameter ready               ;
2626: EF0F C3 24 F6               JP     bcSetdma             ; call bios to set              ;
2627: EF12         ;--------------------------- Set DMAs --------------------------------------;
2628: EF12         ;--------------------------- Read Buffer -----------------------------------;
2629: EF12         ;reads into current DMA, using current Disk,Track and Sector                ;
2630: EF12             ReadBuffer:                      ;
2631: EF12 CD 27 F6               CALL   bcRead               ; Do the read at the BIOS level     ;
2632: EF15 B7                     OR     A                    ; Check status                      ;
2633: EF16 C2 1A F4               JP     NZ,Error_BadSector   ; Report if Status not OK		;
2634: EF19 C9                     RET                         ;
2635: EF1A         ;--------------------------- Read Buffer -----------------------------------;
2636: EF1A         ;--------------------------- Set Current Disk Read Only --------------------;
2637: EF1A         ;set current disk to read only                                              ;
2638: EF1A             SetDiskReadOnly:                      ;
2639: EF1A 2A 7C F4               LD     HL,(readOnlyVector)  ; Get the Vector                    ;
2640: EF1D         ;
2641: EF1D 3A 7A F4               LD     A,(currentDisk)      ; Get the current disk              ;
2642: EF20 47                     LD     B,A                  ; Move into B                       ;
2643: EF21 CD EA F3               CALL   SetVectorBit         ; Set the bit	                    ;
2644: EF24 22 7C F4               LD     (readOnlyVector),HL  ; Update the Vector                 ;
2645: EF27         ;
2646: EF27 2A 97 F4               LD     HL,(dpbDRM)          ; Directory Max Value               ;
2647: EF2A EB                     EX     DE,HL                ;
2648: EF2B 2A 82 F4               LD     HL,(caDirMaxValue)   ; HL = .Directory max value         ;
2649: EF2E 73                     LD     (HL),E               ;
2650: EF2F 23                     INC    HL                   ;
2651: EF30 72                     LD     (HL),D               ;
2652: EF31 C9                     RET                         ;
2653: EF32         ;--------------------------- Set disk Read Only ----------------------------;
2654: EF32         ;--------------------------- Is Disk Write Protected -----------------------;
2655: EF32         ;Returns:	Z flag	= Set if not Write Protected	(Z)                     ;
2656: EF32         ;					= reset if Write Protected		(NZ)					;
2657: EF32             IsDiskWriteProtected:                      ;
2658: EF32 2A 7C F4               LD     HL,(readOnlyVector)  ; Get Read Only Vector              ;
2659: EF35 3A 7A F4               LD     A,(currentDisk)      ; Get current disk                  ;
2660: EF38 47                     LD     B,A                  ;
2661: EF39 CD DA F3               CALL   IsBitSet             ; Check the bit                     ;
2662: EF3C C9                     RET                         ; NZ if Disk is RO                  ;
2663: EF3D         ;--------------------------- Is Disk Write Protected -----------------------;
2664: EF3D
2665: EF3D         ;------------------------- Reselect Disk if Necessary ----------------------;
2666: EF3D         ;check current fcb to see if reselection necessary                         ;
2667: EF3D             ReselectDisk:                      ;
2668: EF3D 3E FF                  LD     A,TRUE               ;
2669: EF3F 32 AA F4               LD     (fResel),A           ; Mark as possible reselect         ;
2670: EF42 2A B4 EA               LD     HL,(paramDE)         ; Point at current FCB              ;
2671: EF45 7E                     LD     A,(HL)               ; Load disk drive (0 = current)     ;
2672: EF46 E6 1F                  AND    01FH                 ; Mask out user Number ??           ;
2673: EF48 3D                     DEC    A                    ; Normalized to 0..29, or 255       ;
2674: EF49 32 B3 EA               LD     (paramE),A           ; Save drive code                   ;
2675: EF4C FE 1E                  CP     30                   ;
2676: EF4E 30 10                  JR     NC,NoSelect          ; Skip drive >= 30                  ;
2677: EF50         ;
2678: EF50 3A 7A F4               LD     A,(currentDisk)      ; Determine the current drive       ;
2679: EF53 32 AB F4               LD     (entryDisk),A        ; Save it                           ;
2680: EF56 7E                     LD     A,(HL)               ;
2681: EF57 32 AC F4               LD     (fcbDisk),A          ; Get calling disk                  ;
2682: EF5A E6 E0                  AND    11100000B            ;
2683: EF5C 77                     LD     (HL),A               ; Preserve User Number              ;
2684: EF5D CD 16 ED               CALL   SelectCurrent        ; Select the new disk               ;
2685: EF60         ;
2686: EF60             NoSelect:                       ;
2687: EF60 3A 79 F4               LD     A,(currentUserNumber) ; Get user code 0...31              ;
2688: EF63 2A B4 EA               LD     HL,(paramDE)         ; Point at disk number              ;
2689: EF66 B6                     OR     M                    ; Combine                           ;
2690: EF67 77                     LD     (HL),A               ; FCB[0] = user number & disk       ;
2691: EF68 C9                     RET                         ;
2692: EF69         ;------------------------- Reselect Disk if Necessary ----------------------;
2693: EF69
2694: EF69
2695: EF69         ;=========================== Disk Utilities ================================;
2696: EF69
2697: EF69         ;=========================== File Utilities ================================;
2698: EF69         ;--------------------------- Set Record Variables --------------------------;
2699: EF69         ;set variables from currently FCB - Current Record, RC, EXM                 ;
2700: EF69             SetRecordVars:                      ;
2701: EF69 CD 80 EF               CALL   GetFcbRecordDetails  ; DE = .RecordCount                 ;
2702: EF6C         ;  and HL => .CurrentRecord         ;
2703: EF6C 7E                     LD     A,(HL)               ;
2704: EF6D 32 AF F4               LD     (currentFileRecord),A ; Save current record               ;
2705: EF70 EB                     EX     DE,HL                ;
2706: EF71 7E                     LD     A,(HL)               ;
2707: EF72 32 AD F4               LD     (fcbRecordCount),A   ; Save the FCBs RC                  ;
2708: EF75 CD 8D EF               CALL   GetExtentAddress     ; HL=.FCB(fcbExtIndex)              ;
2709: EF78 3A 94 F4               LD     A,(dpbEXM)           ; Extent mask                       ;
2710: EF7B A6                     AND    M                    ; Remove unwanted bits              ;
2711: EF7C 32 AE F4               LD     (extentValue),A      ; Store the value                   ;
2712: EF7F C9                     RET                         ;
2713: EF80         ;--------------------------- Set Record Variables --------------------------;
2714: EF80         ;----------------------Get File Record Count and Current Record-------------;
2715: EF80         ; returns with DE pointing at RC from FCB                                   ;
2716: EF80         ;         with HL pointing at Current Record                                ;
2717: EF80             GetFcbRecordDetails:                      ;
2718: EF80 2A B4 EA               LD     HL,(paramDE)         ; Get FCB start                     ;
2719: EF83 11 0F 00               LD     DE,fcbRCIndex        ; Offset to Record Count            ;
2720: EF86 19                     ADD    HL,DE                ;
2721: EF87 EB                     EX     DE,HL                ; DE Points to Record Count         ;
2722: EF88 21 11 00               LD     HL,recordSeq-fcbRCIndex ;
2723: EF8B 19                     ADD    HL,DE                ; HL Points to Current Record       ;
2724: EF8C C9                     RET                         ;
2725: EF8D         ;----------------------Get File Record Count and Current Record-------------;
2726: EF8D         ;----------------------Get FileExtent---------------------------------------;
2727: EF8D         ;get current extent field address to (HL)                                  ;
2728: EF8D             GetExtentAddress:                      ;
2729: EF8D 2A B4 EA               LD     HL,(paramDE)         ; Get FCB                           ;
2730: EF90 11 0C 00               LD     DE,fcbExtIndex       ; Get EXT offset                    ;
2731: EF93 19                     ADD    HL,DE                ; HL=.fcb(fcbExtIndex)              ;
2732: EF94 C9                     RET                         ;
2733: EF95         ;----------------------Get FileExtent---------------------------------------;
2734: EF95         ;--------------------- Set/Reset Disk Map Allocation Bit -------------------;
2735: EF95         ; At Entry:	BC Contains to the Block to be modified                         ;
2736: EF95         ;			E  = TRUE if bit is to be set                                   ;
2737: EF95         ;			E  <> TRUE if bit is to be reset                                ;
2738: EF95         ; At Exit:  The target bit in the target Octet will be set/reset	        ;
2739: EF95             SetResetMapBit:                      ;
2740: EF95         ;
2741: EF95 21 00 00               LD     HL,0000H             ; Move the block number from BC     ;
2742: EF98 09                     ADD    HL,BC                ;  to HL                            ;
2743: EF99 4B                     LD     C,E                  ; Move the flag to E                ;
2744: EF9A         ;
2745: EF9A 7D                     LD     A,L                  ; LSB of the Block Number           ;
2746: EF9B E6 07                  AND    07H                  ; Calculate Mod(Block,8)            ;
2747: EF9D F5                     PUSH   AF                   ; Save the OctetBit                 ;
2748: EF9E 06 03                  LD     B,3                  ;
2749: EFA0 CD FF F2               CALL   ShiftRightHLbyB      ; Calculate Block / 8               ;
2750: EFA3 ED 5B 8E F4               LD     DE,(caAllocVector)   ; Start Of Map                      ;
2751: EFA7 19                     ADD    HL,DE                ; Address of targeted Octet         ;
2752: EFA8 F1                     POP    AF                   ;
2753: EFA9 47                     LD     B,A                  ; Get the bit                       ;
2754: EFAA         ;
2755: EFAA 04                     INC    B                    ; Adjust for looping                ;
2756: EFAB C5                     PUSH   BC                   ; Will need this later              ;
2757: EFAC             Left:                           ;
2758: EFAC CB 16                  RL     (HL)                 ; Rotate the Octet                  ;
2759: EFAE 10 FC                  DJNZ   Left                 ;  to move target bit to bit 0      ;
2760: EFB0 C1                     POP    BC                   ; Restore loop limit and            ;
2761: EFB1 37                     SCF                         ;  set/reset flag                   ;
2762: EFB2 0C                     INC    C                    ; was C = TRUE                      ;
2763: EFB3 28 01                  JR     Z,Right              ; Skip if Set                       ;
2764: EFB5 3F                     CCF                         ; Set for Reset                     ;
2765: EFB6             Right:                          ;
2766: EFB6 CB 1E                  RR     (HL)                 ; Move the Octet back               ;
2767: EFB8 10 FC                  DJNZ   Right                ;  to its original alignment        ;
2768: EFBA C9                     RET                         ;
2769: EFBB         ;--------------------- Set/Reset Disk Map Allocation Bit -------------------;
2770: EFBB         ;--------------------- Initialize Extent Number MSB ------------------------;
2771: EFBB         ;clear the Extent number field for user open/make (S2)                     ;
2772: EFBB             InitializeExtentNumberMSB:                      ;
2773: EFBB CD C1 EF               CALL   GetExtentNumberMSB   ;
2774: EFBE 36 00                  LD     (HL),0               ; Set it to = 0             ;
2775: EFC0 C9                     RET                         ;
2776: EFC1         ;--------------------- Initialize Extent Number MSB ------------------------;
2777: EFC1         ;--------------------- Get Extent Number MSB| Write Protect ----------------;
2778: EFC1         ; Get S2 value                                                              ;
2779: EFC1         ;  Returns:	A = S2 Value (bit 7 write protect, bits 0-6 Ext MSB)            ;
2780: EFC1         ;			HL = Address of S2 for the FCB pointed to by paramDE            ;
2781: EFC1             GetWriteFileFlagValue:                      ; S2 bit 7                  ;
2782: EFC1             GetExtentNumberMSB:                      ; S2 bits 0-6               ;
2783: EFC1 2A B4 EA               LD     HL,(paramDE)         ; FCB address               ;
2784: EFC4 11 0E 00               LD     DE,fcbS2Index        ; Index to value            ;
2785: EFC7 19                     ADD    HL,DE                ; Address of value          ;
2786: EFC8 7E                     LD     A,(HL)               ; load into ACC             ;
2787: EFC9 C9                     RET                         ;
2788: EFCA         ;--------------------- Get Extent Number MSB| Write Protect ----------------;
2789: EFCA         ;--------------------------- Set File Write Flag----------------------------;
2790: EFCA         ;Set file write flag in FCB in (paramDE)									;
2791: EFCA         ; Used to indicate the FCB is clean. No need to write on close				;
2792: EFCA             SetFileWriteFlag:                      ;
2793: EFCA CD C1 EF               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2794: EFCD CB FE                  SET    7,(HL)               ; Set the FileWriteFlag				;
2795: EFCF C9                     RET                         ;
2796: EFD0         ;?	OR		writeFlagMask				; Set the flag , bit 7 of S2        ;
2797: EFD0         ;?	LD		(HL),A						; Put into FCB                      ;
2798: EFD0         ;?	RET	                                                                    ;
2799: EFD0         ;--------------------------- Set File Write Flag----------------------------;
2800: EFD0         ;--------------------------- Reset File Write Flag--------------------------;
2801: EFD0         ;Reset file write flag in FCB in (paramDE)									;
2802: EFD0         ; Used to indicate the FCB is dirty. Need to write on close					;
2803: EFD0             ResetFileWriteFlag:                      ;
2804: EFD0 CD C1 EF               CALL   GetWriteFileFlagValue ; A= Value, HL = Address of fcbS2   ;
2805: EFD3 CB BE                  RES    7,(HL)               ; Reset the FileWriteFlag			;
2806: EFD5 C9                     RET                         ;
2807: EFD6         ;?	AND		0FFH-writeFlagMask			; Remove the flag bit		        ;
2808: EFD6         ;?	LD		(HL),A						; Put into FCB                      ;
2809: EFD6         ;?	RET	                                                                    ;
2810: EFD6         ;--------------------------- Reset File Write Flag--------------------------;
2811: EFD6         ;-------------------------- Compare FCB Extents ----------------------------;
2812: EFD6         ; Enters:	A containing Target FCB EXT value								;
2813: EFD6         ;			HL Points at Possible FCB EXT value								;
2814: EFD6         ;compare extent# in A with that in C, return nonzero if they do not match	;
2815: EFD6             CompareExtents:                      ;
2816: EFD6 C5                     PUSH   BC                   ; Save Callers Registers			;
2817: EFD7 F5                     PUSH   AF                   ; Save Target FCB EXT value    		;
2818: EFD8 3A 94 F4               LD     A,(dpbEXM)           ; Load the Extent Mask         		;
2819: EFDB 2F                     CPL                         ; Complement for And           		;
2820: EFDC 47                     LD     B,A                  ; Put negated Mask into B      		;
2821: EFDD 7E                     LD     A,(HL)               ; Get Possible FCBs EXT        		;
2822: EFDE A0                     AND    B                    ; Apply the Mask               		;
2823: EFDF 4F                     LD     C,A                  ; Low bits removed from C      		;
2824: EFE0 F1                     POP    AF                   ; Restore Target FCB EXT value 		;
2825: EFE1 A0                     AND    B                    ; Apply the Mask               		;
2826: EFE2 91                     SUB    C                    ; Test if Equal ( Z Flag)      		;
2827: EFE3 E6 1F                  AND    maxExtValue          ; Limit Size ?                 		;
2828: EFE5 C1                     POP    BC                   ; Restore Callers Registers    		;
2829: EFE6 C9                     RET                         ;
2830: EFE7         ;-------------------------- Compare FCB Extents ----------------------------;
2831: EFE7         ;---------------------Search for Directory Record --------------------------;
2832: EFE7         ;  Search for directory record of length C.									;
2833: EFE7         ; Target is pointed to by paramDE. The whole directory is searched.			;
2834: EFE7         ; If not found then dirEntryIndex is set to -1, else it points to the		;
2835: EFE7         ; matched directory record													;
2836: EFE7         ; Entry:	C = Search Length                                               ;
2837: EFE7         ; Exit		dirEntryIndex  =	Matched directory index, if found			;
2838: EFE7         ;								-1 (EOD) if there is no match				;
2839: EFE7             SearchForDirectoryRecord:                      ;
2840: EFE7 3E FF                  LD     A,0FFH               ;
2841: EFE9 32 A4 F4               LD     (directoryIndex),A   ; Initialize directory Index        ;
2842: EFEC 21 A6 F4               LD     HL,searchLength      ;
2843: EFEF 71                     LD     (HL),C               ; Save Search Length                ;
2844: EFF0 2A B4 EA               LD     HL,(paramDE)         ; Active FCB                        ;
2845: EFF3 22 A7 F4               LD     (searchAddress),HL   ; Start of search                   ;
2846: EFF6 CD 31 F1               CALL   SetEndDirectory      ; DirEntryIndex = -1                ;
2847: EFF9 CD EA EE               CALL   Home                 ; Reset Disk,Track, & Sector        ;
2848: EFFC         ;
2849: EFFC             GetNextDirectoryRecord:                      ;
2850: EFFC 0E 00                  LD     C,FALSE              ;
2851: EFFE CD 2E F3               CALL   ReadDirectory        ; Read next Dir Record              ;
2852: F001 CD 38 F1               CALL   AtEndOfDirectory     ;
2853: F004 28 4B                  JR     Z,NoDirRecordsMatch  ; Done if at EOD                ;
2854: F006         ;
2855: F006 2A A7 F4               LD     HL,(searchAddress)   ; Get Current Dir Entry             ;
2856: F009 EB                     EX     DE,HL                ; DE=beginning of Directory Entry   ;
2857: F00A 1A                     LD     A,(DE)               ; User Number                       ;
2858: F00B FE E5                  CP     emptyDir             ; Is Dir entry is empty             ;
2859: F00D 28 07                  JR     Z,GetNextDirectoryRecord1 ; Skip if empty                     ;
2860: F00F         ;
2861: F00F         ; Check to be sure we are sill in the Directory                             ;
2862: F00F D5                     PUSH   DE                   ; Save search address               ;
2863: F010 CD 58 F1               CALL   StillInDirectory     ; Still in the directorY            ;
2864: F013 D1                     POP    DE                   ; Recall address                    ;
2865: F014 30 3B                  JR     NC,NoDirRecordsMatch ; Get out if past directory			;
2866: F016         ;
2867: F016             GetNextDirectoryRecord1:                      ;
2868: F016 CD 41 F1               CALL   GetCurrentDirectoryRecord ; Point at next directory record    ;
2869: F019 3A A6 F4               LD     A,(searchLength)     ;
2870: F01C 4F                     LD     C,A                  ; SearchLength to c (down)          ;
2871: F01D 06 00                  LD     B,0                  ; Character Index (up)              ;
2872: F01F         ;
2873: F01F             TestNextPosition:                      ;
2874: F01F 1A                     LD     A,(DE)               ;
2875: F020 FE 3F                  CP     QMARK                ; ? is always a char match          ;
2876: F022 28 16                  JR     Z,SetNextPosition    ; Done with this if it is ?		;
2877: F024         ;
2878: F024 78                     LD     A,B                  ;
2879: F025 FE 0D                  CP     fcbS1Index           ; At File S1 position ?             ;
2880: F027 28 11                  JR     Z,SetNextPosition    ; Done with this if it is ?		;
2881: F029         ; not the fcbS1Index field, extent field?                                  ;
2882: F029 FE 0C                  CP     fcbExtIndex          ; Past File Type position ?         ;
2883: F02B 1A                     LD     A,(DE)               ; Get next character                ;
2884: F02C 28 07                  JR     Z,CheckExtents       ; Skip to search extent             ;
2885: F02E 96                     SUB    M                    ; Do they match ?                   ;
2886: F02F E6 7F                  AND    07FH                 ; Strip MSBit                       ;
2887: F031 20 C9                  JR     NZ,GetNextDirectoryRecord ; Skip if not matched               ;
2888: F033 18 05                  JR     SetNextPosition      ; Matched the character             ;
2889: F035         ;                                                                           ;
2890: F035             CheckExtents:                      ;
2891: F035 CD D6 EF               CALL   CompareExtents       ; Matching EXTs is work             ;
2892: F038 20 C2                  JR     NZ,GetNextDirectoryRecord ; Get out if not matched            ;
2893: F03A         ;
2894: F03A             SetNextPosition:                      ;
2895: F03A 13                     INC    DE                   ; Pointer to Looking FOR            ;
2896: F03B 23                     INC    HL                   ; Pointer to Looking IN             ;
2897: F03C 04                     INC    B                    ; Character Index in FCB            ;
2898: F03D 0D                     DEC    C                    ; Length of search                  ;
2899: F03E 20 DF                  JR     NZ,TestNextPosition  ;
2900: F040         ; Match Found, entire name matches                                          ;
2901: F040 3A B4 F4               LD     A,(dirEntryIndex)    ; Get current Directory Index       ;
2902: F043 E6 03                  AND    dirEntryMask         ; Apply the mask                    ;
2903: F045 32 B6 EA               LD     (exitParameterByte),A ; Put 0...3. Match FOund            ;
2904: F048         ;
2905: F048 21 A4 F4               LD     HL,directoryIndex    ; Point at Directory Flag           ;
2906: F04B 7E                     LD     A,(HL)               ; Get value                         ;
2907: F04C 17                     RLA                         ; Set Carry if Flag = -1            ;
2908: F04D D0                     RET    NC                   ; Return with flag still -1         ;
2909: F04E         ;
2910: F04E AF                     XOR    A                    ; Else Clear the flag               ;
2911: F04F 77                     LD     (HL),A               ;
2912: F050 C9                     RET                         ;  and exit                         ;
2913: F051         ;------                                                                     ;
2914: F051             NoDirRecordsMatch:                      ;
2915: F051 CD 31 F1               CALL   SetEndDirectory      ; Set End of Directory -1           ;
2916: F054 3E FF                  LD     A,-1                 ; Put Failure Code                  ;
2917: F056 32 B6 EA               LD     (exitParameterByte),A ;  into return parameter            ;
2918: F059 C9                     RET                         ;
2919: F05A         ;---------------------Search for Directory Record --------------------------;
2920: F05A         ;---------------------------- Write Current Directory Entry ----------------;
2921: F05A             WriteDir:                       ;
2922: F05A         ;	CALL	NewCheckSum						; initialize entry              ;
2923: F05A 0E FF                  LD     C,TRUE               ;
2924: F05C CD AB F3               CALL   CheckSumUtility      ; Set New CheckSum              ;
2925: F05F         ;
2926: F05F CD 09 EF               CALL   SetDirDMA            ; Directory DMA                 ;
2927: F062 0E 01                  LD     C,WriteDirectory     ; Write type                    ;
2928: F064 CD 6A F0               CALL   WriteBuffer          ; Write the buffer              ;
2929: F067 C3 04 EF               JP     SetDataDMA           ; Reset DMA to default			;
2930: F06A         ;
2931: F06A         ;---------------------------- Write Current Directory Entry ----------------;
2932: F06A         ;----------------------------------- Write Buffer --------------------------;
2933: F06A         ; Write buffer and check result. Current drive,Track, Sector and DMA		;
2934: F06A         ; Are set up prior to calling this routine                                  ;
2935: F06A         ;                                                                           ;
2936: F06A         ; On Entry: C = 0 => normal write operation		WriteAllocated              ;
2937: F06A         ;				1 => directory write operation	WriteDirectory              ;
2938: F06A         ;				2 => start of new block			WriteCleanBuffer			;
2939: F06A             WriteBuffer:                      ;
2940: F06A CD 2A F6               CALL   bcWrite              ; Call into BIOS                    ;
2941: F06D B7                     OR     A                    ; Get return code                   ;
2942: F06E C2 1A F4               JP     NZ,Error_BadSector   ; Error if not 00                   ;
2943: F071 C9                     RET                         ;
2944: F072         ;----------------------------------- Write Buffer --------------------------;
2945: F072         ;---------------------------- Update Record Vars ---------------------------;
2946: F072         ;update variables from I/O in  FCB                                          ;
2947: F072             UpdateRecordVariables:                      ;
2948: F072 CD 80 EF               CALL   GetFcbRecordDetails  ; DE => FCB RC, HL => CurrentRecord ;
2949: F075 3A 9F F4               LD     A,(diskAccessType)   ; If Seq IO it is set to 1			;
2950: F078 4F                     LD     C,A                  ;  and move it to C                 ;
2951: F079 3A AF F4               LD     A,(currentFileRecord) ; Get NEXT_RECORD                   ;
2952: F07C 81                     ADD    A,C                  ; Update record count               ;
2953: F07D 77                     LD     (HL),A               ;  for CurrentRecord                ;
2954: F07E EB                     EX     DE,HL                ;
2955: F07F 3A AD F4               LD     A,(fcbRecordCount)   ;
2956: F082 77                     LD     (HL),A               ;  and FCB RC                       ;
2957: F083 C9                     RET                         ;
2958: F084         ;---------------------------- Update Record Vars ---------------------------;
2959: F084         ;-------------------------------- Random Seek ------------------------------;
2960: F084         ;  Record # = |000M EEEE| |ERRR RRRR|                                       ;
2961: F084         ;		M => Module                                                         ;
2962: F084         ;		E => Extent                                                         ;
2963: F084         ;		R => Record in Extent                                               ;
2964: F084             RandomSeek:                      ;
2965: F084 AF                     XOR    A                    ;
2966: F085 32 9F F4               LD     (diskAccessType),A   ; Set random access                 ;
2967: F088 C5                     PUSH   BC                   ; Save Read(TRUE) / Write (FALSE)   ;
2968: F089         ;?	LD		HL,(paramDE)				; Get the FCB                       ;
2969: F089         ;?	PUSH	HL                                                              ;
2970: F089         ;?	POP		IX							; IX has the FCB address            ;
2971: F089 DD 2A B4 EA               LD     IX,(paramDE)         ; Get the FCB						;
2972: F08D DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record        ;
2973: F090 E6 7F                  AND    7FH                  ; Strip E , left with |0RRR RRRR|   ;
2974: F092 F5                     PUSH   AF                   ; recordSEQ                         ;
2975: F093 DD 7E 21               LD     A,(IX+recordRandomLSB) ; Get LSB from Random Record        ;
2976: F096 17                     RLA                         ; CY = bit 7 from LSB (M's LSBit)   ;
2977: F097 DD 7E 22               LD     A,(IX+recordRandomMSB) ; Get MSB from Random Record        ;
2978: F09A F5                     PUSH   AF                   ; Random record's MSB               ;
2979: F09B 17                     RLA                         ; Shift LSBit into E |00ME EEEE|    ;
2980: F09C E6 1F                  AND    01FH                 ; Extent mask                       ;
2981: F09E 4F                     LD     C,A                  ; Extent is in C                    ;
2982: F09F F1                     POP    AF                   ; Random record's MSB               ;
2983: F0A0 1F                     RRA                         ;
2984: F0A1 1F                     RRA                         ;
2985: F0A2 1F                     RRA                         ;
2986: F0A3 1F                     RRA                         ; MSB's Hi Nibble                   ;
2987: F0A4 E6 0F                  AND    00FH                 ;  moved to Lo Nibble               ;
2988: F0A6 47                     LD     B,A                  ; S2' value in B                    ;
2989: F0A7 F1                     POP    AF                   ; recordSEQ                         ;
2990: F0A8         ;
2991: F0A8 DD 6E 23               LD     L,(IX+recordRandomOVF) ;
2992: F0AB 2C                     INC    L                    ; Insure that high byte             ;
2993: F0AC 2D                     DEC    L                    ;  of ran rec = 00                  ;
2994: F0AD 2E 06                  LD     L,06                 ; "attempt to read beyond end of disk"  ;
2995: F0AF 20 4B                  JR     NZ,RandomSeekError   ;
2996: F0B1         ;
2997: F0B1 DD 77 20               LD     (IX+recordSeq),A     ; Put target record # in FCB	    ;
2998: F0B4 DD 7E 0C               LD     A,(IX+fcbExtIndex)   ; Target EXT in A, FCB EXT in C     ;
2999: F0B7 B9                     CP     C                    ; Are we in the right directory ?	;
3000: F0B8 20 08                  JR     NZ,RandomSeekClose   ;  Skip if not                      ;
3001: F0BA         ;
3002: F0BA DD 7E 0E               LD     A,(IX+fcbS2Index)    ; Target S2 in A, FCB S2 in C       ;
3003: F0BD B8                     CP     B                    ; Still in the right directory ?    ;
3004: F0BE E6 7F                  AND    7FH                  ; Mask out MSBit                    ;
3005: F0C0 28 30                  JR     Z,RandomSeekExit     ;  Exit if yes                      ;
3006: F0C2         ;
3007: F0C2             RandomSeekClose:                      ;
3008: F0C2 C5                     PUSH   BC                   ; Save EXT                          ;
3009: F0C3 D5                     PUSH   DE                   ; Save FCB                          ;
3010: F0C4 CD 39 EE               CALL   CloseDirEntry        ; Close this directory entry        ;
3011: F0C7 D1                     POP    DE                   ; FCB                               ;
3012: F0C8 C1                     POP    BC                   ; EXT                               ;
3013: F0C9 2E 03                  LD     L,03                 ; "CP/M could not close current extent" ;
3014: F0CB 3A B6 EA               LD     A,(exitParameterByte) ; Get result from Close             ;
3015: F0CE 3C                     INC    A                    ;
3016: F0CF 28 27                  JR     Z,RandomSeekErrorBadSeek ; Error exit if 0FFH                ;
3017: F0D1         ;
3018: F0D1 DD 71 0C               LD     (IX+fcbExtIndex),C   ; Update FCB Ext value              ;
3019: F0D4 DD 70 0E               LD     (IX+fcbS2Index),B    ; Update FCB S2 value               ;
3020: F0D7 CD F8 ED               CALL   OpenFile             ; Open the targeted Dir entry       ;
3021: F0DA 3A B6 EA               LD     A,(exitParameterByte) ; is the file present?              ;
3022: F0DD 3C                     INC    A                    ;
3023: F0DE 20 12                  JR     NZ,RandomSeekExit    ; Exit if open successful	        ;
3024: F0E0         ; cannot open the file, read mode?                                          ;
3025: F0E0 C1                     POP    BC                   ; Get Read/Write flag               ;
3026: F0E1 C5                     PUSH   BC                   ; Read/Write flag                   ;
3027: F0E2 2E 04                  LD     L,04                 ; "attempt to read unwritten extent"    ;
3028: F0E4 0C                     INC    C                    ; Becomes 00 if read operation      ;
3029: F0E5 28 11                  JR     Z,RandomSeekErrorBadSeek ; Error exit if read operation      ;
3030: F0E7         ;
3031: F0E7 CD B0 EE               CALL   MakeNewFile          ; Make Directory Entry              ;
3032: F0EA 2E 05                  LD     L,05                 ; "cannot create new extent"        ;
3033: F0EC 3A B6 EA               LD     A,(exitParameterByte) ; Get result from Make              ;
3034: F0EF 3C                     INC    A                    ;
3035: F0F0 28 06                  JR     Z,RandomSeekErrorBadSeek ;  Exit if failed on Make           ;
3036: F0F2         ;
3037: F0F2             RandomSeekExit:                      ;
3038: F0F2 C1                     POP    BC                   ; Balance Stack                     ;
3039: F0F3 AF                     XOR    A                    ; Success                           ;
3040: F0F4 32 B6 EA               LD     (exitParameterByte),A ;
3041: F0F7 C9                     RET                         ;
3042: F0F8         ;
3043: F0F8             RandomSeekErrorBadSeek:                      ;
3044: F0F8 DD 36 0E C0               LD     (IX+fcbS2Index),0C0H ; Set Write protect & overflow      ;
3045: F0FC             RandomSeekError:                      ;
3046: F0FC C1                     POP    BC                   ; Balance Stack                     ;
3047: F0FD 7D                     LD     A,L                  ; Get error code                    ;
3048: F0FE 32 B6 EA               LD     (exitParameterByte),A ;  and return it to caller          ;
3049: F101 C3 CA EF               JP     SetFileWriteFlag     ; Set flag for following close      ;
3050: F104         ;-------------------------------- Random Seek ------------------------------;
3051: F104         ;--------------------------- Get Random Record Position -------------------;?
3052: F104         ; on Entry :                                                               ;?
3053: F104         ;			HL = pointer to directory entry                                ;?
3054: F104         ;			DE = fcbRCIndex/seqRecord index                                ;?
3055: F104             GetRandomRecordPosition:                      ;?
3056: F104 EB                     EX     DE,HL                ; DE = pointer to directory entry  ;?
3057: F105 19                     ADD    HL,DE                ;?
3058: F106         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)               ;?
3059: F106 4E                     LD     C,(HL)               ; C = record count                 ;?
3060: F107 06 00                  LD     B,0                  ; Make count a word value          ;?
3061: F109         ;?
3062: F109 21 0C 00               LD     HL,fcbExtIndex       ; FCB Extent index                 ;?
3063: F10C 19                     ADD    HL,DE                ;?
3064: F10D 7E                     LD     A,(HL)               ; ACC has Extent value             ;?
3065: F10E 0F                     RRCA                        ;?
3066: F10F E6 80                  AND    80H                  ; A=e000 0000                      ;?
3067: F111 81                     ADD    A,C                  ;?
3068: F112 4F                     LD     C,A                  ;?
3069: F113 3E 00                  LD     A,0                  ;?
3070: F115 88                     ADC    A,B                  ;?
3071: F116 47                     LD     B,A                  ;?
3072: F117         ; BC = 0000 000? errrr rrrr                                               ;?
3073: F117 7E                     LD     A,(HL)               ;?
3074: F118 0F                     RRCA                        ;?
3075: F119 E6 0F                  AND    LO_NIBBLE_MASK       ;?
3076: F11B 80                     ADD    A,B                  ;?
3077: F11C 47                     LD     B,A                  ;?
3078: F11D         ; BC = 000? eeee errrr rrrr        ;?
3079: F11D 21 0E 00               LD     HL,fcbS2Index        ;?
3080: F120 19                     ADD    HL,DE                ;?
3081: F121 7E                     LD     A,(HL)               ; A=XXX? mmmm                      ;?
3082: F122 87                     ADD    A,A                  ;?
3083: F123 87                     ADD    A,A                  ;?
3084: F124 87                     ADD    A,A                  ;?
3085: F125 87                     ADD    A,A                  ; cy=? A=mmmm 0000                 ;?
3086: F126 F5                     PUSH   AF                   ;?
3087: F127 80                     ADD    A,B                  ;?
3088: F128 47                     LD     B,A                  ;?
3089: F129         ; cy=?, BC = mmmm eeee errr rrrr                                          ;?
3090: F129 F5                     PUSH   AF                   ; possible second carry            ;?
3091: F12A E1                     POP    HL                   ; cy = lsb of L                    ;?
3092: F12B 7D                     LD     A,L                  ; cy = lsb of A                    ;?
3093: F12C E1                     POP    HL                   ; cy = lsb of L                    ;?
3094: F12D B5                     OR     L                    ; cy/cy = lsb of A                 ;?
3095: F12E E6 01                  AND    1                    ; A = 0000 000? possible carry-out ;?
3096: F130 C9                     RET                         ;?
3097: F131         ;--------------------------- Get Random Record Position -------------------;?
3098: F131
3099: F131
3100: F131         ; FU
3101: F131         ;=========================== File Utilities ================================;
3102: F131
3103: F131         ;=========================== Directory Utilities ===========================;
3104: F131         ;--------------------------- Set End of Directory indicator ----------------;
3105: F131             SetEndDirectory:                      ;
3106: F131 21 FF FF               LD     HL,EOD               ; Put -1 (0FFFFH) in index          ;
3107: F134 22 B4 F4               LD     (dirEntryIndex),HL   ;
3108: F137 C9                     RET                         ;
3109: F138         ;--------------------------- Set End of Directory indicator ----------------;
3110: F138         ;--------------------------- Are we at End Of Directory --------------------;
3111: F138         ; Tests to see if we are at the End Of the Directory                        ;
3112: F138         ;                                                                           ;
3113: F138         ; exits With Z Flag Set if at EOD (dirEntryIndex = -1)                      ;
3114: F138         ;			 Z Flag reset if still in directory                             ;
3115: F138         ;
3116: F138             AtEndOfDirectory:                      ;
3117: F138 21 B4 F4               LD     HL,dirEntryIndex     ; Point at LSB of Dir index         ;
3118: F13B 7E                     LD     A,(HL)               ; Get it                            ;
3119: F13C 23                     INC    HL                   ; Point at MSB	of Dir Index		;
3120: F13D BE                     CP     M                    ; LSB = MSB ?                       ;
3121: F13E C0                     RET    NZ                   ;  exit if not if different         ;
3122: F13F         ; Same.  are they = 0ffh?           ;
3123: F13F 3C                     INC    A                    ;  if yes, A= 0, set Z flag         ;
3124: F140 C9                     RET                         ;
3125: F141         ;--------------------------- Are we at End Of Directory --------------------;
3126: F141         ;--------------------------- Get Directory Element -------------------------;
3127: F141         ; compute the address of a directory element in Directory Buffer            ;
3128: F141         ; Returns:  HL = Address of the specific directory Entry                    ;
3129: F141             GetCurrentDirectoryRecord:                      ;
3130: F141 C5                     PUSH   BC                   ; Save BC                           ;
3131: F142 2A 88 F4               LD     HL,(caDirectoryDMA)  ; Get the Directory Buffer base     ;
3132: F145 3A B3 F4               LD     A,(dirBlockIndex)    ; Get the index value               ;
3133: F148 4F                     LD     C,A                  ;
3134: F149 AF                     XOR    A                    ; Set to Zero and reset CY          ;
3135: F14A 47                     LD     B,A                  ;
3136: F14B ED 4A                  ADC    HL,BC                ; Compute the Entry Location        ;
3137: F14D C1                     POP    BC                   ; Restore	                        ;
3138: F14E C9                     RET                         ;
3139: F14F         ;--------------------------- Get Directory Element -------------------------;
3140: F14F         ;--------------------------- Set Directory Entry ---------------------------;
3141: F14F         ; Will update directory if not in the directory                             ;
3142: F14F         ;
3143: F14F             SetDirectoryEntry:                      ;
3144: F14F CD 58 F1               CALL   StillInDirectory     ;
3145: F152 D8                     RET    C                    ; Exit if still in the Directory  	;
3146: F153         ;
3147: F153         ; StillInDirectory will return with:                                        ;
3148: F153         ;									DE = Directory entry number             ;
3149: F153         ;									HL = Address of entry number + 1        ;
3150: F153 13                     INC    DE                   ;
3151: F154 72                     LD     (HL),D               ;
3152: F155 2B                     DEC    HL                   ;
3153: F156 73                     LD     (HL),E               ;
3154: F157 C9                     RET                         ;
3155: F158         ;--------------------------- Set Directory Entry ---------------------------;
3156: F158         ;--------------------------- Are we sill in the Directory ------------------;
3157: F158         ;Returns	:                                                               ;
3158: F158         ;			CY Set   if dirEntryIndex <= Directory Max Value                ;
3159: F158         ;			CY Reset if dirEntryIndex  > Directory Max Value                ;
3160: F158         ;			HL = (address of Index Value) + 1                               ;
3161: F158         ;			DE = Directory Index Value                                      ;
3162: F158             StillInDirectory:                      ;
3163: F158 2A B4 F4               LD     HL,(dirEntryIndex)   ;
3164: F15B EB                     EX     DE,HL                ; DE = directory counter            ;
3165: F15C 2A 82 F4               LD     HL,(caDirMaxValue)   ; HL = caDirMaxValue              	;
3166: F15F 7B                     LD     A,E                  ;
3167: F160 96                     SUB    M                    ;
3168: F161 23                     INC    HL                   ;
3169: F162 7A                     LD     A,D                  ;
3170: F163 9E                     SBC    A,(HL)               ; Set CY if dirEntryIndex           ;
3171: F164 C9                     RET                         ;  <= Directory Max Value       ;
3172: F165         ;--------------------------- Are we sill in the Directory ------------------;
3173: F165         ;--------------------------- Scan Disk Map ---------------------------------;
3174: F165         ; Will Set/Reset the Allocation Map bit(s) for the current directory entry. ;
3175: F165         ;                                                                           ;
3176: F165         ; On Entry  C = TRUE	Set the Map bits for each block found in FCB        ;
3177: F165         ;           C = FALSE	reset the Map bits for each block found in FCB      ;
3178: F165         ;
3179: F165             ScanDiskMap:                      ;
3180: F165 C5                     PUSH   BC                   ; Save the Set/Reset Info           ;
3181: F166 CD 41 F1               CALL   GetCurrentDirectoryRecord ; HL points at the directory record ;
3182: F169 11 10 00               LD     DE,fcbDiskMapIndex   ; DE is the index to the FCBs Map   ;
3183: F16C 19                     ADD    HL,DE                ; HL is now at start of the MAP     ;
3184: F16D 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; Size of Disk Allocation Map + 1  ;
3185: F16F         ;
3186: F16F             ScanDiskMap0:                      ;
3187: F16F D1                     POP    DE                   ; Recall the set/reset Info         ;
3188: F170 0D                     DEC    C                    ;
3189: F171 C8                     RET    Z                    ; Loop once for each disk map entry ;
3190: F172         ;
3191: F172 D5                     PUSH   DE                   ; Save the Set/Reset Info           ;
3192: F173 3A A9 F4               LD     A,(byteAllocationFlag) ; Is Map Byte or Word sized         ;
3193: F176 B7                     OR     A                    ;
3194: F177 28 07                  JR     Z,ScanDiskMapWord    ; Skip if Word Sized                ;
3195: F179         ;  Byte Allocation scan operation                                           ;
3196: F179 C5                     PUSH   BC                   ; Save counter                      ;
3197: F17A E5                     PUSH   HL                   ; Save map address                  ;
3198: F17B 4E                     LD     C,(HL)               ;
3199: F17C 06 00                  LD     B,0                  ; BC=block# for Byte                ;
3200: F17E 18 06                  JR     ScanDiskMap2         ;
3201: F180         ; Word scan operation                                                       ;
3202: F180             ScanDiskMapWord:                      ;
3203: F180 0D                     DEC    C                    ; Adjust counter for 2 bytes        ;
3204: F181 C5                     PUSH   BC                   ; Save counter                      ;
3205: F182 46                     LD     B,(HL)               ;
3206: F183 23                     INC    HL                   ;
3207: F184 4E                     LD     C,(HL)               ; BC=block# for Word                ;
3208: F185 E5                     PUSH   HL                   ; Save map address                  ;
3209: F186         ;
3210: F186         ; Arrive here with BC=block#, E=0/1	                                        ;
3211: F186             ScanDiskMap2:                      ;
3212: F186 79                     LD     A,C                  ;
3213: F187 B0                     OR     B                    ; Skip if = 0000 (No Block)         ;
3214: F188 C4 95 EF               CALL   NZ,SetResetMapBit    ; bit set to 0/1 its in C           ;
3215: F18B E1                     POP    HL                   ;
3216: F18C 23                     INC    HL                   ; to next bit position              ;
3217: F18D C1                     POP    BC                   ; recall counter                    ;
3218: F18E 18 DF                  JR     ScanDiskMap0         ; for another item                  ;
3219: F190         ;
3220: F190         ;--------------------------- Scan Disk Map ---------------------------------;
3221: F190         ;--------------------------- Get Closest Disk Block ------------------------;
3222: F190         ; Find the closest available disk block, and mark in Map as allocated       ;
3223: F190         ; Enter	BC	= Block number to base the search on                            ;
3224: F190         ; Exit	HL	= 0000 if There are no available open blocks                    ;
3225: F190         ;			= block number of available and marked block                    ;
3226: F190         ;
3227: F190             GetClosestBlock:                      ;
3228: F190 C5                     PUSH   BC                   ; save the starting Block #         ;
3229: F191         ;
3230: F191 2A 95 F4               LD     HL,(dpbDSM)          ; Maximum allocation value          ;
3231: F194 CD FD F2               CALL   DivideHLby8          ; Length of Map	                    ;
3232: F197 EB                     EX     DE,HL                ; put size into DE			        ;
3233: F198 E1                     POP    HL                   ; Block number into HL              ;
3234: F199 CD FD F2               CALL   DivideHLby8          ; Length of Map                     ;
3235: F19C EB                     EX     DE,HL                ; Size in HL, Start in DE           ;
3236: F19D AF                     XOR    A                    ; Reset CY                          ;
3237: F19E ED 52                  SBC    HL,DE                ; Size for right                    ;
3238: F1A0         ; DE = Start Index                                                          ;
3239: F1A0         ; DE = Left Size                                                            ;
3240: F1A0         ; HL	= Right Size                                                        ;
3241: F1A0 E5                     PUSH   HL                   ; Save right size                   ;
3242: F1A1 D5                     PUSH   DE                   ; Save left size & Start Index      ;
3243: F1A2 3E FF                  LD     A,0FFH               ; Full Octet                        ;
3244: F1A4         ;
3245: F1A4 2A 8E F4               LD     HL,(caAllocVector)   ; Start of Map                      ;
3246: F1A7 19                     ADD    HL,DE                ; Determine initial Octet			;
3247: F1A8         ; Set up Left side                                                          ;
3248: F1A8 C1                     POP    BC                   ; Left size                         ;
3249: F1A9 03                     INC    BC                   ; adjust                            ;
3250: F1AA E5                     PUSH   HL                   ; Save initial Octet                ;
3251: F1AB 11 FF FF               LD     DE,-1                ; Flag as Left register set         ;
3252: F1AE         ; HL = Initial Octet                                                        ;
3253: F1AE         ; BC = Left Size                                                            ;
3254: F1AE D9                     EXX                         ; Use alternate registers           ;
3255: F1AF 11 00 00               LD     DE,0000H             ; Flag as Right register set        ;
3256: F1B2 E1                     POP    HL                   ; Get Initial Octet                 ;
3257: F1B3 C1                     POP    BC                   ; Get Right Size                    ;
3258: F1B4 03                     INC    BC                   ; adjust                            ;
3259: F1B5             LookRight:                      ;
3260: F1B5 ED A1                  CPI                         ; UnSet Bit?                        ;
3261: F1B7 20 28                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3262: F1B9 E2 D2 F1               JP     PO,NoMoreRight       ; Exhausted Map to the right        ;
3263: F1BC         ;
3264: F1BC D9                     EXX                         ; Switch to the Left                ;
3265: F1BD ED A9                  CPD                         ; UnSet Bit?                        ;
3266: F1BF 20 20                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3267: F1C1 E2 C7 F1               JP     PO,NoMoreLeft        ; Exhausted Map to the right        ;
3268: F1C4 D9                     EXX                         ; switch to right                   ;
3269: F1C5 18 EE                  JR     LookRight            ; Keep on looking                   ;
3270: F1C7         ;			----------------			                                    ;
3271: F1C7             NoMoreLeft:                      ;
3272: F1C7 D9                     EXX                         ; Switch to Right                   ;
3273: F1C8             NoMoreLeftLoop:                      ;
3274: F1C8 ED A1                  CPI                         ;
3275: F1CA 20 15                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3276: F1CC E2 DD F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right		;
3277: F1CF 18 F7                  JR     NoMoreLeftLoop       ; Keep looking                      ;
3278: F1D1 76                     HALT                        ;
3279: F1D2             NoMoreRight:                      ;
3280: F1D2 D9                     EXX                         ; Switch to Left                    ;
3281: F1D3             NoMoreRightLoop:                      ;
3282: F1D3 ED A9                  CPD                         ;
3283: F1D5 20 0A                  JR     NZ,FoundFreeOctet    ;  Then get out of search           ;
3284: F1D7 E2 DD F1               JP     PO,NoFreeBlocks      ; Exhausted Map to the right        ;
3285: F1DA 18 F7                  JR     NoMoreRightLoop      ; Keep looking                      ;
3286: F1DC 76                     HALT                        ;
3287: F1DD             NoFreeBlocks:                      ;
3288: F1DD 21 00 00               LD     HL,0000H             ; Return 0000 in HL                 ;
3289: F1E0 C9                     RET                         ;
3290: F1E1         ;			----------------			                                    ;
3291: F1E1             FoundFreeOctet:                      ;
3292: F1E1 BB                     CP     E                    ; Left or Right                     ;
3293: F1E2 28 03                  JR     Z,FoundFreeOctet1    ;  it was left                      ;
3294: F1E4 2B                     DEC    HL                   ; Adjust for direction              ;
3295: F1E5 18 01                  JR     FoundFreeOctet2      ;
3296: F1E7         ;
3297: F1E7             FoundFreeOctet1:                      ;
3298: F1E7 23                     INC    HL                   ; Adjust for direction              ;
3299: F1E8             FoundFreeOctet2:                      ;
3300: F1E8 01 00 00               LD     BC,00                ; need to keep track of bit         ;
3301: F1EB             FoundFreeOctet3:                      ;
3302: F1EB CB 06                  RLC    (HL)                 ;
3303: F1ED 03                     INC    BC                   ;
3304: F1EE 38 FB                  JR     C,FoundFreeOctet3    ; Loop if Bit 7 set                 ;
3305: F1F0 CB C6                  SET    0,(HL)               ; Make map bit set                  ;
3306: F1F2 41                     LD     B,C                  ; Put count in B                    ;
3307: F1F3             FoundFreeOctet4:                      ;
3308: F1F3 CB 0E                  RRC    (HL)                 ;
3309: F1F5 10 FC                  DJNZ   FoundFreeOctet4      ; Restore the Octet                 ;
3310: F1F7 0B                     DEC    BC                   ; adjust for Zero based value       ;
3311: F1F8 C5                     PUSH   BC                   ; Save the bit index                ;
3312: F1F9 ED 4B 8E F4               LD     BC,(caAllocVector)   ; Get Map start                     ;
3313: F1FD AF                     XOR    A                    ; Clear CY                          ;
3314: F1FE ED 42                  SBC    HL,BC                ; Get how far in the map            ;
3315: F200 CD 07 F3               CALL   MultiplyHLby8        ; Calculate the Octet           ;
3316: F203 C1                     POP    BC                   ; Restore index into Octet          ;
3317: F204 09                     ADD    HL,BC                ; This is the Block Number          ;
3318: F205 C9                     RET                         ;
3319: F206         ;--------------------------- Get Closest Disk Block ------------------------;
3320: F206         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3321: F206             CopyDirEntryToUserDMA:                      ;
3322: F206 2A 88 F4               LD     HL,(caDirectoryDMA)  ; Point at Directory buffer         ;
3323: F209 ED 5B 80 F4               LD     DE,(initDAMAddress)  ; Point at User's Buffer            ;
3324: F20D 01 80 00               LD     BC,cpmRecordSize     ; The entire record                 ;
3325: F210 ED B0                  LDIR                        ; Move it                           ;
3326: F212 C9                     RET                         ;
3327: F213         ;---------------------------- Copy Dir Entry To User's Buffer --------------;
3328: F213         ;--------------------- Return last Directory Index to Caller ---------------;
3329: F213             DirLocationToReturnLoc:                      ;
3330: F213 3A A4 F4               LD     A,(directoryIndex)   ; Get last directory Index          ;
3331: F216 32 B6 EA               LD     (exitParameterByte),A ; Save for return to Caller         ;
3332: F219 C9                     RET                         ;
3333: F21A         ;--------------------- Return last Directory Index to Caller ---------------;
3334: F21A         ;--------------------------- Check OK to Write to Disk ---------------------;
3335: F21A             CheckWrite:                      ;
3336: F21A CD 32 EF               CALL   IsDiskWriteProtected ; Is this disk Write Protected?     ;
3337: F21D C8                     RET    Z                    ; OK to write                       ;
3338: F21E C3 0E F4               JP     Error_DiskReadOnly   ; Report read only disk error		;
3339: F221         ;--------------------------- Check OK to Write to Disk ---------------------;
3340: F221         ;--------------------------- Check File Write Protect Status ---------------;
3341: F221             CheckRODirectory:                      ;
3342: F221 CD 41 F1               CALL   GetCurrentDirectoryRecord ; Use Entry in Directory Buffer     ;
3343: F224         ; Use HL as the directory entry in Question                                 ;
3344: F224             CheckROFile:                      ;
3345: F224 11 09 00               LD     DE,fcbROfileIndex    ; Index into FC for RO              ;
3346: F227 19                     ADD    HL,DE                ; point at the byte                 ;
3347: F228 7E                     LD     A,(HL)               ;
3348: F229 17                     RLA                         ; Set CY if RO bit set              ;
3349: F22A D0                     RET    NC                   ; Return OK                         ;
3350: F22B C3 14 F4               JP     Error_FileReadOnly   ; Report to read only File          ;
3351: F22E         ;--------------------------- Check File Write Protect Status ---------------;
3352: F22E         ;------------------------- Copy FCB To Directory record --------------------;
3353: F22E         ; On Entry:                                                                 ;
3354: F22E         ;			C = Starting position                                           ;
3355: F22E         ;			E = length of copy                                              ;
3356: F22E         ;copy the whole file control block                                          ;
3357: F22E             CopyFCB:                        ;
3358: F22E 0E 00                  LD     C,0                  ;
3359: F230 1E 20                  LD     E,fcbLength          ; Copy all of the FCB		    ;
3360: F232         ; On Entry:                                                                 ;
3361: F232         ;			C = Starting position                                           ;
3362: F232         ;			E = length of copy                                              ;
3363: F232             CopyDir:                        ;
3364: F232 16 00                  LD     D,0                  ; Make length a word value      ;
3365: F234 D5                     PUSH   DE                   ; Length                        ;
3366: F235 06 00                  LD     B,0                  ; Make index a word             ;
3367: F237 2A B4 EA               LD     HL,(paramDE)         ; HL = source for data          ;
3368: F23A 09                     ADD    HL,BC                ;
3369: F23B EB                     EX     DE,HL                ;
3370: F23C CD 41 F1               CALL   GetCurrentDirectoryRecord ; HL pointer to Dir Record      ;
3371: F23F EB                     EX     DE,HL                ;
3372: F240 C1                     POP    BC                   ; Length                        ;
3373: F241 ED B0                  LDIR                        ;
3374: F243 CD 5C F3               CALL   SeekDir              ; Seek to the dir entry         ;
3375: F246 C3 5A F0               JP     WriteDir             ; Write the directory element   ;
3376: F249         ;------------------------- Copy FCB from Directory record ------------------;
3377: F249         ;-------------------------------- Get Block Number -------------------------;
3378: F249         ;compute disk block number from current FCB                                ;
3379: F249             GetBlockNumber:                      ;
3380: F249 CD 56 F2               CALL   GetDiskMapIndex      ;Return Alloc block index           ;
3381: F24C 4F                     LD     C,A                  ;
3382: F24D 06 00                  LD     B,0                  ;
3383: F24F CD 63 F2               CALL   GetDiskMapValue      ; Convert to Disk record            ;
3384: F252 22 B1 F4               LD     (absoluteCPMRecord),HL ; Save                              ;
3385: F255 C9                     RET                         ;
3386: F256         ;-------------------------------- Get Block Number -------------------------;
3387: F256         ;-------------------------------- Get Disk Map Index -----------------------;
3388: F256         ;Return the  disk map Index for current File Record in the ACC              ;
3389: F256             GetDiskMapIndex:                      ;
3390: F256 21 92 F4               LD     HL,dpbBSH            ; Block# = Record# / (2***dpbBSH)   ;
3391: F259 46                     LD     B,(HL)               ; shift count                       ;
3392: F25A 3A AF F4               LD     A,(currentFileRecord) ;
3393: F25D             GetDiskMapIndexLoop:                      ;
3394: F25D CB 3F                  SRL    A                    ;
3395: F25F 10 FC                  DJNZ   GetDiskMapIndexLoop  ; Loop till done                    ;
3396: F261 00                     NOP                         ;
3397: F262 C9                     RET                         ;
3398: F263         ;-------------------------------- Get Disk Map Index -----------------------;
3399: F263         ;-------------------------------- Get Disk Map Value -----------------------;
3400: F263         ; Enter with Disk Map Index in BC                                           ;
3401: F263         ; Return disk map value  in HL                                              ;
3402: F263             GetDiskMapValue:                      ;
3403: F263 2A B4 EA               LD     HL,(paramDE)         ; FCB                               ;
3404: F266 11 10 00               LD     DE,fcbDiskMapIndex   ; Index to Allocation Map           ;
3405: F269 19                     ADD    HL,DE                ; Address of Allocation Map Start   ;
3406: F26A 09                     ADD    HL,BC                ; Point at the targeted map entry   ;
3407: F26B 3A A9 F4               LD     A,(byteAllocationFlag) ; Is this a byte or word            ;
3408: F26E B7                     OR     A                    ;
3409: F26F 28 04                  JR     Z,GetDiskMap16Bit    ; Skip if word value                ;
3410: F271 6E                     LD     L,(HL)               ;  else its a byte value            ;
3411: F272 26 00                  LD     H,0                  ;load the byte into HL              ;
3412: F274 C9                     RET                         ;
3413: F275         ;
3414: F275             GetDiskMap16Bit:                      ;
3415: F275 09                     ADD    HL,BC                ; make it double width              ;
3416: F276 56                     LD     D,(HL)               ;
3417: F277 23                     INC    HL                   ;
3418: F278 5E                     LD     E,(HL)               ; Load word value into DE           ;
3419: F279 EB                     EX     DE,HL                ; return value in HL                ;
3420: F27A C9                     RET                         ;
3421: F27B         ;-------------------------------- Get Disk Map Value -----------------------;
3422: F27B         ;-------------------------------- Allocate The Block -----------------------;
3423: F27B         ;is  block allocated                                                        ;
3424: F27B             WasBlockAllocated:                      ;
3425: F27B 2A B1 F4               LD     HL,(absoluteCPMRecord) ; Get the Block Number              ;
3426: F27E 7D                     LD     A,L                  ; ZFlag set if                      ;
3427: F27F B4                     OR     H                    ;  absoluteCPMRecord = 0            ;
3428: F280 C9                     RET                         ;
3429: F281         ;-------------------------------- Allocate The Block -----------------------;
3430: F281         ;----------------------------- Set Actual Record Add -----------------------;
3431: F281         ;
3432: F281         ;compute actual record address                                              ;
3433: F281         ; result = absolute CPMRecord * ( 2**BSH)                                  ;
3434: F281             SetActualRecordAdd:                      ;
3435: F281 3A 92 F4               LD     A,(dpbBSH)           ; Block Shift to loop control       ;
3436: F284 47                     LD     B,A                  ;
3437: F285 2A B1 F4               LD     HL,(absoluteCPMRecord) ;
3438: F288         ;
3439: F288             SetActualRecordAddLoop:                      ;
3440: F288 29                     ADD    HL,HL                ;
3441: F289 10 FD                  DJNZ   SetActualRecordAddLoop ;
3442: F28B         ; HL has Record number for start of the block;                              ;
3443: F28B 3A 93 F4               LD     A,(dpbBLM)           ; Get block mask to get current     ;
3444: F28E 4F                     LD     C,A                  ;  File Record mod Block            ;
3445: F28F 3A AF F4               LD     A,(currentFileRecord) ; Get index into block              ;
3446: F292 A1                     AND    C                    ; Record index in Block             ;
3447: F293 B5                     OR     L                    ;
3448: F294 6F                     LD     L,A                  ; to HL                             ;
3449: F295 22 B1 F4               LD     (absoluteCPMRecord),HL ; Absolute CPM Record=HL            ;
3450: F298         ; *** Absolute CPM Record now has current record number                     ;
3451: F298         ; - Starting record number + index into block                               ;
3452: F298 C9                     RET                         ;
3453: F299         ;----------------------------- Set Actual Record Add -----------------------;
3454: F299         ;-------------------------------- Open Next Extent -------------------------;
3455: F299         ;close the current extent  and open the next one if possible.              ;
3456: F299         ;readModeFlag is true if in read mode                                      ;
3457: F299             OpenNextExt:                      ;
3458: F299 AF                     XOR    A                    ; Set to 00                         ;
3459: F29A 32 A2 F4               LD     (fcbCopiedFlag),A    ; Clear Flag                        ;
3460: F29D CD 39 EE               CALL   CloseDirEntry        ; Close current extent.             ;
3461: F2A0 CD 38 F1               CALL   AtEndOfDirectory     ; Is the directory full?            ;
3462: F2A3 C8                     RET    Z                    ;  exit it yes                      ;
3463: F2A4         ;
3464: F2A4 CD 8D EF               CALL   GetExtentAddress     ; HL at FCB's EXT                   ;
3465: F2A7 7E                     LD     A,(HL)               ; Get previous EXT value            ;
3466: F2A8 3C                     INC    A                    ; Add one to it                     ;
3467: F2A9 E6 1F                  AND    maxExtValue          ; Limit to max value                ;
3468: F2AB 77                     LD     (HL),A               ; Put it back into the FCB          ;
3469: F2AC 28 0D                  JR     Z,OpenNextModule     ;  if = 0, need to open new Module  ;
3470: F2AE         ;
3471: F2AE 47                     LD     B,A                  ; put Ext value in B                ;
3472: F2AF 3A 94 F4               LD     A,(dpbEXM)           ; Get the Extent Mask               ;
3473: F2B2 A0                     AND    B                    ; Mask out unwanted bits            ;
3474: F2B3         ; if result is zero, then not in the same group                             ;
3475: F2B3 21 A2 F4               LD     HL,fcbCopiedFlag     ; Point at Copied Flag              ;
3476: F2B6 A6                     AND    M                    ;  00 in Acc if not written         ;
3477: F2B7 28 0C                  JR     Z,OpenNextExt1       ;  go to next physical extent if 0  ;
3478: F2B9 18 24                  JR     UpdateFCB            ;  else continue                    ;
3479: F2BB         ;
3480: F2BB             OpenNextModule:                      ;
3481: F2BB 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ; Index difference between EXT & S2 ;
3482: F2BE 09                     ADD    HL,BC                ; Add to HL( at EXT) gives S2       ;
3483: F2BF 34                     INC    M                    ; Increment the Module number       ;
3484: F2C0 7E                     LD     A,(HL)               ; get the new Module number         ;
3485: F2C1 E6 0F                  AND    moduleMask           ; Mask out unwanted bits            ;
3486: F2C3 28 25                  JR     Z,OpenNextExtError   ; If overflow to zero, error exit   ;
3487: F2C5         ;
3488: F2C5             OpenNextExt1:                      ;
3489: F2C5 0E 0F                  LD     C,nameLength         ; Set search/match size             ;
3490: F2C7 CD E7 EF               CALL   SearchForDirectoryRecord ; Find the file's directory record  ;
3491: F2CA CD 38 F1               CALL   AtEndOfDirectory     ; At end of Directory ?             ;
3492: F2CD 20 10                  JR     NZ,UpdateFCB         ;  No, then keep going              ;
3493: F2CF         ;
3494: F2CF 3A A3 F4               LD     A,(readModeFlag)     ;  else at EOD                      ;
3495: F2D2 3C                     INC    A                    ; 0ffh becomes 00 if read           ;
3496: F2D3 28 15                  JR     Z,OpenNextExtError   ; All done if a read                ;
3497: F2D5         ;
3498: F2D5 CD B0 EE               CALL   MakeNewFile          ; With write we can extend file     ;
3499: F2D8 CD 38 F1               CALL   AtEndOfDirectory     ; Is there room in the directory ?  ;
3500: F2DB 28 0D                  JR     Z,OpenNextExtError   ;  no, exitParameterByte = 1        ;
3501: F2DD 18 03                  JR     OpenNextExt3         ;
3502: F2DF         ;
3503: F2DF             UpdateFCB:                      ;
3504: F2DF CD 01 EE               CALL   CopyDirRecordToFCB   ; Update FCB                        ;
3505: F2E2             OpenNextExt3:                      ;
3506: F2E2 CD 69 EF               CALL   SetRecordVars        ; Set variables for current FCB     ;
3507: F2E5 AF                     XOR    A                    ;
3508: F2E6 32 B6 EA               LD     (exitParameterByte),A ; Set exitParameterByte = 0         ;
3509: F2E9 C9                     RET                         ;
3510: F2EA         ;
3511: F2EA             OpenNextExtError:                      ;
3512: F2EA CD 1F F3               CALL   SetExitParamTo1      ; ExitParameterByte = 1             ;
3513: F2ED C3 CA EF               JP     SetFileWriteFlag     ; Ensure that it will not be closed ;
3514: F2F0         ;-------------------------------- Open Next Extent -------------------------;
3515: F2F0
3516: F2F0         ;=========================== Directory Utilities ===========================;
3517: F2F0         ; DU
3518: F2F0
3519: F2F0         ;=========================== General   Utilities ===========================;
3520: F2F0
3521: F2F0         ;--------------------------- Rotate HL right by value in C -----------------;
3522: F2F0         ;
3523: F2F0         ; HL = Value to be rotated Right                                            ;
3524: F2F0         ;  B = Amount to shift                                                      ;
3525: F2F0             RotateRightHLbyB:                      ;
3526: F2F0 37                     SCF                         ; Set carry flag, expect LSBit = 1  ;
3527: F2F1 CB 45                  BIT    0,L                  ; is LSB set?                       ;
3528: F2F3 20 01                  JR     NZ,RotateRightHLbyB1 ; Skip if LSB set               ;
3529: F2F5 3F                     CCF                         ; else Clear Carry flag             ;
3530: F2F6             RotateRightHLbyB1:                      ;
3531: F2F6 CB 1C                  RR     H                    ; Shift thru CY                     ;
3532: F2F8 CB 1D                  RR     L                    ; ditto                             ;
3533: F2FA 10 F4                  DJNZ   RotateRightHLbyB     ;
3534: F2FC C9                     RET                         ;
3535: F2FD         ;
3536: F2FD         ;--------------------------- Rotate HL right by value in C -----------------;
3537: F2FD         ;---------Divide HL by 8  &&  Shift HL right by value in C -----------------;
3538: F2FD         ; HL = Value to be shifted Right                                            ;
3539: F2FD             DivideHLby8:                      ;
3540: F2FD 06 03                  LD     B,3                  ; 8 = 2**3						    ;
3541: F2FF         ;  B = Amount to shift                                                      ;
3542: F2FF             ShiftRightHLbyB:                      ;
3543: F2FF AF                     XOR    A                    ; else Clear Carry flag             ;
3544: F300 CB 1C                  RR     H                    ; Shift thru CY                     ;
3545: F302 CB 1D                  RR     L                    ; ditto                             ;
3546: F304 10 F9                  DJNZ   ShiftRightHLbyB      ;
3547: F306 C9                     RET                         ;
3548: F307         ;---------Divide HL by 8  &&  Shift HL right by value in C -----------------;
3549: F307         ;---------Multiply HL by 8  &&  Shift HL left by value in C ----------------;
3550: F307         ; HL = Value to be shifted Left                                             ;
3551: F307             MultiplyHLby8:                      ;
3552: F307 06 03                  LD     B,3                  ; 8 = 2**3						    ;
3553: F309         ;  B = Amount to shift                                                      ;
3554: F309             ShiftLeftHLbyB:                      ;
3555: F309 AF                     XOR    A                    ; else Clear Carry flag             ;
3556: F30A CB 15                  RL     L                    ; Shift thru CY                     ;
3557: F30C CB 14                  RL     H                    ; ditto                             ;
3558: F30E 10 F9                  DJNZ   ShiftLeftHLbyB       ;
3559: F310 C9                     RET                         ;
3560: F311         ;---------Multiply HL by 8  &&  Shift HL left by value in C ----------------;
3561: F311         ;----------------------------- Merge ---------------------------------------;
3562: F311         ; Merge Map Block Numbers between FCB and directory record                  ;
3563: F311         ; HL has pointer to map for either dir record or FCB,                       ;
3564: F311         ; DE has the other pointer. If HL is pointing to a non empty block, then    ;
3565: F311         ; it just returns, Else it copies the block number to where DE is pointing  ;
3566: F311         ;
3567: F311             Merge:                          ;
3568: F311 7E                     LD     A,(HL)               ; Get the first byte                ;
3569: F312 23                     INC    HL                   ;
3570: F313 B6                     OR     M                    ; OR it with the second byte        ;
3571: F314 2B                     DEC    HL                   ; Restore HL to start               ;
3572: F315 C0                     RET    NZ                   ; Exit if both are 0s               ;
3573: F316         ; HL points to a non Zero value	                                            ;
3574: F316 1A                     LD     A,(DE)               ; Get the first byte                ;
3575: F317 77                     LD     (HL),A               ; Move it                           ;
3576: F318 13                     INC    DE                   ;
3577: F319 23                     INC    HL                   ; Increment both pointers           ;
3578: F31A 1A                     LD     A,(DE)               ; Get the second byte               ;
3579: F31B 77                     LD     (HL),A               ; Move it                           ;
3580: F31C 1B                     DEC    DE                   ;
3581: F31D 2B                     DEC    HL                   ; Restore HL & DE to start          ;
3582: F31E C9                     RET                         ;
3583: F31F         ;----------------------------- Merge ---------------------------------------;
3584: F31F         ;------------------------- Set Exit Parameter To 1 -------------------------;
3585: F31F             SetExitParamTo1:                      ;
3586: F31F 3E 01                  LD     A,1                  ;
3587: F321 32 B6 EA               LD     (exitParameterByte),A ; Put a 1 in the exit parameter     ;
3588: F324 C9                     RET                         ;
3589: F325         ;------------------------- Set Exit Parameter To 1 -------------------------;
3590: F325
3591: F325         ; GU
3592: F325
3593: F325         ;=========================== General   Utilities ===========================;
3594: F325
3595: F325         ;--------------------------- Read Directory Record -------------------------;
3596: F325         ; read a directory entry into the directory buffer                          ;
3597: F325             ReadDirRecord:                      ;
3598: F325 CD 09 EF               CALL   SetDirDMA            ; System Assigned Buffer            ;
3599: F328 CD 12 EF               CALL   ReadBuffer           ; Go to BIOS for the read           ;
3600: F32B C3 04 EF               JP     SetDataDMA           ; Restore DMA                       ;
3601: F32E         ;--------------------------- Read Directory Record -------------------------;
3602: F32E
3603: F32E         ;--------------------------- Read Directory --------------------------------;
3604: F32E         ; Read next directory entry                                                 ;
3605: F32E         ; Enter :                                                                   ;
3606: F32E         ;		C =  TRUE initializing and setting CheckSum                         ;
3607: F32E         ;		  <> TRUE Checking existing CheckSum                                ;
3608: F32E             ReadDirectory:                      ;
3609: F32E ED 5B 97 F4               LD     DE,(dpbDRM)          ; Number of Dir Entries-1           ;
3610: F332 2A B4 F4               LD     HL,(dirEntryIndex)   ; Prior Directory Index             ;
3611: F335 23                     INC    HL                   ; Increment the Index               ;
3612: F336 22 B4 F4               LD     (dirEntryIndex),HL   ; Save current directory index      ;
3613: F339 AF                     XOR    A                    ; Clear the CY flag                 ;
3614: F33A ED 52                  SBC    HL,DE                ; Are we at end Of the directory    ;
3615: F33C 20 04                  JR     NZ,ReadDirectory0    ;  No the process                   ;
3616: F33E CD 31 F1               CALL   SetEndDirectory      ;  else we are done                 ;
3617: F341 C9                     RET                         ;
3618: F342         ;
3619: F342         ; Calculate the entry index Position in Buffer                              ;
3620: F342             ReadDirectory0:                      ;
3621: F342 3A B4 F4               LD     A,(dirEntryIndex)    ; Get the index                     ;
3622: F345 E6 03                  AND    dirEntryMask         ; Determine Entry number            ;
3623: F347 06 05                  LD     B,fcbShift           ; Shift value for Record Size       ;
3624: F349             ReadDirectory1:                      ;
3625: F349 87                     ADD    A,A                  ;
3626: F34A 10 FD                  DJNZ   ReadDirectory1       ;
3627: F34C 32 B3 F4               LD     (dirBlockIndex),A    ; Now save the Index into to buffer ;
3628: F34F B7                     OR     A                    ; Is this the 1st entry?            ;
3629: F350 C0                     RET    NZ                   ;  return if not.                   ;
3630: F351         ;
3631: F351 C5                     PUSH   BC                   ; Save init Flag (CheckSum)         ;
3632: F352 CD 5C F3               CALL   SeekDir              ; Set up for Directory Read         ;
3633: F355 CD 25 F3               CALL   ReadDirRecord        ; Read the directory record         ;
3634: F358 C1                     POP    BC                   ; Recall initialization flag        ;
3635: F359 C3 AB F3               JP     CheckSumUtility      ; Checksum the directory            ;
3636: F35C         ;--------------------------- Read Directory --------------------------------;
3637: F35C         ;--------------------------- Seek Directory --------------------------------;
3638: F35C         ;seek the record containing the current directory entry					;
3639: F35C             SeekDir:                        ;
3640: F35C 2A B4 F4               LD     HL,(dirEntryIndex)   ; Directory Entry Index             ;
3641: F35F 06 02                  LD     B,dirEntryShift      ; 4 entries per record              ;
3642: F361 CD FF F2               CALL   ShiftRightHLbyB      ;
3643: F364 22 B1 F4               LD     (absoluteCPMRecord),HL ;
3644: F367 22 B6 F4               LD     (dirRecord),HL       ; Save                              ;
3645: F36A C3 6D F3               JP     Seek                 ;
3646: F36D         ;--------------------------- Seek Directory --------------------------------;
3647: F36D         ;--------------------------- Seek ------------------------------------------;
3648: F36D             Seek:                           ;
3649: F36D 01 FF FF               LD     BC,0FFFFH            ; Initialize the track counter      ;
3650: F370 2A B1 F4               LD     HL,(absoluteCPMRecord) ; Get the record in question        ;
3651: F373 ED 5B 90 F4               LD     DE,(dpbSPT)          ; Get Sectors Per track             ;
3652: F377         ;
3653: F377             Seek0:                          ;
3654: F377 03                     INC    BC                   ; Divide the record                 ;
3655: F378 AF                     XOR    A                    ;  by the sectors per track         ;
3656: F379 ED 52                  SBC    HL,DE                ;
3657: F37B 30 FA                  JR     NC,Seek0             ;  to get the gross track number    ;
3658: F37D         ;
3659: F37D         ;
3660: F37D 19                     ADD    HL,DE                ; Gets the sector in the track      ;
3661: F37E E5                     PUSH   HL                   ; Save Index Sector                 ;
3662: F37F         ;
3663: F37F DD E5                  PUSH   IX                   ; Save IX							;
3664: F381 DD 2A 84 F4               LD     IX,(caTrack)         ;
3665: F385 DD 71 00               LD     (IX+0),C             ;
3666: F388 DD 70 01               LD     (IX+1),B             ; Save the Gross Track              ;
3667: F38B         ;
3668: F38B EB                     EX     DE,HL                ; Take the index from the record    ;
3669: F38C 2A B1 F4               LD     HL,(absoluteCPMRecord) ;
3670: F38F AF                     XOR    A                    ;
3671: F390 ED 52                  SBC    HL,DE                ;  and you get the Block start      ;
3672: F392         ;
3673: F392 DD 2A 86 F4               LD     IX,(caSector)        ;
3674: F396 DD 75 00               LD     (IX+0),L             ;
3675: F399 DD 74 01               LD     (IX+1),H             ; Save the Block Start              ;
3676: F39C DD E1                  POP    IX                   ; Restore IX							;
3677: F39E         ;
3678: F39E 2A 9D F4               LD     HL,(dpbOFF)          ; Get directory Offset (tracks)		;
3679: F3A1 09                     ADD    HL,BC                ;  to add to the gross Track        ;
3680: F3A2 E5                     PUSH   HL                   ;  which yields the net or          ;
3681: F3A3 C1                     POP    BC                   ;  actual track for the record      ;
3682: F3A4 CD 1E F6               CALL   bcSettrk             ; Set the net (actual) track        ;
3683: F3A7         ;
3684: F3A7 C1                     POP    BC                   ; Get the sector within the track   ;
3685: F3A8 C3 21 F6               JP     bcSetsec             ;  and set it for the seek          ;
3686: F3AB         ;
3687: F3AB         ;--------------------------- Seek ------------------------------------------;
3688: F3AB         ;--------------------------- Check Sum Utility -----------------------------;
3689: F3AB         ; At entry                                                                  ;
3690: F3AB         ;			C  = TRUE	-  Set the Checksum values in Vector                ;
3691: F3AB         ;			C <> TRUE	-  Validate Checksum value in Vector                ;
3692: F3AB         ;
3693: F3AB             CheckSumUtility:                      ;
3694: F3AB 2A 9B F4               LD     HL,(dpbCKS)          ;
3695: F3AE ED 5B B6 F4               LD     DE,(dirRecord)       ;
3696: F3B2 AF                     XOR    A                    ;
3697: F3B3 ED 52                  SBC    HL,DE                ; Skip if past the Directory    ;
3698: F3B5 D8                     RET    C                    ;  Entries                      ;
3699: F3B6         ;
3700: F3B6 C5                     PUSH   BC                   ; Save New/Validate Flag        ;
3701: F3B7         ;
3702: F3B7         ; CheckSum = MOD( SUM(all bytes in The Record), 0FFH)                       ;
3703: F3B7             ComputeCheckSum:                      ;
3704: F3B7 06 80                  LD     B,cpmRecordSize      ;
3705: F3B9 2A 88 F4               LD     HL,(caDirectoryDMA)  ;
3706: F3BC EE 00                  XOR                         ;
3707: F3BE             ComputeCheckSum1:                      ;
3708: F3BE 86                     ADD    A,(HL)               ;
3709: F3BF 23                     INC    HL                   ;
3710: F3C0 10 FC                  DJNZ   ComputeCheckSum1     ;
3711: F3C2         ; Checksum is in ACC	                                                    ;
3712: F3C2         ;
3713: F3C2 2A 8C F4               LD     HL,(caCheckSum)      ; Address of check sum vector       ;
3714: F3C5 ED 5B B6 F4               LD     DE,(dirRecord)       ; Index to this record              ;
3715: F3C9 19                     ADD    HL,DE                ; Address of this record in vector  ;
3716: F3CA C1                     POP    BC                   ; Retrieve New/Validate Flag        ;
3717: F3CB 0C                     INC    C                    ;
3718: F3CC 28 0A                  JR     Z,SetNewCheckSum     ; Set the Value if Flag was TRUE    ;
3719: F3CE         ;
3720: F3CE BE                     CP     M                    ; Else we are checking the value    ;
3721: F3CF C8                     RET    Z                    ; Exit if OK                        ;
3722: F3D0         ; possible checksum error, are we beyond the end of the disk?               ;
3723: F3D0 CD 58 F1               CALL   StillInDirectory     ;
3724: F3D3 D0                     RET    NC                   ; OK, if not in the directory       ;
3725: F3D4 CD 1A EF               CALL   SetDiskReadOnly      ;  else the checksums don't match   ;
3726: F3D7 C9                     RET                         ;  Set disk RO before returning     ;
3727: F3D8         ;
3728: F3D8         ;initializing the checksum                                                 ;
3729: F3D8             SetNewCheckSum:                      ;
3730: F3D8 77                     LD     (HL),A               ;
3731: F3D9 C9                     RET                         ;
3732: F3DA         ;--------------------------- Check Sum Utility -----------------------------;
3733: F3DA         ;---------------------------------- Is Bit Set -----------------------------;
3734: F3DA         ; Enter HL  contains the bit map                                            ;
3735: F3DA         ;       B   Has the bit number (0...F)                                      ;
3736: F3DA         ; Return ZFlag = 1 if bit is reset (0)                                      ;
3737: F3DA         ;              = 0 if bit is set (1)                                        ;
3738: F3DA             IsBitSet:                       ;
3739: F3DA 04                     INC    B                    ;
3740: F3DB             IsBitSetLoop:                      ;
3741: F3DB 37                     SCF                         ; Set carry flag, expect LSBit = 1  ;
3742: F3DC CB 45                  BIT    0,L                  ; is LSB set?                       ;
3743: F3DE 20 01                  JR     NZ,IsBitSet1         ; Skip if LSB set               ;
3744: F3E0 3F                     CCF                         ; else Clear Carry flag             ;
3745: F3E1             IsBitSet1:                      ;
3746: F3E1 CB 1C                  RR     H                    ; Shift thru CY                     ;
3747: F3E3 CB 1D                  RR     L                    ; ditto                             ;
3748: F3E5 10 F4                  DJNZ   IsBitSetLoop         ;
3749: F3E7 CB 7C                  BIT    7,H                  ; Bit moved from L LSBit to H MSBit	;
3750: F3E9 C9                     RET                         ;
3751: F3EA         ;---------------------------------- Is Bit Set -----------------------------;
3752: F3EA
3753: F3EA         ;============================ Set/Reset Vector Bit =========================;
3754: F3EA         ;---------------------------------- Set Vector Bit -------------------------;
3755: F3EA         ; Enter  HL  contains the bit map vector                                    ;
3756: F3EA         ;        B   Has the bit number (0...F)                                     ;
3757: F3EA         ; Return HL  Contains the modified bit map vector                           ;
3758: F3EA             SetVectorBit:                      ;
3759: F3EA C5                     PUSH   BC                   ; Save the Bit Number               ;
3760: F3EB CD DA F3               CALL   IsBitSet             ; Put the bit in the LSBit          ;
3761: F3EE         ;
3762: F3EE C1                     POP    BC                   ; Get the bit position              ;
3763: F3EF CB FC                  SET    7,H                  ;
3764: F3F1 18 07                  JR     ReAlignVector        ;
3765: F3F3         ;---------------------------------- Set Vector Bit -------------------------;
3766: F3F3         ;---------------------------------- Reset Vector Bit -----------------------;
3767: F3F3         ; Enter  HL  contains the bit map vector                                    ;
3768: F3F3         ;        B   Has the bit number (0...F)                                     ;
3769: F3F3         ; Return HL  Contains the modified bit map vector                           ;
3770: F3F3             ResetVectorBit:                      ;
3771: F3F3 C5                     PUSH   BC                   ; Save the Bit Number               ;
3772: F3F4 CD DA F3               CALL   IsBitSet             ; Put the bit in the LSBit          ;
3773: F3F7         ;
3774: F3F7 C1                     POP    BC                   ; Get the bit position              ;
3775: F3F8 CB BC                  RES    7,H                  ;
3776: F3FA         ; Fall thru to ReAlignVector                                                ;
3777: F3FA         ;---------------------------------- Reset Vector Bit -----------------------;
3778: F3FA         ;---------------------------------- Set VectorBit --------------------------;
3779: F3FA         ; Adjusts the HL register to its Original Alignment after IsBitSet          ;
3780: F3FA         ;
3781: F3FA             ReAlignVector:                      ;
3782: F3FA 04                     INC    B                    ;
3783: F3FB             ReAlignMapLoop:                      ;
3784: F3FB 37                     SCF                         ; Set carry flag, expect LSBit = 1  ;
3785: F3FC CB 7C                  BIT    7,H                  ; is LSB set?                       ;
3786: F3FE 20 01                  JR     NZ,ReAlignMap1       ; Skip if LSB set               ;
3787: F400 3F                     CCF                         ; else Clear Carry flag             ;
3788: F401             ReAlignMap1:                      ;
3789: F401 CB 15                  RL     L                    ; Shift thru CY                     ;
3790: F403 CB 14                  RL     H                    ; ditto                             ;
3791: F405 10 F4                  DJNZ   ReAlignMapLoop       ;
3792: F407 C9                     RET                         ;
3793: F408         ;============================ Set/Reset Vector Bit =========================;
3794: F408         ;============================= Error message World =========================;
3795: F408         ;																			;
3796: F408             Error_Select:                      ;
3797: F408 21 60 F4               LD     HL,ErrMsg_Selection  ; Error Message                     ;
3798: F40B C3 26 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3799: F40E         ;
3800: F40E             Error_DiskReadOnly:                      ;
3801: F40E 21 70 F4               LD     HL,ErrMsg_ReadOnlyDisk ; Error Message                     ;
3802: F411 C3 26 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3803: F414         ;
3804: F414             Error_FileReadOnly:                      ;
3805: F414 21 67 F4               LD     HL,ErrMsg_ReadOnlyFile ; Error Message                     ;
3806: F417 C3 26 F4               JP     WaitBeforeBoot       ; Wait for console input before boot;
3807: F41A         ;
3808: F41A             Error_BadSector:                      ;
3809: F41A 21 55 F4               LD     HL,ErrMsg_BadSector  ; Error Message                     ;
3810: F41D CD 2C F4               CALL   DisplayErrorAndWait  ; Check input from console          ;
3811: F420 FE 03                  CP     CTRL_C               ;
3812: F422 CA 00 00               JP     Z,WarmBoot           ; Reboot if response is CTRL_C      ;
3813: F425 C9                     RET                         ;
3814: F426         ;---------------------------------------------------------------------------;
3815: F426             WaitBeforeBoot:                      ;
3816: F426 CD 2C F4               CALL   DisplayErrorAndWait  ;
3817: F429 C3 00 00               JP     WarmBoot             ;
3818: F42C         ;---------------------------------------------------------------------------;
3819: F42C         ;
3820: F42C             DisplayErrorAndWait:                      ;
3821: F42C E5                     PUSH   HL                   ; Save message pointer              ;
3822: F42D CD D6 E9               CALL   showCRLF             ; Line Feed and Carriage Return     ;
3823: F430 3A 7A F4               LD     A,(currentDisk)      ; Disk in question                  ;
3824: F433 C6 41                  ADD    A,ASCII_A            ; Make ASCII out of it              ;
3825: F435 32 51 F4               LD     (ErrMsg_BDOS_DISK),A ; Put into the error message        ;
3826: F438 01 45 F4               LD     BC,ErrMsg_BDOS       ; Load the start of message         ;
3827: F43B CD 3B E9               CALL   Print                ; Display it                        ;
3828: F43E C1                     POP    BC                   ; Load the rest of message          ;
3829: F43F CD 3B E9               CALL   Print                ; Display it                        ;
3830: F442 C3 21 E9               JP     ConIn                ; Get the input character           ;
3831: F445         ;
3832: F445         ;***************************************************************************;
3833: F445         ;
3834: F445 42 44 4F 53 20 45 72 72 20 4F 6E 20     ErrMsg_BDOS: DB     'BDOS Err On '       ;
3835: F451 20 3A 20 24     ErrMsg_BDOS_DISK: DB     ' : $'               ;
3836: F455 42 61 64 20 53 65 63 74 6F 72 24     ErrMsg_BadSector: DB     'Bad Sector$'        ;
3837: F460 53 65 6C 65 63 74 24     ErrMsg_Selection: DB     'Select$'            ;
3838: F467 52 2F 4F 20 46 69 6C 65 24     ErrMsg_ReadOnlyFile: DB     'R/O File$'          ;
3839: F470 52 2F 4F 20 44 69 73 6B 24     ErrMsg_ReadOnlyDisk: DB     'R/O Disk$'          ;
3840: F479         ;
3841: F479         ;============================= Error message World =========================;
3842: F479
3843: F479         ;********* file control block (fcb) constants ********************
3844: F479             fcbLength  EQU    20H                  ;32				; fcblen file control block size
3845: F479             fcbROfileIndex EQU    09H                  ; high order of first type char
3846: F479             fcbHiddenfileIndex EQU    0AH                  ;10				; invisible file in dir command
3847: F479             fcbExtIndex EQU    0CH                  ;12				; extent number field index
3848: F479             fcbS1Index EQU    0DH                  ;13				; S1 index
3849: F479             fcbS2Index EQU    0EH                  ;14				; S2 data module number index
3850: F479             fcbRCIndex EQU    0FH                  ;15				; record count field index
3851: F479             fcbDiskMapIndex EQU    10H                  ;16				; dskmap disk map field
3852: F479
3853: F479             fcbCurrentRecord EQU    21H                  ;33
3854: F479
3855: F479             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3856: F479
3857: F479             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3858: F479             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3859: F479             dirEntryMask EQU    dirEntriesPerRecord-1
3860: F479             fcbShift   EQU    5                    ; log2(fcbLength)
3861: F479         ;
3862: F479
3863: F479
3864: F479
3865: F479             maxExtValue EQU    31                   ; largest extent number
3866: F479             moduleMask EQU    15                   ; limits module number value
3867: F479             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3868: F479             nameLength EQU    15                   ;  name length
3869: F479
3870: F479             emptyDir   EQU    0E5H                 ; empty empty directory entry
3871: F479             recordSeq  EQU    fcbLength            ; Next Sequential Record
3872: F479             recordRandom EQU    recordSeq + 1        ; Random record field (2 bytes)
3873: F479             recordRandomLSB EQU    recordRandom         ; LSB of Random Record
3874: F479             recordRandomMSB EQU    recordRandom + 1     ; MSB of Random Record
3875: F479             recordRandomOVF EQU    recordRandom + 2     ; Random Record Overflow
3876: F479         ;
3877: F479         ;	reserved file indicators
3878: F479         ;	equ	11				; reserved
3879: F479         ;*****************************************************************
3880: F479         ;*****************************************************************
3881: F479
3882: F479         ;***common values shared between bdosi and bdos******************
3883: F479 00          currentUserNumber: DB     0                    ; usrcode current user number
3884: F47A         ; paramDE:			DS	2					; ParamsDE information address
3885: F47A         ; exitParameterByte:
3886: F47A         ; exitParameterWord:	DS	2					; address value to return
3887: F47A FF          currentDisk: DB     -1                   ; curdsk current disk number
3888: F47B         ; exitParameterByte		EQU	exitParameterWord	; lret low(exitParameterWord)
3889: F47B
3890: F47B         ;********************* Local Variables ***************************
3891: F47B         ;     ************************
3892: F47B         ;     *** Initialized Data ***
3893: F47B
3894: F47B E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3895: F47C 00 00       readOnlyVector: DW     0                    ; rodsk read only disk vector
3896: F47E 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3897: F480 80 00       initDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3898: F482
3899: F482         ;     *** Current Disk attributes ****
3900: F482         ; These are set upon disk select
3901: F482         ; data must be adjacent, do not insert variables
3902: F482         ; address of translate vector, not used
3903: F482         ; ca - currentAddress
3904: F482
3905: F482 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3906: F484 00 00       caTrack:   DW     0000H                ; curtrka current track address
3907: F486 00 00       caSector:  DW     0000H                ; current Sector
3908: F488             caListSizeStart:
3909: F488 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3910: F48A 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3911: F48C 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3912: F48E 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3913: F490             caListSizeEnd:
3914: F490             caListSize EQU    caListSizeEnd - caListSizeStart
3915: F490
3916: F490         ;     ***** Disk Parameter Block *******
3917: F490         ; data must be adjacent, do not insert variables
3918: F490         ; dpb - Disk Parameter Block
3919: F490             dpbStart:
3920: F490 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3921: F492 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3922: F493 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3923: F494 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3924: F495 00 00       dpbDSM:    DW     0000H                ; Maximum allocation number
3925: F497 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3926: F499 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3927: F49B 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3928: F49D 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3929: F49F             dpbEnd:
3930: F49F             dpbSize    EQU    dpbEnd - dpbStart
3931: F49F         ;
3932: F49F
3933: F49F         ;     ************************
3934: F49F             SEQ_ACCESS EQU    01H                  ; Indicates sequential access to file
3935: F49F             RANDOM_ACCESS EQU    00H                  ; Indicates random access to file
3936: F49F 00          diskAccessType: DB     00H                  ; Set to 1 if sequential disk operation
3937: F4A0
3938: F4A0 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3939: F4A2 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3940: F4A3 00          readModeFlag: DB     00H                  ; rmf read mode flag for Open NextExt
3941: F4A4 00          directoryIndex: DB     00H                  ; dirloc directory flag in rename, etc.
3942: F4A5 00          diskMapIndex: DB     00H                  ; dminx  local for Disk_Write
3943: F4A6 00          searchLength: DB     00H                  ; searchl search length
3944: F4A7 00 00       searchAddress: DW     0000H                ; searcha search address
3945: F4A9         ;tinfo:	ds	word							; temp for info in "make"
3946: F4A9 00          byteAllocationFlag: DB     00H                  ; set true if single byte allocation map
3947: F4AA 00          fResel:    DB     00H                  ; resel reselection flag
3948: F4AB 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3949: F4AC 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3950: F4AD 00          fcbRecordCount: DB     00H                  ; record count from current FCB
3951: F4AE 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3952: F4AF 00 00       currentFileRecord: DW     0000H                ; Current File Record - fcbCurrentRecord
3953: F4B1 00 00       absoluteCPMRecord: DW     0000H                ; Raw record ( 4 records / Sector)( 4 Sectors per block)
3954: F4B3         ;
3955: F4B3         ;	local variables for directory access
3956: F4B3 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3957: F4B4 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3958: F4B6 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3959: F4B8
3960: F4B8         ;********************** data areas ******************************
3961: F4B8
3962: F4B8
3963: F4B8         ;---------------------------------- Stack Area--------------------------------;
3964: F4B8             stackBottom: DS     STACK_SIZE * 2       ; stack size                      ;
3965: F4F8             bdosStack:
3966: F4F8         ;
3967: F4F8         ;---------------------------------- Stack Area--------------------------------;
3968: F4F8         ;	end of Basic I/O System
3969: F4F8         ;-----------------------------------------------------------------;
3970: F4F8
3971: F4F8
3972: F4F8         ;
3973: F4F8             Z_HighestLocation:
3974: F4F8             Z_MemoryLeft EQU    (BIOSStart-1) - Z_HighestLocation
3975: F4F8
3976: F4F8
           ************************   Xref   ************************
0000: $               F4F8   0417 0447
3953: absoluteCPMRecord F4B1   1612 3384 3425 3437 3449 3643 3650 3669
1630: Allocate16Bit   EBDB   1625
1045: AreWeAtEndOfBuffer EA31   1041
0086: ASCII_A         0041   3824
0087: ASCII_C         0043
0088: ASCII_K         004B
0095: ASCII_LO_A      0061
0096: ASCII_LO_K      006B
0097: ASCII_LO_P      0070
0038: ASCII_MASK      007F   0988
0089: ASCII_N         004E
0090: ASCII_Q         0051
0091: ASCII_R         0052
0092: ASCII_W         0057
0093: ASCII_Y         0059
0073: ASCII_ZERO      0030
0067: ASTERISK        002A
3116: AtEndOfDirectory F138   1433 1759 1949 2129 2383 2414 2472 2564 2852 3461 3491 3499
1137: BackUp          EA90   1065 1133
1142: BackUp1         EA98   1138
0295: bcBoot          F600
0298: bcConin         F609   0617 0803 0914 0932
0299: bcConout        F60C   0609 0876 1140 1144 1150 1152
0297: bcConst         F606   0614 0910
0303: bcHome          F618   2593
0300: bcList          F60F   0582 0882
0310: bcListst        F62D
0301: bcPunch         F612   0567
0308: bcRead          F627   2631
0302: bcReader        F615   0548
0311: bcSectran       F630
0304: bcSeldsk        F61B   2286
0307: bcSetdma        F624   2626
0306: bcSetsec        F621   3685
0305: bcSettrk        F61E   2599 3682
0296: bcWboot         F603   0468
0309: bcWrite         F62A   2940
0153: BDOSBase        E800   0154 0156 0326
0122: BDOSE           0005   0123
0154: BDOSEntry       E800
0143: BDOSLength      0E00   0146 0156 0157
3965: bdosStack       F4F8   0342
0332: BdosStart       E800
0056: BELL            0007
0156: BIOSBase        F600
0144: BIOSLength      0A00   0146
0116: BIOSPAGE        0002
0157: BIOSStart       F600   0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305 0306 0307 0308 0309 0310 0311 3974
0253: BlockSize       0800   0275
1060: BSspaceBS       EA3E   0999
0034: BYTE            0001   1173
3946: byteAllocationFlag F4A9   1623 2319 2485 3192 3407
3912: caAllocVector   F48E   1853 2339 2341 2366 2750 3245 3312
3911: caCheckSum      F48C   3713
3909: caDirectoryDMA  F488   2306 2620 3131 3322 3705
3905: caDirMaxValue   F482   2297 2373 2648 3165
3910: caDiskParamBlock F48A   1970 2311
3914: caListSize      0008   2307
3913: caListSizeEnd   F490   3914
3908: caListSizeStart F488   3914
0094: CARET           005E   0842
0836: CaretOut        E948   1034 1115
3907: caSector        F486   2303 2607 3673
3938: caSkewTable     F4A0   2295
3906: caTrack         F484   2300 2603 3664
0151: CCPEntry        E000   0153 0157
0142: CCPLength       0800   0146 0153 0157
0928: CheckCTL_S      E9AC   0917
2890: CheckExtents    F035   2884
3341: CheckRODirectory F221   1437 1762
3344: CheckROFile     F224   1574
3693: CheckSumUtility F3AB   2924 3635
3335: CheckWrite      F21A   1428 1572 1747 2557
2459: CloseDirEntry   EE39   1287 3010 3460
2541: CloseDirEntryEnd EE9F   2531
2549: CloseDirEntryError EEAB   2501 2511 2516
0074: COLON           003A
1171: columnPosition  EAB2   0861 0886 0951 0971 1129
0069: COMMA           002C
2815: CompareExtents  EFD6   2891
3703: ComputeCheckSum F3B7
3707: ComputeCheckSum1 F3BE   3710
0128: ComTail         0080   0129
0130: ComTailChars    0082
0129: ComTailCount    0081   0130
0905: ConBreak        E98C   0729 0872
0938: ConBreak0       E9BA   0930
0940: ConBreak1       E9BD   0908
0796: ConIn           E921   0500 0987 3830
0869: ConsoleOut      E96B   0843 0855 0860 0948 0956 0963 0965 1057
3363: CopyDir         F232   1765 1954
3321: CopyDirEntryToUserDMA F206   1340 1405
2417: CopyDirRecordToFCB EE01   3504
3357: CopyFCB         F22E   2583
0230: cpmRecordSize   0080   0232 0235 0237 3324 3704 3857
0059: CR              000D   0809 0962 0992 1056
0042: CTRL_C          0003   0933 1039 3811
0043: CTRL_E          0005   1004
0044: CTRL_H          0008   0815 0998 1143
0045: CTRL_K          000B
0046: CTRL_L          000C
0047: CTRL_P          0010   0916 1007
0048: CTRL_R          0012   1016
0049: CTRL_S          0013   0929
0050: CTRL_U          0015   1013
0051: CTRL_X          0018   1010
0052: CTRL_Z          001A
3887: currentDisk     F47A   1208 1813 2255 2266 2272 2284 2641 2659 2678 3823
3952: currentFileRecord F4AF   1496 1506 1576 1654 1687 2704 2951 3392 3445
3883: currentUserNumber F479   0780 0786 2391 2687
0070: DASH            002D
0264: DataBlocks      02C7   0274
0263: DataSectors     0B1C   0264
1432: DeleteFileLoop  EB15   1444
1124: DeleteTheLine   EA7F   1011
1127: DeleteTheLine1  EA80   1134
3956: dirBlockIndex   F4B3   3132 3627
0235: DirBuffSize     0080
0250: DirectoryBlockCount 0002   0275
0237: DirectoryEntryPerRecord 0004   0278
3941: directoryIndex  F4A4   2841 2905 3330
3857: dirEntriesPerRecord 0004   3859
3957: dirEntryIndex   F4B4   2901 3107 3117 3163 3610 3612 3621 3640
3859: dirEntryMask    0003   2902 3622
3858: dirEntryShift   0002   3641
0234: DirEntrySize    0020   0237 0275
3329: DirLocationToReturnLoc F213   1434 1760 1950
3958: dirRecord       F4B6   3644 3695 3714
3936: diskAccessType  F49F   1489 1566 1676 2949 2966
0222: DiskCommandBlock 0046
0221: DiskControlByte 0045
0224: DiskControlTable 0040
0417: diskf           000B
3942: diskMapIndex    F4A5   1590 1619
1491: DiskRead        EB39   2037
0226: DiskReadCode    0001
0231: diskSectorSize  0200   0232 0253 0261
0220: DiskStatusLocation 0043
1568: DiskWrite       EB7C   2080
1661: DiskWrite1      EC05   1657
1670: DiskWrite2      EC10   1665
1691: DiskWriteCleanup EC2D   1674 1678
1689: DiskWriteCleanup0 EC2B   1685
0227: DiskWriteCode   0002
1564: DiskWriteSeq    EB77
3820: DisplayErrorAndWait F42C   3810 3816
3539: DivideHLby8     F2FD   2334 3231 3234
0133: DMABuffer       0080   1210 3897
0063: DOLLAR          0024   0824 2397
0276: dpb3hdAL0       00C0
0277: dpb3hdAL1       0000
0272: dpb3hdBLM       000F
0271: dpb3hdBSH       0004
0278: dpb3hdCKS       0020
0275: dpb3hdDRM       007F   0278
0274: dpb3hdDSM       02C6
0273: dpb3hdEXM       0000
0280: dpb3hdNOH       0002
0279: dpb3hdOFF       0001
0270: dpb3hdSPT       0090
3922: dpbBLM          F493   3443
3921: dpbBSH          F492   3390 3435
3927: dpbCKS          F49B   3694
3926: dpbDABM         F499   2364
3925: dpbDRM          F497   2646 3609
3924: dpbDSM          F495   2317 2333 2349 3230
3929: dpbEnd          F49F   3930
3923: dpbEXM          F494   2709 2818 3472
3928: dpbOFF          F49D   2595 3678
3930: dpbSize         000F   2313
3920: dpbSPT          F490   3651
3919: dpbStart        F490   2312 3930
0449: DUMMY           E8A9   0444 0445
3870: emptyDir        00E5   1439 2387 2858 3894
3894: emptyFCB        F47B   2560
0137: END_OF_FILE     001A
0040: EndOfMessage    0000
1050: EndRead         EA34   0993 0996
3948: entryDisk       F4AB   0390 2679
0292: EOD             FFFF   3106
0078: EQUAL_SIGN      003D
3836: ErrMsg_BadSector F455   3809
3834: ErrMsg_BDOS     F445   3826
3835: ErrMsg_BDOS_DISK F451   3825
3839: ErrMsg_ReadOnlyDisk F470   3801
3838: ErrMsg_ReadOnlyFile F467   3805
3837: ErrMsg_Selection F460   3797
3808: Error_BadSector F41A   2633 2942
3800: Error_DiskReadOnly F40E   3338
3804: Error_FileReadOnly F414   3350
3796: Error_Select    F408   2265
0061: EXCLAIM_POINT   0021
1175: exitParameterByte EAB6   0509 0618 0730 0756 0781 1507 1608 1642 1682 1814 2401 2461 2550 2903 2917 3014 3021 3033 3040 3048 3331 3508 3587
1176: exitParameterWord EAB6   0346 0397 0549 0638 1790 1854 1900 1971
3951: extentValue     F4AE   2711
0029: FALSE           0000   0923 1095 1440 1569 2078 2323 2850
0125: FCB1            005C   0126
0126: FCB2            006C
3939: fcbCopiedFlag   F4A2   2543 3459 3475
3853: fcbCurrentRecord 0021
3949: fcbDisk         F4AC   0348 0385 2681
3851: fcbDiskMapIndex 0010   1615 1754 1763 2477 2482 3182 3184 3404
3847: fcbExtIndex     000C   1429 1748 1764 1945 1953 2115 2432 2525 2534 2730 2882 2998 3018 3062 3481
0015: fcbExtIndexLSB  000C
0016: fcbExtIndexMSB  000E
3846: fcbHiddenfileIndex 000A
3844: fcbLength       0020   2426 2482 2525 2575 3184 3359 3857 3871
3850: fcbRCIndex      000F   2133 2435 2453 2534 2719 2722
3950: fcbRecordCount  F4AD   1497 1655 2707 2955
3845: fcbROfileIndex  0009   3345
3848: fcbS1Index      000D   2579 2879
3849: fcbS2Index      000E   2784 3002 3019 3044 3079 3481
3860: fcbShift        0005   3623
0170: fCloseFile      0010
0161: fConsoleIn      0001
0162: fConsoleOut     0002
0173: fDeleteFile     0013
0165: fGetConsoleStatus 000B
0179: fGetCurrentDisk 0019
0178: fGetLoginVector 0018
0181: fGetSetUserNumber 0020
0166: fGetVersion     000C
1601: FindAvailableBlock EBB3   1593
0176: fMakeFile       0016
0169: fOpenFile       000F
1611: FoundAvailableBlock EBC0   1605
3291: FoundFreeOctet  F1E1   3261 3266 3275 3283
3297: FoundFreeOctet1 F1E7   3293
3299: FoundFreeOctet2 F1E8   3295
3301: FoundFreeOctet3 F1EB   3304
3307: FoundFreeOctet4 F1F3   3309
0163: fPrintString    0009
0174: fReadSeq        0014
0164: fReadString     000A
0177: fRenameFile     0017
3947: fResel          F4AA   0349 0379 2669
0167: fResetSystem    000D
0171: fSearchFirst    0011
0172: fSearchNext     0012
0168: fSelectDisk     000E
0180: fSetDMA         001A
0447: functionCount   0028   0358
0404: functionTable   E857   0363 0417 0447
0175: fWriteSeq       0015
3379: GetBlockNumber  F249   1512 1580
3227: GetClosestBlock F190   1602
3129: GetCurrentDirectoryRecord F141   1438 2132 2386 2422 2476 2868 3181 3342 3370
3414: GetDiskMap16Bit F275   3409
3389: GetDiskMapIndex F256   1589 3380
3393: GetDiskMapIndexLoop F25D   3395
3402: GetDiskMapValue F263   1597 3383
2728: GetExtentAddress EF8D   2418 2708 3464
2782: GetExtentNumberMSB EFC1   2773
2717: GetFcbRecordDetails EF80   2701 2948
2128: GetFileSize1    ECD8   2157
2155: GetFileSize2    ECF8   2148
2158: GetFileSizeExit ECFD   2130
2849: GetNextDirectoryRecord EFFC   1404 1443 1767 1955 2156 2887 2892
2867: GetNextDirectoryRecord1 F016   2859
3055: GetRandomRecordPosition F104   2134 2189
2781: GetWriteFileFlagValue EFC1   1637 1667 2465 2793 2804
0079: GREATER_THAN    003E
0062: HASH_TAG        0023   0947
1641: HaveWriteBlock  EBE6   1583
3855: highestRecordNumber 007F   1577 1673
2592: Home            EEEA   2372 2847
1147: IgnoreTheLine   EA9D   1014
3897: initDAMAddress  F480   1211 1836 2616 3323
2332: InitDisk        ED88   2278
2379: InitDisk1       EDCD   2389 2407
2402: InitDisk2       EDEE   2393 2398
2772: InitializeExtentNumberMSB EFBB   1254 1334 1715
0117: IOBYTE          0003   0637 0657
3738: IsBitSet        F3DA   2269 2661 3760 3772
3745: IsBitSet1       F3E1   3743
3740: IsBitSetLoop    F3DB   3748
2657: IsDiskWriteProtected EF32   2462 3336
1012: IsItDeleteTheLineU EA12
1009: IsItDeleteTheLineX EA0E
1006: IsItPrintToggle EA0A
1096: IsItPrintToggle1 EA62   1094
1000: IsItRubout      EA02
1003: IsPhysicalEOL   EA06
0808: IsPrintableASCII E92C   0501 0838
1081: ItIsPhysicalEOL EA50   1005
1088: ItIsPrintToggle EA57   1008
1069: ItIsRubout      EA47   1002
1165: keyboardByte    EAAF   0797 0906 0939
0065: L_PAREN         0028
2757: Left            EFAC   2759
0082: LEFT_ARROW      005F
0098: LEFT_CURLY      007B
0146: LengthInBytes   2000   0147 0151 0261
0147: LengthInK       0009
0077: LESS_THAN       003C
0058: LF              000A   0811 0892 0964 0994
1110: LL1             EA6F   1118
0032: LO_NIBBLE_MASK  000F   0785 3075
3896: loggedDisks     F47E   1206 1789 2268 2274 2276
3259: LookRight       F1B5   3269
2556: MakeNewFile     EEB0   1717 3031 3498
2362: Mark4Directory  EDB5   2354
1635: MarkNewBlock    EBDF   1628
3865: maxExtValue     001F   2827 3467
0149: MemorySize      0040   0151
3567: Merge           F311   2505 2507
2484: MergeAllocationMaps EE5E   2522
2499: MergeDirEntryNot0 EE6F   2496
2494: MergeFCBisNot0  EE6A   2492
2518: MergeMapLoop    EE87   2502
2504: MergeWordMaps   EE74   2487
3866: moduleMask      000F   3485
3551: MultiplyHLby8   F307   2348 3315
0262: myOffset        0001   0263 0279
3868: nameLength      000F   1336 2412 2470 2569 2575 3489
2914: NoDirRecordsMatch F051   2853 2865
3287: NoFreeBlocks    F1DD   3276 3284
3271: NoMoreLeft      F1C7   3267
3273: NoMoreLeftLoop  F1C8   3277
3279: NoMoreRight     F1D2   3262
3281: NoMoreRightLoop F1D3   3285
2686: NoSelect        EF60   2676
1522: NothingRead     EB71   1502 1509 1514
0935: NothingWaiting  E9B8   0926
0054: NULL            0000
0246: NumberOfHeads   0002   0257 0259 0270 0280
0243: NumberOfLogicalDisks 0004
0031: OFF             0000
0030: ON              FFFF
2411: OpenFile        EDF8   1256 3020
3457: OpenNextExt     F299   1504 1681
3488: OpenNextExt1    F2C5   3477
3505: OpenNextExt3    F2E2   3501
3511: OpenNextExtError F2EA   3486 3496 3500
3480: OpenNextModule  F2BB   3469
2451: OpenSetRecordCount EE30   2447 2449
1174: paramDE         EAB4   0337 0383 0680 0973 1052 1107 1328 1402 1573 1614 1752 1835 2118 2187 2425 2452 2480 2558 2561 2566 2578 2670 2688 2718 2729 2783 2844 2971 3367 3403
1173: paramE          EAB3   0339 0391 0777 2254 2674
0064: PERCENT         0025
0071: PERIOD          002E
0120: Pg0CurentDisk   0004
0119: Pg0CurentUser   0004   0120
0068: PLUS_SIGN       002B
0822: Print           E93B   0683 0831 3827 3829
1167: printEchoFlag   EAB0   0880 0919 1091
0080: QMARK           003F   1330 2875
1338: QMarkFind       EAF5   1331
0066: R_PAREN         0029
0113: RAM             0000   0115 0116 0117 0119 0122 0125 0128 0133 0135
3935: RANDOM_ACCESS   0000
2964: RandomSeek      F084   2036 2079
3007: RandomSeekClose F0C2   3000
3045: RandomSeekError F0FC   2995
3043: RandomSeekErrorBadSeek F0F8   3016 3029 3035
3037: RandomSeekExit  F0F2   3005 3023
2630: ReadBuffer      EF12   1518 3599
3608: ReadDirectory   F32E   2382 2851
3620: ReadDirectory0  F342   3615
3624: ReadDirectory1  F349   3626
3597: ReadDirRecord   F325   3633
1030: ReadEchoRubOut  EA1E   1078
3940: readModeFlag    F4A3   1493 1570 3494
0983: ReadNext        E9ED   1047 1073 1099 1121
0986: ReadNext0       E9EF   1066 1085
3895: readOnlyVector  F47C   1205 1899 2639 2644 2658
0970: ReadString      E9E0   0714 1131 1153
3788: ReAlignMap1     F401   3786
3783: ReAlignMapLoop  F3FB   3791
3781: ReAlignVector   F3FA   3764
1511: RecordOK        EB5C   1499
3872: recordRandom    0021   2119 2191 3873 3874 3875
3873: recordRandomLSB 0021   2972 2975
3874: recordRandomMSB 0022   2977
3875: recordRandomOVF 0023   2991
3871: recordSeq       0020   2188 2722 2997 3872
0255: RecordsPerBlock 0010
0239: RecordsPerExtent 0080   1501 2450 3855
0232: recordsPerSector 0004   0255 0270
1758: RenameLoop      EC4D   1768
1102: RepeatLine      EA66   1017
2667: ReselectDisk    EF3D   1255 1286 1335 1403 1427 1486 1559 1716 1746 1944 2033 2076 2113
2803: ResetFileWriteFlag EFD0
3770: ResetVectorBit  F3F3
0378: ReturnToCaller  E832   0352
0394: ReturnToCaller1 E84D   0381 0387 0616
2765: Right           EFB6   2763 2767
3525: RotateRightHLbyB F2F0   3533
3530: RotateRightHLbyB1 F2F6   3528
0083: RUBOUT          007F   1001
3179: ScanDiskMap     F165   1441 2405
3186: ScanDiskMap0    F16F   3218
3211: ScanDiskMap2    F186   3200
3202: ScanDiskMapWord F180   3194
3944: searchAddress   F4A7   1401 2845 2855
2839: SearchForDirectoryRecord EFE7   1339 1430 1749 1946 2116 2413 2471 2563 3490
3943: searchLength    F4A6   2842 2869
0284: SectorMask      0003
0249: SectorsPerBlock 0004   0253 0255 0258 0264 0284
0259: SectorsPerCylinder 0024   0262 0263
0248: SectorsPerTrack 0012   0257 0259 0270
3648: Seek            F36D   1517 1648 3645
3653: Seek0           F377   3657
3639: SeekDir         F35C   2545 3374 3632
2263: Select          ED21   1213 2259
2253: SelectCurrent   ED16   0392 1237 2684
2283: SelectDisk      ED42   2264
2326: SelectDisk1     ED84   2322
0076: SEMICOLON       003B
3934: SEQ_ACCESS      0001   1488 1565
3434: SetActualRecordAdd F281   1516 1647
3439: SetActualRecordAddLoop F288   3441
1948: SetAttributesLoop EC92   1956
2357: SetBitLoop      EDB0   2360
2615: SetDataDMA      EF04   1212 1837 2929 3600
2619: SetDirDMA       EF09   2926 3598
3143: SetDirectoryEntry F14F   2406 2582
2638: SetDiskReadOnly EF1A   1881 3725
2622: SetDMA          EF0C   2617
3105: SetEndDirectory F131   2377 2846 2915 3616
3585: SetExitParamTo1 F31F   1523 1578 3512
2792: SetFileWriteFlag EFCA   2430 2585 3049 3513
3729: SetNewCheckSum  F3D8   3718
2894: SetNextPosition F03A   2876 2880 2888
2700: SetRecordVars   EF69   1495 1575 3506
2739: SetResetMapBit  EF95   3214
0784: SetUserNumber   E91B   0779
3758: SetVectorBit    F3EA   2275 2643
3554: ShiftLeftHLbyB  F309   3558
3542: ShiftRightHLbyB F2FF   2749 3546 3642
0961: showCRLF        E9D6   0949 1084 3822
0946: showHashCRLF    E9C0   1105 1148
0950: showHashCRLF1   E9C8   0957
0072: SLASH           002F
0055: SOH             0001
0060: SPACE           0020   0817 0859 0889 0955 1139 1149 1151
0291: STACK_SIZE      0020   3964
3964: stackBottom     F4B8
1170: startingColumn  EAB1   0952 0972 1128
3162: StillInDirectory F158   2863 3144 3723
0261: SystemSectors   0011   0262
0057: TAB             0009   0813 0854
0852: TabOut          E958   0506 0528 0829 0839
0858: TabOut0         E95E   0863
2873: TestNextPosition F01F   2899
0924: ToggleFlag1     E9A9   0922
0123: TopRAM          0007
0258: TotalNumberOfBlocks 02D0
0257: TotalNumberOfSectors 0B40   0258 0263
0135: TPA             0100
0247: TracksPerHead   0050   0257
0028: TRUE            FFFF   0920 0941 1092 1492 2035 2320 2327 2381 2404 2542 2668 2923
0081: UNDER_SCORE     005F
3503: UpdateFCB       F2DF   3478 3492
2947: UpdateRecordVariables F072   1519 1680 1692
1163: usersStack      EAAD   0341 0395
1285: vCloseFile      EADD   0422
2112: vComputeFileSize ECC3   0441
0499: vConsoleIn      E8AD   0406
0527: vConsoleOut     E8BE   0407
1426: vDeleteFile     EB0A   0425
0604: vDirectConIO    E8D1   0411
0613: vDirectConIO1   E8D9   0607
0290: VERSION         0020   0755
1326: vFindFirst      EAE3   0423
1400: vFindNext       EAFB   0424
1852: vGetAllocAddr   EC79   0433
0728: vGetConsoleStatus E900   0416
1812: vGetCurrentDisk EC69   0431
1969: vGetDiskParamBlock ECA4   0437
0636: vGetIOBYTE      E8E7   0412
1788: vGetLoginVector EC62   0430
1898: vGetReadOnlyMap EC83   0435
0776: vGetSetUserNumber E90D   0438
0754: vGetVersion     E907   0418
0581: vListOut        E8CD   0410
1714: vMakeFile       EC30   0428
1253: vOpenFile       EAD4   0421
0679: vPrintString    E8F3   0414
0566: vPunchOut       E8C9   0409
0547: vReaderIn       E8C2   0408
2032: vReadRandom     ECAB   0439
1485: vReadSeq        EB31   0426
0713: vReadString     E8FC   0415
1745: vRenameFile     EC39   0429
2221: vResetDrive     ED12   0443
1203: vResetSystem    EAB8   0419
1236: vSelectDisk     EAD1   0420
1834: vSetDMA         EC70   0432
1943: vSetFileAttributes EC8A   0436
0656: vSetIOBYTE      E8EE   0413
2186: vSetRandomRecord ECFF   0442
0467: vSystemReset    E8AA   0405
1880: vWriteProtectDisk EC80   0434
2075: vWriteRandom    ECB7   0440
2248: vWriteRandom0Fill ED15   0446
1558: vWriteSeq       EB74   0427
3815: WaitBeforeBoot  F426   3798 3802 3806
0115: WarmBoot        0000   0934 1043 3812 3817
3424: WasBlockAllocated F27B   1513 1581
0035: WORD            0002   1174 1176
0195: WriteAllocated  0000   1582
2939: WriteBuffer     F06A   1651 2928
0197: WriteCleanBuffer 0002   1639 1660
2921: WriteDir        F05A   1442 2546 3375
0196: WriteDirectory  0001   2927
3867: writeFlagMask   0080
3973: Z_HighestLocation F4F8   3974
3974: Z_MemoryLeft    0107
0039: ZERO            0000
