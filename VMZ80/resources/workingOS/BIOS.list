0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018-11-22 Z80 idiom
0006: F600         ; 2017-03-31 Added List out functionality for List Device
0007: F600         ; 2017-03-02 Refactored the CP/M Suite
0008: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0009: F600         ; 2014-01-16
0010: F600         ; 2014-03-14  :  Frank Martyn
0011: F600
0012: F600                        Include ./stdHeader.Z80
0013: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0014: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0015: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0016: F600         ; stdHeader.asm
0017: F600         ; standard equates
0018: F600
0019: F600         ; 2017-03-02 Refactored the CP/M Suite
0020: F600
0021: F600
0022: F600             TRUE       EQU    -1                   ; not false
0023: F600             FALSE      EQU    0000H
0024: F600             ON         EQU    -1
0025: F600             OFF        EQU    0000H
0026: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0027: F600
0028: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0029: F600             WORD       EQU    2                    ; number of bytes for "word" type
0030: F600
0031: F600
0032: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0033: F600             ZERO       EQU    00H                  ; Zero
0034: F600             EndOfMessage EQU    00H
0035: F600
0036: F600             CTRL_C     EQU    03H                  ; ETX
0037: F600             CTRL_E     EQU    05H                  ; physical eol
0038: F600             CTRL_H     EQU    08H                  ; backspace
0039: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0040: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0041: F600             CTRL_P     EQU    10H                  ; prnt toggle
0042: F600             CTRL_R     EQU    12H                  ; repeat line
0043: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0044: F600             CTRL_U     EQU    15H                  ; line delete
0045: F600             CTRL_X     EQU    18H                  ; =ctl-u
0046: F600             CTRL_Z     EQU    1AH                  ; end of file
0047: F600
0048: F600             NULL       EQU    00H                  ; Null
0049: F600             SOH        EQU    01H                  ; Start of Heading
0050: F600             BELL       EQU    07H                  ; Bell
0051: F600             TAB        EQU    09H                  ; Tab
0052: F600             LF         EQU    0AH                  ; Line Feed
0053: F600             CR         EQU    0DH                  ; Carriage Return
0054: F600             SPACE      EQU    20H                  ; Space
0055: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0056: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0057: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0058: F600             PERCENT    EQU    25H                  ; Percent Sign
0059: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0060: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0061: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0062: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0063: F600             COMMA      EQU    2CH                  ; Comma
0064: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0065: F600             PERIOD     EQU    2EH                  ; Period
0066: F600             SLASH      EQU    2FH                  ; /
0067: F600             ASCII_ZERO EQU    30H                  ; zero
0068: F600             COLON      EQU    3AH                  ; Colon
0069: F600
0070: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0071: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0072: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0073: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0074: F600             QMARK      EQU    3FH                  ; Question Mark
0075: F600             UNDER_SCORE EQU    5FH                  ; under score _
0076: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0077: F600             RUBOUT     EQU    7FH                  ; Delete Key
0078: F600
0079: F600
0080: F600             ASCII_A    EQU    'A'
0081: F600             ASCII_C    EQU    'C'
0082: F600             ASCII_K    EQU    'K'
0083: F600             ASCII_N    EQU    'N'
0084: F600             ASCII_Q    EQU    'Q'
0085: F600             ASCII_R    EQU    'R'
0086: F600             ASCII_W    EQU    'W'
0087: F600             ASCII_Y    EQU    'Y'
0088: F600             CARET      EQU    '^'
0089: F600             ASCII_LO_A EQU    'a'
0090: F600             ASCII_LO_K EQU    'k'
0091: F600             ASCII_LO_P EQU    'p'
0092: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0093: F600
0094: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0095: F600                        Include ./osHeader.Z80
0096: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0097: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0098: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0099: F600         ; osHeader.asm
0100: F600
0101: F600         ; 2017-03-02 Refactored the CP/M Suite
0102: F600
0103: F600         ; Contains the Equates used by the CP/M system
0104: F600
0105: F600         ;------------------------Page Zero Constants ---------------------------------
0106: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0107: F600
0108: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0109: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0110: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0111: F600
0112: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0113: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0114: F600
0115: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0116: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0117: F600
0118: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0119: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0120: F600
0121: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0122: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0123: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0124: F600         ;-----------------------------------------------------------------------
0125: F600
0126: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0127: F600         ;-----------------------------------------------------------------------
0128: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0129: F600         ;-----------------------------------------------------------------------
0130: F600             END_OF_FILE EQU    1AH                  ; end of file
0131: F600         ;-----------------------------------------------------------------------
0132: F600
0133: F600         ;--------------- CP/M Constants -----------------------------------------
0134: F600
0135: F600             CCPLength  EQU    0800H                ; Constant
0136: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0137: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0138: F600
0139: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0140: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0141: F600
0142: F600             MemorySize EQU    64
0143: F600
0144: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0145: F600
0146: F600             BDOSBase   EQU    CCPEntry + CCPLength
0147: F600             BDOSEntry  EQU    BDOSBase + 6
0148: F600
0149: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0150: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0151: F600         ;-----------------------------------------------------------------------
0152: F600
0153: F600         ;------------------- BDOS System Call Equates --------------------------
0154: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0155: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0156: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0157: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0158: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0159: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0160: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0161: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0162: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0163: F600             fCloseFile EQU    10H                  ; closef - Close File
0164: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0165: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0166: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0167: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0168: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0169: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0170: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0171: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0172: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0173: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0174: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0175: F600         ;-----------------------------------------------------------------------
0176: F600
0177: F600
0178: F600
0179: F600
0180: F600
0181: F600         ;*******************************************************************************
0182: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0183: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0184: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0185: F600         ; sector write) or to an allocation block that has already been allocated to a
0186: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0187: F600         ;*******************************************************************************
0188: F600             WriteAllocated EQU    00H
0189: F600             WriteDirectory EQU    01H
0190: F600             WriteUnallocated EQU    02H
0191: F600
0192: F600
0193: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0194: F600                        Include ./diskHeader.Z80
0195: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0196: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0197: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0198: F600         ; diskHeader.asm
0199: F600
0200: F600         ; 2017-03-02 Refactored the CP/M Suite
0201: F600
0202: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0203: F600
0204: F600         ; Contains the Equates used by the CP/M system to handle disks
0205: F600
0206: F600
0207: F600         ;*******************************************************************************
0208: F600         ;
0209: F600         ;     Disk related values
0210: F600         ;
0211: F600         ;
0212: F600         ;*******************************************************************************
0213: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0214: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0215: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0216: F600         ; for boot
0217: F600             DiskControlTable EQU    0040H
0218: F600
0219: F600             DiskReadCode EQU    01H                  ; Code for Read
0220: F600             DiskWriteCode EQU    02H                  ; Code for Write
0221: F600
0222: F600
0223: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0224: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0225: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0226: F600
0227: F600             DirEntrySize EQU    20H                  ; (32)
0228: F600             DirBuffSize EQU    cpmRecordSize
0229: F600
0230: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0231: F600
0232: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0233: F600
0234: F600
0235: F600         ;-------------------------------------------------------------------------------------
0236: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0237: F600
0238: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0239: F600             NumberOfHeads EQU    02H                  ; number of heads
0240: F600             TracksPerHead EQU    50H                  ; 80
0241: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0242: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0243: F600             DirectoryBlockCount EQU    02H                  ;
0244: F600         ;-----------------------------------------------------------------------
0245: F600
0246: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0247: F600
0248: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0249: F600
0250: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0251: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0252: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0253: F600
0254: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0255: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0256: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0257: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0258: F600
0259: F600         ;-----------------------------------------------------------------------
0260: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0261: F600         ;-----------------------------------------------------------------------
0262: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0263: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0264: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0265: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0266: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0267: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0268: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0269: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0270: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0271: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0272: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0273: F600             dpb3hdNOH  EQU    NumberOfHeads
0274: F600
0275: F600         ;*******************************************************************************
0276: F600
0277: F600             SectorMask EQU    SectorsPerBlock - 1
0278: F600
0279: F600         ;***************************************************************************
0280: F600
0281: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0282: F600
0283: F600
0284: F600             INopCode   EQU    0DBH
0285: F600             OUTopCode  EQU    0D3H
0286: F600
0287: F600
0288: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0289: F600         ; BIOS jum Vector
0290: F600             CodeStart:
0291: F600
0292: F600 C3 8C FE               JP     BOOT                 ; 00  Not Yet Checked
0293: F603             WarmBootEntry:
0294: F603 C3 41 FE               JP     WBOOT                ; 01 Not Yet Checked
0295: F606 C3 F5 F8               JP     CONST                ; 02 Checked
0296: F609 C3 0B F9               JP     CONIN                ; 03 Checked
0297: F60C C3 19 F9               JP     CONOUT               ; 04 Checked
0298: F60F C3 3F F9               JP     LIST                 ; 05 Checked
0299: F612 C3 4F F9               JP     PUNCH                ; 06 Not Yet Checked *
0300: F615 C3 61 F9               JP     READER               ; 07 Not Yet Checked *
0301: F618 C3 71 F9               JP     HOME                 ; 08 Checked
0302: F61B C3 81 F9               JP     SELDSK               ; 09 Checked
0303: F61E C3 A8 F9               JP     SETTRK               ; 0A Checked
0304: F621 C3 AE F9               JP     SETSEC               ; 0B Checked
0305: F624 C3 B3 F9               JP     SETDMA               ; 0C Checked
0306: F627 C3 BC F9               JP     READ                 ; 0D Not Yet Checked
0307: F62A C3 CF F9               JP     WRITE                ; 0E Not Yet Checked
0308: F62D C3 27 F9               JP     LISTST               ; 0F Not Yet Checked *
0309: F630 C3 B9 F9               JP     SECTRAN              ; 10 Checked
0310: F633
0311: F633         ;-------------------------------------------------
0312: F633                        ORG    (($+10H)/10H) * 10H
0313: F640
0314: F640             DiskBuffer:
0315: F640                        DS     diskSectorSize
0316: F840             AfterDiskBuffer EQU    $
0317: F840         ;-------------------------------------------------
0318: F840
0319: F840
0320: F840
0321: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0322: F840
0323: F840
0324: F840
0325: F840         ;-------------------------------------------------
0326: F840
0327: F840             TTYStatusPort EQU    0EDH
0328: F840             TTYDataPort EQU    0ECH
0329: F840             TTYOutputReady EQU    01H                  ; Status Mask
0330: F840             TTYInputReady EQU    02H                  ; Status Mask
0331: F840
0332: F840             CRT_StatusPort EQU    02H
0333: F840             CRT_DataPort EQU    01H
0334: F840             CRT_OutputReady EQU    80H                  ; Status Mask - ready for output
0335: F840             CRT_InputReady EQU    07FH                 ; Status Mask - bytes yet to have been read
0336: F840
0337: F840             CommunicationStatusPort EQU    0EDH
0338: F840             CommunicationDataPort EQU    0ECH
0339: F840             CommunicationOutputReady EQU    01H                  ; Status Mask
0340: F840             CommunicationInputReady EQU    02H                  ; Status Mask
0341: F840
0342: F840             PrinterStatusPort EQU    011H
0343: F840             PrinterDataPort EQU    010H
0344: F840             PrinterOutputReady EQU    0FFH                 ; Status Mask - ready for output
0345: F840             PrinterInputReady EQU    07FH                 ; Status Mask - not used
0346: F840
0347: F840
0348: F840             TTYTable:
0349: F840 ED                     DB     TTYStatusPort
0350: F841 EC                     DB     TTYDataPort
0351: F842 01                     DB     TTYOutputReady
0352: F843 02                     DB     TTYInputReady
0353: F844             CRT_Table:
0354: F844 02                     DB     CRT_StatusPort
0355: F845 01                     DB     CRT_DataPort
0356: F846 80                     DB     CRT_OutputReady
0357: F847 7F                     DB     CRT_InputReady
0358: F848             CommunicationTable:
0359: F848 ED                     DB     CommunicationStatusPort
0360: F849 EC                     DB     CommunicationDataPort
0361: F84A 01                     DB     CommunicationOutputReady
0362: F84B 02                     DB     CommunicationInputReady
0363: F84C             PrinterTable:
0364: F84C 11                     DB     PrinterStatusPort
0365: F84D 10                     DB     PrinterDataPort
0366: F84E FF                     DB     PrinterOutputReady
0367: F84F 7F                     DB     PrinterInputReady
0368: F850
0369: F850
0370: F850         ;----------------------------------------------------------------------
0371: F850
0372: F850         ; SelectRoutine. When called, the calling code has a vector table immediately following it.
0373: F850         ; it is used to get the correct physical routine determined by the IOBYTE bits for the
0374: F850         ; logical device. (00,01,10,11).
0375: F850         ; It will transfer control to a specified address following its calling address
0376: F850         ; according to the values in bits 1, 0 in A.
0377: F850
0378: F850             SelectRoutine:
0379: F850 E6 03                  AND    03H                  ; Keep low 2 bits
0380: F852 87                     ADD    A,A                  ; double for word size add
0381: F853 E3                     EX     (SP),HL              ; HL-> first word of address after CALL instruction
0382: F854 5F                     LD     E,A                  ; Add on selection value to address table base
0383: F855 16 00                  LD     D,00H
0384: F857 19                     ADD    HL,DE                ; HL-> now has the selected routine
0385: F858 7E                     LD     A,(HL)               ; LS Byte
0386: F859 23                     INC    HL                   ; HL-> MS byte
0387: F85A 66                     LD     H,(HL)               ; MS byte
0388: F85B 6F                     LD     L,A                  ; HL->routine
0389: F85C E3                     EX     (SP),HL              ; top of stack -> routine
0390: F85D C9                     RET                         ; transfer control to the selected routine
0391: F85E         ;----------------------routines called by SelectRoutine----------------------------
0392: F85E         ;----------------------------------------------------------------------------------
0393: F85E
0394: F85E         ; ------------ Status In
0395: F85E             TTYInStatus:
0396: F85E 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0397: F861 C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0398: F864             CRT_InStatus:
0399: F864 21 44 F8               LD     HL,CRT_Table         ; HL-> control table
0400: F867 C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0401: F86A             CommunicationInStatus:
0402: F86A 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0403: F86D C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0404: F870             DummyInStatus:
0405: F870 3E FF                  LD     A,0FFH               ; Dummy always indicates data ready
0406: F872 C9                     RET
0407: F873
0408: F873         ; ------------ Status Out
0409: F873             TTYOutStatus:
0410: F873 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0411: F876 C3 DA F8               JP     OutputStatus         ; use of JMP, OutputStatus will execute thr RETurn
0412: F879             CRT_OutStatus:
0413: F879 21 44 F8               LD     HL,CRT_Table         ; HL-> control table
0414: F87C C3 DA F8               JP     OutputStatus         ; use of JMP, OutputStatus will execute thr RETurn
0415: F87F             CommunicationOutStatus:
0416: F87F 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0417: F882 C3 DA F8               JP     OutputStatus         ; use of JMP, OutputStatus will execute thr RETurn
0418: F885             PrinterStatus:
0419: F885 21 4C F8               LD     HL,PrinterTable      ; HL-> control table
0420: F888 C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0421: F88B             DummyOutStatus:
0422: F88B 3E FF                  LD     A,0FFH               ; Dummy always indicates ready to output data
0423: F88D C9                     RET
0424: F88E
0425: F88E         ; ------------ Data In
0426: F88E             TTYInput:
0427: F88E 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0428: F891 C3 CA F8               JP     InputData            ; use of JMP, InputStatus will execute thr RETurn
0429: F894             CRT_Input:
0430: F894 21 44 F8               LD     HL,CRT_Table         ; HL-> control table
0431: F897 CD CA F8               CALL   InputData            ; ** special **
0432: F89A E6 7F                  AND    07FH                 ; Strip off high order bit
0433: F89C C9                     RET
0434: F89D             CommunicationInput:
0435: F89D 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0436: F8A0 C3 CA F8               JP     InputData            ; use of JMP, InputStatus will execute thr RETurn
0437: F8A3             DummyInput:
0438: F8A3 3E 1A                  LD     A,END_OF_FILE        ; Dummy always returns EOF
0439: F8A5 C9                     RET
0440: F8A6
0441: F8A6         ; ------------ Data Out
0442: F8A6             TTYOutput:
0443: F8A6 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0444: F8A9 C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0445: F8AC             CRT_Output:
0446: F8AC 21 44 F8               LD     HL,CRT_Table         ;HL-> control table
0447: F8AF C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0448: F8B2             CommunicationOutput:
0449: F8B2 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0450: F8B5 C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0451: F8B8             PrinterOutput:
0452: F8B8 21 4C F8               LD     HL,PrinterTable      ; HL-> control table
0453: F8BB C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0454: F8BE             DummyOutput:
0455: F8BE C9                     RET                         ; Dummy always discards the data
0456: F8BF         ;-----------------------------------		----------------------------------------
0457: F8BF         ;---------------------------------------------------------------------------
0458: F8BF             InputStatus:                      ; return- A = 00H no incoming data
0459: F8BF 7E                     LD     A,(HL)               ; get status port
0460: F8C0 32 C4 F8               LD     (InputStatusPort),A  ; ** self modifying code
0461: F8C3 DB                     DB     INopCode             ; IN opcode
0462: F8C4             InputStatusPort:
0463: F8C4 00                     DB     00H                  ; <- set from above
0464: F8C5 23                     INC    HL                   ; move HL to point to input data mask
0465: F8C6 23                     INC    HL
0466: F8C7 23                     INC    HL
0467: F8C8 A6                     AND    M                    ; mask with input status
0468: F8C9 C9                     RET                         ; return with status (00 nothing, FF - data available)
0469: F8CA         ;---------------------------------------------------------------------------
0470: F8CA             InputData:                      ; return with next character
0471: F8CA E5                     PUSH   HL                   ; save control table pointer
0472: F8CB CD BF F8               CALL   InputStatus
0473: F8CE E1                     POP    HL                   ; restore the control table
0474: F8CF CA CA F8               JP     Z,InputData          ; wait until incoming data
0475: F8D2 23                     INC    HL                   ; HL <- data port
0476: F8D3 7E                     LD     A,(HL)               ; get data port
0477: F8D4 32 D8 F8               LD     (InputDataPort),A    ; modify code here
0478: F8D7 DB                     DB     INopCode             ; do the actual I/O
0479: F8D8             InputDataPort:
0480: F8D8 00                     DB     00H                  ; <- set from above
0481: F8D9 C9                     RET                         ; return with data in A
0482: F8DA         ;---------------------------------------------------------------------------
0483: F8DA             OutputStatus:                      ; return - A = 00H not ready
0484: F8DA 7E                     LD     A,(HL)
0485: F8DB 32 DF F8               LD     (OutputStatusPort),A
0486: F8DE DB                     DB     INopCode             ; IN opcode
0487: F8DF             OutputStatusPort:
0488: F8DF 00                     DB     00H                  ; <- set from above
0489: F8E0 23                     INC    HL                   ; HL , Output status mask
0490: F8E1 23                     INC    HL
0491: F8E2 A6                     AND    M                    ; mask with output status, 00 = Not ready
0492: F8E3 C9                     RET
0493: F8E4         ;---------------------------------------------------------------------------
0494: F8E4             OutputData:                      ; data in Register C is output
0495: F8E4 E5                     PUSH   HL                   ; save control table pointer
0496: F8E5 CD DA F8               CALL   OutputStatus
0497: F8E8 E1                     POP    HL                   ; restore table pointer
0498: F8E9 CA E4 F8               JP     Z,OutputData         ; wait until incoming data
0499: F8EC 23                     INC    HL                   ; HL <- data port
0500: F8ED 7E                     LD     A,(HL)               ; get data port
0501: F8EE 32 F3 F8               LD     (OutputDataPort),A   ; store it here Modify the code
0502: F8F1 79                     LD     A,C                  ; get the data to output
0503: F8F2 D3                     DB     OUTopCode            ; Do the I/O here !!
0504: F8F3             OutputDataPort:
0505: F8F3 00                     DB     00H                  ; <- set from above
0506: F8F4 C9                     RET
0507: F8F5         ;---------------------------------------------------------------------------
0508: F8F5
0509: F8F5
0510: F8F5         ;---------------------------------------------------------------------------
0511: F8F5         ;	Console Status  BIOS 02
0512: F8F5         ; Entered directly from BIOS JMP vector, returns Register A
0513: F8F5         ; 00H -> No data ,  0FFH -> there is data
0514: F8F5         ;
0515: F8F5
0516: F8F5             CONST:
0517: F8F5 CD FD F8               CALL   GetConsoleStatus     ; return A= zero or not zero
0518: F8F8 B7                     OR     A
0519: F8F9 C8                     RET    Z                    ; if 0 no returning data
0520: F8FA 3E FF                  LD     A,0FFH               ; else indicate there is data
0521: F8FC C9                     RET
0522: F8FD         ;---------------------------------------------------------------------------
0523: F8FD             GetConsoleStatus:
0524: F8FD 3A 03 00               LD     A,(IOBYTE)           ; Get IO redirection byte
0525: F900 CD 50 F8               CALL   SelectRoutine
0526: F903
0527: F903 5E F8                  DW     TTYInStatus          ; 00 TTY
0528: F905 64 F8                  DW     CRT_InStatus         ; 01 CRT
0529: F907 6A F8                  DW     CommunicationInStatus ; 10 BAT
0530: F909 70 F8                  DW     DummyInStatus        ; 11 UC1
0531: F90B
0532: F90B         ;---------------------------------------------------------------------------
0533: F90B         ;	Console In  BIOS 03
0534: F90B         ; Get console Input character entered directly from the BIOS jmp Vector
0535: F90B         ; return the character from the console in the A register.
0536: F90B         ; most significant bit will be 0. except when "reader" (communication)
0537: F90B         ; port has input , all 8 bits are reurned
0538: F90B         ;
0539: F90B         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0540: F90B
0541: F90B             CONIN:
0542: F90B 3A 03 00               LD     A,(IOBYTE)           ; get i/o redirection byte
0543: F90E CD 50 F8               CALL   SelectRoutine
0544: F911
0545: F911 8E F8                  DW     TTYInput             ; 00 TTY
0546: F913 94 F8                  DW     CRT_Input            ; 01 CRT
0547: F915 9D F8                  DW     CommunicationInput   ; 10 BAT
0548: F917 A3 F8                  DW     DummyInput           ; 11 UC1
0549: F919
0550: F919         ;---------------------------------------------------------------------------
0551: F919         ;	Console Out  BIOS 04
0552: F919         ;  entered directly from BIOS JMP Vector. it outputs the
0553: F919         ; character in the C register to the appropriate device according to
0554: F919         ; bits 1,0 of IOBYTE
0555: F919             CONOUT:
0556: F919 3A 03 00               LD     A,(IOBYTE)           ; get i/o redirection byte
0557: F91C CD 50 F8               CALL   SelectRoutine
0558: F91F
0559: F91F A6 F8                  DW     TTYOutput            ; 00 TTY
0560: F921 AC F8                  DW     CRT_Output           ; 01 CRT
0561: F923 B2 F8                  DW     CommunicationOutput  ; 10 BAT
0562: F925 BE F8                  DW     DummyOutput          ; 11 UC1
0563: F927
0564: F927         ;---------------------------------------------------------------------------
0565: F927         ;	List Status  BIOS 0F
0566: F927
0567: F927             LISTST:
0568: F927         ; List Device (output) status entered directly from the BIOS JMP Vector
0569: F927         ; returns in A the list device status that indicates if the device will
0570: F927         ; accept another character the IOBYTE's bits 7,6 determin the physical device
0571: F927         ; A = 00H (zero flag set): cannot accpet data
0572: F927         ; A = 0FFH ( zero flag cleared): can accept data
0573: F927
0574: F927 CD 2F F9               CALL   GetListStatus        ; return  A = 0 or non-zero
0575: F92A B7                     OR     A                    ; set flags
0576: F92B C8                     RET    Z                    ; exit if not ready
0577: F92C 3E FF                  LD     A,0FFH               ; else set retuen value for ok
0578: F92E C9                     RET
0579: F92F         ; exit
0580: F92F             GetListStatus:
0581: F92F 3A 03 00               LD     A,(IOBYTE)
0582: F932 07                     RLCA                        ; move bits 7,6
0583: F933 07                     RLCA                        ; to 1,0
0584: F934 CD 50 F8               CALL   SelectRoutine
0585: F937
0586: F937 73 F8                  DW     TTYOutStatus         ; 00 TTY
0587: F939 79 F8                  DW     CRT_OutStatus        ; 01 CRT
0588: F93B 85 F8                  DW     PrinterStatus        ; 10 LPT
0589: F93D 8B F8                  DW     DummyOutStatus       ; 11 UL1
0590: F93F         ;---------------------------------------------------------------------------
0591: F93F         ;	List output  BIOS 05
0592: F93F         ; entered directly from the BIOS JMP Vector
0593: F93F         ; outputs the data in Register C
0594: F93F             LIST:
0595: F93F 3A 03 00               LD     A,(IOBYTE)
0596: F942 07                     RLCA                        ; move bits 7,6
0597: F943 07                     RLCA                        ; to 1,0
0598: F944 CD 50 F8               CALL   SelectRoutine
0599: F947
0600: F947 A6 F8                  DW     TTYOutput            ; 00 TTY
0601: F949 AC F8                  DW     CRT_Output           ; 01 CRT
0602: F94B B8 F8                  DW     PrinterOutput        ; 10 LPT
0603: F94D BE F8                  DW     DummyOutput          ; 11 UL1
0604: F94F
0605: F94F         ;---------------------------------------------------------------------------
0606: F94F         ;	Punch output  BIOS 06	- not tested
0607: F94F         ; entered directly from the BIOS JMP Vector
0608: F94F         ; outputs the data in Register C
0609: F94F             PUNCH:                          ; Punch output
0610: F94F
0611: F94F 3A 03 00               LD     A,(IOBYTE)
0612: F952 0F                     RRCA
0613: F953 0F                     RRCA
0614: F954 0F                     RRCA                        ; move bits 5,4
0615: F955 0F                     RRCA                        ; to 1,0
0616: F956 CD 50 F8               CALL   SelectRoutine
0617: F959
0618: F959 A6 F8                  DW     TTYOutput            ; 00 TTY
0619: F95B BE F8                  DW     DummyOutput          ; 01 PTP
0620: F95D B2 F8                  DW     CommunicationOutput  ; 10 UP1
0621: F95F AC F8                  DW     CRT_Output           ; 11 UP2
0622: F961
0623: F961         ;---------------------------------------------------------------------------
0624: F961         ;	Reader input  BIOS 07	- not tested
0625: F961         ; entered directly from the BIOS JMP Vector
0626: F961         ; inputs data into the A register
0627: F961             READER:                         ; Reader Input
0628: F961 3A 03 00               LD     A,(IOBYTE)
0629: F964 0F                     RRCA
0630: F965 0F                     RRCA                        ; move bits 3,2  to 1,0
0631: F966 CD 50 F8               CALL   SelectRoutine
0632: F969
0633: F969 A6 F8                  DW     TTYOutput            ; 00 TTY
0634: F96B BE F8                  DW     DummyOutput          ; 01 PTR
0635: F96D B2 F8                  DW     CommunicationOutput  ; 10 UR1
0636: F96F AC F8                  DW     CRT_Output           ; 11 UR2
0637: F971
0638: F971         ;---------------------------------------------------------------------------
0639: F971         ;---------------------------------------------------------------------------
0640: F971         ;	Disk routines
0641: F971         ;---------------------------------------------------------------------------
0642: F971         ;**********************
0643: F971         ;	Home Disk	BIOS 08
0644: F971         ;HOME - Home the selected logical disk to track 0.
0645: F971         ;	Before doing this, a check must be made to see if the
0646: F971         ;	physical disk buffer has information that must be
0647: F971         ;	written out. This is indicated by a flag, MustWriteBuffer,
0648: F971         ;	set in the de-blocking code
0649: F971         ;**********************
0650: F971             HOME:
0651: F971 3A 6F FB               LD     A,(MustWriteBuffer)  ; check flag
0652: F974 B7                     OR     A
0653: F975 C2 7B F9               JP     NZ,HomeNoWrite
0654: F978 32 6E FB               LD     (DataInDiskBuffer),A ; no, so indicate empty buffer
0655: F97B             HomeNoWrite:
0656: F97B 0E 00                  LD     C,00H                ; Set to track 0
0657: F97D CD A8 F9               CALL   SETTRK               ; no, physical, only logical
0658: F980 C9                     RET
0659: F981
0660: F981         ;	Select Disk	BIOS 09
0661: F981         ; Select disk in C. C=0 for A: 1 for B: etc.
0662: F981         ; Return the address of the appropriate disk parameter header
0663: F981         ; in HL, or 0000H if selected disk does not exist
0664: F981         ;**********************
0665: F981             SELDSK:
0666: F981 21 00 00               LD     HL,00H               ; Assume an error
0667: F984 79                     LD     A,C
0668: F985 FE 04                  CP     NumberOfLogicalDisks
0669: F987 D0                     RET    NC                   ; return if > max number of Disks
0670: F988
0671: F988 32 71 FB               LD     (SelectedDisk),A     ; save disk number
0672: F98B 6F                     LD     L,A                  ; make disk into word number
0673: F98C 26 00                  LD     H,0
0674: F98E         ; Compute offset down disk parameter table by multiplying by parameter
0675: F98E         ; header length (16 bytes)
0676: F98E 29                     ADD    HL,HL
0677: F98F 29                     ADD    HL,HL
0678: F990 29                     ADD    HL,HL
0679: F991 29                     ADD    HL,HL                ; pointing at right one
0680: F992 11 80 FB               LD     DE,DiskParameterHeaders ; get DPH address
0681: F995 19                     ADD    HL,DE                ; DE -> appropriate DPH
0682: F996 E5                     PUSH   HL                   ; Save DPH pointer
0683: F997 11 0A 00               LD     DE,10                ; DiskParameterBlock Index
0684: F99A 19                     ADD    HL,DE                ; ????? -> cpmRecords per track
0685: F99B 5E                     LD     E,(HL)
0686: F99C 23                     INC    HL
0687: F99D 56                     LD     D,(HL)               ; DE has Parameter Block for selected disk
0688: F99E 21 0F 00               LD     HL,15                ; SectorsPerHead Index
0689: F9A1 19                     ADD    HL,DE                ; HL is at SecPerHeadPerTrack
0690: F9A2 7E                     LD     A,(HL)               ; get the value and
0691: F9A3 32 70 FB               LD     (SelectedDskSecsPerHead),A ; save for actual IO
0692: F9A6
0693: F9A6 E1                     POP    HL                   ; recover DPH pointer
0694: F9A7 C9                     RET
0695: F9A8
0696: F9A8         ;**********************
0697: F9A8         ;	Set Track	BIOS 0A
0698: F9A8         ;SETTRK - Set logical track for next read or write.	Track is in BC
0699: F9A8         ;**********************
0700: F9A8             SETTRK:
0701: F9A8 60                     LD     H,B                  ; select track in BC on entry
0702: F9A9 69                     LD     L,C
0703: F9AA 22 72 FB               LD     (SelectedTrack),HL   ; save for low level driver
0704: F9AD C9                     RET
0705: F9AE         ;**********************
0706: F9AE         ;	Set Sector	BIOS 0B
0707: F9AE         ;SETSEC - Set logical sector for next read or write. Sector is in C
0708: F9AE         ;**********************
0709: F9AE             SETSEC:
0710: F9AE 79                     LD     A,C
0711: F9AF 32 74 FB               LD     (SelectedSector),A   ; save for low level driver
0712: F9B2 C9                     RET
0713: F9B3         ;**********************
0714: F9B3         ;	Set Sector	BIOS 0C
0715: F9B3         ;SetDMA - Set DMA (input/output) address for next read or write. Address in BC
0716: F9B3         ;**********************
0717: F9B3             SETDMA:
0718: F9B3 69                     LD     L,C                  ; select address in BC on entry
0719: F9B4 60                     LD     H,B
0720: F9B5 22 75 FB               LD     (DMAAddress),HL      ; save for low level driver
0721: F9B8 C9                     RET
0722: F9B9         ;**********************
0723: F9B9         ;	Sector Translate	BIOS 10
0724: F9B9         ;SECTRAN - Translate logical sector to physical
0725: F9B9         ; on Entry:	BC= logical sector number DE-> appropriate skew table
0726: F9B9         ; on Exit:	HL = physical sector number
0727: F9B9         ;**********************
0728: F9B9             SECTRAN:
0729: F9B9 C5                     PUSH   BC
0730: F9BA E1                     POP    HL                   ; just move the value from BC to HL
0731: F9BB C9                     RET
0732: F9BC
0733: F9BC         ;************************************************************************************************
0734: F9BC         ;        READ	BIOS
0735: F9BC         ; Read in the  CP/M record specified by previous calls to select disk and to set track  and
0736: F9BC         ; sector. The sector will be read into the address specified in the previous call to set DMA address
0737: F9BC         ;
0738: F9BC         ;************************************************************************************************
0739: F9BC             READ:
0740: F9BC AF                     XOR    A                    ; set record count to 0
0741: F9BD 32 7C FB               LD     (UnalocatedlRecordCount),A
0742: F9C0 3C                     INC    A
0743: F9C1 32 7F FB               LD     (ReadFlag),A         ; Set to non zero to indicate that this is a read
0744: F9C4 32 7E FB               LD     (PrereadSectorFlag),A ; force pre-read
0745: F9C7 3E 02                  LD     A,WriteUnallocated   ; fake de-blocking code into responding as if this
0746: F9C9 32 69 FB               LD     (WriteType),A        ; is the first write to an unallocated allocation block
0747: F9CC C3 21 FA               JP     PerformReadWrite     ; use common code to execute read
0748: F9CF         ;----------------------------------------
0749: F9CF         ;************************************************************************************************
0750: F9CF         ;	WRITE
0751: F9CF         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
0752: F9CF         ;
0753: F9CF         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
0754: F9CF         ;	00H [WriteAllocated]	 An already allocated allocation block (which means a pre-read of the sector may be needed),
0755: F9CF         ;	01H [WriteDirectory]	 To the directory (in which case the data will be written to the disk immediately),
0756: F9CF         ;	02H	[WriteUnallocated]	 To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
0757: F9CF         ;
0758: F9CF         ; Only writes to the directory take place immediately.
0759: F9CF         ; In all other cases, the data will be moved from the DMA address into the disk buffer,
0760: F9CF         ; and only written out when circumstance force the transfer.
0761: F9CF         ; The number of physical disk operations can therefore be reduced considerably.
0762: F9CF         ;************************************************************************************************
0763: F9CF             WRITE:
0764: F9CF         ; Buffered I/O
0765: F9CF AF                     XOR    A
0766: F9D0 32 7F FB               LD     (ReadFlag),A         ; Set to zero to indicate that this is not a read
0767: F9D3 79                     LD     A,C
0768: F9D4 32 69 FB               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
0769: F9D7 FE 02                  CP     WriteUnallocated     ; first write to an unallocated allocation block ?
0770: F9D9 C2 EA F9               JP     NZ,CheckUnallocatedBlock ; No, - in the middle of writing to an unallocated block ?
0771: F9DC         ; Yes, It is the first write to unallocated allocation block.
0772: F9DC         ; Initialize  variables associated with unallocated writes
0773: F9DC 3E 10                  LD     A,RecordsPerBlock    ; Number of records
0774: F9DE 32 7C FB               LD     (UnalocatedlRecordCount),A ; reset Unallocated Record Count to recordsPerBlock
0775: F9E1 21 71 FB               LD     HL,SelectedDkTrkSec
0776: F9E4 11 78 FB               LD     DE,UnallocatedDkTrkSec
0777: F9E7 CD E4 FA               CALL   MoveDkTrkSec         ; copy disk, track & sector into unallocated variables
0778: F9EA
0779: F9EA         ; Check if this is not the first write to an unallocated allocation block -- if it is,
0780: F9EA         ; the unallocated record count has just been set to the number of records in the allocation block
0781: F9EA             CheckUnallocatedBlock:
0782: F9EA 3A 7C FB               LD     A,(UnalocatedlRecordCount)
0783: F9ED B7                     OR     A
0784: F9EE CA 19 FA               JP     Z,RequestPreread     ; No - write to an unallocated block
0785: F9F1 3D                     DEC    A
0786: F9F2 32 7C FB               LD     (UnalocatedlRecordCount),A ; decrement records left
0787: F9F5
0788: F9F5 21 71 FB               LD     HL,SelectedDkTrkSec  ; same Disk, Track & sector as for those in an unallocated block
0789: F9F8 11 78 FB               LD     DE,UnallocatedDkTrkSec
0790: F9FB CD D8 FA               CALL   CompareDkTrkSec      ; are they the same
0791: F9FE C2 19 FA               JP     NZ,RequestPreread    ; NO - do a pre-read
0792: FA01 EB                     EX     DE,HL
0793: FA02 34                     INC    M                    ; increment UnalocatedlRecordCount
0794: FA03 7E                     LD     A,(HL)
0795: FA04 FE 12                  CP     SectorsPerTrack      ; Sector > maximum on track ?
0796: FA06 DA 12 FA               JP     C,NoTrackChange      ; No ( A < M)
0797: FA09 36 00                  LD     (HL),00H             ; Yes
0798: FA0B 2A 79 FB               LD     HL,(UnallocatedTrack)
0799: FA0E 23                     INC    HL                   ; increment track
0800: FA0F 22 79 FB               LD     (UnallocatedTrack),HL
0801: FA12             NoTrackChange:
0802: FA12 AF                     XOR    A
0803: FA13 32 7E FB               LD     (PrereadSectorFlag),A ; clear flag
0804: FA16 C3 21 FA               JP     PerformReadWrite
0805: FA19
0806: FA19             RequestPreread:
0807: FA19 AF                     XOR    A
0808: FA1A 32 7C FB               LD     (UnalocatedlRecordCount),A ; not a write into an unallocated block
0809: FA1D 3C                     INC    A
0810: FA1E 32 7E FB               LD     (PrereadSectorFlag),A ; set flag
0811: FA21         ;*******************************************************
0812: FA21         ; Common code to execute both reads and writes of 128-byte records
0813: FA21         ;*******************************************************
0814: FA21             PerformReadWrite:
0815: FA21 AF                     XOR    A                    ; Assume no disk error will occur
0816: FA22 32 7D FB               LD     (DiskErrorFlag),A
0817: FA25 3A 74 FB               LD     A,(SelectedSector)
0818: FA28 1F                     RRA                         ; Convert selected record
0819: FA29 1F                     RRA                         ; into physical sector by dividing by 4
0820: FA2A E6 3F                  AND    03FH                 ; remove unwanted bits
0821: FA2C 32 77 FB               LD     (SelectedPhysicalSector),A
0822: FA2F 21 6E FB               LD     HL,DataInDiskBuffer  ; see if there is any data here ?
0823: FA32 7E                     LD     A,(HL)
0824: FA33 36 01                  LD     (HL),001H            ; force there is data here for after the actual read
0825: FA35 B7                     OR     A                    ; really is there any data here ?
0826: FA36 CA 56 FA               JP     Z,ReadSectorIntoBuffer ; NO ?- go read into buffer
0827: FA39         ;
0828: FA39         ; The buffer does have a physical sector in it, Note: The disk, track, and PHYSICAL sector
0829: FA39         ; in the buffer need to be checked, hence the use of the CompareDkTrk subroutine.
0830: FA39 11 6A FB               LD     DE,InBufferDkTrkSec
0831: FA3C 21 71 FB               LD     HL,SelectedDkTrkSec  ; get the requested sector
0832: FA3F CD D3 FA               CALL   CompareDkTrk         ; is it in the buffer ?
0833: FA42 C2 4F FA               JP     NZ,SectorNotInBuffer ; NO,jump - it must be read
0834: FA45         ; Yes, it is in the buffer
0835: FA45 3A 6D FB               LD     A,(InBufferSector)   ; get the sector
0836: FA48 21 77 FB               LD     HL,SelectedPhysicalSector
0837: FA4B BE                     CP     M                    ; Check if correct physical sector
0838: FA4C CA 73 FA               JP     Z,SectorInBuffer     ; Yes - it is already in memory
0839: FA4F         ; No, it will have to be read in over current contents of buffer
0840: FA4F             SectorNotInBuffer:
0841: FA4F 3A 6F FB               LD     A,(MustWriteBuffer)
0842: FA52 B7                     OR     A                    ; do we need to write ?
0843: FA53 C4 EF FA               CALL   NZ,WritePhysical     ; if yes - write it out
0844: FA56
0845: FA56             ReadSectorIntoBuffer:
0846: FA56         ; indicate the  selected disk, track, and sector now residing in buffer
0847: FA56 3A 71 FB               LD     A,(SelectedDisk)
0848: FA59 32 6A FB               LD     (InBufferDisk),A
0849: FA5C 2A 72 FB               LD     HL,(SelectedTrack)
0850: FA5F 22 6B FB               LD     (InBufferTrack),HL
0851: FA62 3A 77 FB               LD     A,(SelectedPhysicalSector)
0852: FA65 32 6D FB               LD     (InBufferSector),A
0853: FA68
0854: FA68 3A 7E FB               LD     A,(PrereadSectorFlag) ; do we need to pre-read
0855: FA6B B7                     OR     A
0856: FA6C C4 F4 FA               CALL   NZ,ReadPhysical      ; yes - pre-read the sector
0857: FA6F
0858: FA6F         ; At this point the data is in the buffer.
0859: FA6F         ; Either it was already here, or we returned from ReadPhysical
0860: FA6F
0861: FA6F AF                     XOR    A                    ; reset the flag
0862: FA70 32 6F FB               LD     (MustWriteBuffer),A  ; and store it away
0863: FA73
0864: FA73         ; Selected sector on correct track and  disk is already 1n the buffer.
0865: FA73         ; Convert the selected cpmRecord into relative address down the buffer.
0866: FA73             SectorInBuffer:
0867: FA73 3A 74 FB               LD     A,(SelectedSector)
0868: FA76 E6 03                  AND    SectorMask           ; only want the least bits
0869: FA78 6F                     LD     L,A                  ; to calculate offset into 512 byte buffer
0870: FA79 26 00                  LD     H,00H                ; Multiply by 128 - cpmRecordSize
0871: FA7B 29                     ADD    HL,HL                ; *2
0872: FA7C 29                     ADD    HL,HL                ; *4
0873: FA7D 29                     ADD    HL,HL                ; *8
0874: FA7E 29                     ADD    HL,HL                ; *16
0875: FA7F 29                     ADD    HL,HL                ; *32
0876: FA80 29                     ADD    HL,HL                ; *64
0877: FA81 29                     ADD    HL,HL                ; *128
0878: FA82 11 40 F6               LD     DE,DiskBuffer
0879: FA85 19                     ADD    HL,DE                ; HL -> record number start address
0880: FA86 EB                     EX     DE,HL                ; DE -> sector in the disk buffer
0881: FA87 2A 75 FB               LD     HL,(DMAAddress)      ; Get DMA address (set in SETDMA)
0882: FA8A EB                     EX     DE,HL                ; assume a read so :
0883: FA8B         ; DE -> DMA Address & HL -> sector in disk buffer
0884: FA8B 0E 10                  LD     C,cpmRecordSize/8    ; 8 bytes per move (loop count)
0885: FA8D         ;
0886: FA8D         ;  At this point -
0887: FA8D         ;	C	->	loop count
0888: FA8D         ;	DE	->	DMA address
0889: FA8D         ;	HL	->	sector in disk buffer
0890: FA8D         ;
0891: FA8D 3A 7F FB               LD     A,(ReadFlag)         ; Move into or out of buffer /
0892: FA90 B7                     OR     A                    ; 0 => Write, non Zero => Read
0893: FA91 C2 99 FA               JP     NZ,BufferMove        ; Move out of buffer
0894: FA94
0895: FA94 3C                     INC    A                    ; going to force a write
0896: FA95 32 6F FB               LD     (MustWriteBuffer),A
0897: FA98 EB                     EX     DE,HL                ; DE <--> HL
0898: FA99
0899: FA99         ;The following move loop moves eight bytes at a time from (HL> to (DE), C contains the loop count
0900: FA99             BufferMove:
0901: FA99 7E                     LD     A,(HL)               ; Get byte from source
0902: FA9A 12                     LD     (DE),A               ; Put into destination
0903: FA9B 13                     INC    DE                   ; update pointers
0904: FA9C 23                     INC    HL
0905: FA9D
0906: FA9D 7E                     LD     A,(HL)
0907: FA9E 12                     LD     (DE),A
0908: FA9F 13                     INC    DE
0909: FAA0 23                     INC    HL
0910: FAA1
0911: FAA1 7E                     LD     A,(HL)
0912: FAA2 12                     LD     (DE),A
0913: FAA3 13                     INC    DE
0914: FAA4 23                     INC    HL
0915: FAA5
0916: FAA5 7E                     LD     A,(HL)
0917: FAA6 12                     LD     (DE),A
0918: FAA7 13                     INC    DE
0919: FAA8 23                     INC    HL
0920: FAA9
0921: FAA9 7E                     LD     A,(HL)
0922: FAAA 12                     LD     (DE),A
0923: FAAB 13                     INC    DE
0924: FAAC 23                     INC    HL
0925: FAAD
0926: FAAD 7E                     LD     A,(HL)
0927: FAAE 12                     LD     (DE),A
0928: FAAF 13                     INC    DE
0929: FAB0 23                     INC    HL
0930: FAB1
0931: FAB1 7E                     LD     A,(HL)
0932: FAB2 12                     LD     (DE),A
0933: FAB3 13                     INC    DE
0934: FAB4 23                     INC    HL
0935: FAB5
0936: FAB5 7E                     LD     A,(HL)
0937: FAB6 12                     LD     (DE),A
0938: FAB7 13                     INC    DE
0939: FAB8 23                     INC    HL
0940: FAB9
0941: FAB9 0D                     DEC    C                    ; count down on loop counter
0942: FABA C2 99 FA               JP     NZ,BufferMove        ; repeat till done (CP/M sector moved)
0943: FABD         ; end of loop
0944: FABD
0945: FABD 3A 69 FB               LD     A,(WriteType)        ; write to directory ?
0946: FAC0 FE 01                  CP     WriteDirectory
0947: FAC2 3A 7D FB               LD     A,(DiskErrorFlag)    ; get flag in case of a delayed read or write
0948: FAC5 C0                     RET    NZ                   ; return if delayed read or write
0949: FAC6
0950: FAC6 B7                     OR     A                    ; Any disk errors ?
0951: FAC7 C0                     RET    NZ                   ; yes - abandon attempt to write to directory
0952: FAC8
0953: FAC8 AF                     XOR    A
0954: FAC9 32 6F FB               LD     (MustWriteBuffer),A  ; clear flag
0955: FACC CD EF FA               CALL   WritePhysical
0956: FACF 3A 7D FB               LD     A,(DiskErrorFlag)    ; return error flag to caller
0957: FAD2 C9                     RET
0958: FAD3         ;********************************************************************
0959: FAD3         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
0960: FAD3             CompareDkTrk:
0961: FAD3 0E 03                  LD     C,03H                ; Disk(1), Track(2)
0962: FAD5 C3 DA FA               JP     CompareDkTrkSecLoop
0963: FAD8             CompareDkTrkSec:                      ;Compares just the disk and track   pointed to by DE and HL
0964: FAD8 0E 04                  LD     C,04H                ; Disk(1), Track(2), Sector(1)
0965: FADA             CompareDkTrkSecLoop:
0966: FADA 1A                     LD     A,(DE)
0967: FADB BE                     CP     M
0968: FADC C0                     RET    NZ                   ; Not equal
0969: FADD 13                     INC    DE
0970: FADE 23                     INC    HL
0971: FADF 0D                     DEC    C
0972: FAE0 C8                     RET    Z                    ; return they match (zero flag set)
0973: FAE1 C3 DA FA               JP     CompareDkTrkSecLoop  ; keep going
0974: FAE4
0975: FAE4         ;********************************************************************
0976: FAE4         ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE
0977: FAE4             MoveDkTrkSec:
0978: FAE4 0E 04                  LD     C,04H                ; Disk(1), Track(2), Sector(1)
0979: FAE6             MoveDkTrkSecLoop:
0980: FAE6 7E                     LD     A,(HL)
0981: FAE7 12                     LD     (DE),A
0982: FAE8 13                     INC    DE
0983: FAE9 23                     INC    HL
0984: FAEA 0D                     DEC    C
0985: FAEB C8                     RET    Z
0986: FAEC C3 E6 FA               JP     MoveDkTrkSecLoop
0987: FAEF         ;********************************************************************
0988: FAEF
0989: FAEF         ;********************************************************************
0990: FAEF         ;Write contents of disk buffer to correct sector
0991: FAEF             WritePhysical:
0992: FAEF 3E 02                  LD     A,DiskWriteCode      ; get write function
0993: FAF1 C3 F6 FA               JP     CommonPhysical
0994: FAF4
0995: FAF4             ReadPhysical:
0996: FAF4 3E 01                  LD     A,DiskReadCode       ; get read function
0997: FAF6
0998: FAF6             CommonPhysical:
0999: FAF6 32 5C FB               LD     (DCTCommand),A       ; set the command
1000: FAF9 3A 6A FB               LD     A,(InBufferDisk)
1001: FAFC E6 03                  AND    03H                  ; only units 0 to 3
1002: FAFE 32 5D FB               LD     (DCTUnit),A          ; set disk
1003: FB01 2A 6B FB               LD     HL,(InBufferTrack)
1004: FB04 7D                     LD     A,L                  ; for this controller it is a byte value
1005: FB05 32 5F FB               LD     (DCTTrack),A         ; set track
1006: FB08         ;  The sector must be converted into a head number and sector number.
1007: FB08         ; This set of disks and Diskettes only have two Heads ******
1008: FB08 06 00                  LD     B,0                  ; assume head 0
1009: FB0A 21 70 FB               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1010: FB0D 3A 6D FB               LD     A,(InBufferSector)   ; get target sector
1011: FB10             Head0:
1012: FB10 BE                     CP     M                    ; Need another Head?
1013: FB11 DA 19 FB               JP     C,Head1              ; nope Acc < M
1014: FB14
1015: FB14 96                     SUB    M                    ; subtrack track value
1016: FB15 04                     INC    B                    ; Increment head
1017: FB16 C3 10 FB               JP     Head0                ; loop til done
1018: FB19
1019: FB19             Head1:
1020: FB19 3C                     INC    A                    ; physical sectors start at 1
1021: FB1A 32 60 FB               LD     (DCTSector),A
1022: FB1D 78                     LD     A,B
1023: FB1E 32 5E FB               LD     (DCTHead),A          ; set head number
1024: FB21
1025: FB21 21 00 02               LD     HL,diskSectorSize
1026: FB24 22 61 FB               LD     (DCTByteCount),HL    ; set byte count
1027: FB27 21 40 F6               LD     HL,DiskBuffer
1028: FB2A 22 63 FB               LD     (DCTDMAAddress),HL   ; set transfer address
1029: FB2D
1030: FB2D         ;	As only one control table is in use, close the status and busy chain pointers
1031: FB2D         ;  back to the main control bytes
1032: FB2D 21 43 00               LD     HL,DiskStatusLocation
1033: FB30 22 65 FB               LD     (DCTNextStatusBlock),HL
1034: FB33 21 45 00               LD     HL,DiskControlByte
1035: FB36 22 67 FB               LD     (DCTNextControlLocation),HL
1036: FB39 21 5C FB               LD     HL,DCTCommand
1037: FB3C 22 46 00               LD     (DiskCommandBlock),HL
1038: FB3F
1039: FB3F 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1040: FB42 36 80                  LD     (HL),080H
1041: FB44
1042: FB44         ;Wait until Disk Status Block indicates , operation complete, then check
1043: FB44         ; if any errors occurred. ,On entry HL -> disk control byte
1044: FB44             WaitForDiskComplete:
1045: FB44 7E                     LD     A,(HL)               ; get control bytes
1046: FB45 B7                     OR     A
1047: FB46 C2 44 FB               JP     NZ,WaitForDiskComplete ; operation not done
1048: FB49
1049: FB49 3A 43 00               LD     A,(DiskStatusLocation) ; done , so now check status
1050: FB4C FE 80                  CP     080H
1051: FB4E DA 56 FB               JP     C,DiskError
1052: FB51 AF                     XOR    A
1053: FB52 32 7D FB               LD     (DiskErrorFlag),A    ; clear the flag
1054: FB55 C9                     RET
1055: FB56
1056: FB56             DiskError:
1057: FB56 3E 01                  LD     A,1
1058: FB58 32 7D FB               LD     (DiskErrorFlag),A    ; set the error flag
1059: FB5B C9                     RET
1060: FB5C
1061: FB5C         ;********************************************************************
1062: FB5C         ;********************************************************************
1063: FB5C         ;********************************************************************
1064: FB5C
1065: FB5C         ;---------------------------------------------------------------------------
1066: FB5C         ;	Disk Data
1067: FB5C         ;---------------------------------------------------------------------------
1068: FB5C         ;	Disk Equates
1069: FB5C         ;---------------------------------------------------------------------------
1070: FB5C         ; Disk Types
1071: FB5C         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1072: FB5C         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1073: FB5C         ;;HardDisk	EQU	2						; hard disk
1074: FB5C         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1075: FB5C
1076: FB5C
1077: FB5C         ;**************************************************************************************************
1078: FB5C         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1079: FB5C         ;
1080: FB5C         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1081: FB5C         ; perform some disk operation.  These are called its disk control byte.
1082: FB5C         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1083: FB5C         ; following the respective control bytes. This word must contain the address of  valid disk control
1084: FB5C         ; table that specifies the exact disk operation to be performed.
1085: FB5C         ;
1086: FB5C         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1087: FB5C         ; This indicates completion to the disk driver code.
1088: FB5C         ;
1089: FB5C         ;  The controller also sets a return code in a disk status block - location 0X43H.
1090: FB5C         ; If the first byte of this status block is less than 80H. then a disk error
1091: FB5C         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1092: FB5C         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1093: FB5C         ; ten times before the controller returns an error
1094: FB5C         ;
1095: FB5C         ;  The disk control table layout is shown below. Note that the controller has the capability
1096: FB5C         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1097: FB5C         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1098: FB5C         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1099: FB5C         ; the end of the chain
1100: FB5C         ;**************************************************************************************************
1101: FB5C
1102: FB5C         ;***************************************************************************
1103: FB5C         ;	Disk Control tables
1104: FB5C         ;***************************************************************************
1105: FB5C         ;;DiskControlTable:
1106: FB5C             DCTStart:
1107: FB5C 00          DCTCommand: DB     00H                  ; Command
1108: FB5D 00          DCTUnit:   DB     00H                  ; unit (drive) number = 0 or 1
1109: FB5E 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1110: FB5F 00          DCTTrack:  DB     00H                  ; track number
1111: FB60 00          DCTSector: DB     00H                  ; sector number
1112: FB61 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1113: FB63 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1114: FB65 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1115: FB67 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1116: FB69             DCTSize    EQU    $-DCTStart
1117: FB69         ;-----------------------------------------
1118: FB69         ;WriteAllocated		EQU	00H		W_NORMAL
1119: FB69         ;WriteDirectory		EQU	01H		W_DIRECTORY
1120: FB69         ;WriteUnallocated	EQU	02H		W_NEW_BLOCK
1121: FB69         ;-----------------------------------------
1122: FB69
1123: FB69 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1124: FB6A
1125: FB6A         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1126: FB6A             InBufferDkTrkSec:
1127: FB6A 00          InBufferDisk: DB     00H
1128: FB6B 00 00       InBufferTrack: DW     00H
1129: FB6D 00          InBufferSector: DB     00H
1130: FB6E 00          DataInDiskBuffer: DB     00H                  ; when non-zero, the disk buffer has data from disk
1131: FB6F 00          MustWriteBuffer: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1132: FB70         ;   but not yet written out to the disk
1133: FB70         ;---------------------------------------------------------------------------
1134: FB70         ;	Disk Storage area
1135: FB70         ;---------------------------------------------------------------------------
1136: FB70         ;     variables for selected disk, track and sector
1137: FB70         ; These are moved and compared as a group, DO NOT ALTER
1138: FB70 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1139: FB71
1140: FB71             SelectedDkTrkSec:
1141: FB71 00          SelectedDisk: DB     00H
1142: FB72 00 00       SelectedTrack: DW     00H
1143: FB74 00          SelectedSector: DB     00H
1144: FB75 00 00       DMAAddress: DW     00H                  ; DMA address
1145: FB77
1146: FB77             SelectedPhysicalSector:
1147: FB77 00                     DB     00H
1148: FB78
1149: FB78         ; Parameters for writing to a previously unallocated allocation block
1150: FB78         ; These are moved and compared as a group, DO NOT ALTER
1151: FB78             UnallocatedDkTrkSec:
1152: FB78 00          UnallocatedDisk: DB     00H
1153: FB79 00 00       UnallocatedTrack: DW     00H
1154: FB7B 00          UnallocatedSector: DB     00H
1155: FB7C 00          UnalocatedlRecordCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1156: FB7D 00          DiskErrorFlag: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1157: FB7E         ; Flags used inside the de-blocking code
1158: FB7E 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1159: FB7F         ; either before a write to a allocated block can occur, or
1160: FB7F         ; for a normal cpmRecord read
1161: FB7F 00          ReadFlag:  DB     00H                  ; Non-zero when a cpmRecord is to be read
1162: FB80
1163: FB80         ;---------------------------------------------------------------------------
1164: FB80
1165: FB80         ;---------------------------------------------------------------------------
1166: FB80         ;	Disk Definition Tables
1167: FB80         ; These consists of disk parameter headers, with one entry
1168: FB80         ; per logical disk driver, and disk parameter blocks, with
1169: FB80         ; either one parameter block per logical disk or the same
1170: FB80         ; parameter block for several logical disks.
1171: FB80         ;---------------------------------------------------------------------------
1172: FB80         ;---------------------------------------------------------------------------
1173: FB80             DiskParameterHeaders:
1174: FB80
1175: FB80         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1176: FB80 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1177: FB82 00 00                  DW     0000H                ; Rel pos for file (0-3)
1178: FB84 00 00                  DW     0000H                ; Last Selected Track #
1179: FB86 00 00                  DW     0000H                ; Last Selected Sector #
1180: FB88 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1181: FB8A C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1182: FB8C D0 FB                  DW     DiskAWorkArea
1183: FB8E 50 FC                  DW     DiskAAllocationVector
1184: FB90
1185: FB90         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1186: FB90 00 00                  DW     0000H                ; No Skew table
1187: FB92 00 00                  DW     0000H                ; Rel pos for file (0-3)
1188: FB94 00 00                  DW     0000H                ; Last Selected Track #
1189: FB96 00 00                  DW     0000H                ; Last Selected Sector #
1190: FB98 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1191: FB9A C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1192: FB9C F0 FB                  DW     DiskBWorkArea
1193: FB9E A9 FC                  DW     DiskBAllocationVector
1194: FBA0
1195: FBA0         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1196: FBA0 00 00                  DW     0000H                ; No Skew table
1197: FBA2 00 00                  DW     0000H                ; Rel pos for file (0-3)
1198: FBA4 00 00                  DW     0000H                ; Last Selected Track #
1199: FBA6 00 00                  DW     0000H                ; Last Selected Sector #
1200: FBA8 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1201: FBAA C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1202: FBAC 10 FC                  DW     DiskCWorkArea
1203: FBAE 02 FD                  DW     DiskCAllocationVector
1204: FBB0
1205: FBB0         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1206: FBB0 00 00                  DW     0000H                ; No Skew table
1207: FBB2 00 00                  DW     0000H                ; Rel pos for file (0-3)
1208: FBB4 00 00                  DW     0000H                ; Last Selected Track #
1209: FBB6 00 00                  DW     0000H                ; Last Selected Sector #
1210: FBB8 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1211: FBBA C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1212: FBBC 30 FC                  DW     DiskDWorkArea
1213: FBBE 5B FD                  DW     DiskDAllocationVector
1214: FBC0
1215: FBC0
1216: FBC0         ;-----------------------------------------------------------
1217: FBC0
1218: FBC0             ParameterBlock3HD:
1219: FBC0 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1220: FBC2 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1221: FBC3 0F                     DB     dpb3hdBLM            ; Block mask
1222: FBC4 00                     DB     dpb3hdEXM            ; Extent mask
1223: FBC5 C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1224: FBC7 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1225: FBC9 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1226: FBCA 00                     DB     dpb3hdAL1            ;  for file directory
1227: FBCB 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1228: FBCD 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1229: FBCF
1230: FBCF 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1231: FBD0
1232: FBD0
1233: FBD0
1234: FBD0         ;---------------------------------------------------------------------------
1235: FBD0         ;	Disk work area
1236: FBD0         ;---------------------------------------------------------------------------
1237: FBD0         ; These are used by the BDOS to detect any unexpected
1238: FBD0         ; change of diskette. The BDOS will automatically set
1239: FBD0         ; such a changed diskette to read-only status.
1240: FBD0
1241: FBD0             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1242: FBF0             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1243: FC10             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1244: FC30             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1245: FC50
1246: FC50         ;---------------------------------------------------------------------------
1247: FC50         ;	Disk allocation vectors
1248: FC50         ;---------------------------------------------------------------------------
1249: FC50         ; Disk allocation vectors
1250: FC50         ; These are used by the BDOS to maintain a bit map of
1251: FC50         ; which allocation blocks are used and which are free.
1252: FC50         ; One byte is used for eight allocation blocks, hence the
1253: FC50         ; expression of the form (allocation blocks/8)+1
1254: FC50
1255: FC50             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1256: FCA9             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1257: FD02
1258: FD02             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1259: FD5B             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1260: FDB4         ;---------------------------------------------------------------------------
1261: FDB4         ;	Disk Buffer
1262: FDB4         ;---------------------------------------------------------------------------
1263: FDB4             DirectoryBuffer: DS     DirBuffSize
1264: FE34         ;---------------------------------------------------------------------------
1265: FE34         ;**********************************************************************************
1266: FE34         ;	Disk Control table image for warm boot
1267: FE34         ;**********************************************************************************
1268: FE34             BootControl:
1269: FE34 01                     DB     DiskReadCode         ; Read function
1270: FE35 00                     DB     00H                  ; unit number
1271: FE36 00                     DB     00H                  ; head number
1272: FE37 00                     DB     00H                  ; track number
1273: FE38 02                     DB     02H                  ; Starting sector number (skip cold boot sector)
1274: FE39 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read ( rest of the head)
1275: FE3B 00 E0                  DW     CCPEntry             ; read into this address
1276: FE3D 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
1277: FE3F 45 00                  DW     DiskControlByte      ; pointer to next table- no linking
1278: FE41
1279: FE41         ;
1280: FE41         ;**********************************************************************************
1281: FE41         ;	Warm Boot
1282: FE41         ;  On warm boot. the CCP and BDOS must be reloaded into memory.
1283: FE41         ; This code is hardware specific to the 3.5 HD controller.
1284: FE41         ;**********************************************************************************
1285: FE41
1286: FE41             WBOOT:
1287: FE41 31 FF DF               LD     SP,CCPEntry-1
1288: FE44 21 34 FE               LD     HL,BootControl       ; point at the disk control table
1289: FE47 22 46 00               LD     (DiskCommandBlock),HL
1290: FE4A
1291: FE4A 21 45 00               LD     HL,DiskControlByte
1292: FE4D 36 80                  LD     (HL),080H            ; activate the controller
1293: FE4F
1294: FE4F             WaitTillDone:
1295: FE4F 7E                     LD     A,(HL)               ; Get the control byte
1296: FE50 B7                     OR     A                    ; Reset to 0 (Completed operation) ?
1297: FE51 C2 4F FE               JP     NZ,WaitTillDone      ; if not try again
1298: FE54
1299: FE54 3A 43 00               LD     A,(DiskStatusLocation) ; after operation what's the status?
1300: FE57 FE 80                  CP     080H                 ; any errors ?
1301: FE59 D2 8C FE               JP     NC,EnterCPM          ; Nope
1302: FE5C         ; yes
1303: FE5C             WarmBootError:
1304: FE5C 21 72 FE               LD     HL,WarmBootErroMessage ; point at error message
1305: FE5F CD 65 FE               CALL   DisplayMessage       ; sent it. and
1306: FE62 C3 41 FE               JP     WBOOT                ; try again.
1307: FE65
1308: FE65         ;---------------------------------------------------------------------------
1309: FE65             DisplayMessage:
1310: FE65 7E                     LD     A,(HL)               ; get next message byte
1311: FE66 B7                     OR     A                    ; terminator (a = 0)?
1312: FE67 C8                     RET    Z                    ; Yes, thes return to caller
1313: FE68
1314: FE68 4F                     LD     C,A                  ; prepare for output
1315: FE69 E5                     PUSH   HL                   ; save message pointer
1316: FE6A CD 19 F9               CALL   CONOUT               ; go to main console output routine *******
1317: FE6D E1                     POP    HL
1318: FE6E 23                     INC    HL                   ; point at next character
1319: FE6F C3 65 FE               JP     DisplayMessage       ; loop till done
1320: FE72
1321: FE72             WarmBootErroMessage:
1322: FE72 0D 0A                  DB     CR,LF
1323: FE74 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'
1324: FE7F 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'
1325: FE89 0D 0A                  DB     CR,LF
1326: FE8B 00                     DB     EndOfMessage
1327: FE8C
1328: FE8C         ;--------------------BOOT-----------------------------
1329: FE8C
1330: FE8C         ; entered directly from the BIOS JMP vector
1331: FE8C         ; Control transfered by the CP/M bootstrap loader
1332: FE8C         ; Sets up Page Zero
1333: FE8C         ;---------------End of Cold Boot Initialization Code--------------
1334: FE8C
1335: FE8C             BOOT:
1336: FE8C             EnterCPM:
1337: FE8C 3E C3                  LD     A,0C3H               ; JMP op code
1338: FE8E 32 00 00               LD     (0000H),A            ; set up the jump in location 0000H
1339: FE91 32 05 00               LD     (0005H),A            ; and at location 0005H
1340: FE94
1341: FE94 21 03 F6               LD     HL,WarmBootEntry     ; get BIOS vector address
1342: FE97 22 01 00               LD     (0001H),HL           ; put address in location 1
1343: FE9A
1344: FE9A 21 06 E8               LD     HL,BDOSEntry         ; Get BDOS entry point address
1345: FE9D 22 06 00               LD     (0006H),HL           ; put address at location 5
1346: FEA0
1347: FEA0 01 80 00               LD     BC,DMABuffer         ; DefaultDiskBuffer set disk I/O address to default
1348: FEA3 CD B3 F9               CALL   SETDMA               ; use normal BIOS routine
1349: FEA6
1350: FEA6 FB                     EI
1351: FEA7 3A 04 00               LD     A,(Pg0CurentDisk)    ; DefaultDisk  Transfer current default disk to
1352: FEAA 4F                     LD     C,A                  ; Console Command Processor
1353: FEAB C3 00 E0               JP     CCPEntry             ; transfer to CCP
1354: FEAE
1355: FEAE         ;-------------------------------------------------
1356: FEAE
           ************************   Xref   ************************
0000: $               FEAB   0312 1116
0316: AfterDiskBuffer F840
0080: ASCII_A         0041
0081: ASCII_C         0043
0082: ASCII_K         004B
0089: ASCII_LO_A      0061
0090: ASCII_LO_K      006B
0091: ASCII_LO_P      0070
0032: ASCII_MASK      007F
0083: ASCII_N         004E
0084: ASCII_Q         0051
0085: ASCII_R         0052
0086: ASCII_W         0057
0087: ASCII_Y         0059
0067: ASCII_ZERO      0030
0061: ASTERISK        002A
0146: BDOSBase        E800   0147 0149
0115: BDOSE           0005   0116
0147: BDOSEntry       E806   1344
0136: BDOSLength      0E00   0139 0149 0150 1274
0050: BELL            0007
0149: BIOSBase        F600
0137: BIOSLength      0A00   0139
0109: BIOSPAGE        0002
0150: BIOSStart       F600   0288
0246: BlockSize       0800   0268
1335: BOOT            FE8C   0292
1268: BootControl     FE34   1288
0900: BufferMove      FA99   0893 0942
0028: BYTE            0001
0088: CARET           005E
0144: CCPEntry        E000   0146 0150 1275 1287 1353
0135: CCPLength       0800   0139 0146 0150 1274
0781: CheckUnallocatedBlock F9EA   0770
0290: CodeStart       F600
0068: COLON           003A
0063: COMMA           002C
0998: CommonPhysical  FAF6   0993
0338: CommunicationDataPort 00EC   0360
0434: CommunicationInput F89D   0547
0340: CommunicationInputReady 0002   0362
0401: CommunicationInStatus F86A   0529
0448: CommunicationOutput F8B2   0561 0620 0635
0339: CommunicationOutputReady 0001   0361
0415: CommunicationOutStatus F87F
0337: CommunicationStatusPort 00ED   0359
0358: CommunicationTable F848   0402 0416 0435 0449
0960: CompareDkTrk    FAD3   0832
0963: CompareDkTrkSec FAD8   0790
0965: CompareDkTrkSecLoop FADA   0962 0973
0121: ComTail         0080   0122
0123: ComTailChars    0082
0122: ComTailCount    0081   0123
0541: CONIN           F90B   0296
0555: CONOUT          F919   0297 1316
0516: CONST           F8F5   0295
0223: cpmRecordSize   0080   0225 0228 0230 0884
0053: CR              000D   1322 1325
0333: CRT_DataPort    0001   0355
0429: CRT_Input       F894   0546
0335: CRT_InputReady  007F   0357
0398: CRT_InStatus    F864   0528
0445: CRT_Output      F8AC   0560 0601 0621 0636
0334: CRT_OutputReady 0080   0356
0412: CRT_OutStatus   F879   0587
0332: CRT_StatusPort  0002   0354
0353: CRT_Table       F844   0399 0413 0430 0446
0036: CTRL_C          0003
0037: CTRL_E          0005
0038: CTRL_H          0008
0039: CTRL_K          000B
0040: CTRL_L          000C
0041: CTRL_P          0010
0042: CTRL_R          0012
0043: CTRL_S          0013
0044: CTRL_U          0015
0045: CTRL_X          0018
0046: CTRL_Z          001A
0064: DASH            002D
0257: DataBlocks      02C7   0267
1130: DataInDiskBuffer FB6E   0654 0822
0256: DataSectors     0B1C   0257
1112: DCTByteCount    FB61   1026
1107: DCTCommand      FB5C   0999 1036
1113: DCTDMAAddress   FB63   1028
1109: DCTHead         FB5E   1023
1115: DCTNextControlLocation FB67   1035
1114: DCTNextStatusBlock FB65   1033
1111: DCTSector       FB60   1021
1116: DCTSize         000B
1106: DCTStart        FB5C   1116
1110: DCTTrack        FB5F   1005
1108: DCTUnit         FB5D   1002
0228: DirBuffSize     0080   1263
0243: DirectoryBlockCount 0002   0268
1263: DirectoryBuffer FDB4   1180 1190 1200 1210
0230: DirectoryEntryPerRecord 0004   0271
0227: DirEntrySize    0020   0230 0268
1255: DiskAAllocationVector FC50   1183
1241: DiskAWorkArea   FBD0   1182
1256: DiskBAllocationVector FCA9   1193
0314: DiskBuffer      F640   0878 1027
1242: DiskBWorkArea   FBF0   1192
1258: DiskCAllocationVector FD02   1203
0215: DiskCommandBlock 0046   1037 1289
0214: DiskControlByte 0045   1034 1039 1277 1291
0217: DiskControlTable 0040
1243: DiskCWorkArea   FC10   1202
1259: DiskDAllocationVector FD5B   1213
1244: DiskDWorkArea   FC30   1212
1056: DiskError       FB56   1051
1156: DiskErrorFlag   FB7D   0816 0947 0956 1053 1058
1173: DiskParameterHeaders FB80   0680
0219: DiskReadCode    0001   0996 1269
0224: diskSectorSize  0200   0225 0246 0254 0315 1025
0213: DiskStatusLocation 0043   1032 1049 1276 1299
0220: DiskWriteCode   0002   0992
1309: DisplayMessage  FE65   1305 1319
1144: DMAAddress      FB75   0720 0881
0126: DMABuffer       0080   1347
0057: DOLLAR          0024
0269: dpb3hdAL0       00C0   1225
0270: dpb3hdAL1       0000   1226
0265: dpb3hdBLM       000F   1221
0264: dpb3hdBSH       0004   1220
0271: dpb3hdCKS       0020   1227 1241 1242 1243 1244
0268: dpb3hdDRM       007F   0271 1224
0267: dpb3hdDSM       02C6   1223 1255 1256 1258 1259
0266: dpb3hdEXM       0000   1222
0273: dpb3hdNOH       0002   1230
0272: dpb3hdOFF       0001   1228
0263: dpb3hdSPT       0090   1219 1230
0437: DummyInput      F8A3   0548
0404: DummyInStatus   F870   0530
0454: DummyOutput     F8BE   0562 0603 0619 0634
0421: DummyOutStatus  F88B   0589
0130: END_OF_FILE     001A   0438
0034: EndOfMessage    0000   1326
1336: EnterCPM        FE8C   1301
0072: EQUAL_SIGN      003D
0055: EXCLAIM_POINT   0021
0023: FALSE           0000
0118: FCB1            005C   0119
0119: FCB2            006C
0163: fCloseFile      0010
0154: fConsoleIn      0001
0155: fConsoleOut     0002
0166: fDeleteFile     0013
0158: fGetConsoleStatus 000B
0172: fGetCurrentDisk 0019
0171: fGetLoginVector 0018
0174: fGetSetUserNumber 0020
0159: fGetVersion     000C
0169: fMakeFile       0016
0162: fOpenFile       000F
0156: fPrintString    0009
0167: fReadSeq        0014
0157: fReadString     000A
0170: fRenameFile     0017
0160: fResetSystem    000D
0164: fSearchFirst    0011
0165: fSearchNext     0012
0161: fSelectDisk     000E
0173: fSetDMA         001A
0168: fWriteSeq       0015
0523: GetConsoleStatus F8FD   0517
0580: GetListStatus   F92F   0574
0073: GREATER_THAN    003E
0056: HASH_TAG        0023
1011: Head0           FB10   1017
1019: Head1           FB19   1013
0650: HOME            F971   0301
0655: HomeNoWrite     F97B   0653
1127: InBufferDisk    FB6A   0848 1000
1126: InBufferDkTrkSec FB6A   0830
1129: InBufferSector  FB6D   0835 0852 1010
1128: InBufferTrack   FB6B   0850 1003
0284: INopCode        00DB   0461 0478 0486
0470: InputData       F8CA   0428 0431 0436 0474
0479: InputDataPort   F8D8   0477
0458: InputStatus     F8BF   0397 0400 0403 0420 0472
0462: InputStatusPort F8C4   0460
0110: IOBYTE          0003   0524 0542 0556 0581 0595 0611 0628
0059: L_PAREN         0028
0076: LEFT_ARROW      005F
0092: LEFT_CURLY      007B
0139: LengthInBytes   2000   0140 0144 0254
0140: LengthInK       0009
0071: LESS_THAN       003C
0052: LF              000A   1322 1325
0594: LIST            F93F   0298
0567: LISTST          F927   0308
0026: LO_NIBBLE_MASK  000F
0142: MemorySize      0040   0144
0977: MoveDkTrkSec    FAE4   0777
0979: MoveDkTrkSecLoop FAE6   0986
1131: MustWriteBuffer FB6F   0651 0841 0862 0896 0954
0255: myOffset        0001   0256 0272
0801: NoTrackChange   FA12   0796
0048: NULL            0000
0239: NumberOfHeads   0002   0250 0252 0263 0273
0236: NumberOfLogicalDisks 0004   0668
0025: OFF             0000
0024: ON              FFFF
0285: OUTopCode       00D3   0503
0494: OutputData      F8E4   0444 0447 0450 0453 0498
0504: OutputDataPort  F8F3   0501
0483: OutputStatus    F8DA   0411 0414 0417 0496
0487: OutputStatusPort F8DF   0485
1218: ParameterBlock3HD FBC0   1181 1191 1201 1211
0058: PERCENT         0025
0814: PerformReadWrite FA21   0747 0804
0065: PERIOD          002E
0113: Pg0CurentDisk   0004   1351
0112: Pg0CurentUser   0004   0113
0062: PLUS_SIGN       002B
1158: PrereadSectorFlag FB7E   0744 0803 0810 0854
0343: PrinterDataPort 0010   0365
0345: PrinterInputReady 007F   0367
0451: PrinterOutput   F8B8   0602
0344: PrinterOutputReady 00FF   0366
0418: PrinterStatus   F885   0588
0342: PrinterStatusPort 0011   0364
0363: PrinterTable    F84C   0419 0452
0609: PUNCH           F94F   0299
0074: QMARK           003F
0060: R_PAREN         0029
0106: RAM             0000   0108 0109 0110 0112 0115 0118 0121 0126 0128
0739: READ            F9BC   0306
0627: READER          F961   0300
1161: ReadFlag        FB7F   0743 0766 0891
0995: ReadPhysical    FAF4   0856
0845: ReadSectorIntoBuffer FA56   0826
0248: RecordsPerBlock 0010   0773
0232: RecordsPerExtent 0080
0225: recordsPerSector 0004   0248 0263
0806: RequestPreread  FA19   0784 0791
0077: RUBOUT          007F
0866: SectorInBuffer  FA73   0838
0277: SectorMask      0003   0868
0840: SectorNotInBuffer FA4F   0833
0242: SectorsPerBlock 0004   0246 0248 0251 0257 0277
0252: SectorsPerCylinder 0024   0255 0256
0241: SectorsPerTrack 0012   0250 0252 0263 0795
0728: SECTRAN         F9B9   0309
0665: SELDSK          F981   0302
1141: SelectedDisk    FB71   0671 0847
1140: SelectedDkTrkSec FB71   0775 0788 0831
1138: SelectedDskSecsPerHead FB70   0691 1009
1146: SelectedPhysicalSector FB77   0821 0836 0851
1143: SelectedSector  FB74   0711 0817 0867
1142: SelectedTrack   FB72   0703 0849
0378: SelectRoutine   F850   0525 0543 0557 0584 0598 0616 0631
0070: SEMICOLON       003B
0717: SETDMA          F9B3   0305 1348
0709: SETSEC          F9AE   0304
0700: SETTRK          F9A8   0303 0657
0066: SLASH           002F
0049: SOH             0001
0054: SPACE           0020
0254: SystemSectors   0011   0255
0051: TAB             0009
0116: TopRAM          0007
0251: TotalNumberOfBlocks 02D0
0250: TotalNumberOfSectors 0B40   0251 0256
0128: TPA             0100
0240: TracksPerHead   0050   0250
0022: TRUE            FFFF
0328: TTYDataPort     00EC   0350
0426: TTYInput        F88E   0545
0330: TTYInputReady   0002   0352
0395: TTYInStatus     F85E   0527
0442: TTYOutput       F8A6   0559 0600 0618 0633
0329: TTYOutputReady  0001   0351
0409: TTYOutStatus    F873   0586
0327: TTYStatusPort   00ED   0349
0348: TTYTable        F840   0396 0410 0427 0443
1152: UnallocatedDisk FB78
1151: UnallocatedDkTrkSec FB78   0776 0789
1154: UnallocatedSector FB7B
1153: UnallocatedTrack FB79   0798 0800
1155: UnalocatedlRecordCount FB7C   0741 0774 0782 0786 0808
0075: UNDER_SCORE     005F
1044: WaitForDiskComplete FB44   1047
1294: WaitTillDone    FE4F   1297
0108: WarmBoot        0000
0293: WarmBootEntry   F603   1341
1321: WarmBootErroMessage FE72   1304
1303: WarmBootError   FE5C
1286: WBOOT           FE41   0294 1306
0029: WORD            0002
0763: WRITE           F9CF   0307
0188: WriteAllocated  0000
0189: WriteDirectory  0001   0946
0991: WritePhysical   FAEF   0843 0955
1123: WriteType       FB69   0746 0768 0945
0190: WriteUnallocated 0002   0745 0769
0033: ZERO            0000
