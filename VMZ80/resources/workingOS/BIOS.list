0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018 12-11 Adjusted BOOT & WBOOT
0006: F600         ; 2018-12-10 Refactored  character device routines;
0007: F600         ; 2017-03-31 Added List out functionality for List Device
0008: F600         ; 2017-03-02 Refactored the CP/M Suite
0009: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0010: F600         ; 2014-01-16
0011: F600         ; 2014-03-14  :  Frank Martyn
0012: F600
0013: F600         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0014: F600         ; by Andy Johnson-Laird
0015: F600         ;
0016: F600         ; Published by
0017: F600         ; Osborne/McGraw-Hill
0018: F600         ; 2600 Tenth Street
0019: F600         ; Berkeley, California 94710
0020: F600         ; U.S.A.
0021: F600
0022: F600                        Include ./stdHeader.Z80
0023: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0024: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0025: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0026: F600         ; stdHeader.asm
0027: F600         ; standard equates
0028: F600
0029: F600         ; 2017-03-02 Refactored the CP/M Suite
0030: F600
0031: F600
0032: F600             TRUE       EQU    -1                   ; not false
0033: F600             FALSE      EQU    0000H
0034: F600             ON         EQU    -1
0035: F600             OFF        EQU    0000H
0036: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0037: F600
0038: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0039: F600             WORD       EQU    2                    ; number of bytes for "word" type
0040: F600
0041: F600
0042: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0043: F600             ZERO       EQU    00H                  ; Zero
0044: F600             EndOfMessage EQU    00H
0045: F600
0046: F600             CTRL_C     EQU    03H                  ; ETX
0047: F600             CTRL_E     EQU    05H                  ; physical eol
0048: F600             CTRL_H     EQU    08H                  ; backspace
0049: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0050: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0051: F600             CTRL_P     EQU    10H                  ; prnt toggle
0052: F600             CTRL_R     EQU    12H                  ; repeat line
0053: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0054: F600             CTRL_U     EQU    15H                  ; line delete
0055: F600             CTRL_X     EQU    18H                  ; =ctl-u
0056: F600             CTRL_Z     EQU    1AH                  ; end of file
0057: F600
0058: F600             NULL       EQU    00H                  ; Null
0059: F600             SOH        EQU    01H                  ; Start of Heading
0060: F600             BELL       EQU    07H                  ; Bell
0061: F600             TAB        EQU    09H                  ; Tab
0062: F600             LF         EQU    0AH                  ; Line Feed
0063: F600             CR         EQU    0DH                  ; Carriage Return
0064: F600             SPACE      EQU    20H                  ; Space
0065: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0066: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0067: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0068: F600             PERCENT    EQU    25H                  ; Percent Sign
0069: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0070: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0071: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0072: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0073: F600             COMMA      EQU    2CH                  ; Comma
0074: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0075: F600             PERIOD     EQU    2EH                  ; Period
0076: F600             SLASH      EQU    2FH                  ; /
0077: F600             ASCII_ZERO EQU    30H                  ; zero
0078: F600             COLON      EQU    3AH                  ; Colon
0079: F600
0080: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0081: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0082: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0083: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0084: F600             QMARK      EQU    3FH                  ; Question Mark
0085: F600             UNDER_SCORE EQU    5FH                  ; under score _
0086: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0087: F600             RUBOUT     EQU    7FH                  ; Delete Key
0088: F600
0089: F600
0090: F600             ASCII_A    EQU    'A'
0091: F600             ASCII_C    EQU    'C'
0092: F600             ASCII_K    EQU    'K'
0093: F600             ASCII_N    EQU    'N'
0094: F600             ASCII_Q    EQU    'Q'
0095: F600             ASCII_R    EQU    'R'
0096: F600             ASCII_W    EQU    'W'
0097: F600             ASCII_Y    EQU    'Y'
0098: F600             CARET      EQU    '^'
0099: F600             ASCII_LO_A EQU    'a'
0100: F600             ASCII_LO_K EQU    'k'
0101: F600             ASCII_LO_P EQU    'p'
0102: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0103: F600
0104: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0105: F600                        Include ./osHeader.Z80
0106: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0107: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0108: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0109: F600         ; osHeader.asm
0110: F600
0111: F600         ; 2017-03-02 Refactored the CP/M Suite
0112: F600
0113: F600         ; Contains the Equates used by the CP/M system
0114: F600
0115: F600         ;------------------------Page Zero Constants ---------------------------------
0116: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0117: F600
0118: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0119: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0120: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0121: F600
0122: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0123: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0124: F600
0125: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0126: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0127: F600
0128: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0129: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0130: F600
0131: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0132: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0133: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0134: F600         ;-----------------------------------------------------------------------
0135: F600
0136: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0137: F600         ;-----------------------------------------------------------------------
0138: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0139: F600         ;-----------------------------------------------------------------------
0140: F600             END_OF_FILE EQU    1AH                  ; end of file
0141: F600         ;-----------------------------------------------------------------------
0142: F600
0143: F600         ;--------------- CP/M Constants -----------------------------------------
0144: F600
0145: F600             CCPLength  EQU    0800H                ; Constant
0146: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0147: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0148: F600
0149: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0150: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0151: F600
0152: F600             MemorySize EQU    64
0153: F600
0154: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0155: F600
0156: F600             BDOSBase   EQU    CCPEntry + CCPLength
0157: F600             BDOSEntry  EQU    BDOSBase + 6
0158: F600
0159: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0160: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0161: F600         ;-----------------------------------------------------------------------
0162: F600
0163: F600         ;------------------- BDOS System Call Equates --------------------------
0164: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0165: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0166: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0167: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0168: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0169: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0170: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0171: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0172: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0173: F600             fCloseFile EQU    10H                  ; closef - Close File
0174: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0175: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0176: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0177: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0178: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0179: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0180: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0181: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0182: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0183: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0184: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0185: F600         ;-----------------------------------------------------------------------
0186: F600
0187: F600
0188: F600
0189: F600
0190: F600
0191: F600         ;*******************************************************************************
0192: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0193: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0194: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0195: F600         ; sector write) or to an allocation block that has already been allocated to a
0196: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0197: F600         ;*******************************************************************************
0198: F600             WriteAllocated EQU    00H
0199: F600             WriteDirectory EQU    01H
0200: F600             WriteCleanBuffer EQU    02H
0201: F600
0202: F600
0203: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0204: F600                        Include ./diskHeader.Z80
0205: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0206: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0207: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0208: F600         ; diskHeader.asm
0209: F600
0210: F600         ; 2017-03-02 Refactored the CP/M Suite
0211: F600
0212: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0213: F600
0214: F600         ; Contains the Equates used by the CP/M system to handle disks
0215: F600
0216: F600
0217: F600         ;*******************************************************************************
0218: F600         ;
0219: F600         ;     Disk related values
0220: F600         ;
0221: F600         ;
0222: F600         ;*******************************************************************************
0223: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0224: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0225: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0226: F600         ; for boot
0227: F600             DiskControlTable EQU    0040H
0228: F600
0229: F600             DiskReadCode EQU    01H                  ; Code for Read
0230: F600             DiskWriteCode EQU    02H                  ; Code for Write
0231: F600
0232: F600
0233: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0234: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0235: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0236: F600
0237: F600             DirEntrySize EQU    20H                  ; (32)
0238: F600             DirBuffSize EQU    cpmRecordSize
0239: F600
0240: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0241: F600
0242: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0243: F600
0244: F600
0245: F600         ;-------------------------------------------------------------------------------------
0246: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0247: F600
0248: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0249: F600             NumberOfHeads EQU    02H                  ; number of heads
0250: F600             TracksPerHead EQU    50H                  ; 80
0251: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0252: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0253: F600             DirectoryBlockCount EQU    02H                  ;
0254: F600         ;-----------------------------------------------------------------------
0255: F600
0256: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0257: F600
0258: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0259: F600
0260: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0261: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0262: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0263: F600
0264: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0265: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0266: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0267: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0268: F600
0269: F600         ;-----------------------------------------------------------------------
0270: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0271: F600         ;-----------------------------------------------------------------------
0272: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0273: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0274: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0275: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0276: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0277: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0278: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0279: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0280: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0281: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0282: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0283: F600             dpb3hdNOH  EQU    NumberOfHeads
0284: F600
0285: F600         ;*******************************************************************************
0286: F600
0287: F600             SectorMask EQU    SectorsPerBlock - 1
0288: F600
0289: F600         ;***************************************************************************
0290: F600
0291: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0292: F600
0293: F600
0294: F600             IN_OPCODE  EQU    0DBH
0295: F600             OUT_OPCODE EQU    0D3H
0296: F600             JP_OPCODE  EQU    0C3H
0297: F600
0298: F600
0299: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0300: F600         ; BIOS jump Vector
0301: F600             CodeStart:
0302: F600
0303: F600 C3 40 F8               JP     BOOT                 ; 00 Cold/Hard Boot
0304: F603             WarmBootEntry:
0305: F603 C3 0E F9               JP     WBOOT                ; 01 Warm/Soft Boot
0306: F606 C3 51 F9               JP     CONST                ; 02 Get Console Status - CON:
0307: F609 C3 63 F9               JP     CONIN                ; 03 Get Character from Console - CON:
0308: F60C C3 6F F9               JP     CONOUT               ; 04 Send Character to Console - CON:
0309: F60F C3 85 F9               JP     LIST                 ; 05 Send Character to List device - LST:
0310: F612 C3 90 F9               JP     PUNCH                ; 06 Send Character to Punch device - PUN:
0311: F615 C3 9D F9               JP     READER               ; 07 Get Character from Reader - RDR:
0312: F618 C3 62 FA               JP     HOME                 ; 08 Position the disk to absolute track 00
0313: F61B C3 71 FA               JP     SELDSK               ; 09 Establish disk to be used by subsequent Read/Write
0314: F61E C3 9B FA               JP     SETTRK               ; 0A Establish track to be used by subsequent Read/Write
0315: F621 C3 A0 FA               JP     SETSEC               ; 0B Establish sector to be used by subsequent Read/Write
0316: F624 C3 A5 FA               JP     SETDMA               ; 0C Establish buffer location to be used by subsequent Read/Write
0317: F627 C3 AD FA               JP     READ                 ; 0D Not Yet Checked
0318: F62A C3 C0 FA               JP     WRITE                ; 0E Not Yet Checked
0319: F62D C3 B2 F9               JP     LISTST               ; 0F Get List device Status - LST:
0320: F630 C3 AA FA               JP     SECTRAN              ; 10 De-skew sector number (null implementation)
0321: F633
0322: F633         ;-------------------------------------------------
0323: F633                        ORG    (($+10H)/10H) * 10H
0324: F640
0325: F640             DiskBuffer:
0326: F640                        DS     diskSectorSize
0327: F840             AfterDiskBuffer EQU    $
0328: F840         ;-------------------------------------------------
0329: F840
0330: F840
0331: F840
0332: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0333: F840
0334: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0335: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0336: F840         ;---------------------------------------------------------------------------
0337: F840         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot
0338: F840
0339: F840         ;  The BOOT jump instruction is the first instruction executed in CP/M. The
0340: F840         ; bootstrap sequence must transfer control to the BOOT entry point in order to
0341: F840         ; bring up CP/M.
0342: F840         ;  This reads in the CP/M loader on the first sector of the physical disk drive
0343: F840         ; chosen to be logical disk A. This CP/M loader program reads the binary image
0344: F840         ; of the CCP, BOOS, and BIOS into memory at some predetermined address.
0345: F840         ; Then it transfers control to the BOOT entry point in the BIOS jump vector.
0346: F840         ;  This BOOT routine must initialize all of the required computer hardware.
0347: F840         ;
0348: F840         ; Most BOOT routines sign on by displaying a short message on the console,
0349: F840         ; indicating the current version ofCP/M and the computer hardware that this BIOS
0350: F840         ; can support. The BOOT routine terminates by transferring control to the start of the CCP
0351: F840         ; +6 bytes (the CCP has its own smalljump vector at the beginning). Just before the
0352: F840         ; BOOT routine jumps into the CCP, it sets the C register to 0 to indicate that logical
0353: F840         ; disk A is to be the default disk drive. This is what causes "A>" to be the CCP's
0354: F840         ; initial prompt.
0355: F840
0356: F840             BOOT:
0357: F840                        Include ./BootBase.Z80
0358: F840         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0359: F840         ;     File created by MakeZ80Source on Tue Sep 18 10:01:22 EDT 2018 from:
0360: F840         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BootSector.asm
0361: F840         ; BootBase.Z80
0362: F840         ; Build 1.0
0363: F840
0364: F840         ; 2018		2018-12-26   Separated from BootSector.Z80
0365: F840         ;							to include in BIOS
0366: F840
0367: F840
0368: F840
0369: F840             BOOT_CON_ADDRESS EQU    0ECH                 ; tty data address
0370: F840             IOBYTE_DEFAULT EQU    080H                 ; LST:=LPT, rest all = TTY:
0371: F840             WarmBootEntry EQU    BIOSStart + 3
0372: F840
0373: F840
0374: F840
0375: F840             Start:
0376: F840 31 3F F8               LD     SP,$-1               ; stack goes down from here
0377: F843 CD 02 F9               CALL   SendBootMessage      ; display boot message
0378: F846 01 3B 00               LD     BC,Page0ImageEnd-Page0Image ; Size of code to move
0379: F849 21 7C F8               LD     HL,Page0Image        ; Source of page 0 code
0380: F84C 11 00 00               LD     DE,0000              ; Location 0, the target
0381: F84F
0382: F84F         ; Set up page zero,Move (B) bytes from (HL) to (DE).
0383: F84F ED B0                  LDIR
0384: F851
0385: F851         ; Now  start to move data to Disk Control Block
0386: F851
0387: F851 21 6F F8               LD     HL,BootControl
0388: F854 22 46 00               LD     (DiskCommandBlock),HL ; put it into the Command block for drive A:
0389: F857
0390: F857
0391: F857 21 45 00               LD     HL,DiskControlByte
0392: F85A 36 80                  LD     (HL),080H            ; activate the controller
0393: F85C
0394: F85C             WaitForBootComplete:
0395: F85C 7E                     LD     A,(HL)               ; Get the control byte
0396: F85D B7                     OR     A                    ; is it set to 0 (Completed operation) ?
0397: F85E 20 FC                  JR     NZ,WaitForBootComplete ; if not try again
0398: F860
0399: F860 3A 43 00               LD     A,(DiskStatusLocation) ; after operation what's the status?
0400: F863 FE 80                  CP     080H                 ; any errors ?
0401: F865
0402: F865
0403: F865 D2 00 F6               JP     NC,BIOSStart         ; now do a Cold Boot
0404: F868         ; else we have a problem
0405: F868 21 D5 F8               LD     HL,FailedBootMessage
0406: F86B CD 05 F9               CALL   SendMessage
0407: F86E 76                     HALT
0408: F86F         ;---------------------------------------------------
0409: F86F
0410: F86F             BootControl:
0411: F86F 01                     DB     DiskReadCode         ; Read function
0412: F870 00                     DB     00H                  ; unit number
0413: F871 00                     DB     00H                  ; head number
0414: F872 00                     DB     00H                  ; track number
0415: F873 0D                     DB     0DH                  ; Starting sector number (13)
0416: F874 00 0A                  DW     5 * 512              ; Number of bytes to read ( 0A00 All of BIOS)
0417: F876 00 F6                  DW     BIOSStart            ; read into this address
0418: F878 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0419: F87A 40 00                  DW     DiskControlTable     ; pointer to next table- no linking
0420: F87C
0421: F87C         ;---------------------------------------------------
0422: F87C
0423: F87C             Page0Image:
0424: F87C C3 03 F6               JP     WarmBootEntry        ; warm start
0425: F87F         ;IOBYTE:
0426: F87F 80                     DB     IOBYTE_DEFAULT       ; IOBYTE-
0427: F880             DefaultDisk:
0428: F880 00                     DB     00H                  ; Current default drive (A)
0429: F881 C3 06 E8               JP     BDOSEntry            ; jump to BDOS entry
0430: F884                        DS     028H                 ; interrupt locations 1-5 not used
0431: F8AC                        DS     008H                 ; interrupt location 6 is reserved
0432: F8B4 C3 00 00               JP     0000H                ; rst 7 used only by DDT & SID programs
0433: F8B7             Page0ImageEnd:
0434: F8B7
0435: F8B7         ;---------------------------------------------------
0436: F8B7
0437: F8B7
0438: F8B7             BootMessage:
0439: F8B7 0D 0A                  DB     CR,LF
0440: F8B9 43 50 2F 4D 20 32 2E 32 20 42 6F 6F 74 53 74 72 61 70                DB     'CP/M 2.2 BootStrap'
0441: F8CB 20 6C 6F 61 64 65 72                DB     ' loader'
0442: F8D2         ; 	DB		CR,LF,
0443: F8D2         ; 	DB		'Build '
0444: F8D2         ; 	DB		'2.0A  : 1.0 - 1.1 - 1.2'
0445: F8D2 0D 0A 00                DB     CR,LF,EndOfMessage
0446: F8D5
0447: F8D5             FailedBootMessage:
0448: F8D5 0D 0A                  DB     CR,LF
0449: F8D7 42 6F 6F 74 20 55 6E 73 75 63 63 65 73 73 66 75 6C 20 2D 20 43 68 65 63 6B 20 66 6F 72 20 44 69 73 6B 20 69 6E 20 41 3A                DB     'Boot Unsuccessful - Check for Disk in A:'
0450: F8FF 0D 0A 00                DB     CR,LF,EndOfMessage
0451: F902
0452: F902             SendBootMessage:
0453: F902 21 B7 F8               LD     HL,BootMessage
0454: F905
0455: F905             SendMessage:
0456: F905 7E                     LD     A,(HL)
0457: F906 B7                     OR     A
0458: F907 C8                     RET    Z
0459: F908 D3 EC                  OUT    (BOOT_CON_ADDRESS),A ; Console address
0460: F90A 23                     INC    HL
0461: F90B C3 05 F9               JP     SendMessage
0462: F90E
0463: F90E
0464: F90E         ;---------------------------------------------------
0465: F90E
0466: F90E         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0467: F90E         ;?	LD		HL,BootMessage
0468: F90E         ;?	CALL	DisplayMessage
0469: F90E         ;?
0470: F90E         ;?	LD		HL,BOOTControl
0471: F90E         ;?	CALL	RawDiskRead
0472: F90E         ;?
0473: F90E         ;?	JP		WBOOT				; do Warm boot if no errors
0474: F90E         ;?	LD		HL,BadBootMessage
0475: F90E         ;?	CALL	DisplayMessage		; Show Boot failure message
0476: F90E         ;?	HALT
0477: F90E         ;?
0478: F90E         ;?BOOTControl:
0479: F90E         ;?	DB		DiskReadCode					; Read function
0480: F90E         ;?	DB		00H								; unit number
0481: F90E         ;?	DB		00H								; head number
0482: F90E         ;?	DB		00H								; track number
0483: F90E         ;?	DB		0DH								; Starting sector number (13)
0484: F90E         ;?	DW		5 * 512							; Number of bytes to read ( 0A00 All of BIOS)
0485: F90E         ;?	DW		BIOSStart						; read into this address
0486: F90E         ;?	DW		DiskStatusLocation				; pointer to next block - no linking
0487: F90E         ;?	DW		DiskControlTable				; pointer to next table- no linking
0488: F90E         ;?
0489: F90E         ;?
0490: F90E         ;?;BOOTControl:
0491: F90E         ;?; 	DB		DiskReadCode		; Read function
0492: F90E         ;?; 	DB		00H					; unit number
0493: F90E         ;?; 	DB		00H					; head number
0494: F90E         ;?; 	DB		00H					; track number
0495: F90E         ;?; 	DB		01H					; Starting sector number ()
0496: F90E         ;?; 	DW		diskSectorSize		; Number of bytes to read ( 1 Sector)
0497: F90E         ;?; 	DW		TPA					; read into this address
0498: F90E         ;?; 	DW		DiskStatusLocation	; pointer to next block - no linking
0499: F90E         ;?; 	DW		DiskControlTable	; pointer to next table- no linking
0500: F90E         ;?
0501: F90E         ;?; Boot Messages and routine
0502: F90E         ;?BootMessage:
0503: F90E         ;?;	DB		'CP/M 2.2 (Z80) '
0504: F90E         ;?;	DB		'BootStrap Loader'
0505: F90E         ;?;	DB		CR,LF
0506: F90E         ;?	DB		'Build 0.A '
0507: F90E         ;?	DB		CR,LF
0508: F90E         ;?	DB		'CCP 0.A |  BDOS 0.A | BIOS 0.B'
0509: F90E         ;?	DB		CR,LF,EndOfMessage
0510: F90E         ;?BadBootMessage:
0511: F90E         ;?	DB		CR,LF
0512: F90E         ;?	DB		'****   Boot Failure'
0513: F90E         ;?	DB		EndOfMessage
0514: F90E         ;?WarmBootErroMessage:
0515: F90E         ;?	DB		CR,LF
0516: F90E         ;?	DB		'Warm Boot -'
0517: F90E         ;?	DB		' Retrying.'
0518: F90E         ;?	DB		CR,LF,EndOfMessage
0519: F90E         ;?;..................Boot Support....................
0520: F90E         ;?
0521: F90E         ;?; Entered with DiskControlBlock pointer in HL
0522: F90E         ;?RawDiskRead:
0523: F90E         ;?	LD		(DiskCommandBlock),HL
0524: F90E         ;?
0525: F90E         ;?	LD		HL,DiskControlByte
0526: F90E         ;?	LD		(HL),080H
0527: F90E         ;?
0528: F90E         ;?; wait for the read to complete
0529: F90E         ;?WaitForReadDone:
0530: F90E         ;?	LD		A,(HL)
0531: F90E         ;?	OR		A
0532: F90E         ;?	JR		NZ,WaitForReadDone
0533: F90E         ;?
0534: F90E         ;?; is it a clean read ?
0535: F90E         ;?	LD		A,(DiskStatusLocation)
0536: F90E         ;?	CP		080H				; any errors NC = good read?
0537: F90E         ;?	RET
0538: F90E         ;?
0539: F90E         ;?; entered with pointer to message in HL
0540: F90E         ;?DisplayMessage:
0541: F90E         ;?	LD		A,M					; get  character
0542: F90E         ;?	OR		A					; is it NULL
0543: F90E         ;?	RET		Z					; return if it is NULL (00)
0544: F90E         ;?	LD		C,A
0545: F90E         ;?	PUSH	HL					; save the pointer
0546: F90E         ;?	OUT		TTY_DataPort
0547: F90E         ;?	POP		HL					; retrieve the pointer
0548: F90E         ;?	INC		HL					; point at next character
0549: F90E         ;?	JR		DisplayMessage
0550: F90E         ;?
0551: F90E         ;....................................................
0552: F90E
0553: F90E         ;---------------------------------------------------------------------------
0554: F90E         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot
0555: F90E         ;
0556: F90E         ;  Unlike the "cold" bootstrap entry point, which executes only once, the WBOOT
0557: F90E         ; or warm boot routine will be executed every time a program terminates by
0558: F90E         ; jumping to location OOOOH, or whenever you type a CONTROL-C on the console as
0559: F90E         ; the first character of an input line.
0560: F90E         ;  The WBOOT routine is responsible for reloading the CCP into memory.
0561: F90E         ; Programs often use all of memory up to the starting point of the BDOS, overwriting
0562: F90E         ; the CCP in the process. The underlying philosophy is that while a program is
0563: F90E         ; executing, the CCP is not needed, so the program can use the memory previously
0564: F90E         ; occupied by the CCP. The CCP occupies 800H (2048) bytes ofmemory-and this
0565: F90E         ; is frequently just enough to make the difference between a program that cannot
0566: F90E         ; run and one that can.
0567: F90E         ; A few programs that are self-contained and do not require the BDOS's
0568: F90E         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes of
0569: F90E         ; memory. Therefore, to be really safe, the WBOOT routine should read in both the
0570: F90E         ; CCP and the BDOS. It also needs to set up the two JMPs at location OOOOH (to
0571: F90E         ; WBOOT itself) and at location 0005H (to the BOOS). Location 0003H should be
0572: F90E         ; set to the initial value of the 10BYTE if this is implemented in the BIOS.
0573: F90E         ; As its last act, the WBOOT routine sets register C to indicate which logical disk
0574: F90E         ; is to be selected (C= 0 for A, I for B, and so on). It then transfers control into the
0575: F90E         ; CCP at the first instruction in order to restart the CCP.
0576: F90E
0577: F90E             WBOOT:
0578: F90E 31 FF DF               LD     SP,CCPEntry-1        ; put stack at top of User area
0579: F911 21 44 F9               LD     HL,WBOOTControl      ; get the WBOOT Control Block
Bad symbol: RawDiskRead
Attempting to reference an undefined symbol: RawDiskRead on line: 0580
0580: F914 CD 00 00               CALL   RawDiskRead          ; read CCP & BDOS
0581: F917 30 09                  JR     NC,LoadPage0         ; set up page 0 if good read
0582: F919
Bad symbol: WarmBootErroMessage
Attempting to reference an undefined symbol: WarmBootErroMessage on line: 0583
0583: F919 21 00 00               LD     HL,WarmBootErroMessage
Bad symbol: DisplayMessage
Attempting to reference an undefined symbol: DisplayMessage on line: 0584
0584: F91C CD 00 00               CALL   DisplayMessage       ; send bad warm boot message
0585: F91F C3 0E F9               JP     WBOOT                ; keep trying
0586: F922
0587: F922
0588: F922         ; Set up page Zero
0589: F922             LoadPage0:
0590: F922 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0591: F924
0592: F924 32 00 00               LD     (WarmBoot),A
0593: F927 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0594: F92A 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0595: F92D
0596: F92D 32 05 00               LD     (BDOSE),A
0597: F930 21 06 E8               LD     HL,BDOSEntry         ; BDOS entry point
0598: F933 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0599: F936
0600: F936 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0601: F939 CD A5 FA               CALL   SETDMA               ; use normal BDOS  routine
0602: F93C FB                     EI                          ; Enable interrupts
0603: F93D
0604: F93D 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0605: F940 4F                     LD     C,A
0606: F941 C3 00 E0               JP     CCPEntry             ; transfer control to CCP
0607: F944
0608: F944
0609: F944             WBOOTControl:
0610: F944 01                     DB     DiskReadCode         ; Read function
0611: F945 00                     DB     00H                  ; unit number
0612: F946 00                     DB     00H                  ; head number
0613: F947 00                     DB     00H                  ; track number
0614: F948 02                     DB     02H                  ; Starting sector number (skip cold boot sector)
0615: F949 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read ( rest of the head)
0616: F94B 00 E0                  DW     CCPEntry             ; read into this address
0617: F94D 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0618: F94F 45 00                  DW     DiskControlByte      ; pointer to next table- no linking
0619: F951
0620: F951         ;---------------------------------------------------------------------------
0621: F951         ;	Console Status:		BIOS 02
0622: F951         ;
0623: F951         ;  CONST simply returns an indicator showing whether there is an incoming
0624: F951         ; character from the console device. The convention is that A = OFFH if a character
0625: F951         ; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
0626: F951         ; to reflect the contents of the A register - it is the contents that are important.
0627: F951         ; CONST is called by the CCP whenever the CCP is in the middle of an
0628: F951         ; operation that can be interrupted by pressing a keyboard character.
0629: F951         ;
0630: F951         ; The BDOS will call CONST if a program makes a Read Console Status
0631: F951         ; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
0632: F951         ; routine, CONIN
0633: F951
0634: F951             CONST:
0635: F951             ConStatus:
0636: F951 3A 03 00               LD     A,(IOBYTE)
0637: F954 DD 21 42 FA               LD     IX,CON_Vector
0638: F958
0639: F958             GenericInStatus:                      ; Entry point for generic input status
0640: F958 CD FE F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0641: F95B CD CB F9               CALL   GetInStatus
0642: F95E B7                     OR     A
0643: F95F C8                     RET    Z                    ; 00 => No data pending
0644: F960 3E FF                  LD     A,0FFH
0645: F962 C9                     RET                         ; OFFH => Data in Buffer
0646: F963         ;---------------------------------------------------------------------
0647: F963         ;	Console In:		BIOS 03
0648: F963         ;
0649: F963         ;  CONIN reads the next character from the console to the A register and sets the
0650: F963         ; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
0651: F963         ; until it detects A = OFFH. Only then will it input the data character and mask off
0652: F963         ; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
0653: F963         ; Read Console Byte function (B$CONIN, code 1).
0654: F963         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0655: F963
0656: F963         ; This is a blocking routine
0657: F963
0658: F963             CONIN:
0659: F963             ConIn:
0660: F963 CD 51 F9               CALL   ConStatus
0661: F966 28 FB                  JR     Z,ConIn              ; loop until there is some data to read
0662: F968         ; Call to ConStatus Sets up IX with Physical Table
0663: F968 DD 6E 06               LD     L,(IX+DataReadIndex)
0664: F96B DD 66 07               LD     H,(IX+(DataReadIndex+1))
0665: F96E E9                     JP     (HL)
0666: F96F         ;---------------------------------------------------------------------------
0667: F96F         ;	Console Out:		BIOS 04
0668: F96F         ;
0669: F96F         ;  CONOUT outputs the character (in ASCII) in register C to the console. The
0670: F96F         ; most significant (parity) bit of the character will always be O.
0671: F96F         ; CONOUT must first check that the console device is ready to receive more
0672: F96F         ; data, delaying if necessary until it is, and only then sending the character to the
0673: F96F         ; device. CONOUT is called by the CCP and by the BDOS when a program executes a
0674: F96F         ; Write Console Byte function (B$CONOUT, code 2).
0675: F96F
0676: F96F         ; This is a blocking routine
0677: F96F
0678: F96F             CONOUT:
0679: F96F             CONOut:
0680: F96F 3A 03 00               LD     A,(IOBYTE)
0681: F972 DD 21 42 FA               LD     IX,CON_Vector
0682: F976
0683: F976             GenericOutStatus:                      ; entry point for standard blocking write
0684: F976 CD FE F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0685: F979             GenericOutStatus1:
0686: F979 CD C6 F9               CALL   GetOutStatus
0687: F97C 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0688: F97E DD 6E 08               LD     L,(IX+DataWriteIndex)
0689: F981 DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0690: F984 E9                     JP     (HL)
0691: F985
0692: F985         ;---------------------------------------------------------------------------
0693: F985         ;	List output  BIOS 05
0694: F985         ;
0695: F985         ; LIST is similar to CONOUT except that it sends the character in register C to
0696: F985         ; the list device. It too checks first that the list device is ready to receive
0697: F985         ; the character. LIST is called by the CCP in response to the CONTROL-P toggle
0698: F985         ; for printer echo of console output, and by the BDOS when a program makes a
0699: F985         ; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).
0700: F985
0701: F985         ; This is a blocking routine
0702: F985
0703: F985             LIST:
0704: F985 3A 03 00               LD     A,(IOBYTE)
0705: F988 07                     RLCA                        ; move bits 7,6
0706: F989 07                     RLCA                        ; to 1,0
0707: F98A DD 21 5A FA               LD     IX,LST_Vector
0708: F98E 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0709: F990
0710: F990         ;---------------------------------------------------------------------------
0711: F990         ;	Punch output  BIOS 06
0712: F990         ;
0713: F990         ;  PUNCH sends the character in register C to the "punch" device. As mentioned
0714: F990         ; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
0715: F990         ; entry point either returns immediately and is effectively a null routine, or it outputs
0716: F990         ; the character to a communications device, such as a modem, on your computer.
0717: F990         ; PUNCH must check that the "punch" device is indeed ready to accept another
0718: F990         ; character for output, and must wait if it is not.
0719: F990         ;
0720: F990         ; Digital Research's documentation states that the character to be output will
0721: F990         ; always have its most significant bit set to O. This is not true. The BDOS simply
0722: F990         ; transfers control over to the PUNCH entry point in the BIOS; the setting of the
0723: F990         ; most significant bit will be determined by the program making the BDOS function
0724: F990         ; request (B$PUNOUT, code 4). This is important because the requirement of a zero
0725: F990         ; would preclude being able to send pure binary data via the BIOS PUNCH
0726: F990         ; function
0727: F990
0728: F990         ; This is a blocking routine
0729: F990
0730: F990             PUNCH:                          ; Punch output
0731: F990 3A 03 00               LD     A,(IOBYTE)
0732: F993 0F                     RRCA
0733: F994 0F                     RRCA
0734: F995 0F                     RRCA                        ; move bits 5,4
0735: F996 0F                     RRCA                        ; to 1,0
0736: F997 DD 21 52 FA               LD     IX,PUN_Vector
0737: F99B 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0738: F99D
0739: F99D         ;---------------------------------------------------------------------------
0740: F99D         ;	Reader input  BIOS 07
0741: F99D         ;
0742: F99D         ; As with the PUNCH entry point, the READER entry point rarely connects to
0743: F99D         ; a real paper tape reader.
0744: F99D         ; The READER function must return the next character from the reader device
0745: F99D         ; in the A register, waiting, if need be, until there is a character.
0746: F99D         ;
0747: F99D         ; Digital Research's documentation again says that the most significant bit of
0748: F99D         ; the A register must be 0, but this is not the case if you wish to receive pure binary
0749: F99D         ; information via this function.
0750: F99D         ; READER is called whenever a program makes a Read "Reader" Byte function
0751: F99D         ; request (B$READIN, code 3).
0752: F99D
0753: F99D         ; This is a blocking routine
0754: F99D
0755: F99D             READER:                         ; Reader Input
0756: F99D 3A 03 00               LD     A,(IOBYTE)
0757: F9A0 0F                     RRCA
0758: F9A1 0F                     RRCA                        ; move bits 3,2  to 1,0
0759: F9A2 DD 21 4A FA               LD     IX,RDR_Vector
0760: F9A6             READER1:
0761: F9A6 CD 58 F9               CALL   GenericInStatus
0762: F9A9 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0763: F9AB
0764: F9AB DD 6E 06               LD     L,(IX+DataReadIndex)
0765: F9AE DD 66 07               LD     H,(IX+(DataReadIndex+1))
0766: F9B1 E9                     JP     (HL)
0767: F9B2
0768: F9B2         ;---------------------------------------------------------------------------
0769: F9B2         ;	List Status:  BIOS 0F
0770: F9B2
0771: F9B2         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0772: F9B2         ; This function returns the current status of the list device, using the IOBYTE if
0773: F9B2         ; necessary to select the correct physical device. It sets the A register to OFFH if the
0774: F9B2         ; list device can accept another character for output or to OOH if it is not ready.
0775: F9B2         ; Digital Research's documentation states that this function is used by the
0776: F9B2         ; DESPOOL utility program (which allows you to print a file "simultaneously" with
0777: F9B2         ; other operations) to improve console response during its operation, and that it is
0778: F9B2         ; acceptable for the routine always to return OOH if you choose not to implement it
0779: F9B2         ; fully.
0780: F9B2         ; Unfortunately, this statement is wrong. Many other programs use the LISTST
0781: F9B2         ; function to "poll" the list device to make sure it is ready, and if it fails to come
0782: F9B2         ; ready after a predetermined time, to output a message to the console indicating
0783: F9B2         ; that the printer is not ready. If you ever make a call to the BDOS list output
0784: F9B2         ; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0785: F9B2         ; not ready, then CP/M will wait forever-and your program will have lost control
0786: F9B2         ; so it cannot even detect that the problem has occurred. If LISTST always returns a
0787: F9B2         ; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
0788: F9B2         ; out of the LISTST function, but it also causes a stream of false "Printer
0789: F9B2         ; not Ready" error messages to appear on the console.
0790: F9B2
0791: F9B2             LISTST:
0792: F9B2 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0793: F9B5 07                     RLCA
0794: F9B6 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0795: F9B7 DD 21 5A FA               LD     IX,LST_Vector        ; Set th vector base
0796: F9BB CD FE F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0797: F9BE CD C6 F9               CALL   GetOutStatus
0798: F9C1
0799: F9C1 B7                     OR     A
0800: F9C2 C8                     RET    Z                    ; 00 => Device Ready
0801: F9C3 3E FF                  LD     A,0FFH
0802: F9C5 C9                     RET                         ; OFFH => Device No Ready
0803: F9C6
0804: F9C6         ;---------------------------------------------------------------------------
0805: F9C6
0806: F9C6         ;---------------------------------------------------------------------
0807: F9C6             GetOutStatus:
0808: F9C6         ; vector to CON Devices
0809: F9C6 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0810: F9C9 18 03                  JR     GetStatus
0811: F9CB             GetInStatus:
0812: F9CB DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0813: F9CE             GetStatus:
0814: F9CE DD 6E 04               LD     L,(IX+StatusReadIndex)
0815: F9D1 DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0816: F9D4 E9                     JP     (HL)                 ; jump to the stats read routine
0817: F9D5
0818: F9D5         ;---------------------------------------------------------------------
0819: F9D5
0820: F9D5             DataRead:
0821: F9D5 DD 7E 01               LD     A,(IX+DataPortIndex)
0822: F9D8 32 DC F9               LD     (AddressDataIn),A    ; modify code with the Data port
0823: F9DB DB                     DB     IN_OPCODE
0824: F9DC             AddressDataIn:
0825: F9DC 00                     DB     00                   ; perform the read
0826: F9DD C9                     RET
0827: F9DE
0828: F9DE             DataReadASCII:
0829: F9DE CD D5 F9               CALL   DataRead
0830: F9E1 E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0831: F9E3 C9                     RET                         ; AND		ASCII_MASK
0832: F9E4
0833: F9E4         ; Enter DataWrite the value to be output in C
0834: F9E4             DataWrite:
0835: F9E4 DD 7E 01               LD     A,(IX+DataPortIndex)
0836: F9E7 32 EC F9               LD     (AddressDataOut),A   ; modify code with the Data port
0837: F9EA 79                     LD     A,C                  ; get value into ACC
0838: F9EB D3                     DB     OUT_OPCODE
0839: F9EC             AddressDataOut:
0840: F9EC 00                     DB     00                   ; perform the write
0841: F9ED C9                     RET
0842: F9EE
0843: F9EE
0844: F9EE         ; Enter Status Read with Target mask in D
0845: F9EE             StatusRead:
0846: F9EE DD 7E 00               LD     A,(IX+StatusPortIndex)
0847: F9F1 32 F5 F9               LD     (AddressStatus),A    ; modify code with the status port
0848: F9F4 DB                     DB     IN_OPCODE
0849: F9F5             AddressStatus:
0850: F9F5 00                     DB     00
0851: F9F6 A2                     AND    D                    ; Check return vale with the mask
0852: F9F7 C9                     RET
0853: F9F8
0854: F9F8             DUMMYRead:
0855: F9F8 C9                     RET
0856: F9F9             DUMMYWrite:
0857: F9F9 C9                     RET
0858: F9FA             DUMMYCheck:
0859: F9FA 3E FF                  LD     A,0FFH               ; Always return 0FFH
0860: F9FC B7                     OR     A                    ; Set flags
0861: F9FD C9                     RET
0862: F9FE
0863: F9FE         ;=============================================================================
0864: F9FE             SetDeviceVector:
0865: F9FE E6 03                  AND    03H                  ; Get bits 0 & 1;
0866: FA00 87                     ADD    A,A                  ; Double for word size index
0867: FA01 16 00                  LD     D,00H
0868: FA03 5F                     LD     E,A                  ; load byte index int DE
0869: FA04 DD 19                  ADD    IX,DE                ; add to the value vector base
0870: FA06         ; IX points at correct entry in vector
0871: FA06 DD 5E 00               LD     E,(IX+0)
0872: FA09 DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0873: FA0C D5                     PUSH   DE
0874: FA0D DD E1                  POP    IX                   ; Move it to IX
0875: FA0F C9                     RET
0876: FA10
0877: FA10
0878: FA10         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0879: FA10         ; Physical Device Attributes
0880: FA10
0881: FA10             TTY_StatusPort EQU    0EDH
0882: FA10             TTY_DataPort EQU    0ECH
0883: FA10             TTY_OutputMask EQU    80H                  ; Status Mask
0884: FA10             TTY_InputMask EQU    7FH                  ; Status Mask
0885: FA10
0886: FA10             CRT_StatusPort EQU    02H
0887: FA10             CRT_DataPort EQU    01H
0888: FA10             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0889: FA10             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0890: FA10
0891: FA10             COM_StatusPort EQU    0EDH
0892: FA10             COM_DataPort EQU    0ECH
0893: FA10             COM_OutputMask EQU    01H                  ; Status Mask
0894: FA10             COM_InputMask EQU    02H                  ; Status Mask
0895: FA10
0896: FA10             LPT_StatusPort EQU    011H
0897: FA10             LPT_DataPort EQU    010H
0898: FA10             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0899: FA10             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0900: FA10
0901: FA10             DUMMY_StatusPort EQU    011H
0902: FA10             DUMMY_DataPort EQU    010H
0903: FA10             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0904: FA10             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0905: FA10
0906: FA10         ; Device Table Control Block Definition
0907: FA10             StatusPortIndex EQU    0
0908: FA10             DataPortIndex EQU    1
0909: FA10             OutputMaskIndex EQU    2
0910: FA10             InputMaskIndex EQU    3
0911: FA10             StatusReadIndex EQU    4
0912: FA10             DataReadIndex EQU    6
0913: FA10             DataWriteIndex EQU    8
0914: FA10
0915: FA10         ;Physical Devices Control Blocks
0916: FA10
0917: FA10             TTY_Table:
0918: FA10 ED                     DB     TTY_StatusPort
0919: FA11 EC                     DB     TTY_DataPort
0920: FA12 80                     DB     TTY_OutputMask
0921: FA13 7F                     DB     TTY_InputMask
0922: FA14 EE F9                  DW     StatusRead
0923: FA16 DE F9                  DW     DataReadASCII
0924: FA18 E4 F9                  DW     DataWrite
0925: FA1A
0926: FA1A             CRT_Table:
0927: FA1A 02                     DB     CRT_StatusPort
0928: FA1B 01                     DB     CRT_DataPort
0929: FA1C 80                     DB     CRT_OutputMask
0930: FA1D 7F                     DB     CRT_InputMask
0931: FA1E EE F9                  DW     StatusRead
0932: FA20 D5 F9                  DW     DataRead
0933: FA22 E4 F9                  DW     DataWrite
0934: FA24             COM_Table:
0935: FA24 ED                     DB     COM_StatusPort
0936: FA25 EC                     DB     COM_DataPort
0937: FA26 01                     DB     COM_OutputMask
0938: FA27 02                     DB     COM_InputMask
0939: FA28 EE F9                  DW     StatusRead
0940: FA2A D5 F9                  DW     DataRead
0941: FA2C E4 F9                  DW     DataWrite
0942: FA2E             LPT_Table:
0943: FA2E 11                     DB     LPT_StatusPort
0944: FA2F 10                     DB     LPT_DataPort
0945: FA30 FF                     DB     LPT_OutputMask
0946: FA31 7F                     DB     LPT_InputMask
0947: FA32 EE F9                  DW     StatusRead
0948: FA34 D5 F9                  DW     DataRead
0949: FA36 E4 F9                  DW     DataWrite
0950: FA38             DUMMY_Table:
0951: FA38 11                     DB     DUMMY_StatusPort
0952: FA39 10                     DB     DUMMY_DataPort
0953: FA3A FF                     DB     DUMMY_OutputMask
0954: FA3B 7F                     DB     DUMMY_InputMask
0955: FA3C FA F9                  DW     DUMMYCheck
0956: FA3E F8 F9                  DW     DUMMYRead
0957: FA40 F9 F9                  DW     DUMMYWrite
0958: FA42
0959: FA42         ;---------------------------------------------------------------------------
0960: FA42
0961: FA42         ; Logical Device Vector, Controlled by IOBYTE
0962: FA42
0963: FA42             CON_Vector:                      ; IOBYTE bits 1 & 0
0964: FA42 10 FA                  DW     TTY_Table
0965: FA44 1A FA                  DW     CRT_Table
0966: FA46 24 FA                  DW     COM_Table
0967: FA48 38 FA                  DW     DUMMY_Table
0968: FA4A             RDR_Vector:                      ; IOBYTE bits 3 & 2
0969: FA4A 10 FA                  DW     TTY_Table
0970: FA4C 1A FA                  DW     CRT_Table
0971: FA4E 38 FA                  DW     DUMMY_Table
0972: FA50 38 FA                  DW     DUMMY_Table
0973: FA52             PUN_Vector:                      ; IOBYTE bits 5 & 4
0974: FA52 10 FA                  DW     TTY_Table
0975: FA54 38 FA                  DW     DUMMY_Table
0976: FA56 24 FA                  DW     COM_Table
0977: FA58 1A FA                  DW     CRT_Table
0978: FA5A             LST_Vector:                      ; IOBYTE bits 7 & 6
0979: FA5A 2E FA                  DW     LPT_Table
0980: FA5C 1A FA                  DW     CRT_Table
0981: FA5E 2E FA                  DW     LPT_Table
0982: FA60 38 FA                  DW     DUMMY_Table
0983: FA62
0984: FA62         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0985: FA62         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0986: FA62
0987: FA62         ;---------------------------------------------------------------------------
0988: FA62         ;	Disk routines
0989: FA62         ;---------------------------------------------------------------------------
0990: FA62
0991: FA62         ;  All of the disk functions that follow were originally designed to operate on the
0992: FA62         ; 128-byte sectors used on single-sided, single-density, 8-inch floppy diskettes that
0993: FA62         ; were standard in the industry at the time. Now that CP/M runs on many different
0994: FA62         ; types of disks, some of the BIOS disk functions seem strange because most of the
0995: FA62         ; new disk drives use sector sizes other than 128 bytes.
0996: FA62         ; To handle larger sector sizes, the BIOS has some additional code that makes
0997: FA62         ; the BDOS respond as if it were still handling 128-byte sectors. This code is referred
0998: FA62         ; to as the blocking/deblocking code.
0999: FA62         ;  As its name implies, it blocks together several 128-byte "sectors" and only writes
1000: FA62         ; to the disk when a complete physical sector has been assembled.
1001: FA62         ;  When reading, it reads in a physical sector and then deblocks it,handing back
1002: FA62         ; several 128-byte "sectors" to the BDOS.
1003: FA62         ;  To do all of this, the blocking/deblocking code uses a special buffer area of the
1004: FA62         ; same size as the physical sectors on the disk. This is known as the host disk buffer
1005: FA62         ; or HSTBUE Physical sectors are read into this buffer and written to the disk
1006: FA62         ; from it. In order to optimize this blocking/deblocking routine, the BIOS has code in it
1007: FA62         ; to reduce the number of times that an actual disk read or write occurs. A side effect
1008: FA62         ; is that at any given moment, several 128-byte "sectors" may be stored in the
1009: FA62         ; HSTBUF, waiting to be written out to the disk when HSTBUF becomes full. This
1010: FA62         ; sometimes complicates the logic of the BIOS disk functions. You cannot simply
1011: FA62         ; select a new disk drive, for example, when the HSTBUF contains data destined for
1012: FA62         ; another disk drive. You will see this complication in the BIOS only in the form of
1013: FA62         ; added logical operations; the BIOS disk functions rarely trigger immediate physical
1014: FA62         ; operations. It is easier to understand these BIOS functions if you consider that
1015: FA62         ; they make requests-and that these requests are satisfied only when it makes
1016: FA62         ; sense to do so, taking into account the blocking/ deblocking logic.
1017: FA62
1018: FA62         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1019: FA62         ;---------------------------------------------------------------------------
1020: FA62
1021: FA62         ;---------------------------------------------------------------------------
1022: FA62         ;	Home Disk	BIOS 08
1023: FA62         ;
1024: FA62         ;  HOME - Home the selected logical disk to track 0. Before doing this, a check
1025: FA62         ; must be made to see if the physical disk buffer has information that must be
1026: FA62         ; written out. This is indicated by a flag, DirtyBufferFlag,set in the de-blocking code
1027: FA62
1028: FA62             HOME:
1029: FA62 3A 0A FC               LD     A,(DirtyBufferFlag)  ; Check for Dirty Buffer
1030: FA65 B7                     OR     A
1031: FA66 20 03                  JR     NZ,HomeNoWrite
1032: FA68 32 09 FC               LD     (DataInBufferFlag),A ; Clear DataInBufferFlag if Buffer not dirty
1033: FA6B             HomeNoWrite:
1034: FA6B 0E 00                  LD     C,00H                ; Set to track 0
1035: FA6D CD 9B FA               CALL   SETTRK               ; no, physical, only logical
1036: FA70 C9                     RET
1037: FA71
1038: FA71         ;---------------------------------------------------------------------------
1039: FA71         ;	Select Disk	BIOS 09
1040: FA71
1041: FA71         ;  SELDSK does not do what its name implies. It does not (and must not)
1042: FA71         ; physically select a logical disk. Instead, it returns a pointer in the
1043: FA71         ; HL register pair to the disk parameter header for the logical disk specified
1044: FA71         ; in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK also
1045: FA71         ; stores this code for the requested disk to be used later in the READ and WRITE functions.
1046: FA71         ; If the logical disk code in register C refers to a nonexistent disk or to one for
1047: FA71         ; which no disk parameter header exists, then SELDSK must return with HL set to
1048: FA71         ; OOOOH. Then the BDOS will output a message of the form "BDOS Err on XI Select"
1049: FA71         ; Note that SELDSK not only does not select the disk, but also does not indicate
1050: FA71         ; whether or not the requested disk is physically present -merely whether or not
1051: FA71         ; there are disk tables present for the disk.
1052: FA71         ;  SELDSK is called by the BDOS either during disk file operations or by a
1053: FA71         ; program issuing a Select Disk request (B$SELDSK, code 14).
1054: FA71
1055: FA71             SELDSK:
1056: FA71 21 00 00               LD     HL,00H               ; Assume an error
1057: FA74 79                     LD     A,C
1058: FA75 FE 04                  CP     NumberOfLogicalDisks
1059: FA77 D0                     RET    NC                   ; return if > max number of Disks
1060: FA78
1061: FA78 32 0C FC               LD     (SelectedDisk),A     ; save disk number
1062: FA7B
1063: FA7B 07                     RLCA                        ; X2
1064: FA7C 07                     RLCA                        ; X4
1065: FA7D 07                     RLCA                        ; X8
1066: FA7E 07                     RLCA                        ; X16
1067: FA7F 16 00                  LD     D,0
1068: FA81 5F                     LD     E,A                  ; put index int DE
1069: FA82 DD 21 1B FC               LD     IX,DiskParameterHeaders ; get DPH address Base
1070: FA86 DD 19                  ADD    IX,DE                ; get the specific DiskParameterHeader
1071: FA88 DD E5                  PUSH   IX                   ; save for return in HL
1072: FA8A
1073: FA8A DD 56 0B               LD     D,(IX+11)            ; LSB for Disk Parameter Block
1074: FA8D DD 5E 0A               LD     E,(IX+10)            ; MSB for Disk Parameter Block
1075: FA90
1076: FA90 D5                     PUSH   DE
1077: FA91 DD E1                  POP    IX
1078: FA93 DD 7E 0F               LD     A,(IX+15)            ; Disk Parameter Block in IY
1079: FA96 32 0B FC               LD     (SelectedDskSecsPerHead),A
1080: FA99
1081: FA99 E1                     POP    HL                   ; recover DPH pointer
1082: FA9A C9                     RET
1083: FA9B
1084: FA9B
1085: FA9B
1086: FA9B         ;---------------------------------------------------------------------------
1087: FA9B         ;	Set Track	BIOS 0A
1088: FA9B
1089: FA9B         ;  SETTRK saves the requested disk track that is in the BC register pair when
1090: FA9B         ; SETTRK gets control. Note that this is an absolute track number; that is, the
1091: FA9B         ; number of reserved tracks before the file directory will have been added to the
1092: FA9B         ; track number relative to the start of the logical disk.
1093: FA9B         ;  The number of the requested track will be used in the next BIOS READ or
1094: FA9B         ; WRITE function.
1095: FA9B         ;  SETTRK is called by the BDOS when it needs to read or write a 128-byte
1096: FA9B         ; sector. Legitimate track numbers are from 0 to OFFFFH (65,535).
1097: FA9B
1098: FA9B             SETTRK:
1099: FA9B         ;	LD		H,B								; select track in BC on entry
1100: FA9B         ;	LD		L,C
1101: FA9B         ;	LD	(SelectedTrack),HL					; save for low level driver
1102: FA9B ED 43 0D FC               LD     (SelectedTrack),BC   ; save for low level driver
1103: FA9F C9                     RET
1104: FAA0
1105: FAA0         ;---------------------------------------------------------------------------
1106: FAA0         ;	Set Sector	BIOS 0B  (Set Record)
1107: FAA0
1108: FAA0         ; Sector  = Record for disk with 128 byte sectors
1109: FAA0         ; Sector contains 4 records for disks with 512 byte sectors
1110: FAA0         ; this routine is missed named it should be called Set Record
1111: FAA0
1112: FAA0         ;  SETSEC is similar to SETTRK in that it stores the requested Record (sector) number
1113: FAA0         ; for later use in BIOS READ or WRITE functions. The requested Record (sector) number is
1114: FAA0         ; handed to SETSEC in the A register; legitimate values are from 0 to OFFH (255).
1115: FAA0         ; The Record (sector) number is a logical Record (sector) number. It does not take into account any
1116: FAA0         ; sector skewing that might be used to improve disk performance.
1117: FAA0         ;  SETSEC is called by the BDOS when it needs to read or write a 128-byte
1118: FAA0         ; Record (sector).
1119: FAA0
1120: FAA0             SETSEC:                         ; SETRECORD
1121: FAA0 79                     LD     A,C
1122: FAA1 32 0F FC               LD     (SelectedRecord),A   ; save for low level driver
1123: FAA4 C9                     RET
1124: FAA5
1125: FAA5         ;---------------------------------------------------------------------------
1126: FAA5         ;	Set Sector	BIOS 0C
1127: FAA5
1128: FAA5         ;  SETDMA saves the address in the BC register pair in the requested DMA
1129: FAA5         ; address. The next BIOS READ or WRITE function will use the DMA address as
1130: FAA5         ; a pointer to the 128-byte sector buffer into which data will be read or from which
1131: FAA5         ; data will be written.
1132: FAA5         ;  The default DMA address is 0080H. SETDMA is called by the BDOS when it
1133: FAA5         ; needs to READ or WRITE a 128-byte sector.
1134: FAA5
1135: FAA5             SETDMA:
1136: FAA5 ED 43 10 FC               LD     (DMAAddress),BC      ; save for low level driver
1137: FAA9 C9                     RET
1138: FAAA
1139: FAAA         ;---------------------------------------------------------------------------
1140: FAAA         ;	Sector Translate	BIOS 10
1141: FAAA
1142: FAAA         ;  SECTRAN, given a logical sector number, locates the correct physical sector
1143: FAAA         ; number in the sector translate table for the previously selected (via SELDSK)
1144: FAAA         ; logical disk drive. Note that both logical and physical sector numbers are
1145: FAAA         ; l28-byte sectors, so if you are working with a hard disk system, it is not
1146: FAAA         ; too efficient to impose a sector interlace at the l28-byte sector level.
1147: FAAA         ; It is better to impose the sector interlace right inside the hard disk driver,
1148: FAAA         ; if at all. In general, hard disks spin so rapidly that CP/M simply cannot take
1149: FAAA         ; advantage of sector interlace.
1150: FAAA         ;  The BDOS hands over the logical sector number in the BC register pair, with
1151: FAAA         ; the address of the sector translate table in the DE register pair. SECTRAN must
1152: FAAA         ; return the physical sector number in HL.
1153: FAAA         ;  If SECTRAN is to be a null routine, it must move the contents of BC to HL
1154: FAAA         ; and return.
1155: FAAA
1156: FAAA             SECTRAN:
1157: FAAA C5                     PUSH   BC
1158: FAAB E1                     POP    HL                   ; just move the value from BC to HL
1159: FAAC C9                     RET
1160: FAAD
1161: FAAD         ;---------------------------------------------------------------------------
1162: FAAD         ;	READ			BIOS 0D
1163: FAAD
1164: FAAD         ;  READ reads in a 128-byte sector provided that there have been previous BIOS
1165: FAAD         ; function calls to:
1166: FAAD         ; 				- SELDSK	"select" the disk
1167: FAAD         ; 				- SETDMA	set the DMA address
1168: FAAD         ; 				- SETTRK	set the track number
1169: FAAD         ; 				- SETSEC	set the sector number.
1170: FAAD         ;
1171: FAAD         ; Because of the blocking/ deblocking code in the BIOS, there are frequent occasions
1172: FAAD         ; when the requested sector will already be in the host buffer (HSTBUF), so that a
1173: FAAD         ; physical disk read is not required. All that is then required is for the BIOS to move
1174: FAAD         ; the appropriate 128 bytes from the HSTBUF into the buffer pointed at by the DMA address.
1175: FAAD         ; Only during the READ function will the BIOS normally communicate with the physical disk
1176: FAAD         ; drive, selecting it and seeking to read the requested track and sector. During this process,
1177: FAAD         ; the READ function must also handle any hardware errors that occur, trying an operation again
1178: FAAD         ; if a "soft," or recoverable, error occurs.
1179: FAAD         ;  The READ function must return with the A register set to OOH if the read operation has completed
1180: FAAD         ; successfully. If the READ function returns with the A register set to 01 H, the BDOS will
1181: FAAD         ; display an error message of the form BDOS Err on X: Bad Sector. Under these circumstances,
1182: FAAD         ; you have only two choices. You can enter a CARRIAGE RETURN, ignore the fact that there was an
1183: FAAD         ; error, and attempt to make sense of the data in the DMA buffer. Or you can type a CONTROL-C
1184: FAAD         ; to abort the operation, perform a warm boot, and return control to the CCP. As you can see,
1185: FAAD         ; CP/M's error handling is not particularly helpful, so most BIOS writers add more sophisticated
1186: FAAD         ; error recovery right in the disk driver. This can include some interaction with the console so
1187: FAAD         ; that a more determined effort can be made to correct errors or, if nothing else, give you more
1188: FAAD         ; information as to what has gone wrong. Such error handling is discussed in Chapter 9.
1189: FAAD         ;  If you are working with a hard disk system, the BIOS driver must also handle the management of
1190: FAAD         ; bad sectors. You cannot simply replace a hard disk drive if one or two sectors become unreadable.
1191: FAAD         ; This bad sector management normally requires that a directory of "spare" sectors be put on the
1192: FAAD         ; hard disk before it is used to store data. Then, when a sector is found to be bad,
1193: FAAD         ; one of the spare sectors is substituted in its place.
1194: FAAD
1195: FAAD             READ:
1196: FAAD AF                     XOR    A
1197: FAAE 32 17 FC               LD     (ModifiedlRecordsCount),A ; 1. Set ModifiedlRecordsCount to 0
1198: FAB1 3C                     INC    A
1199: FAB2 32 1A FC               LD     (ReadWriteFlag),A    ; 2. Set to Flag to read (non-zero)
1200: FAB5 32 19 FC               LD     (PrereadSectorFlag),A ; 3. Force a preread
1201: FAB8 3E 02                  LD     A,WriteCleanBuffer
1202: FABA 32 04 FC               LD     (WriteType),A        ; 4. Fake a clean sector Write type = 02
1203: FABD C3 EA FA               JP     CommonDiskIO         ; Use common code to execute read
1204: FAC0         ;---------------------------------------------------------------------------
1205: FAC0         ;	WRITE			BIOS 0E
1206: FAC0         ;
1207: FAC0         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
1208: FAC0         ;
1209: FAC0         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
1210: FAC0         ;	00H [WriteAllocated]	An already allocated allocation block (which means a pre-read of the sector may be needed),
1211: FAC0         ;	01H [WriteDirectory]	To the directory (in which case the data will be written to the disk immediately),
1212: FAC0         ;	02H [WriteCleanBuffer]	To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
1213: FAC0
1214: FAC0         ;  WRITE is similar to READ but with the obvious difference that data is transferred from the DMA buffer
1215: FAC0         ; to the specified 128-byte sector. Like READ, this function requires that the following function calls
1216: FAC0         ; have already been made:
1217: FAC0         ; 				- SELDSK	"select" the disk
1218: FAC0         ; 				- SETDMA	set the DMA address
1219: FAC0         ; 				- SETTRK	set the track number
1220: FAC0         ; 				- SETSEC	set the sector number.
1221: FAC0         ;
1222: FAC0         ;  Again, it is only in the WRITE routine that the driver will start to talk directly to the physical hardware,
1223: FAC0         ; selecting the disk unit, track, and sector, and transferring the data to the disk. With the blocking/deblocking code,
1224: FAC0         ; the BDOS optimizes the number of disk writes that are needed by indicating in register C the type of disk write
1225: FAC0         ; that is to be performed:
1226: FAC0         ; 				0= normal sector write
1227: FAC0         ; 				1= write to file directory sector
1228: FAC0         ; 				2 = write to sector of previously unchanged Deblocking Buffer
1229: FAC0         ;
1230: FAC0         ;  Type 0 occurs whenever the BDOS is writing to a data sector in an already used allocation block.
1231: FAC0         ; Under these circumstances, the disk driver must preread the appropriate host sector because there
1232: FAC0         ; may be previously stored information on it.
1233: FAC0         ;
1234: FAC0         ;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in this case, the BIOS must not defer
1235: FAC0         ; writing the sector to the disk, as the information is too valuable to hold in memory until the HSTBUF is full.
1236: FAC0         ; The longer the information resides in the HSTBUF, the greater the chance of a power failure or glitch,
1237: FAC0         ; making file data already physically written to the disk inaccessible because the file directory is out of date.
1238: FAC0         ;
1239: FAC0         ;  Type 2 occurs whenever the BDOS needs to write to the first sector of a previously unused allocation block.
1240: FAC0         ; Unused, in this context, includes an allocation block that has become available as a result of a file being erased.
1241: FAC0         ; In this case, there is no need for the disk driver to preread an entire host-sized sector into the HSTBUF,
1242: FAC0         ; as there is no data of value in the physical sector.
1243: FAC0         ;
1244: FAC0         ;  As with the READ routine, the WRITE function returns with A set to OOH if the operation has been completed successfully.
1245: FAC0         ; If the WRITE function returns with A set to 01H, then the BDOS will display the same message as for READ:
1246: FAC0         ; BDOS Err on X: Bad Sector
1247: FAC0
1248: FAC0
1249: FAC0             WRITE:
1250: FAC0         ; BlockingBuffer I/O
1251: FAC0 AF                     XOR    A
1252: FAC1 32 1A FC               LD     (ReadWriteFlag),A    ; Set to zero to indicate that this is a Write
1253: FAC4 79                     LD     A,C
1254: FAC5 32 04 FC               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
1255: FAC8
1256: FAC8 FE 02                  CP     WriteCleanBuffer     ; first, is this a clean Allocation Buffer block ?
1257: FACA C2 D8 FA               JP     NZ,CheckDirtyBuffer  ; No
1258: FACD
1259: FACD         ;Write from a clean Host Buffer
1260: FACD 21 0C FC               LD     HL,SelectedState
1261: FAD0 11 13 FC               LD     DE,HostBufferState
1262: FAD3 01 04 00               LD     BC,SelectedDiskStateSize
1263: FAD6 ED B0                  LDIR                        ; copy Selected State to Host Buffer state
1264: FAD8
1265: FAD8             CheckDirtyBuffer:
1266: FAD8
1267: FAD8 21 0C FC               LD     HL,SelectedState
1268: FADB 11 13 FC               LD     DE,HostBufferState
1269: FADE CD 80 FB               CALL   CompareDkTrkSec      ; is it in Host Buffer?
1270: FAE1 3E FF                  LD     A,TRUE               ;......
1271: FAE3 C2 E7 FA               JP     NZ,SetPreread        ; NO - Then we need to load the Host Buffer
1272: FAE6
1273: FAE6 AF                     XOR    A
1274: FAE7             SetPreread:
1275: FAE7 32 19 FC               LD     (PrereadSectorFlag),A ; clear preread flag
1276: FAEA         ;*******************************************************
1277: FAEA         ; Common code to execute both reads and writes of 128-byte records
1278: FAEA         ;*******************************************************
1279: FAEA             CommonDiskIO:
1280: FAEA AF                     XOR    A                    ; Assume no disk error will occur
1281: FAEB 32 18 FC               LD     (DiskStatus),A
1282: FAEE
1283: FAEE         ;-------------------------Convert selected record into physical sector-----------;
1284: FAEE 3A 0F FC               LD     A,(SelectedRecord)   ;
1285: FAF1 1F                     RRA                         ; Convert selected record                ;
1286: FAF2 1F                     RRA                         ; into physical sector by dividing by 4  ;
1287: FAF3 E6 3F                  AND    03FH                 ; Remove unwanted bits                   ;
1288: FAF5 32 12 FC               LD     (SelectedSector),A   ;
1289: FAF8         ;-------------------------Convert selected record into physical sector-----------;
1290: FAF8
1291: FAF8         ;------------------------- Any Data in Buffer -----------------------------------;
1292: FAF8         ;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes 		 ;
1293: FAF8
1294: FAF8 21 09 FC               LD     HL,DataInBufferFlag  ; See if there is any data here ?        ;
1295: FAFB 7E                     LD     A,(HL)               ;
1296: FAFC 36 FF                  LD     (HL),TRUE            ; Force flag true                        ;
1297: FAFE B7                     OR     A                    ; Was  any data here ?                   ;
1298: FAFF CA 1F FB               JP     Z,SetIOBufferState   ; NO ?- go read into buffer              ;
1299: FB02         ;------------------------- Any Data in Buffer -----------------------------------;
1300: FB02
1301: FB02         ;-----------------------------test for  the sector in the buffer-----------------;
1302: FB02 11 05 FC               LD     DE,IOBufferState     ; get the Buffer Disk and Track          ;
1303: FB05 21 0C FC               LD     HL,SelectedState     ; get the requested Disk and Track       ;
1304: FB08 CD 7B FB               CALL   CompareDkTrk         ; Are they the same ?                    ;
1305: FB0B C2 18 FB               JP     NZ,DataNotInBuffer   ; NO,jump - it must be read 				 ;
1306: FB0E         ;
1307: FB0E         ; Yes, the disk, track are the same are the sectors the same ?                   ;
1308: FB0E         ;
1309: FB0E 3A 08 FC               LD     A,(IOBufferSector)   ; get the sector                         ;
1310: FB11 21 12 FC               LD     HL,SelectedSector    ;
1311: FB14 BE                     CP     M                    ; Check if correct physical sector       ;
1312: FB15 CA 3C FB               JP     Z,DataIsInBuffer     ; Yes - it is already in memory          ;
1313: FB18         ;-----------------------------test for  the sector in the buffer-----------------;
1314: FB18
1315: FB18         ;------------------------- Do we have to write out the buffer ?------------------;
1316: FB18             DataNotInBuffer:                      ;
1317: FB18 3A 0A FC               LD     A,(DirtyBufferFlag)  ;
1318: FB1B B7                     OR     A                    ; do we need to write ?                  ;
1319: FB1C C4 8C FB               CALL   NZ,WritePhysical     ; if yes - write it out                  ;
1320: FB1F         ;------------------------- Do we have to write out the buffer ?------------------;
1321: FB1F
1322: FB1F         ;------------------------- prepare for physical IO ------------------------------;
1323: FB1F             SetIOBufferState:                      ;
1324: FB1F         ; indicate the  selected disk, track, and sector not residing in buffer          ;
1325: FB1F 3A 0C FC               LD     A,(SelectedDisk)     ;
1326: FB22 32 05 FC               LD     (IOBufferDisk),A     ;
1327: FB25 2A 0D FC               LD     HL,(SelectedTrack)   ;
1328: FB28 22 06 FC               LD     (IOBufferTrack),HL   ;
1329: FB2B         ;
1330: FB2B 3A 12 FC               LD     A,(SelectedSector)   ;
1331: FB2E 32 08 FC               LD     (IOBufferSector),A   ;
1332: FB31         ;------------------------- prepare for physical IO ------------------------------;
1333: FB31
1334: FB31         ;------------------------- Read the data if needed, or its already in the buffer -;
1335: FB31 3A 19 FC               LD     A,(PrereadSectorFlag) ; do we need to preread ?                 ;
1336: FB34 B7                     OR     A                    ;
1337: FB35 C4 91 FB               CALL   NZ,ReadPhysical      ; yes - preread the sector                ;
1338: FB38         ;
1339: FB38         ; At this point the data is in the buffer.                                        ;
1340: FB38         ; Either it was already here, or we returned from ReadPhysical                    ;
1341: FB38         ;
1342: FB38 AF                     XOR    A                    ;
1343: FB39 32 0A FC               LD     (DirtyBufferFlag),A  ; Reset the DirtyBufferFlag	          ;
1344: FB3C         ;------------------------- Read the data if needed, or its already in the buffer -;
1345: FB3C
1346: FB3C
1347: FB3C         ; The Buffer now has the data we want to Read/Write
1348: FB3C         ;-------------------------Calculate the address of the record in the sector ------;
1349: FB3C         ;
1350: FB3C             DataIsInBuffer:                      ;
1351: FB3C 3A 0F FC               LD     A,(SelectedRecord)   ;
1352: FB3F E6 03                  AND    SectorMask           ; Want relative record number in Sector   ;
1353: FB41 3C                     INC    A                    ; Adjust for DJNZ                         ;
1354: FB42 47                     LD     B,A                  ;
1355: FB43 11 80 00               LD     DE,cpmRecordSize     ;
1356: FB46 21 80 FF               LD     HL,-cpmRecordSize    ;
1357: FB49             SectorInBuffer1:                      ;
1358: FB49 19                     ADD    HL,DE                ; RecordNumber * recordSize               ;
1359: FB4A 10 FD                  DJNZ   SectorInBuffer1      ;  yields index into the Sector           ;
1360: FB4C         ;
1361: FB4C 11 40 F6               LD     DE,DiskBuffer        ; Start of sector                         ;
1362: FB4F 19                     ADD    HL,DE                ; HL -> start of record in buffer 		  ;
1363: FB50 ED 5B 10 FC               LD     DE,(DMAAddress)      ; Callers  DMA Address                    ;
1364: FB54         ;
1365: FB54         ;-------------------------Calculate the address of the record in the sector ------;
1366: FB54
1367: FB54
1368: FB54         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1369: FB54         ;
1370: FB54 3A 1A FC               LD     A,(ReadWriteFlag)    ; 0 => Write, non Zero => Read            ;
1371: FB57 B7                     OR     A                    ; Write: move data from DMA to Buffer     ;
1372: FB58 C2 60 FB               JP     NZ,BufferMove        ; Read : move data from Buffer to DMA     ;
1373: FB5B         ;
1374: FB5B 3C                     INC    A                    ; Set the flag to indicate dirty buffer   ;
1375: FB5C 32 0A FC               LD     (DirtyBufferFlag),A  ;
1376: FB5F EB                     EX     DE,HL                ; Swap source and destination for write   ;
1377: FB60         ;
1378: FB60         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1379: FB60
1380: FB60
1381: FB60             BufferMove:
1382: FB60 01 80 00               LD     BC,cpmRecordSize
1383: FB63 ED B0                  LDIR                        ; Move data to/from Host Buffer
1384: FB65
1385: FB65 3A 04 FC               LD     A,(WriteType)        ; Is this a write to the directory ?
1386: FB68 FE 01                  CP     WriteDirectory
1387: FB6A 3A 18 FC               LD     A,(DiskStatus)       ; Set ACC with disk status if an immediate return
1388: FB6D C0                     RET    NZ                   ; Return if not updating a directory entry
1389: FB6E
1390: FB6E B7                     OR     A                    ; Check for any disk errors ?
1391: FB6F C0                     RET    NZ                   ; If yes - abandon attempt to write to directory
1392: FB70
1393: FB70 AF                     XOR    A
1394: FB71 32 0A FC               LD     (DirtyBufferFlag),A  ; Clear the dirty buffer flag
1395: FB74 CD 8C FB               CALL   WritePhysical        ; do an immediate update of the directory to disk
1396: FB77 3A 18 FC               LD     A,(DiskStatus)       ; Set ACC with disk status
1397: FB7A C9                     RET
1398: FB7B         ;********************************************************************
1399: FB7B
1400: FB7B
1401: FB7B         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
1402: FB7B             CompareDkTrk:
1403: FB7B 01 03 00               LD     BC,03H
1404: FB7E 18 03                  JR     CompareDkTrkSecLoop
1405: FB80             CompareDkTrkSec:
1406: FB80 01 04 00               LD     BC,04H
1407: FB83             CompareDkTrkSecLoop:
1408: FB83 1A                     LD     A,(DE)               ; Get value
1409: FB84 13                     INC    DE                   ; anticipate next iteration
1410: FB85 ED A1                  CPI                         ; does A = (HL)
1411: FB87 C0                     RET    NZ                   ; Not a match exit
1412: FB88 EA 83 FB               JP     PE,CompareDkTrkSecLoop ; Loop if not done
1413: FB8B C9                     RET
1414: FB8C
1415: FB8C
1416: FB8C         ;************************************************
1417: FB8C         ;			Physical Disk IO					*
1418: FB8C         ;************************************************
1419: FB8C
1420: FB8C         ;Write contents of disk buffer to correct sector
1421: FB8C             WritePhysical:
1422: FB8C 3E 02                  LD     A,DiskWriteCode      ; get write function
1423: FB8E C3 93 FB               JP     CommonPhysical
1424: FB91
1425: FB91             ReadPhysical:
1426: FB91 3E 01                  LD     A,DiskReadCode       ; get read function
1427: FB93
1428: FB93         ; Set up the Dick Control Table DCT
1429: FB93             CommonPhysical:
1430: FB93         ;Command
1431: FB93 32 F7 FB               LD     (DCTCommand),A       ; set the command for Read or Write
1432: FB96         ;Disk
1433: FB96 3A 05 FC               LD     A,(IOBufferDisk)
1434: FB99 E6 03                  AND    03H                  ; only units 0 to 3
1435: FB9B 32 F8 FB               LD     (DCTDisk),A          ; set disk
1436: FB9E         ;Track
1437: FB9E 2A 06 FC               LD     HL,(IOBufferTrack)
1438: FBA1 7D                     LD     A,L                  ; for this controller it is a byte value
1439: FBA2 32 FA FB               LD     (DCTTrack),A         ; set track
1440: FBA5         ;Head and Track	Calculations
1441: FBA5         ; The sector must be converted into a head number and sector number.
1442: FBA5         ;	Head = (int) Sector / SectorsPerHead
1443: FBA5         ;	Sector = Sector MOD SectorsPerHead
1444: FBA5             DetermineHead:
1445: FBA5 06 00                  LD     B,0                  ; Start at head 0
1446: FBA7 21 0B FC               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1447: FBAA 3A 08 FC               LD     A,(IOBufferSector)   ; get target sector
1448: FBAD             DetermineHead1:
1449: FBAD BE                     CP     M                    ; Need another Head?
1450: FBAE DA B6 FB               JP     C,HeadFound          ; nope done with head calculation
1451: FBB1
1452: FBB1 96                     SUB    M                    ; subtract track value
1453: FBB2 04                     INC    B                    ; Increment head
1454: FBB3 C3 AD FB               JP     DetermineHead1       ; loop for next head value
1455: FBB6
1456: FBB6         ;Sector
1457: FBB6             HeadFound:                      ; ACC now has Sector MOD SectorsPerHead
1458: FBB6 3C                     INC    A                    ; physical sectors start at 1
1459: FBB7 32 FB FB               LD     (DCTSector),A        ; set sector
1460: FBBA         ;Head
1461: FBBA 78                     LD     A,B
1462: FBBB 32 F9 FB               LD     (DCTHead),A          ; set head number
1463: FBBE         ;Byte Count
1464: FBBE 21 00 02               LD     HL,diskSectorSize
1465: FBC1 22 FC FB               LD     (DCTByteCount),HL    ; set byte count
1466: FBC4         ;DMA
1467: FBC4 21 40 F6               LD     HL,DiskBuffer
1468: FBC7 22 FE FB               LD     (DCTDMAAddress),HL   ; set transfer address
1469: FBCA
1470: FBCA         ; Since only one control table is in use, close the status and busy chain pointers
1471: FBCA         ; back to the main control bytes
1472: FBCA         ;NextStatusBlock
1473: FBCA 21 43 00               LD     HL,DiskStatusLocation
1474: FBCD 22 00 FC               LD     (DCTNextStatusBlock),HL
1475: FBD0         ;NextControlLocation
1476: FBD0 21 45 00               LD     HL,DiskControlByte
1477: FBD3 22 02 FC               LD     (DCTNextControlLocation),HL
1478: FBD6
1479: FBD6         ;Put  DCT pointer in page0
1480: FBD6 21 F7 FB               LD     HL,DCTCommand
1481: FBD9 22 46 00               LD     (DiskCommandBlock),HL
1482: FBDC         ; Make the IO happen
1483: FBDC 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1484: FBDF 36 80                  LD     (HL),080H
1485: FBE1
1486: FBE1         ;Wait until Disk Status Block indicates the operation is complete,
1487: FBE1             WaitForDiskComplete:
1488: FBE1 7E                     LD     A,(HL)               ; get control bytes
1489: FBE2 B7                     OR     A
1490: FBE3 C2 E1 FB               JP     NZ,WaitForDiskComplete ; operation not done
1491: FBE6
1492: FBE6
1493: FBE6         ;Check if any errors occurred.
1494: FBE6 3A 43 00               LD     A,(DiskStatusLocation)
1495: FBE9 DA F1 FB               JP     C,DiskError
1496: FBEC AF                     XOR    A
1497: FBED 32 18 FC               LD     (DiskStatus),A       ; clear the flag
1498: FBF0 C9                     RET
1499: FBF1
1500: FBF1         ; set error flag and return
1501: FBF1             DiskError:
1502: FBF1 3E 01                  LD     A,1
1503: FBF3 32 18 FC               LD     (DiskStatus),A       ; set the error flag
1504: FBF6 C9                     RET
1505: FBF7
1506: FBF7         ;********************************************************************
1507: FBF7         ;********************************************************************
1508: FBF7         ;********************************************************************
1509: FBF7
1510: FBF7         ;---------------------------------------------------------------------------
1511: FBF7         ;	Disk Data
1512: FBF7         ;---------------------------------------------------------------------------
1513: FBF7         ;	Disk Equates
1514: FBF7         ;---------------------------------------------------------------------------
1515: FBF7         ; Disk Types
1516: FBF7         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1517: FBF7         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1518: FBF7         ;;HardDisk	EQU	2						; hard disk
1519: FBF7         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1520: FBF7
1521: FBF7
1522: FBF7         ;**************************************************************************************************
1523: FBF7         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1524: FBF7         ;
1525: FBF7         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1526: FBF7         ; perform some disk operation.  These are called its disk control byte.
1527: FBF7         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1528: FBF7         ; following the respective control bytes. This word must contain the address of  valid disk control
1529: FBF7         ; table that specifies the exact disk operation to be performed.
1530: FBF7         ;
1531: FBF7         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1532: FBF7         ; This indicates completion to the disk driver code.
1533: FBF7         ;
1534: FBF7         ;  The controller also sets a return code in a disk status block - location 0X43H.
1535: FBF7         ; If the first byte of this status block is less than 80H. then a disk error
1536: FBF7         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1537: FBF7         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1538: FBF7         ; ten times before the controller returns an error
1539: FBF7         ;
1540: FBF7         ;  The disk control table layout is shown below. Note that the controller has the capability
1541: FBF7         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1542: FBF7         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1543: FBF7         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1544: FBF7         ; the end of the chain
1545: FBF7         ;**************************************************************************************************
1546: FBF7
1547: FBF7         ;***************************************************************************
1548: FBF7         ;	Disk Control tables
1549: FBF7         ;***************************************************************************
1550: FBF7         ;;DiskControlTable:
1551: FBF7             DCTStart:
1552: FBF7 00          DCTCommand: DB     00H                  ; Command
1553: FBF8 00          DCTDisk:   DB     00H                  ; unit (drive) number = 0 or 1
1554: FBF9 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1555: FBFA 00          DCTTrack:  DB     00H                  ; track number
1556: FBFB 00          DCTSector: DB     00H                  ; sector number
1557: FBFC 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1558: FBFE 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1559: FC00 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1560: FC02 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1561: FC04             DCTEnd:
1562: FC04             DCTSize    EQU    DCTEnd-DCTStart
1563: FC04         ;-----------------------------------------
1564: FC04         ;WriteAllocated		EQU	00H		W_NORMAL
1565: FC04         ;WriteDirectory		EQU	01H		W_DIRECTORY
1566: FC04         ;WriteCleanBuffer	EQU	02H		W_NEW_BLOCK
1567: FC04         ;-----------------------------------------
1568: FC04
1569: FC04 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1570: FC05
1571: FC05         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1572: FC05             IOBufferState:
1573: FC05 00          IOBufferDisk: DB     00H
1574: FC06 00 00       IOBufferTrack: DW     00H
1575: FC08 00          IOBufferSector: DB     00H
1576: FC09 00          DataInBufferFlag: DB     00H                  ; when non-zero, the disk buffer has data from disk
1577: FC0A 00          DirtyBufferFlag: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1578: FC0B         ;   but not yet written out to the disk
1579: FC0B         ;---------------------------------------------------------------------------
1580: FC0B         ;	Disk Storage area
1581: FC0B         ;---------------------------------------------------------------------------
1582: FC0B         ;     variables for selected disk, track and sector
1583: FC0B         ; These are moved and compared as a group, DO NOT ALTER
1584: FC0B
1585: FC0B 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1586: FC0C
1587: FC0C             SelectedState:
1588: FC0C 00          SelectedDisk: DB     00H
1589: FC0D 00 00       SelectedTrack: DW     0000H
1590: FC0F 00          SelectedRecord: DB     00H
1591: FC10
1592: FC10             SelectedDiskStateEnd:
1593: FC10             SelectedDiskStateSize EQU    SelectedDiskStateEnd - SelectedDisk
1594: FC10
1595: FC10 00 00       DMAAddress: DW     0000H                ; DMA address
1596: FC12
1597: FC12 00          SelectedSector: DB     00H
1598: FC13
1599: FC13         ; Parameters for the records in the Fresh Allocation Block
1600: FC13         ; These are moved and compared as a group, DO NOT ALTER
1601: FC13
1602: FC13             HostBufferState:
1603: FC13 00          HostBufferDisk: DB     00H
1604: FC14 00 00       HostBufferTrack: DW     0000H
1605: FC16 00          HostBufferRecord: DB     00H
1606: FC17
1607: FC17 00          ModifiedlRecordsCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1608: FC18 00          DiskStatus: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1609: FC19         ; Flags used inside the de-blocking code
1610: FC19 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1611: FC1A         ; either before a write to a allocated block can occur, or
1612: FC1A         ; for a normal cpmRecord read
1613: FC1A 00          ReadWriteFlag: DB     00H                  ; 0 => Write-  Non-zero =>read
1614: FC1B
1615: FC1B         ;---------------------------------------------------------------------------
1616: FC1B
1617: FC1B         ;---------------------------------------------------------------------------
1618: FC1B         ;	Disk Definition Tables
1619: FC1B         ; These consists of disk parameter headers, with one entry
1620: FC1B         ; per logical disk driver, and disk parameter blocks, with
1621: FC1B         ; either one parameter block per logical disk or the same
1622: FC1B         ; parameter block for several logical disks.
1623: FC1B         ;---------------------------------------------------------------------------
1624: FC1B         ;---------------------------------------------------------------------------
1625: FC1B             DiskParameterHeaders:
1626: FC1B
1627: FC1B         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1628: FC1B 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1629: FC1D 00 00                  DW     0000H                ; Rel pos for file (0-3)
1630: FC1F 00 00                  DW     0000H                ; Last Selected Track #
1631: FC21 00 00                  DW     0000H                ; Last Selected Sector #
1632: FC23 4F FE                  DW     DirectoryBuffer      ; all disks use this buffer
1633: FC25 5B FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1634: FC27 6B FC                  DW     DiskAWorkArea
1635: FC29 EB FC                  DW     DiskAAllocationVector
1636: FC2B
1637: FC2B         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1638: FC2B 00 00                  DW     0000H                ; No Skew table
1639: FC2D 00 00                  DW     0000H                ; Rel pos for file (0-3)
1640: FC2F 00 00                  DW     0000H                ; Last Selected Track #
1641: FC31 00 00                  DW     0000H                ; Last Selected Sector #
1642: FC33 4F FE                  DW     DirectoryBuffer      ; all disks use this buffer
1643: FC35 5B FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1644: FC37 8B FC                  DW     DiskBWorkArea
1645: FC39 44 FD                  DW     DiskBAllocationVector
1646: FC3B
1647: FC3B         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1648: FC3B 00 00                  DW     0000H                ; No Skew table
1649: FC3D 00 00                  DW     0000H                ; Rel pos for file (0-3)
1650: FC3F 00 00                  DW     0000H                ; Last Selected Track #
1651: FC41 00 00                  DW     0000H                ; Last Selected Sector #
1652: FC43 4F FE                  DW     DirectoryBuffer      ; all disks use this buffer
1653: FC45 5B FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1654: FC47 AB FC                  DW     DiskCWorkArea
1655: FC49 9D FD                  DW     DiskCAllocationVector
1656: FC4B
1657: FC4B         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1658: FC4B 00 00                  DW     0000H                ; No Skew table
1659: FC4D 00 00                  DW     0000H                ; Rel pos for file (0-3)
1660: FC4F 00 00                  DW     0000H                ; Last Selected Track #
1661: FC51 00 00                  DW     0000H                ; Last Selected Sector #
1662: FC53 4F FE                  DW     DirectoryBuffer      ; all disks use this buffer
1663: FC55 5B FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1664: FC57 CB FC                  DW     DiskDWorkArea
1665: FC59 F6 FD                  DW     DiskDAllocationVector
1666: FC5B
1667: FC5B
1668: FC5B         ;-----------------------------------------------------------
1669: FC5B
1670: FC5B             ParameterBlock3HD:
1671: FC5B 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1672: FC5D 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1673: FC5E 0F                     DB     dpb3hdBLM            ; Block mask
1674: FC5F 00                     DB     dpb3hdEXM            ; Extent mask
1675: FC60 C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1676: FC62 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1677: FC64 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1678: FC65 00                     DB     dpb3hdAL1            ;  for file directory
1679: FC66 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1680: FC68 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1681: FC6A
1682: FC6A 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1683: FC6B
1684: FC6B
1685: FC6B
1686: FC6B         ;---------------------------------------------------------------------------
1687: FC6B         ;	Disk work area
1688: FC6B         ;---------------------------------------------------------------------------
1689: FC6B         ; These are used by the BDOS to detect any unexpected
1690: FC6B         ; change of diskette. The BDOS will automatically set
1691: FC6B         ; such a changed diskette to read-only status.
1692: FC6B
1693: FC6B             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1694: FC8B             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1695: FCAB             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1696: FCCB             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1697: FCEB
1698: FCEB         ;---------------------------------------------------------------------------
1699: FCEB         ;	Disk allocation vectors
1700: FCEB         ;---------------------------------------------------------------------------
1701: FCEB         ; Disk allocation vectors
1702: FCEB         ; These are used by the BDOS to maintain a bit map of
1703: FCEB         ; which allocation blocks are used and which are free.
1704: FCEB         ; One byte is used for eight allocation blocks, hence the
1705: FCEB         ; expression of the form (allocation blocks/8)+1
1706: FCEB
1707: FCEB             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1708: FD44             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1709: FD9D
1710: FD9D             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1711: FDF6             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1712: FE4F         ;---------------------------------------------------------------------------
1713: FE4F         ;	Disk Buffer
1714: FE4F         ;---------------------------------------------------------------------------
1715: FE4F             DirectoryBuffer: DS     DirBuffSize
           ************************   Xref   ************************
0000: $               FE4F   0323 0376
0824: AddressDataIn   F9DC   0822
0839: AddressDataOut  F9EC   0836
0849: AddressStatus   F9F5   0847
0327: AfterDiskBuffer F840
0090: ASCII_A         0041
0091: ASCII_C         0043
0092: ASCII_K         004B
0099: ASCII_LO_A      0061
0100: ASCII_LO_K      006B
0101: ASCII_LO_P      0070
0042: ASCII_MASK      007F   0830
0093: ASCII_N         004E
0094: ASCII_Q         0051
0095: ASCII_R         0052
0096: ASCII_W         0057
0097: ASCII_Y         0059
0077: ASCII_ZERO      0030
0071: ASTERISK        002A
0156: BDOSBase        E800   0157 0159
0125: BDOSE           0005   0126 0596 0598
0157: BDOSEntry       E806   0429 0597
0146: BDOSLength      0E00   0149 0159 0160 0615
0060: BELL            0007
0159: BIOSBase        F600
0147: BIOSLength      0A00   0149
0119: BIOSPAGE        0002
0160: BIOSStart       F600   0299 0371 0403 0417
0256: BlockSize       0800   0278
0356: BOOT            F840   0303
0369: BOOT_CON_ADDRESS 00EC   0459
0410: BootControl     F86F   0387
0438: BootMessage     F8B7   0453
1381: BufferMove      FB60   1372
0038: BYTE            0001
0098: CARET           005E
0154: CCPEntry        E000   0156 0160 0578 0606 0616
0145: CCPLength       0800   0149 0156 0160 0615
1265: CheckDirtyBuffer FAD8   1257
0301: CodeStart       F600
0078: COLON           003A
0892: COM_DataPort    00EC   0936
0894: COM_InputMask   0002   0938
0893: COM_OutputMask  0001   0937
0891: COM_StatusPort  00ED   0935
0934: COM_Table       FA24   0966 0976
0073: COMMA           002C
1279: CommonDiskIO    FAEA   1203
1429: CommonPhysical  FB93   1423
1402: CompareDkTrk    FB7B   1304
1405: CompareDkTrkSec FB80   1269
1407: CompareDkTrkSecLoop FB83   1404 1412
0131: ComTail         0080   0132
0133: ComTailChars    0082
0132: ComTailCount    0081   0133
0963: CON_Vector      FA42   0637 0681
0659: ConIn           F963   0661
0658: CONIN           F963   0307
0678: CONOUT          F96F   0308
0679: CONOut          F96F
0634: CONST           F951   0306
0635: ConStatus       F951   0660
0233: cpmRecordSize   0080   0235 0238 0240 1355 1356 1382
0063: CR              000D   0439 0445 0448 0450
0887: CRT_DataPort    0001   0928
0889: CRT_InputMask   007F   0930
0888: CRT_OutputMask  0080   0929
0886: CRT_StatusPort  0002   0927
0926: CRT_Table       FA1A   0965 0970 0977 0980
0046: CTRL_C          0003
0047: CTRL_E          0005
0048: CTRL_H          0008
0049: CTRL_K          000B
0050: CTRL_L          000C
0051: CTRL_P          0010
0052: CTRL_R          0012
0053: CTRL_S          0013
0054: CTRL_U          0015
0055: CTRL_X          0018
0056: CTRL_Z          001A
0074: DASH            002D
0267: DataBlocks      02C7   0277
1576: DataInBufferFlag FC09   1032 1294
1350: DataIsInBuffer  FB3C   1312
1316: DataNotInBuffer FB18   1305
0908: DataPortIndex   0001   0821 0835
0820: DataRead        F9D5   0829 0932 0940 0948
0828: DataReadASCII   F9DE   0923
0912: DataReadIndex   0006   0663 0664 0764 0765
0266: DataSectors     0B1C   0267
0834: DataWrite       F9E4   0924 0933 0941 0949
0913: DataWriteIndex  0008   0688 0689
1557: DCTByteCount    FBFC   1465
1552: DCTCommand      FBF7   1431 1480
1553: DCTDisk         FBF8   1435
1558: DCTDMAAddress   FBFE   1468
1561: DCTEnd          FC04   1562
1554: DCTHead         FBF9   1462
1560: DCTNextControlLocation FC02   1477
1559: DCTNextStatusBlock FC00   1474
1556: DCTSector       FBFB   1459
1562: DCTSize         000D
1551: DCTStart        FBF7   1562
1555: DCTTrack        FBFA   1439
0427: DefaultDisk     F880
1444: DetermineHead   FBA5
1448: DetermineHead1  FBAD   1454
0238: DirBuffSize     0080   1715
0253: DirectoryBlockCount 0002   0278
1715: DirectoryBuffer FE4F   1632 1642 1652 1662
0240: DirectoryEntryPerRecord 0004   0281
0237: DirEntrySize    0020   0240 0278
1577: DirtyBufferFlag FC0A   1029 1317 1343 1375 1394
1707: DiskAAllocationVector FCEB   1635
1693: DiskAWorkArea   FC6B   1634
1708: DiskBAllocationVector FD44   1645
0325: DiskBuffer      F640   1361 1467
1694: DiskBWorkArea   FC8B   1644
1710: DiskCAllocationVector FD9D   1655
0225: DiskCommandBlock 0046   0388 1481
0224: DiskControlByte 0045   0391 0618 1476 1483
0227: DiskControlTable 0040   0419
1695: DiskCWorkArea   FCAB   1654
1711: DiskDAllocationVector FDF6   1665
1696: DiskDWorkArea   FCCB   1664
1501: DiskError       FBF1   1495
1625: DiskParameterHeaders FC1B   1069
0229: DiskReadCode    0001   0411 0610 1426
0234: diskSectorSize  0200   0235 0256 0264 0326 1464
1608: DiskStatus      FC18   1281 1387 1396 1497 1503
0223: DiskStatusLocation 0043   0399 0418 0617 1473 1494
0230: DiskWriteCode   0002   1422
1595: DMAAddress      FC10   1136 1363
0136: DMABuffer       0080   0600
0067: DOLLAR          0024
0279: dpb3hdAL0       00C0   1677
0280: dpb3hdAL1       0000   1678
0275: dpb3hdBLM       000F   1673
0274: dpb3hdBSH       0004   1672
0281: dpb3hdCKS       0020   1679 1693 1694 1695 1696
0278: dpb3hdDRM       007F   0281 1676
0277: dpb3hdDSM       02C6   1675 1707 1708 1710 1711
0276: dpb3hdEXM       0000   1674
0283: dpb3hdNOH       0002   1682
0282: dpb3hdOFF       0001   1680
0273: dpb3hdSPT       0090   1671 1682
0902: DUMMY_DataPort  0010   0952
0904: DUMMY_InputMask 007F   0954
0903: DUMMY_OutputMask 00FF   0953
0901: DUMMY_StatusPort 0011   0951
0950: DUMMY_Table     FA38   0967 0971 0972 0975 0982
0858: DUMMYCheck      F9FA   0955
0854: DUMMYRead       F9F8   0956
0856: DUMMYWrite      F9F9   0957
0140: END_OF_FILE     001A
0044: EndOfMessage    0000   0445 0450
0082: EQUAL_SIGN      003D
0065: EXCLAIM_POINT   0021
0447: FailedBootMessage F8D5   0405
0033: FALSE           0000
0128: FCB1            005C   0129
0129: FCB2            006C
0173: fCloseFile      0010
0164: fConsoleIn      0001
0165: fConsoleOut     0002
0176: fDeleteFile     0013
0168: fGetConsoleStatus 000B
0182: fGetCurrentDisk 0019
0181: fGetLoginVector 0018
0184: fGetSetUserNumber 0020
0169: fGetVersion     000C
0179: fMakeFile       0016
0172: fOpenFile       000F
0166: fPrintString    0009
0177: fReadSeq        0014
0167: fReadString     000A
0180: fRenameFile     0017
0170: fResetSystem    000D
0174: fSearchFirst    0011
0175: fSearchNext     0012
0171: fSelectDisk     000E
0183: fSetDMA         001A
0178: fWriteSeq       0015
0639: GenericInStatus F958   0761
0683: GenericOutStatus F976   0708 0737
0685: GenericOutStatus1 F979   0687
0811: GetInStatus     F9CB   0641
0807: GetOutStatus    F9C6   0686 0797
0813: GetStatus       F9CE   0810
0083: GREATER_THAN    003E
0066: HASH_TAG        0023
1457: HeadFound       FBB6   1450
1028: HOME            FA62   0312
1033: HomeNoWrite     FA6B   1031
1603: HostBufferDisk  FC13
1605: HostBufferRecord FC16
1602: HostBufferState FC13   1261 1268
1604: HostBufferTrack FC14
0294: IN_OPCODE       00DB   0823 0848
0910: InputMaskIndex  0003   0812
1573: IOBufferDisk    FC05   1326 1433
1575: IOBufferSector  FC08   1309 1331 1447
1572: IOBufferState   FC05   1302
1574: IOBufferTrack   FC06   1328 1437
0120: IOBYTE          0003   0636 0680 0704 0731 0756 0792
0370: IOBYTE_DEFAULT  0080   0426
0296: JP_OPCODE       00C3   0590
0069: L_PAREN         0028
0086: LEFT_ARROW      005F
0102: LEFT_CURLY      007B
0149: LengthInBytes   2000   0150 0154 0264
0150: LengthInK       0009
0081: LESS_THAN       003C
0062: LF              000A   0439 0445 0448 0450
0703: LIST            F985   0309
0791: LISTST          F9B2   0319
0036: LO_NIBBLE_MASK  000F
0589: LoadPage0       F922   0581
0897: LPT_DataPort    0010   0944
0899: LPT_InputMask   007F   0946
0898: LPT_OutputMask  00FF   0945
0896: LPT_StatusPort  0011   0943
0942: LPT_Table       FA2E   0979 0981
0978: LST_Vector      FA5A   0707 0795
0152: MemorySize      0040   0154
1607: ModifiedlRecordsCount FC17   1197
0265: myOffset        0001   0266 0282
0058: NULL            0000
0249: NumberOfHeads   0002   0260 0262 0273 0283
0246: NumberOfLogicalDisks 0004   1058
0035: OFF             0000
0034: ON              FFFF
0295: OUT_OPCODE      00D3   0838
0909: OutputMaskIndex 0002   0809
0423: Page0Image      F87C   0378 0379
0433: Page0ImageEnd   F8B7   0378
1670: ParameterBlock3HD FC5B   1633 1643 1653 1663
0068: PERCENT         0025
0075: PERIOD          002E
0123: Pg0CurentDisk   0004   0604
0122: Pg0CurentUser   0004   0123
0072: PLUS_SIGN       002B
1610: PrereadSectorFlag FC19   1200 1275 1335
0973: PUN_Vector      FA52   0736
0730: PUNCH           F990   0310
0084: QMARK           003F
0070: R_PAREN         0029
0116: RAM             0000   0118 0119 0120 0122 0125 0128 0131 0136 0138
0968: RDR_Vector      FA4A   0759
1195: READ            FAAD   0317
0755: READER          F99D   0311
0760: READER1         F9A6   0762
1425: ReadPhysical    FB91   1337
1613: ReadWriteFlag   FC1A   1199 1252 1370
0258: RecordsPerBlock 0010
0242: RecordsPerExtent 0080
0235: recordsPerSector 0004   0258 0273
0087: RUBOUT          007F
1357: SectorInBuffer1 FB49   1359
0287: SectorMask      0003   1352
0252: SectorsPerBlock 0004   0256 0258 0261 0267 0287
0262: SectorsPerCylinder 0024   0265 0266
0251: SectorsPerTrack 0012   0260 0262 0273
1156: SECTRAN         FAAA   0320
1055: SELDSK          FA71   0313
1588: SelectedDisk    FC0C   1061 1325 1593
1592: SelectedDiskStateEnd FC10   1593
1593: SelectedDiskStateSize 0004   1262
1585: SelectedDskSecsPerHead FC0B   1079 1446
1590: SelectedRecord  FC0F   1122 1284 1351
1597: SelectedSector  FC12   1288 1310 1330
1587: SelectedState   FC0C   1260 1267 1303
1589: SelectedTrack   FC0D   1102 1327
0080: SEMICOLON       003B
0452: SendBootMessage F902   0377
0455: SendMessage     F905   0406 0461
0864: SetDeviceVector F9FE   0640 0684 0796
1135: SETDMA          FAA5   0316 0601
1323: SetIOBufferState FB1F   1298
1274: SetPreread      FAE7   1271
1120: SETSEC          FAA0   0315
1098: SETTRK          FA9B   0314 1035
0076: SLASH           002F
0059: SOH             0001
0064: SPACE           0020
0375: Start           F840
0907: StatusPortIndex 0000   0846
0845: StatusRead      F9EE   0922 0931 0939 0947
0911: StatusReadIndex 0004   0814 0815
0264: SystemSectors   0011   0265
0061: TAB             0009
0126: TopRAM          0007
0261: TotalNumberOfBlocks 02D0
0260: TotalNumberOfSectors 0B40   0261 0266
0138: TPA             0100
0250: TracksPerHead   0050   0260
0032: TRUE            FFFF   1270 1296
0882: TTY_DataPort    00EC   0919
0884: TTY_InputMask   007F   0921
0883: TTY_OutputMask  0080   0920
0881: TTY_StatusPort  00ED   0918
0917: TTY_Table       FA10   0964 0969 0974
0085: UNDER_SCORE     005F
0394: WaitForBootComplete F85C   0397
1487: WaitForDiskComplete FBE1   1490
0118: WarmBoot        0000   0592 0594
0304: WarmBootEntry   F603   0424 0593
0577: WBOOT           F90E   0305 0585
0609: WBOOTControl    F944   0579
0039: WORD            0002
1249: WRITE           FAC0   0318
0198: WriteAllocated  0000
0200: WriteCleanBuffer 0002   1201 1256
0199: WriteDirectory  0001   1386
1421: WritePhysical   FB8C   1319 1395
1569: WriteType       FC04   1202 1254 1385
0043: ZERO            0000
