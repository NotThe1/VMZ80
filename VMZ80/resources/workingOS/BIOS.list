0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018 12-11 Adjusted BOOT & WBOOT
0006: F600         ; 2018-12-10 Refactored  character device routines;
0007: F600         ; 2017-03-31 Added List out functionality for List Device
0008: F600         ; 2017-03-02 Refactored the CP/M Suite
0009: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0010: F600         ; 2014-01-16
0011: F600         ; 2014-03-14  :  Frank Martyn
0012: F600
0013: F600         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0014: F600         ; by Andy Johnson-Laird
0015: F600         ;
0016: F600         ; Published by
0017: F600         ; Osborne/McGraw-Hill
0018: F600         ; 2600 Tenth Street
0019: F600         ; Berkeley, California 94710
0020: F600         ; U.S.A.
0021: F600
0022: F600                        Include ./stdHeader.Z80
0023: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0024: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0025: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0026: F600         ; stdHeader.asm
0027: F600         ; standard equates
0028: F600
0029: F600         ; 2017-03-02 Refactored the CP/M Suite
0030: F600
0031: F600
0032: F600             TRUE       EQU    -1                   ; not false
0033: F600             FALSE      EQU    0000H
0034: F600             ON         EQU    -1
0035: F600             OFF        EQU    0000H
0036: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0037: F600
0038: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0039: F600             WORD       EQU    2                    ; number of bytes for "word" type
0040: F600
0041: F600
0042: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0043: F600             ZERO       EQU    00H                  ; Zero
0044: F600             EndOfMessage EQU    00H
0045: F600
0046: F600             CTRL_C     EQU    03H                  ; ETX
0047: F600             CTRL_E     EQU    05H                  ; physical eol
0048: F600             CTRL_H     EQU    08H                  ; backspace
0049: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0050: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0051: F600             CTRL_P     EQU    10H                  ; prnt toggle
0052: F600             CTRL_R     EQU    12H                  ; repeat line
0053: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0054: F600             CTRL_U     EQU    15H                  ; line delete
0055: F600             CTRL_X     EQU    18H                  ; =ctl-u
0056: F600             CTRL_Z     EQU    1AH                  ; end of file
0057: F600
0058: F600             NULL       EQU    00H                  ; Null
0059: F600             SOH        EQU    01H                  ; Start of Heading
0060: F600             BELL       EQU    07H                  ; Bell
0061: F600             TAB        EQU    09H                  ; Tab
0062: F600             LF         EQU    0AH                  ; Line Feed
0063: F600             CR         EQU    0DH                  ; Carriage Return
0064: F600             SPACE      EQU    20H                  ; Space
0065: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0066: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0067: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0068: F600             PERCENT    EQU    25H                  ; Percent Sign
0069: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0070: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0071: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0072: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0073: F600             COMMA      EQU    2CH                  ; Comma
0074: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0075: F600             PERIOD     EQU    2EH                  ; Period
0076: F600             SLASH      EQU    2FH                  ; /
0077: F600             ASCII_ZERO EQU    30H                  ; zero
0078: F600             COLON      EQU    3AH                  ; Colon
0079: F600
0080: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0081: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0082: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0083: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0084: F600             QMARK      EQU    3FH                  ; Question Mark
0085: F600             UNDER_SCORE EQU    5FH                  ; under score _
0086: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0087: F600             RUBOUT     EQU    7FH                  ; Delete Key
0088: F600
0089: F600
0090: F600             ASCII_A    EQU    'A'
0091: F600             ASCII_C    EQU    'C'
0092: F600             ASCII_K    EQU    'K'
0093: F600             ASCII_N    EQU    'N'
0094: F600             ASCII_Q    EQU    'Q'
0095: F600             ASCII_R    EQU    'R'
0096: F600             ASCII_W    EQU    'W'
0097: F600             ASCII_Y    EQU    'Y'
0098: F600             CARET      EQU    '^'
0099: F600             ASCII_LO_A EQU    'a'
0100: F600             ASCII_LO_K EQU    'k'
0101: F600             ASCII_LO_P EQU    'p'
0102: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0103: F600
0104: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0105: F600                        Include ./osHeader.Z80
0106: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0107: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0108: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0109: F600         ; osHeader.asm
0110: F600
0111: F600         ; 2017-03-02 Refactored the CP/M Suite
0112: F600
0113: F600         ; Contains the Equates used by the CP/M system
0114: F600
0115: F600         ;------------------------Page Zero Constants ---------------------------------
0116: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0117: F600
0118: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0119: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0120: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0121: F600
0122: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0123: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0124: F600
0125: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0126: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0127: F600
0128: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0129: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0130: F600
0131: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0132: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0133: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0134: F600         ;-----------------------------------------------------------------------
0135: F600
0136: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0137: F600         ;-----------------------------------------------------------------------
0138: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0139: F600         ;-----------------------------------------------------------------------
0140: F600             END_OF_FILE EQU    1AH                  ; end of file
0141: F600         ;-----------------------------------------------------------------------
0142: F600
0143: F600         ;--------------- CP/M Constants -----------------------------------------
0144: F600
0145: F600             CCPLength  EQU    0800H                ; Constant
0146: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0147: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0148: F600
0149: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0150: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0151: F600
0152: F600             MemorySize EQU    64
0153: F600
0154: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0155: F600
0156: F600             BDOSBase   EQU    CCPEntry + CCPLength
0157: F600             BDOSEntry  EQU    BDOSBase + 6
0158: F600
0159: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0160: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0161: F600         ;-----------------------------------------------------------------------
0162: F600
0163: F600         ;------------------- BDOS System Call Equates --------------------------
0164: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0165: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0166: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0167: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0168: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0169: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0170: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0171: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0172: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0173: F600             fCloseFile EQU    10H                  ; closef - Close File
0174: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0175: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0176: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0177: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0178: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0179: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0180: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0181: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0182: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0183: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0184: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0185: F600         ;-----------------------------------------------------------------------
0186: F600
0187: F600
0188: F600
0189: F600
0190: F600
0191: F600         ;*******************************************************************************
0192: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0193: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0194: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0195: F600         ; sector write) or to an allocation block that has already been allocated to a
0196: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0197: F600         ;*******************************************************************************
0198: F600             WriteAllocated EQU    00H
0199: F600             WriteDirectory EQU    01H
0200: F600             WriteCleanBuffer EQU    02H
0201: F600
0202: F600
0203: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0204: F600                        Include ./diskHeader.Z80
0205: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0206: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0207: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0208: F600         ; diskHeader.asm
0209: F600
0210: F600         ; 2017-03-02 Refactored the CP/M Suite
0211: F600
0212: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0213: F600
0214: F600         ; Contains the Equates used by the CP/M system to handle disks
0215: F600
0216: F600
0217: F600         ;*******************************************************************************
0218: F600         ;
0219: F600         ;     Disk related values
0220: F600         ;
0221: F600         ;
0222: F600         ;*******************************************************************************
0223: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0224: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0225: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0226: F600         ; for boot
0227: F600             DiskControlTable EQU    0040H
0228: F600
0229: F600             DiskReadCode EQU    01H                  ; Code for Read
0230: F600             DiskWriteCode EQU    02H                  ; Code for Write
0231: F600
0232: F600
0233: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0234: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0235: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0236: F600
0237: F600             DirEntrySize EQU    20H                  ; (32)
0238: F600             DirBuffSize EQU    cpmRecordSize
0239: F600
0240: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0241: F600
0242: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0243: F600
0244: F600
0245: F600         ;-------------------------------------------------------------------------------------
0246: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0247: F600
0248: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0249: F600             NumberOfHeads EQU    02H                  ; number of heads
0250: F600             TracksPerHead EQU    50H                  ; 80
0251: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0252: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0253: F600             DirectoryBlockCount EQU    02H                  ;
0254: F600         ;-----------------------------------------------------------------------
0255: F600
0256: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0257: F600
0258: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0259: F600
0260: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0261: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0262: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0263: F600
0264: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0265: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0266: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0267: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0268: F600
0269: F600         ;-----------------------------------------------------------------------
0270: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0271: F600         ;-----------------------------------------------------------------------
0272: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0273: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0274: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0275: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0276: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0277: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0278: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0279: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0280: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0281: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0282: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0283: F600             dpb3hdNOH  EQU    NumberOfHeads
0284: F600
0285: F600         ;*******************************************************************************
0286: F600
0287: F600             SectorMask EQU    SectorsPerBlock - 1
0288: F600
0289: F600         ;***************************************************************************
0290: F600
0291: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0292: F600
0293: F600             BOOT_CON_ADDRESS EQU    0ECH                 ; tty data address
0294: F600
0295: F600             IN_OPCODE  EQU    0DBH
0296: F600             OUT_OPCODE EQU    0D3H
0297: F600             JP_OPCODE  EQU    0C3H
0298: F600
0299: F600
0300: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0301: F600         ; BIOS jump Vector
0302: F600             CodeStart:
0303: F600
0304: F600 C3 40 F8               JP     BOOT                 ; 00 Cold/Hard Boot
0305: F603             WarmBootEntry:
0306: F603 C3 AC F8               JP     WBOOT                ; 01 Warm/Soft Boot
0307: F606 C3 EF F8               JP     CONST                ; 02 Get Console Status - CON:
0308: F609 C3 01 F9               JP     CONIN                ; 03 Get Character from Console - CON:
0309: F60C C3 0D F9               JP     CONOUT               ; 04 Send Character to Console - CON:
0310: F60F C3 23 F9               JP     LIST                 ; 05 Send Character to List device - LST:
0311: F612 C3 2E F9               JP     PUNCH                ; 06 Send Character to Punch device - PUN:
0312: F615 C3 3B F9               JP     READER               ; 07 Get Character from Reader - RDR:
0313: F618 C3 00 FA               JP     HOME                 ; 08 Position the disk to absolute track 00
0314: F61B C3 0F FA               JP     SELDSK               ; 09 Establish disk to be used by subsequent Read/Write
0315: F61E C3 39 FA               JP     SETTRK               ; 0A Establish track to be used by subsequent Read/Write
0316: F621 C3 3E FA               JP     SETSEC               ; 0B Establish sector to be used by subsequent Read/Write
0317: F624 C3 43 FA               JP     SETDMA               ; 0C Establish buffer location to be used by subsequent Read/Write
0318: F627 C3 4B FA               JP     READ                 ; 0D Not Yet Checked
0319: F62A C3 5E FA               JP     WRITE                ; 0E Not Yet Checked
0320: F62D C3 50 F9               JP     LISTST               ; 0F Get List device Status - LST:
0321: F630 C3 48 FA               JP     SECTRAN              ; 10 De-skew sector number (null implementation)
0322: F633
0323: F633         ;-------------------------------------------------
0324: F633                        ORG    (($+10H)/10H) * 10H
0325: F640
0326: F640             DiskBuffer:
0327: F640                        DS     diskSectorSize
0328: F840             AfterDiskBuffer EQU    $
0329: F840         ;-------------------------------------------------
0330: F840
0331: F840
0332: F840
0333: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0334: F840
0335: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0336: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0337: F840         ;---------------------------------------------------------------------------
0338: F840         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot
0339: F840
0340: F840         ;  The BOOT jump instruction is the first instruction executed in CP/M. The
0341: F840         ; bootstrap sequence must transfer control to the BOOT entry point in order to
0342: F840         ; bring up CP/M.
0343: F840         ;  This reads in the CP/M loader on the first sector of the physical disk drive
0344: F840         ; chosen to be logical disk A. This CP/M loader program reads the binary image
0345: F840         ; of the CCP, BOOS, and BIOS into memory at some predetermined address.
0346: F840         ; Then it transfers control to the BOOT entry point in the BIOS jump vector.
0347: F840         ;  This BOOT routine must initialize all of the required computer hardware.
0348: F840         ;
0349: F840         ; Most BOOT routines sign on by displaying a short message on the console,
0350: F840         ; indicating the current version ofCP/M and the computer hardware that this BIOS
0351: F840         ; can support. The BOOT routine terminates by transferring control to the start of the CCP
0352: F840         ; +6 bytes (the CCP has its own smalljump vector at the beginning). Just before the
0353: F840         ; BOOT routine jumps into the CCP, it sets the C register to 0 to indicate that logical
0354: F840         ; disk A is to be the default disk drive. This is what causes "A>" to be the CCP's
0355: F840         ; initial prompt.
0356: F840
0357: F840             BOOT:
0358: F840         ;CodeStart:
0359: F840 21 5F F8               LD     HL,ROMControl
0360: F843 CD 4D F8               CALL   ReadRawDisk
0361: F846 D2 00 01               JP     NC,TPA               ; now execute the boot loader;
0362: F849
0363: F849 CD 6C F8               CALL   NoDisk               ;
0364: F84C 76                     HALT
0365: F84D
0366: F84D             ReadRawDisk:                      ; Enter with DiskControlBlock pointer in HL
0367: F84D 22 46 00               LD     (DiskCommandBlock),HL ; put it into the Command block for drive A:
0368: F850
0369: F850 21 45 00               LD     HL,DiskControlByte
0370: F853 36 80                  LD     (HL),080H            ; activate the controller
0371: F855
0372: F855             WaitForBootComplete:
0373: F855 7E                     LD     A,(HL)               ; Get the control byte
0374: F856 B7                     OR     A                    ; is it set to 0 (Completed operation) ?
0375: F857 20 FC                  JR     NZ,WaitForBootComplete ; if not try again
0376: F859
0377: F859 3A 43 00               LD     A,(DiskStatusLocation) ; after operation what's the status?
0378: F85C FE 80                  CP     080H                 ; any errors ?
0379: F85E C9                     RET                         ; exit with result in the CCs
0380: F85F
0381: F85F
0382: F85F         ;---------------------------- ROM Disk Control Block -------------------------;
0383: F85F             ROMControl:                      ;
0384: F85F 01                     DB     DiskReadCode         ; Read function                       ;
0385: F860 00                     DB     00H                  ; unit number                         ;
0386: F861 00                     DB     00H                  ; head number                         ;
0387: F862 00                     DB     00H                  ; track number                        ;
0388: F863 01                     DB     01H                  ; Starting sector number ()           ;
0389: F864 00 02                  DW     diskSectorSize       ; Number of bytes to read ( 1 Sector) ;
0390: F866 00 01                  DW     TPA                  ; read into this address              ;
0391: F868 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking  ;
0392: F86A 40 00                  DW     DiskControlTable     ; pointer to next table- no linking   ;
0393: F86C         ;---------------------------- ROM Disk Control Block -------------------------;
0394: F86C
0395: F86C
0396: F86C             NoDisk:
0397: F86C 21 77 F8               LD     HL,NoDiskMessage
0398: F86F             DisplayMessage:
0399: F86F 7E                     LD     A,(HL)
0400: F870 B7                     OR     A
0401: F871 C8                     RET    Z
0402: F872 D3 EC                  OUT    (BOOT_CON_ADDRESS),A ; Console address
0403: F874 23                     INC    HL
0404: F875 18 F8                  JR     DisplayMessage
0405: F877
0406: F877             NoDiskMessage:
0407: F877 0D 0A                  DB     CR,LF
0408: F879 4E 6F 20 53 79 73 74 65 6D 20 44 69 73 6B 20 4D 6F 75 6E 74 65 64                DB     'No System Disk Mounted'
0409: F88F 0D 0A 00                DB     CR,LF,EndOfMessage
0410: F892             WarmBootErroMessage:
0411: F892 0D 0A                  DB     CR,LF
0412: F894 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'
0413: F89F 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'
0414: F8A9 0D 0A 00                DB     CR,LF,EndOfMessage
0415: F8AC
0416: F8AC
0417: F8AC         ;?	LD		HL,BootMessage
0418: F8AC         ;?	CALL	DisplayMessage
0419: F8AC         ;?
0420: F8AC         ;?	LD		HL,BOOTControl
0421: F8AC         ;?	CALL	RawDiskRead
0422: F8AC         ;?
0423: F8AC         ;?	JP		WBOOT				; do Warm boot if no errors
0424: F8AC         ;?	LD		HL,BadBootMessage
0425: F8AC         ;?	CALL	DisplayMessage		; Show Boot failure message
0426: F8AC         ;?	HALT
0427: F8AC         ;?
0428: F8AC         ;?BOOTControl:
0429: F8AC         ;?	DB		DiskReadCode					; Read function
0430: F8AC         ;?	DB		00H								; unit number
0431: F8AC         ;?	DB		00H								; head number
0432: F8AC         ;?	DB		00H								; track number
0433: F8AC         ;?	DB		0DH								; Starting sector number (13)
0434: F8AC         ;?	DW		5 * 512							; Number of bytes to read ( 0A00 All of BIOS)
0435: F8AC         ;?	DW		BIOSStart						; read into this address
0436: F8AC         ;?	DW		DiskStatusLocation				; pointer to next block - no linking
0437: F8AC         ;?	DW		DiskControlTable				; pointer to next table- no linking
0438: F8AC         ;?
0439: F8AC         ;?
0440: F8AC         ;?;BOOTControl:
0441: F8AC         ;?; 	DB		DiskReadCode		; Read function
0442: F8AC         ;?; 	DB		00H					; unit number
0443: F8AC         ;?; 	DB		00H					; head number
0444: F8AC         ;?; 	DB		00H					; track number
0445: F8AC         ;?; 	DB		01H					; Starting sector number ()
0446: F8AC         ;?; 	DW		diskSectorSize		; Number of bytes to read ( 1 Sector)
0447: F8AC         ;?; 	DW		TPA					; read into this address
0448: F8AC         ;?; 	DW		DiskStatusLocation	; pointer to next block - no linking
0449: F8AC         ;?; 	DW		DiskControlTable	; pointer to next table- no linking
0450: F8AC         ;?
0451: F8AC         ;?; Boot Messages and routine
0452: F8AC         ;?BootMessage:
0453: F8AC         ;?;	DB		'CP/M 2.2 (Z80) '
0454: F8AC         ;?;	DB		'BootStrap Loader'
0455: F8AC         ;?;	DB		CR,LF
0456: F8AC         ;?	DB		'Build 0.A '
0457: F8AC         ;?	DB		CR,LF
0458: F8AC         ;?	DB		'CCP 0.A |  BDOS 0.A | BIOS 0.B'
0459: F8AC         ;?	DB		CR,LF,EndOfMessage
0460: F8AC         ;?BadBootMessage:
0461: F8AC         ;?	DB		CR,LF
0462: F8AC         ;?	DB		'****   Boot Failure'
0463: F8AC         ;?	DB		EndOfMessage
0464: F8AC         ;?WarmBootErroMessage:
0465: F8AC         ;?	DB		CR,LF
0466: F8AC         ;?	DB		'Warm Boot -'
0467: F8AC         ;?	DB		' Retrying.'
0468: F8AC         ;?	DB		CR,LF,EndOfMessage
0469: F8AC         ;?;..................Boot Support....................
0470: F8AC         ;?
0471: F8AC         ;?; Entered with DiskControlBlock pointer in HL
0472: F8AC         ;?RawDiskRead:
0473: F8AC         ;?	LD		(DiskCommandBlock),HL
0474: F8AC         ;?
0475: F8AC         ;?	LD		HL,DiskControlByte
0476: F8AC         ;?	LD		(HL),080H
0477: F8AC         ;?
0478: F8AC         ;?; wait for the read to complete
0479: F8AC         ;?WaitForReadDone:
0480: F8AC         ;?	LD		A,(HL)
0481: F8AC         ;?	OR		A
0482: F8AC         ;?	JR		NZ,WaitForReadDone
0483: F8AC         ;?
0484: F8AC         ;?; is it a clean read ?
0485: F8AC         ;?	LD		A,(DiskStatusLocation)
0486: F8AC         ;?	CP		080H				; any errors NC = good read?
0487: F8AC         ;?	RET
0488: F8AC         ;?
0489: F8AC         ;?; entered with pointer to message in HL
0490: F8AC         ;?DisplayMessage:
0491: F8AC         ;?	LD		A,M					; get  character
0492: F8AC         ;?	OR		A					; is it NULL
0493: F8AC         ;?	RET		Z					; return if it is NULL (00)
0494: F8AC         ;?	LD		C,A
0495: F8AC         ;?	PUSH	HL					; save the pointer
0496: F8AC         ;?	OUT		TTY_DataPort
0497: F8AC         ;?	POP		HL					; retrieve the pointer
0498: F8AC         ;?	INC		HL					; point at next character
0499: F8AC         ;?	JR		DisplayMessage
0500: F8AC         ;?
0501: F8AC         ;....................................................
0502: F8AC
0503: F8AC         ;---------------------------------------------------------------------------
0504: F8AC         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot
0505: F8AC         ;
0506: F8AC         ;  Unlike the "cold" bootstrap entry point, which executes only once, the WBOOT
0507: F8AC         ; or warm boot routine will be executed every time a program terminates by
0508: F8AC         ; jumping to location OOOOH, or whenever you type a CONTROL-C on the console as
0509: F8AC         ; the first character of an input line.
0510: F8AC         ;  The WBOOT routine is responsible for reloading the CCP into memory.
0511: F8AC         ; Programs often use all of memory up to the starting point of the BDOS, overwriting
0512: F8AC         ; the CCP in the process. The underlying philosophy is that while a program is
0513: F8AC         ; executing, the CCP is not needed, so the program can use the memory previously
0514: F8AC         ; occupied by the CCP. The CCP occupies 800H (2048) bytes ofmemory-and this
0515: F8AC         ; is frequently just enough to make the difference between a program that cannot
0516: F8AC         ; run and one that can.
0517: F8AC         ; A few programs that are self-contained and do not require the BDOS's
0518: F8AC         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes of
0519: F8AC         ; memory. Therefore, to be really safe, the WBOOT routine should read in both the
0520: F8AC         ; CCP and the BDOS. It also needs to set up the two JMPs at location OOOOH (to
0521: F8AC         ; WBOOT itself) and at location 0005H (to the BOOS). Location 0003H should be
0522: F8AC         ; set to the initial value of the 10BYTE if this is implemented in the BIOS.
0523: F8AC         ; As its last act, the WBOOT routine sets register C to indicate which logical disk
0524: F8AC         ; is to be selected (C= 0 for A, I for B, and so on). It then transfers control into the
0525: F8AC         ; CCP at the first instruction in order to restart the CCP.
0526: F8AC
0527: F8AC             WBOOT:
0528: F8AC 31 FF DF               LD     SP,CCPEntry-1        ; put stack at top of User area
0529: F8AF 21 E2 F8               LD     HL,WBOOTControl      ; get the WBOOT Control Block
0530: F8B2 CD 4D F8               CALL   ReadRawDisk          ; read CCP & BDOS
0531: F8B5 30 09                  JR     NC,LoadPage0         ; set up page 0 if good read
0532: F8B7
0533: F8B7 21 92 F8               LD     HL,WarmBootErroMessage
0534: F8BA CD 6F F8               CALL   DisplayMessage       ; send bad warm boot message
0535: F8BD C3 AC F8               JP     WBOOT                ; keep trying
0536: F8C0
0537: F8C0
0538: F8C0         ; Set up page Zero
0539: F8C0             LoadPage0:
0540: F8C0 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0541: F8C2
0542: F8C2 32 00 00               LD     (WarmBoot),A
0543: F8C5 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0544: F8C8 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0545: F8CB
0546: F8CB 32 05 00               LD     (BDOSE),A
0547: F8CE 21 06 E8               LD     HL,BDOSEntry         ; BDOS entry point
0548: F8D1 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0549: F8D4
0550: F8D4 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0551: F8D7 CD 43 FA               CALL   SETDMA               ; use normal BDOS  routine
0552: F8DA FB                     EI                          ; Enable interrupts
0553: F8DB
0554: F8DB 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0555: F8DE 4F                     LD     C,A
0556: F8DF C3 00 E0               JP     CCPEntry             ; transfer control to CCP
0557: F8E2
0558: F8E2
0559: F8E2             WBOOTControl:
0560: F8E2 01                     DB     DiskReadCode         ; Read function
0561: F8E3 00                     DB     00H                  ; unit number
0562: F8E4 00                     DB     00H                  ; head number
0563: F8E5 00                     DB     00H                  ; track number
0564: F8E6 02                     DB     02H                  ; Starting sector number (skip cold boot sector)
0565: F8E7 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read ( rest of the head)
0566: F8E9 00 E0                  DW     CCPEntry             ; read into this address
0567: F8EB 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0568: F8ED 45 00                  DW     DiskControlByte      ; pointer to next table- no linking
0569: F8EF
0570: F8EF         ;---------------------------------------------------------------------------
0571: F8EF         ;	Console Status:		BIOS 02
0572: F8EF         ;
0573: F8EF         ;  CONST simply returns an indicator showing whether there is an incoming
0574: F8EF         ; character from the console device. The convention is that A = OFFH if a character
0575: F8EF         ; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
0576: F8EF         ; to reflect the contents of the A register - it is the contents that are important.
0577: F8EF         ; CONST is called by the CCP whenever the CCP is in the middle of an
0578: F8EF         ; operation that can be interrupted by pressing a keyboard character.
0579: F8EF         ;
0580: F8EF         ; The BDOS will call CONST if a program makes a Read Console Status
0581: F8EF         ; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
0582: F8EF         ; routine, CONIN
0583: F8EF
0584: F8EF             CONST:
0585: F8EF             ConStatus:
0586: F8EF 3A 03 00               LD     A,(IOBYTE)
0587: F8F2 DD 21 E0 F9               LD     IX,CON_Vector
0588: F8F6
0589: F8F6             GenericInStatus:                      ; Entry point for generic input status
0590: F8F6 CD 9C F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0591: F8F9 CD 69 F9               CALL   GetInStatus
0592: F8FC B7                     OR     A
0593: F8FD C8                     RET    Z                    ; 00 => No data pending
0594: F8FE 3E FF                  LD     A,0FFH
0595: F900 C9                     RET                         ; OFFH => Data in Buffer
0596: F901         ;---------------------------------------------------------------------
0597: F901         ;	Console In:		BIOS 03
0598: F901         ;
0599: F901         ;  CONIN reads the next character from the console to the A register and sets the
0600: F901         ; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
0601: F901         ; until it detects A = OFFH. Only then will it input the data character and mask off
0602: F901         ; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
0603: F901         ; Read Console Byte function (B$CONIN, code 1).
0604: F901         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0605: F901
0606: F901         ; This is a blocking routine
0607: F901
0608: F901             CONIN:
0609: F901             ConIn:
0610: F901 CD EF F8               CALL   ConStatus
0611: F904 28 FB                  JR     Z,ConIn              ; loop until there is some data to read
0612: F906         ; Call to ConStatus Sets up IX with Physical Table
0613: F906 DD 6E 06               LD     L,(IX+DataReadIndex)
0614: F909 DD 66 07               LD     H,(IX+(DataReadIndex+1))
0615: F90C E9                     JP     (HL)
0616: F90D         ;---------------------------------------------------------------------------
0617: F90D         ;	Console Out:		BIOS 04
0618: F90D         ;
0619: F90D         ;  CONOUT outputs the character (in ASCII) in register C to the console. The
0620: F90D         ; most significant (parity) bit of the character will always be O.
0621: F90D         ; CONOUT must first check that the console device is ready to receive more
0622: F90D         ; data, delaying if necessary until it is, and only then sending the character to the
0623: F90D         ; device. CONOUT is called by the CCP and by the BDOS when a program executes a
0624: F90D         ; Write Console Byte function (B$CONOUT, code 2).
0625: F90D
0626: F90D         ; This is a blocking routine
0627: F90D
0628: F90D             CONOUT:
0629: F90D             CONOut:
0630: F90D 3A 03 00               LD     A,(IOBYTE)
0631: F910 DD 21 E0 F9               LD     IX,CON_Vector
0632: F914
0633: F914             GenericOutStatus:                      ; entry point for standard blocking write
0634: F914 CD 9C F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0635: F917             GenericOutStatus1:
0636: F917 CD 64 F9               CALL   GetOutStatus
0637: F91A 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0638: F91C DD 6E 08               LD     L,(IX+DataWriteIndex)
0639: F91F DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0640: F922 E9                     JP     (HL)
0641: F923
0642: F923         ;---------------------------------------------------------------------------
0643: F923         ;	List output  BIOS 05
0644: F923         ;
0645: F923         ; LIST is similar to CONOUT except that it sends the character in register C to
0646: F923         ; the list device. It too checks first that the list device is ready to receive
0647: F923         ; the character. LIST is called by the CCP in response to the CONTROL-P toggle
0648: F923         ; for printer echo of console output, and by the BDOS when a program makes a
0649: F923         ; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).
0650: F923
0651: F923         ; This is a blocking routine
0652: F923
0653: F923             LIST:
0654: F923 3A 03 00               LD     A,(IOBYTE)
0655: F926 07                     RLCA                        ; move bits 7,6
0656: F927 07                     RLCA                        ; to 1,0
0657: F928 DD 21 F8 F9               LD     IX,LST_Vector
0658: F92C 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0659: F92E
0660: F92E         ;---------------------------------------------------------------------------
0661: F92E         ;	Punch output  BIOS 06
0662: F92E         ;
0663: F92E         ;  PUNCH sends the character in register C to the "punch" device. As mentioned
0664: F92E         ; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
0665: F92E         ; entry point either returns immediately and is effectively a null routine, or it outputs
0666: F92E         ; the character to a communications device, such as a modem, on your computer.
0667: F92E         ; PUNCH must check that the "punch" device is indeed ready to accept another
0668: F92E         ; character for output, and must wait if it is not.
0669: F92E         ;
0670: F92E         ; Digital Research's documentation states that the character to be output will
0671: F92E         ; always have its most significant bit set to O. This is not true. The BDOS simply
0672: F92E         ; transfers control over to the PUNCH entry point in the BIOS; the setting of the
0673: F92E         ; most significant bit will be determined by the program making the BDOS function
0674: F92E         ; request (B$PUNOUT, code 4). This is important because the requirement of a zero
0675: F92E         ; would preclude being able to send pure binary data via the BIOS PUNCH
0676: F92E         ; function
0677: F92E
0678: F92E         ; This is a blocking routine
0679: F92E
0680: F92E             PUNCH:                          ; Punch output
0681: F92E 3A 03 00               LD     A,(IOBYTE)
0682: F931 0F                     RRCA
0683: F932 0F                     RRCA
0684: F933 0F                     RRCA                        ; move bits 5,4
0685: F934 0F                     RRCA                        ; to 1,0
0686: F935 DD 21 F0 F9               LD     IX,PUN_Vector
0687: F939 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0688: F93B
0689: F93B         ;---------------------------------------------------------------------------
0690: F93B         ;	Reader input  BIOS 07
0691: F93B         ;
0692: F93B         ; As with the PUNCH entry point, the READER entry point rarely connects to
0693: F93B         ; a real paper tape reader.
0694: F93B         ; The READER function must return the next character from the reader device
0695: F93B         ; in the A register, waiting, if need be, until there is a character.
0696: F93B         ;
0697: F93B         ; Digital Research's documentation again says that the most significant bit of
0698: F93B         ; the A register must be 0, but this is not the case if you wish to receive pure binary
0699: F93B         ; information via this function.
0700: F93B         ; READER is called whenever a program makes a Read "Reader" Byte function
0701: F93B         ; request (B$READIN, code 3).
0702: F93B
0703: F93B         ; This is a blocking routine
0704: F93B
0705: F93B             READER:                         ; Reader Input
0706: F93B 3A 03 00               LD     A,(IOBYTE)
0707: F93E 0F                     RRCA
0708: F93F 0F                     RRCA                        ; move bits 3,2  to 1,0
0709: F940 DD 21 E8 F9               LD     IX,RDR_Vector
0710: F944             READER1:
0711: F944 CD F6 F8               CALL   GenericInStatus
0712: F947 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0713: F949
0714: F949 DD 6E 06               LD     L,(IX+DataReadIndex)
0715: F94C DD 66 07               LD     H,(IX+(DataReadIndex+1))
0716: F94F E9                     JP     (HL)
0717: F950
0718: F950         ;---------------------------------------------------------------------------
0719: F950         ;	List Status:  BIOS 0F
0720: F950
0721: F950         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0722: F950         ; This function returns the current status of the list device, using the IOBYTE if
0723: F950         ; necessary to select the correct physical device. It sets the A register to OFFH if the
0724: F950         ; list device can accept another character for output or to OOH if it is not ready.
0725: F950         ; Digital Research's documentation states that this function is used by the
0726: F950         ; DESPOOL utility program (which allows you to print a file "simultaneously" with
0727: F950         ; other operations) to improve console response during its operation, and that it is
0728: F950         ; acceptable for the routine always to return OOH if you choose not to implement it
0729: F950         ; fully.
0730: F950         ; Unfortunately, this statement is wrong. Many other programs use the LISTST
0731: F950         ; function to "poll" the list device to make sure it is ready, and if it fails to come
0732: F950         ; ready after a predetermined time, to output a message to the console indicating
0733: F950         ; that the printer is not ready. If you ever make a call to the BDOS list output
0734: F950         ; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0735: F950         ; not ready, then CP/M will wait forever-and your program will have lost control
0736: F950         ; so it cannot even detect that the problem has occurred. If LISTST always returns a
0737: F950         ; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
0738: F950         ; out of the LISTST function, but it also causes a stream of false "Printer
0739: F950         ; not Ready" error messages to appear on the console.
0740: F950
0741: F950             LISTST:
0742: F950 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0743: F953 07                     RLCA
0744: F954 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0745: F955 DD 21 F8 F9               LD     IX,LST_Vector        ; Set th vector base
0746: F959 CD 9C F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0747: F95C CD 64 F9               CALL   GetOutStatus
0748: F95F
0749: F95F B7                     OR     A
0750: F960 C8                     RET    Z                    ; 00 => Device Ready
0751: F961 3E FF                  LD     A,0FFH
0752: F963 C9                     RET                         ; OFFH => Device No Ready
0753: F964
0754: F964         ;---------------------------------------------------------------------------
0755: F964
0756: F964         ;---------------------------------------------------------------------
0757: F964             GetOutStatus:
0758: F964         ; vector to CON Devices
0759: F964 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0760: F967 18 03                  JR     GetStatus
0761: F969             GetInStatus:
0762: F969 DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0763: F96C             GetStatus:
0764: F96C DD 6E 04               LD     L,(IX+StatusReadIndex)
0765: F96F DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0766: F972 E9                     JP     (HL)                 ; jump to the stats read routine
0767: F973
0768: F973         ;---------------------------------------------------------------------
0769: F973
0770: F973             DataRead:
0771: F973 DD 7E 01               LD     A,(IX+DataPortIndex)
0772: F976 32 7A F9               LD     (AddressDataIn),A    ; modify code with the Data port
0773: F979 DB                     DB     IN_OPCODE
0774: F97A             AddressDataIn:
0775: F97A 00                     DB     00                   ; perform the read
0776: F97B C9                     RET
0777: F97C
0778: F97C             DataReadASCII:
0779: F97C CD 73 F9               CALL   DataRead
0780: F97F E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0781: F981 C9                     RET                         ; AND		ASCII_MASK
0782: F982
0783: F982         ; Enter DataWrite the value to be output in C
0784: F982             DataWrite:
0785: F982 DD 7E 01               LD     A,(IX+DataPortIndex)
0786: F985 32 8A F9               LD     (AddressDataOut),A   ; modify code with the Data port
0787: F988 79                     LD     A,C                  ; get value into ACC
0788: F989 D3                     DB     OUT_OPCODE
0789: F98A             AddressDataOut:
0790: F98A 00                     DB     00                   ; perform the write
0791: F98B C9                     RET
0792: F98C
0793: F98C
0794: F98C         ; Enter Status Read with Target mask in D
0795: F98C             StatusRead:
0796: F98C DD 7E 00               LD     A,(IX+StatusPortIndex)
0797: F98F 32 93 F9               LD     (AddressStatus),A    ; modify code with the status port
0798: F992 DB                     DB     IN_OPCODE
0799: F993             AddressStatus:
0800: F993 00                     DB     00
0801: F994 A2                     AND    D                    ; Check return vale with the mask
0802: F995 C9                     RET
0803: F996
0804: F996             DUMMYRead:
0805: F996 C9                     RET
0806: F997             DUMMYWrite:
0807: F997 C9                     RET
0808: F998             DUMMYCheck:
0809: F998 3E FF                  LD     A,0FFH               ; Always return 0FFH
0810: F99A B7                     OR     A                    ; Set flags
0811: F99B C9                     RET
0812: F99C
0813: F99C         ;=============================================================================
0814: F99C             SetDeviceVector:
0815: F99C E6 03                  AND    03H                  ; Get bits 0 & 1;
0816: F99E 87                     ADD    A,A                  ; Double for word size index
0817: F99F 16 00                  LD     D,00H
0818: F9A1 5F                     LD     E,A                  ; load byte index int DE
0819: F9A2 DD 19                  ADD    IX,DE                ; add to the value vector base
0820: F9A4         ; IX points at correct entry in vector
0821: F9A4 DD 5E 00               LD     E,(IX+0)
0822: F9A7 DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0823: F9AA D5                     PUSH   DE
0824: F9AB DD E1                  POP    IX                   ; Move it to IX
0825: F9AD C9                     RET
0826: F9AE
0827: F9AE
0828: F9AE         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0829: F9AE         ; Physical Device Attributes
0830: F9AE
0831: F9AE             TTY_StatusPort EQU    0EDH
0832: F9AE             TTY_DataPort EQU    0ECH
0833: F9AE             TTY_OutputMask EQU    80H                  ; Status Mask
0834: F9AE             TTY_InputMask EQU    7FH                  ; Status Mask
0835: F9AE
0836: F9AE             CRT_StatusPort EQU    02H
0837: F9AE             CRT_DataPort EQU    01H
0838: F9AE             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0839: F9AE             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0840: F9AE
0841: F9AE             COM_StatusPort EQU    0EDH
0842: F9AE             COM_DataPort EQU    0ECH
0843: F9AE             COM_OutputMask EQU    01H                  ; Status Mask
0844: F9AE             COM_InputMask EQU    02H                  ; Status Mask
0845: F9AE
0846: F9AE             LPT_StatusPort EQU    011H
0847: F9AE             LPT_DataPort EQU    010H
0848: F9AE             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0849: F9AE             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0850: F9AE
0851: F9AE             DUMMY_StatusPort EQU    011H
0852: F9AE             DUMMY_DataPort EQU    010H
0853: F9AE             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0854: F9AE             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0855: F9AE
0856: F9AE         ; Device Table Control Block Definition
0857: F9AE             StatusPortIndex EQU    0
0858: F9AE             DataPortIndex EQU    1
0859: F9AE             OutputMaskIndex EQU    2
0860: F9AE             InputMaskIndex EQU    3
0861: F9AE             StatusReadIndex EQU    4
0862: F9AE             DataReadIndex EQU    6
0863: F9AE             DataWriteIndex EQU    8
0864: F9AE
0865: F9AE         ;Physical Devices Control Blocks
0866: F9AE
0867: F9AE             TTY_Table:
0868: F9AE ED                     DB     TTY_StatusPort
0869: F9AF EC                     DB     TTY_DataPort
0870: F9B0 80                     DB     TTY_OutputMask
0871: F9B1 7F                     DB     TTY_InputMask
0872: F9B2 8C F9                  DW     StatusRead
0873: F9B4 7C F9                  DW     DataReadASCII
0874: F9B6 82 F9                  DW     DataWrite
0875: F9B8
0876: F9B8             CRT_Table:
0877: F9B8 02                     DB     CRT_StatusPort
0878: F9B9 01                     DB     CRT_DataPort
0879: F9BA 80                     DB     CRT_OutputMask
0880: F9BB 7F                     DB     CRT_InputMask
0881: F9BC 8C F9                  DW     StatusRead
0882: F9BE 73 F9                  DW     DataRead
0883: F9C0 82 F9                  DW     DataWrite
0884: F9C2             COM_Table:
0885: F9C2 ED                     DB     COM_StatusPort
0886: F9C3 EC                     DB     COM_DataPort
0887: F9C4 01                     DB     COM_OutputMask
0888: F9C5 02                     DB     COM_InputMask
0889: F9C6 8C F9                  DW     StatusRead
0890: F9C8 73 F9                  DW     DataRead
0891: F9CA 82 F9                  DW     DataWrite
0892: F9CC             LPT_Table:
0893: F9CC 11                     DB     LPT_StatusPort
0894: F9CD 10                     DB     LPT_DataPort
0895: F9CE FF                     DB     LPT_OutputMask
0896: F9CF 7F                     DB     LPT_InputMask
0897: F9D0 8C F9                  DW     StatusRead
0898: F9D2 73 F9                  DW     DataRead
0899: F9D4 82 F9                  DW     DataWrite
0900: F9D6             DUMMY_Table:
0901: F9D6 11                     DB     DUMMY_StatusPort
0902: F9D7 10                     DB     DUMMY_DataPort
0903: F9D8 FF                     DB     DUMMY_OutputMask
0904: F9D9 7F                     DB     DUMMY_InputMask
0905: F9DA 98 F9                  DW     DUMMYCheck
0906: F9DC 96 F9                  DW     DUMMYRead
0907: F9DE 97 F9                  DW     DUMMYWrite
0908: F9E0
0909: F9E0         ;---------------------------------------------------------------------------
0910: F9E0
0911: F9E0         ; Logical Device Vector, Controlled by IOBYTE
0912: F9E0
0913: F9E0             CON_Vector:                      ; IOBYTE bits 1 & 0
0914: F9E0 AE F9                  DW     TTY_Table
0915: F9E2 B8 F9                  DW     CRT_Table
0916: F9E4 C2 F9                  DW     COM_Table
0917: F9E6 D6 F9                  DW     DUMMY_Table
0918: F9E8             RDR_Vector:                      ; IOBYTE bits 3 & 2
0919: F9E8 AE F9                  DW     TTY_Table
0920: F9EA B8 F9                  DW     CRT_Table
0921: F9EC D6 F9                  DW     DUMMY_Table
0922: F9EE D6 F9                  DW     DUMMY_Table
0923: F9F0             PUN_Vector:                      ; IOBYTE bits 5 & 4
0924: F9F0 AE F9                  DW     TTY_Table
0925: F9F2 D6 F9                  DW     DUMMY_Table
0926: F9F4 C2 F9                  DW     COM_Table
0927: F9F6 B8 F9                  DW     CRT_Table
0928: F9F8             LST_Vector:                      ; IOBYTE bits 7 & 6
0929: F9F8 CC F9                  DW     LPT_Table
0930: F9FA B8 F9                  DW     CRT_Table
0931: F9FC CC F9                  DW     LPT_Table
0932: F9FE D6 F9                  DW     DUMMY_Table
0933: FA00
0934: FA00         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0935: FA00         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0936: FA00
0937: FA00         ;---------------------------------------------------------------------------
0938: FA00         ;	Disk routines
0939: FA00         ;---------------------------------------------------------------------------
0940: FA00
0941: FA00         ;  All of the disk functions that follow were originally designed to operate on the
0942: FA00         ; 128-byte sectors used on single-sided, single-density, 8-inch floppy diskettes that
0943: FA00         ; were standard in the industry at the time. Now that CP/M runs on many different
0944: FA00         ; types of disks, some of the BIOS disk functions seem strange because most of the
0945: FA00         ; new disk drives use sector sizes other than 128 bytes.
0946: FA00         ; To handle larger sector sizes, the BIOS has some additional code that makes
0947: FA00         ; the BDOS respond as if it were still handling 128-byte sectors. This code is referred
0948: FA00         ; to as the blocking/deblocking code.
0949: FA00         ;  As its name implies, it blocks together several 128-byte "sectors" and only writes
0950: FA00         ; to the disk when a complete physical sector has been assembled.
0951: FA00         ;  When reading, it reads in a physical sector and then deblocks it,handing back
0952: FA00         ; several 128-byte "sectors" to the BDOS.
0953: FA00         ;  To do all of this, the blocking/deblocking code uses a special buffer area of the
0954: FA00         ; same size as the physical sectors on the disk. This is known as the host disk buffer
0955: FA00         ; or HSTBUE Physical sectors are read into this buffer and written to the disk
0956: FA00         ; from it. In order to optimize this blocking/deblocking routine, the BIOS has code in it
0957: FA00         ; to reduce the number of times that an actual disk read or write occurs. A side effect
0958: FA00         ; is that at any given moment, several 128-byte "sectors" may be stored in the
0959: FA00         ; HSTBUF, waiting to be written out to the disk when HSTBUF becomes full. This
0960: FA00         ; sometimes complicates the logic of the BIOS disk functions. You cannot simply
0961: FA00         ; select a new disk drive, for example, when the HSTBUF contains data destined for
0962: FA00         ; another disk drive. You will see this complication in the BIOS only in the form of
0963: FA00         ; added logical operations; the BIOS disk functions rarely trigger immediate physical
0964: FA00         ; operations. It is easier to understand these BIOS functions if you consider that
0965: FA00         ; they make requests-and that these requests are satisfied only when it makes
0966: FA00         ; sense to do so, taking into account the blocking/ deblocking logic.
0967: FA00
0968: FA00         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0969: FA00         ;---------------------------------------------------------------------------
0970: FA00
0971: FA00         ;---------------------------------------------------------------------------
0972: FA00         ;	Home Disk	BIOS 08
0973: FA00         ;
0974: FA00         ;  HOME - Home the selected logical disk to track 0. Before doing this, a check
0975: FA00         ; must be made to see if the physical disk buffer has information that must be
0976: FA00         ; written out. This is indicated by a flag, DirtyBufferFlag,set in the de-blocking code
0977: FA00
0978: FA00             HOME:
0979: FA00 3A A8 FB               LD     A,(DirtyBufferFlag)  ; Check for Dirty Buffer
0980: FA03 B7                     OR     A
0981: FA04 20 03                  JR     NZ,HomeNoWrite
0982: FA06 32 A7 FB               LD     (DataInBufferFlag),A ; Clear DataInBufferFlag if Buffer not dirty
0983: FA09             HomeNoWrite:
0984: FA09 0E 00                  LD     C,00H                ; Set to track 0
0985: FA0B CD 39 FA               CALL   SETTRK               ; no, physical, only logical
0986: FA0E C9                     RET
0987: FA0F
0988: FA0F         ;---------------------------------------------------------------------------
0989: FA0F         ;	Select Disk	BIOS 09
0990: FA0F
0991: FA0F         ;  SELDSK does not do what its name implies. It does not (and must not)
0992: FA0F         ; physically select a logical disk. Instead, it returns a pointer in the
0993: FA0F         ; HL register pair to the disk parameter header for the logical disk specified
0994: FA0F         ; in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK also
0995: FA0F         ; stores this code for the requested disk to be used later in the READ and WRITE functions.
0996: FA0F         ; If the logical disk code in register C refers to a nonexistent disk or to one for
0997: FA0F         ; which no disk parameter header exists, then SELDSK must return with HL set to
0998: FA0F         ; OOOOH. Then the BDOS will output a message of the form "BDOS Err on XI Select"
0999: FA0F         ; Note that SELDSK not only does not select the disk, but also does not indicate
1000: FA0F         ; whether or not the requested disk is physically present -merely whether or not
1001: FA0F         ; there are disk tables present for the disk.
1002: FA0F         ;  SELDSK is called by the BDOS either during disk file operations or by a
1003: FA0F         ; program issuing a Select Disk request (B$SELDSK, code 14).
1004: FA0F
1005: FA0F             SELDSK:
1006: FA0F 21 00 00               LD     HL,00H               ; Assume an error
1007: FA12 79                     LD     A,C
1008: FA13 FE 04                  CP     NumberOfLogicalDisks
1009: FA15 D0                     RET    NC                   ; return if > max number of Disks
1010: FA16
1011: FA16 32 AA FB               LD     (SelectedDisk),A     ; save disk number
1012: FA19
1013: FA19 07                     RLCA                        ; X2
1014: FA1A 07                     RLCA                        ; X4
1015: FA1B 07                     RLCA                        ; X8
1016: FA1C 07                     RLCA                        ; X16
1017: FA1D 16 00                  LD     D,0
1018: FA1F 5F                     LD     E,A                  ; put index int DE
1019: FA20 DD 21 B9 FB               LD     IX,DiskParameterHeaders ; get DPH address Base
1020: FA24 DD 19                  ADD    IX,DE                ; get the specific DiskParameterHeader
1021: FA26 DD E5                  PUSH   IX                   ; save for return in HL
1022: FA28
1023: FA28 DD 56 0B               LD     D,(IX+11)            ; LSB for Disk Parameter Block
1024: FA2B DD 5E 0A               LD     E,(IX+10)            ; MSB for Disk Parameter Block
1025: FA2E
1026: FA2E D5                     PUSH   DE
1027: FA2F DD E1                  POP    IX
1028: FA31 DD 7E 0F               LD     A,(IX+15)            ; Disk Parameter Block in IY
1029: FA34 32 A9 FB               LD     (SelectedDskSecsPerHead),A
1030: FA37
1031: FA37 E1                     POP    HL                   ; recover DPH pointer
1032: FA38 C9                     RET
1033: FA39
1034: FA39
1035: FA39
1036: FA39         ;---------------------------------------------------------------------------
1037: FA39         ;	Set Track	BIOS 0A
1038: FA39
1039: FA39         ;  SETTRK saves the requested disk track that is in the BC register pair when
1040: FA39         ; SETTRK gets control. Note that this is an absolute track number; that is, the
1041: FA39         ; number of reserved tracks before the file directory will have been added to the
1042: FA39         ; track number relative to the start of the logical disk.
1043: FA39         ;  The number of the requested track will be used in the next BIOS READ or
1044: FA39         ; WRITE function.
1045: FA39         ;  SETTRK is called by the BDOS when it needs to read or write a 128-byte
1046: FA39         ; sector. Legitimate track numbers are from 0 to OFFFFH (65,535).
1047: FA39
1048: FA39             SETTRK:
1049: FA39         ;	LD		H,B								; select track in BC on entry
1050: FA39         ;	LD		L,C
1051: FA39         ;	LD	(SelectedTrack),HL					; save for low level driver
1052: FA39 ED 43 AB FB               LD     (SelectedTrack),BC   ; save for low level driver
1053: FA3D C9                     RET
1054: FA3E
1055: FA3E         ;---------------------------------------------------------------------------
1056: FA3E         ;	Set Sector	BIOS 0B  (Set Record)
1057: FA3E
1058: FA3E         ; Sector  = Record for disk with 128 byte sectors
1059: FA3E         ; Sector contains 4 records for disks with 512 byte sectors
1060: FA3E         ; this routine is missed named it should be called Set Record
1061: FA3E
1062: FA3E         ;  SETSEC is similar to SETTRK in that it stores the requested Record (sector) number
1063: FA3E         ; for later use in BIOS READ or WRITE functions. The requested Record (sector) number is
1064: FA3E         ; handed to SETSEC in the A register; legitimate values are from 0 to OFFH (255).
1065: FA3E         ; The Record (sector) number is a logical Record (sector) number. It does not take into account any
1066: FA3E         ; sector skewing that might be used to improve disk performance.
1067: FA3E         ;  SETSEC is called by the BDOS when it needs to read or write a 128-byte
1068: FA3E         ; Record (sector).
1069: FA3E
1070: FA3E             SETSEC:                         ; SETRECORD
1071: FA3E 79                     LD     A,C
1072: FA3F 32 AD FB               LD     (SelectedRecord),A   ; save for low level driver
1073: FA42 C9                     RET
1074: FA43
1075: FA43         ;---------------------------------------------------------------------------
1076: FA43         ;	Set Sector	BIOS 0C
1077: FA43
1078: FA43         ;  SETDMA saves the address in the BC register pair in the requested DMA
1079: FA43         ; address. The next BIOS READ or WRITE function will use the DMA address as
1080: FA43         ; a pointer to the 128-byte sector buffer into which data will be read or from which
1081: FA43         ; data will be written.
1082: FA43         ;  The default DMA address is 0080H. SETDMA is called by the BDOS when it
1083: FA43         ; needs to READ or WRITE a 128-byte sector.
1084: FA43
1085: FA43             SETDMA:
1086: FA43 ED 43 AE FB               LD     (DMAAddress),BC      ; save for low level driver
1087: FA47 C9                     RET
1088: FA48
1089: FA48         ;---------------------------------------------------------------------------
1090: FA48         ;	Sector Translate	BIOS 10
1091: FA48
1092: FA48         ;  SECTRAN, given a logical sector number, locates the correct physical sector
1093: FA48         ; number in the sector translate table for the previously selected (via SELDSK)
1094: FA48         ; logical disk drive. Note that both logical and physical sector numbers are
1095: FA48         ; l28-byte sectors, so if you are working with a hard disk system, it is not
1096: FA48         ; too efficient to impose a sector interlace at the l28-byte sector level.
1097: FA48         ; It is better to impose the sector interlace right inside the hard disk driver,
1098: FA48         ; if at all. In general, hard disks spin so rapidly that CP/M simply cannot take
1099: FA48         ; advantage of sector interlace.
1100: FA48         ;  The BDOS hands over the logical sector number in the BC register pair, with
1101: FA48         ; the address of the sector translate table in the DE register pair. SECTRAN must
1102: FA48         ; return the physical sector number in HL.
1103: FA48         ;  If SECTRAN is to be a null routine, it must move the contents of BC to HL
1104: FA48         ; and return.
1105: FA48
1106: FA48             SECTRAN:
1107: FA48 C5                     PUSH   BC
1108: FA49 E1                     POP    HL                   ; just move the value from BC to HL
1109: FA4A C9                     RET
1110: FA4B
1111: FA4B         ;---------------------------------------------------------------------------
1112: FA4B         ;	READ			BIOS 0D
1113: FA4B
1114: FA4B         ;  READ reads in a 128-byte sector provided that there have been previous BIOS
1115: FA4B         ; function calls to:
1116: FA4B         ; 				- SELDSK	"select" the disk
1117: FA4B         ; 				- SETDMA	set the DMA address
1118: FA4B         ; 				- SETTRK	set the track number
1119: FA4B         ; 				- SETSEC	set the sector number.
1120: FA4B         ;
1121: FA4B         ; Because of the blocking/ deblocking code in the BIOS, there are frequent occasions
1122: FA4B         ; when the requested sector will already be in the host buffer (HSTBUF), so that a
1123: FA4B         ; physical disk read is not required. All that is then required is for the BIOS to move
1124: FA4B         ; the appropriate 128 bytes from the HSTBUF into the buffer pointed at by the DMA address.
1125: FA4B         ; Only during the READ function will the BIOS normally communicate with the physical disk
1126: FA4B         ; drive, selecting it and seeking to read the requested track and sector. During this process,
1127: FA4B         ; the READ function must also handle any hardware errors that occur, trying an operation again
1128: FA4B         ; if a "soft," or recoverable, error occurs.
1129: FA4B         ;  The READ function must return with the A register set to OOH if the read operation has completed
1130: FA4B         ; successfully. If the READ function returns with the A register set to 01 H, the BDOS will
1131: FA4B         ; display an error message of the form BDOS Err on X: Bad Sector. Under these circumstances,
1132: FA4B         ; you have only two choices. You can enter a CARRIAGE RETURN, ignore the fact that there was an
1133: FA4B         ; error, and attempt to make sense of the data in the DMA buffer. Or you can type a CONTROL-C
1134: FA4B         ; to abort the operation, perform a warm boot, and return control to the CCP. As you can see,
1135: FA4B         ; CP/M's error handling is not particularly helpful, so most BIOS writers add more sophisticated
1136: FA4B         ; error recovery right in the disk driver. This can include some interaction with the console so
1137: FA4B         ; that a more determined effort can be made to correct errors or, if nothing else, give you more
1138: FA4B         ; information as to what has gone wrong. Such error handling is discussed in Chapter 9.
1139: FA4B         ;  If you are working with a hard disk system, the BIOS driver must also handle the management of
1140: FA4B         ; bad sectors. You cannot simply replace a hard disk drive if one or two sectors become unreadable.
1141: FA4B         ; This bad sector management normally requires that a directory of "spare" sectors be put on the
1142: FA4B         ; hard disk before it is used to store data. Then, when a sector is found to be bad,
1143: FA4B         ; one of the spare sectors is substituted in its place.
1144: FA4B
1145: FA4B             READ:
1146: FA4B AF                     XOR    A
1147: FA4C 32 B5 FB               LD     (ModifiedlRecordsCount),A ; 1. Set ModifiedlRecordsCount to 0
1148: FA4F 3C                     INC    A
1149: FA50 32 B8 FB               LD     (ReadWriteFlag),A    ; 2. Set to Flag to read (non-zero)
1150: FA53 32 B7 FB               LD     (PrereadSectorFlag),A ; 3. Force a preread
1151: FA56 3E 02                  LD     A,WriteCleanBuffer
1152: FA58 32 A2 FB               LD     (WriteType),A        ; 4. Fake a clean sector Write type = 02
1153: FA5B C3 88 FA               JP     CommonDiskIO         ; Use common code to execute read
1154: FA5E         ;---------------------------------------------------------------------------
1155: FA5E         ;	WRITE			BIOS 0E
1156: FA5E         ;
1157: FA5E         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
1158: FA5E         ;
1159: FA5E         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
1160: FA5E         ;	00H [WriteAllocated]	An already allocated allocation block (which means a pre-read of the sector may be needed),
1161: FA5E         ;	01H [WriteDirectory]	To the directory (in which case the data will be written to the disk immediately),
1162: FA5E         ;	02H [WriteCleanBuffer]	To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
1163: FA5E
1164: FA5E         ;  WRITE is similar to READ but with the obvious difference that data is transferred from the DMA buffer
1165: FA5E         ; to the specified 128-byte sector. Like READ, this function requires that the following function calls
1166: FA5E         ; have already been made:
1167: FA5E         ; 				- SELDSK	"select" the disk
1168: FA5E         ; 				- SETDMA	set the DMA address
1169: FA5E         ; 				- SETTRK	set the track number
1170: FA5E         ; 				- SETSEC	set the sector number.
1171: FA5E         ;
1172: FA5E         ;  Again, it is only in the WRITE routine that the driver will start to talk directly to the physical hardware,
1173: FA5E         ; selecting the disk unit, track, and sector, and transferring the data to the disk. With the blocking/deblocking code,
1174: FA5E         ; the BDOS optimizes the number of disk writes that are needed by indicating in register C the type of disk write
1175: FA5E         ; that is to be performed:
1176: FA5E         ; 				0= normal sector write
1177: FA5E         ; 				1= write to file directory sector
1178: FA5E         ; 				2 = write to sector of previously unchanged Deblocking Buffer
1179: FA5E         ;
1180: FA5E         ;  Type 0 occurs whenever the BDOS is writing to a data sector in an already used allocation block.
1181: FA5E         ; Under these circumstances, the disk driver must preread the appropriate host sector because there
1182: FA5E         ; may be previously stored information on it.
1183: FA5E         ;
1184: FA5E         ;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in this case, the BIOS must not defer
1185: FA5E         ; writing the sector to the disk, as the information is too valuable to hold in memory until the HSTBUF is full.
1186: FA5E         ; The longer the information resides in the HSTBUF, the greater the chance of a power failure or glitch,
1187: FA5E         ; making file data already physically written to the disk inaccessible because the file directory is out of date.
1188: FA5E         ;
1189: FA5E         ;  Type 2 occurs whenever the BDOS needs to write to the first sector of a previously unused allocation block.
1190: FA5E         ; Unused, in this context, includes an allocation block that has become available as a result of a file being erased.
1191: FA5E         ; In this case, there is no need for the disk driver to preread an entire host-sized sector into the HSTBUF,
1192: FA5E         ; as there is no data of value in the physical sector.
1193: FA5E         ;
1194: FA5E         ;  As with the READ routine, the WRITE function returns with A set to OOH if the operation has been completed successfully.
1195: FA5E         ; If the WRITE function returns with A set to 01H, then the BDOS will display the same message as for READ:
1196: FA5E         ; BDOS Err on X: Bad Sector
1197: FA5E
1198: FA5E
1199: FA5E             WRITE:
1200: FA5E         ; BlockingBuffer I/O
1201: FA5E AF                     XOR    A
1202: FA5F 32 B8 FB               LD     (ReadWriteFlag),A    ; Set to zero to indicate that this is a Write
1203: FA62 79                     LD     A,C
1204: FA63 32 A2 FB               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
1205: FA66
1206: FA66 FE 02                  CP     WriteCleanBuffer     ; first, is this a clean Allocation Buffer block ?
1207: FA68 C2 76 FA               JP     NZ,CheckDirtyBuffer  ; No
1208: FA6B
1209: FA6B         ;Write from a clean Host Buffer
1210: FA6B 21 AA FB               LD     HL,SelectedState
1211: FA6E 11 B1 FB               LD     DE,HostBufferState
1212: FA71 01 04 00               LD     BC,SelectedDiskStateSize
1213: FA74 ED B0                  LDIR                        ; copy Selected State to Host Buffer state
1214: FA76
1215: FA76             CheckDirtyBuffer:
1216: FA76
1217: FA76 21 AA FB               LD     HL,SelectedState
1218: FA79 11 B1 FB               LD     DE,HostBufferState
1219: FA7C CD 1E FB               CALL   CompareDkTrkSec      ; is it in Host Buffer?
1220: FA7F 3E FF                  LD     A,TRUE               ;......
1221: FA81 C2 85 FA               JP     NZ,SetPreread        ; NO - Then we need to load the Host Buffer
1222: FA84
1223: FA84 AF                     XOR    A
1224: FA85             SetPreread:
1225: FA85 32 B7 FB               LD     (PrereadSectorFlag),A ; clear preread flag
1226: FA88         ;*******************************************************
1227: FA88         ; Common code to execute both reads and writes of 128-byte records
1228: FA88         ;*******************************************************
1229: FA88             CommonDiskIO:
1230: FA88 AF                     XOR    A                    ; Assume no disk error will occur
1231: FA89 32 B6 FB               LD     (DiskStatus),A
1232: FA8C
1233: FA8C         ;-------------------------Convert selected record into physical sector-----------;
1234: FA8C 3A AD FB               LD     A,(SelectedRecord)   ;
1235: FA8F 1F                     RRA                         ; Convert selected record                ;
1236: FA90 1F                     RRA                         ; into physical sector by dividing by 4  ;
1237: FA91 E6 3F                  AND    03FH                 ; Remove unwanted bits                   ;
1238: FA93 32 B0 FB               LD     (SelectedSector),A   ;
1239: FA96         ;-------------------------Convert selected record into physical sector-----------;
1240: FA96
1241: FA96         ;------------------------- Any Data in Buffer -----------------------------------;
1242: FA96         ;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes 		 ;
1243: FA96
1244: FA96 21 A7 FB               LD     HL,DataInBufferFlag  ; See if there is any data here ?        ;
1245: FA99 7E                     LD     A,(HL)               ;
1246: FA9A 36 FF                  LD     (HL),TRUE            ; Force flag true                        ;
1247: FA9C B7                     OR     A                    ; Was  any data here ?                   ;
1248: FA9D CA BD FA               JP     Z,SetIOBufferState   ; NO ?- go read into buffer              ;
1249: FAA0         ;------------------------- Any Data in Buffer -----------------------------------;
1250: FAA0
1251: FAA0         ;-----------------------------test for  the sector in the buffer-----------------;
1252: FAA0 11 A3 FB               LD     DE,IOBufferState     ; get the Buffer Disk and Track          ;
1253: FAA3 21 AA FB               LD     HL,SelectedState     ; get the requested Disk and Track       ;
1254: FAA6 CD 19 FB               CALL   CompareDkTrk         ; Are they the same ?                    ;
1255: FAA9 C2 B6 FA               JP     NZ,DataNotInBuffer   ; NO,jump - it must be read 				 ;
1256: FAAC         ;
1257: FAAC         ; Yes, the disk, track are the same are the sectors the same ?                   ;
1258: FAAC         ;
1259: FAAC 3A A6 FB               LD     A,(IOBufferSector)   ; get the sector                         ;
1260: FAAF 21 B0 FB               LD     HL,SelectedSector    ;
1261: FAB2 BE                     CP     M                    ; Check if correct physical sector       ;
1262: FAB3 CA DA FA               JP     Z,DataIsInBuffer     ; Yes - it is already in memory          ;
1263: FAB6         ;-----------------------------test for  the sector in the buffer-----------------;
1264: FAB6
1265: FAB6         ;------------------------- Do we have to write out the buffer ?------------------;
1266: FAB6             DataNotInBuffer:                      ;
1267: FAB6 3A A8 FB               LD     A,(DirtyBufferFlag)  ;
1268: FAB9 B7                     OR     A                    ; do we need to write ?                  ;
1269: FABA C4 2A FB               CALL   NZ,WritePhysical     ; if yes - write it out                  ;
1270: FABD         ;------------------------- Do we have to write out the buffer ?------------------;
1271: FABD
1272: FABD         ;------------------------- prepare for physical IO ------------------------------;
1273: FABD             SetIOBufferState:                      ;
1274: FABD         ; indicate the  selected disk, track, and sector not residing in buffer          ;
1275: FABD 3A AA FB               LD     A,(SelectedDisk)     ;
1276: FAC0 32 A3 FB               LD     (IOBufferDisk),A     ;
1277: FAC3 2A AB FB               LD     HL,(SelectedTrack)   ;
1278: FAC6 22 A4 FB               LD     (IOBufferTrack),HL   ;
1279: FAC9         ;
1280: FAC9 3A B0 FB               LD     A,(SelectedSector)   ;
1281: FACC 32 A6 FB               LD     (IOBufferSector),A   ;
1282: FACF         ;------------------------- prepare for physical IO ------------------------------;
1283: FACF
1284: FACF         ;------------------------- Read the data if needed, or its already in the buffer -;
1285: FACF 3A B7 FB               LD     A,(PrereadSectorFlag) ; do we need to preread ?                 ;
1286: FAD2 B7                     OR     A                    ;
1287: FAD3 C4 2F FB               CALL   NZ,ReadPhysical      ; yes - preread the sector                ;
1288: FAD6         ;
1289: FAD6         ; At this point the data is in the buffer.                                        ;
1290: FAD6         ; Either it was already here, or we returned from ReadPhysical                    ;
1291: FAD6         ;
1292: FAD6 AF                     XOR    A                    ;
1293: FAD7 32 A8 FB               LD     (DirtyBufferFlag),A  ; Reset the DirtyBufferFlag	          ;
1294: FADA         ;------------------------- Read the data if needed, or its already in the buffer -;
1295: FADA
1296: FADA
1297: FADA         ; The Buffer now has the data we want to Read/Write
1298: FADA         ;-------------------------Calculate the address of the record in the sector ------;
1299: FADA         ;
1300: FADA             DataIsInBuffer:                      ;
1301: FADA 3A AD FB               LD     A,(SelectedRecord)   ;
1302: FADD E6 03                  AND    SectorMask           ; Want relative record number in Sector   ;
1303: FADF 3C                     INC    A                    ; Adjust for DJNZ                         ;
1304: FAE0 47                     LD     B,A                  ;
1305: FAE1 11 80 00               LD     DE,cpmRecordSize     ;
1306: FAE4 21 80 FF               LD     HL,-cpmRecordSize    ;
1307: FAE7             SectorInBuffer1:                      ;
1308: FAE7 19                     ADD    HL,DE                ; RecordNumber * recordSize               ;
1309: FAE8 10 FD                  DJNZ   SectorInBuffer1      ;  yields index into the Sector           ;
1310: FAEA         ;
1311: FAEA 11 40 F6               LD     DE,DiskBuffer        ; Start of sector                         ;
1312: FAED 19                     ADD    HL,DE                ; HL -> start of record in buffer 		  ;
1313: FAEE ED 5B AE FB               LD     DE,(DMAAddress)      ; Callers  DMA Address                    ;
1314: FAF2         ;
1315: FAF2         ;-------------------------Calculate the address of the record in the sector ------;
1316: FAF2
1317: FAF2
1318: FAF2         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1319: FAF2         ;
1320: FAF2 3A B8 FB               LD     A,(ReadWriteFlag)    ; 0 => Write, non Zero => Read            ;
1321: FAF5 B7                     OR     A                    ; Write: move data from DMA to Buffer     ;
1322: FAF6 C2 FE FA               JP     NZ,BufferMove        ; Read : move data from Buffer to DMA     ;
1323: FAF9         ;
1324: FAF9 3C                     INC    A                    ; Set the flag to indicate dirty buffer   ;
1325: FAFA 32 A8 FB               LD     (DirtyBufferFlag),A  ;
1326: FAFD EB                     EX     DE,HL                ; Swap source and destination for write   ;
1327: FAFE         ;
1328: FAFE         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1329: FAFE
1330: FAFE
1331: FAFE             BufferMove:
1332: FAFE 01 80 00               LD     BC,cpmRecordSize
1333: FB01 ED B0                  LDIR                        ; Move data to/from Host Buffer
1334: FB03
1335: FB03 3A A2 FB               LD     A,(WriteType)        ; Is this a write to the directory ?
1336: FB06 FE 01                  CP     WriteDirectory
1337: FB08 3A B6 FB               LD     A,(DiskStatus)       ; Set ACC with disk status if an immediate return
1338: FB0B C0                     RET    NZ                   ; Return if not updating a directory entry
1339: FB0C
1340: FB0C B7                     OR     A                    ; Check for any disk errors ?
1341: FB0D C0                     RET    NZ                   ; If yes - abandon attempt to write to directory
1342: FB0E
1343: FB0E AF                     XOR    A
1344: FB0F 32 A8 FB               LD     (DirtyBufferFlag),A  ; Clear the dirty buffer flag
1345: FB12 CD 2A FB               CALL   WritePhysical        ; do an immediate update of the directory to disk
1346: FB15 3A B6 FB               LD     A,(DiskStatus)       ; Set ACC with disk status
1347: FB18 C9                     RET
1348: FB19         ;********************************************************************
1349: FB19
1350: FB19
1351: FB19         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
1352: FB19             CompareDkTrk:
1353: FB19 01 03 00               LD     BC,03H
1354: FB1C 18 03                  JR     CompareDkTrkSecLoop
1355: FB1E             CompareDkTrkSec:
1356: FB1E 01 04 00               LD     BC,04H
1357: FB21             CompareDkTrkSecLoop:
1358: FB21 1A                     LD     A,(DE)               ; Get value
1359: FB22 13                     INC    DE                   ; anticipate next iteration
1360: FB23 ED A1                  CPI                         ; does A = (HL)
1361: FB25 C0                     RET    NZ                   ; Not a match exit
1362: FB26 EA 21 FB               JP     PE,CompareDkTrkSecLoop ; Loop if not done
1363: FB29 C9                     RET
1364: FB2A
1365: FB2A
1366: FB2A         ;************************************************
1367: FB2A         ;			Physical Disk IO					*
1368: FB2A         ;************************************************
1369: FB2A
1370: FB2A         ;Write contents of disk buffer to correct sector
1371: FB2A             WritePhysical:
1372: FB2A 3E 02                  LD     A,DiskWriteCode      ; get write function
1373: FB2C C3 31 FB               JP     CommonPhysical
1374: FB2F
1375: FB2F             ReadPhysical:
1376: FB2F 3E 01                  LD     A,DiskReadCode       ; get read function
1377: FB31
1378: FB31         ; Set up the Dick Control Table DCT
1379: FB31             CommonPhysical:
1380: FB31         ;Command
1381: FB31 32 95 FB               LD     (DCTCommand),A       ; set the command for Read or Write
1382: FB34         ;Disk
1383: FB34 3A A3 FB               LD     A,(IOBufferDisk)
1384: FB37 E6 03                  AND    03H                  ; only units 0 to 3
1385: FB39 32 96 FB               LD     (DCTDisk),A          ; set disk
1386: FB3C         ;Track
1387: FB3C 2A A4 FB               LD     HL,(IOBufferTrack)
1388: FB3F 7D                     LD     A,L                  ; for this controller it is a byte value
1389: FB40 32 98 FB               LD     (DCTTrack),A         ; set track
1390: FB43         ;Head and Track	Calculations
1391: FB43         ; The sector must be converted into a head number and sector number.
1392: FB43         ;	Head = (int) Sector / SectorsPerHead
1393: FB43         ;	Sector = Sector MOD SectorsPerHead
1394: FB43             DetermineHead:
1395: FB43 06 00                  LD     B,0                  ; Start at head 0
1396: FB45 21 A9 FB               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1397: FB48 3A A6 FB               LD     A,(IOBufferSector)   ; get target sector
1398: FB4B             DetermineHead1:
1399: FB4B BE                     CP     M                    ; Need another Head?
1400: FB4C DA 54 FB               JP     C,HeadFound          ; nope done with head calculation
1401: FB4F
1402: FB4F 96                     SUB    M                    ; subtract track value
1403: FB50 04                     INC    B                    ; Increment head
1404: FB51 C3 4B FB               JP     DetermineHead1       ; loop for next head value
1405: FB54
1406: FB54         ;Sector
1407: FB54             HeadFound:                      ; ACC now has Sector MOD SectorsPerHead
1408: FB54 3C                     INC    A                    ; physical sectors start at 1
1409: FB55 32 99 FB               LD     (DCTSector),A        ; set sector
1410: FB58         ;Head
1411: FB58 78                     LD     A,B
1412: FB59 32 97 FB               LD     (DCTHead),A          ; set head number
1413: FB5C         ;Byte Count
1414: FB5C 21 00 02               LD     HL,diskSectorSize
1415: FB5F 22 9A FB               LD     (DCTByteCount),HL    ; set byte count
1416: FB62         ;DMA
1417: FB62 21 40 F6               LD     HL,DiskBuffer
1418: FB65 22 9C FB               LD     (DCTDMAAddress),HL   ; set transfer address
1419: FB68
1420: FB68         ; Since only one control table is in use, close the status and busy chain pointers
1421: FB68         ; back to the main control bytes
1422: FB68         ;NextStatusBlock
1423: FB68 21 43 00               LD     HL,DiskStatusLocation
1424: FB6B 22 9E FB               LD     (DCTNextStatusBlock),HL
1425: FB6E         ;NextControlLocation
1426: FB6E 21 45 00               LD     HL,DiskControlByte
1427: FB71 22 A0 FB               LD     (DCTNextControlLocation),HL
1428: FB74
1429: FB74         ;Put  DCT pointer in page0
1430: FB74 21 95 FB               LD     HL,DCTCommand
1431: FB77 22 46 00               LD     (DiskCommandBlock),HL
1432: FB7A         ; Make the IO happen
1433: FB7A 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1434: FB7D 36 80                  LD     (HL),080H
1435: FB7F
1436: FB7F         ;Wait until Disk Status Block indicates the operation is complete,
1437: FB7F             WaitForDiskComplete:
1438: FB7F 7E                     LD     A,(HL)               ; get control bytes
1439: FB80 B7                     OR     A
1440: FB81 C2 7F FB               JP     NZ,WaitForDiskComplete ; operation not done
1441: FB84
1442: FB84
1443: FB84         ;Check if any errors occurred.
1444: FB84 3A 43 00               LD     A,(DiskStatusLocation)
1445: FB87 DA 8F FB               JP     C,DiskError
1446: FB8A AF                     XOR    A
1447: FB8B 32 B6 FB               LD     (DiskStatus),A       ; clear the flag
1448: FB8E C9                     RET
1449: FB8F
1450: FB8F         ; set error flag and return
1451: FB8F             DiskError:
1452: FB8F 3E 01                  LD     A,1
1453: FB91 32 B6 FB               LD     (DiskStatus),A       ; set the error flag
1454: FB94 C9                     RET
1455: FB95
1456: FB95         ;********************************************************************
1457: FB95         ;********************************************************************
1458: FB95         ;********************************************************************
1459: FB95
1460: FB95         ;---------------------------------------------------------------------------
1461: FB95         ;	Disk Data
1462: FB95         ;---------------------------------------------------------------------------
1463: FB95         ;	Disk Equates
1464: FB95         ;---------------------------------------------------------------------------
1465: FB95         ; Disk Types
1466: FB95         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1467: FB95         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1468: FB95         ;;HardDisk	EQU	2						; hard disk
1469: FB95         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1470: FB95
1471: FB95
1472: FB95         ;**************************************************************************************************
1473: FB95         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1474: FB95         ;
1475: FB95         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1476: FB95         ; perform some disk operation.  These are called its disk control byte.
1477: FB95         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1478: FB95         ; following the respective control bytes. This word must contain the address of  valid disk control
1479: FB95         ; table that specifies the exact disk operation to be performed.
1480: FB95         ;
1481: FB95         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1482: FB95         ; This indicates completion to the disk driver code.
1483: FB95         ;
1484: FB95         ;  The controller also sets a return code in a disk status block - location 0X43H.
1485: FB95         ; If the first byte of this status block is less than 80H. then a disk error
1486: FB95         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1487: FB95         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1488: FB95         ; ten times before the controller returns an error
1489: FB95         ;
1490: FB95         ;  The disk control table layout is shown below. Note that the controller has the capability
1491: FB95         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1492: FB95         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1493: FB95         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1494: FB95         ; the end of the chain
1495: FB95         ;**************************************************************************************************
1496: FB95
1497: FB95         ;***************************************************************************
1498: FB95         ;	Disk Control tables
1499: FB95         ;***************************************************************************
1500: FB95         ;;DiskControlTable:
1501: FB95             DCTStart:
1502: FB95 00          DCTCommand: DB     00H                  ; Command
1503: FB96 00          DCTDisk:   DB     00H                  ; unit (drive) number = 0 or 1
1504: FB97 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1505: FB98 00          DCTTrack:  DB     00H                  ; track number
1506: FB99 00          DCTSector: DB     00H                  ; sector number
1507: FB9A 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1508: FB9C 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1509: FB9E 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1510: FBA0 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1511: FBA2             DCTEnd:
1512: FBA2             DCTSize    EQU    DCTEnd-DCTStart
1513: FBA2         ;-----------------------------------------
1514: FBA2         ;WriteAllocated		EQU	00H		W_NORMAL
1515: FBA2         ;WriteDirectory		EQU	01H		W_DIRECTORY
1516: FBA2         ;WriteCleanBuffer	EQU	02H		W_NEW_BLOCK
1517: FBA2         ;-----------------------------------------
1518: FBA2
1519: FBA2 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1520: FBA3
1521: FBA3         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1522: FBA3             IOBufferState:
1523: FBA3 00          IOBufferDisk: DB     00H
1524: FBA4 00 00       IOBufferTrack: DW     00H
1525: FBA6 00          IOBufferSector: DB     00H
1526: FBA7 00          DataInBufferFlag: DB     00H                  ; when non-zero, the disk buffer has data from disk
1527: FBA8 00          DirtyBufferFlag: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1528: FBA9         ;   but not yet written out to the disk
1529: FBA9         ;---------------------------------------------------------------------------
1530: FBA9         ;	Disk Storage area
1531: FBA9         ;---------------------------------------------------------------------------
1532: FBA9         ;     variables for selected disk, track and sector
1533: FBA9         ; These are moved and compared as a group, DO NOT ALTER
1534: FBA9
1535: FBA9 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1536: FBAA
1537: FBAA             SelectedState:
1538: FBAA 00          SelectedDisk: DB     00H
1539: FBAB 00 00       SelectedTrack: DW     0000H
1540: FBAD 00          SelectedRecord: DB     00H
1541: FBAE
1542: FBAE             SelectedDiskStateEnd:
1543: FBAE             SelectedDiskStateSize EQU    SelectedDiskStateEnd - SelectedDisk
1544: FBAE
1545: FBAE 00 00       DMAAddress: DW     0000H                ; DMA address
1546: FBB0
1547: FBB0 00          SelectedSector: DB     00H
1548: FBB1
1549: FBB1         ; Parameters for the records in the Fresh Allocation Block
1550: FBB1         ; These are moved and compared as a group, DO NOT ALTER
1551: FBB1
1552: FBB1             HostBufferState:
1553: FBB1 00          HostBufferDisk: DB     00H
1554: FBB2 00 00       HostBufferTrack: DW     0000H
1555: FBB4 00          HostBufferRecord: DB     00H
1556: FBB5
1557: FBB5 00          ModifiedlRecordsCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1558: FBB6 00          DiskStatus: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1559: FBB7         ; Flags used inside the de-blocking code
1560: FBB7 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1561: FBB8         ; either before a write to a allocated block can occur, or
1562: FBB8         ; for a normal cpmRecord read
1563: FBB8 00          ReadWriteFlag: DB     00H                  ; 0 => Write-  Non-zero =>read
1564: FBB9
1565: FBB9         ;---------------------------------------------------------------------------
1566: FBB9
1567: FBB9         ;---------------------------------------------------------------------------
1568: FBB9         ;	Disk Definition Tables
1569: FBB9         ; These consists of disk parameter headers, with one entry
1570: FBB9         ; per logical disk driver, and disk parameter blocks, with
1571: FBB9         ; either one parameter block per logical disk or the same
1572: FBB9         ; parameter block for several logical disks.
1573: FBB9         ;---------------------------------------------------------------------------
1574: FBB9         ;---------------------------------------------------------------------------
1575: FBB9             DiskParameterHeaders:
1576: FBB9
1577: FBB9         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1578: FBB9 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1579: FBBB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1580: FBBD 00 00                  DW     0000H                ; Last Selected Track #
1581: FBBF 00 00                  DW     0000H                ; Last Selected Sector #
1582: FBC1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1583: FBC3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1584: FBC5 09 FC                  DW     DiskAWorkArea
1585: FBC7 89 FC                  DW     DiskAAllocationVector
1586: FBC9
1587: FBC9         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1588: FBC9 00 00                  DW     0000H                ; No Skew table
1589: FBCB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1590: FBCD 00 00                  DW     0000H                ; Last Selected Track #
1591: FBCF 00 00                  DW     0000H                ; Last Selected Sector #
1592: FBD1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1593: FBD3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1594: FBD5 29 FC                  DW     DiskBWorkArea
1595: FBD7 E2 FC                  DW     DiskBAllocationVector
1596: FBD9
1597: FBD9         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1598: FBD9 00 00                  DW     0000H                ; No Skew table
1599: FBDB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1600: FBDD 00 00                  DW     0000H                ; Last Selected Track #
1601: FBDF 00 00                  DW     0000H                ; Last Selected Sector #
1602: FBE1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1603: FBE3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1604: FBE5 49 FC                  DW     DiskCWorkArea
1605: FBE7 3B FD                  DW     DiskCAllocationVector
1606: FBE9
1607: FBE9         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1608: FBE9 00 00                  DW     0000H                ; No Skew table
1609: FBEB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1610: FBED 00 00                  DW     0000H                ; Last Selected Track #
1611: FBEF 00 00                  DW     0000H                ; Last Selected Sector #
1612: FBF1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1613: FBF3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1614: FBF5 69 FC                  DW     DiskDWorkArea
1615: FBF7 94 FD                  DW     DiskDAllocationVector
1616: FBF9
1617: FBF9
1618: FBF9         ;-----------------------------------------------------------
1619: FBF9
1620: FBF9             ParameterBlock3HD:
1621: FBF9 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1622: FBFB 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1623: FBFC 0F                     DB     dpb3hdBLM            ; Block mask
1624: FBFD 00                     DB     dpb3hdEXM            ; Extent mask
1625: FBFE C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1626: FC00 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1627: FC02 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1628: FC03 00                     DB     dpb3hdAL1            ;  for file directory
1629: FC04 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1630: FC06 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1631: FC08
1632: FC08 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1633: FC09
1634: FC09
1635: FC09
1636: FC09         ;---------------------------------------------------------------------------
1637: FC09         ;	Disk work area
1638: FC09         ;---------------------------------------------------------------------------
1639: FC09         ; These are used by the BDOS to detect any unexpected
1640: FC09         ; change of diskette. The BDOS will automatically set
1641: FC09         ; such a changed diskette to read-only status.
1642: FC09
1643: FC09             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1644: FC29             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1645: FC49             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1646: FC69             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1647: FC89
1648: FC89         ;---------------------------------------------------------------------------
1649: FC89         ;	Disk allocation vectors
1650: FC89         ;---------------------------------------------------------------------------
1651: FC89         ; Disk allocation vectors
1652: FC89         ; These are used by the BDOS to maintain a bit map of
1653: FC89         ; which allocation blocks are used and which are free.
1654: FC89         ; One byte is used for eight allocation blocks, hence the
1655: FC89         ; expression of the form (allocation blocks/8)+1
1656: FC89
1657: FC89             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1658: FCE2             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1659: FD3B
1660: FD3B             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1661: FD94             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1662: FDED         ;---------------------------------------------------------------------------
1663: FDED         ;	Disk Buffer
1664: FDED         ;---------------------------------------------------------------------------
1665: FDED             DirectoryBuffer: DS     DirBuffSize
           ************************   Xref   ************************
0000: $               FDED   0324
0774: AddressDataIn   F97A   0772
0789: AddressDataOut  F98A   0786
0799: AddressStatus   F993   0797
0328: AfterDiskBuffer F840
0090: ASCII_A         0041
0091: ASCII_C         0043
0092: ASCII_K         004B
0099: ASCII_LO_A      0061
0100: ASCII_LO_K      006B
0101: ASCII_LO_P      0070
0042: ASCII_MASK      007F   0780
0093: ASCII_N         004E
0094: ASCII_Q         0051
0095: ASCII_R         0052
0096: ASCII_W         0057
0097: ASCII_Y         0059
0077: ASCII_ZERO      0030
0071: ASTERISK        002A
0156: BDOSBase        E800   0157 0159
0125: BDOSE           0005   0126 0546 0548
0157: BDOSEntry       E806   0547
0146: BDOSLength      0E00   0149 0159 0160 0565
0060: BELL            0007
0159: BIOSBase        F600
0147: BIOSLength      0A00   0149
0119: BIOSPAGE        0002
0160: BIOSStart       F600   0300
0256: BlockSize       0800   0278
0357: BOOT            F840   0304
0293: BOOT_CON_ADDRESS 00EC   0402
1331: BufferMove      FAFE   1322
0038: BYTE            0001
0098: CARET           005E
0154: CCPEntry        E000   0156 0160 0528 0556 0566
0145: CCPLength       0800   0149 0156 0160 0565
1215: CheckDirtyBuffer FA76   1207
0302: CodeStart       F600
0078: COLON           003A
0842: COM_DataPort    00EC   0886
0844: COM_InputMask   0002   0888
0843: COM_OutputMask  0001   0887
0841: COM_StatusPort  00ED   0885
0884: COM_Table       F9C2   0916 0926
0073: COMMA           002C
1229: CommonDiskIO    FA88   1153
1379: CommonPhysical  FB31   1373
1352: CompareDkTrk    FB19   1254
1355: CompareDkTrkSec FB1E   1219
1357: CompareDkTrkSecLoop FB21   1354 1362
0131: ComTail         0080   0132
0133: ComTailChars    0082
0132: ComTailCount    0081   0133
0913: CON_Vector      F9E0   0587 0631
0609: ConIn           F901   0611
0608: CONIN           F901   0308
0628: CONOUT          F90D   0309
0629: CONOut          F90D
0584: CONST           F8EF   0307
0585: ConStatus       F8EF   0610
0233: cpmRecordSize   0080   0235 0238 0240 1305 1306 1332
0063: CR              000D   0407 0409 0411 0414
0837: CRT_DataPort    0001   0878
0839: CRT_InputMask   007F   0880
0838: CRT_OutputMask  0080   0879
0836: CRT_StatusPort  0002   0877
0876: CRT_Table       F9B8   0915 0920 0927 0930
0046: CTRL_C          0003
0047: CTRL_E          0005
0048: CTRL_H          0008
0049: CTRL_K          000B
0050: CTRL_L          000C
0051: CTRL_P          0010
0052: CTRL_R          0012
0053: CTRL_S          0013
0054: CTRL_U          0015
0055: CTRL_X          0018
0056: CTRL_Z          001A
0074: DASH            002D
0267: DataBlocks      02C7   0277
1526: DataInBufferFlag FBA7   0982 1244
1300: DataIsInBuffer  FADA   1262
1266: DataNotInBuffer FAB6   1255
0858: DataPortIndex   0001   0771 0785
0770: DataRead        F973   0779 0882 0890 0898
0778: DataReadASCII   F97C   0873
0862: DataReadIndex   0006   0613 0614 0714 0715
0266: DataSectors     0B1C   0267
0784: DataWrite       F982   0874 0883 0891 0899
0863: DataWriteIndex  0008   0638 0639
1507: DCTByteCount    FB9A   1415
1502: DCTCommand      FB95   1381 1430
1503: DCTDisk         FB96   1385
1508: DCTDMAAddress   FB9C   1418
1511: DCTEnd          FBA2   1512
1504: DCTHead         FB97   1412
1510: DCTNextControlLocation FBA0   1427
1509: DCTNextStatusBlock FB9E   1424
1506: DCTSector       FB99   1409
1512: DCTSize         000D
1501: DCTStart        FB95   1512
1505: DCTTrack        FB98   1389
1394: DetermineHead   FB43
1398: DetermineHead1  FB4B   1404
0238: DirBuffSize     0080   1665
0253: DirectoryBlockCount 0002   0278
1665: DirectoryBuffer FDED   1582 1592 1602 1612
0240: DirectoryEntryPerRecord 0004   0281
0237: DirEntrySize    0020   0240 0278
1527: DirtyBufferFlag FBA8   0979 1267 1293 1325 1344
1657: DiskAAllocationVector FC89   1585
1643: DiskAWorkArea   FC09   1584
1658: DiskBAllocationVector FCE2   1595
0326: DiskBuffer      F640   1311 1417
1644: DiskBWorkArea   FC29   1594
1660: DiskCAllocationVector FD3B   1605
0225: DiskCommandBlock 0046   0367 1431
0224: DiskControlByte 0045   0369 0568 1426 1433
0227: DiskControlTable 0040   0392
1645: DiskCWorkArea   FC49   1604
1661: DiskDAllocationVector FD94   1615
1646: DiskDWorkArea   FC69   1614
1451: DiskError       FB8F   1445
1575: DiskParameterHeaders FBB9   1019
0229: DiskReadCode    0001   0384 0560 1376
0234: diskSectorSize  0200   0235 0256 0264 0327 0389 1414
1558: DiskStatus      FBB6   1231 1337 1346 1447 1453
0223: DiskStatusLocation 0043   0377 0391 0567 1423 1444
0230: DiskWriteCode   0002   1372
0398: DisplayMessage  F86F   0404 0534
1545: DMAAddress      FBAE   1086 1313
0136: DMABuffer       0080   0550
0067: DOLLAR          0024
0279: dpb3hdAL0       00C0   1627
0280: dpb3hdAL1       0000   1628
0275: dpb3hdBLM       000F   1623
0274: dpb3hdBSH       0004   1622
0281: dpb3hdCKS       0020   1629 1643 1644 1645 1646
0278: dpb3hdDRM       007F   0281 1626
0277: dpb3hdDSM       02C6   1625 1657 1658 1660 1661
0276: dpb3hdEXM       0000   1624
0283: dpb3hdNOH       0002   1632
0282: dpb3hdOFF       0001   1630
0273: dpb3hdSPT       0090   1621 1632
0852: DUMMY_DataPort  0010   0902
0854: DUMMY_InputMask 007F   0904
0853: DUMMY_OutputMask 00FF   0903
0851: DUMMY_StatusPort 0011   0901
0900: DUMMY_Table     F9D6   0917 0921 0922 0925 0932
0808: DUMMYCheck      F998   0905
0804: DUMMYRead       F996   0906
0806: DUMMYWrite      F997   0907
0140: END_OF_FILE     001A
0044: EndOfMessage    0000   0409 0414
0082: EQUAL_SIGN      003D
0065: EXCLAIM_POINT   0021
0033: FALSE           0000
0128: FCB1            005C   0129
0129: FCB2            006C
0173: fCloseFile      0010
0164: fConsoleIn      0001
0165: fConsoleOut     0002
0176: fDeleteFile     0013
0168: fGetConsoleStatus 000B
0182: fGetCurrentDisk 0019
0181: fGetLoginVector 0018
0184: fGetSetUserNumber 0020
0169: fGetVersion     000C
0179: fMakeFile       0016
0172: fOpenFile       000F
0166: fPrintString    0009
0177: fReadSeq        0014
0167: fReadString     000A
0180: fRenameFile     0017
0170: fResetSystem    000D
0174: fSearchFirst    0011
0175: fSearchNext     0012
0171: fSelectDisk     000E
0183: fSetDMA         001A
0178: fWriteSeq       0015
0589: GenericInStatus F8F6   0711
0633: GenericOutStatus F914   0658 0687
0635: GenericOutStatus1 F917   0637
0761: GetInStatus     F969   0591
0757: GetOutStatus    F964   0636 0747
0763: GetStatus       F96C   0760
0083: GREATER_THAN    003E
0066: HASH_TAG        0023
1407: HeadFound       FB54   1400
0978: HOME            FA00   0313
0983: HomeNoWrite     FA09   0981
1553: HostBufferDisk  FBB1
1555: HostBufferRecord FBB4
1552: HostBufferState FBB1   1211 1218
1554: HostBufferTrack FBB2
0295: IN_OPCODE       00DB   0773 0798
0860: InputMaskIndex  0003   0762
1523: IOBufferDisk    FBA3   1276 1383
1525: IOBufferSector  FBA6   1259 1281 1397
1522: IOBufferState   FBA3   1252
1524: IOBufferTrack   FBA4   1278 1387
0120: IOBYTE          0003   0586 0630 0654 0681 0706 0742
0297: JP_OPCODE       00C3   0540
0069: L_PAREN         0028
0086: LEFT_ARROW      005F
0102: LEFT_CURLY      007B
0149: LengthInBytes   2000   0150 0154 0264
0150: LengthInK       0009
0081: LESS_THAN       003C
0062: LF              000A   0407 0409 0411 0414
0653: LIST            F923   0310
0741: LISTST          F950   0320
0036: LO_NIBBLE_MASK  000F
0539: LoadPage0       F8C0   0531
0847: LPT_DataPort    0010   0894
0849: LPT_InputMask   007F   0896
0848: LPT_OutputMask  00FF   0895
0846: LPT_StatusPort  0011   0893
0892: LPT_Table       F9CC   0929 0931
0928: LST_Vector      F9F8   0657 0745
0152: MemorySize      0040   0154
1557: ModifiedlRecordsCount FBB5   1147
0265: myOffset        0001   0266 0282
0396: NoDisk          F86C   0363
0406: NoDiskMessage   F877   0397
0058: NULL            0000
0249: NumberOfHeads   0002   0260 0262 0273 0283
0246: NumberOfLogicalDisks 0004   1008
0035: OFF             0000
0034: ON              FFFF
0296: OUT_OPCODE      00D3   0788
0859: OutputMaskIndex 0002   0759
1620: ParameterBlock3HD FBF9   1583 1593 1603 1613
0068: PERCENT         0025
0075: PERIOD          002E
0123: Pg0CurentDisk   0004   0554
0122: Pg0CurentUser   0004   0123
0072: PLUS_SIGN       002B
1560: PrereadSectorFlag FBB7   1150 1225 1285
0923: PUN_Vector      F9F0   0686
0680: PUNCH           F92E   0311
0084: QMARK           003F
0070: R_PAREN         0029
0116: RAM             0000   0118 0119 0120 0122 0125 0128 0131 0136 0138
0918: RDR_Vector      F9E8   0709
1145: READ            FA4B   0318
0705: READER          F93B   0312
0710: READER1         F944   0712
1375: ReadPhysical    FB2F   1287
0366: ReadRawDisk     F84D   0360 0530
1563: ReadWriteFlag   FBB8   1149 1202 1320
0258: RecordsPerBlock 0010
0242: RecordsPerExtent 0080
0235: recordsPerSector 0004   0258 0273
0383: ROMControl      F85F   0359
0087: RUBOUT          007F
1307: SectorInBuffer1 FAE7   1309
0287: SectorMask      0003   1302
0252: SectorsPerBlock 0004   0256 0258 0261 0267 0287
0262: SectorsPerCylinder 0024   0265 0266
0251: SectorsPerTrack 0012   0260 0262 0273
1106: SECTRAN         FA48   0321
1005: SELDSK          FA0F   0314
1538: SelectedDisk    FBAA   1011 1275 1543
1542: SelectedDiskStateEnd FBAE   1543
1543: SelectedDiskStateSize 0004   1212
1535: SelectedDskSecsPerHead FBA9   1029 1396
1540: SelectedRecord  FBAD   1072 1234 1301
1547: SelectedSector  FBB0   1238 1260 1280
1537: SelectedState   FBAA   1210 1217 1253
1539: SelectedTrack   FBAB   1052 1277
0080: SEMICOLON       003B
0814: SetDeviceVector F99C   0590 0634 0746
1085: SETDMA          FA43   0317 0551
1273: SetIOBufferState FABD   1248
1224: SetPreread      FA85   1221
1070: SETSEC          FA3E   0316
1048: SETTRK          FA39   0315 0985
0076: SLASH           002F
0059: SOH             0001
0064: SPACE           0020
0857: StatusPortIndex 0000   0796
0795: StatusRead      F98C   0872 0881 0889 0897
0861: StatusReadIndex 0004   0764 0765
0264: SystemSectors   0011   0265
0061: TAB             0009
0126: TopRAM          0007
0261: TotalNumberOfBlocks 02D0
0260: TotalNumberOfSectors 0B40   0261 0266
0138: TPA             0100   0361 0390
0250: TracksPerHead   0050   0260
0032: TRUE            FFFF   1220 1246
0832: TTY_DataPort    00EC   0869
0834: TTY_InputMask   007F   0871
0833: TTY_OutputMask  0080   0870
0831: TTY_StatusPort  00ED   0868
0867: TTY_Table       F9AE   0914 0919 0924
0085: UNDER_SCORE     005F
0372: WaitForBootComplete F855   0375
1437: WaitForDiskComplete FB7F   1440
0118: WarmBoot        0000   0542 0544
0305: WarmBootEntry   F603   0543
0410: WarmBootErroMessage F892   0533
0527: WBOOT           F8AC   0306 0535
0559: WBOOTControl    F8E2   0529
0039: WORD            0002
1199: WRITE           FA5E   0319
0198: WriteAllocated  0000
0200: WriteCleanBuffer 0002   1151 1206
0199: WriteDirectory  0001   1336
1371: WritePhysical   FB2A   1269 1345
1519: WriteType       FBA2   1152 1204 1335
0043: ZERO            0000
