0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018-12-28 Version 1.0
0006: F600         ; 2018-12-28 Changed the READ & WRITE routines
0007: F600         ; 2018 12-27 Adjusted BOOT & WBOOT
0008: F600         ; 2018-12-10 Refactored  character device routines;
0009: F600         ; 2017-03-31 Added List out functionality for List Device
0010: F600         ; 2017-03-02 Refactored the CP/M Suite
0011: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0012: F600         ; 2014-01-16
0013: F600         ; 2014-03-14  :  Frank Martyn
0014: F600
0015: F600         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0016: F600         ; by Andy Johnson-Laird
0017: F600         ;
0018: F600         ; Published by
0019: F600         ; Osborne/McGraw-Hill
0020: F600         ; 2600 Tenth Street
0021: F600         ; Berkeley, California 94710
0022: F600         ; U.S.A.
0023: F600
0024: F600                        Include ./stdHeader.Z80
0025: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0026: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0027: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0028: F600         ; stdHeader.asm
0029: F600         ; standard equates
0030: F600
0031: F600         ; 2017-03-02 Refactored the CP/M Suite
0032: F600
0033: F600
0034: F600             TRUE       EQU    -1                   ; not false
0035: F600             FALSE      EQU    0000H
0036: F600             ON         EQU    -1
0037: F600             OFF        EQU    0000H
0038: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0039: F600
0040: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0041: F600             WORD       EQU    2                    ; number of bytes for "word" type
0042: F600
0043: F600
0044: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0045: F600             ZERO       EQU    00H                  ; Zero
0046: F600             EndOfMessage EQU    00H
0047: F600
0048: F600             CTRL_C     EQU    03H                  ; ETX
0049: F600             CTRL_E     EQU    05H                  ; physical eol
0050: F600             CTRL_H     EQU    08H                  ; backspace
0051: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0052: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0053: F600             CTRL_P     EQU    10H                  ; prnt toggle
0054: F600             CTRL_R     EQU    12H                  ; repeat line
0055: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0056: F600             CTRL_U     EQU    15H                  ; line delete
0057: F600             CTRL_X     EQU    18H                  ; =ctl-u
0058: F600             CTRL_Z     EQU    1AH                  ; end of file
0059: F600
0060: F600             NULL       EQU    00H                  ; Null
0061: F600             SOH        EQU    01H                  ; Start of Heading
0062: F600             BELL       EQU    07H                  ; Bell
0063: F600             TAB        EQU    09H                  ; Tab
0064: F600             LF         EQU    0AH                  ; Line Feed
0065: F600             CR         EQU    0DH                  ; Carriage Return
0066: F600             SPACE      EQU    20H                  ; Space
0067: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0068: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0069: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0070: F600             PERCENT    EQU    25H                  ; Percent Sign
0071: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0072: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0073: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0074: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0075: F600             COMMA      EQU    2CH                  ; Comma
0076: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0077: F600             PERIOD     EQU    2EH                  ; Period
0078: F600             SLASH      EQU    2FH                  ; /
0079: F600             ASCII_ZERO EQU    30H                  ; zero
0080: F600             COLON      EQU    3AH                  ; Colon
0081: F600
0082: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0083: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0084: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0085: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0086: F600             QMARK      EQU    3FH                  ; Question Mark
0087: F600             UNDER_SCORE EQU    5FH                  ; under score _
0088: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0089: F600             RUBOUT     EQU    7FH                  ; Delete Key
0090: F600
0091: F600
0092: F600             ASCII_A    EQU    'A'
0093: F600             ASCII_C    EQU    'C'
0094: F600             ASCII_K    EQU    'K'
0095: F600             ASCII_N    EQU    'N'
0096: F600             ASCII_Q    EQU    'Q'
0097: F600             ASCII_R    EQU    'R'
0098: F600             ASCII_W    EQU    'W'
0099: F600             ASCII_Y    EQU    'Y'
0100: F600             CARET      EQU    '^'
0101: F600             ASCII_LO_A EQU    'a'
0102: F600             ASCII_LO_K EQU    'k'
0103: F600             ASCII_LO_P EQU    'p'
0104: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0105: F600
0106: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0107: F600                        Include ./osHeader.Z80
0108: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0109: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0110: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0111: F600         ; osHeader.Z80
0112: F600
0113: F600         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0114: F600         ; 2017-03-02 Refactored the CP/M Suite
0115: F600
0116: F600         ; Contains the Equates used by the CP/M system
0117: F600
0118: F600         ;------------------------Page Zero Constants ---------------------------------
0119: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0120: F600
0121: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0122: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0123: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0124: F600
0125: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0126: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0127: F600
0128: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0129: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0130: F600
0131: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0132: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0133: F600
0134: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0135: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0136: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0137: F600         ;-----------------------------------------------------------------------
0138: F600
0139: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0140: F600         ;-----------------------------------------------------------------------
0141: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0142: F600         ;-----------------------------------------------------------------------
0143: F600             END_OF_FILE EQU    1AH                  ; end of file
0144: F600         ;-----------------------------------------------------------------------
0145: F600
0146: F600         ;--------------- CP/M Constants -----------------------------------------
0147: F600
0148: F600             CCPLength  EQU    0800H                ; Constant
0149: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0150: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0151: F600
0152: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0153: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0154: F600
0155: F600             MemorySize EQU    64
0156: F600
0157: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0158: F600
0159: F600             BDOSBase   EQU    CCPEntry + CCPLength
0160: F600             BDOSEntry  EQU    BDOSBase
0161: F600
0162: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0163: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0164: F600         ;-----------------------------------------------------------------------
0165: F600
0166: F600         ;------------------- BDOS System Call Equates --------------------------
0167: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0168: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0169: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0170: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0171: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0172: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0173: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0174: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0175: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0176: F600             fCloseFile EQU    10H                  ; closef - Close File
0177: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0178: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0179: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0180: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0181: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0182: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0183: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0184: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0185: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0186: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0187: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0188: F600         ;-----------------------------------------------------------------------
0189: F600
0190: F600
0191: F600
0192: F600
0193: F600
0194: F600         ;*******************************************************************************
0195: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0196: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0197: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0198: F600         ; sector write) or to an allocation block that has already been allocated to a
0199: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0200: F600         ;*******************************************************************************
0201: F600             WriteAllocated EQU    00H
0202: F600             WriteDirectory EQU    01H
0203: F600             WriteCleanBuffer EQU    02H
0204: F600
0205: F600
0206: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0207: F600                        Include ./diskHeader.Z80
0208: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0209: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0210: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0211: F600         ; diskHeader.asm
0212: F600
0213: F600         ; 2017-03-02 Refactored the CP/M Suite
0214: F600
0215: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0216: F600
0217: F600         ; Contains the Equates used by the CP/M system to handle disks
0218: F600
0219: F600
0220: F600         ;*******************************************************************************
0221: F600         ;
0222: F600         ;     Disk related values
0223: F600         ;
0224: F600         ;
0225: F600         ;*******************************************************************************
0226: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0227: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0228: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0229: F600         ; for boot
0230: F600             DiskControlTable EQU    0040H
0231: F600
0232: F600             DiskReadCode EQU    01H                  ; Code for Read
0233: F600             DiskWriteCode EQU    02H                  ; Code for Write
0234: F600
0235: F600
0236: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0237: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0238: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0239: F600
0240: F600             DirEntrySize EQU    20H                  ; (32)
0241: F600             DirBuffSize EQU    cpmRecordSize
0242: F600
0243: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0244: F600
0245: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0246: F600
0247: F600
0248: F600         ;-------------------------------------------------------------------------------------
0249: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0250: F600
0251: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0252: F600             NumberOfHeads EQU    02H                  ; number of heads
0253: F600             TracksPerHead EQU    50H                  ; 80
0254: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0255: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0256: F600             DirectoryBlockCount EQU    02H                  ;
0257: F600         ;-----------------------------------------------------------------------
0258: F600
0259: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0260: F600
0261: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0262: F600
0263: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0264: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0265: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0266: F600
0267: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0268: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0269: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0270: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0271: F600
0272: F600         ;-----------------------------------------------------------------------
0273: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0274: F600         ;-----------------------------------------------------------------------
0275: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0276: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0277: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0278: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0279: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0280: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0281: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0282: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0283: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0284: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0285: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0286: F600             dpb3hdNOH  EQU    NumberOfHeads
0287: F600
0288: F600         ;*******************************************************************************
0289: F600
0290: F600             SectorMask EQU    SectorsPerBlock - 1
0291: F600
0292: F600         ;***************************************************************************
0293: F600
0294: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0295: F600
0296: F600             BOOT_CON_ADDRESS EQU    0ECH                 ; tty data address
0297: F600
0298: F600             IN_OPCODE  EQU    0DBH
0299: F600             OUT_OPCODE EQU    0D3H
0300: F600             JP_OPCODE  EQU    0C3H
0301: F600             DISK_READ  EQU    0FFH
0302: F600             DISK_WRITE EQU    000H
0303: F600
0304: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0305: F600         ; BIOS jump Vector
0306: F600             CodeStart:
0307: F600
0308: F600 C3 33 F6               JP     BOOT                 ; 00 Cold/Hard Boot
0309: F603             WarmBootEntry:
0310: F603 C3 43 F6               JP     WBOOT                ; 01 Warm/Soft Boot
0311: F606 C3 E2 F6               JP     CONST                ; 02 Get Console Status - CON:
0312: F609 C3 F4 F6               JP     CONIN                ; 03 Get Character from Console - CON:
0313: F60C C3 00 F7               JP     CONOUT               ; 04 Send Character to Console - CON:
0314: F60F C3 16 F7               JP     LIST                 ; 05 Send Character to List device - LST:
0315: F612 C3 21 F7               JP     PUNCH                ; 06 Send Character to Punch device - PUN:
0316: F615 C3 2E F7               JP     READER               ; 07 Get Character from Reader - RDR:
0317: F618 C3 F3 F7               JP     HOME                 ; 08 Position the disk to absolute track 00
0318: F61B C3 04 F8               JP     SELDSK               ; 09 Establish disk to be used by subsequent Read/Write
0319: F61E C3 2E F8               JP     SETTRK               ; 0A Establish track to be used by subsequent Read/Write
0320: F621 C3 33 F8               JP     SETSEC               ; 0B Establish sector to be used by subsequent Read/Write
0321: F624 C3 38 F8               JP     SETDMA               ; 0C Establish buffer location to be used by subsequent Read/Write
0322: F627 C3 40 F8               JP     READ                 ; 0D Not Yet Checked
0323: F62A C3 4D F8               JP     WRITE                ; 0E Not Yet Checked
0324: F62D C3 43 F7               JP     LISTST               ; 0F Get List device Status - LST:
0325: F630 C3 3D F8               JP     SECTRAN              ; 10 De-skew sector number (null implementation)
0326: F633
0327: F633
0328: F633         ;=============================================================================;
0329: F633         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot                                   ;
0330: F633         ;                                                                             ;
0331: F633         ;  The BOOT jump instruction is the first instruction executed in CP/M. The   ;
0332: F633         ; bootstrap sequence must transfer control to the BOOT entry point in order   ;
0333: F633         ; to  bring up CP/M.                                                          ;
0334: F633         ;  This reads in the CP/M loader on the first sector of the physical disk     ;
0335: F633         ; drive chosen to be logical disk A. This CP/M loader program reads the       ;
0336: F633         ; binary image of the CCP, BOOS, and BIOS into memory at some predetermined   ;
0337: F633         ; address. Then it transfers control to the BOOT entry point in the BIOS      ;
0338: F633         ; jump vector. This BOOT routine must initialize all of the required          ;
0339: F633         ; computer hardware.                                                          ;
0340: F633         ;                                                                             ;
0341: F633         ;  Most BOOT routines sign on by displaying a short message on the console,   ;
0342: F633         ; indicating the current version ofCP/M and the computer hardware that this   ;
0343: F633         ; BIOS can support. The BOOT routine terminates by transferring control to    ;
0344: F633         ; the start of the CCP +6 bytes (the CCP has its own small jump vector at     ;
0345: F633         ; the beginning). Just before the BOOT routine jumps into the CCP, it sets    ;
0346: F633         ; the C register to 0 to indicate that logical disk A is to be the default    ;
0347: F633         ; disk drive. This is what causes "A>" to be the CCP's initial prompt.        ;
0348: F633         ;=============================================================================;
0349: F633
0350: F633             BOOT:
0351: F633         ;CodeStart:
0352: F633 21 D5 F6               LD     HL,ROMControl
0353: F636 CD 79 F6               CALL   ReadRawDisk          ; Load the boot sector from the disk
0354: F639 D2 00 01               JP     NC,TPA               ; Now execute the boot loader;
0355: F63C
0356: F63C 21 93 F6               LD     HL,NoDiskMessage     ; Else let the user know Disk A does
0357: F63F CD 8B F6               CALL   DisplayMessage       ;  not have a system disk in it
0358: F642 76                     HALT
0359: F643
0360: F643
0361: F643         ;=============================================================================;
0362: F643         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot                                    ;
0363: F643         ;                                                                             ;
0364: F643         ;  Unlike the "cold" bootstrap entry point, which executes only once,         ;
0365: F643         ; the WBOOT or warm boot routine will be executed every time a program        ;
0366: F643         ; terminates by jumping to location OOOOH, or whenever you type a CONTROL-C   ;
0367: F643         ; on the console as the first character of an input line.                     ;
0368: F643         ;  The WBOOT routine is responsible for reloading the CCP into memory.        ;
0369: F643         ; Programs often use all of memory up to the starting point of the BDOS,      ;
0370: F643         ; overwriting the CCP in the process. The underlying philosophy is that       ;
0371: F643         ; while a program is executing, the CCP is not needed, so the program can     ;
0372: F643         ; use the memory previously occupied by the CCP. The CCP occupies             ;
0373: F643         ; 800H (2048) bytes ofmemory-and this is frequently just enough to make the   ;
0374: F643         ; difference between a program that cannot run and one that can.              ;
0375: F643         ; A few programs that are self-contained and do not require the BDOS's        ;
0376: F643         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes   ;
0377: F643         ; of memory. Therefore, to be really safe, the WBOOT routine should read in   ;
0378: F643         ; both the CCP and the BDOS. It also needs to set up the two JMPs at location ;
0379: F643         ; OOOOH (to WBOOT itself) and at location 0005H (to the BOOS). Location 0003H ;
0380: F643         ; should be set to the initial value of the 10BYTE if this is implemented in  ;
0381: F643         ; the BIOS. As its last act, the WBOOT routine sets register C to indicate    ;
0382: F643         ; which logical disk is to be selected (C= 0 for A, I for B, and so on).      ;
0383: F643         ; It then transfers control into the CCP at the first instruction in order    ;
0384: F643         ; to restart the CCP.                                                         ;
0385: F643         ;=============================================================================;
0386: F643
0387: F643             WBOOT:
0388: F643 31 FF DF               LD     SP,CCPEntry-1        ; Put stack at top of User area
0389: F646 21 C8 F6               LD     HL,WBOOTControl      ; Get the WBOOT Control Block
0390: F649 CD 79 F6               CALL   ReadRawDisk          ; Read CCP & BDOS
0391: F64C 30 09                  JR     NC,LoadPage0         ; Set up page 0 if good read
0392: F64E
0393: F64E 21 AE F6               LD     HL,WarmBootErroMessage
0394: F651 CD 8B F6               CALL   DisplayMessage       ; Send bad warm boot message
0395: F654 C3 43 F6               JP     WBOOT                ;  Keep trying
0396: F657
0397: F657
0398: F657         ; Set up page Zero
0399: F657             LoadPage0:
0400: F657 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0401: F659
0402: F659 32 00 00               LD     (WarmBoot),A
0403: F65C 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0404: F65F 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0405: F662
0406: F662 32 05 00               LD     (BDOSE),A
0407: F665 21 00 E8               LD     HL,BDOSEntry         ; BDOS entry point
0408: F668 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0409: F66B
0410: F66B 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0411: F66E CD 38 F8               CALL   SETDMA               ; use normal BDOS  routine
0412: F671 FB                     EI                          ; Enable interrupts
0413: F672
0414: F672 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0415: F675 4F                     LD     C,A
0416: F676 C3 00 E0               JP     CCPEntry             ; Transfer control to CCP
0417: F679
0418: F679
0419: F679
0420: F679
0421: F679         ;=============================================================================
0422: F679         ;---------------------------- Raw Disk Code ---------------------------------;
0423: F679         ;  Enter with DiskControlBlock pointer in HL	                             ;
0424: F679             ReadRawDisk:                      ;
0425: F679 22 46 00               LD     (DiskCommandBlock),HL ; Put it into the DCB in page 0      ;
0426: F67C         ;
0427: F67C 21 45 00               LD     HL,DiskControlByte   ;
0428: F67F 36 80                  LD     (HL),080H            ; Activate the controller            ;
0429: F681         ;
0430: F681             WaitForBootComplete:                      ;
0431: F681 7E                     LD     A,(HL)               ; Get the control byte               ;
0432: F682 B7                     OR     A                    ; Is it completed                    ;
0433: F683 20 FC                  JR     NZ,WaitForBootComplete ; If not try again                   ;
0434: F685         ;
0435: F685 3A 43 00               LD     A,(DiskStatusLocation) ; What's the status?                 ;
0436: F688 FE 80                  CP     080H                 ; Any errors ?                       ;
0437: F68A C9                     RET                         ; Exit with result in the CCs        ;
0438: F68B         ;
0439: F68B         ;---------------------------- Raw Disk Code ---------------------------------;
0440: F68B
0441: F68B         ;---------------------------- Raw Message Code ------------------------------;
0442: F68B             DisplayMessage:                      ;
0443: F68B 7E                     LD     A,(HL)               ;
0444: F68C B7                     OR     A                    ;
0445: F68D C8                     RET    Z                    ;
0446: F68E D3 EC                  OUT    (BOOT_CON_ADDRESS),A ; Console address                ;
0447: F690 23                     INC    HL                   ;
0448: F691 18 F8                  JR     DisplayMessage       ;
0449: F693         ;
0450: F693             NoDiskMessage:                      ;
0451: F693 0D 0A                  DB     CR,LF                ;
0452: F695 4E 6F 20 53 79 73 74 65 6D 20 44 69 73 6B 20 4D 6F 75 6E 74 65 64                DB     'No System Disk Mounted' ;
0453: F6AB 0D 0A 00                DB     CR,LF,EndOfMessage   ;
0454: F6AE         ;
0455: F6AE             WarmBootErroMessage:                      ;
0456: F6AE 0D 0A                  DB     CR,LF                ;
0457: F6B0 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'        ;
0458: F6BB 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'         ;
0459: F6C5 0D 0A 00                DB     CR,LF,EndOfMessage   ;
0460: F6C8         ;---------------------------- Raw Message Code ------------------------------;
0461: F6C8         ;---------------------------- WBOOT Disk Control Block ----------------------;
0462: F6C8             WBOOTControl:                      ;
0463: F6C8 01                     DB     DiskReadCode         ; Read function                      ;
0464: F6C9 00                     DB     00H                  ; unit number                        ;
0465: F6CA 00                     DB     00H                  ; head number                        ;
0466: F6CB 00                     DB     00H                  ; track number                       ;
0467: F6CC 02                     DB     02H                  ; Starting sector number             ;
0468: F6CD         ;  (skip cold boot sector)           ;
0469: F6CD 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read            ;
0470: F6CF         ;  ( rest of the head)               ;
0471: F6CF 00 E0                  DW     CCPEntry             ; read into this address             ;
0472: F6D1 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking ;
0473: F6D3 45 00                  DW     DiskControlByte      ; pointer to next table- no linking  ;
0474: F6D5         ;---------------------------- WBOOT Disk Control Block ----------------------;
0475: F6D5         ;---------------------------- ROM Disk Control Block ------------------------;
0476: F6D5             ROMControl:                      ;
0477: F6D5 01                     DB     DiskReadCode         ; Read function                      ;
0478: F6D6 00                     DB     00H                  ; unit number                        ;
0479: F6D7 00                     DB     00H                  ; head number                        ;
0480: F6D8 00                     DB     00H                  ; track number                       ;
0481: F6D9 01                     DB     01H                  ; Starting sector number ()          ;
0482: F6DA 00 02                  DW     diskSectorSize       ; Number of bytes to read ( 1 Sector);
0483: F6DC 00 01                  DW     TPA                  ; read into this address             ;
0484: F6DE 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking ;
0485: F6E0 40 00                  DW     DiskControlTable     ; pointer to next table- no linking  ;
0486: F6E2         ;---------------------------- ROM Disk Control Block ------------------------;
0487: F6E2
0488: F6E2         ;=============================================================================
0489: F6E2
0490: F6E2
0491: F6E2         ;=============================================================================;
0492: F6E2         ;	Console Status:		BIOS 02                                               ;
0493: F6E2         ;                                                                             ;
0494: F6E2         ;  CONST simply returns an indicator showing whether there is an incoming     ;
0495: F6E2         ; character from the console device. The convention is that A = OFFH if a     ;
0496: F6E2         ; character is waiting to be processed, A = 0 if one is not. Note that the    ;
0497: F6E2         ; zero flag need not be set to reflect the contents of the A register         ;
0498: F6E2         ; it is the contents that are important. CONST is called by the CCP whenever  ;
0499: F6E2         ; the CCP is in the middle of an operation that can be interrupted by         ;
0500: F6E2         ; pressing a keyboard character.                                              ;
0501: F6E2         ;                                                                             ;
0502: F6E2         ;  The BDOS will call CONST if a program makes a Read Console Status          ;
0503: F6E2         ; function call (CONST, code 11, OBH). It is also called by the console input ;
0504: F6E2         ; BIOS routine, CONIN                                                         ;
0505: F6E2         ;=============================================================================;
0506: F6E2
0507: F6E2             CONST:
0508: F6E2             ConStatus:
0509: F6E2 3A 03 00               LD     A,(IOBYTE)
0510: F6E5 DD 21 D3 F7               LD     IX,CON_Vector
0511: F6E9
0512: F6E9             GenericInStatus:                      ; Entry point for generic input status
0513: F6E9 CD 8F F7               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0514: F6EC CD 5C F7               CALL   GetInStatus
0515: F6EF B7                     OR     A
0516: F6F0 C8                     RET    Z                    ; 00 => No data pending
0517: F6F1 3E FF                  LD     A,0FFH
0518: F6F3 C9                     RET                         ; OFFH => Data in Buffer
0519: F6F4
0520: F6F4         ;=============================================================================;
0521: F6F4         ;	Console In:		BIOS 03                                                   ;
0522: F6F4         ;                                                                             ;
0523: F6F4         ;  CONIN reads the next character from the console to the A register and sets ;
0524: F6F4         ; the most significant (parity) bit to O. Normally, CONIN will call the       ;
0525: F6F4         ; CONST routine until it detects A = OFFH. Only then will it input the data   ;
0526: F6F4         ; character and mask off the parity bit. CONIN is called by the CCP and by    ;
0527: F6F4         ; the BDOS when a program executes a Read Console Byte function               ;
0528: F6F4         ; (CONIN, code 1). Normally this follows a call to CONST                      ;
0529: F6F4         ; ( a blocking call) to indicates a char is ready.                            ;
0530: F6F4         ;                                                                             ;
0531: F6F4         ; This is a blocking routine                                                  ;
0532: F6F4         ;=============================================================================;
0533: F6F4
0534: F6F4             CONIN:
0535: F6F4             ConIn:
0536: F6F4 CD E2 F6               CALL   ConStatus
0537: F6F7 28 FB                  JR     Z,ConIn              ; loop until there is some data to read
0538: F6F9         ; Call to ConStatus Sets up IX with Physical Table
0539: F6F9 DD 6E 06               LD     L,(IX+DataReadIndex)
0540: F6FC DD 66 07               LD     H,(IX+(DataReadIndex+1))
0541: F6FF E9                     JP     (HL)
0542: F700         ;=============================================================================;
0543: F700         ;	Console Out:		BIOS 04                                               ;
0544: F700         ;                                                                             ;
0545: F700         ;  CONOUT outputs the character (in ASCII) in register C to the console. The  ;
0546: F700         ; most significant (parity) bit of the character will always be O.            ;
0547: F700         ; CONOUT must first check that the console device is ready to receive more    ;
0548: F700         ; data, delaying if necessary until it is, and only then sending the          ;
0549: F700         ; character to the device. CONOUT is called by the CCP and by the BDOS when   ;
0550: F700         ; a program executes a Write Console Byte function (CONOUT, code 2).          ;
0551: F700         ;                                                                             ;
0552: F700         ; This is a blocking routine                                                  ;
0553: F700         ;=============================================================================;
0554: F700
0555: F700             CONOUT:
0556: F700             CONOut:
0557: F700 3A 03 00               LD     A,(IOBYTE)
0558: F703 DD 21 D3 F7               LD     IX,CON_Vector
0559: F707
0560: F707             GenericOutStatus:                      ; entry point for standard blocking write
0561: F707 CD 8F F7               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0562: F70A             GenericOutStatus1:
0563: F70A CD 57 F7               CALL   GetOutStatus
0564: F70D 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0565: F70F DD 6E 08               LD     L,(IX+DataWriteIndex)
0566: F712 DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0567: F715 E9                     JP     (HL)
0568: F716
0569: F716         ;=============================================================================;
0570: F716         ;	List output  BIOS 05                                                      ;
0571: F716         ;                                                                             ;
0572: F716         ;  LIST is similar to CONOUT except that it sends the character in register   ;
0573: F716         ; C to the list device. It too checks first that the list device is ready to  ;
0574: F716         ; receive the character. LIST is called by the CCP in response to the         ;
0575: F716         ; CONTROL-P toggle for printer echo of console output, and by the BDOS when a ;
0576: F716         ; program makes a Write Printer Byte or Display String call                   ;
0577: F716         ; (LISTOUT and PRINTS, codes 5 and 9).                                        ;
0578: F716         ;                                                                             ;
0579: F716         ; This is a blocking routine                                                  ;
0580: F716         ;=============================================================================;
0581: F716
0582: F716             LIST:
0583: F716 3A 03 00               LD     A,(IOBYTE)
0584: F719 07                     RLCA                        ; move bits 7,6
0585: F71A 07                     RLCA                        ; to 1,0
0586: F71B DD 21 EB F7               LD     IX,LST_Vector
0587: F71F 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0588: F721
0589: F721         ;=============================================================================;
0590: F721         ;	Punch output  BIOS 06                                                     ;
0591: F721         ;                                                                             ;
0592: F721         ;  PUNCH sends the character in register C to the "punch" device. As mentioned;
0593: F721         ; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the ;
0594: F721         ; PUNCH entry point either returns immediately and is effectively a null      ;
0595: F721         ; routine, or it outputs the character to a communications device, such as a  ;
0596: F721         ; modem, on your computer. PUNCH must check that the "punch" device is indeed ;
0597: F721         ; ready to accept another character for output, and must wait if it is not.   ;
0598: F721         ;                                                                             ;
0599: F721         ;  Digital Research's documentation states that the character to be output    ;
0600: F721         ; will always have its most significant bit set to O. This is not true.       ;
0601: F721         ; The BDOS simply transfers control over to the PUNCH entry point in the BIOS ;
0602: F721         ; the setting of the most significant bit will be determined by the program   ;
0603: F721         ; making the BDOS function request (PUNOUT, code 4). This is important        ;
0604: F721         ; because the requirement of a zero would preclude being able to send pure    ;
0605: F721         ; binary data via the BIOS PUNCH function                                     ;
0606: F721         ;                                                                             ;
0607: F721         ; This is a blocking routine                                                  ;
0608: F721         ;=============================================================================;
0609: F721
0610: F721             PUNCH:                          ; Punch output
0611: F721 3A 03 00               LD     A,(IOBYTE)
0612: F724 0F                     RRCA
0613: F725 0F                     RRCA
0614: F726 0F                     RRCA                        ; move bits 5,4
0615: F727 0F                     RRCA                        ; to 1,0
0616: F728 DD 21 E3 F7               LD     IX,PUN_Vector
0617: F72C 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0618: F72E
0619: F72E         ;=============================================================================;
0620: F72E         ;	Reader input  BIOS 07                                                     ;
0621: F72E         ;                                                                             ;
0622: F72E         ;  As with the PUNCH entry point, the READER entry point rarely connects to   ;
0623: F72E         ; a real paper tape reader.                                                   ;
0624: F72E         ; The READER function must return the next character from the reader device   ;
0625: F72E         ; in the A register, waiting, if need be, until there is a character.         ;
0626: F72E         ;                                                                             ;
0627: F72E         ;  Digital Research's documentation again says that the most significant bit  ;
0628: F72E         ; of the A register must be 0, but this is not the case if you wish to        ;
0629: F72E         ; receive pure binary information via this function.                          ;
0630: F72E         ;                                                                             ;
0631: F72E         ;  READER is called whenever a program makes a Read "Reader" Byte function    ;
0632: F72E         ; request (READIN, code 3).                                                   ;
0633: F72E         ;                                                                             ;
0634: F72E         ; This is a blocking routine                                                  ;
0635: F72E         ;=============================================================================;
0636: F72E
0637: F72E             READER:                         ; Reader Input
0638: F72E 3A 03 00               LD     A,(IOBYTE)
0639: F731 0F                     RRCA
0640: F732 0F                     RRCA                        ; move bits 3,2  to 1,0
0641: F733 DD 21 DB F7               LD     IX,RDR_Vector
0642: F737             READER1:
0643: F737 CD E9 F6               CALL   GenericInStatus
0644: F73A 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0645: F73C
0646: F73C DD 6E 06               LD     L,(IX+DataReadIndex)
0647: F73F DD 66 07               LD     H,(IX+(DataReadIndex+1))
0648: F742 E9                     JP     (HL)
0649: F743
0650: F743         ;=============================================================================;
0651: F743         ;	List Status:  BIOS 0F                                                     ;
0652: F743         ;                                                                             ;
0653: F743         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.   ;
0654: F743         ; This function returns the current status of the list device, using the      ;
0655: F743         ; IOBYTE if necessary to select the correct physical device. It sets the A    ;
0656: F743         ; register to OFFH if the list device can accept another character for output ;
0657: F743         ; or to OOH if it is not ready. Digital Research's documentation states that  ;
0658: F743         ; this function is used by the DESPOOL utility program (which allows you to   ;
0659: F743         ; print a file "simultaneously" with other operations) to improve console     ;
0660: F743         ; response during its operation, and that it is acceptable for the routine    ;
0661: F743         ; always to return OOH if you choose not to implement it fully. Unfortunately,;
0662: F743         ; this statement is wrong. Many other programs use the LISTST function to     ;
0663: F743         ; "poll" the list device to make sure it is ready, and if it fails to come    ;
0664: F743         ; ready after a predetermined time, to output a message to the console        ;
0665: F743         ; indicating that the printer is not ready. If you ever make a call to the    ;
0666: F743         ; BDOS list output functions, Write Printer Byte and Print String             ;
0667: F743         ; (codes 5 and 9), and the printer is not ready, then CP/M will wait          ;
0668: F743         ; forever-and your program will have lost control so it cannot even detect    ;
0669: F743         ; that the problem has occurred. If LISTST always returns a OOH, then the     ;
0670: F743         ; printer will always appear not to be ready. Not only does this make         ;
0671: F743         ; nonsense out of the LISTST function, but it also causes a stream of false   ;
0672: F743         ; "Printer not Ready" error messages to appear on the console.                ;
0673: F743         ;=============================================================================;
0674: F743
0675: F743             LISTST:
0676: F743 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0677: F746 07                     RLCA
0678: F747 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0679: F748 DD 21 EB F7               LD     IX,LST_Vector        ; Set th vector base
0680: F74C CD 8F F7               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0681: F74F CD 57 F7               CALL   GetOutStatus
0682: F752
0683: F752 B7                     OR     A
0684: F753 C8                     RET    Z                    ; 00 => Device Ready
0685: F754 3E FF                  LD     A,0FFH
0686: F756 C9                     RET                         ; OFFH => Device No Ready
0687: F757
0688: F757         ;-----------------------------------------------------------------------------
0689: F757         ;-----------------------------------------------------------------------------
0690: F757             GetOutStatus:
0691: F757         ; vector to CON Devices
0692: F757 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0693: F75A 18 03                  JR     GetStatus
0694: F75C             GetInStatus:
0695: F75C DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0696: F75F             GetStatus:
0697: F75F DD 6E 04               LD     L,(IX+StatusReadIndex)
0698: F762 DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0699: F765 E9                     JP     (HL)                 ; jump to the stats read routine
0700: F766
0701: F766         ;-----------------------------------------------------------------------------
0702: F766
0703: F766             DataRead:
0704: F766 DD 7E 01               LD     A,(IX+DataPortIndex)
0705: F769 32 6D F7               LD     (AddressDataIn),A    ; modify code with the Data port
0706: F76C DB                     DB     IN_OPCODE
0707: F76D             AddressDataIn:
0708: F76D 00                     DB     00                   ; perform the read
0709: F76E C9                     RET
0710: F76F
0711: F76F             DataReadASCII:
0712: F76F CD 66 F7               CALL   DataRead
0713: F772 E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0714: F774 C9                     RET
0715: F775
0716: F775         ; Enter DataWrite the value to be output in C
0717: F775             DataWrite:
0718: F775 DD 7E 01               LD     A,(IX+DataPortIndex)
0719: F778 32 7D F7               LD     (AddressDataOut),A   ; modify code with the Data port
0720: F77B 79                     LD     A,C                  ; get value into ACC
0721: F77C D3                     DB     OUT_OPCODE
0722: F77D             AddressDataOut:
0723: F77D 00                     DB     00                   ; perform the write
0724: F77E C9                     RET
0725: F77F
0726: F77F
0727: F77F         ; Enter Status Read with Target mask in D
0728: F77F             StatusRead:
0729: F77F DD 7E 00               LD     A,(IX+StatusPortIndex)
0730: F782 32 86 F7               LD     (AddressStatus),A    ; modify code with the status port
0731: F785 DB                     DB     IN_OPCODE
0732: F786             AddressStatus:
0733: F786 00                     DB     00
0734: F787 A2                     AND    D                    ; Check return vale with the mask
0735: F788 C9                     RET
0736: F789
0737: F789             DUMMYRead:
0738: F789 C9                     RET
0739: F78A             DUMMYWrite:
0740: F78A C9                     RET
0741: F78B             DUMMYCheck:
0742: F78B 3E FF                  LD     A,0FFH               ; Always return 0FFH
0743: F78D B7                     OR     A                    ; Set flags
0744: F78E C9                     RET
0745: F78F
0746: F78F         ;=============================================================================;
0747: F78F             SetDeviceVector:
0748: F78F E6 03                  AND    03H                  ; Get bits 0 & 1;
0749: F791 87                     ADD    A,A                  ; Double for word size index
0750: F792 16 00                  LD     D,00H
0751: F794 5F                     LD     E,A                  ; load byte index int DE
0752: F795 DD 19                  ADD    IX,DE                ; add to the value vector base
0753: F797         ; IX points at correct entry in vector
0754: F797 DD 5E 00               LD     E,(IX+0)
0755: F79A DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0756: F79D D5                     PUSH   DE
0757: F79E DD E1                  POP    IX                   ; Move it to IX
0758: F7A0 C9                     RET
0759: F7A1
0760: F7A1
0761: F7A1         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0762: F7A1         ; Physical Device Attributes
0763: F7A1
0764: F7A1             TTY_StatusPort EQU    0EDH
0765: F7A1             TTY_DataPort EQU    0ECH
0766: F7A1             TTY_OutputMask EQU    80H                  ; Status Mask
0767: F7A1             TTY_InputMask EQU    7FH                  ; Status Mask
0768: F7A1
0769: F7A1             CRT_StatusPort EQU    02H
0770: F7A1             CRT_DataPort EQU    01H
0771: F7A1             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0772: F7A1             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0773: F7A1
0774: F7A1             COM_StatusPort EQU    0EDH
0775: F7A1             COM_DataPort EQU    0ECH
0776: F7A1             COM_OutputMask EQU    01H                  ; Status Mask
0777: F7A1             COM_InputMask EQU    02H                  ; Status Mask
0778: F7A1
0779: F7A1             LPT_StatusPort EQU    011H
0780: F7A1             LPT_DataPort EQU    010H
0781: F7A1             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0782: F7A1             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0783: F7A1
0784: F7A1             DUMMY_StatusPort EQU    011H
0785: F7A1             DUMMY_DataPort EQU    010H
0786: F7A1             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0787: F7A1             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0788: F7A1
0789: F7A1         ; Device Table Control Block Definition
0790: F7A1             StatusPortIndex EQU    0
0791: F7A1             DataPortIndex EQU    1
0792: F7A1             OutputMaskIndex EQU    2
0793: F7A1             InputMaskIndex EQU    3
0794: F7A1             StatusReadIndex EQU    4
0795: F7A1             DataReadIndex EQU    6
0796: F7A1             DataWriteIndex EQU    8
0797: F7A1
0798: F7A1         ;Physical Devices Control Blocks
0799: F7A1
0800: F7A1             TTY_Table:
0801: F7A1 ED                     DB     TTY_StatusPort
0802: F7A2 EC                     DB     TTY_DataPort
0803: F7A3 80                     DB     TTY_OutputMask
0804: F7A4 7F                     DB     TTY_InputMask
0805: F7A5 7F F7                  DW     StatusRead
0806: F7A7 6F F7                  DW     DataReadASCII
0807: F7A9 75 F7                  DW     DataWrite
0808: F7AB
0809: F7AB             CRT_Table:
0810: F7AB 02                     DB     CRT_StatusPort
0811: F7AC 01                     DB     CRT_DataPort
0812: F7AD 80                     DB     CRT_OutputMask
0813: F7AE 7F                     DB     CRT_InputMask
0814: F7AF 7F F7                  DW     StatusRead
0815: F7B1 66 F7                  DW     DataRead
0816: F7B3 75 F7                  DW     DataWrite
0817: F7B5             COM_Table:
0818: F7B5 ED                     DB     COM_StatusPort
0819: F7B6 EC                     DB     COM_DataPort
0820: F7B7 01                     DB     COM_OutputMask
0821: F7B8 02                     DB     COM_InputMask
0822: F7B9 7F F7                  DW     StatusRead
0823: F7BB 66 F7                  DW     DataRead
0824: F7BD 75 F7                  DW     DataWrite
0825: F7BF             LPT_Table:
0826: F7BF 11                     DB     LPT_StatusPort
0827: F7C0 10                     DB     LPT_DataPort
0828: F7C1 FF                     DB     LPT_OutputMask
0829: F7C2 7F                     DB     LPT_InputMask
0830: F7C3 7F F7                  DW     StatusRead
0831: F7C5 66 F7                  DW     DataRead
0832: F7C7 75 F7                  DW     DataWrite
0833: F7C9             DUMMY_Table:
0834: F7C9 11                     DB     DUMMY_StatusPort
0835: F7CA 10                     DB     DUMMY_DataPort
0836: F7CB FF                     DB     DUMMY_OutputMask
0837: F7CC 7F                     DB     DUMMY_InputMask
0838: F7CD 8B F7                  DW     DUMMYCheck
0839: F7CF 89 F7                  DW     DUMMYRead
0840: F7D1 8A F7                  DW     DUMMYWrite
0841: F7D3
0842: F7D3         ;---------------------------------------------------------------------------
0843: F7D3
0844: F7D3         ; Logical Device Vector, Controlled by IOBYTE
0845: F7D3
0846: F7D3             CON_Vector:                      ; IOBYTE bits 1 & 0
0847: F7D3 A1 F7                  DW     TTY_Table
0848: F7D5 AB F7                  DW     CRT_Table
0849: F7D7 B5 F7                  DW     COM_Table
0850: F7D9 C9 F7                  DW     DUMMY_Table
0851: F7DB             RDR_Vector:                      ; IOBYTE bits 3 & 2
0852: F7DB A1 F7                  DW     TTY_Table
0853: F7DD AB F7                  DW     CRT_Table
0854: F7DF C9 F7                  DW     DUMMY_Table
0855: F7E1 C9 F7                  DW     DUMMY_Table
0856: F7E3             PUN_Vector:                      ; IOBYTE bits 5 & 4
0857: F7E3 A1 F7                  DW     TTY_Table
0858: F7E5 C9 F7                  DW     DUMMY_Table
0859: F7E7 B5 F7                  DW     COM_Table
0860: F7E9 AB F7                  DW     CRT_Table
0861: F7EB             LST_Vector:                      ; IOBYTE bits 7 & 6
0862: F7EB BF F7                  DW     LPT_Table
0863: F7ED AB F7                  DW     CRT_Table
0864: F7EF BF F7                  DW     LPT_Table
0865: F7F1 C9 F7                  DW     DUMMY_Table
0866: F7F3
0867: F7F3         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0868: F7F3         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0869: F7F3
0870: F7F3         ;=============================================================================;
0871: F7F3         ;                            Disk routines                                    ;
0872: F7F3         ;=============================================================================;
0873: F7F3         ;                                                                             ;
0874: F7F3         ;  All of the disk functions that follow were originally designed to operate  ;
0875: F7F3         ; on the 128-byte sectors used on single-sided, single-density, 8-inch floppy ;
0876: F7F3         ; diskettes that were standard in the industry at the time. Now that CP/M     ;
0877: F7F3         ; runs on many different types of disks, some of the BIOS disk functions      ;
0878: F7F3         ; seem strange because most of the new disk drives use sector sizes other     ;
0879: F7F3         ; than 128 bytes. To handle larger sector sizes, the BIOS has some            ;
0880: F7F3         ; additional code that makes the BDOS respond as if it were still handling    ;
0881: F7F3         ; 128-byte sectors. This code is referred to as the blocking/deblocking       ;
0882: F7F3         ; code.  As its name implies, it blocks together several 128-byte "sectors"   ;
0883: F7F3         ; and only writes to the disk when a complete physical sector has been        ;
0884: F7F3         ; assembled.  When reading, it reads in a physical sector and then de-blocks  ;
0885: F7F3         ; it,handing back several 128-byte "sectors" to the BDOS.                     ;
0886: F7F3         ;  To do all of this, the blocking/deblocking code uses a special buffer area ;
0887: F7F3         ; of the same size as the physical sectors on the disk. This is known as the  ;
0888: F7F3         ; host disk buffer or HSTBUE Physical sectors are read into this buffer and   ;
0889: F7F3         ; written to the disk from it. In order to optimize this blocking/deblocking  ;
0890: F7F3         ; routine, the BIOS has code in it to reduce the number of times that an      ;
0891: F7F3         ; actual disk read or write occurs. A side effect is that at any given        ;
0892: F7F3         ; moment, several 128-byte "sectors" may be stored in the HSTBUF, waiting to  ;
0893: F7F3         ; be written out to the disk when HSTBUF becomes full. This sometimes         ;
0894: F7F3         ; complicates the logic of the BIOS disk functions. You cannot simply select  ;
0895: F7F3         ; a new disk drive, for example, when the HSTBUF contains data destined for   ;
0896: F7F3         ; another disk drive. You will see this complication in the BIOS only in the  ;
0897: F7F3         ; form of added logical operations; the BIOS disk functions rarely trigger    ;
0898: F7F3         ; immediate physical operations. It is easier to understand these BIOS        ;
0899: F7F3         ; functions if you consider that they make requests-and that these requests   ;
0900: F7F3         ; are satisfied only when it makes sense to do so, taking into account        ;
0901: F7F3         ; the blocking/ deblocking logic.                                             ;
0902: F7F3         ;=============================================================================;
0903: F7F3         ;=============================================================================;
0904: F7F3
0905: F7F3         ;=============================================================================;
0906: F7F3         ;	Home Disk	BIOS 08                                                       ;
0907: F7F3         ;                                                                             ;
0908: F7F3         ;  HOME - Home the selected logical disk to track 0. Before doing this, a     ;
0909: F7F3         ; check must be made to see if the physical disk buffer has information that  ;
0910: F7F3         ; must be written out. This is indicated by a flag, DirtyBufferFlag,set in    ;
0911: F7F3         ; the de-blocking code                                                        ;
0912: F7F3         ;=============================================================================;
0913: F7F3
0914: F7F3             HOME:
0915: F7F3 3A 67 F9               LD     A,(DirtyBufferFlag)  ; Check for Dirty Buffer
0916: F7F6 BF                     CP     A,TRUE
0917: F7F7 28 05                  JR     Z,Home1
0918: F7F9 3E 00                  LD     A,FALSE
0919: F7FB 32 66 F9               LD     (DataInBufferFlag),A ; Clear DataInBufferFlag if Buffer not dirty
0920: F7FE             Home1:
0921: F7FE 0E 00                  LD     C,00H                ; Set to track 0
0922: F800 CD 2E F8               CALL   SETTRK               ; no, physical, only logical
0923: F803 C9                     RET
0924: F804
0925: F804         ;=============================================================================;
0926: F804         ;	Select Disk	BIOS 09                                                       ;
0927: F804         ;                                                                             ;
0928: F804         ;  SELDSK does not do what its name implies. It does not (and must not)       ;
0929: F804         ;  physically select a logical disk. Instead, it returns a pointer in the HL  ;
0930: F804         ;  register pair to the disk parameter header for the logical disk specified  ;
0931: F804         ;  in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK   ;
0932: F804         ;  also stores this code for the requested disk to be used later in the READ  ;
0933: F804         ;  and WRITE functions. If the logical disk code in register C refers to a    ;
0934: F804         ;  nonexistent disk or to one for which no disk parameter header exists, then ;
0935: F804         ;  SELDSK must return with HL set to OOOOH. Then the BDOS will output a       ;
0936: F804         ;  message of the form "BDOS Err on XI Select" Note that SELDSK not only does ;
0937: F804         ;  not select the disk, but also does not indicate whether or not the         ;
0938: F804         ;  requested disk is physically present -merely whether or not there are disk ;
0939: F804         ;  tables present for the disk.                                               ;
0940: F804         ;                                                                             ;
0941: F804         ;  SELDSK is called by the BDOS either during disk file operations or by a    ;
0942: F804         ; program issuing a Select Disk request (SELDSK, code 14).                    ;
0943: F804         ;=============================================================================;
0944: F804
0945: F804             SELDSK:
0946: F804 21 00 00               LD     HL,00H               ; Assume an error
0947: F807 79                     LD     A,C
0948: F808 FE 04                  CP     NumberOfLogicalDisks
0949: F80A D0                     RET    NC                   ; return if > max number of Disks
0950: F80B
0951: F80B 32 68 F9               LD     (SelectedDisk),A     ; save disk number
0952: F80E
0953: F80E 07                     RLCA                        ; X2
0954: F80F 07                     RLCA                        ; X4
0955: F810 07                     RLCA                        ; X8
0956: F811 07                     RLCA                        ; X16
0957: F812 16 00                  LD     D,0
0958: F814 5F                     LD     E,A                  ; put index int DE
0959: F815 DD 21 73 F9               LD     IX,DiskParameterHeaders ; get DPH address Base
0960: F819 DD 19                  ADD    IX,DE                ; get the specific DiskParameterHeader
0961: F81B DD E5                  PUSH   IX                   ; save for return in HL
0962: F81D
0963: F81D DD 56 0B               LD     D,(IX+11)            ; LSB for Disk Parameter Block
0964: F820 DD 5E 0A               LD     E,(IX+10)            ; MSB for Disk Parameter Block
0965: F823
0966: F823 D5                     PUSH   DE
0967: F824 DD E1                  POP    IX
0968: F826 DD 7E 0F               LD     A,(IX+15)            ; Disk Parameter Block in IY
0969: F829 32 6D F9               LD     (SelectedDskSecsPerHead),A
0970: F82C
0971: F82C E1                     POP    HL                   ; recover DPH pointer
0972: F82D C9                     RET
0973: F82E
0974: F82E
0975: F82E
0976: F82E         ;=============================================================================;
0977: F82E         ;	Set Track	BIOS 0A                                                       ;
0978: F82E         ;                                                                             ;
0979: F82E         ;  SETTRK saves the requested disk track that is in the BC register pair when ;
0980: F82E         ; SETTRK gets control. Note that this is an absolute track number; that is,   ;
0981: F82E         ; the number of reserved tracks before the file directory will have been added;
0982: F82E         ; to the track number relative to the start of the logical disk. The number of;
0983: F82E         ; the requested track will be used in the next BIOS READ or WRITE function.   ;
0984: F82E         ;  SETTRK is called by the BDOS when it needs to read or write a 128-byte     ;
0985: F82E         ; sector. Legitimate track numbers are from 0 to OFFFFH (65,535).             ;
0986: F82E         ;=============================================================================;
0987: F82E
0988: F82E             SETTRK:
0989: F82E         ;	LD		H,B							; select track in BC on entry
0990: F82E         ;	LD		L,C
0991: F82E         ;	LD	(SelectedTrack),HL				; save for low level driver
0992: F82E ED 43 69 F9               LD     (SelectedTrack),BC   ; save for low level driver
0993: F832 C9                     RET
0994: F833
0995: F833         ;=============================================================================;
0996: F833         ;	Set Sector	BIOS 0B  (Set Record)                                         ;
0997: F833         ;                                                                             ;
0998: F833         ; Sector  = Record for disk with 128 byte sectors                             ;
0999: F833         ;                                                                             ;
1000: F833         ;  Sector contains 4 records for disks with 512 byte sectors this routine is  ;
1001: F833         ; missed named it should be called Set Record                                 ;
1002: F833         ;                                                                             ;
1003: F833         ;  SETSEC is similar to SETTRK in that it stores the requested Record (sector);
1004: F833         ; number for later use in BIOS READ or WRITE functions. The requested Record  ;
1005: F833         ; (sector) number is handed to SETSEC in the A register; legitimate values    ;
1006: F833         ; are from 0 to OFFH (255). The Record (sector) number is a logical Record    ;
1007: F833         ; (sector) number. It does not take into account any sector skewing that      ;
1008: F833         ; might be used to improve disk performance. SETSEC is called by the BDOS     ;
1009: F833         ; when it needs to read or write a 128-byte Record (sector).                  ;
1010: F833         ;=============================================================================;
1011: F833
1012: F833             SETSEC:                         ; SETRECORD
1013: F833 79                     LD     A,C
1014: F834 32 6C F9               LD     (SelectedRecord),A   ; save for low level driver
1015: F837 C9                     RET
1016: F838
1017: F838         ;=============================================================================;
1018: F838         ;	Set DMA		BIOS 0C                                                       ;
1019: F838         ;                                                                             ;
1020: F838         ;  SETDMA saves the address in the BC register pair in the requested DMA      ;
1021: F838         ; address. The next BIOS READ or WRITE function will use the DMA address as   ;
1022: F838         ; a pointer to the 128-byte sector buffer into which data will be read or     ;
1023: F838         ; from which data will be written.                                            ;
1024: F838         ;  The default DMA address is 0080H. SETDMA is called by the BDOS when it     ;
1025: F838         ; needs to READ or WRITE a 128-byte sector.                                   ;
1026: F838         ;=============================================================================;
1027: F838
1028: F838             SETDMA:
1029: F838 ED 43 6E F9               LD     (DMAAddress),BC      ; save for low level driver
1030: F83C C9                     RET
1031: F83D
1032: F83D         ;=============================================================================;
1033: F83D         ;	Sector Translate	BIOS 10                                               ;
1034: F83D         ;                                                                             ;
1035: F83D         ;  SECTRAN, given a logical sector number, locates the correct physical       ;
1036: F83D         ;  sector number in the sector translate table for the previously selected    ;
1037: F83D         ;  (via SELDSK) logical disk drive. Note that both logical and physical       ;
1038: F83D         ;  sector numbers are l28-byte sectors, so if you are working with a hard     ;
1039: F83D         ;  disk system, it is not too efficient to impose a sector interlace at the   ;
1040: F83D         ;  l28-byte sector level. It is better to impose the sector interlace right   ;
1041: F83D         ;  inside the hard disk driver, if at all. In general, hard disks spin so     ;
1042: F83D         ;  rapidly that CP/M simply cannot take advantage of sector interlace.        ;
1043: F83D         ;  The BDOS hands over the logical sector number in the BC register pair,     ;
1044: F83D         ;  with the address of the sector translate table in the DE register pair.    ;
1045: F83D         ;  SECTRAN must return the physical sector number in HL. If SECTRAN is to be  ;
1046: F83D         ;  a null routine, it must move the contents of BC to HL and return.          ;
1047: F83D         ;=============================================================================;
1048: F83D             SECTRAN:
1049: F83D C5                     PUSH   BC
1050: F83E E1                     POP    HL                   ; just move the value from BC to HL
1051: F83F C9                     RET
1052: F840
1053: F840         ;=============================================================================;
1054: F840         ;	READ			BIOS 0D                                                   ;
1055: F840         ;                                                                             ;
1056: F840         ;  READ reads in a 128-byte sector provided that there have been previous BIOS;
1057: F840         ; function calls to:                                                          ;
1058: F840         ; 				- SELDSK	"select" the disk                                 ;
1059: F840         ; 				- SETDMA	set the DMA address                               ;
1060: F840         ; 				- SETTRK	set the track number                              ;
1061: F840         ; 				- SETSEC	set the sector number.                            ;
1062: F840         ; 			                                                                  ;
1063: F840         ;   Because of the blocking/ deblocking code in the BIOS, there are frequent  ;
1064: F840         ;  occasions when the requested sector will already be in the host buffer     ;
1065: F840         ;  (HSTBUF), so that a physical disk read is not required. All that is then   ;
1066: F840         ;  required is for the BIOS to move the appropriate 128 bytes from the HSTBUF ;
1067: F840         ;  into the buffer pointed at by the DMA address. Only during the READ        ;
1068: F840         ;  function will the BIOS normally communicate with the physical disk drive,  ;
1069: F840         ;  selecting it and seeking to read the requested track and sector. During    ;
1070: F840         ;  this process, the READ function must also handle any hardware errors that  ;
1071: F840         ;  occur, trying an operation again if a "soft," or recoverable, error occurs.;
1072: F840         ;  The READ function must return with the A register set to OOH if the read   ;
1073: F840         ;  operation has completed successfully. If the READ function returns with    ;
1074: F840         ;  the A register set to 01 H, the BDOS will display an error message of the  ;
1075: F840         ;  form BDOS Err on X: Bad Sector. Under these circumstances, you have only   ;
1076: F840         ;  two choices. You can enter a CARRIAGE RETURN, ignore the fact that there   ;
1077: F840         ;  was an error, and attempt to make sense of the data in the DMA buffer. Or  ;
1078: F840         ;  you can type a CONTROL-C to abort the operation, perform a warm boot, and  ;
1079: F840         ;  return control to the CCP. As you can see, CP/M's error handling is not    ;
1080: F840         ;  particularly helpful, so most BIOS writers add more sophisticated error    ;
1081: F840         ;  recovery right in the disk driver. This can include some interaction with  ;
1082: F840         ;  the console so that a more determined effort can be made to correct errors ;
1083: F840         ;  or, if nothing else, give you more information as to what has gone wrong.  ;
1084: F840         ;                                                                             ;
1085: F840         ;=============================================================================;
1086: F840
1087: F840             READ:
1088: F840 3E FF                  LD     A,DISK_READ
1089: F842 32 71 F9               LD     (DiskCommand),A      ; Set to Flag to read (non-zero)
1090: F845 3E 02                  LD     A,WriteCleanBuffer   ; Fake a clean sector Write
1091: F847 32 72 F9               LD     (WriteType),A        ;  to avoid a Directory Write later at the end
1092: F84A C3 56 F8               JP     CommonDiskIO         ; Use common code to execute read
1093: F84D
1094: F84D         ;=============================================================================;
1095: F84D         ;	WRITE			BIOS 0E                                                   ;
1096: F84D         ;                                                                             ;
1097: F84D         ;  Write a cpmRecord,128-bytes, from the current DMA address to the previously;
1098: F84D         ; Selected disk, track, and sector.                                           ;
1099: F84D         ;                                                                             ;
1100: F84D         ;  On arrival here, the BDOS will have set register C to indicate whether this;
1101: F84D         ; write operation is to:                                                      ;
1102: F84D         ;	00H [WriteAllocated]	An already allocated allocation block             ;
1103: F84D         ;	01H [WriteDirectory]	To the directory                                  ;
1104: F84D         ;	02H [WriteCleanBuffer]	To the first cpmRecord of an Alocation block      ;
1105: F84D         ;                                                                             ;
1106: F84D         ;  WRITE is similar to READ but with the obvious difference that data is      ;
1107: F84D         ; transferred from the DMA buffer to the specified 128-byte sector. Like READ,;
1108: F84D         ; this function requires that the following  calls have already been made:    ;
1109: F84D         ;	- SELDSK	"select" the disk                                             ;
1110: F84D         ;	- SETDMA	set the DMA address                                           ;
1111: F84D         ;	- SETTRK	set the track number                                          ;
1112: F84D         ;	- SETSEC	set the sector number.                                        ;
1113: F84D         ;			                                                                  ;
1114: F84D         ;  Again, it is only in the WRITE routine that the driver will start to talk  ;
1115: F84D         ; directly to the physical hardware, selecting the disk unit, track, and      ;
1116: F84D         ; sector, and transferring the data to the disk. With the blocking/deblocking ;
1117: F84D         ; code, the BDOS optimizes the number of disk writes that are needed by       ;
1118: F84D         ; indicating in register C the type of disk write that is to be performed:    ;
1119: F84D         ;	0= normal sector write                                                    ;
1120: F84D         ;	1= write to file directory sector                                         ;
1121: F84D         ;	2 = write to sector of previously unchanged Deblocking Buffer             ;
1122: F84D         ;			                                                                  ;
1123: F84D         ;  Type 0 occurs whenever the BDOS is writing to a data sector in an already  ;
1124: F84D         ; used allocation block. Under these circumstances, the disk driver must      ;
1125: F84D         ; preread the appropriate host sector because there may be previously stored  ;
1126: F84D         ; information on it.                                                          ;
1127: F84D         ;                                                                             ;
1128: F84D         ;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in   ;
1129: F84D         ; this case, the BIOS must not defer writing the sector to the disk, as the   ;
1130: F84D         ; information is too valuable to hold in memory until the HSTBUF is full. The ;
1131: F84D         ; longer the information resides in the HSTBUF, the greater the chance of a   ;
1132: F84D         ; power failure or glitch, making file data already physically written to the ;
1133: F84D         ; disk inaccessible because the file directory is out of date.                ;
1134: F84D         ;                                                                             ;
1135: F84D         ;  Type 2 occurs whenever the BDOS needs to write to the first sector of a    ;
1136: F84D         ; previously unused allocation block. Unused, in this context, includes an    ;
1137: F84D         ; allocation block that has become available as a result of a file being      ;
1138: F84D         ; erased. In this case, there is no need for the disk driver to preread an    ;
1139: F84D         ; entire host-sized sector into the HSTBUF, as there is no data of value in   ;
1140: F84D         ; the physical sector.                                                        ;
1141: F84D         ;                                                                             ;
1142: F84D         ;  As with the READ routine, the WRITE function returns with A set to OOH if  ;
1143: F84D         ; the operation has been completed successfully. If the WRITE function        ;
1144: F84D         ; returns with A set to 01H, then the BDOS will display the same message as   ;
1145: F84D         ; for READ: BDOS Err on X: Bad Sector                                         ;
1146: F84D         ;=============================================================================;
1147: F84D
1148: F84D             WRITE:
1149: F84D 79                     LD     A,C                  ; Retrieve the calling write type
1150: F84E 32 72 F9               LD     (WriteType),A        ; Save the type of write
1151: F851 3E 00                  LD     A,DISK_WRITE
1152: F853 32 71 F9               LD     (DiskCommand),A      ; Set to Flag to Write
1153: F856
1154: F856         ;*****************************************************************************;
1155: F856         ;     Common code to execute both reads and writes of 128-byte records        ;
1156: F856         ;*****************************************************************************;
1157: F856             CommonDiskIO:
1158: F856 AF                     XOR    A                    ; Assume no disk error will occur
1159: F857 32 70 F9               LD     (DiskStatus),A
1160: F85A         ;-------------------------Convert selected record into physical sector-------;
1161: F85A 3A 6C F9               LD     A,(SelectedRecord)   ;
1162: F85D 1F                     RRA                         ; Convert selected record            ;
1163: F85E 1F                     RRA                         ; into physical sector by dividing by;
1164: F85F E6 3F                  AND    03FH                 ; Remove unwanted bits               ;
1165: F861 32 6B F9               LD     (SelectedSector),A   ;
1166: F864         ;-------------------------Convert selected record into physical sector-------;
1167: F864
1168: F864         ;------------------------- Any Data in Buffer -------------------------------;
1169: F864         ;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes ; ;                                                                            ;
1170: F864 21 66 F9               LD     HL,DataInBufferFlag  ; See if there is any data here ?    ;
1171: F867 7E                     LD     A,(HL)               ;
1172: F868 36 FF                  LD     (HL),TRUE            ; Force flag true                    ;
1173: F86A FE FF                  CP     TRUE                 ; Was  any data here ?               ;
1174: F86C 20 0F                  JR     NZ,PreRead           ; No, then we need to load data      ;
1175: F86E         ;------------------------- Any Data in Buffer -------------------------------;
1176: F86E
1177: F86E         ;--------------------------- Is This My Data --------------------------------;
1178: F86E CD D7 F8               CALL   IsItMyData           ;
1179: F871 28 22                  JR     Z,DoPart2            ;
1180: F873         ;--------------------------- Is This My Data --------------------------------;
1181: F873
1182: F873         ;--------------------------- Is The Data Dirty -----------------------------;
1183: F873 3A 67 F9               LD     A,(DirtyBufferFlag)  ;
1184: F876 FE FF                  CP     TRUE                 ;
1185: F878 20 03                  JR     NZ,PreRead           ;
1186: F87A         ;--------------------------- Is The Data Dirty -----------------------------;
1187: F87A
1188: F87A         ;-------------------------------- PreWrite ---------------------------------;
1189: F87A             PreWrite:                       ;
1190: F87A         ; Do the actual Write                                                       ;
1191: F87A CD E8 F8               CALL   PhysicalWrite        ;
1192: F87D         ;-------------------------------- PreWrite ---------------------------------;
1193: F87D
1194: F87D         ;--------------------------------- PreRead ---------------------------------;
1195: F87D         ;     prepare for physical IO                                               ;
1196: F87D             PreRead:                        ;
1197: F87D         ; Set IOBuffer to Selected state for physical read                          ;
1198: F87D 21 68 F9               LD     HL,SelectedState     ;
1199: F880 11 62 F9               LD     DE,IOBufferState     ;
1200: F883 01 04 00               LD     BC,SelectedStateSize ;
1201: F886 ED B0                  LDIR                        ;
1202: F888         ; Do the actual read                                                        ;
1203: F888 CD ED F8               CALL   PhysicalRead         ;
1204: F88B 3E FF                  LD     A,TRUE               ;
1205: F88D 32 66 F9               LD     (DataInBufferFlag),A ; Set DataInBuffeer Flag			;
1206: F890 3E 00                  LD     A,FALSE              ;
1207: F892 32 67 F9               LD     (DirtyBufferFlag),A  ; Reset DataIsDirty Flag			;
1208: F895         ;--------------------------------- PreRead ---------------------------------;
1209: F895
1210: F895         ;-------------------Calculate the address of the record in the sector ------;
1211: F895             DoPart2:                        ;
1212: F895             DataIsInBuffer:                      ;
1213: F895 3A 6C F9               LD     A,(SelectedRecord)   ;
1214: F898 E6 03                  AND    SectorMask           ; Want relative record              ;
1215: F89A 3C                     INC    A                    ; Adjust for DJNZ                   ;
1216: F89B 47                     LD     B,A                  ;
1217: F89C 11 80 00               LD     DE,cpmRecordSize     ;
1218: F89F 21 80 FF               LD     HL,-cpmRecordSize    ;
1219: F8A2             SectorInBuffer1:                      ;
1220: F8A2 19                     ADD    HL,DE                ; RecordNumber * recordSize         ;
1221: F8A3 10 FD                  DJNZ   SectorInBuffer1      ;  yields index into the Sector     ;
1222: F8A5         ;
1223: F8A5 11 27 FC               LD     DE,DiskBuffer        ; Start of sector                   ;
1224: F8A8 19                     ADD    HL,DE                ; HL -> start of record in buffer	;
1225: F8A9 ED 5B 6E F9               LD     DE,(DMAAddress)      ; Callers  DMA Address              ;
1226: F8AD         ;
1227: F8AD         ;-------------------Calculate the address of the record in the sector ------;
1228: F8AD
1229: F8AD         ;------------------------- Determine if its a Read or Write and set HL & DE ;
1230: F8AD 3A 71 F9               LD     A,(DiskCommand)      ; 0 => Write, non Zero => Read      ;
1231: F8B0 FE FF                  CP     DISK_READ            ;
1232: F8B2 CA BB F8               JP     Z,BufferMove         ; Read : move data from Buffer to DMA
1233: F8B5         ;write                              	; Write: move data from DMA to Buffer
1234: F8B5 3E FF                  LD     A,TRUE               ; Set the flag to indicate dirty buffer
1235: F8B7 32 67 F9               LD     (DirtyBufferFlag),A  ;
1236: F8BA EB                     EX     DE,HL                ; Swap source and destination for Write
1237: F8BB         ;------------------------- Determine if its a Read or Write and set HL & DE ;
1238: F8BB
1239: F8BB         ;----------------------  Move the Data between Buffer and DMA location   ---;
1240: F8BB             BufferMove:                      ;
1241: F8BB 01 80 00               LD     BC,cpmRecordSize     ;
1242: F8BE ED B0                  LDIR                        ;
1243: F8C0         ;----------------------  Move the Data between Buffer and DMA location   ---;
1244: F8C0
1245: F8C0
1246: F8C0 3A 72 F9               LD     A,(WriteType)        ; Is this a write to the directory ?
1247: F8C3 FE 01                  CP     WriteDirectory
1248: F8C5 3A 70 F9               LD     A,(DiskStatus)       ; Get disk status if an immediate return
1249: F8C8 C0                     RET    NZ                   ; Return if not a directory entry
1250: F8C9
1251: F8C9 B7                     OR     A                    ; Check for any disk errors ?
1252: F8CA C0                     RET    NZ                   ; If yes - abandon do not write to dir
1253: F8CB
1254: F8CB 3E 00                  LD     A,FALSE
1255: F8CD 32 67 F9               LD     (DirtyBufferFlag),A  ; Clear the dirty buffer flag
1256: F8D0 CD E8 F8               CALL   PhysicalWrite        ; Immediate update of the directory
1257: F8D3 3A 70 F9               LD     A,(DiskStatus)       ; Set ACC with disk status
1258: F8D6 C9                     RET
1259: F8D7
1260: F8D7
1261: F8D7         ;--------------------------- Is It My Data ---------------------------------;
1262: F8D7             IsItMyData:                      ;
1263: F8D7         ;
1264: F8D7 21 68 F9               LD     HL,SelectedState     ;
1265: F8DA 11 62 F9               LD     DE,IOBufferState     ;
1266: F8DD 06 04                  LD     B,SelectedStateSize  ;
1267: F8DF             IsItMyData1:                      ;
1268: F8DF 1A                     LD     A,(DE)               ;
1269: F8E0 AE                     XOR    (HL)                 ; (HL) =(DE)                        ;
1270: F8E1 C0                     RET    NZ                   ; If not we are done                ;
1271: F8E2 13                     INC    DE                   ;
1272: F8E3 23                     INC    HL                   ; Lets look at the next bytes       ;
1273: F8E4 10 F9                  DJNZ   IsItMyData1          ; Loop if not exhausted the count   ;
1274: F8E6 AF                     XOR    A                    ; Else set the Z flag               ;
1275: F8E7 C9                     RET                         ;  and exit                         ;
1276: F8E8
1277: F8E8         ;--------------------------- Is It My Data ---------------------------------;
1278: F8E8
1279: F8E8         ;***********************************************;
1280: F8E8         ;			      Physical Disk IO				  ;
1281: F8E8         ;***********************************************;
1282: F8E8
1283: F8E8         ;Write contents of disk buffer to correct sector
1284: F8E8             PhysicalWrite:
1285: F8E8 3E 02                  LD     A,DiskWriteCode      ; get write function
1286: F8EA C3 EF F8               JP     CommonPhysical
1287: F8ED
1288: F8ED             PhysicalRead:
1289: F8ED 3E 01                  LD     A,DiskReadCode       ; get read function
1290: F8EF
1291: F8EF
1292: F8EF             CommonPhysical:
1293: F8EF         ;--------------------------- Setup Disk Control Table  ---------------------;
1294: F8EF         ;                                     ;
1295: F8EF         ;Command                                                                    ;
1296: F8EF 32 55 F9               LD     (DCTCommand),A       ; set the command for Read or Write ;
1297: F8F2         ;Disk                                                                       ;
1298: F8F2 3A 62 F9               LD     A,(IOBufferDisk)     ;
1299: F8F5 E6 03                  AND    03H                  ; only units 0 to 3                 ;
1300: F8F7 32 56 F9               LD     (DCTDisk),A          ; set disk                          ;
1301: F8FA         ;Track                                                                      ;
1302: F8FA 2A 63 F9               LD     HL,(IOBufferTrack)   ;
1303: F8FD 7D                     LD     A,L                  ;
1304: F8FE 32 58 F9               LD     (DCTTrack),A         ; set track	                        ;
1305: F901         ;
1306: F901         ;Head and Track	Calculations                                                ;
1307: F901         ; The sector must be converted into a head number and sector number.        ;
1308: F901         ;	Head = (int) Sector / SectorsPerHead                                    ;
1309: F901         ;	Sector = Sector MOD SectorsPerHead                                      ;
1310: F901             DetermineHead:                      ;
1311: F901 06 00                  LD     B,0                  ; Start at head 0                   ;
1312: F903 21 6D F9               LD     HL,SelectedDskSecsPerHead ; Point at track counts             ;
1313: F906 3A 65 F9               LD     A,(IOBufferSector)   ; get target sector                 ;
1314: F909             DetermineHead1:                      ;
1315: F909 BE                     CP     M                    ; Need another Head?                ;
1316: F90A DA 12 F9               JP     C,HeadFound          ; nope done with head calculation   ;
1317: F90D         ;
1318: F90D 96                     SUB    M                    ; subtract track value              ;
1319: F90E 04                     INC    B                    ; Increment head                    ;
1320: F90F C3 09 F9               JP     DetermineHead1       ; loop for next head value          ;
1321: F912         ;Sector                                                                     ;
1322: F912             HeadFound:                      ; Sector MOD SectorsPerHead         ;
1323: F912 3C                     INC    A                    ; physical sectors start at 1       ;
1324: F913 32 59 F9               LD     (DCTSector),A        ; set sector                        ;
1325: F916         ;Head                                                                       ;
1326: F916 78                     LD     A,B                  ;
1327: F917 32 57 F9               LD     (DCTHead),A          ; set head number                   ;
1328: F91A         ;Byte Count                                                                 ;
1329: F91A 21 00 02               LD     HL,diskSectorSize    ;
1330: F91D 22 5A F9               LD     (DCTByteCount),HL    ; set byte count                    ;
1331: F920         ;DMA                                                                        ;
1332: F920 21 27 FC               LD     HL,DiskBuffer        ;
1333: F923 22 5C F9               LD     (DCTDMAAddress),HL   ; set transfer address              ;
1334: F926         ;
1335: F926         ; Since only one control table is in use, close the status and              ;
1336: F926         ; busy chain pointers ; back to the main control bytes.                     ;
1337: F926         ;
1338: F926         ;NextStatusBlock                                                            ;
1339: F926 21 43 00               LD     HL,DiskStatusLocation ;
1340: F929 22 5E F9               LD     (DCTNextStatusBlock),HL ;
1341: F92C         ;NextControlLocation                                                        ;
1342: F92C 21 45 00               LD     HL,DiskControlByte   ;
1343: F92F 22 60 F9               LD     (DCTNextControlLocation),HL ;
1344: F932         ;                                                                       ;
1345: F932         ;Put  DCT pointer in page0                                                  ;
1346: F932 21 55 F9               LD     HL,DCTCommand        ;
1347: F935 22 46 00               LD     (DiskCommandBlock),HL ;
1348: F938         ;--------------------------- Setup Disk Control Table  ---------------------;
1349: F938
1350: F938         ; Make the IO happen
1351: F938 21 45 00               LD     HL,DiskControlByte   ; Activate disk controller
1352: F93B 36 80                  LD     (HL),080H
1353: F93D
1354: F93D             WaitForDiskComplete:
1355: F93D 7E                     LD     A,(HL)               ; Get control bytes
1356: F93E B7                     OR     A
1357: F93F C2 3D F9               JP     NZ,WaitForDiskComplete ; Operation not done
1358: F942
1359: F942         ;Check if any errors occurred.
1360: F942 3A 43 00               LD     A,(DiskStatusLocation)
1361: F945 FE 80                  CP     080H                 ; Any errors NC = good read?
1362: F947 DA 4F F9               JP     C,DiskError
1363: F94A AF                     XOR    A
1364: F94B 32 70 F9               LD     (DiskStatus),A       ; Clear the flag
1365: F94E C9                     RET                         ; Clean read, return to caller
1366: F94F
1367: F94F         ; set error flag and return
1368: F94F             DiskError:
1369: F94F 3E 01                  LD     A,1
1370: F951 32 70 F9               LD     (DiskStatus),A       ; Set the error flag
1371: F954 C9                     RET
1372: F955
1373: F955
1374: F955
1375: F955
1376: F955
1377: F955         ;=============================================================================;
1378: F955         ;                                                                             ;
1379: F955         ;  There is one  disk controller on this system, for the 3.5 HD drive (1.44MB);
1380: F955         ;                                                                             ;
1381: F955         ; The controller is "hard-wired" to monitor memory location 0X45 to detect    ;
1382: F955         ; when it is to perform some disk operation.  This is called its disk         ;
1383: F955         ; control byte. If the most significant bit of  disk control byte is set,     ;
1384: F955         ; the controller will look at the word following the respective control bytes.;
1385: F955         ; This word must contain the address of  valid disk control table that        ;
1386: F955         ; specifies the exact disk operation to be performed. Once the operation has  ;
1387: F955         ; been completed. the controller resets its disk control byte to OOH.         ;
1388: F955         ; This indicates completion to the disk driver code.                          ;
1389: F955         ;                                                                             ;
1390: F955         ;  The controller also sets a return code in a disk status block,             ;
1391: F955         ; location 0X43H. If the first byte of this status block is less than 80H.    ;
1392: F955         ; then a disk error has occurred.
1393: F955
1394: F955         ;  The disk control table layout is shown below. Note that the controller     ;
1395: F955         ; has the capability  for control tables to be chained together so that a     ;
1396: F955         ; sequence of disk operations can be initiated. In this BIOS this feature     ;
1397: F955         ; is not used. However. the controller requires that the chain pointers       ;
1398: F955         ; in the disk control tables be pointed back to the main control bytes in     ;
1399: F955         ; order to indicate  the end of the chain                                     ;
1400: F955         ;=============================================================================;
1401: F955
1402: F955         ;**************************** Disk ControlTable ******************************;
1403: F955             DCTStart:                       ;
1404: F955 00          DCTCommand: DB     00H                  ; Command	                          ;
1405: F956 00          DCTDisk:   DB     00H                  ; unit (drive) number = 0 or 1   	  ;
1406: F957 00          DCTHead:   DB     00H                  ; head number = 0 or 1           	  ;
1407: F958 00          DCTTrack:  DB     00H                  ; track number                   	  ;
1408: F959 00          DCTSector: DB     00H                  ; sector number                  	  ;
1409: F95A 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write  	  ;
1410: F95C 00 00       DCTDMAAddress: DW     0000H                ; transfer address               	  ;
1411: F95E 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block   	  ;
1412: F960 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte   	  ;
1413: F962             DCTEnd:                         ;
1414: F962             DCTSize    EQU    DCTEnd-DCTStart      ;
1415: F962         ;**************************** Disk ControlTable ******************************;
1416: F962
1417: F962         ;**************************** Physical IO State ******************************;
1418: F962             IOBufferState:                      ;
1419: F962 00          IOBufferDisk: DB     00H                  ;
1420: F963 00 00       IOBufferTrack: DW     0000H                ;
1421: F965 10          IOBufferSector: DB     010H                 ;
1422: F966         ;**************************** Physical IO State ******************************;
1423: F966
1424: F966         ;**************************** Buffer State ***********************************;
1425: F966 00          DataInBufferFlag: DB     00H                  ;
1426: F967 00          DirtyBufferFlag: DB     00H                  ;
1427: F968         ;**************************** Buffer State ***********************************;
1428: F968
1429: F968         ;**************************** Selected Record State **************************;
1430: F968         ;     variables for selected disk, track and sector                           ;
1431: F968         ;These are moved and compared as a group with Physical IO State. DO NOT ALTER ;
1432: F968         ;
1433: F968             SelectedState:                      ;
1434: F968 00          SelectedDisk: DB     00H                  ;
1435: F969 00 00       SelectedTrack: DW     0000H                ;
1436: F96B 00          SelectedSector: DB     00H                  ; (SelectedRecord/RecordsPerSector)   ;
1437: F96C             SelectedStateEnd:                      ;
1438: F96C             SelectedStateSize EQU    SelectedStateEnd - SelectedState ;
1439: F96C         ;
1440: F96C 00          SelectedRecord: DB     00H                  ;
1441: F96D         ;
1442: F96D 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head	                  ;
1443: F96E         ;**************************** Selected Record State **************************;
1444: F96E
1445: F96E 00 00       DMAAddress: DW     0000H                ; Callers DMA address
1446: F970 00          DiskStatus: DB     00H                  ; Non-Zero - unrecoverable error
1447: F971 00          DiskCommand: DB     00H                  ; holds the disk command
1448: F972 00          WriteType: DB     00H                  ; The type of write set by BDOS
1449: F973
1450: F973         ;============================================================================
1451: F973
1452: F973
1453: F973         ;*************************** Disk Definition Tables **************************;
1454: F973         ; These consists of disk parameter headers, with one entry per logical disk   ;
1455: F973         ; drive, and disk parameter blocks, with either one parameter block per       ;
1456: F973         ; logical disk or the same parameter block for several logical disks.         ;
1457: F973             DiskParameterHeaders:                      ;
1458: F973         ;
1459: F973         ; Logical Disk A: (3.25" HD 1.44MB Diskette)                                  ;
1460: F973 00 00                  DW     0000H                ; No Skew table                  	  ;
1461: F975 00 00                  DW     0000H                ; Rel pos for file (0-3)         	  ;
1462: F977 00 00                  DW     0000H                ; Last Selected Track #          	  ;
1463: F979 00 00                  DW     0000H                ; Last Selected Sector #         	  ;
1464: F97B A7 FB                  DW     DirectoryBuffer      ; all disks use this buffer      	  ;
1465: F97D B3 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters  	  ;
1466: F97F C3 F9                  DW     DiskAWorkArea        ;
1467: F981 43 FA                  DW     DiskAAllocationVector ;
1468: F983         ;
1469: F983         ; Logical Disk B: (3.25" HD 1.44MB Diskette)                                  ;
1470: F983 00 00                  DW     0000H                ; No Skew table                   	  ;
1471: F985 00 00                  DW     0000H                ; Rel pos for file (0-3)          	  ;
1472: F987 00 00                  DW     0000H                ; Last Selected Track #           	  ;
1473: F989 00 00                  DW     0000H                ; Last Selected Sector #          	  ;
1474: F98B A7 FB                  DW     DirectoryBuffer      ; all disks use this buffer       	  ;
1475: F98D B3 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters   	  ;
1476: F98F E3 F9                  DW     DiskBWorkArea        ;
1477: F991 9C FA                  DW     DiskBAllocationVector ;
1478: F993         ;
1479: F993         ; Logical Disk C: (3.25" HD 1.44MB Diskette)                                  ;
1480: F993 00 00                  DW     0000H                ; No Skew table                  	  ;
1481: F995 00 00                  DW     0000H                ; Rel pos for file (0-3)         	  ;
1482: F997 00 00                  DW     0000H                ; Last Selected Track #          	  ;
1483: F999 00 00                  DW     0000H                ; Last Selected Sector #         	  ;
1484: F99B A7 FB                  DW     DirectoryBuffer      ; all disks use this buffer      	  ;
1485: F99D B3 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters  	  ;
1486: F99F 03 FA                  DW     DiskCWorkArea        ;
1487: F9A1 F5 FA                  DW     DiskCAllocationVector ;
1488: F9A3         ;
1489: F9A3         ; Logical Disk D: (3.25" HD 1.44MB Diskette)                                  ;
1490: F9A3 00 00                  DW     0000H                ; No Skew table                  	  ;
1491: F9A5 00 00                  DW     0000H                ; Rel pos for file (0-3)         	  ;
1492: F9A7 00 00                  DW     0000H                ; Last Selected Track #          	  ;
1493: F9A9 00 00                  DW     0000H                ; Last Selected Sector #         	  ;
1494: F9AB A7 FB                  DW     DirectoryBuffer      ; all disks use this buffer      	  ;
1495: F9AD B3 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters  	  ;
1496: F9AF 23 FA                  DW     DiskDWorkArea        ;
1497: F9B1 4E FB                  DW     DiskDAllocationVector ;
1498: F9B3         ;*************************** Disk Definition Tables **************************;
1499: F9B3
1500: F9B3
1501: F9B3         ;-----------------------------------------------------------
1502: F9B3         ;******** Parameter Block for 3.5 Inch High Density 1.44 MB Diskettes *******;
1503: F9B3         ;
1504: F9B3             ParameterBlock3HD:                      ;
1505: F9B3 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)        ;
1506: F9B5 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)              ;
1507: F9B6 0F                     DB     dpb3hdBLM            ; Block mask                         ;
1508: F9B7 00                     DB     dpb3hdEXM            ; Extent mask                        ;
1509: F9B8 C6 02                  DW     dpb3hdDSM            ; Max allocation block number (710)  ;
1510: F9BA 7F 00                  DW     dpb3hdDRM            ; Max directory entries - 1 (127)    ;
1511: F9BC C0                     DB     dpb3hdAL0            ; Bit map for reserving allocation   ;
1512: F9BD 00                     DB     dpb3hdAL1            ;   blocks for file directory        ;
1513: F9BE 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)    ;
1514: F9C0 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory  ;
1515: F9C2         ;
1516: F9C2 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head             ;
1517: F9C3         ;******** Parameter Block for 3.5 Inch High Density 1.44 MB Diskettes *******;
1518: F9C3
1519: F9C3         ;**************************** Disk Work Area ********************************;
1520: F9C3         ; This is used by the BDOS to detect any unexpected  change of diskette.     ;
1521: F9C3         ; The BDOS will  set such a changed diskette to read-only status.            ;
1522: F9C3         ;
1523: F9C3             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H	                         ;
1524: F9E3             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H	                         ;
1525: FA03             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H	                         ;
1526: FA23             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H	                         ;
1527: FA43         ;**************************** Disk Work Area ********************************;
1528: FA43
1529: FA43         ;************************ Disk Allocation Vectors ***************************;
1530: FA43         ; These are used by the BDOS to maintain a bit map of which allocation blocks;
1531: FA43         ; are used and which are free. One byte is used for eight allocation blocks, ;
1532: FA43         ; hence the  expression of the form  (allocation blocks/8)+1				 ;
1533: FA43         ;
1534: FA43             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:                  			 ;
1535: FA9C             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:                  			 ;
1536: FAF5         ;
1537: FAF5             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:                  			 ;
1538: FB4E             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:                  			 ;
1539: FBA7         ;************************ Disk Allocation Vectors ***************************;
1540: FBA7
1541: FBA7         ;********************************* Buffers **********************************;
1542: FBA7             DirectoryBuffer: DS     DirBuffSize          ;
1543: FC27         ;
1544: FC27         ;
1545: FC27             DiskBuffer:                      ;
1546: FC27                        DS     diskSectorSize       ;
1547: FE27         ;********************************* Buffers **********************************;
1548: FE27
1549: FE27             Z_HighestLocation:
1550: FE27             Z_MemoryLeft EQU    0FFFFH - Z_HighestLocation
1551: FE27
           ************************   Xref   ************************
0000: $               FE27
0707: AddressDataIn   F76D   0705
0722: AddressDataOut  F77D   0719
0732: AddressStatus   F786   0730
0092: ASCII_A         0041
0093: ASCII_C         0043
0094: ASCII_K         004B
0101: ASCII_LO_A      0061
0102: ASCII_LO_K      006B
0103: ASCII_LO_P      0070
0044: ASCII_MASK      007F   0713
0095: ASCII_N         004E
0096: ASCII_Q         0051
0097: ASCII_R         0052
0098: ASCII_W         0057
0099: ASCII_Y         0059
0079: ASCII_ZERO      0030
0073: ASTERISK        002A
0159: BDOSBase        E800   0160 0162
0128: BDOSE           0005   0129 0406 0408
0160: BDOSEntry       E800   0407
0149: BDOSLength      0E00   0152 0162 0163 0469
0062: BELL            0007
0162: BIOSBase        F600
0150: BIOSLength      0A00   0152
0122: BIOSPAGE        0002
0163: BIOSStart       F600   0304
0259: BlockSize       0800   0281
0350: BOOT            F633   0308
0296: BOOT_CON_ADDRESS 00EC   0446
1240: BufferMove      F8BB   1232
0040: BYTE            0001
0100: CARET           005E
0157: CCPEntry        E000   0159 0163 0388 0416 0471
0148: CCPLength       0800   0152 0159 0163 0469
0306: CodeStart       F600
0080: COLON           003A
0775: COM_DataPort    00EC   0819
0777: COM_InputMask   0002   0821
0776: COM_OutputMask  0001   0820
0774: COM_StatusPort  00ED   0818
0817: COM_Table       F7B5   0849 0859
0075: COMMA           002C
1157: CommonDiskIO    F856   1092
1292: CommonPhysical  F8EF   1286
0134: ComTail         0080   0135
0136: ComTailChars    0082
0135: ComTailCount    0081   0136
0846: CON_Vector      F7D3   0510 0558
0535: ConIn           F6F4   0537
0534: CONIN           F6F4   0312
0555: CONOUT          F700   0313
0556: CONOut          F700
0507: CONST           F6E2   0311
0508: ConStatus       F6E2   0536
0236: cpmRecordSize   0080   0238 0241 0243 1217 1218 1241
0065: CR              000D   0451 0453 0456 0459
0770: CRT_DataPort    0001   0811
0772: CRT_InputMask   007F   0813
0771: CRT_OutputMask  0080   0812
0769: CRT_StatusPort  0002   0810
0809: CRT_Table       F7AB   0848 0853 0860 0863
0048: CTRL_C          0003
0049: CTRL_E          0005
0050: CTRL_H          0008
0051: CTRL_K          000B
0052: CTRL_L          000C
0053: CTRL_P          0010
0054: CTRL_R          0012
0055: CTRL_S          0013
0056: CTRL_U          0015
0057: CTRL_X          0018
0058: CTRL_Z          001A
0076: DASH            002D
0270: DataBlocks      02C7   0280
1425: DataInBufferFlag F966   0919 1170 1205
1212: DataIsInBuffer  F895
0791: DataPortIndex   0001   0704 0718
0703: DataRead        F766   0712 0815 0823 0831
0711: DataReadASCII   F76F   0806
0795: DataReadIndex   0006   0539 0540 0646 0647
0269: DataSectors     0B1C   0270
0717: DataWrite       F775   0807 0816 0824 0832
0796: DataWriteIndex  0008   0565 0566
1409: DCTByteCount    F95A   1330
1404: DCTCommand      F955   1296 1346
1405: DCTDisk         F956   1300
1410: DCTDMAAddress   F95C   1333
1413: DCTEnd          F962   1414
1406: DCTHead         F957   1327
1412: DCTNextControlLocation F960   1343
1411: DCTNextStatusBlock F95E   1340
1408: DCTSector       F959   1324
1414: DCTSize         000D
1403: DCTStart        F955   1414
1407: DCTTrack        F958   1304
1310: DetermineHead   F901
1314: DetermineHead1  F909   1320
0241: DirBuffSize     0080   1542
0256: DirectoryBlockCount 0002   0281
1542: DirectoryBuffer FBA7   1464 1474 1484 1494
0243: DirectoryEntryPerRecord 0004   0284
0240: DirEntrySize    0020   0243 0281
1426: DirtyBufferFlag F967   0915 1183 1207 1235 1255
0301: DISK_READ       00FF   1088 1231
0302: DISK_WRITE      0000   1151
1534: DiskAAllocationVector FA43   1467
1523: DiskAWorkArea   F9C3   1466
1535: DiskBAllocationVector FA9C   1477
1545: DiskBuffer      FC27   1223 1332
1524: DiskBWorkArea   F9E3   1476
1537: DiskCAllocationVector FAF5   1487
1447: DiskCommand     F971   1089 1152 1230
0228: DiskCommandBlock 0046   0425 1347
0227: DiskControlByte 0045   0427 0473 1342 1351
0230: DiskControlTable 0040   0485
1525: DiskCWorkArea   FA03   1486
1538: DiskDAllocationVector FB4E   1497
1526: DiskDWorkArea   FA23   1496
1368: DiskError       F94F   1362
1457: DiskParameterHeaders F973   0959
0232: DiskReadCode    0001   0463 0477 1289
0237: diskSectorSize  0200   0238 0259 0267 0482 1329 1546
1446: DiskStatus      F970   1159 1248 1257 1364 1370
0226: DiskStatusLocation 0043   0435 0472 0484 1339 1360
0233: DiskWriteCode   0002   1285
0442: DisplayMessage  F68B   0357 0394 0448
1445: DMAAddress      F96E   1029 1225
0139: DMABuffer       0080   0410
0069: DOLLAR          0024
1211: DoPart2         F895   1179
0282: dpb3hdAL0       00C0   1511
0283: dpb3hdAL1       0000   1512
0278: dpb3hdBLM       000F   1507
0277: dpb3hdBSH       0004   1506
0284: dpb3hdCKS       0020   1513 1523 1524 1525 1526
0281: dpb3hdDRM       007F   0284 1510
0280: dpb3hdDSM       02C6   1509 1534 1535 1537 1538
0279: dpb3hdEXM       0000   1508
0286: dpb3hdNOH       0002   1516
0285: dpb3hdOFF       0001   1514
0276: dpb3hdSPT       0090   1505 1516
0785: DUMMY_DataPort  0010   0835
0787: DUMMY_InputMask 007F   0837
0786: DUMMY_OutputMask 00FF   0836
0784: DUMMY_StatusPort 0011   0834
0833: DUMMY_Table     F7C9   0850 0854 0855 0858 0865
0741: DUMMYCheck      F78B   0838
0737: DUMMYRead       F789   0839
0739: DUMMYWrite      F78A   0840
0143: END_OF_FILE     001A
0046: EndOfMessage    0000   0453 0459
0084: EQUAL_SIGN      003D
0067: EXCLAIM_POINT   0021
0035: FALSE           0000   0918 1206 1254
0131: FCB1            005C   0132
0132: FCB2            006C
0176: fCloseFile      0010
0167: fConsoleIn      0001
0168: fConsoleOut     0002
0179: fDeleteFile     0013
0171: fGetConsoleStatus 000B
0185: fGetCurrentDisk 0019
0184: fGetLoginVector 0018
0187: fGetSetUserNumber 0020
0172: fGetVersion     000C
0182: fMakeFile       0016
0175: fOpenFile       000F
0169: fPrintString    0009
0180: fReadSeq        0014
0170: fReadString     000A
0183: fRenameFile     0017
0173: fResetSystem    000D
0177: fSearchFirst    0011
0178: fSearchNext     0012
0174: fSelectDisk     000E
0186: fSetDMA         001A
0181: fWriteSeq       0015
0512: GenericInStatus F6E9   0643
0560: GenericOutStatus F707   0587 0617
0562: GenericOutStatus1 F70A   0564
0694: GetInStatus     F75C   0514
0690: GetOutStatus    F757   0563 0681
0696: GetStatus       F75F   0693
0085: GREATER_THAN    003E
0068: HASH_TAG        0023
1322: HeadFound       F912   1316
0914: HOME            F7F3   0317
0920: Home1           F7FE   0917
0298: IN_OPCODE       00DB   0706 0731
0793: InputMaskIndex  0003   0695
1419: IOBufferDisk    F962   1298
1421: IOBufferSector  F965   1313
1418: IOBufferState   F962   1199 1265
1420: IOBufferTrack   F963   1302
0123: IOBYTE          0003   0509 0557 0583 0611 0638 0676
1262: IsItMyData      F8D7   1178
1267: IsItMyData1     F8DF   1273
0300: JP_OPCODE       00C3   0400
0071: L_PAREN         0028
0088: LEFT_ARROW      005F
0104: LEFT_CURLY      007B
0152: LengthInBytes   2000   0153 0157 0267
0153: LengthInK       0009
0083: LESS_THAN       003C
0064: LF              000A   0451 0453 0456 0459
0582: LIST            F716   0314
0675: LISTST          F743   0324
0038: LO_NIBBLE_MASK  000F
0399: LoadPage0       F657   0391
0780: LPT_DataPort    0010   0827
0782: LPT_InputMask   007F   0829
0781: LPT_OutputMask  00FF   0828
0779: LPT_StatusPort  0011   0826
0825: LPT_Table       F7BF   0862 0864
0861: LST_Vector      F7EB   0586 0679
0155: MemorySize      0040   0157
0268: myOffset        0001   0269 0285
0450: NoDiskMessage   F693   0356
0060: NULL            0000
0252: NumberOfHeads   0002   0263 0265 0276 0286
0249: NumberOfLogicalDisks 0004   0948
0037: OFF             0000
0036: ON              FFFF
0299: OUT_OPCODE      00D3   0721
0792: OutputMaskIndex 0002   0692
1504: ParameterBlock3HD F9B3   1465 1475 1485 1495
0070: PERCENT         0025
0077: PERIOD          002E
0126: Pg0CurentDisk   0004   0414
0125: Pg0CurentUser   0004   0126
1288: PhysicalRead    F8ED   1203
1284: PhysicalWrite   F8E8   1191 1256
0074: PLUS_SIGN       002B
1196: PreRead         F87D   1174 1185
1189: PreWrite        F87A
0856: PUN_Vector      F7E3   0616
0610: PUNCH           F721   0315
0086: QMARK           003F
0072: R_PAREN         0029
0119: RAM             0000   0121 0122 0123 0125 0128 0131 0134 0139 0141
0851: RDR_Vector      F7DB   0641
1087: READ            F840   0322
0637: READER          F72E   0316
0642: READER1         F737   0644
0424: ReadRawDisk     F679   0353 0390
0261: RecordsPerBlock 0010
0245: RecordsPerExtent 0080
0238: recordsPerSector 0004   0261 0276
0476: ROMControl      F6D5   0352
0089: RUBOUT          007F
1219: SectorInBuffer1 F8A2   1221
0290: SectorMask      0003   1214
0255: SectorsPerBlock 0004   0259 0261 0264 0270 0290
0265: SectorsPerCylinder 0024   0268 0269
0254: SectorsPerTrack 0012   0263 0265 0276
1048: SECTRAN         F83D   0325
0945: SELDSK          F804   0318
1434: SelectedDisk    F968   0951
1442: SelectedDskSecsPerHead F96D   0969 1312
1440: SelectedRecord  F96C   1014 1161 1213
1436: SelectedSector  F96B   1165
1433: SelectedState   F968   1198 1264 1438
1437: SelectedStateEnd F96C   1438
1438: SelectedStateSize 0004   1200 1266
1435: SelectedTrack   F969   0992
0082: SEMICOLON       003B
0747: SetDeviceVector F78F   0513 0561 0680
1028: SETDMA          F838   0321 0411
1012: SETSEC          F833   0320
0988: SETTRK          F82E   0319 0922
0078: SLASH           002F
0061: SOH             0001
0066: SPACE           0020
0790: StatusPortIndex 0000   0729
0728: StatusRead      F77F   0805 0814 0822 0830
0794: StatusReadIndex 0004   0697 0698
0267: SystemSectors   0011   0268
0063: TAB             0009
0129: TopRAM          0007
0264: TotalNumberOfBlocks 02D0
0263: TotalNumberOfSectors 0B40   0264 0269
0141: TPA             0100   0354 0483
0253: TracksPerHead   0050   0263
0034: TRUE            FFFF   1172 1173 1184 1204 1234
0765: TTY_DataPort    00EC   0802
0767: TTY_InputMask   007F   0804
0766: TTY_OutputMask  0080   0803
0764: TTY_StatusPort  00ED   0801
0800: TTY_Table       F7A1   0847 0852 0857
0087: UNDER_SCORE     005F
0430: WaitForBootComplete F681   0433
1354: WaitForDiskComplete F93D   1357
0121: WarmBoot        0000   0402 0404
0309: WarmBootEntry   F603   0403
0455: WarmBootErroMessage F6AE   0393
0387: WBOOT           F643   0310 0395
0462: WBOOTControl    F6C8   0389
0041: WORD            0002
1148: WRITE           F84D   0323
0201: WriteAllocated  0000
0203: WriteCleanBuffer 0002   1090
0202: WriteDirectory  0001   1247
1448: WriteType       F972   1091 1150 1246
1549: Z_HighestLocation FE27   1550
1550: Z_MemoryLeft    01D8
0045: ZERO            0000
