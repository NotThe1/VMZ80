0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018-01-19 Repaired CP   A,TRUE
0006: F600         ; 2018-12-28 Version 1.0
0007: F600         ; 2018-12-28 Changed the READ & WRITE routines
0008: F600         ; 2018 12-27 Adjusted BOOT & WBOOT
0009: F600         ; 2018-12-10 Refactored  character device routines;
0010: F600         ; 2017-03-31 Added List out functionality for List Device
0011: F600         ; 2017-03-02 Refactored the CP/M Suite
0012: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0013: F600         ; 2014-01-16
0014: F600         ; 2014-03-14  :  Frank Martyn
0015: F600
0016: F600         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0017: F600         ; by Andy Johnson-Laird
0018: F600         ;
0019: F600         ; Published by
0020: F600         ; Osborne/McGraw-Hill
0021: F600         ; 2600 Tenth Street
0022: F600         ; Berkeley, California 94710
0023: F600         ; U.S.A.
0024: F600
0025: F600                        Include ./stdHeader.Z80
0026: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0027: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0028: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0029: F600         ; stdHeader.Z80
0030: F600         ; standard equates for use by CP/M
0031: F600
0032: F600         ; 2019-03-02 Removed any unused constants
0033: F600         ; 2017-03-02 Refactored the CP/M Suite
0034: F600
0035: F600
0036: F600             TRUE       EQU    -1                   ; Not false
0037: F600             FALSE      EQU    0000H
0038: F600             LO_NIBBLE_MASK EQU    0FH                  ; Mask used to obtain the bytes low four bits
0039: F600
0040: F600             BYTE       EQU    1                    ; Number of bytes for "byte" type
0041: F600             WORD       EQU    2                    ; Number of bytes for "word" type
0042: F600
0043: F600
0044: F600             ASCII_MASK EQU    7FH                  ; ASCII mask 7 bits
0045: F600             EndOfMessage EQU    00H
0046: F600
0047: F600             CTRL_C     EQU    03H                  ; ETX
0048: F600             CTRL_E     EQU    05H                  ; Physical EOL
0049: F600             CTRL_H     EQU    08H                  ; Backspace
0050: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0051: F600             CTRL_P     EQU    10H                  ; Print toggle
0052: F600             CTRL_R     EQU    12H                  ; Repeat line
0053: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0054: F600             CTRL_U     EQU    15H                  ; Line delete
0055: F600             CTRL_X     EQU    18H                  ; Logical line delete
0056: F600             CTRL_Z     EQU    1AH                  ; End of file
0057: F600
0058: F600             TAB        EQU    09H                  ; Tab
0059: F600             LF         EQU    0AH                  ; Line Feed
0060: F600             CR         EQU    0DH                  ; Carriage Return
0061: F600             SPACE      EQU    20H                  ; Space
0062: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0063: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0064: F600             PERCENT    EQU    25H                  ; Percent Sign
0065: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0066: F600             PERIOD     EQU    2EH                  ; Period
0067: F600             ASCII_ZERO EQU    30H                  ; zero
0068: F600             COLON      EQU    3AH                  ; Colon
0069: F600
0070: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0071: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0072: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0073: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0074: F600             QMARK      EQU    3FH                  ; Question Mark
0075: F600             UNDER_SCORE EQU    5FH                  ; under score _
0076: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0077: F600             RUBOUT     EQU    7FH                  ; Delete Key
0078: F600
0079: F600
0080: F600             ASCII_A    EQU    'A'
0081: F600             ASCII_C    EQU    'C'
0082: F600             ASCII_M    EQU    'M'
0083: F600             ASCII_O    EQU    'O'
0084: F600             ASCII_Y    EQU    'Y'
0085: F600             CARET      EQU    '^'
0086: F600
0087: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0088: F600                        Include ./osHeader.Z80
0089: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0090: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0091: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0092: F600         ; osHeader.Z80
0093: F600
0094: F600         ; 2018-12-28 Changed BDOSEntry to remove dead space in BDOS
0095: F600         ; 2017-03-02 Refactored the CP/M Suite
0096: F600
0097: F600         ; Contains the Equates used by the CP/M system
0098: F600
0099: F600         ;------------------------Page Zero Constants ---------------------------------
0100: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0101: F600
0102: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0103: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0104: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0105: F600
0106: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0107: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0108: F600
0109: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0110: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0111: F600
0112: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0113: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0114: F600
0115: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0116: F600             ComTailCount EQU    ComTail              ; Count of the number of char in tail
0117: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0118: F600         ;-----------------------------------------------------------------------
0119: F600
0120: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0121: F600         ;-----------------------------------------------------------------------
0122: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0123: F600         ;-----------------------------------------------------------------------
0124: F600             END_OF_FILE EQU    1AH                  ; end of file
0125: F600         ;-----------------------------------------------------------------------
0126: F600
0127: F600         ;--------------- CP/M Constants -----------------------------------------
0128: F600
0129: F600             CCPLength  EQU    0800H                ; Constant
0130: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0131: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0132: F600
0133: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0134: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0135: F600
0136: F600             MemorySize EQU    64
0137: F600
0138: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0139: F600
0140: F600             BDOSBase   EQU    CCPEntry + CCPLength
0141: F600             BDOSEntry  EQU    BDOSBase
0142: F600
0143: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0144: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0145: F600         ;-----------------------------------------------------------------------
0146: F600
0147: F600         ;? ;------------------- BDOS System Call Equates --------------------------
0148: F600         ;? fConsoleIn			EQU		01H			; rcharf - Console Input
0149: F600         ;? fConsoleOut			EQU		02H			; pcharf - Console Output
0150: F600         ;? fPrintString		EQU		09H			; pbuff	- Print String
0151: F600         ;? fReadString			EQU		0AH			; rbuff	- Read Console String
0152: F600         ;? fGetConsoleStatus	EQU		0BH			; breakf - Get Console Status
0153: F600         ;? fGetVersion			EQU		0CH			; liftf	- Return Version Number
0154: F600         ;? fResetSystem		EQU		0DH			; initf	- Reset Disk System
0155: F600         ;? fSelectDisk			EQU		0EH			; self	- Select Disk
0156: F600         ;? fOpenFile			EQU		0FH			; openf	- Open File
0157: F600         ;? fCloseFile			EQU		10H			; closef - Close File
0158: F600         ;? fSearchFirst		EQU		11H			; searf	- Search For First
0159: F600         ;? fSearchNext			EQU		12H			; searnf - Search for Next
0160: F600         ;? fDeleteFile			EQU		13H			; delf - Delete File
0161: F600         ;? fReadSeq			EQU		14H			; dreadf - Read Sequential
0162: F600         ;? fWriteSeq			EQU		15H			; dwritf - Write Sequential
0163: F600         ;? fMakeFile			EQU		16H			; makef	- Make File
0164: F600         ;? fRenameFile			EQU		17H			; renf	- Rename File
0165: F600         ;? fGetLoginVector		EQU		18H			; logf	- Return Login Vector
0166: F600         ;? fGetCurrentDisk		EQU		19H			; cself	- Return Current Disk
0167: F600         ;? fSetDMA				EQU		1AH			; dmaf	- Set DMA address
0168: F600         ;? fGetSetUserNumber	EQU		20H			; userf	- Set/Get User Code
0169: F600         ;? ;-----------------------------------------------------------------------
0170: F600         ;?
0171: F600         ;?
0172: F600         ;?
0173: F600         ;?
0174: F600         ;?
0175: F600         ;? ;*******************************************************************************
0176: F600         ;? ; These are the values handed over by the BDOS when it calls the Writer operation
0177: F600         ;? ; The allocated.unallocated indicates whether the BDOS is set to write to an
0178: F600         ;? ; unallocated allocation block (it only indicates this for the first 128 byte
0179: F600         ;? ; sector write) or to an allocation block that has already been allocated to a
0180: F600         ;? ; file. The BDOS also indicates if it is set to write to the file directory
0181: F600         ;? ;*******************************************************************************
0182: F600         ;? WriteAllocated		EQU	00H
0183: F600         ;? WriteDirectory		EQU	01H
0184: F600         ;? WriteCleanBuffer	EQU	02H
0185: F600
0186: F600
0187: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0188: F600                        Include ./diskHeader.Z80
0189: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0190: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0191: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0192: F600         ; diskHeader.asm
0193: F600
0194: F600         ; 2017-03-02 Refactored the CP/M Suite
0195: F600
0196: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0197: F600
0198: F600         ; Contains the Equates used by the CP/M system to handle disks
0199: F600
0200: F600
0201: F600         ;*******************************************************************************
0202: F600         ;
0203: F600         ;     Disk related values
0204: F600         ;
0205: F600         ;
0206: F600         ;*******************************************************************************
0207: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0208: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0209: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0210: F600         ; for boot
0211: F600             DiskControlTable EQU    0040H
0212: F600
0213: F600             DiskReadCode EQU    01H                  ; Code for Read
0214: F600             DiskWriteCode EQU    02H                  ; Code for Write
0215: F600
0216: F600
0217: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0218: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0219: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0220: F600
0221: F600             DirEntrySize EQU    20H                  ; (32)
0222: F600             DirBuffSize EQU    cpmRecordSize
0223: F600
0224: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0225: F600
0226: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0227: F600
0228: F600
0229: F600         ;-------------------------------------------------------------------------------------
0230: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0231: F600
0232: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0233: F600             NumberOfHeads EQU    02H                  ; number of heads
0234: F600             TracksPerHead EQU    50H                  ; 80
0235: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0236: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0237: F600             DirectoryBlockCount EQU    02H                  ;
0238: F600         ;-----------------------------------------------------------------------
0239: F600
0240: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0241: F600
0242: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0243: F600
0244: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0245: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0246: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0247: F600
0248: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0249: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0250: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0251: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0252: F600
0253: F600         ;-----------------------------------------------------------------------
0254: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0255: F600         ;-----------------------------------------------------------------------
0256: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0257: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0258: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0259: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0260: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0261: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0262: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0263: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0264: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0265: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0266: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0267: F600             dpb3hdNOH  EQU    NumberOfHeads
0268: F600
0269: F600         ;*******************************************************************************
0270: F600
0271: F600             SectorMask EQU    SectorsPerBlock - 1
0272: F600
0273: F600         ;***************************************************************************
0274: F600
0275: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0276: F600
0277: F600             BOOT_CON_ADDRESS EQU    0ECH                 ; tty data address
0278: F600
0279: F600             IN_OPCODE  EQU    0DBH
0280: F600             OUT_OPCODE EQU    0D3H
0281: F600             JP_OPCODE  EQU    0C3H
0282: F600             DISK_READ  EQU    0FFH
0283: F600             DISK_WRITE EQU    000H
0284: F600
0285: F600         ;*******************************************************************************
0286: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0287: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0288: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0289: F600         ; sector write) or to an allocation block that has already been allocated to a
0290: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0291: F600         ;*******************************************************************************
0292: F600             WriteAllocated EQU    00H
0293: F600             WriteDirectory EQU    01H
0294: F600             WriteCleanBuffer EQU    02H
0295: F600
0296: F600
0297: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0298: F600         ; BIOS jump Vector
0299: F600             CodeStart:
0300: F600
0301: F600 C3 33 F6               JP     BOOT                 ; 00 Cold/Hard Boot
0302: F603             WarmBootEntry:
0303: F603 C3 43 F6               JP     WBOOT                ; 01 Warm/Soft Boot
0304: F606 C3 E2 F6               JP     CONST                ; 02 Console Input Status
0305: F609 C3 F4 F6               JP     CONIN                ; 03 Console Input
0306: F60C C3 00 F7               JP     CONOUT               ; 04 Console Output
0307: F60F C3 16 F7               JP     LIST                 ; 05 List Output
0308: F612 C3 21 F7               JP     PUNCH                ; 06 Punch Device Output
0309: F615 C3 2E F7               JP     READER               ; 07 Reader Device Input
0310: F618 C3 F3 F7               JP     HOME                 ; 08 Home Disk
0311: F61B C3 05 F8               JP     SELDSK               ; 09 Select Disk
0312: F61E C3 2F F8               JP     SETTRK               ; 0A Set Track
0313: F621 C3 34 F8               JP     SETSEC               ; 0B Set Sector
0314: F624 C3 39 F8               JP     SETDMA               ; 0C Set DMA Address
0315: F627 C3 41 F8               JP     READ                 ; 0D Read Sector
0316: F62A C3 4E F8               JP     WRITE                ; 0E Write Sector
0317: F62D C3 43 F7               JP     LISTST               ; 0F List Status
0318: F630 C3 3E F8               JP     SECTRAN              ; 10 Sector Translate
0319: F633
0320: F633
0321: F633         ;============================================================================;
0322: F633         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot                                  ;
0323: F633         ;                                                                            ;
0324: F633         ;  The BOOT jump instruction is the first instruction executed in CP/M. The  ;
0325: F633         ; bootstrap sequence must transfer control to the BOOT entry point in order  ;
0326: F633         ; to  bring up CP/M.                                                         ;
0327: F633         ;  This reads in the CP/M loader on the first sector of the physical disk    ;
0328: F633         ; drive chosen to be logical disk A. This CP/M loader program reads the      ;
0329: F633         ; binary image of the CCP, BOOS, and BIOS into memory at some predetermined  ;
0330: F633         ; address. Then it transfers control to the BOOT entry point in the BIOS     ;
0331: F633         ; jump vector. This BOOT routine must initialize all of the required         ;
0332: F633         ; computer hardware.                                                         ;
0333: F633         ;                                                                            ;
0334: F633         ;  Most BOOT routines sign on by displaying a short message on the console,  ;
0335: F633         ; indicating the current version ofCP/M and the computer hardware that this  ;
0336: F633         ; BIOS can support. The BOOT routine terminates by transferring control to   ;
0337: F633         ; the start of the CCP +6 bytes (the CCP has its own small jump vector at    ;
0338: F633         ; the beginning). Just before the BOOT routine jumps into the CCP, it sets   ;
0339: F633         ; the C register to 0 to indicate that logical disk A is to be the default   ;
0340: F633         ; disk drive. This is what causes "A>" to be the CCP's initial prompt.       ;
0341: F633         ;                                                                            ;
0342: F633         ;			Entry Point  	:	BiosStart + (0 *  3).  (00H)                 ;
0343: F633         ;			Entry Parameters:	None										 ;
0344: F633         ;			Exit Parameters :	None										 ;
0345: F633         ;============================================================================;
0346: F633
0347: F633             BOOT:
0348: F633         ;CodeStart:
0349: F633 21 D5 F6               LD     HL,ROMControl
0350: F636 CD 79 F6               CALL   ReadRawDisk          ; Load the boot sector from the disk
0351: F639 D2 00 01               JP     NC,TPA               ; Now execute the boot loader;
0352: F63C
0353: F63C 21 93 F6               LD     HL,NoDiskMessage     ; Else let the user know Disk A does
0354: F63F CD 8B F6               CALL   DisplayMessage       ;  not have a system disk in it
0355: F642 76                     HALT
0356: F643
0357: F643
0358: F643         ;============================================================================;
0359: F643         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot                                   ;
0360: F643         ;                                                                            ;
0361: F643         ;  Unlike the "cold" bootstrap entry point, which executes only once,        ;
0362: F643         ; the WBOOT or warm boot routine will be executed every time a program       ;
0363: F643         ; terminates by jumping to location OOOOH, or whenever you type a CONTROL-C  ;
0364: F643         ; on the console as the first character of an input line.                    ;
0365: F643         ;  The WBOOT routine is responsible for reloading the CCP into memory.       ;
0366: F643         ; Programs often use all of memory up to the starting point of the BDOS,     ;
0367: F643         ; overwriting the CCP in the process. The underlying philosophy is that      ;
0368: F643         ; while a program is executing, the CCP is not needed, so the program can    ;
0369: F643         ; use the memory previously occupied by the CCP. The CCP occupies            ;
0370: F643         ; 800H (2048) bytes ofmemory-and this is frequently just enough to make the  ;
0371: F643         ; difference between a program that cannot run and one that can.             ;
0372: F643         ; A few programs that are self-contained and do not require the BDOS's       ;
0373: F643         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes  ;
0374: F643         ; of memory. Therefore, to be really safe, the WBOOT routine should read in  ;
0375: F643         ; both the CCP and the BDOS. It also needs to set up the two JMPs at         ;
0376: F643         ; location OOOOH (to WBOOT itself) and at location 0005H (to the BOOS).      ;
0377: F643         ; Location 0003H should be set to the initial value of the 10BYTE if this    ;
0378: F643         ; is implemented in the BIOS. As its last act, the WBOOT routine sets        ;
0379: F643         ; register C to indicate which logical disk is to be selected                ;
0380: F643         ; (C= 0 for A, I for B, and so on). It then transfers control into the CCP   ;
0381: F643         ; at the first instruction in order to restart the CCP.                      ;
0382: F643         ;                                                                            ;
0383: F643         ;			Entry Point  	:	BiosStart + (1 *  3).  (003H)                ;
0384: F643         ;			Entry Parameters:	None										 ;
0385: F643         ;			Exit Parameters :	None										 ;
0386: F643         ;============================================================================;
0387: F643
0388: F643             WBOOT:
0389: F643 31 FF DF               LD     SP,CCPEntry-1        ; Put stack at top of User area
0390: F646 21 C8 F6               LD     HL,WBOOTControl      ; Get the WBOOT Control Block
0391: F649 CD 79 F6               CALL   ReadRawDisk          ; Read CCP & BDOS
0392: F64C 30 09                  JR     NC,LoadPage0         ; Set up page 0 if good read
0393: F64E
0394: F64E 21 AE F6               LD     HL,WarmBootErroMessage
0395: F651 CD 8B F6               CALL   DisplayMessage       ; Send bad warm boot message
0396: F654 C3 43 F6               JP     WBOOT                ;  Keep trying
0397: F657
0398: F657
0399: F657         ; Set up page Zero
0400: F657             LoadPage0:
0401: F657 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0402: F659
0403: F659 32 00 00               LD     (WarmBoot),A
0404: F65C 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0405: F65F 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0406: F662
0407: F662 32 05 00               LD     (BDOSE),A
0408: F665 21 00 E8               LD     HL,BDOSEntry         ; BDOS entry point
0409: F668 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0410: F66B
0411: F66B 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0412: F66E CD 39 F8               CALL   SETDMA               ; use normal BDOS  routine
0413: F671 FB                     EI                          ; Enable interrupts
0414: F672
0415: F672 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0416: F675 4F                     LD     C,A
0417: F676 C3 00 E0               JP     CCPEntry             ; Transfer control to CCP
0418: F679
0419: F679
0420: F679
0421: F679
0422: F679         ;=============================================================================
0423: F679         ;---------------------------- Raw Disk Code ---------------------------------;
0424: F679         ;  Enter with DiskControlBlock pointer in HL	                             ;
0425: F679             ReadRawDisk:                      ;
0426: F679 22 46 00               LD     (DiskCommandBlock),HL ; Put it into the DCB in page 0      ;
0427: F67C         ;
0428: F67C 21 45 00               LD     HL,DiskControlByte   ;
0429: F67F 36 80                  LD     (HL),080H            ; Activate the controller            ;
0430: F681         ;
0431: F681             WaitForBootComplete:                      ;
0432: F681 7E                     LD     A,(HL)               ; Get the control byte               ;
0433: F682 B7                     OR     A                    ; Is it completed                    ;
0434: F683 20 FC                  JR     NZ,WaitForBootComplete ; If not try again                   ;
0435: F685         ;
0436: F685 3A 43 00               LD     A,(DiskStatusLocation) ; What's the status?                 ;
0437: F688 FE 80                  CP     080H                 ; Any errors ?                       ;
0438: F68A C9                     RET                         ; Exit with result in the CCs        ;
0439: F68B         ;
0440: F68B         ;---------------------------- Raw Disk Code ---------------------------------;
0441: F68B
0442: F68B         ;---------------------------- Raw Message Code ------------------------------;
0443: F68B             DisplayMessage:                      ;
0444: F68B 7E                     LD     A,(HL)               ;
0445: F68C B7                     OR     A                    ;
0446: F68D C8                     RET    Z                    ;
0447: F68E D3 EC                  OUT    (BOOT_CON_ADDRESS),A ; Console address               	 ;
0448: F690 23                     INC    HL                   ;
0449: F691 18 F8                  JR     DisplayMessage       ;
0450: F693         ;
0451: F693             NoDiskMessage:                      ;
0452: F693 0D 0A                  DB     CR,LF                ;
0453: F695 4E 6F 20 53 79 73 74 65 6D 20 44 69 73 6B 20 4D 6F 75 6E 74 65 64                DB     'No System Disk Mounted' ;
0454: F6AB 0D 0A 00                DB     CR,LF,EndOfMessage   ;
0455: F6AE         ;
0456: F6AE             WarmBootErroMessage:                      ;
0457: F6AE 0D 0A                  DB     CR,LF                ;
0458: F6B0 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'        ;
0459: F6BB 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'         ;
0460: F6C5 0D 0A 00                DB     CR,LF,EndOfMessage   ;
0461: F6C8         ;---------------------------- Raw Message Code ------------------------------;
0462: F6C8         ;---------------------------- WBOOT Disk Control Block ----------------------;
0463: F6C8             WBOOTControl:                      ;
0464: F6C8 01                     DB     DiskReadCode         ; Read function                      ;
0465: F6C9 00                     DB     00H                  ; unit number                        ;
0466: F6CA 00                     DB     00H                  ; head number                        ;
0467: F6CB 00                     DB     00H                  ; track number                       ;
0468: F6CC 02                     DB     02H                  ; Starting sector number             ;
0469: F6CD         ;  (skip cold boot sector)           ;
0470: F6CD 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read            ;
0471: F6CF         ;  ( rest of the head)               ;
0472: F6CF 00 E0                  DW     CCPEntry             ; read into this address             ;
0473: F6D1 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking ;
0474: F6D3 45 00                  DW     DiskControlByte      ; pointer to next table- no linking  ;
0475: F6D5         ;---------------------------- WBOOT Disk Control Block ----------------------;
0476: F6D5         ;---------------------------- ROM Disk Control Block ------------------------;
0477: F6D5             ROMControl:                      ;
0478: F6D5 01                     DB     DiskReadCode         ; Read function                      ;
0479: F6D6 00                     DB     00H                  ; unit number                        ;
0480: F6D7 00                     DB     00H                  ; head number                        ;
0481: F6D8 00                     DB     00H                  ; track number                       ;
0482: F6D9 01                     DB     01H                  ; Starting sector number ()          ;
0483: F6DA 00 02                  DW     diskSectorSize       ; Number of bytes to read ( 1 Sector);
0484: F6DC 00 01                  DW     TPA                  ; read into this address             ;
0485: F6DE 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking ;
0486: F6E0 40 00                  DW     DiskControlTable     ; pointer to next table- no linking  ;
0487: F6E2         ;---------------------------- ROM Disk Control Block ------------------------;
0488: F6E2
0489: F6E2         ;=============================================================================
0490: F6E2
0491: F6E2
0492: F6E2         ;============================================================================;
0493: F6E2         ;	Console Status:		BIOS 02                                              ;
0494: F6E2         ;                                                                            ;
0495: F6E2         ;  CONST simply returns an indicator showing whether there is an incoming    ;
0496: F6E2         ; character from the console device. The convention is that A = OFFH if a    ;
0497: F6E2         ; character is waiting to be processed, A = 0 if one is not. Note that the   ;
0498: F6E2         ; zero flag need not be set to reflect the contents of the A register        ;
0499: F6E2         ; it is the contents that are important. CONST is called by the CCP whenever ;
0500: F6E2         ; the CCP is in the middle of an operation that can be interrupted by        ;
0501: F6E2         ; pressing a keyboard character.                                             ;
0502: F6E2         ;                                                                            ;
0503: F6E2         ;  The BDOS will call CONST if a program makes a Read Console Status         ;
0504: F6E2         ; function call (CONST, code 11, OBH). It is also called by the console      ;
0505: F6E2         ; input BIOS routine, CONIN                                                  ;
0506: F6E2         ;                                                                            ;
0507: F6E2         ;			Entry Point  	:	BiosStart + (2 *  3).  (006H)                ;
0508: F6E2         ;			Entry Parameters:	None										 ;
0509: F6E2         ;			Exit Parameters :	A = 0FFH if there is a character waiting	 ;
0510: F6E2         ;			                    A = 00H  if one is not						 ;
0511: F6E2         ;============================================================================;
0512: F6E2
0513: F6E2             CONST:
0514: F6E2             ConStatus:
0515: F6E2 3A 03 00               LD     A,(IOBYTE)
0516: F6E5 DD 21 D3 F7               LD     IX,CON_Vector
0517: F6E9
0518: F6E9             GenericInStatus:                      ; Entry point for generic input status
0519: F6E9 CD 8F F7               CALL   SetDeviceVector      ; IX has the vector
0520: F6EC CD 5C F7               CALL   GetInStatus          ;  for the Physical Device
0521: F6EF B7                     OR     A
0522: F6F0 C8                     RET    Z                    ; 00 => No data pending
0523: F6F1 3E FF                  LD     A,0FFH
0524: F6F3 C9                     RET                         ; OFFH => Data in Buffer
0525: F6F4
0526: F6F4         ;============================================================================;
0527: F6F4         ;	Console In:		BIOS 03                                                  ;
0528: F6F4         ;                                                                            ;
0529: F6F4         ;  CONIN reads the next character from the console to the A register and     ;
0530: F6F4         ; sets; the most significant (parity) bit to O. Normally, CONIN will call    ;
0531: F6F4         ; the CONST routine until it detects A = OFFH. Only then will it input the   ;
0532: F6F4         ; data character and mask off the parity bit. CONIN is called by the CCP     ;
0533: F6F4         ; and by the BDOS when a program executes a Read Console Byte function       ;
0534: F6F4         ; (CONIN, code 1). Normally this follows a call to CONST                     ;
0535: F6F4         ; ( a blocking call) to indicates a char is ready.                           ;
0536: F6F4         ;                                                                            ;
0537: F6F4         ; This is a blocking routine                                                 ;
0538: F6F4         ;                                                                            ;
0539: F6F4         ;			Entry Point  	:	BiosStart + (3 *  3).  (009H)                ;
0540: F6F4         ;			Entry Parameters:	None										 ;
0541: F6F4         ;			Exit Parameters :	A = ASCII character read from console   	 ;
0542: F6F4         ;============================================================================;
0543: F6F4
0544: F6F4             CONIN:
0545: F6F4             ConIn:
0546: F6F4 CD E2 F6               CALL   ConStatus            ; Loop until there is some
0547: F6F7 28 FB                  JR     Z,ConIn              ;   data to read
0548: F6F9         ; Call to ConStatus Sets up IX with Physical Table
0549: F6F9 DD 6E 06               LD     L,(IX+DataReadIndex)
0550: F6FC DD 66 07               LD     H,(IX+(DataReadIndex+1))
0551: F6FF E9                     JP     (HL)
0552: F700         ;============================================================================;
0553: F700         ;	Console Out:		BIOS 04                                              ;
0554: F700         ;                                                                            ;
0555: F700         ;  CONOUT outputs the character (in ASCII) in register C to the console. The ;
0556: F700         ; most significant (parity) bit of the character will always be O.           ;
0557: F700         ; CONOUT must first check that the console device is ready to receive more   ;
0558: F700         ; data, delaying if necessary until it is, and only then sending the         ;
0559: F700         ; character to the device. CONOUT is called by the CCP and by the BDOS when  ;
0560: F700         ; a program executes a Write Console Byte function (CONOUT, code 2).         ;
0561: F700         ;                                                                            ;
0562: F700         ; This is a blocking routine                                                 ;
0563: F700         ;                                                                            ;
0564: F700         ;			Entry Point  	:	BiosStart + (4 *  3).  (00CH)                ;
0565: F700         ;			Entry Parameters:	C = ASCII character to be sent to Console	 ;
0566: F700         ;			Exit Parameters :	None										 ;
0567: F700         ;============================================================================;
0568: F700
0569: F700             CONOUT:
0570: F700             CONOut:
0571: F700 3A 03 00               LD     A,(IOBYTE)
0572: F703 DD 21 D3 F7               LD     IX,CON_Vector
0573: F707         ; entry point for standard blocking write
0574: F707             GenericOutStatus:
0575: F707 CD 8F F7               CALL   SetDeviceVector
0576: F70A         ; IX has the vector for the Physical Device
0577: F70A             GenericOutStatus1:
0578: F70A CD 57 F7               CALL   GetOutStatus
0579: F70D 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0580: F70F DD 6E 08               LD     L,(IX+DataWriteIndex)
0581: F712 DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0582: F715 E9                     JP     (HL)
0583: F716
0584: F716         ;============================================================================;
0585: F716         ;	List output  BIOS 05                                                     ;
0586: F716         ;                                                                            ;
0587: F716         ;  LIST is similar to CONOUT except that it sends the character in register  ;
0588: F716         ; C to the list device. It too checks first that the list device is ready to ;
0589: F716         ; receive the character. LIST is called by the CCP in response to the        ;
0590: F716         ; CONTROL-P toggle for printer echo of console output, and by the BDOS when	 ;
0591: F716         ; a program makes a Write Printer Byte or Display String call                ;
0592: F716         ; (LISTOUT and PRINTS, codes 5 and 9).                                       ;
0593: F716         ;                                                                            ;
0594: F716         ; This is a blocking routine                                                 ;
0595: F716         ;                                                                            ;
0596: F716         ;			Entry Point  	:	BiosStart + (5 *  3.)  (00FH)                ;
0597: F716         ;			Entry Parameters:	C = ASCII character to be sent to List Device;
0598: F716         ;			Exit Parameters :	None										 ;
0599: F716         ;============================================================================;
0600: F716
0601: F716             LIST:
0602: F716 3A 03 00               LD     A,(IOBYTE)
0603: F719 07                     RLCA                        ; move bits 7,6
0604: F71A 07                     RLCA                        ; to 1,0
0605: F71B DD 21 EB F7               LD     IX,LST_Vector
0606: F71F 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0607: F721
0608: F721         ;============================================================================;
0609: F721         ;	Punch output  BIOS 06                                                    ;
0610: F721         ;                                                                            ;
0611: F721         ;  PUNCH sends the character in register C to the "punch" device. As         ;
0612: F721         ; mentioned earlier, the "punch" is rarely a real paper tape punch.          ;
0613: F721         ; In most BIOS's, the PUNCH entry point either returns immediately and is    ;
0614: F721         ; effectively a null routine, or it outputs the character to a               ;
0615: F721         ; communications device, such as a; modem, on your computer. PUNCH must      ;
0616: F721         ; check that the "punch" device is indeed ready to accept another character  ;
0617: F721         ; for output, and must wait if it is not.                                    ;
0618: F721         ;                                                                            ;
0619: F721         ;  Digital Research's documentation states that the character to be output   ;
0620: F721         ; will always have its most significant bit set to O. This is not true.      ;
0621: F721         ; The BDOS simply transfers control over to the PUNCH entry point in the     ;
0622: F721         ; BIOS the setting of the most significant bit will be determined by the     ;
0623: F721         ; program making the BDOS function request (PUNOUT, code 4). This is         ;
0624: F721         ; important because the requirement of a zero would preclude being able to   ;
0625: F721         ; send pure  binary data via the BIOS PUNCH function                         ;
0626: F721         ;                                                                            ;
0627: F721         ; This is a blocking routine                                                 ;
0628: F721         ;                                                                            ;
0629: F721         ;			Entry Point  	:	BiosStart + (6 *  3).  (012H)                ;
0630: F721         ;			Entry Parameters:	C = ASCII character to be sent toPunch Device;
0631: F721         ;			Exit Parameters :	None										 ;
0632: F721         ;============================================================================;
0633: F721
0634: F721             PUNCH:                          ; Punch output
0635: F721 3A 03 00               LD     A,(IOBYTE)
0636: F724 0F                     RRCA
0637: F725 0F                     RRCA
0638: F726 0F                     RRCA                        ; move bits 5,4
0639: F727 0F                     RRCA                        ; to 1,0
0640: F728 DD 21 E3 F7               LD     IX,PUN_Vector
0641: F72C 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0642: F72E
0643: F72E         ;============================================================================;
0644: F72E         ;	Reader input  BIOS 07                                                    ;
0645: F72E         ;                                                                            ;
0646: F72E         ;  As with the PUNCH entry point, the READER entry point rarely connects to  ;
0647: F72E         ; a real paper tape reader.                                                  ;
0648: F72E         ; The READER function must return the next character from the reader device  ;
0649: F72E         ; in the A register, waiting, if need be, until there is a character.        ;
0650: F72E         ;                                                                            ;
0651: F72E         ;  Digital Research's documentation again says that the most significant bit ;
0652: F72E         ; of the A register must be 0, but this is not the case if you wish to       ;
0653: F72E         ; receive pure binary information via this function.                         ;
0654: F72E         ;                                                                            ;
0655: F72E         ;  READER is called whenever a program makes a Read "Reader" Byte function   ;
0656: F72E         ; request (READIN, code 3).                                                  ;
0657: F72E         ;                                                                            ;
0658: F72E         ; This is a blocking routine                                                 ;
0659: F72E         ;                                                                            ;
0660: F72E         ;			Entry Point  	:	BiosStart + (7 *  3).  (015H)                ;
0661: F72E         ;			Entry Parameters:	None										 ;
0662: F72E         ;			Exit Parameters :	A = ASCII character read from Reader Device	 ;
0663: F72E         ;============================================================================;
0664: F72E
0665: F72E             READER:                         ; Reader Input
0666: F72E 3A 03 00               LD     A,(IOBYTE)
0667: F731 0F                     RRCA
0668: F732 0F                     RRCA                        ; move bits 3,2  to 1,0
0669: F733 DD 21 DB F7               LD     IX,RDR_Vector
0670: F737             READER1:
0671: F737 CD E9 F6               CALL   GenericInStatus
0672: F73A 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0673: F73C
0674: F73C DD 6E 06               LD     L,(IX+DataReadIndex)
0675: F73F DD 66 07               LD     H,(IX+(DataReadIndex+1))
0676: F742 E9                     JP     (HL)
0677: F743
0678: F743         ;============================================================================;
0679: F743         ;	List Status:  BIOS 0F                                                    ;
0680: F743         ;                                                                            ;
0681: F743         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.  ;
0682: F743         ; This function returns the current status of the list device, using the     ;
0683: F743         ; IOBYTE if necessary to select the correct physical device. It sets the A   ;
0684: F743         ; register to OFFH if the list device can accept another character for       ;
0685: F743         ; output or to OOH if it is not ready. Digital Research's documentation      ;
0686: F743         ; states that this function is used by the DESPOOL utility program (which    ;
0687: F743         ; allows you to print a file "simultaneously" with other operations) to      ;
0688: F743         ; improve console response during its operation, and that it is acceptable   ;
0689: F743         ; for the routine always to return OOH if you choose not to implement it     ;
0690: F743         ; fully. Unfortunately, this statement is wrong. Many other programs use     ;
0691: F743         ; the LISTST function to "poll" the list device to make sure it is ready,    ;
0692: F743         ; and if it fails to come ready after a predetermined time, to output a      ;
0693: F743         ; message to the console; indicating that the printer is not ready. If you   ;
0694: F743         ; ever make a call to the BDOS list output functions, Write Printer Byte     ;
0695: F743         ; and Print String (codes 5 and 9), and the printer is not ready,            ;
0696: F743         ; then CP/M will wait forever-and your program will have lost control so     ;
0697: F743         ; it cannot even detect that the problem has occurred. If LISTST always      ;
0698: F743         ; returns a OOH, then the printer will always appear not to be ready.        ;
0699: F743         ; Not only does this make nonsense out of the LISTST function, but it also   ;
0700: F743         ; causes a stream of false "Printer not Ready" error messages to appear      ;
0701: F743         ; on the console.											                 ;
0702: F743         ;                                                                            ;
0703: F743         ;			Entry Point  	:	BiosStart + (F *  3).  (02DH)                ;
0704: F743         ;			Entry Parameters:	None										 ;
0705: F743         ;			Exit Parameters :	A = 0FFH if List Device is ready        	 ;
0706: F743         ;			                    A = 00H  if List Device is  not ready     	 ;
0707: F743         ;============================================================================;
0708: F743
0709: F743             LISTST:
0710: F743 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0711: F746 07                     RLCA
0712: F747 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0713: F748 DD 21 EB F7               LD     IX,LST_Vector        ; Set th vector base
0714: F74C CD 8F F7               CALL   SetDeviceVector      ; IX has the vector for
0715: F74F CD 57 F7               CALL   GetOutStatus         ;  the Physical Device
0716: F752
0717: F752 B7                     OR     A
0718: F753 C8                     RET    Z                    ; 00 => Device Ready
0719: F754 3E FF                  LD     A,0FFH
0720: F756 C9                     RET                         ; OFFH => Device No Ready
0721: F757
0722: F757         ;-----------------------------------------------------------------------------
0723: F757         ;-----------------------------------------------------------------------------
0724: F757             GetOutStatus:
0725: F757         ; vector to CON Devices
0726: F757 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0727: F75A 18 03                  JR     GetStatus
0728: F75C             GetInStatus:
0729: F75C DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0730: F75F             GetStatus:
0731: F75F DD 6E 04               LD     L,(IX+StatusReadIndex)
0732: F762 DD 66 05               LD     H,(IX+(StatusReadIndex+1))
0733: F765         ; Load HL with address for Status Read
0734: F765 E9                     JP     (HL)                 ; jump to the stats read routine
0735: F766
0736: F766         ;-----------------------------------------------------------------------------
0737: F766
0738: F766             DataRead:
0739: F766 DD 7E 01               LD     A,(IX+DataPortIndex)
0740: F769 32 6D F7               LD     (AddressDataIn),A    ; modify code with the Data port
0741: F76C DB                     DB     IN_OPCODE
0742: F76D             AddressDataIn:
0743: F76D 00                     DB     00                   ; perform the read
0744: F76E C9                     RET
0745: F76F
0746: F76F             DataReadASCII:
0747: F76F CD 66 F7               CALL   DataRead
0748: F772 E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0749: F774 C9                     RET
0750: F775
0751: F775         ; Enter DataWrite the value to be output in C
0752: F775             DataWrite:
0753: F775 DD 7E 01               LD     A,(IX+DataPortIndex)
0754: F778 32 7D F7               LD     (AddressDataOut),A   ; modify code with the Data port
0755: F77B 79                     LD     A,C                  ; get value into ACC
0756: F77C D3                     DB     OUT_OPCODE
0757: F77D             AddressDataOut:
0758: F77D 00                     DB     00                   ; perform the write
0759: F77E C9                     RET
0760: F77F
0761: F77F
0762: F77F         ; Enter Status Read with Target mask in D
0763: F77F             StatusRead:
0764: F77F DD 7E 00               LD     A,(IX+StatusPortIndex)
0765: F782 32 86 F7               LD     (AddressStatus),A    ; modify code with the status port
0766: F785 DB                     DB     IN_OPCODE
0767: F786             AddressStatus:
0768: F786 00                     DB     00
0769: F787 A2                     AND    D                    ; Check return vale with the mask
0770: F788 C9                     RET
0771: F789
0772: F789             DUMMYRead:
0773: F789 C9                     RET
0774: F78A             DUMMYWrite:
0775: F78A C9                     RET
0776: F78B             DUMMYCheck:
0777: F78B 3E FF                  LD     A,0FFH               ; Always return 0FFH
0778: F78D B7                     OR     A                    ; Set flags
0779: F78E C9                     RET
0780: F78F
0781: F78F         ;============================================================================;
0782: F78F             SetDeviceVector:
0783: F78F E6 03                  AND    03H                  ; Get bits 0 & 1;
0784: F791 87                     ADD    A,A                  ; Double for word size index
0785: F792 16 00                  LD     D,00H
0786: F794 5F                     LD     E,A                  ; load byte index int DE
0787: F795 DD 19                  ADD    IX,DE                ; add to the value vector base
0788: F797         ; IX points at correct entry in vector
0789: F797 DD 5E 00               LD     E,(IX+0)
0790: F79A DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0791: F79D D5                     PUSH   DE
0792: F79E DD E1                  POP    IX                   ; Move it to IX
0793: F7A0 C9                     RET
0794: F7A1
0795: F7A1
0796: F7A1         ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0797: F7A1         ; Physical Device Attributes
0798: F7A1
0799: F7A1             TTY_StatusPort EQU    0EDH
0800: F7A1             TTY_DataPort EQU    0ECH
0801: F7A1             TTY_OutputMask EQU    80H                  ; Status Mask
0802: F7A1             TTY_InputMask EQU    7FH                  ; Status Mask
0803: F7A1
0804: F7A1             CRT_StatusPort EQU    02H
0805: F7A1             CRT_DataPort EQU    01H
0806: F7A1             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0807: F7A1             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to  read
0808: F7A1
0809: F7A1             COM_StatusPort EQU    0EDH
0810: F7A1             COM_DataPort EQU    0ECH
0811: F7A1             COM_OutputMask EQU    01H                  ; Status Mask
0812: F7A1             COM_InputMask EQU    02H                  ; Status Mask
0813: F7A1
0814: F7A1             LPT_StatusPort EQU    011H
0815: F7A1             LPT_DataPort EQU    010H
0816: F7A1             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0817: F7A1             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0818: F7A1
0819: F7A1             DUMMY_StatusPort EQU    011H
0820: F7A1             DUMMY_DataPort EQU    010H
0821: F7A1             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0822: F7A1             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0823: F7A1
0824: F7A1         ; Device Table Control Block Definition
0825: F7A1             StatusPortIndex EQU    0
0826: F7A1             DataPortIndex EQU    1
0827: F7A1             OutputMaskIndex EQU    2
0828: F7A1             InputMaskIndex EQU    3
0829: F7A1             StatusReadIndex EQU    4
0830: F7A1             DataReadIndex EQU    6
0831: F7A1             DataWriteIndex EQU    8
0832: F7A1
0833: F7A1         ;Physical Devices Control Blocks
0834: F7A1
0835: F7A1             TTY_Table:
0836: F7A1 ED                     DB     TTY_StatusPort
0837: F7A2 EC                     DB     TTY_DataPort
0838: F7A3 80                     DB     TTY_OutputMask
0839: F7A4 7F                     DB     TTY_InputMask
0840: F7A5 7F F7                  DW     StatusRead
0841: F7A7 6F F7                  DW     DataReadASCII
0842: F7A9 75 F7                  DW     DataWrite
0843: F7AB
0844: F7AB             CRT_Table:
0845: F7AB 02                     DB     CRT_StatusPort
0846: F7AC 01                     DB     CRT_DataPort
0847: F7AD 80                     DB     CRT_OutputMask
0848: F7AE 7F                     DB     CRT_InputMask
0849: F7AF 7F F7                  DW     StatusRead
0850: F7B1 66 F7                  DW     DataRead
0851: F7B3 75 F7                  DW     DataWrite
0852: F7B5             COM_Table:
0853: F7B5 ED                     DB     COM_StatusPort
0854: F7B6 EC                     DB     COM_DataPort
0855: F7B7 01                     DB     COM_OutputMask
0856: F7B8 02                     DB     COM_InputMask
0857: F7B9 7F F7                  DW     StatusRead
0858: F7BB 66 F7                  DW     DataRead
0859: F7BD 75 F7                  DW     DataWrite
0860: F7BF             LPT_Table:
0861: F7BF 11                     DB     LPT_StatusPort
0862: F7C0 10                     DB     LPT_DataPort
0863: F7C1 FF                     DB     LPT_OutputMask
0864: F7C2 7F                     DB     LPT_InputMask
0865: F7C3 7F F7                  DW     StatusRead
0866: F7C5 66 F7                  DW     DataRead
0867: F7C7 75 F7                  DW     DataWrite
0868: F7C9             DUMMY_Table:
0869: F7C9 11                     DB     DUMMY_StatusPort
0870: F7CA 10                     DB     DUMMY_DataPort
0871: F7CB FF                     DB     DUMMY_OutputMask
0872: F7CC 7F                     DB     DUMMY_InputMask
0873: F7CD 8B F7                  DW     DUMMYCheck
0874: F7CF 89 F7                  DW     DUMMYRead
0875: F7D1 8A F7                  DW     DUMMYWrite
0876: F7D3
0877: F7D3         ;-----------------------------------------------------------------------------
0878: F7D3
0879: F7D3         ; Logical Device Vector, Controlled by IOBYTE
0880: F7D3
0881: F7D3             CON_Vector:                      ; IOBYTE bits 1 & 0
0882: F7D3 A1 F7                  DW     TTY_Table
0883: F7D5 AB F7                  DW     CRT_Table
0884: F7D7 B5 F7                  DW     COM_Table
0885: F7D9 C9 F7                  DW     DUMMY_Table
0886: F7DB             RDR_Vector:                      ; IOBYTE bits 3 & 2
0887: F7DB A1 F7                  DW     TTY_Table
0888: F7DD AB F7                  DW     CRT_Table
0889: F7DF C9 F7                  DW     DUMMY_Table
0890: F7E1 C9 F7                  DW     DUMMY_Table
0891: F7E3             PUN_Vector:                      ; IOBYTE bits 5 & 4
0892: F7E3 A1 F7                  DW     TTY_Table
0893: F7E5 C9 F7                  DW     DUMMY_Table
0894: F7E7 B5 F7                  DW     COM_Table
0895: F7E9 AB F7                  DW     CRT_Table
0896: F7EB             LST_Vector:                      ; IOBYTE bits 7 & 6
0897: F7EB BF F7                  DW     LPT_Table
0898: F7ED AB F7                  DW     CRT_Table
0899: F7EF BF F7                  DW     LPT_Table
0900: F7F1 C9 F7                  DW     DUMMY_Table
0901: F7F3
0902: F7F3         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0903: F7F3         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0904: F7F3
0905: F7F3         ;============================================================================;
0906: F7F3         ;                            Disk routines                                   ;
0907: F7F3         ;============================================================================;
0908: F7F3         ;                                                                            ;
0909: F7F3         ;  All of the disk functions that follow were originally designed to operate ;
0910: F7F3         ; on the 128-byte sectors used on single-sided, single-density, 8-inch       ;
0911: F7F3         ; floppy diskettes that were standard in the industry at the time.           ;
0912: F7F3         ; Now that CP/M runs on many different types of disks, some of the BIOS      ;
0913: F7F3         ; disk functions seem strange because most of the new disk drives use        ;
0914: F7F3         ; sector sizes other than 128 bytes. To handle larger sector sizes,          ;
0915: F7F3         ; the BIOS has some additional code that makes the BDOS respond as if it     ;
0916: F7F3         ; were still handling 128-byte sectors. This code is referred to as the      ;
0917: F7F3         ; blocking/deblocking code.  As its name implies, it blocks together         ;
0918: F7F3         ; several 128-byte "sectors" and only writes to the disk when a complete     ;
0919: F7F3         ; physical sector has been assembled.  When reading, it reads in a physical  ;
0920: F7F3         ; sector and then de-blocks it,handing back several 128-byte "sectors"       ;
0921: F7F3         ; to the BDOS.                                                               ;
0922: F7F3         ;  To do all of this, the blocking/deblocking code uses a special buffer     ;
0923: F7F3         ; area; of the same size as the physical sectors on the disk. This is known  ;
0924: F7F3         ; as the host disk buffer or HSTBUE Physical sectors are read into this      ;
0925: F7F3         ; buffer and written to the disk from it. In order to optimize this          ;
0926: F7F3         ; blocking/deblocking ; routine, the BIOS has code in it to reduce the       ;
0927: F7F3         ; number of times that an; actual disk read or write occurs. A side effect   ;
0928: F7F3         ; is that at any given  moment, several 128-byte "sectors" may be stored     ;
0929: F7F3         ; in the HSTBUF, waiting to be written out to the disk when HSTBUF becomes   ;
0930: F7F3         ; full. This sometimes complicates the logic of the BIOS disk functions.     ;
0931: F7F3         ; You cannot simply select a new disk drive, for example, when the HSTBUF    ;
0932: F7F3         ; contains data destined for another disk drive. You will see this           ;
0933: F7F3         ; complication in the BIOS only in the form of added logical operations the  ;
0934: F7F3         ; BIOS disk functions rarely trigger immediate physical operations.          ;
0935: F7F3         ; It is easier to understand these BIOS functions if you consider that they  ;
0936: F7F3         ; make requests-and that these requests are satisfied only when it makes     ;
0937: F7F3         ; sense to do so, taking into account the blocking/ deblocking logic.        ;
0938: F7F3         ;============================================================================;
0939: F7F3         ;============================================================================;
0940: F7F3
0941: F7F3         ;============================================================================;
0942: F7F3         ;	Home Disk	BIOS 08                                                      ;
0943: F7F3         ;                                                                            ;
0944: F7F3         ;  HOME - Home the selected logical disk to track 0. Before doing this, a    ;
0945: F7F3         ; check must be made to see if the physical disk buffer has information that ;
0946: F7F3         ; must be written out. This is indicated by a flag, DirtyBufferFlag,set in   ;
0947: F7F3         ; the de-blocking code                                                       ;
0948: F7F3         ;                                                                            ;
0949: F7F3         ;			Entry Point  	:	BiosStart + (8 *  3).  (18H)                 ;
0950: F7F3         ;			Entry Parameters:	None										 ;
0951: F7F3         ;			Exit Parameters :	None										 ;
0952: F7F3         ;============================================================================;
0953: F7F3
0954: F7F3             HOME:
0955: F7F3 3A 68 F9               LD     A,(DirtyBufferFlag)  ; Check for Dirty Buffer
0956: F7F6 FE FF                  CP     TRUE
0957: F7F8 28 05                  JR     Z,Home1
0958: F7FA 3E 00                  LD     A,FALSE              ; Clear DataInBufferFlag
0959: F7FC 32 67 F9               LD     (DataInBufferFlag),A ;   if Buffer not dirty
0960: F7FF             Home1:
0961: F7FF 0E 00                  LD     C,00H                ; Set to track 0
0962: F801 CD 2F F8               CALL   SETTRK               ; no, physical, only logical
0963: F804 C9                     RET
0964: F805
0965: F805         ;============================================================================;
0966: F805         ;	Select Disk	BIOS 09                                                      ;
0967: F805         ;                                                                            ;
0968: F805         ;  SELDSK does not do what its name implies. It does not (and must not)      ;
0969: F805         ;  physically select a logical disk. Instead, it returns a pointer in the HL ;
0970: F805         ;  register pair to the disk parameter header for the logical disk specified ;
0971: F805         ;  in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK  ;
0972: F805         ;  also stores this code for the requested disk to be used later in the READ ;
0973: F805         ;  and WRITE functions. If the logical disk code in register C refers to a   ;
0974: F805         ;  nonexistent disk or to one for which no disk parameter header exists,     ;
0975: F805         ; then SELDSK must return with HL set to OOOOH. Then the BDOS will output a  ;
0976: F805         ;  message of the form "BDOS Err on XI Select" Note that SELDSK not only     ;
0977: F805         ; does not select the disk, but also does not indicate whether or not the    ;
0978: F805         ;  requested disk is physically present -merely whether or not there are     ;
0979: F805         ; disk tables present for the disk.                                          ;
0980: F805         ;                                                                            ;
0981: F805         ;  SELDSK is called by the BDOS either during disk file operations or by a   ;
0982: F805         ; program issuing a Select Disk request (SELDSK, code 14).                   ;
0983: F805         ;                                                                            ;
0984: F805         ;			Entry Point  	:	BiosStart + (9 *  3).  (1BH)                 ;
0985: F805         ;			Entry Parameters:	C = Drive to select (0=A,1=B...)             ;
0986: F805         ;			Exit Parameters :	HL = Pointer to Disk Parameter Header		 ;
0987: F805         ;			                    HL = 0000H if no disk found					 ;
0988: F805         ;============================================================================;
0989: F805
0990: F805             SELDSK:
0991: F805 21 00 00               LD     HL,00H               ; Assume an error
0992: F808 79                     LD     A,C
0993: F809 FE 04                  CP     NumberOfLogicalDisks
0994: F80B D0                     RET    NC                   ; return if > max number of Disks
0995: F80C
0996: F80C 32 69 F9               LD     (SelectedDisk),A     ; save disk number
0997: F80F
0998: F80F 07                     RLCA                        ; X2
0999: F810 07                     RLCA                        ; X4
1000: F811 07                     RLCA                        ; X8
1001: F812 07                     RLCA                        ; X16
1002: F813 16 00                  LD     D,0
1003: F815 5F                     LD     E,A                  ; put index int DE
1004: F816 DD 21 74 F9               LD     IX,DiskParameterHeaders ; get DPH address Base
1005: F81A DD 19                  ADD    IX,DE                ; get the specific DiskParameterHeader
1006: F81C DD E5                  PUSH   IX                   ; save for return in HL
1007: F81E
1008: F81E DD 56 0B               LD     D,(IX+11)            ; LSB for Disk Parameter Block
1009: F821 DD 5E 0A               LD     E,(IX+10)            ; MSB for Disk Parameter Block
1010: F824
1011: F824 D5                     PUSH   DE
1012: F825 DD E1                  POP    IX
1013: F827 DD 7E 0F               LD     A,(IX+15)            ; Disk Parameter Block in IY
1014: F82A 32 6E F9               LD     (SelectedDskSecsPerHead),A
1015: F82D
1016: F82D E1                     POP    HL                   ; recover DPH pointer
1017: F82E C9                     RET
1018: F82F
1019: F82F
1020: F82F
1021: F82F         ;============================================================================;
1022: F82F         ;	Set Track	BIOS 0A                                                      ;
1023: F82F         ;                                                                            ;
1024: F82F         ;  SETTRK saves the requested disk track that is in the BC register pair     ;
1025: F82F         ; when SETTRK gets control. Note that this is an absolute track number       ;
1026: F82F         ; that is the number of reserved tracks before the file directory will have  ;
1027: F82F         ; been added to the track number relative to the start of the logical disk.  ;
1028: F82F         ; The number of the requested track will be used in the next BIOS READ or    ;
1029: F82F         ; WRITE function. SETTRK is called by the BDOS when it needs to read or      ;
1030: F82F         ; write a 128-byte sector. Legitimate track numbers are from                 ;
1031: F82F         ; 0 to OFFFFH (65,535).                                                      ;
1032: F82F         ;                                                                            ;
1033: F82F         ;			Entry Point  	:	BiosStart + (A *  3).  (1EH)                 ;
1034: F82F         ;			Entry Parameters:	BC = Absolute Track Number					 ;
1035: F82F         ;			Exit Parameters :	None										 ;
1036: F82F         ;============================================================================;
1037: F82F
1038: F82F             SETTRK:
1039: F82F         ;	LD		H,B							; select track in BC on entry
1040: F82F         ;	LD		L,C
1041: F82F         ;	LD	(SelectedTrack),HL				; save for low level driver
1042: F82F ED 43 6A F9               LD     (SelectedTrack),BC   ; save for low level driver
1043: F833 C9                     RET
1044: F834
1045: F834         ;============================================================================;
1046: F834         ;	Set Sector	BIOS 0B  (Set Record)                                        ;
1047: F834         ;                                                                            ;
1048: F834         ; Sector  = Record for disk with 128 byte sectors                            ;
1049: F834         ;                                                                            ;
1050: F834         ;  Sector contains 4 records for disks with 512 byte sectors this routine is ;
1051: F834         ; missed named it should be called Set Record                                ;
1052: F834         ;                                                                            ;
1053: F834         ;  SETSEC is similar to SETTRK in that it stores the requested Record        ;
1054: F834         ; (sector) number for later use in BIOS READ or WRITE functions. The         ;
1055: F834         ; requested Record (sector) number is handed to SETSEC in the A register     ;
1056: F834         ; legitimate values are from 0 to OFFH (255). The Record (sector) number     ;
1057: F834         ; is a logical Record (sector) number. It does not take into account any     ;
1058: F834         ; sector skewing that might be used to improve disk performance. SETSEC      ;
1059: F834         ; is called by the BDOS when it needs to read or write a 128-byte            ;
1060: F834         ; Record (sector).                                                           ;
1061: F834         ;                                                                            ;
1062: F834         ;			Entry Point  	:	BiosStart + (B *  3).  (21H)                 ;
1063: F834         ;			Entry Parameters:	A = Logical Sector Number					 ;
1064: F834         ;			Exit Parameters :	None										 ;
1065: F834         ;============================================================================;
1066: F834
1067: F834             SETSEC:                         ; SETRECORD
1068: F834 79                     LD     A,C
1069: F835 32 6D F9               LD     (SelectedRecord),A   ; save for low level driver
1070: F838 C9                     RET
1071: F839
1072: F839         ;============================================================================;
1073: F839         ;	Set DMA		BIOS 0C                                                      ;
1074: F839         ;                                                                            ;
1075: F839         ;  SETDMA saves the address in the BC register pair in the requested DMA     ;
1076: F839         ; address. The next BIOS READ or WRITE function will use the DMA address as  ;
1077: F839         ; a pointer to the 128-byte sector buffer into which data will be read or    ;
1078: F839         ; from which data will be written.                                           ;
1079: F839         ;  The default DMA address is 0080H. SETDMA is called by the BDOS when it    ;
1080: F839         ; needs to READ or WRITE a 128-byte sector.                                  ;
1081: F839         ;                                                                            ;
1082: F839         ;			Entry Point  	:	BiosStart + (C *  3).  (24H)                 ;
1083: F839         ;			Entry Parameters:	BC = DMA address							 ;
1084: F839         ;			Exit Parameters :	None										 ;
1085: F839         ;============================================================================;
1086: F839
1087: F839             SETDMA:
1088: F839 ED 43 6F F9               LD     (DMAAddress),BC      ; save for low level driver
1089: F83D C9                     RET
1090: F83E
1091: F83E         ;============================================================================;
1092: F83E         ;	Sector Translate	BIOS 10                                              ;
1093: F83E         ;                                                                            ;
1094: F83E         ;  SECTRAN, given a logical sector number, locates the correct physical      ;
1095: F83E         ;  sector number in the sector translate table for the previously selected   ;
1096: F83E         ;  (via SELDSK) logical disk drive. Note that both logical and physical      ;
1097: F83E         ;  sector numbers are l28-byte sectors, so if you are working with a hard    ;
1098: F83E         ;  disk system, it is not too efficient to impose a sector interlace at the  ;
1099: F83E         ;  l28-byte sector level. It is better to impose the sector interlace right  ;
1100: F83E         ;  inside the hard disk driver, if at all. In general, hard disks spin so    ;
1101: F83E         ;  rapidly that CP/M simply cannot take advantage of sector interlace.       ;
1102: F83E         ;  The BDOS hands over the logical sector number in the BC register pair,    ;
1103: F83E         ;  with the address of the sector translate table in the DE register pair.   ;
1104: F83E         ;  SECTRAN must return the physical sector number in HL. If SECTRAN is to be ;
1105: F83E         ;  a null routine, it must move the contents of BC to HL and return.         ;
1106: F83E         ;                                                                            ;
1107: F83E         ;			Entry Point  	:	BiosStart + (10 *  3).  (30H)                ;
1108: F83E         ;			Entry Parameters:	BC = Original Sector						 ;
1109: F83E         ;			Exit Parameters :	DE = Translated Sector	                 	 ;
1110: F83E         ;============================================================================;
1111: F83E             SECTRAN:
1112: F83E C5                     PUSH   BC
1113: F83F E1                     POP    HL                   ; just move the value from BC to HL
1114: F840 C9                     RET
1115: F841
1116: F841         ;============================================================================;
1117: F841         ;	READ			BIOS 0D                                                  ;
1118: F841         ;                                                                            ;
1119: F841         ;  READ reads in a 128-byte sector provided that there have been previous    ;
1120: F841         ; BIOS function calls to:                                                    ;
1121: F841         ; 				- SELDSK	"select" the disk                                ;
1122: F841         ; 				- SETDMA	set the DMA address                              ;
1123: F841         ; 				- SETTRK	set the track number                             ;
1124: F841         ; 				- SETSEC	set the sector number.                           ;
1125: F841         ; 			                                                                 ;
1126: F841         ;  Because of the blocking/ deblocking code in the BIOS, there are frequent  ;
1127: F841         ; occasions when the requested sector will already be in the host buffer     ;
1128: F841         ; (HSTBUF), so that a physical disk read is not required. All that is then   ;
1129: F841         ; required is for the BIOS to move the appropriate 128 bytes from the        ;
1130: F841         ; HSTBUF into the buffer pointed at by the DMA address. Only during the READ ;
1131: F841         ; function will the BIOS normally communicate with the physical disk drive,  ;
1132: F841         ; selecting it and seeking to read the requested track and sector. During    ;
1133: F841         ; this process, the READ function must also handle any hardware errors that  ;
1134: F841         ; occur, trying an operation again if a "soft," or recoverable, error        ;
1135: F841         ; occurs.                                                                    ;
1136: F841         ;  The READ function must return with the A register set to OOH if the read  ;
1137: F841         ; operation has completed successfully. If the READ function returns with    ;
1138: F841         ; the A register set to 01 H, the BDOS will display an error message of the  ;
1139: F841         ; form BDOS Err on X: Bad Sector. Under these circumstances, you have only   ;
1140: F841         ; two choices. You can enter a CARRIAGE RETURN, ignore the fact that there   ;
1141: F841         ; was an error, and attempt to make sense of the data in the DMA buffer. Or  ;
1142: F841         ; you can type a CONTROL-C to abort the operation, perform a warm boot, and  ;
1143: F841         ; return control to the CCP. As you can see, CP/M's error handling is not    ;
1144: F841         ; particularly helpful, so most BIOS writers add more sophisticated error    ;
1145: F841         ; recovery right in the disk driver. This can include some interaction with  ;
1146: F841         ; the console so that a more determined effort can be made to correct errors ;
1147: F841         ; or, if nothing else, give you more information as to what has gone wrong.  ;
1148: F841         ;                                                                            ;
1149: F841         ;                                                                            ;
1150: F841         ;			Entry Point  	:	BiosStart + (D *  3).  (27H)                 ;
1151: F841         ;			Entry Parameters:	None										 ;
1152: F841         ;			Exit Parameters :	A = 00H Successful Read                 	 ;
1153: F841         ;			                    A = 01H BDOS Err         					 ;
1154: F841         ;============================================================================;
1155: F841
1156: F841             READ:
1157: F841 3E FF                  LD     A,DISK_READ
1158: F843 32 72 F9               LD     (DiskCommand),A      ; Set to Flag to read (non-zero)
1159: F846 3E 02                  LD     A,WriteCleanBuffer   ; Fake a clean sector Write
1160: F848 32 73 F9               LD     (WriteType),A        ;  to avoid a Directory Write later
1161: F84B C3 57 F8               JP     CommonDiskIO         ; Use common code to execute read
1162: F84E
1163: F84E         ;============================================================================;
1164: F84E         ;	WRITE			BIOS 0E                                                  ;
1165: F84E         ;                                                                            ;
1166: F84E         ;  Write a cpmRecord,128-bytes, from the current DMA address to the          ;
1167: F84E         ; previously Selected disk, track, and sector.                               ;
1168: F84E         ;                                                                            ;
1169: F84E         ;  On arrival here, the BDOS will have set register C to indicate whether    ;
1170: F84E         ; this write operation is to:                                                ;
1171: F84E         ;	00H [WriteAllocated]	An already allocated allocation block            ;
1172: F84E         ;	01H [WriteDirectory]	To the directory                                 ;
1173: F84E         ;	02H [WriteCleanBuffer]	To the first cpmRecord of an Alocation block     ;
1174: F84E         ;                                                                            ;
1175: F84E         ;  WRITE is similar to READ but with the obvious difference that data is     ;
1176: F84E         ; transferred from the DMA buffer to the specified 128-byte sector.Like READ,;
1177: F84E         ; this function requires that the following  calls have already been made:   ;
1178: F84E         ;	- SELDSK	"select" the disk                                            ;
1179: F84E         ;	- SETDMA	set the DMA address                                          ;
1180: F84E         ;	- SETTRK	set the track number                                         ;
1181: F84E         ;	- SETSEC	set the sector number.                                       ;
1182: F84E         ;			                                                                 ;
1183: F84E         ;  Again, it is only in the WRITE routine that the driver will start to talk ;
1184: F84E         ; directly to the physical hardware, selecting the disk unit, track, and     ;
1185: F84E         ; sector, and transferring the data to the disk. With the                    ;
1186: F84E         ; blocking/deblocking code, the BDOS optimizes the number of disk writes     ;
1187: F84E         ; that are needed by indicating in register C the type of disk write that    ;
1188: F84E         ; is to be performed:                                                        ;
1189: F84E         ;	0 = normal sector write                                                  ;
1190: F84E         ;	1 = write to file directory sector                                       ;
1191: F84E         ;	2 = write to sector of previously unchanged Deblocking Buffer            ;
1192: F84E         ;			                                                                 ;
1193: F84E         ;  Type 0 occurs whenever the BDOS is writing to a data sector in an already ;
1194: F84E         ; used allocation block. Under these circumstances, the disk driver must     ;
1195: F84E         ; preread the appropriate host sector because there may be previously stored ;
1196: F84E         ; information on it.                                                         ;
1197: F84E         ;                                                                            ;
1198: F84E         ;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in  ;
1199: F84E         ; this case, the BIOS must not defer writing the sector to the disk, as the  ;
1200: F84E         ; information is too valuable to hold in memory until the HSTBUF is full.    ;
1201: F84E         ; The longer the information resides in the HSTBUF, the greater the chance   ;
1202: F84E         ; of a power failure or glitch, making file data already physically written  ;
1203: F84E         ; to the disk inaccessible because the file directory is out of date.        ;
1204: F84E         ;                                                                            ;
1205: F84E         ;  Type 2 occurs whenever the BDOS needs to write to the first sector of a   ;
1206: F84E         ; previously unused allocation block. Unused, in this context, includes an   ;
1207: F84E         ; allocation block that has become available as a result of a file being     ;
1208: F84E         ; erased. In this case, there is no need for the disk driver to preread an   ;
1209: F84E         ; entire host-sized sector into the HSTBUF, as there is no data of value in  ;
1210: F84E         ; the physical sector.                                                       ;
1211: F84E         ;                                                                            ;
1212: F84E         ;  As with the READ routine, the WRITE function returns with A set to OOH if ;
1213: F84E         ; the operation has been completed successfully. If the WRITE function       ;
1214: F84E         ; returns with A set to 01H, then the BDOS will display the same message as  ;
1215: F84E         ; for READ: BDOS Err on X: Bad Sector                                        ;
1216: F84E         ;                                                                            ;
1217: F84E         ;			Entry Point  	:	BiosStart + (E *  3).  (2AH)                 ;
1218: F84E         ;			Entry Parameters:	C = Write type 								 ;
1219: F84E         ;			Exit Parameters :	A = 00H Successful Read                 	 ;
1220: F84E         ;			                    A = 01H BDOS Err         					 ;
1221: F84E         ;============================================================================;
1222: F84E
1223: F84E             WRITE:
1224: F84E 79                     LD     A,C                  ; Retrieve the calling write type
1225: F84F 32 73 F9               LD     (WriteType),A        ; Save the type of write
1226: F852 3E 00                  LD     A,DISK_WRITE
1227: F854 32 72 F9               LD     (DiskCommand),A      ; Set to Flag to Write
1228: F857
1229: F857         ;****************************************************************************;
1230: F857         ;     Common code to execute both reads and writes of 128-byte records       ;
1231: F857         ;****************************************************************************;
1232: F857             CommonDiskIO:
1233: F857 AF                     XOR    A                    ; Assume no disk error will occur
1234: F858 32 71 F9               LD     (DiskStatus),A
1235: F85B         ;-------------------------Convert selected record into physical sector-------;
1236: F85B 3A 6D F9               LD     A,(SelectedRecord)   ;
1237: F85E 1F                     RRA                         ; Convert selected record into       ;
1238: F85F 1F                     RRA                         ;  physical sector by dividing by    ;
1239: F860 E6 3F                  AND    03FH                 ; Remove unwanted bits               ;
1240: F862 32 6C F9               LD     (SelectedSector),A   ;
1241: F865         ;-------------------------Convert selected record into physical sector-------;
1242: F865
1243: F865         ;------------------------- Any Data in Buffer -------------------------------;
1244: F865         ;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes ; ;                                                                            ;
1245: F865 21 67 F9               LD     HL,DataInBufferFlag  ; See if there is any data here ?    ;
1246: F868 7E                     LD     A,(HL)               ;
1247: F869 36 FF                  LD     (HL),TRUE            ; Force flag true                    ;
1248: F86B FE FF                  CP     TRUE                 ; Was  any data here ?               ;
1249: F86D 20 0F                  JR     NZ,PreRead           ; No, then we need to load data      ;
1250: F86F         ;------------------------- Any Data in Buffer -------------------------------;
1251: F86F
1252: F86F         ;--------------------------- Is This My Data --------------------------------;
1253: F86F CD D8 F8               CALL   IsItMyData           ;
1254: F872 28 22                  JR     Z,DoPart2            ;
1255: F874         ;--------------------------- Is This My Data --------------------------------;
1256: F874
1257: F874         ;--------------------------- Is The Data Dirty ------------------------------;
1258: F874 3A 68 F9               LD     A,(DirtyBufferFlag)  ;
1259: F877 FE FF                  CP     TRUE                 ;
1260: F879 20 03                  JR     NZ,PreRead           ;
1261: F87B         ;--------------------------- Is The Data Dirty ------------------------------;
1262: F87B
1263: F87B         ;-------------------------------- PreWrite ----------------------------------;
1264: F87B             PreWrite:                       ;
1265: F87B         ; Do the actual Write                                                        ;
1266: F87B CD E9 F8               CALL   PhysicalWrite        ;
1267: F87E         ;-------------------------------- PreWrite ----------------------------------;
1268: F87E
1269: F87E         ;--------------------------------- PreRead ----------------------------------;
1270: F87E         ;     prepare for physical IO                                                ;
1271: F87E             PreRead:                        ;
1272: F87E         ; Set IOBuffer to Selected state for physical read                           ;
1273: F87E 21 69 F9               LD     HL,SelectedState     ;
1274: F881 11 63 F9               LD     DE,IOBufferState     ;
1275: F884 01 04 00               LD     BC,SelectedStateSize ;
1276: F887 ED B0                  LDIR                        ;
1277: F889         ; Do the actual read                                                         ;
1278: F889 CD EE F8               CALL   PhysicalRead         ;
1279: F88C 3E FF                  LD     A,TRUE               ;
1280: F88E 32 67 F9               LD     (DataInBufferFlag),A ; Set DataInBuffeer Flag			 ;
1281: F891 3E 00                  LD     A,FALSE              ;
1282: F893 32 68 F9               LD     (DirtyBufferFlag),A  ; Reset DataIsDirty Flag			 ;
1283: F896         ;--------------------------------- PreRead ----------------------------------;
1284: F896
1285: F896         ;-------------------Calculate the address of the record in the sector -------;
1286: F896             DoPart2:                        ;
1287: F896             DataIsInBuffer:                      ;
1288: F896 3A 6D F9               LD     A,(SelectedRecord)   ;
1289: F899 E6 03                  AND    SectorMask           ; Want relative record               ;
1290: F89B 3C                     INC    A                    ; Adjust for DJNZ                    ;
1291: F89C 47                     LD     B,A                  ;
1292: F89D 11 80 00               LD     DE,cpmRecordSize     ;
1293: F8A0 21 80 FF               LD     HL,-cpmRecordSize    ;
1294: F8A3             SectorInBuffer1:                      ;
1295: F8A3 19                     ADD    HL,DE                ; RecordNumber * recordSize          ;
1296: F8A4 10 FD                  DJNZ   SectorInBuffer1      ;  yields index into the Sector      ;
1297: F8A6         ;
1298: F8A6 11 28 FC               LD     DE,DiskBuffer        ; Start of sector                    ;
1299: F8A9 19                     ADD    HL,DE                ; HL -> start of record in buffer	 ;
1300: F8AA ED 5B 6F F9               LD     DE,(DMAAddress)      ; Callers  DMA Address               ;
1301: F8AE         ;
1302: F8AE         ;-------------------Calculate the address of the record in the sector -------;
1303: F8AE
1304: F8AE         ;------------------------- Determine if its a Read or Write and set HL & DE  ;
1305: F8AE 3A 72 F9               LD     A,(DiskCommand)      ; 0 => Write, non Zero => Read       ;
1306: F8B1 FE FF                  CP     DISK_READ            ;
1307: F8B3 CA BC F8               JP     Z,BufferMove         ; Read : move data from Buffer to DMA;
1308: F8B6         ;write                              	; Write: move data from DMA to Buffer;
1309: F8B6 3E FF                  LD     A,TRUE               ; Set the flag to indicate           ;
1310: F8B8 32 68 F9               LD     (DirtyBufferFlag),A  ;   dirty buffer                     ;
1311: F8BB EB                     EX     DE,HL                ; Swap source and destn for Write    ;
1312: F8BC         ;------------------------- Determine if its a Read or Write and set HL & DE ;
1313: F8BC
1314: F8BC         ;----------------------  Move the Data between Buffer and DMA location   ----;
1315: F8BC             BufferMove:                      ;
1316: F8BC 01 80 00               LD     BC,cpmRecordSize     ;
1317: F8BF ED B0                  LDIR                        ;
1318: F8C1         ;----------------------  Move the Data between Buffer and DMA location   ----;
1319: F8C1
1320: F8C1
1321: F8C1 3A 73 F9               LD     A,(WriteType)        ; Is this a write to the directory ?
1322: F8C4 FE 01                  CP     WriteDirectory
1323: F8C6 3A 71 F9               LD     A,(DiskStatus)       ; Get disk status if an  return
1324: F8C9 C0                     RET    NZ                   ; Return if not a directory entry
1325: F8CA
1326: F8CA B7                     OR     A                    ; Check for any disk errors ?
1327: F8CB C0                     RET    NZ                   ; If yes - abandon
1328: F8CC
1329: F8CC 3E 00                  LD     A,FALSE
1330: F8CE 32 68 F9               LD     (DirtyBufferFlag),A  ; Clear the dirty buffer flag
1331: F8D1 CD E9 F8               CALL   PhysicalWrite        ; Immediate update of the directory
1332: F8D4 3A 71 F9               LD     A,(DiskStatus)       ; Set ACC with disk status
1333: F8D7 C9                     RET
1334: F8D8
1335: F8D8
1336: F8D8         ;--------------------------- Is It My Data ----------------------------------;
1337: F8D8             IsItMyData:                      ;
1338: F8D8         ;
1339: F8D8 21 69 F9               LD     HL,SelectedState     ;
1340: F8DB 11 63 F9               LD     DE,IOBufferState     ;
1341: F8DE 06 04                  LD     B,SelectedStateSize  ;
1342: F8E0             IsItMyData1:                      ;
1343: F8E0 1A                     LD     A,(DE)               ;
1344: F8E1 AE                     XOR    (HL)                 ; (HL) =(DE)                         ;
1345: F8E2 C0                     RET    NZ                   ; If not we are done                 ;
1346: F8E3 13                     INC    DE                   ;
1347: F8E4 23                     INC    HL                   ; Lets look at the next bytes        ;
1348: F8E5 10 F9                  DJNZ   IsItMyData1          ; Loop if not exhausted the count    ;
1349: F8E7 AF                     XOR    A                    ; Else set the Z flag                ;
1350: F8E8 C9                     RET                         ;  and exit                          ;
1351: F8E9         ;--------------------------- Is It My Data ----------------------------------;
1352: F8E9
1353: F8E9         ;***********************************************;
1354: F8E9         ;			      Physical Disk IO				  ;
1355: F8E9         ;***********************************************;
1356: F8E9
1357: F8E9         ;Write contents of disk buffer to correct sector
1358: F8E9             PhysicalWrite:
1359: F8E9 3E 02                  LD     A,DiskWriteCode      ; get write function
1360: F8EB C3 F0 F8               JP     CommonPhysical
1361: F8EE
1362: F8EE             PhysicalRead:
1363: F8EE 3E 01                  LD     A,DiskReadCode       ; get read function
1364: F8F0
1365: F8F0
1366: F8F0             CommonPhysical:
1367: F8F0         ;--------------------------- Setup Disk Control Table  ----------------------;
1368: F8F0         ;
1369: F8F0         ;Command                                                                     ;
1370: F8F0 32 56 F9               LD     (DCTCommand),A       ; set the command for Read or Write  ;
1371: F8F3         ;Disk                                                                        ;
1372: F8F3 3A 63 F9               LD     A,(IOBufferDisk)     ;
1373: F8F6 E6 03                  AND    03H                  ; only units 0 to 3                  ;
1374: F8F8 32 57 F9               LD     (DCTDisk),A          ; set disk                           ;
1375: F8FB         ;Track                                                                       ;
1376: F8FB 2A 64 F9               LD     HL,(IOBufferTrack)   ;
1377: F8FE 7D                     LD     A,L                  ;
1378: F8FF 32 59 F9               LD     (DCTTrack),A         ; set track	                         ;
1379: F902         ;
1380: F902         ;Head and Track	Calculations                                                 ;
1381: F902         ; The sector must be converted into a head number and sector number.         ;
1382: F902         ;	Head = (int) Sector / SectorsPerHead                                     ;
1383: F902         ;	Sector = Sector MOD SectorsPerHead                                       ;
1384: F902             DetermineHead:                      ;
1385: F902 06 00                  LD     B,0                  ; Start at head 0                    ;
1386: F904 21 6E F9               LD     HL,SelectedDskSecsPerHead ; Point at track counts              ;
1387: F907 3A 66 F9               LD     A,(IOBufferSector)   ; get target sector                  ;
1388: F90A             DetermineHead1:                      ;
1389: F90A BE                     CP     M                    ; Need another Head?                 ;
1390: F90B DA 13 F9               JP     C,HeadFound          ; nope done with head calculation    ;
1391: F90E         ;
1392: F90E 96                     SUB    M                    ; subtract track value               ;
1393: F90F 04                     INC    B                    ; Increment head                     ;
1394: F910 C3 0A F9               JP     DetermineHead1       ; loop for next head value           ;
1395: F913         ;Sector                                                                      ;
1396: F913             HeadFound:                      ; Sector MOD SectorsPerHead          ;
1397: F913 3C                     INC    A                    ; physical sectors start at 1        ;
1398: F914 32 5A F9               LD     (DCTSector),A        ; set sector                         ;
1399: F917         ;Head                                                                        ;
1400: F917 78                     LD     A,B                  ;
1401: F918 32 58 F9               LD     (DCTHead),A          ; set head number                    ;
1402: F91B         ;Byte Count                                                                  ;
1403: F91B 21 00 02               LD     HL,diskSectorSize    ;
1404: F91E 22 5B F9               LD     (DCTByteCount),HL    ; set byte count                     ;
1405: F921         ;DMA                                                                         ;
1406: F921 21 28 FC               LD     HL,DiskBuffer        ;
1407: F924 22 5D F9               LD     (DCTDMAAddress),HL   ; set transfer address               ;
1408: F927         ;
1409: F927         ; Since only one control table is in use, close the status and               ;
1410: F927         ; busy chain pointers ; back to the main control bytes.                      ;
1411: F927         ;
1412: F927         ;NextStatusBlock                                                             ;
1413: F927 21 43 00               LD     HL,DiskStatusLocation ;
1414: F92A 22 5F F9               LD     (DCTNextStatusBlock),HL ;
1415: F92D         ;NextControlLocation                                                         ;
1416: F92D 21 45 00               LD     HL,DiskControlByte   ;
1417: F930 22 61 F9               LD     (DCTNextControlLocation),HL ;
1418: F933         ;                                                                        ;
1419: F933         ;Put  DCT pointer in page0                                                   ;
1420: F933 21 56 F9               LD     HL,DCTCommand        ;
1421: F936 22 46 00               LD     (DiskCommandBlock),HL ;
1422: F939         ;--------------------------- Setup Disk Control Table  ----------------------;
1423: F939
1424: F939         ; Make the IO happen
1425: F939 21 45 00               LD     HL,DiskControlByte   ; Activate disk controller
1426: F93C 36 80                  LD     (HL),080H
1427: F93E
1428: F93E             WaitForDiskComplete:
1429: F93E 7E                     LD     A,(HL)               ; Get control bytes
1430: F93F B7                     OR     A
1431: F940 C2 3E F9               JP     NZ,WaitForDiskComplete ; Operation not done
1432: F943
1433: F943         ;Check if any errors occurred.
1434: F943 3A 43 00               LD     A,(DiskStatusLocation)
1435: F946 FE 80                  CP     080H                 ; Any errors NC = good read?
1436: F948 DA 50 F9               JP     C,DiskError
1437: F94B AF                     XOR    A
1438: F94C 32 71 F9               LD     (DiskStatus),A       ; Clear the flag
1439: F94F C9                     RET                         ; Clean read, return to caller
1440: F950
1441: F950         ; set error flag and return
1442: F950             DiskError:
1443: F950 3E 01                  LD     A,1
1444: F952 32 71 F9               LD     (DiskStatus),A       ; Set the error flag
1445: F955 C9                     RET
1446: F956
1447: F956
1448: F956
1449: F956
1450: F956
1451: F956         ;============================================================================;
1452: F956         ;                                                                            ;
1453: F956         ;  There is one  disk controller on this system,                             ;
1454: F956         ; for the 3.5 HD drive (1.44MB)                                              ;
1455: F956         ;                                                                            ;
1456: F956         ; The controller is "hard-wired" to monitor memory location 0X45 to detect   ;
1457: F956         ; when it is to perform some disk operation.  This is called its disk        ;
1458: F956         ; control byte. If the most significant bit of  disk control byte is set,    ;
1459: F956         ; the controller will look at the word following the respective control      ;
1460: F956         ; bytes. This word must contain the address of  valid disk control table     ;
1461: F956         ; that specifies the exact disk operation to be performed. Once the          ;
1462: F956         ; operation has been completed. the controller resets its disk control byte  ;
1463: F956         ; to OOH.  This indicates completion to the disk driver code.                ;
1464: F956         ;                                                                            ;
1465: F956         ;  The controller also sets a return code in a disk status block,            ;
1466: F956         ; location 0X43H. If the first byte of this status block is less than 80H.   ;
1467: F956         ; then a disk error has occurred.                                            ;
1468: F956         ;
1469: F956         ;  The disk control table layout is shown below. Note that the controller    ;
1470: F956         ; has the capability  for control tables to be chained together so that a    ;
1471: F956         ; sequence of disk operations can be initiated. In this BIOS this feature    ;
1472: F956         ; is not used. However. the controller requires that the chain pointers      ;
1473: F956         ; in the disk control tables be pointed back to the main control bytes in    ;
1474: F956         ; order to indicate  the end of the chain                                    ;
1475: F956         ;============================================================================;
1476: F956
1477: F956         ;**************************** Disk ControlTable *****************************;
1478: F956             DCTStart:                       ;
1479: F956 00          DCTCommand: DB     00H                  ; Command	                         ;
1480: F957 00          DCTDisk:   DB     00H                  ; unit (drive) number = 0 or 1   	 ;
1481: F958 00          DCTHead:   DB     00H                  ; head number = 0 or 1           	 ;
1482: F959 00          DCTTrack:  DB     00H                  ; track number                   	 ;
1483: F95A 00          DCTSector: DB     00H                  ; sector number                  	 ;
1484: F95B 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write  	 ;
1485: F95D 00 00       DCTDMAAddress: DW     0000H                ; transfer address               	 ;
1486: F95F 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block   	 ;
1487: F961 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte   	 ;
1488: F963             DCTEnd:                         ;
1489: F963             DCTSize    EQU    DCTEnd-DCTStart      ;
1490: F963         ;**************************** Disk ControlTable *****************************;
1491: F963
1492: F963         ;**************************** Physical IO State *****************************;
1493: F963             IOBufferState:                      ;
1494: F963 00          IOBufferDisk: DB     00H                  ;
1495: F964 00 00       IOBufferTrack: DW     0000H                ;
1496: F966 10          IOBufferSector: DB     010H                 ;
1497: F967         ;**************************** Physical IO State *****************************;
1498: F967
1499: F967         ;**************************** Buffer State **********************************;
1500: F967 00          DataInBufferFlag: DB     00H                  ;
1501: F968 00          DirtyBufferFlag: DB     00H                  ;
1502: F969         ;**************************** Buffer State **********************************;
1503: F969
1504: F969         ;**************************** Selected Record State *************************;
1505: F969         ;     variables for selected disk, track and sector                          ;
1506: F969         ;These are moved and compared as a group with Physical IO State. DO NOT ALTER;
1507: F969         ;
1508: F969             SelectedState:                      ;
1509: F969 00          SelectedDisk: DB     00H                  ;
1510: F96A 00 00       SelectedTrack: DW     0000H                ;
1511: F96C 00          SelectedSector: DB     00H                  ; (SelectedRecord/RecordsPerSector)  ;
1512: F96D             SelectedStateEnd:                      ;
1513: F96D             SelectedStateSize EQU    SelectedStateEnd - SelectedState ;
1514: F96D         ;
1515: F96D 00          SelectedRecord: DB     00H                  ;
1516: F96E         ;
1517: F96E 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head	                 ;
1518: F96F         ;**************************** Selected Record State *************************;
1519: F96F
1520: F96F 00 00       DMAAddress: DW     0000H                ; Callers DMA address
1521: F971 00          DiskStatus: DB     00H                  ; Non-Zero - unrecoverable error
1522: F972 00          DiskCommand: DB     00H                  ; holds the disk command
1523: F973 00          WriteType: DB     00H                  ; The type of write set by BDOS
1524: F974
1525: F974         ;=============================================================================
1526: F974
1527: F974
1528: F974         ;*************************** Disk Definition Tables *************************;
1529: F974         ; These consists of disk parameter headers, with one entry per logical disk  ;
1530: F974         ; drive, and disk parameter blocks, with either one parameter block per      ;
1531: F974         ; logical disk or the same parameter block for several logical disks.        ;
1532: F974             DiskParameterHeaders:                      ;
1533: F974         ;
1534: F974         ; Logical Disk A: (3.25" HD 1.44MB Diskette)                                 ;
1535: F974 00 00                  DW     0000H                ; No Skew table                  	 ;
1536: F976 00 00                  DW     0000H                ; Rel pos for file (0-3)         	 ;
1537: F978 00 00                  DW     0000H                ; Last Selected Track #          	 ;
1538: F97A 00 00                  DW     0000H                ; Last Selected Sector #         	 ;
1539: F97C A8 FB                  DW     DirectoryBuffer      ; all disks use this buffer      	 ;
1540: F97E B4 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters  	 ;
1541: F980 C4 F9                  DW     DiskAWorkArea        ;
1542: F982 44 FA                  DW     DiskAAllocationVector ;
1543: F984         ;
1544: F984         ; Logical Disk B: (3.25" HD 1.44MB Diskette)                                 ;
1545: F984 00 00                  DW     0000H                ; No Skew table                   	 ;
1546: F986 00 00                  DW     0000H                ; Rel pos for file (0-3)          	 ;
1547: F988 00 00                  DW     0000H                ; Last Selected Track #           	 ;
1548: F98A 00 00                  DW     0000H                ; Last Selected Sector #          	 ;
1549: F98C A8 FB                  DW     DirectoryBuffer      ; all disks use this buffer       	 ;
1550: F98E B4 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters   	 ;
1551: F990 E4 F9                  DW     DiskBWorkArea        ;
1552: F992 9D FA                  DW     DiskBAllocationVector ;
1553: F994         ;
1554: F994         ; Logical Disk C: (3.25" HD 1.44MB Diskette)                                 ;
1555: F994 00 00                  DW     0000H                ; No Skew table                  	 ;
1556: F996 00 00                  DW     0000H                ; Rel pos for file (0-3)         	 ;
1557: F998 00 00                  DW     0000H                ; Last Selected Track #          	 ;
1558: F99A 00 00                  DW     0000H                ; Last Selected Sector #         	 ;
1559: F99C A8 FB                  DW     DirectoryBuffer      ; all disks use this buffer      	 ;
1560: F99E B4 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters  	 ;
1561: F9A0 04 FA                  DW     DiskCWorkArea        ;
1562: F9A2 F6 FA                  DW     DiskCAllocationVector ;
1563: F9A4         ;
1564: F9A4         ; Logical Disk D: (3.25" HD 1.44MB Diskette)                                 ;
1565: F9A4 00 00                  DW     0000H                ; No Skew table                  	 ;
1566: F9A6 00 00                  DW     0000H                ; Rel pos for file (0-3)         	 ;
1567: F9A8 00 00                  DW     0000H                ; Last Selected Track #          	 ;
1568: F9AA 00 00                  DW     0000H                ; Last Selected Sector #         	 ;
1569: F9AC A8 FB                  DW     DirectoryBuffer      ; all disks use this buffer      	 ;
1570: F9AE B4 F9                  DW     ParameterBlock3HD    ; specific to disk's parameters  	 ;
1571: F9B0 24 FA                  DW     DiskDWorkArea        ;
1572: F9B2 4F FB                  DW     DiskDAllocationVector ;
1573: F9B4         ;*************************** Disk Definition Tables *************************;
1574: F9B4
1575: F9B4
1576: F9B4         ;-----------------------------------------------------------
1577: F9B4         ;******** Parameter Block for 3.5 Inch High Density 1.44 MB Diskettes *******;
1578: F9B4         ;
1579: F9B4             ParameterBlock3HD:                      ;
1580: F9B4 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)        ;
1581: F9B6 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)              ;
1582: F9B7 0F                     DB     dpb3hdBLM            ; Block mask                         ;
1583: F9B8 00                     DB     dpb3hdEXM            ; Extent mask                        ;
1584: F9B9 C6 02                  DW     dpb3hdDSM            ; Max allocation block number (710)  ;
1585: F9BB 7F 00                  DW     dpb3hdDRM            ; Max directory entries - 1 (127)    ;
1586: F9BD C0                     DB     dpb3hdAL0            ; Bit map for reserving allocation   ;
1587: F9BE 00                     DB     dpb3hdAL1            ;   blocks for file directory        ;
1588: F9BF 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)    ;
1589: F9C1 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory  ;
1590: F9C3         ;
1591: F9C3 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head             ;
1592: F9C4         ;******** Parameter Block for 3.5 Inch High Density 1.44 MB Diskettes *******;
1593: F9C4
1594: F9C4         ;**************************** Disk Work Area ********************************;
1595: F9C4         ; This is used by the BDOS to detect any unexpected  change of diskette.     ;
1596: F9C4         ; The BDOS will  set such a changed diskette to read-only status.            ;
1597: F9C4         ;
1598: F9C4             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H	                         ;
1599: F9E4             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H	                         ;
1600: FA04             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H	                         ;
1601: FA24             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H	                         ;
1602: FA44         ;**************************** Disk Work Area ********************************;
1603: FA44
1604: FA44         ;************************ Disk Allocation Vectors ***************************;
1605: FA44         ; These are used by the BDOS to maintain a bit map of which allocation blocks;
1606: FA44         ; are used and which are free. One byte is used for eight allocation blocks, ;
1607: FA44         ; hence the  expression of the form  (allocation blocks/8)+1				 ;
1608: FA44         ;
1609: FA44             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:                  			 ;
1610: FA9D             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:                  			 ;
1611: FAF6         ;
1612: FAF6             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:                  			 ;
1613: FB4F             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:                  			 ;
1614: FBA8         ;************************ Disk Allocation Vectors ***************************;
1615: FBA8
1616: FBA8         ;********************************* Buffers **********************************;
1617: FBA8             DirectoryBuffer: DS     DirBuffSize          ;
1618: FC28         ;
1619: FC28         ;
1620: FC28             DiskBuffer:                      ;
1621: FC28                        DS     diskSectorSize       ;
1622: FE28         ;********************************* Buffers **********************************;
1623: FE28
1624: FE28             Z_HighestLocation:
1625: FE28             Z_MemoryLeft EQU    0FFFFH - Z_HighestLocation
1626: FE28
           ************************   Xref   ************************
0000: $               FE28
0742: AddressDataIn   F76D   0740
0757: AddressDataOut  F77D   0754
0767: AddressStatus   F786   0765
0080: ASCII_A         0041
0081: ASCII_C         0043
0082: ASCII_M         004D
0044: ASCII_MASK      007F   0748
0083: ASCII_O         004F
0084: ASCII_Y         0059
0067: ASCII_ZERO      0030
0065: ASTERISK        002A
0140: BDOSBase        E800   0141 0143
0109: BDOSE           0005   0110 0407 0409
0141: BDOSEntry       E800   0408
0130: BDOSLength      0E00   0133 0143 0144 0470
0143: BIOSBase        F600
0131: BIOSLength      0A00   0133
0103: BIOSPAGE        0002
0144: BIOSStart       F600   0297
0240: BlockSize       0800   0262
0347: BOOT            F633   0301
0277: BOOT_CON_ADDRESS 00EC   0447
1315: BufferMove      F8BC   1307
0040: BYTE            0001
0085: CARET           005E
0138: CCPEntry        E000   0140 0144 0389 0417 0472
0129: CCPLength       0800   0133 0140 0144 0470
0299: CodeStart       F600
0068: COLON           003A
0810: COM_DataPort    00EC   0854
0812: COM_InputMask   0002   0856
0811: COM_OutputMask  0001   0855
0809: COM_StatusPort  00ED   0853
0852: COM_Table       F7B5   0884 0894
1232: CommonDiskIO    F857   1161
1366: CommonPhysical  F8F0   1360
0115: ComTail         0080   0116
0117: ComTailChars    0081
0116: ComTailCount    0080   0117
0881: CON_Vector      F7D3   0516 0572
0545: ConIn           F6F4   0547
0544: CONIN           F6F4   0305
0569: CONOUT          F700   0306
0570: CONOut          F700
0513: CONST           F6E2   0304
0514: ConStatus       F6E2   0546
0217: cpmRecordSize   0080   0219 0222 0224 1292 1293 1316
0060: CR              000D   0452 0454 0457 0460
0805: CRT_DataPort    0001   0846
0807: CRT_InputMask   007F   0848
0806: CRT_OutputMask  0080   0847
0804: CRT_StatusPort  0002   0845
0844: CRT_Table       F7AB   0883 0888 0895 0898
0047: CTRL_C          0003
0048: CTRL_E          0005
0049: CTRL_H          0008
0050: CTRL_L          000C
0051: CTRL_P          0010
0052: CTRL_R          0012
0053: CTRL_S          0013
0054: CTRL_U          0015
0055: CTRL_X          0018
0056: CTRL_Z          001A
0251: DataBlocks      02C7   0261
1500: DataInBufferFlag F967   0959 1245 1280
1287: DataIsInBuffer  F896
0826: DataPortIndex   0001   0739 0753
0738: DataRead        F766   0747 0850 0858 0866
0746: DataReadASCII   F76F   0841
0830: DataReadIndex   0006   0549 0550 0674 0675
0250: DataSectors     0B1C   0251
0752: DataWrite       F775   0842 0851 0859 0867
0831: DataWriteIndex  0008   0580 0581
1484: DCTByteCount    F95B   1404
1479: DCTCommand      F956   1370 1420
1480: DCTDisk         F957   1374
1485: DCTDMAAddress   F95D   1407
1488: DCTEnd          F963   1489
1481: DCTHead         F958   1401
1487: DCTNextControlLocation F961   1417
1486: DCTNextStatusBlock F95F   1414
1483: DCTSector       F95A   1398
1489: DCTSize         000D
1478: DCTStart        F956   1489
1482: DCTTrack        F959   1378
1384: DetermineHead   F902
1388: DetermineHead1  F90A   1394
0222: DirBuffSize     0080   1617
0237: DirectoryBlockCount 0002   0262
1617: DirectoryBuffer FBA8   1539 1549 1559 1569
0224: DirectoryEntryPerRecord 0004   0265
0221: DirEntrySize    0020   0224 0262
1501: DirtyBufferFlag F968   0955 1258 1282 1310 1330
0282: DISK_READ       00FF   1157 1306
0283: DISK_WRITE      0000   1226
1609: DiskAAllocationVector FA44   1542
1598: DiskAWorkArea   F9C4   1541
1610: DiskBAllocationVector FA9D   1552
1620: DiskBuffer      FC28   1298 1406
1599: DiskBWorkArea   F9E4   1551
1612: DiskCAllocationVector FAF6   1562
1522: DiskCommand     F972   1158 1227 1305
0209: DiskCommandBlock 0046   0426 1421
0208: DiskControlByte 0045   0428 0474 1416 1425
0211: DiskControlTable 0040   0486
1600: DiskCWorkArea   FA04   1561
1613: DiskDAllocationVector FB4F   1572
1601: DiskDWorkArea   FA24   1571
1442: DiskError       F950   1436
1532: DiskParameterHeaders F974   1004
0213: DiskReadCode    0001   0464 0478 1363
0218: diskSectorSize  0200   0219 0240 0248 0483 1403 1621
1521: DiskStatus      F971   1234 1323 1332 1438 1444
0207: DiskStatusLocation 0043   0436 0473 0485 1413 1434
0214: DiskWriteCode   0002   1359
0443: DisplayMessage  F68B   0354 0395 0449
1520: DMAAddress      F96F   1088 1300
0120: DMABuffer       0080   0411
0063: DOLLAR          0024
1286: DoPart2         F896   1254
0263: dpb3hdAL0       00C0   1586
0264: dpb3hdAL1       0000   1587
0259: dpb3hdBLM       000F   1582
0258: dpb3hdBSH       0004   1581
0265: dpb3hdCKS       0020   1588 1598 1599 1600 1601
0262: dpb3hdDRM       007F   0265 1585
0261: dpb3hdDSM       02C6   1584 1609 1610 1612 1613
0260: dpb3hdEXM       0000   1583
0267: dpb3hdNOH       0002   1591
0266: dpb3hdOFF       0001   1589
0257: dpb3hdSPT       0090   1580 1591
0820: DUMMY_DataPort  0010   0870
0822: DUMMY_InputMask 007F   0872
0821: DUMMY_OutputMask 00FF   0871
0819: DUMMY_StatusPort 0011   0869
0868: DUMMY_Table     F7C9   0885 0889 0890 0893 0900
0776: DUMMYCheck      F78B   0873
0772: DUMMYRead       F789   0874
0774: DUMMYWrite      F78A   0875
0124: END_OF_FILE     001A
0045: EndOfMessage    0000   0454 0460
0072: EQUAL_SIGN      003D
0037: FALSE           0000   0958 1281 1329
0112: FCB1            005C   0113
0113: FCB2            006C
0518: GenericInStatus F6E9   0671
0574: GenericOutStatus F707   0606 0641
0577: GenericOutStatus1 F70A   0579
0728: GetInStatus     F75C   0520
0724: GetOutStatus    F757   0578 0715
0730: GetStatus       F75F   0727
0073: GREATER_THAN    003E
0062: HASH_TAG        0023
1396: HeadFound       F913   1390
0954: HOME            F7F3   0310
0960: Home1           F7FF   0957
0279: IN_OPCODE       00DB   0741 0766
0828: InputMaskIndex  0003   0729
1494: IOBufferDisk    F963   1372
1496: IOBufferSector  F966   1387
1493: IOBufferState   F963   1274 1340
1495: IOBufferTrack   F964   1376
0104: IOBYTE          0003   0515 0571 0602 0635 0666 0710
1337: IsItMyData      F8D8   1253
1342: IsItMyData1     F8E0   1348
0281: JP_OPCODE       00C3   0401
0076: LEFT_ARROW      005F
0133: LengthInBytes   2000   0134 0138 0248
0134: LengthInK       0009
0071: LESS_THAN       003C
0059: LF              000A   0452 0454 0457 0460
0601: LIST            F716   0307
0709: LISTST          F743   0317
0038: LO_NIBBLE_MASK  000F
0400: LoadPage0       F657   0392
0815: LPT_DataPort    0010   0862
0817: LPT_InputMask   007F   0864
0816: LPT_OutputMask  00FF   0863
0814: LPT_StatusPort  0011   0861
0860: LPT_Table       F7BF   0897 0899
0896: LST_Vector      F7EB   0605 0713
0136: MemorySize      0040   0138
0249: myOffset        0001   0250 0266
0451: NoDiskMessage   F693   0353
0233: NumberOfHeads   0002   0244 0246 0257 0267
0230: NumberOfLogicalDisks 0004   0993
0280: OUT_OPCODE      00D3   0756
0827: OutputMaskIndex 0002   0726
1579: ParameterBlock3HD F9B4   1540 1550 1560 1570
0064: PERCENT         0025
0066: PERIOD          002E
0107: Pg0CurentDisk   0004   0415
0106: Pg0CurentUser   0004   0107
1362: PhysicalRead    F8EE   1278
1358: PhysicalWrite   F8E9   1266 1331
1271: PreRead         F87E   1249 1260
1264: PreWrite        F87B
0891: PUN_Vector      F7E3   0640
0634: PUNCH           F721   0308
0074: QMARK           003F
0100: RAM             0000   0102 0103 0104 0106 0109 0112 0115 0120 0122
0886: RDR_Vector      F7DB   0669
1156: READ            F841   0315
0665: READER          F72E   0309
0670: READER1         F737   0672
0425: ReadRawDisk     F679   0350 0391
0242: RecordsPerBlock 0010
0226: RecordsPerExtent 0080
0219: recordsPerSector 0004   0242 0257
0477: ROMControl      F6D5   0349
0077: RUBOUT          007F
1294: SectorInBuffer1 F8A3   1296
0271: SectorMask      0003   1289
0236: SectorsPerBlock 0004   0240 0242 0245 0251 0271
0246: SectorsPerCylinder 0024   0249 0250
0235: SectorsPerTrack 0012   0244 0246 0257
1111: SECTRAN         F83E   0318
0990: SELDSK          F805   0311
1509: SelectedDisk    F969   0996
1517: SelectedDskSecsPerHead F96E   1014 1386
1515: SelectedRecord  F96D   1069 1236 1288
1511: SelectedSector  F96C   1240
1508: SelectedState   F969   1273 1339 1513
1512: SelectedStateEnd F96D   1513
1513: SelectedStateSize 0004   1275 1341
1510: SelectedTrack   F96A   1042
0070: SEMICOLON       003B
0782: SetDeviceVector F78F   0519 0575 0714
1087: SETDMA          F839   0314 0412
1067: SETSEC          F834   0313
1038: SETTRK          F82F   0312 0962
0061: SPACE           0020
0825: StatusPortIndex 0000   0764
0763: StatusRead      F77F   0840 0849 0857 0865
0829: StatusReadIndex 0004   0731 0732
0248: SystemSectors   0011   0249
0058: TAB             0009
0110: TopRAM          0007
0245: TotalNumberOfBlocks 02D0
0244: TotalNumberOfSectors 0B40   0245 0250
0122: TPA             0100   0351 0484
0234: TracksPerHead   0050   0244
0036: TRUE            FFFF   0956 1247 1248 1259 1279 1309
0800: TTY_DataPort    00EC   0837
0802: TTY_InputMask   007F   0839
0801: TTY_OutputMask  0080   0838
0799: TTY_StatusPort  00ED   0836
0835: TTY_Table       F7A1   0882 0887 0892
0075: UNDER_SCORE     005F
0431: WaitForBootComplete F681   0434
1428: WaitForDiskComplete F93E   1431
0102: WarmBoot        0000   0403 0405
0302: WarmBootEntry   F603   0404
0456: WarmBootErroMessage F6AE   0394
0388: WBOOT           F643   0303 0396
0463: WBOOTControl    F6C8   0390
0041: WORD            0002
1223: WRITE           F84E   0316
0292: WriteAllocated  0000
0294: WriteCleanBuffer 0002   1159
0293: WriteDirectory  0001   1322
1523: WriteType       F973   1160 1225 1321
1624: Z_HighestLocation FE28   1625
1625: Z_MemoryLeft    01D7
