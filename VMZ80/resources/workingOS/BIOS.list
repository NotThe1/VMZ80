0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018 12-27 Adjusted BOOT & WBOOT
0006: F600         ; 2018-12-10 Refactored  character device routines;
0007: F600         ; 2017-03-31 Added List out functionality for List Device
0008: F600         ; 2017-03-02 Refactored the CP/M Suite
0009: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0010: F600         ; 2014-01-16
0011: F600         ; 2014-03-14  :  Frank Martyn
0012: F600
0013: F600         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0014: F600         ; by Andy Johnson-Laird
0015: F600         ;
0016: F600         ; Published by
0017: F600         ; Osborne/McGraw-Hill
0018: F600         ; 2600 Tenth Street
0019: F600         ; Berkeley, California 94710
0020: F600         ; U.S.A.
0021: F600
0022: F600                        Include ./stdHeader.Z80
0023: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0024: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0025: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0026: F600         ; stdHeader.asm
0027: F600         ; standard equates
0028: F600
0029: F600         ; 2017-03-02 Refactored the CP/M Suite
0030: F600
0031: F600
0032: F600             TRUE       EQU    -1                   ; not false
0033: F600             FALSE      EQU    0000H
0034: F600             ON         EQU    -1
0035: F600             OFF        EQU    0000H
0036: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0037: F600
0038: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0039: F600             WORD       EQU    2                    ; number of bytes for "word" type
0040: F600
0041: F600
0042: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0043: F600             ZERO       EQU    00H                  ; Zero
0044: F600             EndOfMessage EQU    00H
0045: F600
0046: F600             CTRL_C     EQU    03H                  ; ETX
0047: F600             CTRL_E     EQU    05H                  ; physical eol
0048: F600             CTRL_H     EQU    08H                  ; backspace
0049: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0050: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0051: F600             CTRL_P     EQU    10H                  ; prnt toggle
0052: F600             CTRL_R     EQU    12H                  ; repeat line
0053: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0054: F600             CTRL_U     EQU    15H                  ; line delete
0055: F600             CTRL_X     EQU    18H                  ; =ctl-u
0056: F600             CTRL_Z     EQU    1AH                  ; end of file
0057: F600
0058: F600             NULL       EQU    00H                  ; Null
0059: F600             SOH        EQU    01H                  ; Start of Heading
0060: F600             BELL       EQU    07H                  ; Bell
0061: F600             TAB        EQU    09H                  ; Tab
0062: F600             LF         EQU    0AH                  ; Line Feed
0063: F600             CR         EQU    0DH                  ; Carriage Return
0064: F600             SPACE      EQU    20H                  ; Space
0065: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0066: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0067: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0068: F600             PERCENT    EQU    25H                  ; Percent Sign
0069: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0070: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0071: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0072: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0073: F600             COMMA      EQU    2CH                  ; Comma
0074: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0075: F600             PERIOD     EQU    2EH                  ; Period
0076: F600             SLASH      EQU    2FH                  ; /
0077: F600             ASCII_ZERO EQU    30H                  ; zero
0078: F600             COLON      EQU    3AH                  ; Colon
0079: F600
0080: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0081: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0082: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0083: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0084: F600             QMARK      EQU    3FH                  ; Question Mark
0085: F600             UNDER_SCORE EQU    5FH                  ; under score _
0086: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0087: F600             RUBOUT     EQU    7FH                  ; Delete Key
0088: F600
0089: F600
0090: F600             ASCII_A    EQU    'A'
0091: F600             ASCII_C    EQU    'C'
0092: F600             ASCII_K    EQU    'K'
0093: F600             ASCII_N    EQU    'N'
0094: F600             ASCII_Q    EQU    'Q'
0095: F600             ASCII_R    EQU    'R'
0096: F600             ASCII_W    EQU    'W'
0097: F600             ASCII_Y    EQU    'Y'
0098: F600             CARET      EQU    '^'
0099: F600             ASCII_LO_A EQU    'a'
0100: F600             ASCII_LO_K EQU    'k'
0101: F600             ASCII_LO_P EQU    'p'
0102: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0103: F600
0104: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0105: F600                        Include ./osHeader.Z80
0106: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0107: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0108: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0109: F600         ; osHeader.asm
0110: F600
0111: F600         ; 2017-03-02 Refactored the CP/M Suite
0112: F600
0113: F600         ; Contains the Equates used by the CP/M system
0114: F600
0115: F600         ;------------------------Page Zero Constants ---------------------------------
0116: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0117: F600
0118: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0119: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0120: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0121: F600
0122: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0123: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0124: F600
0125: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0126: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0127: F600
0128: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0129: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0130: F600
0131: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0132: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0133: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0134: F600         ;-----------------------------------------------------------------------
0135: F600
0136: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0137: F600         ;-----------------------------------------------------------------------
0138: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0139: F600         ;-----------------------------------------------------------------------
0140: F600             END_OF_FILE EQU    1AH                  ; end of file
0141: F600         ;-----------------------------------------------------------------------
0142: F600
0143: F600         ;--------------- CP/M Constants -----------------------------------------
0144: F600
0145: F600             CCPLength  EQU    0800H                ; Constant
0146: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0147: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0148: F600
0149: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0150: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0151: F600
0152: F600             MemorySize EQU    64
0153: F600
0154: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0155: F600
0156: F600             BDOSBase   EQU    CCPEntry + CCPLength
0157: F600             BDOSEntry  EQU    BDOSBase + 6
0158: F600
0159: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0160: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0161: F600         ;-----------------------------------------------------------------------
0162: F600
0163: F600         ;------------------- BDOS System Call Equates --------------------------
0164: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0165: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0166: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0167: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0168: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0169: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0170: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0171: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0172: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0173: F600             fCloseFile EQU    10H                  ; closef - Close File
0174: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0175: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0176: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0177: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0178: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0179: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0180: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0181: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0182: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0183: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0184: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0185: F600         ;-----------------------------------------------------------------------
0186: F600
0187: F600
0188: F600
0189: F600
0190: F600
0191: F600         ;*******************************************************************************
0192: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0193: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0194: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0195: F600         ; sector write) or to an allocation block that has already been allocated to a
0196: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0197: F600         ;*******************************************************************************
0198: F600             WriteAllocated EQU    00H
0199: F600             WriteDirectory EQU    01H
0200: F600             WriteCleanBuffer EQU    02H
0201: F600
0202: F600
0203: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0204: F600                        Include ./diskHeader.Z80
0205: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0206: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0207: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0208: F600         ; diskHeader.asm
0209: F600
0210: F600         ; 2017-03-02 Refactored the CP/M Suite
0211: F600
0212: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0213: F600
0214: F600         ; Contains the Equates used by the CP/M system to handle disks
0215: F600
0216: F600
0217: F600         ;*******************************************************************************
0218: F600         ;
0219: F600         ;     Disk related values
0220: F600         ;
0221: F600         ;
0222: F600         ;*******************************************************************************
0223: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0224: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0225: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0226: F600         ; for boot
0227: F600             DiskControlTable EQU    0040H
0228: F600
0229: F600             DiskReadCode EQU    01H                  ; Code for Read
0230: F600             DiskWriteCode EQU    02H                  ; Code for Write
0231: F600
0232: F600
0233: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0234: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0235: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0236: F600
0237: F600             DirEntrySize EQU    20H                  ; (32)
0238: F600             DirBuffSize EQU    cpmRecordSize
0239: F600
0240: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0241: F600
0242: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0243: F600
0244: F600
0245: F600         ;-------------------------------------------------------------------------------------
0246: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0247: F600
0248: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0249: F600             NumberOfHeads EQU    02H                  ; number of heads
0250: F600             TracksPerHead EQU    50H                  ; 80
0251: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0252: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0253: F600             DirectoryBlockCount EQU    02H                  ;
0254: F600         ;-----------------------------------------------------------------------
0255: F600
0256: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0257: F600
0258: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0259: F600
0260: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0261: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0262: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0263: F600
0264: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0265: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0266: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0267: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0268: F600
0269: F600         ;-----------------------------------------------------------------------
0270: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0271: F600         ;-----------------------------------------------------------------------
0272: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0273: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0274: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0275: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0276: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0277: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0278: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0279: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0280: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0281: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0282: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0283: F600             dpb3hdNOH  EQU    NumberOfHeads
0284: F600
0285: F600         ;*******************************************************************************
0286: F600
0287: F600             SectorMask EQU    SectorsPerBlock - 1
0288: F600
0289: F600         ;***************************************************************************
0290: F600
0291: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0292: F600
0293: F600             BOOT_CON_ADDRESS EQU    0ECH                 ; tty data address
0294: F600
0295: F600             IN_OPCODE  EQU    0DBH
0296: F600             OUT_OPCODE EQU    0D3H
0297: F600             JP_OPCODE  EQU    0C3H
0298: F600
0299: F600
0300: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0301: F600         ; BIOS jump Vector
0302: F600             CodeStart:
0303: F600
0304: F600 C3 40 F8               JP     BOOT                 ; 00 Cold/Hard Boot
0305: F603             WarmBootEntry:
0306: F603 C3 62 F8               JP     WBOOT                ; 01 Warm/Soft Boot
0307: F606 C3 EF F8               JP     CONST                ; 02 Get Console Status - CON:
0308: F609 C3 01 F9               JP     CONIN                ; 03 Get Character from Console - CON:
0309: F60C C3 0D F9               JP     CONOUT               ; 04 Send Character to Console - CON:
0310: F60F C3 23 F9               JP     LIST                 ; 05 Send Character to List device - LST:
0311: F612 C3 2E F9               JP     PUNCH                ; 06 Send Character to Punch device - PUN:
0312: F615 C3 3B F9               JP     READER               ; 07 Get Character from Reader - RDR:
0313: F618 C3 00 FA               JP     HOME                 ; 08 Position the disk to absolute track 00
0314: F61B C3 0F FA               JP     SELDSK               ; 09 Establish disk to be used by subsequent Read/Write
0315: F61E C3 39 FA               JP     SETTRK               ; 0A Establish track to be used by subsequent Read/Write
0316: F621 C3 3E FA               JP     SETSEC               ; 0B Establish sector to be used by subsequent Read/Write
0317: F624 C3 43 FA               JP     SETDMA               ; 0C Establish buffer location to be used by subsequent Read/Write
0318: F627 C3 4B FA               JP     READ                 ; 0D Not Yet Checked
0319: F62A C3 5E FA               JP     WRITE                ; 0E Not Yet Checked
0320: F62D C3 50 F9               JP     LISTST               ; 0F Get List device Status - LST:
0321: F630 C3 48 FA               JP     SECTRAN              ; 10 De-skew sector number (null implementation)
0322: F633
0323: F633         ;-------------------------------------------------
0324: F633                        ORG    (($+10H)/10H) * 10H
0325: F640
0326: F640             DiskBuffer:
0327: F640                        DS     diskSectorSize
0328: F840             AfterDiskBuffer EQU    $
0329: F840         ;-------------------------------------------------
0330: F840
0331: F840
0332: F840
0333: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0334: F840
0335: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0336: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0337: F840         ;---------------------------------------------------------------------------
0338: F840         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot
0339: F840
0340: F840         ;  The BOOT jump instruction is the first instruction executed in CP/M. The
0341: F840         ; bootstrap sequence must transfer control to the BOOT entry point in order to
0342: F840         ; bring up CP/M.
0343: F840         ;  This reads in the CP/M loader on the first sector of the physical disk drive
0344: F840         ; chosen to be logical disk A. This CP/M loader program reads the binary image
0345: F840         ; of the CCP, BOOS, and BIOS into memory at some predetermined address.
0346: F840         ; Then it transfers control to the BOOT entry point in the BIOS jump vector.
0347: F840         ;  This BOOT routine must initialize all of the required computer hardware.
0348: F840         ;
0349: F840         ; Most BOOT routines sign on by displaying a short message on the console,
0350: F840         ; indicating the current version ofCP/M and the computer hardware that this BIOS
0351: F840         ; can support. The BOOT routine terminates by transferring control to the start of the CCP
0352: F840         ; +6 bytes (the CCP has its own smalljump vector at the beginning). Just before the
0353: F840         ; BOOT routine jumps into the CCP, it sets the C register to 0 to indicate that logical
0354: F840         ; disk A is to be the default disk drive. This is what causes "A>" to be the CCP's
0355: F840         ; initial prompt.
0356: F840
0357: F840             BOOT:
0358: F840         ;CodeStart:
0359: F840 21 E2 F8               LD     HL,ROMControl
0360: F843 CD 50 F8               CALL   ReadRawDisk          ; load the boot sector from the disk
0361: F846 D2 00 01               JP     NC,TPA               ; now execute the boot loader;
0362: F849
0363: F849 21 A0 F8               LD     HL,NoDiskMessage
0364: F84C CD 98 F8               CALL   DisplayMessage       ;
0365: F84F 76                     HALT
0366: F850
0367: F850             ReadRawDisk:                      ; Enter with DiskControlBlock pointer in HL
0368: F850 22 46 00               LD     (DiskCommandBlock),HL ; put it into the Command block for drive A:
0369: F853
0370: F853 21 45 00               LD     HL,DiskControlByte
0371: F856 36 80                  LD     (HL),080H            ; activate the controller
0372: F858
0373: F858             WaitForBootComplete:
0374: F858 7E                     LD     A,(HL)               ; Get the control byte
0375: F859 B7                     OR     A                    ; is it set to 0 (Completed operation) ?
0376: F85A 20 FC                  JR     NZ,WaitForBootComplete ; if not try again
0377: F85C
0378: F85C 3A 43 00               LD     A,(DiskStatusLocation) ; after operation what's the status?
0379: F85F FE 80                  CP     080H                 ; any errors ?
0380: F861 C9                     RET                         ; exit with result in the CCs
0381: F862
0382: F862
0383: F862         ;
0384: F862         ;
0385: F862         ;
0386: F862         ;DisplayMessage:
0387: F862         ; 	LD		A,(HL)
0388: F862         ; 	OR		A
0389: F862         ; 	RET	Z
0390: F862         ; 	OUT		(BOOT_CON_ADDRESS),A				; Console address
0391: F862         ; 	INC		HL
0392: F862         ; 	JR		DisplayMessage
0393: F862         ;
0394: F862         ;NoDiskMessage:
0395: F862         ; 	DB		CR,LF
0396: F862         ; 	DB		'No System Disk Mounted'
0397: F862         ; 	DB		CR,LF,EndOfMessage
0398: F862         ;
0399: F862         ;WarmBootErroMessage:
0400: F862         ;	DB		CR,LF
0401: F862         ;	DB		'Warm Boot -'
0402: F862         ;	DB		' Retrying.'
0403: F862         ;	DB		CR,LF,EndOfMessage
0404: F862         ;
0405: F862         ;
0406: F862         ;---------------------------------------------------------------------------
0407: F862         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot
0408: F862         ;
0409: F862         ;  Unlike the "cold" bootstrap entry point, which executes only once, the WBOOT
0410: F862         ; or warm boot routine will be executed every time a program terminates by
0411: F862         ; jumping to location OOOOH, or whenever you type a CONTROL-C on the console as
0412: F862         ; the first character of an input line.
0413: F862         ;  The WBOOT routine is responsible for reloading the CCP into memory.
0414: F862         ; Programs often use all of memory up to the starting point of the BDOS, overwriting
0415: F862         ; the CCP in the process. The underlying philosophy is that while a program is
0416: F862         ; executing, the CCP is not needed, so the program can use the memory previously
0417: F862         ; occupied by the CCP. The CCP occupies 800H (2048) bytes ofmemory-and this
0418: F862         ; is frequently just enough to make the difference between a program that cannot
0419: F862         ; run and one that can.
0420: F862         ; A few programs that are self-contained and do not require the BDOS's
0421: F862         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes of
0422: F862         ; memory. Therefore, to be really safe, the WBOOT routine should read in both the
0423: F862         ; CCP and the BDOS. It also needs to set up the two JMPs at location OOOOH (to
0424: F862         ; WBOOT itself) and at location 0005H (to the BOOS). Location 0003H should be
0425: F862         ; set to the initial value of the 10BYTE if this is implemented in the BIOS.
0426: F862         ; As its last act, the WBOOT routine sets register C to indicate which logical disk
0427: F862         ; is to be selected (C= 0 for A, I for B, and so on). It then transfers control into the
0428: F862         ; CCP at the first instruction in order to restart the CCP.
0429: F862
0430: F862             WBOOT:
0431: F862 31 FF DF               LD     SP,CCPEntry-1        ; put stack at top of User area
0432: F865 21 D5 F8               LD     HL,WBOOTControl      ; get the WBOOT Control Block
0433: F868 CD 50 F8               CALL   ReadRawDisk          ; read CCP & BDOS
0434: F86B 30 09                  JR     NC,LoadPage0         ; set up page 0 if good read
0435: F86D
0436: F86D 21 BB F8               LD     HL,WarmBootErroMessage
0437: F870 CD 98 F8               CALL   DisplayMessage       ; send bad warm boot message
0438: F873 C3 62 F8               JP     WBOOT                ; keep trying
0439: F876
0440: F876
0441: F876         ; Set up page Zero
0442: F876             LoadPage0:
0443: F876 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0444: F878
0445: F878 32 00 00               LD     (WarmBoot),A
0446: F87B 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0447: F87E 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0448: F881
0449: F881 32 05 00               LD     (BDOSE),A
0450: F884 21 06 E8               LD     HL,BDOSEntry         ; BDOS entry point
0451: F887 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0452: F88A
0453: F88A 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0454: F88D CD 43 FA               CALL   SETDMA               ; use normal BDOS  routine
0455: F890 FB                     EI                          ; Enable interrupts
0456: F891
0457: F891 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0458: F894 4F                     LD     C,A
0459: F895 C3 00 E0               JP     CCPEntry             ; transfer control to CCP
0460: F898
0461: F898
0462: F898
0463: F898
0464: F898         ;=============================================================================
0465: F898         ;---------------------------- Raw Message Code ------------------------------;
0466: F898             DisplayMessage:                      ;
0467: F898 7E                     LD     A,(HL)               ;
0468: F899 B7                     OR     A                    ;
0469: F89A C8                     RET    Z                    ;
0470: F89B D3 EC                  OUT    (BOOT_CON_ADDRESS),A ; Console address                ;
0471: F89D 23                     INC    HL                   ;
0472: F89E 18 F8                  JR     DisplayMessage       ;
0473: F8A0         ;
0474: F8A0             NoDiskMessage:                      ;
0475: F8A0 0D 0A                  DB     CR,LF                ;
0476: F8A2 4E 6F 20 53 79 73 74 65 6D 20 44 69 73 6B 20 4D 6F 75 6E 74 65 64                DB     'No System Disk Mounted' ;
0477: F8B8 0D 0A 00                DB     CR,LF,EndOfMessage   ;
0478: F8BB         ;
0479: F8BB             WarmBootErroMessage:                      ;
0480: F8BB 0D 0A                  DB     CR,LF                ;
0481: F8BD 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'        ;
0482: F8C8 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'         ;
0483: F8D2 0D 0A 00                DB     CR,LF,EndOfMessage   ;
0484: F8D5         ;---------------------------- Raw Message Code ------------------------------;
0485: F8D5         ;---------------------------- WBOOT Disk Control Block ----------------------;
0486: F8D5             WBOOTControl:                      ;
0487: F8D5 01                     DB     DiskReadCode         ; Read function                      ;
0488: F8D6 00                     DB     00H                  ; unit number                        ;
0489: F8D7 00                     DB     00H                  ; head number                        ;
0490: F8D8 00                     DB     00H                  ; track number                       ;
0491: F8D9 02                     DB     02H                  ; Starting sector number             ;
0492: F8DA         ;  (skip cold boot sector)           ;
0493: F8DA 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read            ;
0494: F8DC         ;  ( rest of the head)               ;
0495: F8DC 00 E0                  DW     CCPEntry             ; read into this address             ;
0496: F8DE 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking ;
0497: F8E0 45 00                  DW     DiskControlByte      ; pointer to next table- no linking  ;
0498: F8E2         ;---------------------------- WBOOT Disk Control Block ----------------------;
0499: F8E2         ;---------------------------- ROM Disk Control Block ------------------------;
0500: F8E2             ROMControl:                      ;
0501: F8E2 01                     DB     DiskReadCode         ; Read function                      ;
0502: F8E3 00                     DB     00H                  ; unit number                        ;
0503: F8E4 00                     DB     00H                  ; head number                        ;
0504: F8E5 00                     DB     00H                  ; track number                       ;
0505: F8E6 01                     DB     01H                  ; Starting sector number ()          ;
0506: F8E7 00 02                  DW     diskSectorSize       ; Number of bytes to read ( 1 Sector);
0507: F8E9 00 01                  DW     TPA                  ; read into this address             ;
0508: F8EB 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking ;
0509: F8ED 40 00                  DW     DiskControlTable     ; pointer to next table- no linking  ;
0510: F8EF         ;---------------------------- ROM Disk Control Block ------------------------;
0511: F8EF
0512: F8EF         ;=============================================================================
0513: F8EF
0514: F8EF
0515: F8EF         ;---------------------------------------------------------------------------
0516: F8EF         ;	Console Status:		BIOS 02
0517: F8EF         ;
0518: F8EF         ;  CONST simply returns an indicator showing whether there is an incoming
0519: F8EF         ; character from the console device. The convention is that A = OFFH if a character
0520: F8EF         ; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
0521: F8EF         ; to reflect the contents of the A register - it is the contents that are important.
0522: F8EF         ; CONST is called by the CCP whenever the CCP is in the middle of an
0523: F8EF         ; operation that can be interrupted by pressing a keyboard character.
0524: F8EF         ;
0525: F8EF         ; The BDOS will call CONST if a program makes a Read Console Status
0526: F8EF         ; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
0527: F8EF         ; routine, CONIN
0528: F8EF
0529: F8EF             CONST:
0530: F8EF             ConStatus:
0531: F8EF 3A 03 00               LD     A,(IOBYTE)
0532: F8F2 DD 21 E0 F9               LD     IX,CON_Vector
0533: F8F6
0534: F8F6             GenericInStatus:                      ; Entry point for generic input status
0535: F8F6 CD 9C F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0536: F8F9 CD 69 F9               CALL   GetInStatus
0537: F8FC B7                     OR     A
0538: F8FD C8                     RET    Z                    ; 00 => No data pending
0539: F8FE 3E FF                  LD     A,0FFH
0540: F900 C9                     RET                         ; OFFH => Data in Buffer;---------------------------------------------------------------------
0541: F901         ;	Console In:		BIOS 03
0542: F901         ;
0543: F901         ;  CONIN reads the next character from the console to the A register and sets the
0544: F901         ; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
0545: F901         ; until it detects A = OFFH. Only then will it input the data character and mask off
0546: F901         ; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
0547: F901         ; Read Console Byte function (B$CONIN, code 1).
0548: F901         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0549: F901
0550: F901         ; This is a blocking routine
0551: F901
0552: F901             CONIN:
0553: F901             ConIn:
0554: F901 CD EF F8               CALL   ConStatus
0555: F904 28 FB                  JR     Z,ConIn              ; loop until there is some data to read
0556: F906         ; Call to ConStatus Sets up IX with Physical Table
0557: F906 DD 6E 06               LD     L,(IX+DataReadIndex)
0558: F909 DD 66 07               LD     H,(IX+(DataReadIndex+1))
0559: F90C E9                     JP     (HL)
0560: F90D         ;---------------------------------------------------------------------------
0561: F90D         ;	Console Out:		BIOS 04
0562: F90D         ;
0563: F90D         ;  CONOUT outputs the character (in ASCII) in register C to the console. The
0564: F90D         ; most significant (parity) bit of the character will always be O.
0565: F90D         ; CONOUT must first check that the console device is ready to receive more
0566: F90D         ; data, delaying if necessary until it is, and only then sending the character to the
0567: F90D         ; device. CONOUT is called by the CCP and by the BDOS when a program executes a
0568: F90D         ; Write Console Byte function (B$CONOUT, code 2).
0569: F90D
0570: F90D         ; This is a blocking routine
0571: F90D
0572: F90D             CONOUT:
0573: F90D             CONOut:
0574: F90D 3A 03 00               LD     A,(IOBYTE)
0575: F910 DD 21 E0 F9               LD     IX,CON_Vector
0576: F914
0577: F914             GenericOutStatus:                      ; entry point for standard blocking write
0578: F914 CD 9C F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0579: F917             GenericOutStatus1:
0580: F917 CD 64 F9               CALL   GetOutStatus
0581: F91A 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0582: F91C DD 6E 08               LD     L,(IX+DataWriteIndex)
0583: F91F DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0584: F922 E9                     JP     (HL)
0585: F923
0586: F923         ;---------------------------------------------------------------------------
0587: F923         ;	List output  BIOS 05
0588: F923         ;
0589: F923         ; LIST is similar to CONOUT except that it sends the character in register C to
0590: F923         ; the list device. It too checks first that the list device is ready to receive
0591: F923         ; the character. LIST is called by the CCP in response to the CONTROL-P toggle
0592: F923         ; for printer echo of console output, and by the BDOS when a program makes a
0593: F923         ; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).
0594: F923
0595: F923         ; This is a blocking routine
0596: F923
0597: F923             LIST:
0598: F923 3A 03 00               LD     A,(IOBYTE)
0599: F926 07                     RLCA                        ; move bits 7,6
0600: F927 07                     RLCA                        ; to 1,0
0601: F928 DD 21 F8 F9               LD     IX,LST_Vector
0602: F92C 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0603: F92E
0604: F92E         ;---------------------------------------------------------------------------
0605: F92E         ;	Punch output  BIOS 06
0606: F92E         ;
0607: F92E         ;  PUNCH sends the character in register C to the "punch" device. As mentioned
0608: F92E         ; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
0609: F92E         ; entry point either returns immediately and is effectively a null routine, or it outputs
0610: F92E         ; the character to a communications device, such as a modem, on your computer.
0611: F92E         ; PUNCH must check that the "punch" device is indeed ready to accept another
0612: F92E         ; character for output, and must wait if it is not.
0613: F92E         ;
0614: F92E         ; Digital Research's documentation states that the character to be output will
0615: F92E         ; always have its most significant bit set to O. This is not true. The BDOS simply
0616: F92E         ; transfers control over to the PUNCH entry point in the BIOS; the setting of the
0617: F92E         ; most significant bit will be determined by the program making the BDOS function
0618: F92E         ; request (B$PUNOUT, code 4). This is important because the requirement of a zero
0619: F92E         ; would preclude being able to send pure binary data via the BIOS PUNCH
0620: F92E         ; function
0621: F92E
0622: F92E         ; This is a blocking routine
0623: F92E
0624: F92E             PUNCH:                          ; Punch output
0625: F92E 3A 03 00               LD     A,(IOBYTE)
0626: F931 0F                     RRCA
0627: F932 0F                     RRCA
0628: F933 0F                     RRCA                        ; move bits 5,4
0629: F934 0F                     RRCA                        ; to 1,0
0630: F935 DD 21 F0 F9               LD     IX,PUN_Vector
0631: F939 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0632: F93B
0633: F93B         ;---------------------------------------------------------------------------
0634: F93B         ;	Reader input  BIOS 07
0635: F93B         ;
0636: F93B         ; As with the PUNCH entry point, the READER entry point rarely connects to
0637: F93B         ; a real paper tape reader.
0638: F93B         ; The READER function must return the next character from the reader device
0639: F93B         ; in the A register, waiting, if need be, until there is a character.
0640: F93B         ;
0641: F93B         ; Digital Research's documentation again says that the most significant bit of
0642: F93B         ; the A register must be 0, but this is not the case if you wish to receive pure binary
0643: F93B         ; information via this function.
0644: F93B         ; READER is called whenever a program makes a Read "Reader" Byte function
0645: F93B         ; request (B$READIN, code 3).
0646: F93B
0647: F93B         ; This is a blocking routine
0648: F93B
0649: F93B             READER:                         ; Reader Input
0650: F93B 3A 03 00               LD     A,(IOBYTE)
0651: F93E 0F                     RRCA
0652: F93F 0F                     RRCA                        ; move bits 3,2  to 1,0
0653: F940 DD 21 E8 F9               LD     IX,RDR_Vector
0654: F944             READER1:
0655: F944 CD F6 F8               CALL   GenericInStatus
0656: F947 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0657: F949
0658: F949 DD 6E 06               LD     L,(IX+DataReadIndex)
0659: F94C DD 66 07               LD     H,(IX+(DataReadIndex+1))
0660: F94F E9                     JP     (HL)
0661: F950
0662: F950         ;---------------------------------------------------------------------------
0663: F950         ;	List Status:  BIOS 0F
0664: F950
0665: F950         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0666: F950         ; This function returns the current status of the list device, using the IOBYTE if
0667: F950         ; necessary to select the correct physical device. It sets the A register to OFFH if the
0668: F950         ; list device can accept another character for output or to OOH if it is not ready.
0669: F950         ; Digital Research's documentation states that this function is used by the
0670: F950         ; DESPOOL utility program (which allows you to print a file "simultaneously" with
0671: F950         ; other operations) to improve console response during its operation, and that it is
0672: F950         ; acceptable for the routine always to return OOH if you choose not to implement it
0673: F950         ; fully.
0674: F950         ; Unfortunately, this statement is wrong. Many other programs use the LISTST
0675: F950         ; function to "poll" the list device to make sure it is ready, and if it fails to come
0676: F950         ; ready after a predetermined time, to output a message to the console indicating
0677: F950         ; that the printer is not ready. If you ever make a call to the BDOS list output
0678: F950         ; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0679: F950         ; not ready, then CP/M will wait forever-and your program will have lost control
0680: F950         ; so it cannot even detect that the problem has occurred. If LISTST always returns a
0681: F950         ; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
0682: F950         ; out of the LISTST function, but it also causes a stream of false "Printer
0683: F950         ; not Ready" error messages to appear on the console.
0684: F950
0685: F950             LISTST:
0686: F950 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0687: F953 07                     RLCA
0688: F954 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0689: F955 DD 21 F8 F9               LD     IX,LST_Vector        ; Set th vector base
0690: F959 CD 9C F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0691: F95C CD 64 F9               CALL   GetOutStatus
0692: F95F
0693: F95F B7                     OR     A
0694: F960 C8                     RET    Z                    ; 00 => Device Ready
0695: F961 3E FF                  LD     A,0FFH
0696: F963 C9                     RET                         ; OFFH => Device No Ready
0697: F964
0698: F964         ;---------------------------------------------------------------------------
0699: F964
0700: F964         ;---------------------------------------------------------------------
0701: F964             GetOutStatus:
0702: F964         ; vector to CON Devices
0703: F964 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0704: F967 18 03                  JR     GetStatus
0705: F969             GetInStatus:
0706: F969 DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0707: F96C             GetStatus:
0708: F96C DD 6E 04               LD     L,(IX+StatusReadIndex)
0709: F96F DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0710: F972 E9                     JP     (HL)                 ; jump to the stats read routine
0711: F973
0712: F973         ;---------------------------------------------------------------------
0713: F973
0714: F973             DataRead:
0715: F973 DD 7E 01               LD     A,(IX+DataPortIndex)
0716: F976 32 7A F9               LD     (AddressDataIn),A    ; modify code with the Data port
0717: F979 DB                     DB     IN_OPCODE
0718: F97A             AddressDataIn:
0719: F97A 00                     DB     00                   ; perform the read
0720: F97B C9                     RET
0721: F97C
0722: F97C             DataReadASCII:
0723: F97C CD 73 F9               CALL   DataRead
0724: F97F E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0725: F981 C9                     RET                         ; AND		ASCII_MASK
0726: F982
0727: F982         ; Enter DataWrite the value to be output in C
0728: F982             DataWrite:
0729: F982 DD 7E 01               LD     A,(IX+DataPortIndex)
0730: F985 32 8A F9               LD     (AddressDataOut),A   ; modify code with the Data port
0731: F988 79                     LD     A,C                  ; get value into ACC
0732: F989 D3                     DB     OUT_OPCODE
0733: F98A             AddressDataOut:
0734: F98A 00                     DB     00                   ; perform the write
0735: F98B C9                     RET
0736: F98C
0737: F98C
0738: F98C         ; Enter Status Read with Target mask in D
0739: F98C             StatusRead:
0740: F98C DD 7E 00               LD     A,(IX+StatusPortIndex)
0741: F98F 32 93 F9               LD     (AddressStatus),A    ; modify code with the status port
0742: F992 DB                     DB     IN_OPCODE
0743: F993             AddressStatus:
0744: F993 00                     DB     00
0745: F994 A2                     AND    D                    ; Check return vale with the mask
0746: F995 C9                     RET
0747: F996
0748: F996             DUMMYRead:
0749: F996 C9                     RET
0750: F997             DUMMYWrite:
0751: F997 C9                     RET
0752: F998             DUMMYCheck:
0753: F998 3E FF                  LD     A,0FFH               ; Always return 0FFH
0754: F99A B7                     OR     A                    ; Set flags
0755: F99B C9                     RET
0756: F99C
0757: F99C         ;=============================================================================
0758: F99C             SetDeviceVector:
0759: F99C E6 03                  AND    03H                  ; Get bits 0 & 1;
0760: F99E 87                     ADD    A,A                  ; Double for word size index
0761: F99F 16 00                  LD     D,00H
0762: F9A1 5F                     LD     E,A                  ; load byte index int DE
0763: F9A2 DD 19                  ADD    IX,DE                ; add to the value vector base
0764: F9A4         ; IX points at correct entry in vector
0765: F9A4 DD 5E 00               LD     E,(IX+0)
0766: F9A7 DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0767: F9AA D5                     PUSH   DE
0768: F9AB DD E1                  POP    IX                   ; Move it to IX
0769: F9AD C9                     RET
0770: F9AE
0771: F9AE
0772: F9AE         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0773: F9AE         ; Physical Device Attributes
0774: F9AE
0775: F9AE             TTY_StatusPort EQU    0EDH
0776: F9AE             TTY_DataPort EQU    0ECH
0777: F9AE             TTY_OutputMask EQU    80H                  ; Status Mask
0778: F9AE             TTY_InputMask EQU    7FH                  ; Status Mask
0779: F9AE
0780: F9AE             CRT_StatusPort EQU    02H
0781: F9AE             CRT_DataPort EQU    01H
0782: F9AE             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0783: F9AE             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0784: F9AE
0785: F9AE             COM_StatusPort EQU    0EDH
0786: F9AE             COM_DataPort EQU    0ECH
0787: F9AE             COM_OutputMask EQU    01H                  ; Status Mask
0788: F9AE             COM_InputMask EQU    02H                  ; Status Mask
0789: F9AE
0790: F9AE             LPT_StatusPort EQU    011H
0791: F9AE             LPT_DataPort EQU    010H
0792: F9AE             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0793: F9AE             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0794: F9AE
0795: F9AE             DUMMY_StatusPort EQU    011H
0796: F9AE             DUMMY_DataPort EQU    010H
0797: F9AE             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0798: F9AE             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0799: F9AE
0800: F9AE         ; Device Table Control Block Definition
0801: F9AE             StatusPortIndex EQU    0
0802: F9AE             DataPortIndex EQU    1
0803: F9AE             OutputMaskIndex EQU    2
0804: F9AE             InputMaskIndex EQU    3
0805: F9AE             StatusReadIndex EQU    4
0806: F9AE             DataReadIndex EQU    6
0807: F9AE             DataWriteIndex EQU    8
0808: F9AE
0809: F9AE         ;Physical Devices Control Blocks
0810: F9AE
0811: F9AE             TTY_Table:
0812: F9AE ED                     DB     TTY_StatusPort
0813: F9AF EC                     DB     TTY_DataPort
0814: F9B0 80                     DB     TTY_OutputMask
0815: F9B1 7F                     DB     TTY_InputMask
0816: F9B2 8C F9                  DW     StatusRead
0817: F9B4 7C F9                  DW     DataReadASCII
0818: F9B6 82 F9                  DW     DataWrite
0819: F9B8
0820: F9B8             CRT_Table:
0821: F9B8 02                     DB     CRT_StatusPort
0822: F9B9 01                     DB     CRT_DataPort
0823: F9BA 80                     DB     CRT_OutputMask
0824: F9BB 7F                     DB     CRT_InputMask
0825: F9BC 8C F9                  DW     StatusRead
0826: F9BE 73 F9                  DW     DataRead
0827: F9C0 82 F9                  DW     DataWrite
0828: F9C2             COM_Table:
0829: F9C2 ED                     DB     COM_StatusPort
0830: F9C3 EC                     DB     COM_DataPort
0831: F9C4 01                     DB     COM_OutputMask
0832: F9C5 02                     DB     COM_InputMask
0833: F9C6 8C F9                  DW     StatusRead
0834: F9C8 73 F9                  DW     DataRead
0835: F9CA 82 F9                  DW     DataWrite
0836: F9CC             LPT_Table:
0837: F9CC 11                     DB     LPT_StatusPort
0838: F9CD 10                     DB     LPT_DataPort
0839: F9CE FF                     DB     LPT_OutputMask
0840: F9CF 7F                     DB     LPT_InputMask
0841: F9D0 8C F9                  DW     StatusRead
0842: F9D2 73 F9                  DW     DataRead
0843: F9D4 82 F9                  DW     DataWrite
0844: F9D6             DUMMY_Table:
0845: F9D6 11                     DB     DUMMY_StatusPort
0846: F9D7 10                     DB     DUMMY_DataPort
0847: F9D8 FF                     DB     DUMMY_OutputMask
0848: F9D9 7F                     DB     DUMMY_InputMask
0849: F9DA 98 F9                  DW     DUMMYCheck
0850: F9DC 96 F9                  DW     DUMMYRead
0851: F9DE 97 F9                  DW     DUMMYWrite
0852: F9E0
0853: F9E0         ;---------------------------------------------------------------------------
0854: F9E0
0855: F9E0         ; Logical Device Vector, Controlled by IOBYTE
0856: F9E0
0857: F9E0             CON_Vector:                      ; IOBYTE bits 1 & 0
0858: F9E0 AE F9                  DW     TTY_Table
0859: F9E2 B8 F9                  DW     CRT_Table
0860: F9E4 C2 F9                  DW     COM_Table
0861: F9E6 D6 F9                  DW     DUMMY_Table
0862: F9E8             RDR_Vector:                      ; IOBYTE bits 3 & 2
0863: F9E8 AE F9                  DW     TTY_Table
0864: F9EA B8 F9                  DW     CRT_Table
0865: F9EC D6 F9                  DW     DUMMY_Table
0866: F9EE D6 F9                  DW     DUMMY_Table
0867: F9F0             PUN_Vector:                      ; IOBYTE bits 5 & 4
0868: F9F0 AE F9                  DW     TTY_Table
0869: F9F2 D6 F9                  DW     DUMMY_Table
0870: F9F4 C2 F9                  DW     COM_Table
0871: F9F6 B8 F9                  DW     CRT_Table
0872: F9F8             LST_Vector:                      ; IOBYTE bits 7 & 6
0873: F9F8 CC F9                  DW     LPT_Table
0874: F9FA B8 F9                  DW     CRT_Table
0875: F9FC CC F9                  DW     LPT_Table
0876: F9FE D6 F9                  DW     DUMMY_Table
0877: FA00
0878: FA00         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0879: FA00         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0880: FA00
0881: FA00         ;---------------------------------------------------------------------------
0882: FA00         ;	Disk routines
0883: FA00         ;---------------------------------------------------------------------------
0884: FA00
0885: FA00         ;  All of the disk functions that follow were originally designed to operate on the
0886: FA00         ; 128-byte sectors used on single-sided, single-density, 8-inch floppy diskettes that
0887: FA00         ; were standard in the industry at the time. Now that CP/M runs on many different
0888: FA00         ; types of disks, some of the BIOS disk functions seem strange because most of the
0889: FA00         ; new disk drives use sector sizes other than 128 bytes.
0890: FA00         ; To handle larger sector sizes, the BIOS has some additional code that makes
0891: FA00         ; the BDOS respond as if it were still handling 128-byte sectors. This code is referred
0892: FA00         ; to as the blocking/deblocking code.
0893: FA00         ;  As its name implies, it blocks together several 128-byte "sectors" and only writes
0894: FA00         ; to the disk when a complete physical sector has been assembled.
0895: FA00         ;  When reading, it reads in a physical sector and then deblocks it,handing back
0896: FA00         ; several 128-byte "sectors" to the BDOS.
0897: FA00         ;  To do all of this, the blocking/deblocking code uses a special buffer area of the
0898: FA00         ; same size as the physical sectors on the disk. This is known as the host disk buffer
0899: FA00         ; or HSTBUE Physical sectors are read into this buffer and written to the disk
0900: FA00         ; from it. In order to optimize this blocking/deblocking routine, the BIOS has code in it
0901: FA00         ; to reduce the number of times that an actual disk read or write occurs. A side effect
0902: FA00         ; is that at any given moment, several 128-byte "sectors" may be stored in the
0903: FA00         ; HSTBUF, waiting to be written out to the disk when HSTBUF becomes full. This
0904: FA00         ; sometimes complicates the logic of the BIOS disk functions. You cannot simply
0905: FA00         ; select a new disk drive, for example, when the HSTBUF contains data destined for
0906: FA00         ; another disk drive. You will see this complication in the BIOS only in the form of
0907: FA00         ; added logical operations; the BIOS disk functions rarely trigger immediate physical
0908: FA00         ; operations. It is easier to understand these BIOS functions if you consider that
0909: FA00         ; they make requests-and that these requests are satisfied only when it makes
0910: FA00         ; sense to do so, taking into account the blocking/ deblocking logic.
0911: FA00
0912: FA00         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0913: FA00         ;---------------------------------------------------------------------------
0914: FA00
0915: FA00         ;---------------------------------------------------------------------------
0916: FA00         ;	Home Disk	BIOS 08
0917: FA00         ;
0918: FA00         ;  HOME - Home the selected logical disk to track 0. Before doing this, a check
0919: FA00         ; must be made to see if the physical disk buffer has information that must be
0920: FA00         ; written out. This is indicated by a flag, DirtyBufferFlag,set in the de-blocking code
0921: FA00
0922: FA00             HOME:
0923: FA00 3A A8 FB               LD     A,(DirtyBufferFlag)  ; Check for Dirty Buffer
0924: FA03 B7                     OR     A
0925: FA04 20 03                  JR     NZ,HomeNoWrite
0926: FA06 32 A7 FB               LD     (DataInBufferFlag),A ; Clear DataInBufferFlag if Buffer not dirty
0927: FA09             HomeNoWrite:
0928: FA09 0E 00                  LD     C,00H                ; Set to track 0
0929: FA0B CD 39 FA               CALL   SETTRK               ; no, physical, only logical
0930: FA0E C9                     RET
0931: FA0F
0932: FA0F         ;---------------------------------------------------------------------------
0933: FA0F         ;	Select Disk	BIOS 09
0934: FA0F
0935: FA0F         ;  SELDSK does not do what its name implies. It does not (and must not)
0936: FA0F         ; physically select a logical disk. Instead, it returns a pointer in the
0937: FA0F         ; HL register pair to the disk parameter header for the logical disk specified
0938: FA0F         ; in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK also
0939: FA0F         ; stores this code for the requested disk to be used later in the READ and WRITE functions.
0940: FA0F         ; If the logical disk code in register C refers to a nonexistent disk or to one for
0941: FA0F         ; which no disk parameter header exists, then SELDSK must return with HL set to
0942: FA0F         ; OOOOH. Then the BDOS will output a message of the form "BDOS Err on XI Select"
0943: FA0F         ; Note that SELDSK not only does not select the disk, but also does not indicate
0944: FA0F         ; whether or not the requested disk is physically present -merely whether or not
0945: FA0F         ; there are disk tables present for the disk.
0946: FA0F         ;  SELDSK is called by the BDOS either during disk file operations or by a
0947: FA0F         ; program issuing a Select Disk request (B$SELDSK, code 14).
0948: FA0F
0949: FA0F             SELDSK:
0950: FA0F 21 00 00               LD     HL,00H               ; Assume an error
0951: FA12 79                     LD     A,C
0952: FA13 FE 04                  CP     NumberOfLogicalDisks
0953: FA15 D0                     RET    NC                   ; return if > max number of Disks
0954: FA16
0955: FA16 32 AA FB               LD     (SelectedDisk),A     ; save disk number
0956: FA19
0957: FA19 07                     RLCA                        ; X2
0958: FA1A 07                     RLCA                        ; X4
0959: FA1B 07                     RLCA                        ; X8
0960: FA1C 07                     RLCA                        ; X16
0961: FA1D 16 00                  LD     D,0
0962: FA1F 5F                     LD     E,A                  ; put index int DE
0963: FA20 DD 21 B9 FB               LD     IX,DiskParameterHeaders ; get DPH address Base
0964: FA24 DD 19                  ADD    IX,DE                ; get the specific DiskParameterHeader
0965: FA26 DD E5                  PUSH   IX                   ; save for return in HL
0966: FA28
0967: FA28 DD 56 0B               LD     D,(IX+11)            ; LSB for Disk Parameter Block
0968: FA2B DD 5E 0A               LD     E,(IX+10)            ; MSB for Disk Parameter Block
0969: FA2E
0970: FA2E D5                     PUSH   DE
0971: FA2F DD E1                  POP    IX
0972: FA31 DD 7E 0F               LD     A,(IX+15)            ; Disk Parameter Block in IY
0973: FA34 32 A9 FB               LD     (SelectedDskSecsPerHead),A
0974: FA37
0975: FA37 E1                     POP    HL                   ; recover DPH pointer
0976: FA38 C9                     RET
0977: FA39
0978: FA39
0979: FA39
0980: FA39         ;---------------------------------------------------------------------------
0981: FA39         ;	Set Track	BIOS 0A
0982: FA39
0983: FA39         ;  SETTRK saves the requested disk track that is in the BC register pair when
0984: FA39         ; SETTRK gets control. Note that this is an absolute track number; that is, the
0985: FA39         ; number of reserved tracks before the file directory will have been added to the
0986: FA39         ; track number relative to the start of the logical disk.
0987: FA39         ;  The number of the requested track will be used in the next BIOS READ or
0988: FA39         ; WRITE function.
0989: FA39         ;  SETTRK is called by the BDOS when it needs to read or write a 128-byte
0990: FA39         ; sector. Legitimate track numbers are from 0 to OFFFFH (65,535).
0991: FA39
0992: FA39             SETTRK:
0993: FA39         ;	LD		H,B								; select track in BC on entry
0994: FA39         ;	LD		L,C
0995: FA39         ;	LD	(SelectedTrack),HL					; save for low level driver
0996: FA39 ED 43 AB FB               LD     (SelectedTrack),BC   ; save for low level driver
0997: FA3D C9                     RET
0998: FA3E
0999: FA3E         ;---------------------------------------------------------------------------
1000: FA3E         ;	Set Sector	BIOS 0B  (Set Record)
1001: FA3E
1002: FA3E         ; Sector  = Record for disk with 128 byte sectors
1003: FA3E         ; Sector contains 4 records for disks with 512 byte sectors
1004: FA3E         ; this routine is missed named it should be called Set Record
1005: FA3E
1006: FA3E         ;  SETSEC is similar to SETTRK in that it stores the requested Record (sector) number
1007: FA3E         ; for later use in BIOS READ or WRITE functions. The requested Record (sector) number is
1008: FA3E         ; handed to SETSEC in the A register; legitimate values are from 0 to OFFH (255).
1009: FA3E         ; The Record (sector) number is a logical Record (sector) number. It does not take into account any
1010: FA3E         ; sector skewing that might be used to improve disk performance.
1011: FA3E         ;  SETSEC is called by the BDOS when it needs to read or write a 128-byte
1012: FA3E         ; Record (sector).
1013: FA3E
1014: FA3E             SETSEC:                         ; SETRECORD
1015: FA3E 79                     LD     A,C
1016: FA3F 32 AD FB               LD     (SelectedRecord),A   ; save for low level driver
1017: FA42 C9                     RET
1018: FA43
1019: FA43         ;---------------------------------------------------------------------------
1020: FA43         ;	Set Sector	BIOS 0C
1021: FA43
1022: FA43         ;  SETDMA saves the address in the BC register pair in the requested DMA
1023: FA43         ; address. The next BIOS READ or WRITE function will use the DMA address as
1024: FA43         ; a pointer to the 128-byte sector buffer into which data will be read or from which
1025: FA43         ; data will be written.
1026: FA43         ;  The default DMA address is 0080H. SETDMA is called by the BDOS when it
1027: FA43         ; needs to READ or WRITE a 128-byte sector.
1028: FA43
1029: FA43             SETDMA:
1030: FA43 ED 43 AE FB               LD     (DMAAddress),BC      ; save for low level driver
1031: FA47 C9                     RET
1032: FA48
1033: FA48         ;---------------------------------------------------------------------------
1034: FA48         ;	Sector Translate	BIOS 10
1035: FA48
1036: FA48         ;  SECTRAN, given a logical sector number, locates the correct physical sector
1037: FA48         ; number in the sector translate table for the previously selected (via SELDSK)
1038: FA48         ; logical disk drive. Note that both logical and physical sector numbers are
1039: FA48         ; l28-byte sectors, so if you are working with a hard disk system, it is not
1040: FA48         ; too efficient to impose a sector interlace at the l28-byte sector level.
1041: FA48         ; It is better to impose the sector interlace right inside the hard disk driver,
1042: FA48         ; if at all. In general, hard disks spin so rapidly that CP/M simply cannot take
1043: FA48         ; advantage of sector interlace.
1044: FA48         ;  The BDOS hands over the logical sector number in the BC register pair, with
1045: FA48         ; the address of the sector translate table in the DE register pair. SECTRAN must
1046: FA48         ; return the physical sector number in HL.
1047: FA48         ;  If SECTRAN is to be a null routine, it must move the contents of BC to HL
1048: FA48         ; and return.
1049: FA48
1050: FA48             SECTRAN:
1051: FA48 C5                     PUSH   BC
1052: FA49 E1                     POP    HL                   ; just move the value from BC to HL
1053: FA4A C9                     RET
1054: FA4B
1055: FA4B         ;---------------------------------------------------------------------------
1056: FA4B         ;	READ			BIOS 0D
1057: FA4B
1058: FA4B         ;  READ reads in a 128-byte sector provided that there have been previous BIOS
1059: FA4B         ; function calls to:
1060: FA4B         ; 				- SELDSK	"select" the disk
1061: FA4B         ; 				- SETDMA	set the DMA address
1062: FA4B         ; 				- SETTRK	set the track number
1063: FA4B         ; 				- SETSEC	set the sector number.
1064: FA4B         ;
1065: FA4B         ; Because of the blocking/ deblocking code in the BIOS, there are frequent occasions
1066: FA4B         ; when the requested sector will already be in the host buffer (HSTBUF), so that a
1067: FA4B         ; physical disk read is not required. All that is then required is for the BIOS to move
1068: FA4B         ; the appropriate 128 bytes from the HSTBUF into the buffer pointed at by the DMA address.
1069: FA4B         ; Only during the READ function will the BIOS normally communicate with the physical disk
1070: FA4B         ; drive, selecting it and seeking to read the requested track and sector. During this process,
1071: FA4B         ; the READ function must also handle any hardware errors that occur, trying an operation again
1072: FA4B         ; if a "soft," or recoverable, error occurs.
1073: FA4B         ;  The READ function must return with the A register set to OOH if the read operation has completed
1074: FA4B         ; successfully. If the READ function returns with the A register set to 01 H, the BDOS will
1075: FA4B         ; display an error message of the form BDOS Err on X: Bad Sector. Under these circumstances,
1076: FA4B         ; you have only two choices. You can enter a CARRIAGE RETURN, ignore the fact that there was an
1077: FA4B         ; error, and attempt to make sense of the data in the DMA buffer. Or you can type a CONTROL-C
1078: FA4B         ; to abort the operation, perform a warm boot, and return control to the CCP. As you can see,
1079: FA4B         ; CP/M's error handling is not particularly helpful, so most BIOS writers add more sophisticated
1080: FA4B         ; error recovery right in the disk driver. This can include some interaction with the console so
1081: FA4B         ; that a more determined effort can be made to correct errors or, if nothing else, give you more
1082: FA4B         ; information as to what has gone wrong. Such error handling is discussed in Chapter 9.
1083: FA4B         ;  If you are working with a hard disk system, the BIOS driver must also handle the management of
1084: FA4B         ; bad sectors. You cannot simply replace a hard disk drive if one or two sectors become unreadable.
1085: FA4B         ; This bad sector management normally requires that a directory of "spare" sectors be put on the
1086: FA4B         ; hard disk before it is used to store data. Then, when a sector is found to be bad,
1087: FA4B         ; one of the spare sectors is substituted in its place.
1088: FA4B
1089: FA4B             READ:
1090: FA4B AF                     XOR    A
1091: FA4C 32 B5 FB               LD     (ModifiedlRecordsCount),A ; 1. Set ModifiedlRecordsCount to 0
1092: FA4F 3C                     INC    A
1093: FA50 32 B8 FB               LD     (ReadWriteFlag),A    ; 2. Set to Flag to read (non-zero)
1094: FA53 32 B7 FB               LD     (PrereadSectorFlag),A ; 3. Force a preread
1095: FA56 3E 02                  LD     A,WriteCleanBuffer
1096: FA58 32 A2 FB               LD     (WriteType),A        ; 4. Fake a clean sector Write type = 02
1097: FA5B C3 88 FA               JP     CommonDiskIO         ; Use common code to execute read
1098: FA5E         ;---------------------------------------------------------------------------
1099: FA5E         ;	WRITE			BIOS 0E
1100: FA5E         ;
1101: FA5E         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
1102: FA5E         ;
1103: FA5E         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
1104: FA5E         ;	00H [WriteAllocated]	An already allocated allocation block (which means a pre-read of the sector may be needed),
1105: FA5E         ;	01H [WriteDirectory]	To the directory (in which case the data will be written to the disk immediately),
1106: FA5E         ;	02H [WriteCleanBuffer]	To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
1107: FA5E
1108: FA5E         ;  WRITE is similar to READ but with the obvious difference that data is transferred from the DMA buffer
1109: FA5E         ; to the specified 128-byte sector. Like READ, this function requires that the following function calls
1110: FA5E         ; have already been made:
1111: FA5E         ; 				- SELDSK	"select" the disk
1112: FA5E         ; 				- SETDMA	set the DMA address
1113: FA5E         ; 				- SETTRK	set the track number
1114: FA5E         ; 				- SETSEC	set the sector number.
1115: FA5E         ;
1116: FA5E         ;  Again, it is only in the WRITE routine that the driver will start to talk directly to the physical hardware,
1117: FA5E         ; selecting the disk unit, track, and sector, and transferring the data to the disk. With the blocking/deblocking code,
1118: FA5E         ; the BDOS optimizes the number of disk writes that are needed by indicating in register C the type of disk write
1119: FA5E         ; that is to be performed:
1120: FA5E         ; 				0= normal sector write
1121: FA5E         ; 				1= write to file directory sector
1122: FA5E         ; 				2 = write to sector of previously unchanged Deblocking Buffer
1123: FA5E         ;
1124: FA5E         ;  Type 0 occurs whenever the BDOS is writing to a data sector in an already used allocation block.
1125: FA5E         ; Under these circumstances, the disk driver must preread the appropriate host sector because there
1126: FA5E         ; may be previously stored information on it.
1127: FA5E         ;
1128: FA5E         ;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in this case, the BIOS must not defer
1129: FA5E         ; writing the sector to the disk, as the information is too valuable to hold in memory until the HSTBUF is full.
1130: FA5E         ; The longer the information resides in the HSTBUF, the greater the chance of a power failure or glitch,
1131: FA5E         ; making file data already physically written to the disk inaccessible because the file directory is out of date.
1132: FA5E         ;
1133: FA5E         ;  Type 2 occurs whenever the BDOS needs to write to the first sector of a previously unused allocation block.
1134: FA5E         ; Unused, in this context, includes an allocation block that has become available as a result of a file being erased.
1135: FA5E         ; In this case, there is no need for the disk driver to preread an entire host-sized sector into the HSTBUF,
1136: FA5E         ; as there is no data of value in the physical sector.
1137: FA5E         ;
1138: FA5E         ;  As with the READ routine, the WRITE function returns with A set to OOH if the operation has been completed successfully.
1139: FA5E         ; If the WRITE function returns with A set to 01H, then the BDOS will display the same message as for READ:
1140: FA5E         ; BDOS Err on X: Bad Sector
1141: FA5E
1142: FA5E
1143: FA5E             WRITE:
1144: FA5E         ; BlockingBuffer I/O
1145: FA5E AF                     XOR    A
1146: FA5F 32 B8 FB               LD     (ReadWriteFlag),A    ; Set to zero to indicate that this is a Write
1147: FA62 79                     LD     A,C
1148: FA63 32 A2 FB               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
1149: FA66
1150: FA66 FE 02                  CP     WriteCleanBuffer     ; first, is this a clean Allocation Buffer block ?
1151: FA68 C2 76 FA               JP     NZ,CheckDirtyBuffer  ; No
1152: FA6B
1153: FA6B         ;Write from a clean Host Buffer
1154: FA6B 21 AA FB               LD     HL,SelectedState
1155: FA6E 11 B1 FB               LD     DE,HostBufferState
1156: FA71 01 04 00               LD     BC,SelectedDiskStateSize
1157: FA74 ED B0                  LDIR                        ; copy Selected State to Host Buffer state
1158: FA76
1159: FA76             CheckDirtyBuffer:
1160: FA76
1161: FA76 21 AA FB               LD     HL,SelectedState
1162: FA79 11 B1 FB               LD     DE,HostBufferState
1163: FA7C CD 1E FB               CALL   CompareDkTrkSec      ; is it in Host Buffer?
1164: FA7F 3E FF                  LD     A,TRUE               ;......
1165: FA81 C2 85 FA               JP     NZ,SetPreread        ; NO - Then we need to load the Host Buffer
1166: FA84
1167: FA84 AF                     XOR    A
1168: FA85             SetPreread:
1169: FA85 32 B7 FB               LD     (PrereadSectorFlag),A ; clear preread flag
1170: FA88         ;*******************************************************
1171: FA88         ; Common code to execute both reads and writes of 128-byte records
1172: FA88         ;*******************************************************
1173: FA88             CommonDiskIO:
1174: FA88 AF                     XOR    A                    ; Assume no disk error will occur
1175: FA89 32 B6 FB               LD     (DiskStatus),A
1176: FA8C
1177: FA8C         ;-------------------------Convert selected record into physical sector-----------;
1178: FA8C 3A AD FB               LD     A,(SelectedRecord)   ;
1179: FA8F 1F                     RRA                         ; Convert selected record                ;
1180: FA90 1F                     RRA                         ; into physical sector by dividing by 4  ;
1181: FA91 E6 3F                  AND    03FH                 ; Remove unwanted bits                   ;
1182: FA93 32 B0 FB               LD     (SelectedSector),A   ;
1183: FA96         ;-------------------------Convert selected record into physical sector-----------;
1184: FA96
1185: FA96         ;------------------------- Any Data in Buffer -----------------------------------;
1186: FA96         ;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes 		 ;
1187: FA96
1188: FA96 21 A7 FB               LD     HL,DataInBufferFlag  ; See if there is any data here ?        ;
1189: FA99 7E                     LD     A,(HL)               ;
1190: FA9A 36 FF                  LD     (HL),TRUE            ; Force flag true                        ;
1191: FA9C B7                     OR     A                    ; Was  any data here ?                   ;
1192: FA9D CA BD FA               JP     Z,SetIOBufferState   ; NO ?- go read into buffer              ;
1193: FAA0         ;------------------------- Any Data in Buffer -----------------------------------;
1194: FAA0
1195: FAA0         ;-----------------------------test for  the sector in the buffer-----------------;
1196: FAA0 11 A3 FB               LD     DE,IOBufferState     ; get the Buffer Disk and Track          ;
1197: FAA3 21 AA FB               LD     HL,SelectedState     ; get the requested Disk and Track       ;
1198: FAA6 CD 19 FB               CALL   CompareDkTrk         ; Are they the same ?                    ;
1199: FAA9 C2 B6 FA               JP     NZ,DataNotInBuffer   ; NO,jump - it must be read 				 ;
1200: FAAC         ;
1201: FAAC         ; Yes, the disk, track are the same are the sectors the same ?                   ;
1202: FAAC         ;
1203: FAAC 3A A6 FB               LD     A,(IOBufferSector)   ; get the sector                         ;
1204: FAAF 21 B0 FB               LD     HL,SelectedSector    ;
1205: FAB2 BE                     CP     M                    ; Check if correct physical sector       ;
1206: FAB3 CA DA FA               JP     Z,DataIsInBuffer     ; Yes - it is already in memory          ;
1207: FAB6         ;-----------------------------test for  the sector in the buffer-----------------;
1208: FAB6
1209: FAB6         ;------------------------- Do we have to write out the buffer ?------------------;
1210: FAB6             DataNotInBuffer:                      ;
1211: FAB6 3A A8 FB               LD     A,(DirtyBufferFlag)  ;
1212: FAB9 B7                     OR     A                    ; do we need to write ?                  ;
1213: FABA C4 2A FB               CALL   NZ,WritePhysical     ; if yes - write it out                  ;
1214: FABD         ;------------------------- Do we have to write out the buffer ?------------------;
1215: FABD
1216: FABD         ;------------------------- prepare for physical IO ------------------------------;
1217: FABD             SetIOBufferState:                      ;
1218: FABD         ; indicate the  selected disk, track, and sector not residing in buffer          ;
1219: FABD 3A AA FB               LD     A,(SelectedDisk)     ;
1220: FAC0 32 A3 FB               LD     (IOBufferDisk),A     ;
1221: FAC3 2A AB FB               LD     HL,(SelectedTrack)   ;
1222: FAC6 22 A4 FB               LD     (IOBufferTrack),HL   ;
1223: FAC9         ;
1224: FAC9 3A B0 FB               LD     A,(SelectedSector)   ;
1225: FACC 32 A6 FB               LD     (IOBufferSector),A   ;
1226: FACF         ;------------------------- prepare for physical IO ------------------------------;
1227: FACF
1228: FACF         ;------------------------- Read the data if needed, or its already in the buffer -;
1229: FACF 3A B7 FB               LD     A,(PrereadSectorFlag) ; do we need to preread ?                 ;
1230: FAD2 B7                     OR     A                    ;
1231: FAD3 C4 2F FB               CALL   NZ,ReadPhysical      ; yes - preread the sector                ;
1232: FAD6         ;
1233: FAD6         ; At this point the data is in the buffer.                                        ;
1234: FAD6         ; Either it was already here, or we returned from ReadPhysical                    ;
1235: FAD6         ;
1236: FAD6 AF                     XOR    A                    ;
1237: FAD7 32 A8 FB               LD     (DirtyBufferFlag),A  ; Reset the DirtyBufferFlag	          ;
1238: FADA         ;------------------------- Read the data if needed, or its already in the buffer -;
1239: FADA
1240: FADA
1241: FADA         ; The Buffer now has the data we want to Read/Write
1242: FADA         ;-------------------------Calculate the address of the record in the sector ------;
1243: FADA         ;
1244: FADA             DataIsInBuffer:                      ;
1245: FADA 3A AD FB               LD     A,(SelectedRecord)   ;
1246: FADD E6 03                  AND    SectorMask           ; Want relative record number in Sector   ;
1247: FADF 3C                     INC    A                    ; Adjust for DJNZ                         ;
1248: FAE0 47                     LD     B,A                  ;
1249: FAE1 11 80 00               LD     DE,cpmRecordSize     ;
1250: FAE4 21 80 FF               LD     HL,-cpmRecordSize    ;
1251: FAE7             SectorInBuffer1:                      ;
1252: FAE7 19                     ADD    HL,DE                ; RecordNumber * recordSize               ;
1253: FAE8 10 FD                  DJNZ   SectorInBuffer1      ;  yields index into the Sector           ;
1254: FAEA         ;
1255: FAEA 11 40 F6               LD     DE,DiskBuffer        ; Start of sector                         ;
1256: FAED 19                     ADD    HL,DE                ; HL -> start of record in buffer 		  ;
1257: FAEE ED 5B AE FB               LD     DE,(DMAAddress)      ; Callers  DMA Address                    ;
1258: FAF2         ;
1259: FAF2         ;-------------------------Calculate the address of the record in the sector ------;
1260: FAF2
1261: FAF2
1262: FAF2         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1263: FAF2         ;
1264: FAF2 3A B8 FB               LD     A,(ReadWriteFlag)    ; 0 => Write, non Zero => Read            ;
1265: FAF5 B7                     OR     A                    ; Write: move data from DMA to Buffer     ;
1266: FAF6 C2 FE FA               JP     NZ,BufferMove        ; Read : move data from Buffer to DMA     ;
1267: FAF9         ;
1268: FAF9 3C                     INC    A                    ; Set the flag to indicate dirty buffer   ;
1269: FAFA 32 A8 FB               LD     (DirtyBufferFlag),A  ;
1270: FAFD EB                     EX     DE,HL                ; Swap source and destination for write   ;
1271: FAFE         ;
1272: FAFE         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1273: FAFE
1274: FAFE
1275: FAFE             BufferMove:
1276: FAFE 01 80 00               LD     BC,cpmRecordSize
1277: FB01 ED B0                  LDIR                        ; Move data to/from Host Buffer
1278: FB03
1279: FB03 3A A2 FB               LD     A,(WriteType)        ; Is this a write to the directory ?
1280: FB06 FE 01                  CP     WriteDirectory
1281: FB08 3A B6 FB               LD     A,(DiskStatus)       ; Set ACC with disk status if an immediate return
1282: FB0B C0                     RET    NZ                   ; Return if not updating a directory entry
1283: FB0C
1284: FB0C B7                     OR     A                    ; Check for any disk errors ?
1285: FB0D C0                     RET    NZ                   ; If yes - abandon attempt to write to directory
1286: FB0E
1287: FB0E AF                     XOR    A
1288: FB0F 32 A8 FB               LD     (DirtyBufferFlag),A  ; Clear the dirty buffer flag
1289: FB12 CD 2A FB               CALL   WritePhysical        ; do an immediate update of the directory to disk
1290: FB15 3A B6 FB               LD     A,(DiskStatus)       ; Set ACC with disk status
1291: FB18 C9                     RET
1292: FB19         ;********************************************************************
1293: FB19
1294: FB19
1295: FB19         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
1296: FB19             CompareDkTrk:
1297: FB19 01 03 00               LD     BC,03H
1298: FB1C 18 03                  JR     CompareDkTrkSecLoop
1299: FB1E             CompareDkTrkSec:
1300: FB1E 01 04 00               LD     BC,04H
1301: FB21             CompareDkTrkSecLoop:
1302: FB21 1A                     LD     A,(DE)               ; Get value
1303: FB22 13                     INC    DE                   ; anticipate next iteration
1304: FB23 ED A1                  CPI                         ; does A = (HL)
1305: FB25 C0                     RET    NZ                   ; Not a match exit
1306: FB26 EA 21 FB               JP     PE,CompareDkTrkSecLoop ; Loop if not done
1307: FB29 C9                     RET
1308: FB2A
1309: FB2A
1310: FB2A         ;************************************************
1311: FB2A         ;			Physical Disk IO					*
1312: FB2A         ;************************************************
1313: FB2A
1314: FB2A         ;Write contents of disk buffer to correct sector
1315: FB2A             WritePhysical:
1316: FB2A 3E 02                  LD     A,DiskWriteCode      ; get write function
1317: FB2C C3 31 FB               JP     CommonPhysical
1318: FB2F
1319: FB2F             ReadPhysical:
1320: FB2F 3E 01                  LD     A,DiskReadCode       ; get read function
1321: FB31
1322: FB31         ; Set up the Dick Control Table DCT
1323: FB31             CommonPhysical:
1324: FB31         ;Command
1325: FB31 32 95 FB               LD     (DCTCommand),A       ; set the command for Read or Write
1326: FB34         ;Disk
1327: FB34 3A A3 FB               LD     A,(IOBufferDisk)
1328: FB37 E6 03                  AND    03H                  ; only units 0 to 3
1329: FB39 32 96 FB               LD     (DCTDisk),A          ; set disk
1330: FB3C         ;Track
1331: FB3C 2A A4 FB               LD     HL,(IOBufferTrack)
1332: FB3F 7D                     LD     A,L                  ; for this controller it is a byte value
1333: FB40 32 98 FB               LD     (DCTTrack),A         ; set track
1334: FB43         ;Head and Track	Calculations
1335: FB43         ; The sector must be converted into a head number and sector number.
1336: FB43         ;	Head = (int) Sector / SectorsPerHead
1337: FB43         ;	Sector = Sector MOD SectorsPerHead
1338: FB43             DetermineHead:
1339: FB43 06 00                  LD     B,0                  ; Start at head 0
1340: FB45 21 A9 FB               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1341: FB48 3A A6 FB               LD     A,(IOBufferSector)   ; get target sector
1342: FB4B             DetermineHead1:
1343: FB4B BE                     CP     M                    ; Need another Head?
1344: FB4C DA 54 FB               JP     C,HeadFound          ; nope done with head calculation
1345: FB4F
1346: FB4F 96                     SUB    M                    ; subtract track value
1347: FB50 04                     INC    B                    ; Increment head
1348: FB51 C3 4B FB               JP     DetermineHead1       ; loop for next head value
1349: FB54
1350: FB54         ;Sector
1351: FB54             HeadFound:                      ; ACC now has Sector MOD SectorsPerHead
1352: FB54 3C                     INC    A                    ; physical sectors start at 1
1353: FB55 32 99 FB               LD     (DCTSector),A        ; set sector
1354: FB58         ;Head
1355: FB58 78                     LD     A,B
1356: FB59 32 97 FB               LD     (DCTHead),A          ; set head number
1357: FB5C         ;Byte Count
1358: FB5C 21 00 02               LD     HL,diskSectorSize
1359: FB5F 22 9A FB               LD     (DCTByteCount),HL    ; set byte count
1360: FB62         ;DMA
1361: FB62 21 40 F6               LD     HL,DiskBuffer
1362: FB65 22 9C FB               LD     (DCTDMAAddress),HL   ; set transfer address
1363: FB68
1364: FB68         ; Since only one control table is in use, close the status and busy chain pointers
1365: FB68         ; back to the main control bytes
1366: FB68         ;NextStatusBlock
1367: FB68 21 43 00               LD     HL,DiskStatusLocation
1368: FB6B 22 9E FB               LD     (DCTNextStatusBlock),HL
1369: FB6E         ;NextControlLocation
1370: FB6E 21 45 00               LD     HL,DiskControlByte
1371: FB71 22 A0 FB               LD     (DCTNextControlLocation),HL
1372: FB74
1373: FB74         ;Put  DCT pointer in page0
1374: FB74 21 95 FB               LD     HL,DCTCommand
1375: FB77 22 46 00               LD     (DiskCommandBlock),HL
1376: FB7A         ; Make the IO happen
1377: FB7A 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1378: FB7D 36 80                  LD     (HL),080H
1379: FB7F
1380: FB7F         ;Wait until Disk Status Block indicates the operation is complete,
1381: FB7F             WaitForDiskComplete:
1382: FB7F 7E                     LD     A,(HL)               ; get control bytes
1383: FB80 B7                     OR     A
1384: FB81 C2 7F FB               JP     NZ,WaitForDiskComplete ; operation not done
1385: FB84
1386: FB84
1387: FB84         ;Check if any errors occurred.
1388: FB84 3A 43 00               LD     A,(DiskStatusLocation)
1389: FB87 DA 8F FB               JP     C,DiskError
1390: FB8A AF                     XOR    A
1391: FB8B 32 B6 FB               LD     (DiskStatus),A       ; clear the flag
1392: FB8E C9                     RET
1393: FB8F
1394: FB8F         ; set error flag and return
1395: FB8F             DiskError:
1396: FB8F 3E 01                  LD     A,1
1397: FB91 32 B6 FB               LD     (DiskStatus),A       ; set the error flag
1398: FB94 C9                     RET
1399: FB95
1400: FB95         ;********************************************************************
1401: FB95         ;********************************************************************
1402: FB95         ;********************************************************************
1403: FB95
1404: FB95         ;---------------------------------------------------------------------------
1405: FB95         ;	Disk Data
1406: FB95         ;---------------------------------------------------------------------------
1407: FB95         ;	Disk Equates
1408: FB95         ;---------------------------------------------------------------------------
1409: FB95         ; Disk Types
1410: FB95         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1411: FB95         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1412: FB95         ;;HardDisk	EQU	2						; hard disk
1413: FB95         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1414: FB95
1415: FB95
1416: FB95         ;**************************************************************************************************
1417: FB95         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1418: FB95         ;
1419: FB95         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1420: FB95         ; perform some disk operation.  These are called its disk control byte.
1421: FB95         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1422: FB95         ; following the respective control bytes. This word must contain the address of  valid disk control
1423: FB95         ; table that specifies the exact disk operation to be performed.
1424: FB95         ;
1425: FB95         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1426: FB95         ; This indicates completion to the disk driver code.
1427: FB95         ;
1428: FB95         ;  The controller also sets a return code in a disk status block - location 0X43H.
1429: FB95         ; If the first byte of this status block is less than 80H. then a disk error
1430: FB95         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1431: FB95         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1432: FB95         ; ten times before the controller returns an error
1433: FB95         ;
1434: FB95         ;  The disk control table layout is shown below. Note that the controller has the capability
1435: FB95         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1436: FB95         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1437: FB95         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1438: FB95         ; the end of the chain
1439: FB95         ;**************************************************************************************************
1440: FB95
1441: FB95         ;***************************************************************************
1442: FB95         ;	Disk Control tables
1443: FB95         ;***************************************************************************
1444: FB95         ;;DiskControlTable:
1445: FB95             DCTStart:
1446: FB95 00          DCTCommand: DB     00H                  ; Command
1447: FB96 00          DCTDisk:   DB     00H                  ; unit (drive) number = 0 or 1
1448: FB97 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1449: FB98 00          DCTTrack:  DB     00H                  ; track number
1450: FB99 00          DCTSector: DB     00H                  ; sector number
1451: FB9A 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1452: FB9C 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1453: FB9E 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1454: FBA0 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1455: FBA2             DCTEnd:
1456: FBA2             DCTSize    EQU    DCTEnd-DCTStart
1457: FBA2         ;-----------------------------------------
1458: FBA2         ;WriteAllocated		EQU	00H		W_NORMAL
1459: FBA2         ;WriteDirectory		EQU	01H		W_DIRECTORY
1460: FBA2         ;WriteCleanBuffer	EQU	02H		W_NEW_BLOCK
1461: FBA2         ;-----------------------------------------
1462: FBA2
1463: FBA2 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1464: FBA3
1465: FBA3         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1466: FBA3             IOBufferState:
1467: FBA3 00          IOBufferDisk: DB     00H
1468: FBA4 00 00       IOBufferTrack: DW     00H
1469: FBA6 00          IOBufferSector: DB     00H
1470: FBA7 00          DataInBufferFlag: DB     00H                  ; when non-zero, the disk buffer has data from disk
1471: FBA8 00          DirtyBufferFlag: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1472: FBA9         ;   but not yet written out to the disk
1473: FBA9         ;---------------------------------------------------------------------------
1474: FBA9         ;	Disk Storage area
1475: FBA9         ;---------------------------------------------------------------------------
1476: FBA9         ;     variables for selected disk, track and sector
1477: FBA9         ; These are moved and compared as a group, DO NOT ALTER
1478: FBA9
1479: FBA9 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1480: FBAA
1481: FBAA             SelectedState:
1482: FBAA 00          SelectedDisk: DB     00H
1483: FBAB 00 00       SelectedTrack: DW     0000H
1484: FBAD 00          SelectedRecord: DB     00H
1485: FBAE
1486: FBAE             SelectedDiskStateEnd:
1487: FBAE             SelectedDiskStateSize EQU    SelectedDiskStateEnd - SelectedDisk
1488: FBAE
1489: FBAE 00 00       DMAAddress: DW     0000H                ; DMA address
1490: FBB0
1491: FBB0 00          SelectedSector: DB     00H
1492: FBB1
1493: FBB1         ; Parameters for the records in the Fresh Allocation Block
1494: FBB1         ; These are moved and compared as a group, DO NOT ALTER
1495: FBB1
1496: FBB1             HostBufferState:
1497: FBB1 00          HostBufferDisk: DB     00H
1498: FBB2 00 00       HostBufferTrack: DW     0000H
1499: FBB4 00          HostBufferRecord: DB     00H
1500: FBB5
1501: FBB5 00          ModifiedlRecordsCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1502: FBB6 00          DiskStatus: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1503: FBB7         ; Flags used inside the de-blocking code
1504: FBB7 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1505: FBB8         ; either before a write to a allocated block can occur, or
1506: FBB8         ; for a normal cpmRecord read
1507: FBB8 00          ReadWriteFlag: DB     00H                  ; 0 => Write-  Non-zero =>read
1508: FBB9
1509: FBB9         ;---------------------------------------------------------------------------
1510: FBB9
1511: FBB9         ;---------------------------------------------------------------------------
1512: FBB9         ;	Disk Definition Tables
1513: FBB9         ; These consists of disk parameter headers, with one entry
1514: FBB9         ; per logical disk driver, and disk parameter blocks, with
1515: FBB9         ; either one parameter block per logical disk or the same
1516: FBB9         ; parameter block for several logical disks.
1517: FBB9         ;---------------------------------------------------------------------------
1518: FBB9         ;---------------------------------------------------------------------------
1519: FBB9             DiskParameterHeaders:
1520: FBB9
1521: FBB9         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1522: FBB9 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1523: FBBB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1524: FBBD 00 00                  DW     0000H                ; Last Selected Track #
1525: FBBF 00 00                  DW     0000H                ; Last Selected Sector #
1526: FBC1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1527: FBC3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1528: FBC5 09 FC                  DW     DiskAWorkArea
1529: FBC7 89 FC                  DW     DiskAAllocationVector
1530: FBC9
1531: FBC9         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1532: FBC9 00 00                  DW     0000H                ; No Skew table
1533: FBCB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1534: FBCD 00 00                  DW     0000H                ; Last Selected Track #
1535: FBCF 00 00                  DW     0000H                ; Last Selected Sector #
1536: FBD1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1537: FBD3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1538: FBD5 29 FC                  DW     DiskBWorkArea
1539: FBD7 E2 FC                  DW     DiskBAllocationVector
1540: FBD9
1541: FBD9         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1542: FBD9 00 00                  DW     0000H                ; No Skew table
1543: FBDB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1544: FBDD 00 00                  DW     0000H                ; Last Selected Track #
1545: FBDF 00 00                  DW     0000H                ; Last Selected Sector #
1546: FBE1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1547: FBE3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1548: FBE5 49 FC                  DW     DiskCWorkArea
1549: FBE7 3B FD                  DW     DiskCAllocationVector
1550: FBE9
1551: FBE9         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1552: FBE9 00 00                  DW     0000H                ; No Skew table
1553: FBEB 00 00                  DW     0000H                ; Rel pos for file (0-3)
1554: FBED 00 00                  DW     0000H                ; Last Selected Track #
1555: FBEF 00 00                  DW     0000H                ; Last Selected Sector #
1556: FBF1 ED FD                  DW     DirectoryBuffer      ; all disks use this buffer
1557: FBF3 F9 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1558: FBF5 69 FC                  DW     DiskDWorkArea
1559: FBF7 94 FD                  DW     DiskDAllocationVector
1560: FBF9
1561: FBF9
1562: FBF9         ;-----------------------------------------------------------
1563: FBF9
1564: FBF9             ParameterBlock3HD:
1565: FBF9 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1566: FBFB 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1567: FBFC 0F                     DB     dpb3hdBLM            ; Block mask
1568: FBFD 00                     DB     dpb3hdEXM            ; Extent mask
1569: FBFE C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1570: FC00 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1571: FC02 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1572: FC03 00                     DB     dpb3hdAL1            ;  for file directory
1573: FC04 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1574: FC06 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1575: FC08
1576: FC08 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1577: FC09
1578: FC09
1579: FC09
1580: FC09         ;---------------------------------------------------------------------------
1581: FC09         ;	Disk work area
1582: FC09         ;---------------------------------------------------------------------------
1583: FC09         ; These are used by the BDOS to detect any unexpected
1584: FC09         ; change of diskette. The BDOS will automatically set
1585: FC09         ; such a changed diskette to read-only status.
1586: FC09
1587: FC09             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1588: FC29             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1589: FC49             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1590: FC69             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1591: FC89
1592: FC89         ;---------------------------------------------------------------------------
1593: FC89         ;	Disk allocation vectors
1594: FC89         ;---------------------------------------------------------------------------
1595: FC89         ; Disk allocation vectors
1596: FC89         ; These are used by the BDOS to maintain a bit map of
1597: FC89         ; which allocation blocks are used and which are free.
1598: FC89         ; One byte is used for eight allocation blocks, hence the
1599: FC89         ; expression of the form (allocation blocks/8)+1
1600: FC89
1601: FC89             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1602: FCE2             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1603: FD3B
1604: FD3B             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1605: FD94             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1606: FDED         ;---------------------------------------------------------------------------
1607: FDED         ;	Disk Buffer
1608: FDED         ;---------------------------------------------------------------------------
1609: FDED             DirectoryBuffer: DS     DirBuffSize
           ************************   Xref   ************************
0000: $               FDED   0324
0718: AddressDataIn   F97A   0716
0733: AddressDataOut  F98A   0730
0743: AddressStatus   F993   0741
0328: AfterDiskBuffer F840
0090: ASCII_A         0041
0091: ASCII_C         0043
0092: ASCII_K         004B
0099: ASCII_LO_A      0061
0100: ASCII_LO_K      006B
0101: ASCII_LO_P      0070
0042: ASCII_MASK      007F   0724
0093: ASCII_N         004E
0094: ASCII_Q         0051
0095: ASCII_R         0052
0096: ASCII_W         0057
0097: ASCII_Y         0059
0077: ASCII_ZERO      0030
0071: ASTERISK        002A
0156: BDOSBase        E800   0157 0159
0125: BDOSE           0005   0126 0449 0451
0157: BDOSEntry       E806   0450
0146: BDOSLength      0E00   0149 0159 0160 0493
0060: BELL            0007
0159: BIOSBase        F600
0147: BIOSLength      0A00   0149
0119: BIOSPAGE        0002
0160: BIOSStart       F600   0300
0256: BlockSize       0800   0278
0357: BOOT            F840   0304
0293: BOOT_CON_ADDRESS 00EC   0470
1275: BufferMove      FAFE   1266
0038: BYTE            0001
0098: CARET           005E
0154: CCPEntry        E000   0156 0160 0431 0459 0495
0145: CCPLength       0800   0149 0156 0160 0493
1159: CheckDirtyBuffer FA76   1151
0302: CodeStart       F600
0078: COLON           003A
0786: COM_DataPort    00EC   0830
0788: COM_InputMask   0002   0832
0787: COM_OutputMask  0001   0831
0785: COM_StatusPort  00ED   0829
0828: COM_Table       F9C2   0860 0870
0073: COMMA           002C
1173: CommonDiskIO    FA88   1097
1323: CommonPhysical  FB31   1317
1296: CompareDkTrk    FB19   1198
1299: CompareDkTrkSec FB1E   1163
1301: CompareDkTrkSecLoop FB21   1298 1306
0131: ComTail         0080   0132
0133: ComTailChars    0082
0132: ComTailCount    0081   0133
0857: CON_Vector      F9E0   0532 0575
0553: ConIn           F901   0555
0552: CONIN           F901   0308
0572: CONOUT          F90D   0309
0573: CONOut          F90D
0529: CONST           F8EF   0307
0530: ConStatus       F8EF   0554
0233: cpmRecordSize   0080   0235 0238 0240 1249 1250 1276
0063: CR              000D   0475 0477 0480 0483
0781: CRT_DataPort    0001   0822
0783: CRT_InputMask   007F   0824
0782: CRT_OutputMask  0080   0823
0780: CRT_StatusPort  0002   0821
0820: CRT_Table       F9B8   0859 0864 0871 0874
0046: CTRL_C          0003
0047: CTRL_E          0005
0048: CTRL_H          0008
0049: CTRL_K          000B
0050: CTRL_L          000C
0051: CTRL_P          0010
0052: CTRL_R          0012
0053: CTRL_S          0013
0054: CTRL_U          0015
0055: CTRL_X          0018
0056: CTRL_Z          001A
0074: DASH            002D
0267: DataBlocks      02C7   0277
1470: DataInBufferFlag FBA7   0926 1188
1244: DataIsInBuffer  FADA   1206
1210: DataNotInBuffer FAB6   1199
0802: DataPortIndex   0001   0715 0729
0714: DataRead        F973   0723 0826 0834 0842
0722: DataReadASCII   F97C   0817
0806: DataReadIndex   0006   0557 0558 0658 0659
0266: DataSectors     0B1C   0267
0728: DataWrite       F982   0818 0827 0835 0843
0807: DataWriteIndex  0008   0582 0583
1451: DCTByteCount    FB9A   1359
1446: DCTCommand      FB95   1325 1374
1447: DCTDisk         FB96   1329
1452: DCTDMAAddress   FB9C   1362
1455: DCTEnd          FBA2   1456
1448: DCTHead         FB97   1356
1454: DCTNextControlLocation FBA0   1371
1453: DCTNextStatusBlock FB9E   1368
1450: DCTSector       FB99   1353
1456: DCTSize         000D
1445: DCTStart        FB95   1456
1449: DCTTrack        FB98   1333
1338: DetermineHead   FB43
1342: DetermineHead1  FB4B   1348
0238: DirBuffSize     0080   1609
0253: DirectoryBlockCount 0002   0278
1609: DirectoryBuffer FDED   1526 1536 1546 1556
0240: DirectoryEntryPerRecord 0004   0281
0237: DirEntrySize    0020   0240 0278
1471: DirtyBufferFlag FBA8   0923 1211 1237 1269 1288
1601: DiskAAllocationVector FC89   1529
1587: DiskAWorkArea   FC09   1528
1602: DiskBAllocationVector FCE2   1539
0326: DiskBuffer      F640   1255 1361
1588: DiskBWorkArea   FC29   1538
1604: DiskCAllocationVector FD3B   1549
0225: DiskCommandBlock 0046   0368 1375
0224: DiskControlByte 0045   0370 0497 1370 1377
0227: DiskControlTable 0040   0509
1589: DiskCWorkArea   FC49   1548
1605: DiskDAllocationVector FD94   1559
1590: DiskDWorkArea   FC69   1558
1395: DiskError       FB8F   1389
1519: DiskParameterHeaders FBB9   0963
0229: DiskReadCode    0001   0487 0501 1320
0234: diskSectorSize  0200   0235 0256 0264 0327 0506 1358
1502: DiskStatus      FBB6   1175 1281 1290 1391 1397
0223: DiskStatusLocation 0043   0378 0496 0508 1367 1388
0230: DiskWriteCode   0002   1316
0466: DisplayMessage  F898   0364 0437 0472
1489: DMAAddress      FBAE   1030 1257
0136: DMABuffer       0080   0453
0067: DOLLAR          0024
0279: dpb3hdAL0       00C0   1571
0280: dpb3hdAL1       0000   1572
0275: dpb3hdBLM       000F   1567
0274: dpb3hdBSH       0004   1566
0281: dpb3hdCKS       0020   1573 1587 1588 1589 1590
0278: dpb3hdDRM       007F   0281 1570
0277: dpb3hdDSM       02C6   1569 1601 1602 1604 1605
0276: dpb3hdEXM       0000   1568
0283: dpb3hdNOH       0002   1576
0282: dpb3hdOFF       0001   1574
0273: dpb3hdSPT       0090   1565 1576
0796: DUMMY_DataPort  0010   0846
0798: DUMMY_InputMask 007F   0848
0797: DUMMY_OutputMask 00FF   0847
0795: DUMMY_StatusPort 0011   0845
0844: DUMMY_Table     F9D6   0861 0865 0866 0869 0876
0752: DUMMYCheck      F998   0849
0748: DUMMYRead       F996   0850
0750: DUMMYWrite      F997   0851
0140: END_OF_FILE     001A
0044: EndOfMessage    0000   0477 0483
0082: EQUAL_SIGN      003D
0065: EXCLAIM_POINT   0021
0033: FALSE           0000
0128: FCB1            005C   0129
0129: FCB2            006C
0173: fCloseFile      0010
0164: fConsoleIn      0001
0165: fConsoleOut     0002
0176: fDeleteFile     0013
0168: fGetConsoleStatus 000B
0182: fGetCurrentDisk 0019
0181: fGetLoginVector 0018
0184: fGetSetUserNumber 0020
0169: fGetVersion     000C
0179: fMakeFile       0016
0172: fOpenFile       000F
0166: fPrintString    0009
0177: fReadSeq        0014
0167: fReadString     000A
0180: fRenameFile     0017
0170: fResetSystem    000D
0174: fSearchFirst    0011
0175: fSearchNext     0012
0171: fSelectDisk     000E
0183: fSetDMA         001A
0178: fWriteSeq       0015
0534: GenericInStatus F8F6   0655
0577: GenericOutStatus F914   0602 0631
0579: GenericOutStatus1 F917   0581
0705: GetInStatus     F969   0536
0701: GetOutStatus    F964   0580 0691
0707: GetStatus       F96C   0704
0083: GREATER_THAN    003E
0066: HASH_TAG        0023
1351: HeadFound       FB54   1344
0922: HOME            FA00   0313
0927: HomeNoWrite     FA09   0925
1497: HostBufferDisk  FBB1
1499: HostBufferRecord FBB4
1496: HostBufferState FBB1   1155 1162
1498: HostBufferTrack FBB2
0295: IN_OPCODE       00DB   0717 0742
0804: InputMaskIndex  0003   0706
1467: IOBufferDisk    FBA3   1220 1327
1469: IOBufferSector  FBA6   1203 1225 1341
1466: IOBufferState   FBA3   1196
1468: IOBufferTrack   FBA4   1222 1331
0120: IOBYTE          0003   0531 0574 0598 0625 0650 0686
0297: JP_OPCODE       00C3   0443
0069: L_PAREN         0028
0086: LEFT_ARROW      005F
0102: LEFT_CURLY      007B
0149: LengthInBytes   2000   0150 0154 0264
0150: LengthInK       0009
0081: LESS_THAN       003C
0062: LF              000A   0475 0477 0480 0483
0597: LIST            F923   0310
0685: LISTST          F950   0320
0036: LO_NIBBLE_MASK  000F
0442: LoadPage0       F876   0434
0791: LPT_DataPort    0010   0838
0793: LPT_InputMask   007F   0840
0792: LPT_OutputMask  00FF   0839
0790: LPT_StatusPort  0011   0837
0836: LPT_Table       F9CC   0873 0875
0872: LST_Vector      F9F8   0601 0689
0152: MemorySize      0040   0154
1501: ModifiedlRecordsCount FBB5   1091
0265: myOffset        0001   0266 0282
0474: NoDiskMessage   F8A0   0363
0058: NULL            0000
0249: NumberOfHeads   0002   0260 0262 0273 0283
0246: NumberOfLogicalDisks 0004   0952
0035: OFF             0000
0034: ON              FFFF
0296: OUT_OPCODE      00D3   0732
0803: OutputMaskIndex 0002   0703
1564: ParameterBlock3HD FBF9   1527 1537 1547 1557
0068: PERCENT         0025
0075: PERIOD          002E
0123: Pg0CurentDisk   0004   0457
0122: Pg0CurentUser   0004   0123
0072: PLUS_SIGN       002B
1504: PrereadSectorFlag FBB7   1094 1169 1229
0867: PUN_Vector      F9F0   0630
0624: PUNCH           F92E   0311
0084: QMARK           003F
0070: R_PAREN         0029
0116: RAM             0000   0118 0119 0120 0122 0125 0128 0131 0136 0138
0862: RDR_Vector      F9E8   0653
1089: READ            FA4B   0318
0649: READER          F93B   0312
0654: READER1         F944   0656
1319: ReadPhysical    FB2F   1231
0367: ReadRawDisk     F850   0360 0433
1507: ReadWriteFlag   FBB8   1093 1146 1264
0258: RecordsPerBlock 0010
0242: RecordsPerExtent 0080
0235: recordsPerSector 0004   0258 0273
0500: ROMControl      F8E2   0359
0087: RUBOUT          007F
1251: SectorInBuffer1 FAE7   1253
0287: SectorMask      0003   1246
0252: SectorsPerBlock 0004   0256 0258 0261 0267 0287
0262: SectorsPerCylinder 0024   0265 0266
0251: SectorsPerTrack 0012   0260 0262 0273
1050: SECTRAN         FA48   0321
0949: SELDSK          FA0F   0314
1482: SelectedDisk    FBAA   0955 1219 1487
1486: SelectedDiskStateEnd FBAE   1487
1487: SelectedDiskStateSize 0004   1156
1479: SelectedDskSecsPerHead FBA9   0973 1340
1484: SelectedRecord  FBAD   1016 1178 1245
1491: SelectedSector  FBB0   1182 1204 1224
1481: SelectedState   FBAA   1154 1161 1197
1483: SelectedTrack   FBAB   0996 1221
0080: SEMICOLON       003B
0758: SetDeviceVector F99C   0535 0578 0690
1029: SETDMA          FA43   0317 0454
1217: SetIOBufferState FABD   1192
1168: SetPreread      FA85   1165
1014: SETSEC          FA3E   0316
0992: SETTRK          FA39   0315 0929
0076: SLASH           002F
0059: SOH             0001
0064: SPACE           0020
0801: StatusPortIndex 0000   0740
0739: StatusRead      F98C   0816 0825 0833 0841
0805: StatusReadIndex 0004   0708 0709
0264: SystemSectors   0011   0265
0061: TAB             0009
0126: TopRAM          0007
0261: TotalNumberOfBlocks 02D0
0260: TotalNumberOfSectors 0B40   0261 0266
0138: TPA             0100   0361 0507
0250: TracksPerHead   0050   0260
0032: TRUE            FFFF   1164 1190
0776: TTY_DataPort    00EC   0813
0778: TTY_InputMask   007F   0815
0777: TTY_OutputMask  0080   0814
0775: TTY_StatusPort  00ED   0812
0811: TTY_Table       F9AE   0858 0863 0868
0085: UNDER_SCORE     005F
0373: WaitForBootComplete F858   0376
1381: WaitForDiskComplete FB7F   1384
0118: WarmBoot        0000   0445 0447
0305: WarmBootEntry   F603   0446
0479: WarmBootErroMessage F8BB   0436
0430: WBOOT           F862   0306 0438
0486: WBOOTControl    F8D5   0432
0039: WORD            0002
1143: WRITE           FA5E   0319
0198: WriteAllocated  0000
0200: WriteCleanBuffer 0002   1095 1150
0199: WriteDirectory  0001   1280
1315: WritePhysical   FB2A   1213 1289
1463: WriteType       FBA2   1096 1148 1279
0043: ZERO            0000
