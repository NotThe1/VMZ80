0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018 12-11 Adjusted BOOT & WBOOT
0006: F600         ; 2018-12-10 Refactored  character device routines;
0007: F600         ; 2017-03-31 Added List out functionality for List Device
0008: F600         ; 2017-03-02 Refactored the CP/M Suite
0009: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0010: F600         ; 2014-01-16
0011: F600         ; 2014-03-14  :  Frank Martyn
0012: F600
0013: F600                        Include ./stdHeader.Z80
0014: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0015: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0016: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0017: F600         ; stdHeader.asm
0018: F600         ; standard equates
0019: F600
0020: F600         ; 2017-03-02 Refactored the CP/M Suite
0021: F600
0022: F600
0023: F600             TRUE       EQU    -1                   ; not false
0024: F600             FALSE      EQU    0000H
0025: F600             ON         EQU    -1
0026: F600             OFF        EQU    0000H
0027: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0028: F600
0029: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0030: F600             WORD       EQU    2                    ; number of bytes for "word" type
0031: F600
0032: F600
0033: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0034: F600             ZERO       EQU    00H                  ; Zero
0035: F600             EndOfMessage EQU    00H
0036: F600
0037: F600             CTRL_C     EQU    03H                  ; ETX
0038: F600             CTRL_E     EQU    05H                  ; physical eol
0039: F600             CTRL_H     EQU    08H                  ; backspace
0040: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0041: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0042: F600             CTRL_P     EQU    10H                  ; prnt toggle
0043: F600             CTRL_R     EQU    12H                  ; repeat line
0044: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0045: F600             CTRL_U     EQU    15H                  ; line delete
0046: F600             CTRL_X     EQU    18H                  ; =ctl-u
0047: F600             CTRL_Z     EQU    1AH                  ; end of file
0048: F600
0049: F600             NULL       EQU    00H                  ; Null
0050: F600             SOH        EQU    01H                  ; Start of Heading
0051: F600             BELL       EQU    07H                  ; Bell
0052: F600             TAB        EQU    09H                  ; Tab
0053: F600             LF         EQU    0AH                  ; Line Feed
0054: F600             CR         EQU    0DH                  ; Carriage Return
0055: F600             SPACE      EQU    20H                  ; Space
0056: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0057: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0058: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0059: F600             PERCENT    EQU    25H                  ; Percent Sign
0060: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0061: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0062: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0063: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0064: F600             COMMA      EQU    2CH                  ; Comma
0065: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0066: F600             PERIOD     EQU    2EH                  ; Period
0067: F600             SLASH      EQU    2FH                  ; /
0068: F600             ASCII_ZERO EQU    30H                  ; zero
0069: F600             COLON      EQU    3AH                  ; Colon
0070: F600
0071: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0072: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0073: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0074: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0075: F600             QMARK      EQU    3FH                  ; Question Mark
0076: F600             UNDER_SCORE EQU    5FH                  ; under score _
0077: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0078: F600             RUBOUT     EQU    7FH                  ; Delete Key
0079: F600
0080: F600
0081: F600             ASCII_A    EQU    'A'
0082: F600             ASCII_C    EQU    'C'
0083: F600             ASCII_K    EQU    'K'
0084: F600             ASCII_N    EQU    'N'
0085: F600             ASCII_Q    EQU    'Q'
0086: F600             ASCII_R    EQU    'R'
0087: F600             ASCII_W    EQU    'W'
0088: F600             ASCII_Y    EQU    'Y'
0089: F600             CARET      EQU    '^'
0090: F600             ASCII_LO_A EQU    'a'
0091: F600             ASCII_LO_K EQU    'k'
0092: F600             ASCII_LO_P EQU    'p'
0093: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0094: F600
0095: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0096: F600                        Include ./osHeader.Z80
0097: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0098: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0099: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0100: F600         ; osHeader.asm
0101: F600
0102: F600         ; 2017-03-02 Refactored the CP/M Suite
0103: F600
0104: F600         ; Contains the Equates used by the CP/M system
0105: F600
0106: F600         ;------------------------Page Zero Constants ---------------------------------
0107: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0108: F600
0109: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0110: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0111: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0112: F600
0113: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0114: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0115: F600
0116: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0117: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0118: F600
0119: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0120: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0121: F600
0122: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0123: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0124: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0125: F600         ;-----------------------------------------------------------------------
0126: F600
0127: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0128: F600         ;-----------------------------------------------------------------------
0129: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0130: F600         ;-----------------------------------------------------------------------
0131: F600             END_OF_FILE EQU    1AH                  ; end of file
0132: F600         ;-----------------------------------------------------------------------
0133: F600
0134: F600         ;--------------- CP/M Constants -----------------------------------------
0135: F600
0136: F600             CCPLength  EQU    0800H                ; Constant
0137: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0138: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0139: F600
0140: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0141: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0142: F600
0143: F600             MemorySize EQU    64
0144: F600
0145: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0146: F600
0147: F600             BDOSBase   EQU    CCPEntry + CCPLength
0148: F600             BDOSEntry  EQU    BDOSBase + 6
0149: F600
0150: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0151: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0152: F600         ;-----------------------------------------------------------------------
0153: F600
0154: F600         ;------------------- BDOS System Call Equates --------------------------
0155: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0156: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0157: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0158: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0159: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0160: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0161: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0162: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0163: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0164: F600             fCloseFile EQU    10H                  ; closef - Close File
0165: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0166: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0167: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0168: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0169: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0170: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0171: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0172: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0173: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0174: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0175: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0176: F600         ;-----------------------------------------------------------------------
0177: F600
0178: F600
0179: F600
0180: F600
0181: F600
0182: F600         ;*******************************************************************************
0183: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0184: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0185: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0186: F600         ; sector write) or to an allocation block that has already been allocated to a
0187: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0188: F600         ;*******************************************************************************
0189: F600             WriteAllocated EQU    00H
0190: F600             WriteDirectory EQU    01H
0191: F600             WriteUnallocated EQU    02H
0192: F600
0193: F600
0194: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0195: F600                        Include ./diskHeader.Z80
0196: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0197: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0198: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0199: F600         ; diskHeader.asm
0200: F600
0201: F600         ; 2017-03-02 Refactored the CP/M Suite
0202: F600
0203: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0204: F600
0205: F600         ; Contains the Equates used by the CP/M system to handle disks
0206: F600
0207: F600
0208: F600         ;*******************************************************************************
0209: F600         ;
0210: F600         ;     Disk related values
0211: F600         ;
0212: F600         ;
0213: F600         ;*******************************************************************************
0214: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0215: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0216: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0217: F600         ; for boot
0218: F600             DiskControlTable EQU    0040H
0219: F600
0220: F600             DiskReadCode EQU    01H                  ; Code for Read
0221: F600             DiskWriteCode EQU    02H                  ; Code for Write
0222: F600
0223: F600
0224: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0225: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0226: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0227: F600
0228: F600             DirEntrySize EQU    20H                  ; (32)
0229: F600             DirBuffSize EQU    cpmRecordSize
0230: F600
0231: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0232: F600
0233: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0234: F600
0235: F600
0236: F600         ;-------------------------------------------------------------------------------------
0237: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0238: F600
0239: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0240: F600             NumberOfHeads EQU    02H                  ; number of heads
0241: F600             TracksPerHead EQU    50H                  ; 80
0242: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0243: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0244: F600             DirectoryBlockCount EQU    02H                  ;
0245: F600         ;-----------------------------------------------------------------------
0246: F600
0247: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0248: F600
0249: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0250: F600
0251: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0252: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0253: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0254: F600
0255: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0256: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0257: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0258: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0259: F600
0260: F600         ;-----------------------------------------------------------------------
0261: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0262: F600         ;-----------------------------------------------------------------------
0263: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0264: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0265: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0266: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0267: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0268: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0269: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0270: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0271: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0272: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0273: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0274: F600             dpb3hdNOH  EQU    NumberOfHeads
0275: F600
0276: F600         ;*******************************************************************************
0277: F600
0278: F600             SectorMask EQU    SectorsPerBlock - 1
0279: F600
0280: F600         ;***************************************************************************
0281: F600
0282: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0283: F600
0284: F600
0285: F600             IN_OPCODE  EQU    0DBH
0286: F600             OUT_OPCODE EQU    0D3H
0287: F600             JP_OPCODE  EQU    0C3H
0288: F600
0289: F600
0290: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0291: F600         ; BIOS jump Vector
0292: F600             CodeStart:
0293: F600
0294: F600 C3 40 F8               JP     BOOT                 ; 00  Not Yet Checked
0295: F603             WarmBootEntry:
0296: F603 C3 DD F8               JP     WBOOT                ; 01 Not Yet Checked
0297: F606 C3 20 F9               JP     CONST                ; 02 Checked
0298: F609 C3 32 F9               JP     CONIN                ; 03 Checked
0299: F60C C3 3E F9               JP     CONOUT               ; 04 Checked
0300: F60F C3 54 F9               JP     LIST                 ; 05 Checked
0301: F612 C3 5F F9               JP     PUNCH                ; 06 Not Yet Checked *
0302: F615 C3 6C F9               JP     READER               ; 07 Not Yet Checked *
0303: F618 C3 31 FA               JP     HOME                 ; 08 Checked
0304: F61B C3 41 FA               JP     SELDSK               ; 09 Checked
0305: F61E C3 68 FA               JP     SETTRK               ; 0A Checked
0306: F621 C3 6E FA               JP     SETSEC               ; 0B Checked
0307: F624 C3 73 FA               JP     SETDMA               ; 0C Checked
0308: F627 C3 7C FA               JP     READ                 ; 0D Not Yet Checked
0309: F62A C3 8F FA               JP     WRITE                ; 0E Not Yet Checked
0310: F62D C3 81 F9               JP     LISTST               ; 0F Not Yet Checked *
0311: F630 C3 79 FA               JP     SECTRAN              ; 10 Checked
0312: F633
0313: F633         ;-------------------------------------------------
0314: F633                        ORG    (($+10H)/10H) * 10H
0315: F640
0316: F640             DiskBuffer:
0317: F640                        DS     diskSectorSize
0318: F840             AfterDiskBuffer EQU    $
0319: F840         ;-------------------------------------------------
0320: F840
0321: F840
0322: F840
0323: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0324: F840
0325: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0326: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0327: F840         ;---------------------------------------------------------------------------
0328: F840         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot
0329: F840
0330: F840         ;  The BOOT jump instruction is the first instruction executed in CP/M. The
0331: F840         ; bootstrap sequence must transfer control to the BOOT entry point in order to
0332: F840         ; bring up CP/M.
0333: F840         ;  This reads in the CP/M loader on the first sector of the physical disk drive
0334: F840         ; chosen to be logical disk A. This CP/M loader program reads the binary image
0335: F840         ; of the CCP, BOOS, and BIOS into memory at some predetermined address.
0336: F840         ; Then it transfers control to the BOOT entry point in the BIOS jump vector.
0337: F840         ;  This BOOT routine must initialize all of the required computer hardware.
0338: F840         ;
0339: F840         ; Most BOOT routines sign on by displaying a short message on the console,
0340: F840         ; indicating the current version ofCP/M and the computer hardware that this BIOS
0341: F840         ; can support. The BOOT routine terminates by transferring control to the start of the CCP
0342: F840         ; +6 bytes (the CCP has its own smalljump vector at the beginning). Just before the
0343: F840         ; BOOT routine jumps into the CCP, it sets the C register to 0 to indicate that logical
0344: F840         ; disk A is to be the default disk drive. This is what causes "A>" to be the CCP's
0345: F840         ; initial prompt.
0346: F840
0347: F840             BOOT:
0348: F840 21 63 F8               LD     HL,BootMessage
0349: F843 CD D2 F8               CALL   DisplayMessage
0350: F846
0351: F846 21 56 F8               LD     HL,BOOTControl
0352: F849 CD C0 F8               CALL   RawDiskRead
0353: F84C
0354: F84C C3 DD F8               JP     WBOOT                ; do Warm boot if no errors
0355: F84F 21 90 F8               LD     HL,BadBootMessage
0356: F852 CD D2 F8               CALL   DisplayMessage       ; Show Boot failure message
0357: F855 76                     HALT
0358: F856
0359: F856             BOOTControl:
0360: F856 01                     DB     DiskReadCode         ; Read function
0361: F857 00                     DB     00H                  ; unit number
0362: F858 00                     DB     00H                  ; head number
0363: F859 00                     DB     00H                  ; track number
0364: F85A 0D                     DB     0DH                  ; Starting sector number (13)
0365: F85B 00 0A                  DW     5 * 512              ; Number of bytes to read ( 0A00 All of BIOS)
0366: F85D 00 F6                  DW     BIOSStart            ; read into this address
0367: F85F 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0368: F861 40 00                  DW     DiskControlTable     ; pointer to next table- no linking
0369: F863
0370: F863
0371: F863         ;BOOTControl:
0372: F863         ; 	DB		DiskReadCode		; Read function
0373: F863         ; 	DB		00H					; unit number
0374: F863         ; 	DB		00H					; head number
0375: F863         ; 	DB		00H					; track number
0376: F863         ; 	DB		01H					; Starting sector number ()
0377: F863         ; 	DW		diskSectorSize		; Number of bytes to read ( 1 Sector)
0378: F863         ; 	DW		TPA					; read into this address
0379: F863         ; 	DW		DiskStatusLocation	; pointer to next block - no linking
0380: F863         ; 	DW		DiskControlTable	; pointer to next table- no linking
0381: F863
0382: F863         ; Boot Messages and routine
0383: F863             BootMessage:
0384: F863         ;	DB		'CP/M 2.2 (Z80) '
0385: F863         ;	DB		'BootStrap Loader'
0386: F863         ;	DB		CR,LF
0387: F863 42 75 69 6C 64 20 30 2E 41 20                DB     'Build 0.A '
0388: F86D 0D 0A                  DB     CR,LF
0389: F86F 43 43 50 20 30 2E 41 20 7C 20 20 42 44 4F 53 20 30 2E 41 20 7C 20 42 49 4F 53 20 30 2E 42                DB     'CCP 0.A |  BDOS 0.A | BIOS 0.B'
0390: F88D 0D 0A 00                DB     CR,LF,EndOfMessage
0391: F890             BadBootMessage:
0392: F890 0D 0A                  DB     CR,LF
0393: F892 2A 2A 2A 2A 20 20 20 42 6F 6F 74 20 46 61 69 6C 75 72 65                DB     '****   Boot Failure'
0394: F8A5 00                     DB     EndOfMessage
0395: F8A6             WarmBootErroMessage:
0396: F8A6 0D 0A                  DB     CR,LF
0397: F8A8 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'
0398: F8B3 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'
0399: F8BD 0D 0A 00                DB     CR,LF,EndOfMessage
0400: F8C0         ;..................Boot Support....................
0401: F8C0
0402: F8C0         ; Entered with DiskControlBlock pointer in HL
0403: F8C0             RawDiskRead:
0404: F8C0 22 46 00               LD     (DiskCommandBlock),HL
0405: F8C3
0406: F8C3 21 45 00               LD     HL,DiskControlByte
0407: F8C6 36 80                  LD     (HL),080H
0408: F8C8
0409: F8C8         ; wait for the read to complete
0410: F8C8             WaitForReadDone:
0411: F8C8 7E                     LD     A,(HL)
0412: F8C9 B7                     OR     A
0413: F8CA 20 FC                  JR     NZ,WaitForReadDone
0414: F8CC
0415: F8CC         ; is it a clean read ?
0416: F8CC 3A 43 00               LD     A,(DiskStatusLocation)
0417: F8CF FE 80                  CP     080H                 ; any errors NC = good read?
0418: F8D1 C9                     RET
0419: F8D2
0420: F8D2         ; entered with pointer to message in HL
0421: F8D2             DisplayMessage:
0422: F8D2 7E                     LD     A,M                  ; get  character
0423: F8D3 B7                     OR     A                    ; is it NULL
0424: F8D4 C8                     RET    Z                    ; return if it is NULL (00)
0425: F8D5 4F                     LD     C,A
0426: F8D6 E5                     PUSH   HL                   ; save the pointer
0427: F8D7 D3 EC                  OUT    TTY_DataPort
0428: F8D9 E1                     POP    HL                   ; retrieve the pointer
0429: F8DA 23                     INC    HL                   ; point at next character
0430: F8DB 18 F5                  JR     DisplayMessage
0431: F8DD
0432: F8DD         ;....................................................
0433: F8DD
0434: F8DD         ;---------------------------------------------------------------------------
0435: F8DD         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot
0436: F8DD         ;
0437: F8DD         ;  Unlike the "cold" bootstrap entry point, which executes only once, the WBOOT
0438: F8DD         ; or warm boot routine will be executed every time a program terminates by
0439: F8DD         ; jumping to location OOOOH, or whenever you type a CONTROL-C on the console as
0440: F8DD         ; the first character of an input line.
0441: F8DD         ;  The WBOOT routine is responsible for reloading the CCP into memory.
0442: F8DD         ; Programs often use all of memory up to the starting point of the BDOS, overwriting
0443: F8DD         ; the CCP in the process. The underlying philosophy is that while a program is
0444: F8DD         ; executing, the CCP is not needed, so the program can use the memory previously
0445: F8DD         ; occupied by the CCP. The CCP occupies 800H (2048) bytes ofmemory-and this
0446: F8DD         ; is frequently just enough to make the difference between a program that cannot
0447: F8DD         ; run and one that can.
0448: F8DD         ; A few programs that are self-contained and do not require the BDOS's
0449: F8DD         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes of
0450: F8DD         ; memory. Therefore, to be really safe, the WBOOT routine should read in both the
0451: F8DD         ; CCP and the BDOS. It also needs to set up the two JMPs at location OOOOH (to
0452: F8DD         ; WBOOT itself) and at location 0005H (to the BOOS). Location 0003H should be
0453: F8DD         ; set to the initial value of the 10BYTE if this is implemented in the BIOS.
0454: F8DD         ; As its last act, the WBOOT routine sets register C to indicate which logical disk
0455: F8DD         ; is to be selected (C= 0 for A, I for B, and so on). It then transfers control into the
0456: F8DD         ; CCP at the first instruction in order to restart the CCP.
0457: F8DD
0458: F8DD             WBOOT:
0459: F8DD 31 FF DF               LD     SP,CCPEntry-1        ; put stack at top of User area
0460: F8E0 21 13 F9               LD     HL,WBOOTControl      ; get the WBOOT Control Block
0461: F8E3 CD C0 F8               CALL   RawDiskRead          ; read CCP & BDOS
0462: F8E6 30 09                  JR     NC,LoadPage0         ; set up page 0 if good read
0463: F8E8
0464: F8E8 21 A6 F8               LD     HL,WarmBootErroMessage
0465: F8EB CD D2 F8               CALL   DisplayMessage       ; send bad warm boot message
0466: F8EE C3 DD F8               JP     WBOOT                ; keep trying
0467: F8F1
0468: F8F1
0469: F8F1         ; Set up page Zero
0470: F8F1             LoadPage0:
0471: F8F1 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0472: F8F3
0473: F8F3 32 00 00               LD     (WarmBoot),A
0474: F8F6 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0475: F8F9 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0476: F8FC
0477: F8FC 32 05 00               LD     (BDOSE),A
0478: F8FF 21 06 E8               LD     HL,BDOSEntry         ; BDOS entry point
0479: F902 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0480: F905
0481: F905 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0482: F908 CD 73 FA               CALL   SETDMA               ; use normal BDOS  routine
0483: F90B FB                     EI                          ; Enable interrupts
0484: F90C
0485: F90C 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0486: F90F 4F                     LD     C,A
0487: F910 C3 00 E0               JP     CCPEntry             ; transfer control to CCP
0488: F913
0489: F913
0490: F913             WBOOTControl:
0491: F913 01                     DB     DiskReadCode         ; Read function
0492: F914 00                     DB     00H                  ; unit number
0493: F915 00                     DB     00H                  ; head number
0494: F916 00                     DB     00H                  ; track number
0495: F917 02                     DB     02H                  ; Starting sector number (skip cold boot sector)
0496: F918 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read ( rest of the head)
0497: F91A 00 E0                  DW     CCPEntry             ; read into this address
0498: F91C 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0499: F91E 45 00                  DW     DiskControlByte      ; pointer to next table- no linking
0500: F920
0501: F920         ;---------------------------------------------------------------------------
0502: F920         ;	Console Status:		BIOS 02
0503: F920         ;
0504: F920         ;  CONST simply returns an indicator showing whether there is an incoming
0505: F920         ; character from the console device. The convention is that A = OFFH if a character
0506: F920         ; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
0507: F920         ; to reflect the contents of the A register - it is the contents that are important.
0508: F920         ; CONST is called by the CCP whenever the CCP is in the middle of an
0509: F920         ; operation that can be interrupted by pressing a keyboard character.
0510: F920         ;
0511: F920         ; The BDOS will call CONST if a program makes a Read Console Status
0512: F920         ; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
0513: F920         ; routine, CONIN
0514: F920
0515: F920             CONST:
0516: F920             ConStatus:
0517: F920 3A 03 00               LD     A,(IOBYTE)
0518: F923 DD 21 11 FA               LD     IX,CON_Vector
0519: F927
0520: F927             GenericInStatus:                      ; Entry point for generic input status
0521: F927 CD CD F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0522: F92A CD 9A F9               CALL   GetInStatus
0523: F92D B7                     OR     A
0524: F92E C8                     RET    Z                    ; 00 => No data pending
0525: F92F 3E FF                  LD     A,0FFH
0526: F931 C9                     RET                         ; OFFH => Data in Buffer
0527: F932         ;---------------------------------------------------------------------
0528: F932         ;	Console In:		BIOS 03
0529: F932         ;  CONIN reads the next character from the console to the A register and sets the
0530: F932         ; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
0531: F932         ; until it detects A = OFFH. Only then will it input the data character and mask off
0532: F932         ; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
0533: F932         ; Read Console Byte function (B$CONIN, code 1).
0534: F932         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0535: F932
0536: F932         ; This is a blocking routine
0537: F932             CONIN:
0538: F932             ConIn:
0539: F932 CD 20 F9               CALL   ConStatus
0540: F935 28 FB                  JR     Z,ConIn              ; loop until there is some data to read
0541: F937         ; Call to ConStatus Sets up IX with Physical Table
0542: F937 DD 6E 06               LD     L,(IX+DataReadIndex)
0543: F93A DD 66 07               LD     H,(IX+(DataReadIndex+1))
0544: F93D E9                     JP     (HL)
0545: F93E         ;---------------------------------------------------------------------------
0546: F93E         ;	Console Out:		BIOS 04
0547: F93E         ;  CONOUT outputs the character (in ASCII) in register C to the console. The
0548: F93E         ; most significant (parity) bit of the character will always be O.
0549: F93E         ; CONOUT must first check that the console device is ready to receive more
0550: F93E         ; data, delaying if necessary until it is, and only then sending the character to the
0551: F93E         ; device. CONOUT is called by the CCP and by the BDOS when a program executes a
0552: F93E         ; Write Console Byte function (B$CONOUT, code 2).
0553: F93E
0554: F93E         ; This is a blocking routine
0555: F93E             CONOUT:
0556: F93E             CONOut:
0557: F93E 3A 03 00               LD     A,(IOBYTE)
0558: F941 DD 21 11 FA               LD     IX,CON_Vector
0559: F945
0560: F945             GenericOutStatus:                      ; entry point for standard blocking write
0561: F945 CD CD F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0562: F948             GenericOutStatus1:
0563: F948 CD 95 F9               CALL   GetOutStatus
0564: F94B 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0565: F94D DD 6E 08               LD     L,(IX+DataWriteIndex)
0566: F950 DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0567: F953 E9                     JP     (HL)
0568: F954
0569: F954         ;---------------------------------------------------------------------------
0570: F954         ;	List output  BIOS 05
0571: F954         ; LIST is similar to CONOUT except that it sends the character in register C to
0572: F954         ; the list device. It too checks first that the list device is ready to receive
0573: F954         ; the character. LIST is called by the CCP in response to the CONTROL-P toggle
0574: F954         ; for printer echo of console output, and by the BDOS when a program makes a
0575: F954         ; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).
0576: F954
0577: F954         ; This is a blocking routine
0578: F954
0579: F954             LIST:
0580: F954 3A 03 00               LD     A,(IOBYTE)
0581: F957 07                     RLCA                        ; move bits 7,6
0582: F958 07                     RLCA                        ; to 1,0
0583: F959 DD 21 29 FA               LD     IX,LST_Vector
0584: F95D 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0585: F95F
0586: F95F         ;---------------------------------------------------------------------------
0587: F95F         ;	Punch output  BIOS 06
0588: F95F         ;  PUNCH sends the character in register C to the "punch" device. As mentioned
0589: F95F         ; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
0590: F95F         ; entry point either returns immediately and is effectively a null routine, or it outputs
0591: F95F         ; the character to a communications device, such as a modem, on your computer.
0592: F95F         ; PUNCH must check that the "punch" device is indeed ready to accept another
0593: F95F         ; character for output, and must wait if it is not.
0594: F95F         ;
0595: F95F         ; Digital Research's documentation states that the character to be output will
0596: F95F         ; always have its most significant bit set to O. This is not true. The BDOS simply
0597: F95F         ; transfers control over to the PUNCH entry point in the BIOS; the setting of the
0598: F95F         ; most significant bit will be determined by the program making the BDOS function
0599: F95F         ; request (B$PUNOUT, code 4). This is important because the requirement of a zero
0600: F95F         ; would preclude being able to send pure binary data via the BIOS PUNCH
0601: F95F         ; function
0602: F95F
0603: F95F         ; This is a blocking routine
0604: F95F
0605: F95F             PUNCH:                          ; Punch output
0606: F95F 3A 03 00               LD     A,(IOBYTE)
0607: F962 0F                     RRCA
0608: F963 0F                     RRCA
0609: F964 0F                     RRCA                        ; move bits 5,4
0610: F965 0F                     RRCA                        ; to 1,0
0611: F966 DD 21 21 FA               LD     IX,PUN_Vector
0612: F96A 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0613: F96C
0614: F96C         ;---------------------------------------------------------------------------
0615: F96C         ;	Reader input  BIOS 07	-
0616: F96C         ; As with the PUNCH entry point, the READER entry point rarely connects to
0617: F96C         ; a real paper tape reader.
0618: F96C         ; The READER function must return the next character from the reader device
0619: F96C         ; in the A register, waiting, if need be, until there is a character.
0620: F96C         ;
0621: F96C         ; Digital Research's documentation again says that the most significant bit of
0622: F96C         ; the A register must be 0, but this is not the case if you wish to receive pure binary
0623: F96C         ; information via this function.
0624: F96C         ; READER is called whenever a program makes a Read "Reader" Byte function
0625: F96C         ; request (B$READIN, code 3).
0626: F96C
0627: F96C         ; This is a blocking routine
0628: F96C
0629: F96C             READER:                         ; Reader Input
0630: F96C 3A 03 00               LD     A,(IOBYTE)
0631: F96F 0F                     RRCA
0632: F970 0F                     RRCA                        ; move bits 3,2  to 1,0
0633: F971 DD 21 19 FA               LD     IX,RDR_Vector
0634: F975             READER1:
0635: F975 CD 27 F9               CALL   GenericInStatus
0636: F978 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0637: F97A
0638: F97A DD 6E 06               LD     L,(IX+DataReadIndex)
0639: F97D DD 66 07               LD     H,(IX+(DataReadIndex+1))
0640: F980 E9                     JP     (HL)
0641: F981
0642: F981
0643: F981         ;---------------------------------------------------------------------------
0644: F981         ;	List Status:  BIOS 0F
0645: F981
0646: F981         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0647: F981         ; This function returns the current status of the list device, using the IOBYTE if
0648: F981         ; necessary to select the correct physical device. It sets the A register to OFFH if the
0649: F981         ; list device can accept another character for output or to OOH if it is not ready.
0650: F981         ; Digital Research's documentation states that this function is used by the
0651: F981         ; DESPOOL utility program (which allows you to print a file "simultaneously" with
0652: F981         ; other operations) to improve console response during its operation, and that it is
0653: F981         ; acceptable for the routine always to return OOH if you choose not to implement it
0654: F981         ; fully.
0655: F981         ; Unfortunately, this statement is wrong. Many other programs use the LISTST
0656: F981         ; function to "poll" the list device to make sure it is ready, and if it fails to come
0657: F981         ; ready after a predetermined time, to output a message to the console indicating
0658: F981         ; that the printer is not ready. If you ever make a call to the BDOS list output
0659: F981         ; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0660: F981         ; not ready, then CP/M will wait forever-and your program will have lost control
0661: F981         ; so it cannot even detect that the problem has occurred. If LISTST always returns a
0662: F981         ; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
0663: F981         ; out of the LISTST function, but it also causes a stream of false "Printer
0664: F981         ; not Ready" error messages to appear on the console.
0665: F981         ;
0666: F981             LISTST:
0667: F981 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0668: F984 07                     RLCA
0669: F985 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0670: F986 DD 21 29 FA               LD     IX,LST_Vector        ; Set th vector base
0671: F98A CD CD F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0672: F98D CD 95 F9               CALL   GetOutStatus
0673: F990
0674: F990 B7                     OR     A
0675: F991 C8                     RET    Z                    ; 00 => Device Ready
0676: F992 3E FF                  LD     A,0FFH
0677: F994 C9                     RET                         ; OFFH => Device No Ready
0678: F995
0679: F995         ;---------------------------------------------------------------------------
0680: F995
0681: F995         ;---------------------------------------------------------------------
0682: F995             GetOutStatus:
0683: F995         ; vector to CON Devices
0684: F995 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0685: F998 18 03                  JR     GetStatus
0686: F99A             GetInStatus:
0687: F99A DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0688: F99D             GetStatus:
0689: F99D DD 6E 04               LD     L,(IX+StatusReadIndex)
0690: F9A0 DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0691: F9A3 E9                     JP     (HL)                 ; jump to the stats read routine
0692: F9A4
0693: F9A4         ;---------------------------------------------------------------------
0694: F9A4
0695: F9A4             DataRead:
0696: F9A4 DD 7E 01               LD     A,(IX+DataPortIndex)
0697: F9A7 32 AB F9               LD     (AddressDataIn),A    ; modify code with the Data port
0698: F9AA DB                     DB     IN_OPCODE
0699: F9AB             AddressDataIn:
0700: F9AB 00                     DB     00                   ; perform the read
0701: F9AC C9                     RET
0702: F9AD
0703: F9AD             DataReadASCII:
0704: F9AD CD A4 F9               CALL   DataRead
0705: F9B0 E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0706: F9B2 C9                     RET                         ; AND		ASCII_MASK
0707: F9B3
0708: F9B3         ; Enter DataWrite the value to be output in C
0709: F9B3             DataWrite:
0710: F9B3 DD 7E 01               LD     A,(IX+DataPortIndex)
0711: F9B6 32 BB F9               LD     (AddressDataOut),A   ; modify code with the Data port
0712: F9B9 79                     LD     A,C                  ; get value into ACC
0713: F9BA D3                     DB     OUT_OPCODE
0714: F9BB             AddressDataOut:
0715: F9BB 00                     DB     00                   ; perform the write
0716: F9BC C9                     RET
0717: F9BD
0718: F9BD
0719: F9BD         ; Enter Status Read with Target mask in D
0720: F9BD             StatusRead:
0721: F9BD DD 7E 00               LD     A,(IX+StatusPortIndex)
0722: F9C0 32 C4 F9               LD     (AddressStatus),A    ; modify code with the status port
0723: F9C3 DB                     DB     IN_OPCODE
0724: F9C4             AddressStatus:
0725: F9C4 00                     DB     00
0726: F9C5 A2                     AND    D                    ; Check return vale with the mask
0727: F9C6 C9                     RET
0728: F9C7
0729: F9C7             DUMMYRead:
0730: F9C7 C9                     RET
0731: F9C8             DUMMYWrite:
0732: F9C8 C9                     RET
0733: F9C9             DUMMYCheck:
0734: F9C9 3E FF                  LD     A,0FFH               ; Always return 0FFH
0735: F9CB B7                     OR     A                    ; Set flags
0736: F9CC C9                     RET
0737: F9CD
0738: F9CD         ;=============================================================================
0739: F9CD             SetDeviceVector:
0740: F9CD E6 03                  AND    03H                  ; Get bits 0 & 1;
0741: F9CF 87                     ADD    A,A                  ; Double for word size index
0742: F9D0 16 00                  LD     D,00H
0743: F9D2 5F                     LD     E,A                  ; load byte index int DE
0744: F9D3 DD 19                  ADD    IX,DE                ; add to the value vector base
0745: F9D5         ; IX points at correct entry in vector
0746: F9D5 DD 5E 00               LD     E,(IX+0)
0747: F9D8 DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0748: F9DB D5                     PUSH   DE
0749: F9DC DD E1                  POP    IX                   ; Move it to IX
0750: F9DE C9                     RET
0751: F9DF
0752: F9DF
0753: F9DF         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0754: F9DF         ; Physical Device Attributes
0755: F9DF
0756: F9DF             TTY_StatusPort EQU    0EDH
0757: F9DF             TTY_DataPort EQU    0ECH
0758: F9DF             TTY_OutputMask EQU    80H                  ; Status Mask
0759: F9DF             TTY_InputMask EQU    7FH                  ; Status Mask
0760: F9DF
0761: F9DF             CRT_StatusPort EQU    02H
0762: F9DF             CRT_DataPort EQU    01H
0763: F9DF             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0764: F9DF             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0765: F9DF
0766: F9DF             COM_StatusPort EQU    0EDH
0767: F9DF             COM_DataPort EQU    0ECH
0768: F9DF             COM_OutputMask EQU    01H                  ; Status Mask
0769: F9DF             COM_InputMask EQU    02H                  ; Status Mask
0770: F9DF
0771: F9DF             LPT_StatusPort EQU    011H
0772: F9DF             LPT_DataPort EQU    010H
0773: F9DF             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0774: F9DF             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0775: F9DF
0776: F9DF             DUMMY_StatusPort EQU    011H
0777: F9DF             DUMMY_DataPort EQU    010H
0778: F9DF             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0779: F9DF             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0780: F9DF
0781: F9DF         ; Device Table Control Block Definition
0782: F9DF             StatusPortIndex EQU    0
0783: F9DF             DataPortIndex EQU    1
0784: F9DF             OutputMaskIndex EQU    2
0785: F9DF             InputMaskIndex EQU    3
0786: F9DF             StatusReadIndex EQU    4
0787: F9DF             DataReadIndex EQU    6
0788: F9DF             DataWriteIndex EQU    8
0789: F9DF
0790: F9DF         ;Physical Devices Control Blocks
0791: F9DF
0792: F9DF             TTY_Table:
0793: F9DF ED                     DB     TTY_StatusPort
0794: F9E0 EC                     DB     TTY_DataPort
0795: F9E1 80                     DB     TTY_OutputMask
0796: F9E2 7F                     DB     TTY_InputMask
0797: F9E3 BD F9                  DW     StatusRead
0798: F9E5 AD F9                  DW     DataReadASCII
0799: F9E7 B3 F9                  DW     DataWrite
0800: F9E9
0801: F9E9             CRT_Table:
0802: F9E9 02                     DB     CRT_StatusPort
0803: F9EA 01                     DB     CRT_DataPort
0804: F9EB 80                     DB     CRT_OutputMask
0805: F9EC 7F                     DB     CRT_InputMask
0806: F9ED BD F9                  DW     StatusRead
0807: F9EF A4 F9                  DW     DataRead
0808: F9F1 B3 F9                  DW     DataWrite
0809: F9F3             COM_Table:
0810: F9F3 ED                     DB     COM_StatusPort
0811: F9F4 EC                     DB     COM_DataPort
0812: F9F5 01                     DB     COM_OutputMask
0813: F9F6 02                     DB     COM_InputMask
0814: F9F7 BD F9                  DW     StatusRead
0815: F9F9 A4 F9                  DW     DataRead
0816: F9FB B3 F9                  DW     DataWrite
0817: F9FD             LPT_Table:
0818: F9FD 11                     DB     LPT_StatusPort
0819: F9FE 10                     DB     LPT_DataPort
0820: F9FF FF                     DB     LPT_OutputMask
0821: FA00 7F                     DB     LPT_InputMask
0822: FA01 BD F9                  DW     StatusRead
0823: FA03 A4 F9                  DW     DataRead
0824: FA05 B3 F9                  DW     DataWrite
0825: FA07             DUMMY_Table:
0826: FA07 11                     DB     DUMMY_StatusPort
0827: FA08 10                     DB     DUMMY_DataPort
0828: FA09 FF                     DB     DUMMY_OutputMask
0829: FA0A 7F                     DB     DUMMY_InputMask
0830: FA0B C9 F9                  DW     DUMMYCheck
0831: FA0D C7 F9                  DW     DUMMYRead
0832: FA0F C8 F9                  DW     DUMMYWrite
0833: FA11
0834: FA11         ;---------------------------------------------------------------------------
0835: FA11
0836: FA11         ; Logical Device Vector, Controlled by IOBYTE
0837: FA11
0838: FA11             CON_Vector:                      ; IOBYTE bits 1 & 0
0839: FA11 DF F9                  DW     TTY_Table
0840: FA13 E9 F9                  DW     CRT_Table
0841: FA15 F3 F9                  DW     COM_Table
0842: FA17 07 FA                  DW     DUMMY_Table
0843: FA19             RDR_Vector:                      ; IOBYTE bits 3 & 2
0844: FA19 DF F9                  DW     TTY_Table
0845: FA1B E9 F9                  DW     CRT_Table
0846: FA1D 07 FA                  DW     DUMMY_Table
0847: FA1F 07 FA                  DW     DUMMY_Table
0848: FA21             PUN_Vector:                      ; IOBYTE bits 5 & 4
0849: FA21 DF F9                  DW     TTY_Table
0850: FA23 07 FA                  DW     DUMMY_Table
0851: FA25 F3 F9                  DW     COM_Table
0852: FA27 E9 F9                  DW     CRT_Table
0853: FA29             LST_Vector:                      ; IOBYTE bits 7 & 6
0854: FA29 FD F9                  DW     LPT_Table
0855: FA2B E9 F9                  DW     CRT_Table
0856: FA2D FD F9                  DW     LPT_Table
0857: FA2F 07 FA                  DW     DUMMY_Table
0858: FA31
0859: FA31         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0860: FA31         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0861: FA31
0862: FA31         ;-------------------------------------------------
0863: FA31         ;	Disk routines
0864: FA31         ;---------------------------------------------------------------------------
0865: FA31         ;**********************
0866: FA31         ;	Home Disk	BIOS 08
0867: FA31         ;HOME - Home the selected logical disk to track 0.
0868: FA31         ;	Before doing this, a check must be made to see if the
0869: FA31         ;	physical disk buffer has information that must be
0870: FA31         ;	written out. This is indicated by a flag, MustWriteBuffer,
0871: FA31         ;	set in the de-blocking code
0872: FA31         ;**********************
0873: FA31             HOME:
0874: FA31 3A 2F FC               LD     A,(MustWriteBuffer)  ; check flag
0875: FA34 B7                     OR     A
0876: FA35 C2 3B FA               JP     NZ,HomeNoWrite
0877: FA38 32 2E FC               LD     (DataInDiskBuffer),A ; no, so indicate empty buffer
0878: FA3B             HomeNoWrite:
0879: FA3B 0E 00                  LD     C,00H                ; Set to track 0
0880: FA3D CD 68 FA               CALL   SETTRK               ; no, physical, only logical
0881: FA40 C9                     RET
0882: FA41
0883: FA41         ;	Select Disk	BIOS 09
0884: FA41         ; Select disk in C. C=0 for A: 1 for B: etc.
0885: FA41         ; Return the address of the appropriate disk parameter header
0886: FA41         ; in HL, or 0000H if selected disk does not exist
0887: FA41         ;**********************
0888: FA41             SELDSK:
0889: FA41 21 00 00               LD     HL,00H               ; Assume an error
0890: FA44 79                     LD     A,C
0891: FA45 FE 04                  CP     NumberOfLogicalDisks
0892: FA47 D0                     RET    NC                   ; return if > max number of Disks
0893: FA48
0894: FA48 32 31 FC               LD     (SelectedDisk),A     ; save disk number
0895: FA4B 6F                     LD     L,A                  ; make disk into word number
0896: FA4C 26 00                  LD     H,0
0897: FA4E         ; Compute offset down disk parameter table by multiplying by parameter
0898: FA4E         ; header length (16 bytes)
0899: FA4E 29                     ADD    HL,HL
0900: FA4F 29                     ADD    HL,HL
0901: FA50 29                     ADD    HL,HL
0902: FA51 29                     ADD    HL,HL                ; pointing at right one
0903: FA52 11 40 FC               LD     DE,DiskParameterHeaders ; get DPH address
0904: FA55 19                     ADD    HL,DE                ; DE -> appropriate DPH
0905: FA56 E5                     PUSH   HL                   ; Save DPH pointer
0906: FA57 11 0A 00               LD     DE,10                ; DiskParameterBlock Index
0907: FA5A 19                     ADD    HL,DE                ; ????? -> cpmRecords per track
0908: FA5B 5E                     LD     E,(HL)
0909: FA5C 23                     INC    HL
0910: FA5D 56                     LD     D,(HL)               ; DE has Parameter Block for selected disk
0911: FA5E 21 0F 00               LD     HL,15                ; SectorsPerHead Index
0912: FA61 19                     ADD    HL,DE                ; HL is at SecPerHeadPerTrack
0913: FA62 7E                     LD     A,(HL)               ; get the value and
0914: FA63 32 30 FC               LD     (SelectedDskSecsPerHead),A ; save for actual IO
0915: FA66
0916: FA66 E1                     POP    HL                   ; recover DPH pointer
0917: FA67 C9                     RET
0918: FA68
0919: FA68         ;**********************
0920: FA68         ;	Set Track	BIOS 0A
0921: FA68         ;SETTRK - Set logical track for next read or write.	Track is in BC
0922: FA68         ;**********************
0923: FA68             SETTRK:
0924: FA68 60                     LD     H,B                  ; select track in BC on entry
0925: FA69 69                     LD     L,C
0926: FA6A 22 32 FC               LD     (SelectedTrack),HL   ; save for low level driver
0927: FA6D C9                     RET
0928: FA6E         ;**********************
0929: FA6E         ;	Set Sector	BIOS 0B
0930: FA6E         ;SETSEC - Set logical sector for next read or write. Sector is in C
0931: FA6E         ;**********************
0932: FA6E             SETSEC:
0933: FA6E 79                     LD     A,C
0934: FA6F 32 34 FC               LD     (SelectedSector),A   ; save for low level driver
0935: FA72 C9                     RET
0936: FA73         ;**********************
0937: FA73         ;	Set Sector	BIOS 0C
0938: FA73         ;SetDMA - Set DMA (input/output) address for next read or write. Address in BC
0939: FA73         ;**********************
0940: FA73             SETDMA:
0941: FA73 69                     LD     L,C                  ; select address in BC on entry
0942: FA74 60                     LD     H,B
0943: FA75 22 35 FC               LD     (DMAAddress),HL      ; save for low level driver
0944: FA78 C9                     RET
0945: FA79         ;**********************
0946: FA79         ;	Sector Translate	BIOS 10
0947: FA79         ;SECTRAN - Translate logical sector to physical
0948: FA79         ; on Entry:	BC= logical sector number DE-> appropriate skew table
0949: FA79         ; on Exit:	HL = physical sector number
0950: FA79         ;**********************
0951: FA79             SECTRAN:
0952: FA79 C5                     PUSH   BC
0953: FA7A E1                     POP    HL                   ; just move the value from BC to HL
0954: FA7B C9                     RET
0955: FA7C
0956: FA7C         ;************************************************************************************************
0957: FA7C         ;        READ	BIOS
0958: FA7C         ; Read in the  CP/M record specified by previous calls to select disk and to set track  and
0959: FA7C         ; sector. The sector will be read into the address specified in the previous call to set DMA address
0960: FA7C         ;
0961: FA7C         ;************************************************************************************************
0962: FA7C             READ:
0963: FA7C AF                     XOR    A                    ; set record count to 0
0964: FA7D 32 3C FC               LD     (UnalocatedlRecordCount),A
0965: FA80 3C                     INC    A
0966: FA81 32 3F FC               LD     (ReadFlag),A         ; Set to non zero to indicate that this is a read
0967: FA84 32 3E FC               LD     (PrereadSectorFlag),A ; force pre-read
0968: FA87 3E 02                  LD     A,WriteUnallocated   ; fake de-blocking code into responding as if this
0969: FA89 32 29 FC               LD     (WriteType),A        ; is the first write to an unallocated allocation block
0970: FA8C C3 E1 FA               JP     PerformReadWrite     ; use common code to execute read
0971: FA8F         ;----------------------------------------
0972: FA8F         ;************************************************************************************************
0973: FA8F         ;	WRITE
0974: FA8F         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
0975: FA8F         ;
0976: FA8F         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
0977: FA8F         ;	00H [WriteAllocated]	 An already allocated allocation block (which means a pre-read of the sector may be needed),
0978: FA8F         ;	01H [WriteDirectory]	 To the directory (in which case the data will be written to the disk immediately),
0979: FA8F         ;	02H	[WriteUnallocated]	 To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
0980: FA8F         ;
0981: FA8F         ; Only writes to the directory take place immediately.
0982: FA8F         ; In all other cases, the data will be moved from the DMA address into the disk buffer,
0983: FA8F         ; and only written out when circumstance force the transfer.
0984: FA8F         ; The number of physical disk operations can therefore be reduced considerably.
0985: FA8F         ;************************************************************************************************
0986: FA8F             WRITE:
0987: FA8F         ; Buffered I/O
0988: FA8F AF                     XOR    A
0989: FA90 32 3F FC               LD     (ReadFlag),A         ; Set to zero to indicate that this is not a read
0990: FA93 79                     LD     A,C
0991: FA94 32 29 FC               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
0992: FA97 FE 02                  CP     WriteUnallocated     ; first write to an unallocated allocation block ?
0993: FA99 C2 AA FA               JP     NZ,CheckUnallocatedBlock ; No, - in the middle of writing to an unallocated block ?
0994: FA9C         ; Yes, It is the first write to unallocated allocation block.
0995: FA9C         ; Initialize  variables associated with unallocated writes
0996: FA9C 3E 10                  LD     A,RecordsPerBlock    ; Number of records
0997: FA9E 32 3C FC               LD     (UnalocatedlRecordCount),A ; reset Unallocated Record Count to recordsPerBlock
0998: FAA1 21 31 FC               LD     HL,SelectedDkTrkSec
0999: FAA4 11 38 FC               LD     DE,UnallocatedDkTrkSec
1000: FAA7 CD A4 FB               CALL   MoveDkTrkSec         ; copy disk, track & sector into unallocated variables
1001: FAAA
1002: FAAA         ; Check if this is not the first write to an unallocated allocation block -- if it is,
1003: FAAA         ; the unallocated record count has just been set to the number of records in the allocation block
1004: FAAA             CheckUnallocatedBlock:
1005: FAAA 3A 3C FC               LD     A,(UnalocatedlRecordCount)
1006: FAAD B7                     OR     A
1007: FAAE CA D9 FA               JP     Z,RequestPreread     ; No - write to an unallocated block
1008: FAB1 3D                     DEC    A
1009: FAB2 32 3C FC               LD     (UnalocatedlRecordCount),A ; decrement records left
1010: FAB5
1011: FAB5 21 31 FC               LD     HL,SelectedDkTrkSec  ; same Disk, Track & sector as for those in an unallocated block
1012: FAB8 11 38 FC               LD     DE,UnallocatedDkTrkSec
1013: FABB CD 98 FB               CALL   CompareDkTrkSec      ; are they the same
1014: FABE C2 D9 FA               JP     NZ,RequestPreread    ; NO - do a pre-read
1015: FAC1 EB                     EX     DE,HL
1016: FAC2 34                     INC    M                    ; increment UnalocatedlRecordCount
1017: FAC3 7E                     LD     A,(HL)
1018: FAC4 FE 12                  CP     SectorsPerTrack      ; Sector > maximum on track ?
1019: FAC6 DA D2 FA               JP     C,NoTrackChange      ; No ( A < M)
1020: FAC9 36 00                  LD     (HL),00H             ; Yes
1021: FACB 2A 39 FC               LD     HL,(UnallocatedTrack)
1022: FACE 23                     INC    HL                   ; increment track
1023: FACF 22 39 FC               LD     (UnallocatedTrack),HL
1024: FAD2             NoTrackChange:
1025: FAD2 AF                     XOR    A
1026: FAD3 32 3E FC               LD     (PrereadSectorFlag),A ; clear flag
1027: FAD6 C3 E1 FA               JP     PerformReadWrite
1028: FAD9
1029: FAD9             RequestPreread:
1030: FAD9 AF                     XOR    A
1031: FADA 32 3C FC               LD     (UnalocatedlRecordCount),A ; not a write into an unallocated block
1032: FADD 3C                     INC    A
1033: FADE 32 3E FC               LD     (PrereadSectorFlag),A ; set flag
1034: FAE1         ;*******************************************************
1035: FAE1         ; Common code to execute both reads and writes of 128-byte records
1036: FAE1         ;*******************************************************
1037: FAE1             PerformReadWrite:
1038: FAE1 AF                     XOR    A                    ; Assume no disk error will occur
1039: FAE2 32 3D FC               LD     (DiskErrorFlag),A
1040: FAE5 3A 34 FC               LD     A,(SelectedSector)
1041: FAE8 1F                     RRA                         ; Convert selected record
1042: FAE9 1F                     RRA                         ; into physical sector by dividing by 4
1043: FAEA E6 3F                  AND    03FH                 ; remove unwanted bits
1044: FAEC 32 37 FC               LD     (SelectedPhysicalSector),A
1045: FAEF 21 2E FC               LD     HL,DataInDiskBuffer  ; see if there is any data here ?
1046: FAF2 7E                     LD     A,(HL)
1047: FAF3 36 01                  LD     (HL),001H            ; force there is data here for after the actual read
1048: FAF5 B7                     OR     A                    ; really is there any data here ?
1049: FAF6 CA 16 FB               JP     Z,ReadSectorIntoBuffer ; NO ?- go read into buffer
1050: FAF9         ;
1051: FAF9         ; The buffer does have a physical sector in it, Note: The disk, track, and PHYSICAL sector
1052: FAF9         ; in the buffer need to be checked, hence the use of the CompareDkTrk subroutine.
1053: FAF9 11 2A FC               LD     DE,InBufferDkTrkSec
1054: FAFC 21 31 FC               LD     HL,SelectedDkTrkSec  ; get the requested sector
1055: FAFF CD 93 FB               CALL   CompareDkTrk         ; is it in the buffer ?
1056: FB02 C2 0F FB               JP     NZ,SectorNotInBuffer ; NO,jump - it must be read
1057: FB05         ; Yes, it is in the buffer
1058: FB05 3A 2D FC               LD     A,(InBufferSector)   ; get the sector
1059: FB08 21 37 FC               LD     HL,SelectedPhysicalSector
1060: FB0B BE                     CP     M                    ; Check if correct physical sector
1061: FB0C CA 33 FB               JP     Z,SectorInBuffer     ; Yes - it is already in memory
1062: FB0F         ; No, it will have to be read in over current contents of buffer
1063: FB0F             SectorNotInBuffer:
1064: FB0F 3A 2F FC               LD     A,(MustWriteBuffer)
1065: FB12 B7                     OR     A                    ; do we need to write ?
1066: FB13 C4 AF FB               CALL   NZ,WritePhysical     ; if yes - write it out
1067: FB16
1068: FB16             ReadSectorIntoBuffer:
1069: FB16         ; indicate the  selected disk, track, and sector now residing in buffer
1070: FB16 3A 31 FC               LD     A,(SelectedDisk)
1071: FB19 32 2A FC               LD     (InBufferDisk),A
1072: FB1C 2A 32 FC               LD     HL,(SelectedTrack)
1073: FB1F 22 2B FC               LD     (InBufferTrack),HL
1074: FB22 3A 37 FC               LD     A,(SelectedPhysicalSector)
1075: FB25 32 2D FC               LD     (InBufferSector),A
1076: FB28
1077: FB28 3A 3E FC               LD     A,(PrereadSectorFlag) ; do we need to pre-read
1078: FB2B B7                     OR     A
1079: FB2C C4 B4 FB               CALL   NZ,ReadPhysical      ; yes - pre-read the sector
1080: FB2F
1081: FB2F         ; At this point the data is in the buffer.
1082: FB2F         ; Either it was already here, or we returned from ReadPhysical
1083: FB2F
1084: FB2F AF                     XOR    A                    ; reset the flag
1085: FB30 32 2F FC               LD     (MustWriteBuffer),A  ; and store it away
1086: FB33
1087: FB33         ; Selected sector on correct track and  disk is already 1n the buffer.
1088: FB33         ; Convert the selected cpmRecord into relative address down the buffer.
1089: FB33             SectorInBuffer:
1090: FB33 3A 34 FC               LD     A,(SelectedSector)
1091: FB36 E6 03                  AND    SectorMask           ; only want the least bits
1092: FB38 6F                     LD     L,A                  ; to calculate offset into 512 byte buffer
1093: FB39 26 00                  LD     H,00H                ; Multiply by 128 - cpmRecordSize
1094: FB3B 29                     ADD    HL,HL                ; *2
1095: FB3C 29                     ADD    HL,HL                ; *4
1096: FB3D 29                     ADD    HL,HL                ; *8
1097: FB3E 29                     ADD    HL,HL                ; *16
1098: FB3F 29                     ADD    HL,HL                ; *32
1099: FB40 29                     ADD    HL,HL                ; *64
1100: FB41 29                     ADD    HL,HL                ; *128
1101: FB42 11 40 F6               LD     DE,DiskBuffer
1102: FB45 19                     ADD    HL,DE                ; HL -> record number start address
1103: FB46 EB                     EX     DE,HL                ; DE -> sector in the disk buffer
1104: FB47 2A 35 FC               LD     HL,(DMAAddress)      ; Get DMA address (set in SETDMA)
1105: FB4A EB                     EX     DE,HL                ; assume a read so :
1106: FB4B         ; DE -> DMA Address & HL -> sector in disk buffer
1107: FB4B 0E 10                  LD     C,cpmRecordSize/8    ; 8 bytes per move (loop count)
1108: FB4D         ;
1109: FB4D         ;  At this point -
1110: FB4D         ;	C	->	loop count
1111: FB4D         ;	DE	->	DMA address
1112: FB4D         ;	HL	->	sector in disk buffer
1113: FB4D         ;
1114: FB4D 3A 3F FC               LD     A,(ReadFlag)         ; Move into or out of buffer /
1115: FB50 B7                     OR     A                    ; 0 => Write, non Zero => Read
1116: FB51 C2 59 FB               JP     NZ,BufferMove        ; Move out of buffer
1117: FB54
1118: FB54 3C                     INC    A                    ; going to force a write
1119: FB55 32 2F FC               LD     (MustWriteBuffer),A
1120: FB58 EB                     EX     DE,HL                ; DE <--> HL
1121: FB59
1122: FB59         ;The following move loop moves eight bytes at a time from (HL> to (DE), C contains the loop count
1123: FB59             BufferMove:
1124: FB59 7E                     LD     A,(HL)               ; Get byte from source
1125: FB5A 12                     LD     (DE),A               ; Put into destination
1126: FB5B 13                     INC    DE                   ; update pointers
1127: FB5C 23                     INC    HL
1128: FB5D
1129: FB5D 7E                     LD     A,(HL)
1130: FB5E 12                     LD     (DE),A
1131: FB5F 13                     INC    DE
1132: FB60 23                     INC    HL
1133: FB61
1134: FB61 7E                     LD     A,(HL)
1135: FB62 12                     LD     (DE),A
1136: FB63 13                     INC    DE
1137: FB64 23                     INC    HL
1138: FB65
1139: FB65 7E                     LD     A,(HL)
1140: FB66 12                     LD     (DE),A
1141: FB67 13                     INC    DE
1142: FB68 23                     INC    HL
1143: FB69
1144: FB69 7E                     LD     A,(HL)
1145: FB6A 12                     LD     (DE),A
1146: FB6B 13                     INC    DE
1147: FB6C 23                     INC    HL
1148: FB6D
1149: FB6D 7E                     LD     A,(HL)
1150: FB6E 12                     LD     (DE),A
1151: FB6F 13                     INC    DE
1152: FB70 23                     INC    HL
1153: FB71
1154: FB71 7E                     LD     A,(HL)
1155: FB72 12                     LD     (DE),A
1156: FB73 13                     INC    DE
1157: FB74 23                     INC    HL
1158: FB75
1159: FB75 7E                     LD     A,(HL)
1160: FB76 12                     LD     (DE),A
1161: FB77 13                     INC    DE
1162: FB78 23                     INC    HL
1163: FB79
1164: FB79 0D                     DEC    C                    ; count down on loop counter
1165: FB7A C2 59 FB               JP     NZ,BufferMove        ; repeat till done (CP/M sector moved)
1166: FB7D         ; end of loop
1167: FB7D
1168: FB7D 3A 29 FC               LD     A,(WriteType)        ; write to directory ?
1169: FB80 FE 01                  CP     WriteDirectory
1170: FB82 3A 3D FC               LD     A,(DiskErrorFlag)    ; get flag in case of a delayed read or write
1171: FB85 C0                     RET    NZ                   ; return if delayed read or write
1172: FB86
1173: FB86 B7                     OR     A                    ; Any disk errors ?
1174: FB87 C0                     RET    NZ                   ; yes - abandon attempt to write to directory
1175: FB88
1176: FB88 AF                     XOR    A
1177: FB89 32 2F FC               LD     (MustWriteBuffer),A  ; clear flag
1178: FB8C CD AF FB               CALL   WritePhysical
1179: FB8F 3A 3D FC               LD     A,(DiskErrorFlag)    ; return error flag to caller
1180: FB92 C9                     RET
1181: FB93         ;********************************************************************
1182: FB93         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
1183: FB93             CompareDkTrk:
1184: FB93 0E 03                  LD     C,03H                ; Disk(1), Track(2)
1185: FB95 C3 9A FB               JP     CompareDkTrkSecLoop
1186: FB98             CompareDkTrkSec:                      ;Compares just the disk and track   pointed to by DE and HL
1187: FB98 0E 04                  LD     C,04H                ; Disk(1), Track(2), Sector(1)
1188: FB9A             CompareDkTrkSecLoop:
1189: FB9A 1A                     LD     A,(DE)
1190: FB9B BE                     CP     M
1191: FB9C C0                     RET    NZ                   ; Not equal
1192: FB9D 13                     INC    DE
1193: FB9E 23                     INC    HL
1194: FB9F 0D                     DEC    C
1195: FBA0 C8                     RET    Z                    ; return they match (zero flag set)
1196: FBA1 C3 9A FB               JP     CompareDkTrkSecLoop  ; keep going
1197: FBA4
1198: FBA4         ;********************************************************************
1199: FBA4         ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE
1200: FBA4             MoveDkTrkSec:
1201: FBA4 0E 04                  LD     C,04H                ; Disk(1), Track(2), Sector(1)
1202: FBA6             MoveDkTrkSecLoop:
1203: FBA6 7E                     LD     A,(HL)
1204: FBA7 12                     LD     (DE),A
1205: FBA8 13                     INC    DE
1206: FBA9 23                     INC    HL
1207: FBAA 0D                     DEC    C
1208: FBAB C8                     RET    Z
1209: FBAC C3 A6 FB               JP     MoveDkTrkSecLoop
1210: FBAF         ;********************************************************************
1211: FBAF
1212: FBAF         ;********************************************************************
1213: FBAF         ;Write contents of disk buffer to correct sector
1214: FBAF             WritePhysical:
1215: FBAF 3E 02                  LD     A,DiskWriteCode      ; get write function
1216: FBB1 C3 B6 FB               JP     CommonPhysical
1217: FBB4
1218: FBB4             ReadPhysical:
1219: FBB4 3E 01                  LD     A,DiskReadCode       ; get read function
1220: FBB6
1221: FBB6             CommonPhysical:
1222: FBB6 32 1C FC               LD     (DCTCommand),A       ; set the command
1223: FBB9 3A 2A FC               LD     A,(InBufferDisk)
1224: FBBC E6 03                  AND    03H                  ; only units 0 to 3
1225: FBBE 32 1D FC               LD     (DCTUnit),A          ; set disk
1226: FBC1 2A 2B FC               LD     HL,(InBufferTrack)
1227: FBC4 7D                     LD     A,L                  ; for this controller it is a byte value
1228: FBC5 32 1F FC               LD     (DCTTrack),A         ; set track
1229: FBC8         ;  The sector must be converted into a head number and sector number.
1230: FBC8         ; This set of disks and Diskettes only have two Heads ******
1231: FBC8 06 00                  LD     B,0                  ; assume head 0
1232: FBCA 21 30 FC               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1233: FBCD 3A 2D FC               LD     A,(InBufferSector)   ; get target sector
1234: FBD0             Head0:
1235: FBD0 BE                     CP     M                    ; Need another Head?
1236: FBD1 DA D9 FB               JP     C,Head1              ; nope Acc < M
1237: FBD4
1238: FBD4 96                     SUB    M                    ; subtrack track value
1239: FBD5 04                     INC    B                    ; Increment head
1240: FBD6 C3 D0 FB               JP     Head0                ; loop til done
1241: FBD9
1242: FBD9             Head1:
1243: FBD9 3C                     INC    A                    ; physical sectors start at 1
1244: FBDA 32 20 FC               LD     (DCTSector),A
1245: FBDD 78                     LD     A,B
1246: FBDE 32 1E FC               LD     (DCTHead),A          ; set head number
1247: FBE1
1248: FBE1 21 00 02               LD     HL,diskSectorSize
1249: FBE4 22 21 FC               LD     (DCTByteCount),HL    ; set byte count
1250: FBE7 21 40 F6               LD     HL,DiskBuffer
1251: FBEA 22 23 FC               LD     (DCTDMAAddress),HL   ; set transfer address
1252: FBED
1253: FBED         ;	As only one control table is in use, close the status and busy chain pointers
1254: FBED         ;  back to the main control bytes
1255: FBED 21 43 00               LD     HL,DiskStatusLocation
1256: FBF0 22 25 FC               LD     (DCTNextStatusBlock),HL
1257: FBF3 21 45 00               LD     HL,DiskControlByte
1258: FBF6 22 27 FC               LD     (DCTNextControlLocation),HL
1259: FBF9 21 1C FC               LD     HL,DCTCommand
1260: FBFC 22 46 00               LD     (DiskCommandBlock),HL
1261: FBFF
1262: FBFF 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1263: FC02 36 80                  LD     (HL),080H
1264: FC04
1265: FC04         ;Wait until Disk Status Block indicates , operation complete, then check
1266: FC04         ; if any errors occurred. ,On entry HL -> disk control byte
1267: FC04             WaitForDiskComplete:
1268: FC04 7E                     LD     A,(HL)               ; get control bytes
1269: FC05 B7                     OR     A
1270: FC06 C2 04 FC               JP     NZ,WaitForDiskComplete ; operation not done
1271: FC09
1272: FC09 3A 43 00               LD     A,(DiskStatusLocation) ; done , so now check status
1273: FC0C FE 80                  CP     080H
1274: FC0E DA 16 FC               JP     C,DiskError
1275: FC11 AF                     XOR    A
1276: FC12 32 3D FC               LD     (DiskErrorFlag),A    ; clear the flag
1277: FC15 C9                     RET
1278: FC16
1279: FC16             DiskError:
1280: FC16 3E 01                  LD     A,1
1281: FC18 32 3D FC               LD     (DiskErrorFlag),A    ; set the error flag
1282: FC1B C9                     RET
1283: FC1C
1284: FC1C         ;********************************************************************
1285: FC1C         ;********************************************************************
1286: FC1C         ;********************************************************************
1287: FC1C
1288: FC1C         ;---------------------------------------------------------------------------
1289: FC1C         ;	Disk Data
1290: FC1C         ;---------------------------------------------------------------------------
1291: FC1C         ;	Disk Equates
1292: FC1C         ;---------------------------------------------------------------------------
1293: FC1C         ; Disk Types
1294: FC1C         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1295: FC1C         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1296: FC1C         ;;HardDisk	EQU	2						; hard disk
1297: FC1C         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1298: FC1C
1299: FC1C
1300: FC1C         ;**************************************************************************************************
1301: FC1C         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1302: FC1C         ;
1303: FC1C         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1304: FC1C         ; perform some disk operation.  These are called its disk control byte.
1305: FC1C         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1306: FC1C         ; following the respective control bytes. This word must contain the address of  valid disk control
1307: FC1C         ; table that specifies the exact disk operation to be performed.
1308: FC1C         ;
1309: FC1C         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1310: FC1C         ; This indicates completion to the disk driver code.
1311: FC1C         ;
1312: FC1C         ;  The controller also sets a return code in a disk status block - location 0X43H.
1313: FC1C         ; If the first byte of this status block is less than 80H. then a disk error
1314: FC1C         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1315: FC1C         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1316: FC1C         ; ten times before the controller returns an error
1317: FC1C         ;
1318: FC1C         ;  The disk control table layout is shown below. Note that the controller has the capability
1319: FC1C         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1320: FC1C         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1321: FC1C         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1322: FC1C         ; the end of the chain
1323: FC1C         ;**************************************************************************************************
1324: FC1C
1325: FC1C         ;***************************************************************************
1326: FC1C         ;	Disk Control tables
1327: FC1C         ;***************************************************************************
1328: FC1C         ;;DiskControlTable:
1329: FC1C             DCTStart:
1330: FC1C 00          DCTCommand: DB     00H                  ; Command
1331: FC1D 00          DCTUnit:   DB     00H                  ; unit (drive) number = 0 or 1
1332: FC1E 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1333: FC1F 00          DCTTrack:  DB     00H                  ; track number
1334: FC20 00          DCTSector: DB     00H                  ; sector number
1335: FC21 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1336: FC23 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1337: FC25 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1338: FC27 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1339: FC29             DCTSize    EQU    $-DCTStart
1340: FC29         ;-----------------------------------------
1341: FC29         ;WriteAllocated		EQU	00H		W_NORMAL
1342: FC29         ;WriteDirectory		EQU	01H		W_DIRECTORY
1343: FC29         ;WriteUnallocated	EQU	02H		W_NEW_BLOCK
1344: FC29         ;-----------------------------------------
1345: FC29
1346: FC29 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1347: FC2A
1348: FC2A         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1349: FC2A             InBufferDkTrkSec:
1350: FC2A 00          InBufferDisk: DB     00H
1351: FC2B 00 00       InBufferTrack: DW     00H
1352: FC2D 00          InBufferSector: DB     00H
1353: FC2E 00          DataInDiskBuffer: DB     00H                  ; when non-zero, the disk buffer has data from disk
1354: FC2F 00          MustWriteBuffer: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1355: FC30         ;   but not yet written out to the disk
1356: FC30         ;---------------------------------------------------------------------------
1357: FC30         ;	Disk Storage area
1358: FC30         ;---------------------------------------------------------------------------
1359: FC30         ;     variables for selected disk, track and sector
1360: FC30         ; These are moved and compared as a group, DO NOT ALTER
1361: FC30 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1362: FC31
1363: FC31             SelectedDkTrkSec:
1364: FC31 00          SelectedDisk: DB     00H
1365: FC32 00 00       SelectedTrack: DW     00H
1366: FC34 00          SelectedSector: DB     00H
1367: FC35 00 00       DMAAddress: DW     00H                  ; DMA address
1368: FC37
1369: FC37             SelectedPhysicalSector:
1370: FC37 00                     DB     00H
1371: FC38
1372: FC38         ; Parameters for writing to a previously unallocated allocation block
1373: FC38         ; These are moved and compared as a group, DO NOT ALTER
1374: FC38             UnallocatedDkTrkSec:
1375: FC38 00          UnallocatedDisk: DB     00H
1376: FC39 00 00       UnallocatedTrack: DW     00H
1377: FC3B 00          UnallocatedSector: DB     00H
1378: FC3C 00          UnalocatedlRecordCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1379: FC3D 00          DiskErrorFlag: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1380: FC3E         ; Flags used inside the de-blocking code
1381: FC3E 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1382: FC3F         ; either before a write to a allocated block can occur, or
1383: FC3F         ; for a normal cpmRecord read
1384: FC3F 00          ReadFlag:  DB     00H                  ; Non-zero when a cpmRecord is to be read
1385: FC40
1386: FC40         ;---------------------------------------------------------------------------
1387: FC40
1388: FC40         ;---------------------------------------------------------------------------
1389: FC40         ;	Disk Definition Tables
1390: FC40         ; These consists of disk parameter headers, with one entry
1391: FC40         ; per logical disk driver, and disk parameter blocks, with
1392: FC40         ; either one parameter block per logical disk or the same
1393: FC40         ; parameter block for several logical disks.
1394: FC40         ;---------------------------------------------------------------------------
1395: FC40         ;---------------------------------------------------------------------------
1396: FC40             DiskParameterHeaders:
1397: FC40
1398: FC40         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1399: FC40 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1400: FC42 00 00                  DW     0000H                ; Rel pos for file (0-3)
1401: FC44 00 00                  DW     0000H                ; Last Selected Track #
1402: FC46 00 00                  DW     0000H                ; Last Selected Sector #
1403: FC48 74 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1404: FC4A 80 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1405: FC4C 90 FC                  DW     DiskAWorkArea
1406: FC4E 10 FD                  DW     DiskAAllocationVector
1407: FC50
1408: FC50         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1409: FC50 00 00                  DW     0000H                ; No Skew table
1410: FC52 00 00                  DW     0000H                ; Rel pos for file (0-3)
1411: FC54 00 00                  DW     0000H                ; Last Selected Track #
1412: FC56 00 00                  DW     0000H                ; Last Selected Sector #
1413: FC58 74 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1414: FC5A 80 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1415: FC5C B0 FC                  DW     DiskBWorkArea
1416: FC5E 69 FD                  DW     DiskBAllocationVector
1417: FC60
1418: FC60         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1419: FC60 00 00                  DW     0000H                ; No Skew table
1420: FC62 00 00                  DW     0000H                ; Rel pos for file (0-3)
1421: FC64 00 00                  DW     0000H                ; Last Selected Track #
1422: FC66 00 00                  DW     0000H                ; Last Selected Sector #
1423: FC68 74 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1424: FC6A 80 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1425: FC6C D0 FC                  DW     DiskCWorkArea
1426: FC6E C2 FD                  DW     DiskCAllocationVector
1427: FC70
1428: FC70         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1429: FC70 00 00                  DW     0000H                ; No Skew table
1430: FC72 00 00                  DW     0000H                ; Rel pos for file (0-3)
1431: FC74 00 00                  DW     0000H                ; Last Selected Track #
1432: FC76 00 00                  DW     0000H                ; Last Selected Sector #
1433: FC78 74 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1434: FC7A 80 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1435: FC7C F0 FC                  DW     DiskDWorkArea
1436: FC7E 1B FE                  DW     DiskDAllocationVector
1437: FC80
1438: FC80
1439: FC80         ;-----------------------------------------------------------
1440: FC80
1441: FC80             ParameterBlock3HD:
1442: FC80 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1443: FC82 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1444: FC83 0F                     DB     dpb3hdBLM            ; Block mask
1445: FC84 00                     DB     dpb3hdEXM            ; Extent mask
1446: FC85 C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1447: FC87 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1448: FC89 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1449: FC8A 00                     DB     dpb3hdAL1            ;  for file directory
1450: FC8B 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1451: FC8D 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1452: FC8F
1453: FC8F 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1454: FC90
1455: FC90
1456: FC90
1457: FC90         ;---------------------------------------------------------------------------
1458: FC90         ;	Disk work area
1459: FC90         ;---------------------------------------------------------------------------
1460: FC90         ; These are used by the BDOS to detect any unexpected
1461: FC90         ; change of diskette. The BDOS will automatically set
1462: FC90         ; such a changed diskette to read-only status.
1463: FC90
1464: FC90             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1465: FCB0             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1466: FCD0             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1467: FCF0             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1468: FD10
1469: FD10         ;---------------------------------------------------------------------------
1470: FD10         ;	Disk allocation vectors
1471: FD10         ;---------------------------------------------------------------------------
1472: FD10         ; Disk allocation vectors
1473: FD10         ; These are used by the BDOS to maintain a bit map of
1474: FD10         ; which allocation blocks are used and which are free.
1475: FD10         ; One byte is used for eight allocation blocks, hence the
1476: FD10         ; expression of the form (allocation blocks/8)+1
1477: FD10
1478: FD10             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1479: FD69             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1480: FDC2
1481: FDC2             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1482: FE1B             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1483: FE74         ;---------------------------------------------------------------------------
1484: FE74         ;	Disk Buffer
1485: FE74         ;---------------------------------------------------------------------------
1486: FE74             DirectoryBuffer: DS     DirBuffSize
1487: FEF4         ;---------------------------------------------------------------------------
1488: FEF4         ;**********************************************************************************
1489: FEF4         ;	Disk Control table image for warm boot
1490: FEF4         ;**********************************************************************************
1491: FEF4         ;?  BootControl:
1492: FEF4         ;?  	DB		DiskReadCode					; Read function
1493: FEF4         ;?  	DB		00H								; unit number
1494: FEF4         ;?  	DB		00H								; head number
1495: FEF4         ;?  	DB		00H								; track number
1496: FEF4         ;?  	DB		02H								; Starting sector number (skip cold boot sector)
1497: FEF4         ;?  	DW		CCPLength + BDOSLength			; Number of bytes to read ( rest of the head)
1498: FEF4         ;?  	DW		CCPEntry						; read into this address
1499: FEF4         ;?  	DW		DiskStatusLocation				; pointer to next block - no linking
1500: FEF4         ;?  	DW		DiskControlByte					; pointer to next table- no linking
1501: FEF4         ;?
1502: FEF4         ;
1503: FEF4         ;**********************************************************************************
1504: FEF4         ;	Warm Boot
1505: FEF4         ;  On warm boot. the CCP and BDOS must be reloaded into memory.
1506: FEF4         ; This code is hardware specific to the 3.5 HD controller.
1507: FEF4         ;**********************************************************************************
1508: FEF4
1509: FEF4         ;?WBOOT:
1510: FEF4         ;?	LD		SP,CCPEntry -1
1511: FEF4         ;?	LD		HL,BootControl					; point at the disk control table
1512: FEF4         ;?	LD	(DiskCommandBlock),HL
1513: FEF4         ;?
1514: FEF4         ;?	LD		HL,DiskControlByte
1515: FEF4         ;?	LD		(HL),080H							; activate the controller
1516: FEF4         ;?
1517: FEF4         ;?WaitTillDone:
1518: FEF4         ;?	LD		A,(HL)								; Get the control byte
1519: FEF4         ;?	OR		A								; Reset to 0 (Completed operation) ?
1520: FEF4         ;?	JP	NZ,WaitTillDone					; if not try again
1521: FEF4         ;?
1522: FEF4         ;?	LD		A,(DiskStatusLocation)				; after operation what's the status?
1523: FEF4         ;?	CP		080H							; any errors ?
1524: FEF4         ;?	JP	NC,EnterCPM						; Nope
1525: FEF4         ;?											; yes
1526: FEF4         ;?WarmBootError:
1527: FEF4         ;?	LD		HL,WarmBootErroMessage			; point at error message
1528: FEF4         ;?	CALL	DisplayMessage					; sent it. and
1529: FEF4         ;?	JP		WBOOT							; try again.
1530: FEF4         ;?
1531: FEF4         ;?;---------------------------------------------------------------------------
1532: FEF4         ;?DisplayMessage:
1533: FEF4         ;?	LD		A,(HL)								; get next message byte
1534: FEF4         ;?	OR		A								; terminator (a = 0)?
1535: FEF4         ;?	RET	Z; Yes, thes return to caller
1536: FEF4         ;?
1537: FEF4         ;?	LD		C,A								; prepare for output
1538: FEF4         ;?	PUSH	HL								; save message pointer
1539: FEF4         ;?	CALL	CONOUT							; go to main console output routine *******
1540: FEF4         ;?	POP		HL
1541: FEF4         ;?	INC		HL 								; point at next character
1542: FEF4         ;?	JP		DisplayMessage					; loop till done
1543: FEF4         ;?
1544: FEF4         ;?WarmBootErroMessage:
1545: FEF4         ;?	DB		CR,LF
1546: FEF4         ;?	DB		'Warm Boot -'
1547: FEF4         ;?	DB		' Retrying.'
1548: FEF4         ;?	DB		CR,LF
1549: FEF4         ;?	DB		EndOfMessage
1550: FEF4         ;?
1551: FEF4         ;--------------------BOOT-----------------------------
1552: FEF4
1553: FEF4         ; entered directly from the BIOS JMP vector
1554: FEF4         ; Control transfered by the CP/M bootstrap loader
1555: FEF4         ; Sets up Page Zero
1556: FEF4         ;---------------End of Cold Boot Initialization Code--------------
1557: FEF4
1558: FEF4         ; BOOT:
1559: FEF4         ; EnterCPM:
1560: FEF4         ; 	LD		A,0C3H							; JMP op code
1561: FEF4         ; 	LD		(0000H),A							; set up the jump in location 0000H
1562: FEF4         ; 	LD		(0005H),A							; and at location 0005H
1563: FEF4         ;
1564: FEF4         ; 	LD		HL,WarmBootEntry					; get BIOS vector address
1565: FEF4         ; 	LD	(0001H),HL							; put address in location 1
1566: FEF4         ;
1567: FEF4         ; 	LD		HL,BDOSEntry						; Get BDOS entry point address
1568: FEF4         ; 	LD	(0006H),HL							; put address at location 5
1569: FEF4         ;
1570: FEF4         ; 	LD		BC,DMABuffer						; DefaultDiskBuffer set disk I/O address to default
1571: FEF4         ; 	CALL	SETDMA							; use normal BIOS routine
1572: FEF4         ;
1573: FEF4         ; 	EI
1574: FEF4         ; 	LD		A,(Pg0CurentDisk)					; DefaultDisk  Transfer current default disk to
1575: FEF4         ; 	LD		C,A								; Console Command Processor
1576: FEF4         ; 	JP		CCPEntry						; transfer to CCP
1577: FEF4
1578: FEF4         ;-------------------------------------------------
1579: FEF4
           ************************   Xref   ************************
0000: $               FE74   0314 1339
0699: AddressDataIn   F9AB   0697
0714: AddressDataOut  F9BB   0711
0724: AddressStatus   F9C4   0722
0318: AfterDiskBuffer F840
0081: ASCII_A         0041
0082: ASCII_C         0043
0083: ASCII_K         004B
0090: ASCII_LO_A      0061
0091: ASCII_LO_K      006B
0092: ASCII_LO_P      0070
0033: ASCII_MASK      007F   0705
0084: ASCII_N         004E
0085: ASCII_Q         0051
0086: ASCII_R         0052
0087: ASCII_W         0057
0088: ASCII_Y         0059
0068: ASCII_ZERO      0030
0062: ASTERISK        002A
0391: BadBootMessage  F890   0355
0147: BDOSBase        E800   0148 0150
0116: BDOSE           0005   0117 0477 0479
0148: BDOSEntry       E806   0478
0137: BDOSLength      0E00   0140 0150 0151 0496
0051: BELL            0007
0150: BIOSBase        F600
0138: BIOSLength      0A00   0140
0110: BIOSPAGE        0002
0151: BIOSStart       F600   0290 0366
0247: BlockSize       0800   0269
0347: BOOT            F840   0294
0359: BOOTControl     F856   0351
0383: BootMessage     F863   0348
1123: BufferMove      FB59   1116 1165
0029: BYTE            0001
0089: CARET           005E
0145: CCPEntry        E000   0147 0151 0459 0487 0497
0136: CCPLength       0800   0140 0147 0151 0496
1004: CheckUnallocatedBlock FAAA   0993
0292: CodeStart       F600
0069: COLON           003A
0767: COM_DataPort    00EC   0811
0769: COM_InputMask   0002   0813
0768: COM_OutputMask  0001   0812
0766: COM_StatusPort  00ED   0810
0809: COM_Table       F9F3   0841 0851
0064: COMMA           002C
1221: CommonPhysical  FBB6   1216
1183: CompareDkTrk    FB93   1055
1186: CompareDkTrkSec FB98   1013
1188: CompareDkTrkSecLoop FB9A   1185 1196
0122: ComTail         0080   0123
0124: ComTailChars    0082
0123: ComTailCount    0081   0124
0838: CON_Vector      FA11   0518 0558
0538: ConIn           F932   0540
0537: CONIN           F932   0298
0555: CONOUT          F93E   0299
0556: CONOut          F93E
0515: CONST           F920   0297
0516: ConStatus       F920   0539
0224: cpmRecordSize   0080   0226 0229 0231 1107
0054: CR              000D   0388 0390 0392 0396 0399
0762: CRT_DataPort    0001   0803
0764: CRT_InputMask   007F   0805
0763: CRT_OutputMask  0080   0804
0761: CRT_StatusPort  0002   0802
0801: CRT_Table       F9E9   0840 0845 0852 0855
0037: CTRL_C          0003
0038: CTRL_E          0005
0039: CTRL_H          0008
0040: CTRL_K          000B
0041: CTRL_L          000C
0042: CTRL_P          0010
0043: CTRL_R          0012
0044: CTRL_S          0013
0045: CTRL_U          0015
0046: CTRL_X          0018
0047: CTRL_Z          001A
0065: DASH            002D
0258: DataBlocks      02C7   0268
1353: DataInDiskBuffer FC2E   0877 1045
0783: DataPortIndex   0001   0696 0710
0695: DataRead        F9A4   0704 0807 0815 0823
0703: DataReadASCII   F9AD   0798
0787: DataReadIndex   0006   0542 0543 0638 0639
0257: DataSectors     0B1C   0258
0709: DataWrite       F9B3   0799 0808 0816 0824
0788: DataWriteIndex  0008   0565 0566
1335: DCTByteCount    FC21   1249
1330: DCTCommand      FC1C   1222 1259
1336: DCTDMAAddress   FC23   1251
1332: DCTHead         FC1E   1246
1338: DCTNextControlLocation FC27   1258
1337: DCTNextStatusBlock FC25   1256
1334: DCTSector       FC20   1244
1339: DCTSize         000B
1329: DCTStart        FC1C   1339
1333: DCTTrack        FC1F   1228
1331: DCTUnit         FC1D   1225
0229: DirBuffSize     0080   1486
0244: DirectoryBlockCount 0002   0269
1486: DirectoryBuffer FE74   1403 1413 1423 1433
0231: DirectoryEntryPerRecord 0004   0272
0228: DirEntrySize    0020   0231 0269
1478: DiskAAllocationVector FD10   1406
1464: DiskAWorkArea   FC90   1405
1479: DiskBAllocationVector FD69   1416
0316: DiskBuffer      F640   1101 1250
1465: DiskBWorkArea   FCB0   1415
1481: DiskCAllocationVector FDC2   1426
0216: DiskCommandBlock 0046   0404 1260
0215: DiskControlByte 0045   0406 0499 1257 1262
0218: DiskControlTable 0040   0368
1466: DiskCWorkArea   FCD0   1425
1482: DiskDAllocationVector FE1B   1436
1467: DiskDWorkArea   FCF0   1435
1279: DiskError       FC16   1274
1379: DiskErrorFlag   FC3D   1039 1170 1179 1276 1281
1396: DiskParameterHeaders FC40   0903
0220: DiskReadCode    0001   0360 0491 1219
0225: diskSectorSize  0200   0226 0247 0255 0317 1248
0214: DiskStatusLocation 0043   0367 0416 0498 1255 1272
0221: DiskWriteCode   0002   1215
0421: DisplayMessage  F8D2   0349 0356 0430 0465
1367: DMAAddress      FC35   0943 1104
0127: DMABuffer       0080   0481
0058: DOLLAR          0024
0270: dpb3hdAL0       00C0   1448
0271: dpb3hdAL1       0000   1449
0266: dpb3hdBLM       000F   1444
0265: dpb3hdBSH       0004   1443
0272: dpb3hdCKS       0020   1450 1464 1465 1466 1467
0269: dpb3hdDRM       007F   0272 1447
0268: dpb3hdDSM       02C6   1446 1478 1479 1481 1482
0267: dpb3hdEXM       0000   1445
0274: dpb3hdNOH       0002   1453
0273: dpb3hdOFF       0001   1451
0264: dpb3hdSPT       0090   1442 1453
0777: DUMMY_DataPort  0010   0827
0779: DUMMY_InputMask 007F   0829
0778: DUMMY_OutputMask 00FF   0828
0776: DUMMY_StatusPort 0011   0826
0825: DUMMY_Table     FA07   0842 0846 0847 0850 0857
0733: DUMMYCheck      F9C9   0830
0729: DUMMYRead       F9C7   0831
0731: DUMMYWrite      F9C8   0832
0131: END_OF_FILE     001A
0035: EndOfMessage    0000   0390 0394 0399
0073: EQUAL_SIGN      003D
0056: EXCLAIM_POINT   0021
0024: FALSE           0000
0119: FCB1            005C   0120
0120: FCB2            006C
0164: fCloseFile      0010
0155: fConsoleIn      0001
0156: fConsoleOut     0002
0167: fDeleteFile     0013
0159: fGetConsoleStatus 000B
0173: fGetCurrentDisk 0019
0172: fGetLoginVector 0018
0175: fGetSetUserNumber 0020
0160: fGetVersion     000C
0170: fMakeFile       0016
0163: fOpenFile       000F
0157: fPrintString    0009
0168: fReadSeq        0014
0158: fReadString     000A
0171: fRenameFile     0017
0161: fResetSystem    000D
0165: fSearchFirst    0011
0166: fSearchNext     0012
0162: fSelectDisk     000E
0174: fSetDMA         001A
0169: fWriteSeq       0015
0520: GenericInStatus F927   0635
0560: GenericOutStatus F945   0584 0612
0562: GenericOutStatus1 F948   0564
0686: GetInStatus     F99A   0522
0682: GetOutStatus    F995   0563 0672
0688: GetStatus       F99D   0685
0074: GREATER_THAN    003E
0057: HASH_TAG        0023
1234: Head0           FBD0   1240
1242: Head1           FBD9   1236
0873: HOME            FA31   0303
0878: HomeNoWrite     FA3B   0876
0285: IN_OPCODE       00DB   0698 0723
1350: InBufferDisk    FC2A   1071 1223
1349: InBufferDkTrkSec FC2A   1053
1352: InBufferSector  FC2D   1058 1075 1233
1351: InBufferTrack   FC2B   1073 1226
0785: InputMaskIndex  0003   0687
0111: IOBYTE          0003   0517 0557 0580 0606 0630 0667
0287: JP_OPCODE       00C3   0471
0060: L_PAREN         0028
0077: LEFT_ARROW      005F
0093: LEFT_CURLY      007B
0140: LengthInBytes   2000   0141 0145 0255
0141: LengthInK       0009
0072: LESS_THAN       003C
0053: LF              000A   0388 0390 0392 0396 0399
0579: LIST            F954   0300
0666: LISTST          F981   0310
0027: LO_NIBBLE_MASK  000F
0470: LoadPage0       F8F1   0462
0772: LPT_DataPort    0010   0819
0774: LPT_InputMask   007F   0821
0773: LPT_OutputMask  00FF   0820
0771: LPT_StatusPort  0011   0818
0817: LPT_Table       F9FD   0854 0856
0853: LST_Vector      FA29   0583 0670
0143: MemorySize      0040   0145
1200: MoveDkTrkSec    FBA4   1000
1202: MoveDkTrkSecLoop FBA6   1209
1354: MustWriteBuffer FC2F   0874 1064 1085 1119 1177
0256: myOffset        0001   0257 0273
1024: NoTrackChange   FAD2   1019
0049: NULL            0000
0240: NumberOfHeads   0002   0251 0253 0264 0274
0237: NumberOfLogicalDisks 0004   0891
0026: OFF             0000
0025: ON              FFFF
0286: OUT_OPCODE      00D3   0713
0784: OutputMaskIndex 0002   0684
1441: ParameterBlock3HD FC80   1404 1414 1424 1434
0059: PERCENT         0025
1037: PerformReadWrite FAE1   0970 1027
0066: PERIOD          002E
0114: Pg0CurentDisk   0004   0485
0113: Pg0CurentUser   0004   0114
0063: PLUS_SIGN       002B
1381: PrereadSectorFlag FC3E   0967 1026 1033 1077
0848: PUN_Vector      FA21   0611
0605: PUNCH           F95F   0301
0075: QMARK           003F
0061: R_PAREN         0029
0107: RAM             0000   0109 0110 0111 0113 0116 0119 0122 0127 0129
0403: RawDiskRead     F8C0   0352 0461
0843: RDR_Vector      FA19   0633
0962: READ            FA7C   0308
0629: READER          F96C   0302
0634: READER1         F975   0636
1384: ReadFlag        FC3F   0966 0989 1114
1218: ReadPhysical    FBB4   1079
1068: ReadSectorIntoBuffer FB16   1049
0249: RecordsPerBlock 0010   0996
0233: RecordsPerExtent 0080
0226: recordsPerSector 0004   0249 0264
1029: RequestPreread  FAD9   1007 1014
0078: RUBOUT          007F
1089: SectorInBuffer  FB33   1061
0278: SectorMask      0003   1091
1063: SectorNotInBuffer FB0F   1056
0243: SectorsPerBlock 0004   0247 0249 0252 0258 0278
0253: SectorsPerCylinder 0024   0256 0257
0242: SectorsPerTrack 0012   0251 0253 0264 1018
0951: SECTRAN         FA79   0311
0888: SELDSK          FA41   0304
1364: SelectedDisk    FC31   0894 1070
1363: SelectedDkTrkSec FC31   0998 1011 1054
1361: SelectedDskSecsPerHead FC30   0914 1232
1369: SelectedPhysicalSector FC37   1044 1059 1074
1366: SelectedSector  FC34   0934 1040 1090
1365: SelectedTrack   FC32   0926 1072
0071: SEMICOLON       003B
0739: SetDeviceVector F9CD   0521 0561 0671
0940: SETDMA          FA73   0307 0482
0932: SETSEC          FA6E   0306
0923: SETTRK          FA68   0305 0880
0067: SLASH           002F
0050: SOH             0001
0055: SPACE           0020
0782: StatusPortIndex 0000   0721
0720: StatusRead      F9BD   0797 0806 0814 0822
0786: StatusReadIndex 0004   0689 0690
0255: SystemSectors   0011   0256
0052: TAB             0009
0117: TopRAM          0007
0252: TotalNumberOfBlocks 02D0
0251: TotalNumberOfSectors 0B40   0252 0257
0129: TPA             0100
0241: TracksPerHead   0050   0251
0023: TRUE            FFFF
0757: TTY_DataPort    00EC   0427 0794
0759: TTY_InputMask   007F   0796
0758: TTY_OutputMask  0080   0795
0756: TTY_StatusPort  00ED   0793
0792: TTY_Table       F9DF   0839 0844 0849
1375: UnallocatedDisk FC38
1374: UnallocatedDkTrkSec FC38   0999 1012
1377: UnallocatedSector FC3B
1376: UnallocatedTrack FC39   1021 1023
1378: UnalocatedlRecordCount FC3C   0964 0997 1005 1009 1031
0076: UNDER_SCORE     005F
1267: WaitForDiskComplete FC04   1270
0410: WaitForReadDone F8C8   0413
0109: WarmBoot        0000   0473 0475
0295: WarmBootEntry   F603   0474
0395: WarmBootErroMessage F8A6   0464
0458: WBOOT           F8DD   0296 0354 0466
0490: WBOOTControl    F913   0460
0030: WORD            0002
0986: WRITE           FA8F   0309
0189: WriteAllocated  0000
0190: WriteDirectory  0001   1169
1214: WritePhysical   FBAF   1066 1178
1346: WriteType       FC29   0969 0991 1168
0191: WriteUnallocated 0002   0968 0992
0034: ZERO            0000
