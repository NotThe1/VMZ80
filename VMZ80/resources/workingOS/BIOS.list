0001: F600         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: F600         ; BIOS.Z80
0004: F600
0005: F600         ; 2018 12-11 Adjusted BOOT & WBOOT
0006: F600         ; 2018-12-10 Refactored  character device routines;
0007: F600         ; 2017-03-31 Added List out functionality for List Device
0008: F600         ; 2017-03-02 Refactored the CP/M Suite
0009: F600         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0010: F600         ; 2014-01-16
0011: F600         ; 2014-03-14  :  Frank Martyn
0012: F600
0013: F600         ; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
0014: F600         ; by Andy Johnson-Laird
0015: F600         ;
0016: F600         ; Published by
0017: F600         ; Osborne/McGraw-Hill
0018: F600         ; 2600 Tenth Street
0019: F600         ; Berkeley, California 94710
0020: F600         ; U.S.A.
0021: F600
0022: F600                        Include ./stdHeader.Z80
0023: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0024: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0025: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0026: F600         ; stdHeader.asm
0027: F600         ; standard equates
0028: F600
0029: F600         ; 2017-03-02 Refactored the CP/M Suite
0030: F600
0031: F600
0032: F600             TRUE       EQU    -1                   ; not false
0033: F600             FALSE      EQU    0000H
0034: F600             ON         EQU    -1
0035: F600             OFF        EQU    0000H
0036: F600             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0037: F600
0038: F600             BYTE       EQU    1                    ; number of bytes for "byte" type
0039: F600             WORD       EQU    2                    ; number of bytes for "word" type
0040: F600
0041: F600
0042: F600             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0043: F600             ZERO       EQU    00H                  ; Zero
0044: F600             EndOfMessage EQU    00H
0045: F600
0046: F600             CTRL_C     EQU    03H                  ; ETX
0047: F600             CTRL_E     EQU    05H                  ; physical eol
0048: F600             CTRL_H     EQU    08H                  ; backspace
0049: F600             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0050: F600             CTRL_L     EQU    0CH                  ; FF - Form feed
0051: F600             CTRL_P     EQU    10H                  ; prnt toggle
0052: F600             CTRL_R     EQU    12H                  ; repeat line
0053: F600             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0054: F600             CTRL_U     EQU    15H                  ; line delete
0055: F600             CTRL_X     EQU    18H                  ; =ctl-u
0056: F600             CTRL_Z     EQU    1AH                  ; end of file
0057: F600
0058: F600             NULL       EQU    00H                  ; Null
0059: F600             SOH        EQU    01H                  ; Start of Heading
0060: F600             BELL       EQU    07H                  ; Bell
0061: F600             TAB        EQU    09H                  ; Tab
0062: F600             LF         EQU    0AH                  ; Line Feed
0063: F600             CR         EQU    0DH                  ; Carriage Return
0064: F600             SPACE      EQU    20H                  ; Space
0065: F600             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0066: F600             HASH_TAG   EQU    23H                  ; Sharp sign #
0067: F600             DOLLAR     EQU    24H                  ; Dollar Sign
0068: F600             PERCENT    EQU    25H                  ; Percent Sign
0069: F600             L_PAREN    EQU    28H                  ; Left Paenthesis (
0070: F600             R_PAREN    EQU    29H                  ; Right Paenthesis )
0071: F600             ASTERISK   EQU    2AH                  ; Asterisk *
0072: F600             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0073: F600             COMMA      EQU    2CH                  ; Comma
0074: F600             DASH       EQU    2DH                  ; Dash Hyphen -
0075: F600             PERIOD     EQU    2EH                  ; Period
0076: F600             SLASH      EQU    2FH                  ; /
0077: F600             ASCII_ZERO EQU    30H                  ; zero
0078: F600             COLON      EQU    3AH                  ; Colon
0079: F600
0080: F600             SEMICOLON  EQU    3BH                  ; Semi Colon
0081: F600             LESS_THAN  EQU    3CH                  ; Less Than <
0082: F600             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0083: F600             GREATER_THAN EQU    3EH                  ; Greater Than >
0084: F600             QMARK      EQU    3FH                  ; Question Mark
0085: F600             UNDER_SCORE EQU    5FH                  ; under score _
0086: F600             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0087: F600             RUBOUT     EQU    7FH                  ; Delete Key
0088: F600
0089: F600
0090: F600             ASCII_A    EQU    'A'
0091: F600             ASCII_C    EQU    'C'
0092: F600             ASCII_K    EQU    'K'
0093: F600             ASCII_N    EQU    'N'
0094: F600             ASCII_Q    EQU    'Q'
0095: F600             ASCII_R    EQU    'R'
0096: F600             ASCII_W    EQU    'W'
0097: F600             ASCII_Y    EQU    'Y'
0098: F600             CARET      EQU    '^'
0099: F600             ASCII_LO_A EQU    'a'
0100: F600             ASCII_LO_K EQU    'k'
0101: F600             ASCII_LO_P EQU    'p'
0102: F600             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0103: F600
0104: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0105: F600                        Include ./osHeader.Z80
0106: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0107: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0108: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0109: F600         ; osHeader.asm
0110: F600
0111: F600         ; 2017-03-02 Refactored the CP/M Suite
0112: F600
0113: F600         ; Contains the Equates used by the CP/M system
0114: F600
0115: F600         ;------------------------Page Zero Constants ---------------------------------
0116: F600             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0117: F600
0118: F600             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0119: F600             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0120: F600             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0121: F600
0122: F600             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0123: F600             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0124: F600
0125: F600             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0126: F600             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0127: F600
0128: F600             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0129: F600             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0130: F600
0131: F600             ComTail    EQU    RAM + 080H           ; Complete command tail
0132: F600             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0133: F600             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0134: F600         ;-----------------------------------------------------------------------
0135: F600
0136: F600             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0137: F600         ;-----------------------------------------------------------------------
0138: F600             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0139: F600         ;-----------------------------------------------------------------------
0140: F600             END_OF_FILE EQU    1AH                  ; end of file
0141: F600         ;-----------------------------------------------------------------------
0142: F600
0143: F600         ;--------------- CP/M Constants -----------------------------------------
0144: F600
0145: F600             CCPLength  EQU    0800H                ; Constant
0146: F600             BDOSLength EQU    0E00H                ; Constant 0E00H
0147: F600             BIOSLength EQU    0A00H                ; Constant 0900H
0148: F600
0149: F600             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0150: F600             LengthInK  EQU    (LengthInBytes/1024) + 1
0151: F600
0152: F600             MemorySize EQU    64
0153: F600
0154: F600             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0155: F600
0156: F600             BDOSBase   EQU    CCPEntry + CCPLength
0157: F600             BDOSEntry  EQU    BDOSBase + 6
0158: F600
0159: F600             BIOSBase   EQU    BDOSBase + BDOSLength
0160: F600             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0161: F600         ;-----------------------------------------------------------------------
0162: F600
0163: F600         ;------------------- BDOS System Call Equates --------------------------
0164: F600             fConsoleIn EQU    01H                  ; rcharf - Console Input
0165: F600             fConsoleOut EQU    02H                  ; pcharf - Console Output
0166: F600             fPrintString EQU    09H                  ; pbuff	- Print String
0167: F600             fReadString EQU    0AH                  ; rbuff	- Read Console String
0168: F600             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0169: F600             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0170: F600             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0171: F600             fSelectDisk EQU    0EH                  ; self	- Select Disk
0172: F600             fOpenFile  EQU    0FH                  ; openf	- Open File
0173: F600             fCloseFile EQU    10H                  ; closef - Close File
0174: F600             fSearchFirst EQU    11H                  ; searf	- Search For First
0175: F600             fSearchNext EQU    12H                  ; searnf - Search for Next
0176: F600             fDeleteFile EQU    13H                  ; delf - Delete File
0177: F600             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0178: F600             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0179: F600             fMakeFile  EQU    16H                  ; makef	- Make File
0180: F600             fRenameFile EQU    17H                  ; renf	- Rename File
0181: F600             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0182: F600             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0183: F600             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0184: F600             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0185: F600         ;-----------------------------------------------------------------------
0186: F600
0187: F600
0188: F600
0189: F600
0190: F600
0191: F600         ;*******************************************************************************
0192: F600         ; These are the values handed over by the BDOS when it calls the Writer operation
0193: F600         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0194: F600         ; unallocated allocation block (it only indicates this for the first 128 byte
0195: F600         ; sector write) or to an allocation block that has already been allocated to a
0196: F600         ; file. The BDOS also indicates if it is set to write to the file directory
0197: F600         ;*******************************************************************************
0198: F600             WriteAllocated EQU    00H
0199: F600             WriteDirectory EQU    01H
0200: F600             WriteCleanBuffer EQU    02H
0201: F600
0202: F600
0203: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0204: F600                        Include ./diskHeader.Z80
0205: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0206: F600         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0207: F600         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0208: F600         ; diskHeader.asm
0209: F600
0210: F600         ; 2017-03-02 Refactored the CP/M Suite
0211: F600
0212: F600         ; needs osHeader.asm declared before this is used !!!!!!!
0213: F600
0214: F600         ; Contains the Equates used by the CP/M system to handle disks
0215: F600
0216: F600
0217: F600         ;*******************************************************************************
0218: F600         ;
0219: F600         ;     Disk related values
0220: F600         ;
0221: F600         ;
0222: F600         ;*******************************************************************************
0223: F600             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0224: F600             DiskControlByte EQU    045H                 ; control byte for disk I/O
0225: F600             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0226: F600         ; for boot
0227: F600             DiskControlTable EQU    0040H
0228: F600
0229: F600             DiskReadCode EQU    01H                  ; Code for Read
0230: F600             DiskWriteCode EQU    02H                  ; Code for Write
0231: F600
0232: F600
0233: F600             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0234: F600             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0235: F600             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0236: F600
0237: F600             DirEntrySize EQU    20H                  ; (32)
0238: F600             DirBuffSize EQU    cpmRecordSize
0239: F600
0240: F600             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0241: F600
0242: F600             RecordsPerExtent EQU    080H                 ; extent Record capacity
0243: F600
0244: F600
0245: F600         ;-------------------------------------------------------------------------------------
0246: F600             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0247: F600
0248: F600         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0249: F600             NumberOfHeads EQU    02H                  ; number of heads
0250: F600             TracksPerHead EQU    50H                  ; 80
0251: F600             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0252: F600             SectorsPerBlock EQU    04H                  ; 2048 bytes
0253: F600             DirectoryBlockCount EQU    02H                  ;
0254: F600         ;-----------------------------------------------------------------------
0255: F600
0256: F600             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0257: F600
0258: F600             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0259: F600
0260: F600             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0261: F600             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0262: F600             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0263: F600
0264: F600             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0265: F600             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0266: F600             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0267: F600             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0268: F600
0269: F600         ;-----------------------------------------------------------------------
0270: F600         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0271: F600         ;-----------------------------------------------------------------------
0272: F600         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0273: F600             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0274: F600             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0275: F600             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0276: F600             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0277: F600             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0278: F600             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0279: F600             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0280: F600             dpb3hdAL1  EQU    00H                  ;  for each file directory
0281: F600             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0282: F600             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0283: F600             dpb3hdNOH  EQU    NumberOfHeads
0284: F600
0285: F600         ;*******************************************************************************
0286: F600
0287: F600             SectorMask EQU    SectorsPerBlock - 1
0288: F600
0289: F600         ;***************************************************************************
0290: F600
0291: F600         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0292: F600
0293: F600
0294: F600             IN_OPCODE  EQU    0DBH
0295: F600             OUT_OPCODE EQU    0D3H
0296: F600             JP_OPCODE  EQU    0C3H
0297: F600
0298: F600
0299: F600                        ORG    BIOSStart            ; Assemble code at BIOS address
0300: F600         ; BIOS jump Vector
0301: F600             CodeStart:
0302: F600
0303: F600 C3 40 F8               JP     BOOT                 ; 00 Cold/Hard Boot
0304: F603             WarmBootEntry:
0305: F603 C3 DD F8               JP     WBOOT                ; 01 Warm/Soft Boot
0306: F606 C3 20 F9               JP     CONST                ; 02 Get Console Status - CON:
0307: F609 C3 32 F9               JP     CONIN                ; 03 Get Character from Console - CON:
0308: F60C C3 3E F9               JP     CONOUT               ; 04 Send Character to Console - CON:
0309: F60F C3 54 F9               JP     LIST                 ; 05 Send Character to List device - LST:
0310: F612 C3 5F F9               JP     PUNCH                ; 06 Send Character to Punch device - PUN:
0311: F615 C3 6C F9               JP     READER               ; 07 Get Character from Reader - RDR:
0312: F618 C3 31 FA               JP     HOME                 ; 08 Position the disk to absolute track 00
0313: F61B C3 40 FA               JP     SELDSK               ; 09 Establish disk to be used by subsequent Read/Write
0314: F61E C3 6A FA               JP     SETTRK               ; 0A Establish track to be used by subsequent Read/Write
0315: F621 C3 6F FA               JP     SETSEC               ; 0B Establish sector to be used by subsequent Read/Write
0316: F624 C3 74 FA               JP     SETDMA               ; 0C Establish buffer location to be used by subsequent Read/Write
0317: F627 C3 7C FA               JP     READ                 ; 0D Not Yet Checked
0318: F62A C3 8F FA               JP     WRITE                ; 0E Not Yet Checked
0319: F62D C3 81 F9               JP     LISTST               ; 0F Get List device Status - LST:
0320: F630 C3 79 FA               JP     SECTRAN              ; 10 De-skew sector number (null implementation)
0321: F633
0322: F633         ;-------------------------------------------------
0323: F633                        ORG    (($+10H)/10H) * 10H
0324: F640
0325: F640             DiskBuffer:
0326: F640                        DS     diskSectorSize
0327: F840             AfterDiskBuffer EQU    $
0328: F840         ;-------------------------------------------------
0329: F840
0330: F840
0331: F840
0332: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0333: F840
0334: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0335: F840         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0336: F840         ;---------------------------------------------------------------------------
0337: F840         ;	BOOT:  BIOS 00		Hard Boot/Cold Boot
0338: F840
0339: F840         ;  The BOOT jump instruction is the first instruction executed in CP/M. The
0340: F840         ; bootstrap sequence must transfer control to the BOOT entry point in order to
0341: F840         ; bring up CP/M.
0342: F840         ;  This reads in the CP/M loader on the first sector of the physical disk drive
0343: F840         ; chosen to be logical disk A. This CP/M loader program reads the binary image
0344: F840         ; of the CCP, BOOS, and BIOS into memory at some predetermined address.
0345: F840         ; Then it transfers control to the BOOT entry point in the BIOS jump vector.
0346: F840         ;  This BOOT routine must initialize all of the required computer hardware.
0347: F840         ;
0348: F840         ; Most BOOT routines sign on by displaying a short message on the console,
0349: F840         ; indicating the current version ofCP/M and the computer hardware that this BIOS
0350: F840         ; can support. The BOOT routine terminates by transferring control to the start of the CCP
0351: F840         ; +6 bytes (the CCP has its own smalljump vector at the beginning). Just before the
0352: F840         ; BOOT routine jumps into the CCP, it sets the C register to 0 to indicate that logical
0353: F840         ; disk A is to be the default disk drive. This is what causes "A>" to be the CCP's
0354: F840         ; initial prompt.
0355: F840
0356: F840             BOOT:
0357: F840 21 63 F8               LD     HL,BootMessage
0358: F843 CD D2 F8               CALL   DisplayMessage
0359: F846
0360: F846 21 56 F8               LD     HL,BOOTControl
0361: F849 CD C0 F8               CALL   RawDiskRead
0362: F84C
0363: F84C C3 DD F8               JP     WBOOT                ; do Warm boot if no errors
0364: F84F 21 90 F8               LD     HL,BadBootMessage
0365: F852 CD D2 F8               CALL   DisplayMessage       ; Show Boot failure message
0366: F855 76                     HALT
0367: F856
0368: F856             BOOTControl:
0369: F856 01                     DB     DiskReadCode         ; Read function
0370: F857 00                     DB     00H                  ; unit number
0371: F858 00                     DB     00H                  ; head number
0372: F859 00                     DB     00H                  ; track number
0373: F85A 0D                     DB     0DH                  ; Starting sector number (13)
0374: F85B 00 0A                  DW     5 * 512              ; Number of bytes to read ( 0A00 All of BIOS)
0375: F85D 00 F6                  DW     BIOSStart            ; read into this address
0376: F85F 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0377: F861 40 00                  DW     DiskControlTable     ; pointer to next table- no linking
0378: F863
0379: F863
0380: F863         ;BOOTControl:
0381: F863         ; 	DB		DiskReadCode		; Read function
0382: F863         ; 	DB		00H					; unit number
0383: F863         ; 	DB		00H					; head number
0384: F863         ; 	DB		00H					; track number
0385: F863         ; 	DB		01H					; Starting sector number ()
0386: F863         ; 	DW		diskSectorSize		; Number of bytes to read ( 1 Sector)
0387: F863         ; 	DW		TPA					; read into this address
0388: F863         ; 	DW		DiskStatusLocation	; pointer to next block - no linking
0389: F863         ; 	DW		DiskControlTable	; pointer to next table- no linking
0390: F863
0391: F863         ; Boot Messages and routine
0392: F863             BootMessage:
0393: F863         ;	DB		'CP/M 2.2 (Z80) '
0394: F863         ;	DB		'BootStrap Loader'
0395: F863         ;	DB		CR,LF
0396: F863 42 75 69 6C 64 20 30 2E 41 20                DB     'Build 0.A '
0397: F86D 0D 0A                  DB     CR,LF
0398: F86F 43 43 50 20 30 2E 41 20 7C 20 20 42 44 4F 53 20 30 2E 41 20 7C 20 42 49 4F 53 20 30 2E 42                DB     'CCP 0.A |  BDOS 0.A | BIOS 0.B'
0399: F88D 0D 0A 00                DB     CR,LF,EndOfMessage
0400: F890             BadBootMessage:
0401: F890 0D 0A                  DB     CR,LF
0402: F892 2A 2A 2A 2A 20 20 20 42 6F 6F 74 20 46 61 69 6C 75 72 65                DB     '****   Boot Failure'
0403: F8A5 00                     DB     EndOfMessage
0404: F8A6             WarmBootErroMessage:
0405: F8A6 0D 0A                  DB     CR,LF
0406: F8A8 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'
0407: F8B3 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'
0408: F8BD 0D 0A 00                DB     CR,LF,EndOfMessage
0409: F8C0         ;..................Boot Support....................
0410: F8C0
0411: F8C0         ; Entered with DiskControlBlock pointer in HL
0412: F8C0             RawDiskRead:
0413: F8C0 22 46 00               LD     (DiskCommandBlock),HL
0414: F8C3
0415: F8C3 21 45 00               LD     HL,DiskControlByte
0416: F8C6 36 80                  LD     (HL),080H
0417: F8C8
0418: F8C8         ; wait for the read to complete
0419: F8C8             WaitForReadDone:
0420: F8C8 7E                     LD     A,(HL)
0421: F8C9 B7                     OR     A
0422: F8CA 20 FC                  JR     NZ,WaitForReadDone
0423: F8CC
0424: F8CC         ; is it a clean read ?
0425: F8CC 3A 43 00               LD     A,(DiskStatusLocation)
0426: F8CF FE 80                  CP     080H                 ; any errors NC = good read?
0427: F8D1 C9                     RET
0428: F8D2
0429: F8D2         ; entered with pointer to message in HL
0430: F8D2             DisplayMessage:
0431: F8D2 7E                     LD     A,M                  ; get  character
0432: F8D3 B7                     OR     A                    ; is it NULL
0433: F8D4 C8                     RET    Z                    ; return if it is NULL (00)
0434: F8D5 4F                     LD     C,A
0435: F8D6 E5                     PUSH   HL                   ; save the pointer
0436: F8D7 D3 EC                  OUT    TTY_DataPort
0437: F8D9 E1                     POP    HL                   ; retrieve the pointer
0438: F8DA 23                     INC    HL                   ; point at next character
0439: F8DB 18 F5                  JR     DisplayMessage
0440: F8DD
0441: F8DD         ;....................................................
0442: F8DD
0443: F8DD         ;---------------------------------------------------------------------------
0444: F8DD         ;	WBOOT:  BIOS 01		SoftBoot/Warm Boot
0445: F8DD         ;
0446: F8DD         ;  Unlike the "cold" bootstrap entry point, which executes only once, the WBOOT
0447: F8DD         ; or warm boot routine will be executed every time a program terminates by
0448: F8DD         ; jumping to location OOOOH, or whenever you type a CONTROL-C on the console as
0449: F8DD         ; the first character of an input line.
0450: F8DD         ;  The WBOOT routine is responsible for reloading the CCP into memory.
0451: F8DD         ; Programs often use all of memory up to the starting point of the BDOS, overwriting
0452: F8DD         ; the CCP in the process. The underlying philosophy is that while a program is
0453: F8DD         ; executing, the CCP is not needed, so the program can use the memory previously
0454: F8DD         ; occupied by the CCP. The CCP occupies 800H (2048) bytes ofmemory-and this
0455: F8DD         ; is frequently just enough to make the difference between a program that cannot
0456: F8DD         ; run and one that can.
0457: F8DD         ; A few programs that are self-contained and do not require the BDOS's
0458: F8DD         ; facilities will also overwrite the BDOS to get another 1600H (5632) bytes of
0459: F8DD         ; memory. Therefore, to be really safe, the WBOOT routine should read in both the
0460: F8DD         ; CCP and the BDOS. It also needs to set up the two JMPs at location OOOOH (to
0461: F8DD         ; WBOOT itself) and at location 0005H (to the BOOS). Location 0003H should be
0462: F8DD         ; set to the initial value of the 10BYTE if this is implemented in the BIOS.
0463: F8DD         ; As its last act, the WBOOT routine sets register C to indicate which logical disk
0464: F8DD         ; is to be selected (C= 0 for A, I for B, and so on). It then transfers control into the
0465: F8DD         ; CCP at the first instruction in order to restart the CCP.
0466: F8DD
0467: F8DD             WBOOT:
0468: F8DD 31 FF DF               LD     SP,CCPEntry-1        ; put stack at top of User area
0469: F8E0 21 13 F9               LD     HL,WBOOTControl      ; get the WBOOT Control Block
0470: F8E3 CD C0 F8               CALL   RawDiskRead          ; read CCP & BDOS
0471: F8E6 30 09                  JR     NC,LoadPage0         ; set up page 0 if good read
0472: F8E8
0473: F8E8 21 A6 F8               LD     HL,WarmBootErroMessage
0474: F8EB CD D2 F8               CALL   DisplayMessage       ; send bad warm boot message
0475: F8EE C3 DD F8               JP     WBOOT                ; keep trying
0476: F8F1
0477: F8F1
0478: F8F1         ; Set up page Zero
0479: F8F1             LoadPage0:
0480: F8F1 3E C3                  LD     A,JP_OPCODE          ; Get JP opCode
0481: F8F3
0482: F8F3 32 00 00               LD     (WarmBoot),A
0483: F8F6 21 03 F6               LD     HL,WarmBootEntry     ; Warm Boot entry point
0484: F8F9 22 01 00               LD     (WarmBoot+1),HL      ; Warm Boot Vector
0485: F8FC
0486: F8FC 32 05 00               LD     (BDOSE),A
0487: F8FF 21 06 E8               LD     HL,BDOSEntry         ; BDOS entry point
0488: F902 22 06 00               LD     (BDOSE+1),HL         ; BDOS Vector
0489: F905
0490: F905 01 80 00               LD     BC,DMABuffer         ; Default Disk Buffer
0491: F908 CD 74 FA               CALL   SETDMA               ; use normal BDOS  routine
0492: F90B FB                     EI                          ; Enable interrupts
0493: F90C
0494: F90C 3A 04 00               LD     A,(Pg0CurentDisk)    ; Let CCP know what disk is current
0495: F90F 4F                     LD     C,A
0496: F910 C3 00 E0               JP     CCPEntry             ; transfer control to CCP
0497: F913
0498: F913
0499: F913             WBOOTControl:
0500: F913 01                     DB     DiskReadCode         ; Read function
0501: F914 00                     DB     00H                  ; unit number
0502: F915 00                     DB     00H                  ; head number
0503: F916 00                     DB     00H                  ; track number
0504: F917 02                     DB     02H                  ; Starting sector number (skip cold boot sector)
0505: F918 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read ( rest of the head)
0506: F91A 00 E0                  DW     CCPEntry             ; read into this address
0507: F91C 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
0508: F91E 45 00                  DW     DiskControlByte      ; pointer to next table- no linking
0509: F920
0510: F920         ;---------------------------------------------------------------------------
0511: F920         ;	Console Status:		BIOS 02
0512: F920         ;
0513: F920         ;  CONST simply returns an indicator showing whether there is an incoming
0514: F920         ; character from the console device. The convention is that A = OFFH if a character
0515: F920         ; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
0516: F920         ; to reflect the contents of the A register - it is the contents that are important.
0517: F920         ; CONST is called by the CCP whenever the CCP is in the middle of an
0518: F920         ; operation that can be interrupted by pressing a keyboard character.
0519: F920         ;
0520: F920         ; The BDOS will call CONST if a program makes a Read Console Status
0521: F920         ; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
0522: F920         ; routine, CONIN
0523: F920
0524: F920             CONST:
0525: F920             ConStatus:
0526: F920 3A 03 00               LD     A,(IOBYTE)
0527: F923 DD 21 11 FA               LD     IX,CON_Vector
0528: F927
0529: F927             GenericInStatus:                      ; Entry point for generic input status
0530: F927 CD CD F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0531: F92A CD 9A F9               CALL   GetInStatus
0532: F92D B7                     OR     A
0533: F92E C8                     RET    Z                    ; 00 => No data pending
0534: F92F 3E FF                  LD     A,0FFH
0535: F931 C9                     RET                         ; OFFH => Data in Buffer
0536: F932         ;---------------------------------------------------------------------
0537: F932         ;	Console In:		BIOS 03
0538: F932         ;
0539: F932         ;  CONIN reads the next character from the console to the A register and sets the
0540: F932         ; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
0541: F932         ; until it detects A = OFFH. Only then will it input the data character and mask off
0542: F932         ; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
0543: F932         ; Read Console Byte function (B$CONIN, code 1).
0544: F932         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0545: F932
0546: F932         ; This is a blocking routine
0547: F932
0548: F932             CONIN:
0549: F932             ConIn:
0550: F932 CD 20 F9               CALL   ConStatus
0551: F935 28 FB                  JR     Z,ConIn              ; loop until there is some data to read
0552: F937         ; Call to ConStatus Sets up IX with Physical Table
0553: F937 DD 6E 06               LD     L,(IX+DataReadIndex)
0554: F93A DD 66 07               LD     H,(IX+(DataReadIndex+1))
0555: F93D E9                     JP     (HL)
0556: F93E         ;---------------------------------------------------------------------------
0557: F93E         ;	Console Out:		BIOS 04
0558: F93E         ;
0559: F93E         ;  CONOUT outputs the character (in ASCII) in register C to the console. The
0560: F93E         ; most significant (parity) bit of the character will always be O.
0561: F93E         ; CONOUT must first check that the console device is ready to receive more
0562: F93E         ; data, delaying if necessary until it is, and only then sending the character to the
0563: F93E         ; device. CONOUT is called by the CCP and by the BDOS when a program executes a
0564: F93E         ; Write Console Byte function (B$CONOUT, code 2).
0565: F93E
0566: F93E         ; This is a blocking routine
0567: F93E
0568: F93E             CONOUT:
0569: F93E             CONOut:
0570: F93E 3A 03 00               LD     A,(IOBYTE)
0571: F941 DD 21 11 FA               LD     IX,CON_Vector
0572: F945
0573: F945             GenericOutStatus:                      ; entry point for standard blocking write
0574: F945 CD CD F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0575: F948             GenericOutStatus1:
0576: F948 CD 95 F9               CALL   GetOutStatus
0577: F94B 28 FB                  JR     Z,GenericOutStatus1  ; wait until ready
0578: F94D DD 6E 08               LD     L,(IX+DataWriteIndex)
0579: F950 DD 66 09               LD     H,(IX+(DataWriteIndex+1))
0580: F953 E9                     JP     (HL)
0581: F954
0582: F954         ;---------------------------------------------------------------------------
0583: F954         ;	List output  BIOS 05
0584: F954         ;
0585: F954         ; LIST is similar to CONOUT except that it sends the character in register C to
0586: F954         ; the list device. It too checks first that the list device is ready to receive
0587: F954         ; the character. LIST is called by the CCP in response to the CONTROL-P toggle
0588: F954         ; for printer echo of console output, and by the BDOS when a program makes a
0589: F954         ; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).
0590: F954
0591: F954         ; This is a blocking routine
0592: F954
0593: F954             LIST:
0594: F954 3A 03 00               LD     A,(IOBYTE)
0595: F957 07                     RLCA                        ; move bits 7,6
0596: F958 07                     RLCA                        ; to 1,0
0597: F959 DD 21 29 FA               LD     IX,LST_Vector
0598: F95D 18 E6                  JR     GenericOutStatus     ; go to generic blocking out routine
0599: F95F
0600: F95F         ;---------------------------------------------------------------------------
0601: F95F         ;	Punch output  BIOS 06
0602: F95F         ;
0603: F95F         ;  PUNCH sends the character in register C to the "punch" device. As mentioned
0604: F95F         ; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
0605: F95F         ; entry point either returns immediately and is effectively a null routine, or it outputs
0606: F95F         ; the character to a communications device, such as a modem, on your computer.
0607: F95F         ; PUNCH must check that the "punch" device is indeed ready to accept another
0608: F95F         ; character for output, and must wait if it is not.
0609: F95F         ;
0610: F95F         ; Digital Research's documentation states that the character to be output will
0611: F95F         ; always have its most significant bit set to O. This is not true. The BDOS simply
0612: F95F         ; transfers control over to the PUNCH entry point in the BIOS; the setting of the
0613: F95F         ; most significant bit will be determined by the program making the BDOS function
0614: F95F         ; request (B$PUNOUT, code 4). This is important because the requirement of a zero
0615: F95F         ; would preclude being able to send pure binary data via the BIOS PUNCH
0616: F95F         ; function
0617: F95F
0618: F95F         ; This is a blocking routine
0619: F95F
0620: F95F             PUNCH:                          ; Punch output
0621: F95F 3A 03 00               LD     A,(IOBYTE)
0622: F962 0F                     RRCA
0623: F963 0F                     RRCA
0624: F964 0F                     RRCA                        ; move bits 5,4
0625: F965 0F                     RRCA                        ; to 1,0
0626: F966 DD 21 21 FA               LD     IX,PUN_Vector
0627: F96A 18 D9                  JR     GenericOutStatus     ; go to generic blocking out routine
0628: F96C
0629: F96C         ;---------------------------------------------------------------------------
0630: F96C         ;	Reader input  BIOS 07
0631: F96C         ;
0632: F96C         ; As with the PUNCH entry point, the READER entry point rarely connects to
0633: F96C         ; a real paper tape reader.
0634: F96C         ; The READER function must return the next character from the reader device
0635: F96C         ; in the A register, waiting, if need be, until there is a character.
0636: F96C         ;
0637: F96C         ; Digital Research's documentation again says that the most significant bit of
0638: F96C         ; the A register must be 0, but this is not the case if you wish to receive pure binary
0639: F96C         ; information via this function.
0640: F96C         ; READER is called whenever a program makes a Read "Reader" Byte function
0641: F96C         ; request (B$READIN, code 3).
0642: F96C
0643: F96C         ; This is a blocking routine
0644: F96C
0645: F96C             READER:                         ; Reader Input
0646: F96C 3A 03 00               LD     A,(IOBYTE)
0647: F96F 0F                     RRCA
0648: F970 0F                     RRCA                        ; move bits 3,2  to 1,0
0649: F971 DD 21 19 FA               LD     IX,RDR_Vector
0650: F975             READER1:
0651: F975 CD 27 F9               CALL   GenericInStatus
0652: F978 28 FB                  JR     Z,READER1            ; loop until there is some data to read
0653: F97A
0654: F97A DD 6E 06               LD     L,(IX+DataReadIndex)
0655: F97D DD 66 07               LD     H,(IX+(DataReadIndex+1))
0656: F980 E9                     JP     (HL)
0657: F981
0658: F981         ;---------------------------------------------------------------------------
0659: F981         ;	List Status:  BIOS 0F
0660: F981
0661: F981         ;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
0662: F981         ; This function returns the current status of the list device, using the IOBYTE if
0663: F981         ; necessary to select the correct physical device. It sets the A register to OFFH if the
0664: F981         ; list device can accept another character for output or to OOH if it is not ready.
0665: F981         ; Digital Research's documentation states that this function is used by the
0666: F981         ; DESPOOL utility program (which allows you to print a file "simultaneously" with
0667: F981         ; other operations) to improve console response during its operation, and that it is
0668: F981         ; acceptable for the routine always to return OOH if you choose not to implement it
0669: F981         ; fully.
0670: F981         ; Unfortunately, this statement is wrong. Many other programs use the LISTST
0671: F981         ; function to "poll" the list device to make sure it is ready, and if it fails to come
0672: F981         ; ready after a predetermined time, to output a message to the console indicating
0673: F981         ; that the printer is not ready. If you ever make a call to the BDOS list output
0674: F981         ; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
0675: F981         ; not ready, then CP/M will wait forever-and your program will have lost control
0676: F981         ; so it cannot even detect that the problem has occurred. If LISTST always returns a
0677: F981         ; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
0678: F981         ; out of the LISTST function, but it also causes a stream of false "Printer
0679: F981         ; not Ready" error messages to appear on the console.
0680: F981
0681: F981             LISTST:
0682: F981 3A 03 00               LD     A,(IOBYTE)           ; Get Physical device
0683: F984 07                     RLCA
0684: F985 07                     RLCA                        ; Move bits 6 & 7 to bits 0 & 1
0685: F986 DD 21 29 FA               LD     IX,LST_Vector        ; Set th vector base
0686: F98A CD CD F9               CALL   SetDeviceVector      ; IX has the vector for the Physical Device
0687: F98D CD 95 F9               CALL   GetOutStatus
0688: F990
0689: F990 B7                     OR     A
0690: F991 C8                     RET    Z                    ; 00 => Device Ready
0691: F992 3E FF                  LD     A,0FFH
0692: F994 C9                     RET                         ; OFFH => Device No Ready
0693: F995
0694: F995         ;---------------------------------------------------------------------------
0695: F995
0696: F995         ;---------------------------------------------------------------------
0697: F995             GetOutStatus:
0698: F995         ; vector to CON Devices
0699: F995 DD 56 02               LD     D,(IX+OutputMaskIndex) ; setup Output mask
0700: F998 18 03                  JR     GetStatus
0701: F99A             GetInStatus:
0702: F99A DD 56 03               LD     D,(IX+InputMaskIndex) ; setup Input mask
0703: F99D             GetStatus:
0704: F99D DD 6E 04               LD     L,(IX+StatusReadIndex)
0705: F9A0 DD 66 05               LD     H,(IX+(StatusReadIndex+1)) ; Load HL with address for Status Read
0706: F9A3 E9                     JP     (HL)                 ; jump to the stats read routine
0707: F9A4
0708: F9A4         ;---------------------------------------------------------------------
0709: F9A4
0710: F9A4             DataRead:
0711: F9A4 DD 7E 01               LD     A,(IX+DataPortIndex)
0712: F9A7 32 AB F9               LD     (AddressDataIn),A    ; modify code with the Data port
0713: F9AA DB                     DB     IN_OPCODE
0714: F9AB             AddressDataIn:
0715: F9AB 00                     DB     00                   ; perform the read
0716: F9AC C9                     RET
0717: F9AD
0718: F9AD             DataReadASCII:
0719: F9AD CD A4 F9               CALL   DataRead
0720: F9B0 E6 7F                  AND    ASCII_MASK           ; Strip off MSB
0721: F9B2 C9                     RET                         ; AND		ASCII_MASK
0722: F9B3
0723: F9B3         ; Enter DataWrite the value to be output in C
0724: F9B3             DataWrite:
0725: F9B3 DD 7E 01               LD     A,(IX+DataPortIndex)
0726: F9B6 32 BB F9               LD     (AddressDataOut),A   ; modify code with the Data port
0727: F9B9 79                     LD     A,C                  ; get value into ACC
0728: F9BA D3                     DB     OUT_OPCODE
0729: F9BB             AddressDataOut:
0730: F9BB 00                     DB     00                   ; perform the write
0731: F9BC C9                     RET
0732: F9BD
0733: F9BD
0734: F9BD         ; Enter Status Read with Target mask in D
0735: F9BD             StatusRead:
0736: F9BD DD 7E 00               LD     A,(IX+StatusPortIndex)
0737: F9C0 32 C4 F9               LD     (AddressStatus),A    ; modify code with the status port
0738: F9C3 DB                     DB     IN_OPCODE
0739: F9C4             AddressStatus:
0740: F9C4 00                     DB     00
0741: F9C5 A2                     AND    D                    ; Check return vale with the mask
0742: F9C6 C9                     RET
0743: F9C7
0744: F9C7             DUMMYRead:
0745: F9C7 C9                     RET
0746: F9C8             DUMMYWrite:
0747: F9C8 C9                     RET
0748: F9C9             DUMMYCheck:
0749: F9C9 3E FF                  LD     A,0FFH               ; Always return 0FFH
0750: F9CB B7                     OR     A                    ; Set flags
0751: F9CC C9                     RET
0752: F9CD
0753: F9CD         ;=============================================================================
0754: F9CD             SetDeviceVector:
0755: F9CD E6 03                  AND    03H                  ; Get bits 0 & 1;
0756: F9CF 87                     ADD    A,A                  ; Double for word size index
0757: F9D0 16 00                  LD     D,00H
0758: F9D2 5F                     LD     E,A                  ; load byte index int DE
0759: F9D3 DD 19                  ADD    IX,DE                ; add to the value vector base
0760: F9D5         ; IX points at correct entry in vector
0761: F9D5 DD 5E 00               LD     E,(IX+0)
0762: F9D8 DD 56 01               LD     D,(IX+1)             ; DE now has the Vector for the device
0763: F9DB D5                     PUSH   DE
0764: F9DC DD E1                  POP    IX                   ; Move it to IX
0765: F9DE C9                     RET
0766: F9DF
0767: F9DF
0768: F9DF         ;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0769: F9DF         ; Physical Device Attributes
0770: F9DF
0771: F9DF             TTY_StatusPort EQU    0EDH
0772: F9DF             TTY_DataPort EQU    0ECH
0773: F9DF             TTY_OutputMask EQU    80H                  ; Status Mask
0774: F9DF             TTY_InputMask EQU    7FH                  ; Status Mask
0775: F9DF
0776: F9DF             CRT_StatusPort EQU    02H
0777: F9DF             CRT_DataPort EQU    01H
0778: F9DF             CRT_OutputMask EQU    80H                  ; Status Mask - ready for output
0779: F9DF             CRT_InputMask EQU    07FH                 ; Status Mask - bytes yet to have been read
0780: F9DF
0781: F9DF             COM_StatusPort EQU    0EDH
0782: F9DF             COM_DataPort EQU    0ECH
0783: F9DF             COM_OutputMask EQU    01H                  ; Status Mask
0784: F9DF             COM_InputMask EQU    02H                  ; Status Mask
0785: F9DF
0786: F9DF             LPT_StatusPort EQU    011H
0787: F9DF             LPT_DataPort EQU    010H
0788: F9DF             LPT_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0789: F9DF             LPT_InputMask EQU    07FH                 ; Status Mask - not used
0790: F9DF
0791: F9DF             DUMMY_StatusPort EQU    011H
0792: F9DF             DUMMY_DataPort EQU    010H
0793: F9DF             DUMMY_OutputMask EQU    0FFH                 ; Status Mask - ready for output
0794: F9DF             DUMMY_InputMask EQU    07FH                 ; Status Mask - not used
0795: F9DF
0796: F9DF         ; Device Table Control Block Definition
0797: F9DF             StatusPortIndex EQU    0
0798: F9DF             DataPortIndex EQU    1
0799: F9DF             OutputMaskIndex EQU    2
0800: F9DF             InputMaskIndex EQU    3
0801: F9DF             StatusReadIndex EQU    4
0802: F9DF             DataReadIndex EQU    6
0803: F9DF             DataWriteIndex EQU    8
0804: F9DF
0805: F9DF         ;Physical Devices Control Blocks
0806: F9DF
0807: F9DF             TTY_Table:
0808: F9DF ED                     DB     TTY_StatusPort
0809: F9E0 EC                     DB     TTY_DataPort
0810: F9E1 80                     DB     TTY_OutputMask
0811: F9E2 7F                     DB     TTY_InputMask
0812: F9E3 BD F9                  DW     StatusRead
0813: F9E5 AD F9                  DW     DataReadASCII
0814: F9E7 B3 F9                  DW     DataWrite
0815: F9E9
0816: F9E9             CRT_Table:
0817: F9E9 02                     DB     CRT_StatusPort
0818: F9EA 01                     DB     CRT_DataPort
0819: F9EB 80                     DB     CRT_OutputMask
0820: F9EC 7F                     DB     CRT_InputMask
0821: F9ED BD F9                  DW     StatusRead
0822: F9EF A4 F9                  DW     DataRead
0823: F9F1 B3 F9                  DW     DataWrite
0824: F9F3             COM_Table:
0825: F9F3 ED                     DB     COM_StatusPort
0826: F9F4 EC                     DB     COM_DataPort
0827: F9F5 01                     DB     COM_OutputMask
0828: F9F6 02                     DB     COM_InputMask
0829: F9F7 BD F9                  DW     StatusRead
0830: F9F9 A4 F9                  DW     DataRead
0831: F9FB B3 F9                  DW     DataWrite
0832: F9FD             LPT_Table:
0833: F9FD 11                     DB     LPT_StatusPort
0834: F9FE 10                     DB     LPT_DataPort
0835: F9FF FF                     DB     LPT_OutputMask
0836: FA00 7F                     DB     LPT_InputMask
0837: FA01 BD F9                  DW     StatusRead
0838: FA03 A4 F9                  DW     DataRead
0839: FA05 B3 F9                  DW     DataWrite
0840: FA07             DUMMY_Table:
0841: FA07 11                     DB     DUMMY_StatusPort
0842: FA08 10                     DB     DUMMY_DataPort
0843: FA09 FF                     DB     DUMMY_OutputMask
0844: FA0A 7F                     DB     DUMMY_InputMask
0845: FA0B C9 F9                  DW     DUMMYCheck
0846: FA0D C7 F9                  DW     DUMMYRead
0847: FA0F C8 F9                  DW     DUMMYWrite
0848: FA11
0849: FA11         ;---------------------------------------------------------------------------
0850: FA11
0851: FA11         ; Logical Device Vector, Controlled by IOBYTE
0852: FA11
0853: FA11             CON_Vector:                      ; IOBYTE bits 1 & 0
0854: FA11 DF F9                  DW     TTY_Table
0855: FA13 E9 F9                  DW     CRT_Table
0856: FA15 F3 F9                  DW     COM_Table
0857: FA17 07 FA                  DW     DUMMY_Table
0858: FA19             RDR_Vector:                      ; IOBYTE bits 3 & 2
0859: FA19 DF F9                  DW     TTY_Table
0860: FA1B E9 F9                  DW     CRT_Table
0861: FA1D 07 FA                  DW     DUMMY_Table
0862: FA1F 07 FA                  DW     DUMMY_Table
0863: FA21             PUN_Vector:                      ; IOBYTE bits 5 & 4
0864: FA21 DF F9                  DW     TTY_Table
0865: FA23 07 FA                  DW     DUMMY_Table
0866: FA25 F3 F9                  DW     COM_Table
0867: FA27 E9 F9                  DW     CRT_Table
0868: FA29             LST_Vector:                      ; IOBYTE bits 7 & 6
0869: FA29 FD F9                  DW     LPT_Table
0870: FA2B E9 F9                  DW     CRT_Table
0871: FA2D FD F9                  DW     LPT_Table
0872: FA2F 07 FA                  DW     DUMMY_Table
0873: FA31
0874: FA31         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0875: FA31         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0876: FA31
0877: FA31         ;---------------------------------------------------------------------------
0878: FA31         ;	Disk routines
0879: FA31         ;---------------------------------------------------------------------------
0880: FA31
0881: FA31         ;  All of the disk functions that follow were originally designed to operate on the
0882: FA31         ; 128-byte sectors used on single-sided, single-density, 8-inch floppy diskettes that
0883: FA31         ; were standard in the industry at the time. Now that CP/M runs on many different
0884: FA31         ; types of disks, some of the BIOS disk functions seem strange because most of the
0885: FA31         ; new disk drives use sector sizes other than 128 bytes.
0886: FA31         ; To handle larger sector sizes, the BIOS has some additional code that makes
0887: FA31         ; the BDOS respond as if it were still handling 128-byte sectors. This code is referred
0888: FA31         ; to as the blocking/deblocking code.
0889: FA31         ;  As its name implies, it blocks together several 128-byte "sectors" and only writes
0890: FA31         ; to the disk when a complete physical sector has been assembled.
0891: FA31         ;  When reading, it reads in a physical sector and then deblocks it,handing back
0892: FA31         ; several 128-byte "sectors" to the BDOS.
0893: FA31         ;  To do all of this, the blocking/deblocking code uses a special buffer area of the
0894: FA31         ; same size as the physical sectors on the disk. This is known as the host disk buffer
0895: FA31         ; or HSTBUE Physical sectors are read into this buffer and written to the disk
0896: FA31         ; from it. In order to optimize this blocking/deblocking routine, the BIOS has code in it
0897: FA31         ; to reduce the number of times that an actual disk read or write occurs. A side effect
0898: FA31         ; is that at any given moment, several 128-byte "sectors" may be stored in the
0899: FA31         ; HSTBUF, waiting to be written out to the disk when HSTBUF becomes full. This
0900: FA31         ; sometimes complicates the logic of the BIOS disk functions. You cannot simply
0901: FA31         ; select a new disk drive, for example, when the HSTBUF contains data destined for
0902: FA31         ; another disk drive. You will see this complication in the BIOS only in the form of
0903: FA31         ; added logical operations; the BIOS disk functions rarely trigger immediate physical
0904: FA31         ; operations. It is easier to understand these BIOS functions if you consider that
0905: FA31         ; they make requests-and that these requests are satisfied only when it makes
0906: FA31         ; sense to do so, taking into account the blocking/ deblocking logic.
0907: FA31
0908: FA31         ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0909: FA31         ;---------------------------------------------------------------------------
0910: FA31
0911: FA31         ;---------------------------------------------------------------------------
0912: FA31         ;	Home Disk	BIOS 08
0913: FA31         ;
0914: FA31         ;  HOME - Home the selected logical disk to track 0. Before doing this, a check
0915: FA31         ; must be made to see if the physical disk buffer has information that must be
0916: FA31         ; written out. This is indicated by a flag, DirtyBufferFlag,set in the de-blocking code
0917: FA31
0918: FA31             HOME:
0919: FA31 3A DF FB               LD     A,(DirtyBufferFlag)  ; Check for Dirty Buffer
0920: FA34 B7                     OR     A
0921: FA35 20 03                  JR     NZ,HomeNoWrite
0922: FA37 32 DE FB               LD     (DataInBufferFlag),A ; Clear DataInBufferFlag if Buffer not dirty
0923: FA3A             HomeNoWrite:
0924: FA3A 0E 00                  LD     C,00H                ; Set to track 0
0925: FA3C CD 6A FA               CALL   SETTRK               ; no, physical, only logical
0926: FA3F C9                     RET
0927: FA40
0928: FA40         ;---------------------------------------------------------------------------
0929: FA40         ;	Select Disk	BIOS 09
0930: FA40
0931: FA40         ;  SELDSK does not do what its name implies. It does not (and must not)
0932: FA40         ; physically select a logical disk. Instead, it returns a pointer in the
0933: FA40         ; HL register pair to the disk parameter header for the logical disk specified
0934: FA40         ; in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK also
0935: FA40         ; stores this code for the requested disk to be used later in the READ and WRITE functions.
0936: FA40         ; If the logical disk code in register C refers to a nonexistent disk or to one for
0937: FA40         ; which no disk parameter header exists, then SELDSK must return with HL set to
0938: FA40         ; OOOOH. Then the BDOS will output a message of the form "BDOS Err on XI Select"
0939: FA40         ; Note that SELDSK not only does not select the disk, but also does not indicate
0940: FA40         ; whether or not the requested disk is physically present -merely whether or not
0941: FA40         ; there are disk tables present for the disk.
0942: FA40         ;  SELDSK is called by the BDOS either during disk file operations or by a
0943: FA40         ; program issuing a Select Disk request (B$SELDSK, code 14).
0944: FA40
0945: FA40             SELDSK:
0946: FA40 21 00 00               LD     HL,00H               ; Assume an error
0947: FA43 79                     LD     A,C
0948: FA44 FE 04                  CP     NumberOfLogicalDisks
0949: FA46 D0                     RET    NC                   ; return if > max number of Disks
0950: FA47
0951: FA47 32 E1 FB               LD     (SelectedDisk),A     ; save disk number
0952: FA4A
0953: FA4A 07                     RLCA                        ; X2
0954: FA4B 07                     RLCA                        ; X4
0955: FA4C 07                     RLCA                        ; X8
0956: FA4D 07                     RLCA                        ; X16
0957: FA4E 16 00                  LD     D,0
0958: FA50 5F                     LD     E,A                  ; put index int DE
0959: FA51 DD 21 F0 FB               LD     IX,DiskParameterHeaders ; get DPH address Base
0960: FA55 DD 19                  ADD    IX,DE                ; get the specific DiskParameterHeader
0961: FA57 DD E5                  PUSH   IX                   ; save for return in HL
0962: FA59
0963: FA59 DD 56 0B               LD     D,(IX+11)            ; LSB for Disk Parameter Block
0964: FA5C DD 5E 0A               LD     E,(IX+10)            ; MSB for Disk Parameter Block
0965: FA5F
0966: FA5F D5                     PUSH   DE
0967: FA60 DD E1                  POP    IX
0968: FA62 DD 7E 0F               LD     A,(IX+15)            ; Disk Parameter Block in IY
0969: FA65 32 E0 FB               LD     (SelectedDskSecsPerHead),A
0970: FA68
0971: FA68 E1                     POP    HL                   ; recover DPH pointer
0972: FA69 C9                     RET
0973: FA6A
0974: FA6A
0975: FA6A
0976: FA6A         ;---------------------------------------------------------------------------
0977: FA6A         ;	Set Track	BIOS 0A
0978: FA6A
0979: FA6A         ;  SETTRK saves the requested disk track that is in the BC register pair when
0980: FA6A         ; SETTRK gets control. Note that this is an absolute track number; that is, the
0981: FA6A         ; number of reserved tracks before the file directory will have been added to the
0982: FA6A         ; track number relative to the start of the logical disk.
0983: FA6A         ;  The number of the requested track will be used in the next BIOS READ or
0984: FA6A         ; WRITE function.
0985: FA6A         ;  SETTRK is called by the BDOS when it needs to read or write a 128-byte
0986: FA6A         ; sector. Legitimate track numbers are from 0 to OFFFFH (65,535).
0987: FA6A
0988: FA6A             SETTRK:
0989: FA6A         ;	LD		H,B								; select track in BC on entry
0990: FA6A         ;	LD		L,C
0991: FA6A         ;	LD	(SelectedTrack),HL					; save for low level driver
0992: FA6A ED 43 E2 FB               LD     (SelectedTrack),BC   ; save for low level driver
0993: FA6E C9                     RET
0994: FA6F
0995: FA6F         ;---------------------------------------------------------------------------
0996: FA6F         ;	Set Sector	BIOS 0B  (Set Record)
0997: FA6F
0998: FA6F         ; Sector  = Record for disk with 128 byte sectors
0999: FA6F         ; Sector contains 4 records for disks with 512 byte sectors
1000: FA6F         ; this routine is missed named it should be called Set Record
1001: FA6F
1002: FA6F         ;  SETSEC is similar to SETTRK in that it stores the requested Record (sector) number
1003: FA6F         ; for later use in BIOS READ or WRITE functions. The requested Record (sector) number is
1004: FA6F         ; handed to SETSEC in the A register; legitimate values are from 0 to OFFH (255).
1005: FA6F         ; The Record (sector) number is a logical Record (sector) number. It does not take into account any
1006: FA6F         ; sector skewing that might be used to improve disk performance.
1007: FA6F         ;  SETSEC is called by the BDOS when it needs to read or write a 128-byte
1008: FA6F         ; Record (sector).
1009: FA6F
1010: FA6F             SETSEC:                         ; SETRECORD
1011: FA6F 79                     LD     A,C
1012: FA70 32 E4 FB               LD     (SelectedRecord),A   ; save for low level driver
1013: FA73 C9                     RET
1014: FA74
1015: FA74         ;---------------------------------------------------------------------------
1016: FA74         ;	Set Sector	BIOS 0C
1017: FA74
1018: FA74         ;  SETDMA saves the address in the BC register pair in the requested DMA
1019: FA74         ; address. The next BIOS READ or WRITE function will use the DMA address as
1020: FA74         ; a pointer to the 128-byte sector buffer into which data will be read or from which
1021: FA74         ; data will be written.
1022: FA74         ;  The default DMA address is 0080H. SETDMA is called by the BDOS when it
1023: FA74         ; needs to READ or WRITE a 128-byte sector.
1024: FA74
1025: FA74             SETDMA:
1026: FA74 ED 43 E5 FB               LD     (DMAAddress),BC      ; save for low level driver
1027: FA78 C9                     RET
1028: FA79
1029: FA79         ;---------------------------------------------------------------------------
1030: FA79         ;	Sector Translate	BIOS 10
1031: FA79
1032: FA79         ;  SECTRAN, given a logical sector number, locates the correct physical sector
1033: FA79         ; number in the sector translate table for the previously selected (via SELDSK)
1034: FA79         ; logical disk drive. Note that both logical and physical sector numbers are
1035: FA79         ; l28-byte sectors, so if you are working with a hard disk system, it is not
1036: FA79         ; too efficient to impose a sector interlace at the l28-byte sector level.
1037: FA79         ; It is better to impose the sector interlace right inside the hard disk driver,
1038: FA79         ; if at all. In general, hard disks spin so rapidly that CP/M simply cannot take
1039: FA79         ; advantage of sector interlace.
1040: FA79         ;  The BDOS hands over the logical sector number in the BC register pair, with
1041: FA79         ; the address of the sector translate table in the DE register pair. SECTRAN must
1042: FA79         ; return the physical sector number in HL.
1043: FA79         ;  If SECTRAN is to be a null routine, it must move the contents of BC to HL
1044: FA79         ; and return.
1045: FA79
1046: FA79             SECTRAN:
1047: FA79 C5                     PUSH   BC
1048: FA7A E1                     POP    HL                   ; just move the value from BC to HL
1049: FA7B C9                     RET
1050: FA7C
1051: FA7C         ;---------------------------------------------------------------------------
1052: FA7C         ;	READ			BIOS 0D
1053: FA7C
1054: FA7C         ;  READ reads in a 128-byte sector provided that there have been previous BIOS
1055: FA7C         ; function calls to:
1056: FA7C         ; 				- SELDSK	"select" the disk
1057: FA7C         ; 				- SETDMA	set the DMA address
1058: FA7C         ; 				- SETTRK	set the track number
1059: FA7C         ; 				- SETSEC	set the sector number.
1060: FA7C         ;
1061: FA7C         ; Because of the blocking/ deblocking code in the BIOS, there are frequent occasions
1062: FA7C         ; when the requested sector will already be in the host buffer (HSTBUF), so that a
1063: FA7C         ; physical disk read is not required. All that is then required is for the BIOS to move
1064: FA7C         ; the appropriate 128 bytes from the HSTBUF into the buffer pointed at by the DMA address.
1065: FA7C         ; Only during the READ function will the BIOS normally communicate with the physical disk
1066: FA7C         ; drive, selecting it and seeking to read the requested track and sector. During this process,
1067: FA7C         ; the READ function must also handle any hardware errors that occur, trying an operation again
1068: FA7C         ; if a "soft," or recoverable, error occurs.
1069: FA7C         ;  The READ function must return with the A register set to OOH if the read operation has completed
1070: FA7C         ; successfully. If the READ function returns with the A register set to 01 H, the BDOS will
1071: FA7C         ; display an error message of the form BDOS Err on X: Bad Sector. Under these circumstances,
1072: FA7C         ; you have only two choices. You can enter a CARRIAGE RETURN, ignore the fact that there was an
1073: FA7C         ; error, and attempt to make sense of the data in the DMA buffer. Or you can type a CONTROL-C
1074: FA7C         ; to abort the operation, perform a warm boot, and return control to the CCP. As you can see,
1075: FA7C         ; CP/M's error handling is not particularly helpful, so most BIOS writers add more sophisticated
1076: FA7C         ; error recovery right in the disk driver. This can include some interaction with the console so
1077: FA7C         ; that a more determined effort can be made to correct errors or, if nothing else, give you more
1078: FA7C         ; information as to what has gone wrong. Such error handling is discussed in Chapter 9.
1079: FA7C         ;  If you are working with a hard disk system, the BIOS driver must also handle the management of
1080: FA7C         ; bad sectors. You cannot simply replace a hard disk drive if one or two sectors become unreadable.
1081: FA7C         ; This bad sector management normally requires that a directory of "spare" sectors be put on the
1082: FA7C         ; hard disk before it is used to store data. Then, when a sector is found to be bad,
1083: FA7C         ; one of the spare sectors is substituted in its place.
1084: FA7C
1085: FA7C             READ:
1086: FA7C AF                     XOR    A
1087: FA7D 32 EC FB               LD     (ModifiedlRecordsCount),A ; 1. Set ModifiedlRecordsCount to 0
1088: FA80 3C                     INC    A
1089: FA81 32 EF FB               LD     (ReadWriteFlag),A    ; 2. Set to Flag to read (non-zero)
1090: FA84 32 EE FB               LD     (PrereadSectorFlag),A ; 3. Force a preread
1091: FA87 3E 02                  LD     A,WriteCleanBuffer
1092: FA89 32 D9 FB               LD     (WriteType),A        ; 4. Fake a clean sector Write type = 02
1093: FA8C C3 BF FA               JP     CommonDiskIO         ; Use common code to execute read
1094: FA8F         ;---------------------------------------------------------------------------
1095: FA8F         ;	WRITE			BIOS 0E
1096: FA8F         ;
1097: FA8F         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
1098: FA8F         ;
1099: FA8F         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
1100: FA8F         ;	00H [WriteAllocated]	An already allocated allocation block (which means a pre-read of the sector may be needed),
1101: FA8F         ;	01H [WriteDirectory]	To the directory (in which case the data will be written to the disk immediately),
1102: FA8F         ;	02H [WriteCleanBuffer]	To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
1103: FA8F
1104: FA8F         ;  WRITE is similar to READ but with the obvious difference that data is transferred from the DMA buffer
1105: FA8F         ; to the specified 128-byte sector. Like READ, this function requires that the following function calls
1106: FA8F         ; have already been made:
1107: FA8F         ; 				- SELDSK	"select" the disk
1108: FA8F         ; 				- SETDMA	set the DMA address
1109: FA8F         ; 				- SETTRK	set the track number
1110: FA8F         ; 				- SETSEC	set the sector number.
1111: FA8F         ;
1112: FA8F         ;  Again, it is only in the WRITE routine that the driver will start to talk directly to the physical hardware,
1113: FA8F         ; selecting the disk unit, track, and sector, and transferring the data to the disk. With the blocking/deblocking code,
1114: FA8F         ; the BDOS optimizes the number of disk writes that are needed by indicating in register C the type of disk write
1115: FA8F         ; that is to be performed:
1116: FA8F         ; 				0= normal sector write
1117: FA8F         ; 				1= write to file directory sector
1118: FA8F         ; 				2 = write to sector of previously unchanged Deblocking Buffer
1119: FA8F         ;
1120: FA8F         ;  Type 0 occurs whenever the BDOS is writing to a data sector in an already used allocation block.
1121: FA8F         ; Under these circumstances, the disk driver must preread the appropriate host sector because there
1122: FA8F         ; may be previously stored information on it.
1123: FA8F         ;
1124: FA8F         ;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in this case, the BIOS must not defer
1125: FA8F         ; writing the sector to the disk, as the information is too valuable to hold in memory until the HSTBUF is full.
1126: FA8F         ; The longer the information resides in the HSTBUF, the greater the chance of a power failure or glitch,
1127: FA8F         ; making file data already physically written to the disk inaccessible because the file directory is out of date.
1128: FA8F         ;
1129: FA8F         ;  Type 2 occurs whenever the BOOS needs to write to the first sector of a previously unused allocation block.
1130: FA8F         ; Unused, in this context, includes an allocation block that has become available as a result of a file being erased.
1131: FA8F         ; In this case, there is no need for the disk driver to preread an entire host-sized sector into the HSTBUF,
1132: FA8F         ; as there is no data of value in the physical sector.
1133: FA8F         ;
1134: FA8F         ;  As with the READ routine, the WRITE function returns with A set to OOH if the operation has been completed successfully.
1135: FA8F         ; If the WRITE function returns with A set to 01H, then the BDOS will display the same message as for READ:
1136: FA8F         ; BDOS Err on X: Bad Sector
1137: FA8F
1138: FA8F
1139: FA8F             WRITE:
1140: FA8F         ; BlockingBuffer I/O
1141: FA8F AF                     XOR    A
1142: FA90 32 EF FB               LD     (ReadWriteFlag),A    ; Set to zero to indicate that this is a Write
1143: FA93 79                     LD     A,C
1144: FA94 32 D9 FB               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
1145: FA97
1146: FA97 FE 02                  CP     WriteCleanBuffer     ; first, is this a clean Host Buffer block ?
1147: FA99 C2 A7 FA               JP     NZ,CheckDirtyBuffer  ; No
1148: FA9C
1149: FA9C         ;Write from a clean Host Buffer
1150: FA9C         ;?	LD		A,RecordsPerBlock			; Number of records per Block
1151: FA9C         ;?	LD		(ModifiedlRecordsCount),A 	; reset Modified Records Count to RecordsPerBlock
1152: FA9C
1153: FA9C 21 E1 FB               LD     HL,SelectedState
1154: FA9F 11 E8 FB               LD     DE,HostBufferState
1155: FAA2 01 04 00               LD     BC,SelectedDiskStateSize
1156: FAA5 ED B0                  LDIR                        ; copy Selected State to Host Buffer state
1157: FAA7
1158: FAA7             CheckDirtyBuffer:
1159: FAA7         ;?	LD		A,(ModifiedlRecordsCount)
1160: FAA7         ;?	OR		A
1161: FAA7         ;?	JP		Z,RequestPreread			;if no modified records, just do a clean preread
1162: FAA7         ;?	JP		RequestPreread				;  ***** ;?
1163: FAA7         ; is the record to write in the Host Buffer?
1164: FAA7 21 E1 FB               LD     HL,SelectedState
1165: FAAA 11 E8 FB               LD     DE,HostBufferState
1166: FAAD CD 55 FB               CALL   CompareDkTrkSec      ; is it in Host Buffer?
1167: FAB0 C2 BA FA               JP     NZ,RequestPreread    ; NO - Then we need to load the Host Buffer
1168: FAB3
1169: FAB3         ;===============================================================================================;
1170: FAB3         ;?																								;
1171: FAB3         ;?; The Host Buffer is dirty
1172: FAB3         ;?	DEC		A
1173: FAB3         ;?	LD		(ModifiedlRecordsCount),A	; decrement records left
1174: FAB3
1175: FAB3         ;?; record to be written is in Host Buffer
1176: FAB3         ;?	LD		A,(ModifiedlRecordsCount)
1177: FAB3         ;?	CP		SectorsPerTrack				; Sector > maximum on track ?
1178: FAB3         ;?	JP		C,NoTrackChange				; No, then all parameters are set for write
1179: FAB3         ;?
1180: FAB3         ;?	XOR		A
1181: FAB3         ;?	LD		(ModifiedlRecordsCount),A	; Set value to 0
1182: FAB3         ;?	LD		HL,(HostBufferTrack)
1183: FAB3         ;?	INC		HL							; set track to next one
1184: FAB3         ;?	LD		(HostBufferTrack),HL
1185: FAB3         ;===============================================================================================;
1186: FAB3
1187: FAB3             NoTrackChange:
1188: FAB3 AF                     XOR    A
1189: FAB4 32 EE FB               LD     (PrereadSectorFlag),A ; clear preread flag
1190: FAB7 C3 BF FA               JP     CommonDiskIO
1191: FABA
1192: FABA             RequestPreread:
1193: FABA AF                     XOR    A
1194: FABB         ;?	LD		(ModifiedlRecordsCount),A	; not a write into an unallocated block
1195: FABB 3C                     INC    A
1196: FABC 32 EE FB               LD     (PrereadSectorFlag),A ; set preread flag
1197: FABF         ;*******************************************************
1198: FABF         ; Common code to execute both reads and writes of 128-byte records
1199: FABF         ;*******************************************************
1200: FABF             CommonDiskIO:
1201: FABF AF                     XOR    A                    ; Assume no disk error will occur
1202: FAC0 32 ED FB               LD     (DiskStatus),A
1203: FAC3
1204: FAC3         ;-------------------------Convert selected record into physical sector-----------;
1205: FAC3 3A E4 FB               LD     A,(SelectedRecord)   ;
1206: FAC6 1F                     RRA                         ; Convert selected record                ;
1207: FAC7 1F                     RRA                         ; into physical sector by dividing by 4  ;
1208: FAC8 E6 3F                  AND    03FH                 ; Remove unwanted bits                   ;
1209: FACA 32 E7 FB               LD     (SelectedSector),A   ;
1210: FACD         ;-------------------------Convert selected record into physical sector-----------;
1211: FACD
1212: FACD         ;------------------------- Any Data in Buffer -----------------------------------;
1213: FACD         ;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes 		 ;
1214: FACD
1215: FACD 21 DE FB               LD     HL,DataInBufferFlag  ; See if there is any data here ?        ;
1216: FAD0 7E                     LD     A,(HL)               ;
1217: FAD1 36 FF                  LD     (HL),TRUE            ; Force flag true                        ;
1218: FAD3 B7                     OR     A                    ; Was  any data here ?                   ;
1219: FAD4 CA F4 FA               JP     Z,SetIOBufferState   ; NO ?- go read into buffer              ;
1220: FAD7         ;------------------------- Any Data in Buffer -----------------------------------;
1221: FAD7
1222: FAD7         ;-----------------------------test for  the sector in the buffer-----------------;
1223: FAD7 11 DA FB               LD     DE,IOBufferState     ; get the Buffer Disk and Track          ;
1224: FADA 21 E1 FB               LD     HL,SelectedState     ; get the requested Disk and Track       ;
1225: FADD CD 50 FB               CALL   CompareDkTrk         ; Are they the same ?                    ;
1226: FAE0 C2 ED FA               JP     NZ,DataNotInBuffer   ; NO,jump - it must be read 				 ;
1227: FAE3         ;
1228: FAE3         ; Yes, the disk, track are the same are the sectors the same ?                   ;
1229: FAE3         ;
1230: FAE3 3A DD FB               LD     A,(IOBufferSector)   ; get the sector                         ;
1231: FAE6 21 E7 FB               LD     HL,SelectedSector    ;
1232: FAE9 BE                     CP     M                    ; Check if correct physical sector       ;
1233: FAEA CA 11 FB               JP     Z,DataIsInBuffer     ; Yes - it is already in memory          ;
1234: FAED         ;-----------------------------test for  the sector in the buffer-----------------;
1235: FAED
1236: FAED         ;------------------------- Do we have to write out the buffer ?------------------;
1237: FAED             DataNotInBuffer:                      ;
1238: FAED 3A DF FB               LD     A,(DirtyBufferFlag)  ;
1239: FAF0 B7                     OR     A                    ; do we need to write ?                  ;
1240: FAF1 C4 61 FB               CALL   NZ,WritePhysical     ; if yes - write it out                  ;
1241: FAF4         ;------------------------- Do we have to write out the buffer ?------------------;
1242: FAF4
1243: FAF4         ;------------------------- prepare for physical IO ------------------------------;
1244: FAF4             SetIOBufferState:                      ;
1245: FAF4         ; indicate the  selected disk, track, and sector not residing in buffer          ;
1246: FAF4 3A E1 FB               LD     A,(SelectedDisk)     ;
1247: FAF7 32 DA FB               LD     (IOBufferDisk),A     ;
1248: FAFA 2A E2 FB               LD     HL,(SelectedTrack)   ;
1249: FAFD 22 DB FB               LD     (IOBufferTrack),HL   ;
1250: FB00         ;
1251: FB00 3A E7 FB               LD     A,(SelectedSector)   ;
1252: FB03 32 DD FB               LD     (IOBufferSector),A   ;
1253: FB06         ;------------------------- prepare for physical IO ------------------------------;
1254: FB06
1255: FB06         ;------------------------- Read the data if needed, or its already in the buffer -;
1256: FB06 3A EE FB               LD     A,(PrereadSectorFlag) ; do we need to preread ?                 ;
1257: FB09 B7                     OR     A                    ;
1258: FB0A C4 66 FB               CALL   NZ,ReadPhysical      ; yes - preread the sector                ;
1259: FB0D         ;
1260: FB0D         ; At this point the data is in the buffer.                                        ;
1261: FB0D         ; Either it was already here, or we returned from ReadPhysical                    ;
1262: FB0D         ;
1263: FB0D AF                     XOR    A                    ;
1264: FB0E 32 DF FB               LD     (DirtyBufferFlag),A  ; Reset the DirtyBufferFlag	          ;
1265: FB11         ;------------------------- Read the data if needed, or its already in the buffer -;
1266: FB11
1267: FB11
1268: FB11         ; The Buffer now has the data we want to Read/Write
1269: FB11         ;-------------------------Calculate the address of the record in the sector ------;
1270: FB11         ;
1271: FB11             DataIsInBuffer:                      ;
1272: FB11 3A E4 FB               LD     A,(SelectedRecord)   ;
1273: FB14 E6 03                  AND    SectorMask           ; Want relative record number in Sector   ;
1274: FB16 3C                     INC    A                    ; Adjust for DJNZ                         ;
1275: FB17 47                     LD     B,A                  ;
1276: FB18 11 80 00               LD     DE,cpmRecordSize     ;
1277: FB1B 21 80 FF               LD     HL,-cpmRecordSize    ;
1278: FB1E             SectorInBuffer1:                      ;
1279: FB1E 19                     ADD    HL,DE                ; RecordNumber * recordSize               ;
1280: FB1F 10 FD                  DJNZ   SectorInBuffer1      ;  yields index into the Sector           ;
1281: FB21         ;
1282: FB21 11 40 F6               LD     DE,DiskBuffer        ; Start of sector                         ;
1283: FB24 19                     ADD    HL,DE                ; HL -> start of record in buffer 		  ;
1284: FB25 ED 5B E5 FB               LD     DE,(DMAAddress)      ; Callers  DMA Address                    ;
1285: FB29         ;
1286: FB29         ;-------------------------Calculate the address of the record in the sector ------;
1287: FB29
1288: FB29
1289: FB29         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1290: FB29         ;
1291: FB29 3A EF FB               LD     A,(ReadWriteFlag)    ; 0 => Write, non Zero => Read            ;
1292: FB2C B7                     OR     A                    ; Write: move data from DMA to Buffer     ;
1293: FB2D C2 35 FB               JP     NZ,BufferMove        ; Read : move data from Buffer to DMA     ;
1294: FB30         ;
1295: FB30 3C                     INC    A                    ; Set the flag to indicate dirty buffer   ;
1296: FB31 32 DF FB               LD     (DirtyBufferFlag),A  ;
1297: FB34 EB                     EX     DE,HL                ; Swap source and destination for write   ;
1298: FB35         ;
1299: FB35         ;------------------------- Determine if its a Read or Write and set HL & DE ------;
1300: FB35
1301: FB35
1302: FB35             BufferMove:
1303: FB35 01 80 00               LD     BC,cpmRecordSize
1304: FB38 ED B0                  LDIR                        ; Move data to/from Host Buffer
1305: FB3A
1306: FB3A 3A D9 FB               LD     A,(WriteType)        ; Is this a write to the directory ?
1307: FB3D FE 01                  CP     WriteDirectory
1308: FB3F 3A ED FB               LD     A,(DiskStatus)       ; Set ACC with disk status if an immediate return
1309: FB42 C0                     RET    NZ                   ; Return if not updating a directory entry
1310: FB43
1311: FB43 B7                     OR     A                    ; Check for any disk errors ?
1312: FB44 C0                     RET    NZ                   ; If yes - abandon attempt to write to directory
1313: FB45
1314: FB45 AF                     XOR    A
1315: FB46 32 DF FB               LD     (DirtyBufferFlag),A  ; Clear the dirty buffer flag
1316: FB49 CD 61 FB               CALL   WritePhysical        ; do an immediate update of the directory to disk
1317: FB4C 3A ED FB               LD     A,(DiskStatus)       ; Set ACC with disk status
1318: FB4F C9                     RET
1319: FB50         ;********************************************************************
1320: FB50
1321: FB50
1322: FB50         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
1323: FB50             CompareDkTrk:
1324: FB50 01 03 00               LD     BC,03H
1325: FB53 18 03                  JR     CompareDkTrkSecLoop
1326: FB55             CompareDkTrkSec:
1327: FB55 01 04 00               LD     BC,04H
1328: FB58             CompareDkTrkSecLoop:
1329: FB58 1A                     LD     A,(DE)               ; Get value
1330: FB59 13                     INC    DE                   ; anticipate next iteration
1331: FB5A ED A1                  CPI                         ; does A = (HL)
1332: FB5C C0                     RET    NZ                   ; Not a match exit
1333: FB5D EA 58 FB               JP     PE,CompareDkTrkSecLoop ; Loop if not done
1334: FB60 C9                     RET
1335: FB61
1336: FB61
1337: FB61         ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE
1338: FB61         ; MoveDkTrkSec:
1339: FB61         ; 	LD		C,04H							; Disk(1), Track(2), Sector(1)
1340: FB61         ; MoveDkTrkSecLoop:
1341: FB61         ; 	LD		A,(HL)
1342: FB61         ; 	LD		(DE),A
1343: FB61         ; 	INC		DE
1344: FB61         ; 	INC		HL
1345: FB61         ; 	DEC		C
1346: FB61         ; 	RET	Z
1347: FB61         ; 	JP		MoveDkTrkSecLoop
1348: FB61
1349: FB61         ;************************************************
1350: FB61         ;			Physical Disk IO					*
1351: FB61         ;************************************************
1352: FB61
1353: FB61         ;Write contents of disk buffer to correct sector
1354: FB61             WritePhysical:
1355: FB61 3E 02                  LD     A,DiskWriteCode      ; get write function
1356: FB63 C3 68 FB               JP     CommonPhysical
1357: FB66
1358: FB66             ReadPhysical:
1359: FB66 3E 01                  LD     A,DiskReadCode       ; get read function
1360: FB68
1361: FB68         ; Set up the Dick Control Table DCT
1362: FB68             CommonPhysical:
1363: FB68         ;Command
1364: FB68 32 CC FB               LD     (DCTCommand),A       ; set the command for Read or Write
1365: FB6B         ;Disk
1366: FB6B 3A DA FB               LD     A,(IOBufferDisk)
1367: FB6E E6 03                  AND    03H                  ; only units 0 to 3
1368: FB70 32 CD FB               LD     (DCTDisk),A          ; set disk
1369: FB73         ;Track
1370: FB73 2A DB FB               LD     HL,(IOBufferTrack)
1371: FB76 7D                     LD     A,L                  ; for this controller it is a byte value
1372: FB77 32 CF FB               LD     (DCTTrack),A         ; set track
1373: FB7A         ;Head and Track	Calculations
1374: FB7A         ; The sector must be converted into a head number and sector number.
1375: FB7A         ;	Head = (int) Sector / SectorsPerHead
1376: FB7A         ;	Sector = Sector MOD SectorsPerHead
1377: FB7A             DetermineHead:
1378: FB7A 06 00                  LD     B,0                  ; Start at head 0
1379: FB7C 21 E0 FB               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1380: FB7F 3A DD FB               LD     A,(IOBufferSector)   ; get target sector
1381: FB82             DetermineHead1:
1382: FB82 BE                     CP     M                    ; Need another Head?
1383: FB83 DA 8B FB               JP     C,HeadFound          ; nope done with head calculation
1384: FB86
1385: FB86 96                     SUB    M                    ; subtract track value
1386: FB87 04                     INC    B                    ; Increment head
1387: FB88 C3 82 FB               JP     DetermineHead1       ; loop for next head value
1388: FB8B
1389: FB8B         ;Sector
1390: FB8B             HeadFound:                      ; ACC now has Sector MOD SectorsPerHead
1391: FB8B 3C                     INC    A                    ; physical sectors start at 1
1392: FB8C 32 D0 FB               LD     (DCTSector),A        ; set sector
1393: FB8F         ;Head
1394: FB8F 78                     LD     A,B
1395: FB90 32 CE FB               LD     (DCTHead),A          ; set head number
1396: FB93         ;Byte Count
1397: FB93 21 00 02               LD     HL,diskSectorSize
1398: FB96 22 D1 FB               LD     (DCTByteCount),HL    ; set byte count
1399: FB99         ;DMA
1400: FB99 21 40 F6               LD     HL,DiskBuffer
1401: FB9C 22 D3 FB               LD     (DCTDMAAddress),HL   ; set transfer address
1402: FB9F
1403: FB9F         ; Since only one control table is in use, close the status and busy chain pointers
1404: FB9F         ; back to the main control bytes
1405: FB9F         ;NextStatusBlock
1406: FB9F 21 43 00               LD     HL,DiskStatusLocation
1407: FBA2 22 D5 FB               LD     (DCTNextStatusBlock),HL
1408: FBA5         ;NextControlLocation
1409: FBA5 21 45 00               LD     HL,DiskControlByte
1410: FBA8 22 D7 FB               LD     (DCTNextControlLocation),HL
1411: FBAB
1412: FBAB         ;Put  DCT pointer in page0
1413: FBAB 21 CC FB               LD     HL,DCTCommand
1414: FBAE 22 46 00               LD     (DiskCommandBlock),HL
1415: FBB1         ; Make the IO happen
1416: FBB1 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1417: FBB4 36 80                  LD     (HL),080H
1418: FBB6
1419: FBB6         ;Wait until Disk Status Block indicates the operation is complete,
1420: FBB6             WaitForDiskComplete:
1421: FBB6 7E                     LD     A,(HL)               ; get control bytes
1422: FBB7 B7                     OR     A
1423: FBB8 C2 B6 FB               JP     NZ,WaitForDiskComplete ; operation not done
1424: FBBB
1425: FBBB
1426: FBBB         ;Check if any errors occurred.
1427: FBBB 3A 43 00               LD     A,(DiskStatusLocation)
1428: FBBE DA C6 FB               JP     C,DiskError
1429: FBC1 AF                     XOR    A
1430: FBC2 32 ED FB               LD     (DiskStatus),A       ; clear the flag
1431: FBC5 C9                     RET
1432: FBC6
1433: FBC6         ; set error flag and return
1434: FBC6             DiskError:
1435: FBC6 3E 01                  LD     A,1
1436: FBC8 32 ED FB               LD     (DiskStatus),A       ; set the error flag
1437: FBCB C9                     RET
1438: FBCC
1439: FBCC         ;********************************************************************
1440: FBCC         ;********************************************************************
1441: FBCC         ;********************************************************************
1442: FBCC
1443: FBCC         ;---------------------------------------------------------------------------
1444: FBCC         ;	Disk Data
1445: FBCC         ;---------------------------------------------------------------------------
1446: FBCC         ;	Disk Equates
1447: FBCC         ;---------------------------------------------------------------------------
1448: FBCC         ; Disk Types
1449: FBCC         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1450: FBCC         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1451: FBCC         ;;HardDisk	EQU	2						; hard disk
1452: FBCC         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1453: FBCC
1454: FBCC
1455: FBCC         ;**************************************************************************************************
1456: FBCC         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1457: FBCC         ;
1458: FBCC         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1459: FBCC         ; perform some disk operation.  These are called its disk control byte.
1460: FBCC         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1461: FBCC         ; following the respective control bytes. This word must contain the address of  valid disk control
1462: FBCC         ; table that specifies the exact disk operation to be performed.
1463: FBCC         ;
1464: FBCC         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1465: FBCC         ; This indicates completion to the disk driver code.
1466: FBCC         ;
1467: FBCC         ;  The controller also sets a return code in a disk status block - location 0X43H.
1468: FBCC         ; If the first byte of this status block is less than 80H. then a disk error
1469: FBCC         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1470: FBCC         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1471: FBCC         ; ten times before the controller returns an error
1472: FBCC         ;
1473: FBCC         ;  The disk control table layout is shown below. Note that the controller has the capability
1474: FBCC         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1475: FBCC         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1476: FBCC         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1477: FBCC         ; the end of the chain
1478: FBCC         ;**************************************************************************************************
1479: FBCC
1480: FBCC         ;***************************************************************************
1481: FBCC         ;	Disk Control tables
1482: FBCC         ;***************************************************************************
1483: FBCC         ;;DiskControlTable:
1484: FBCC             DCTStart:
1485: FBCC 00          DCTCommand: DB     00H                  ; Command
1486: FBCD 00          DCTDisk:   DB     00H                  ; unit (drive) number = 0 or 1
1487: FBCE 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1488: FBCF 00          DCTTrack:  DB     00H                  ; track number
1489: FBD0 00          DCTSector: DB     00H                  ; sector number
1490: FBD1 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1491: FBD3 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1492: FBD5 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1493: FBD7 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1494: FBD9             DCTEnd:
1495: FBD9             DCTSize    EQU    DCTEnd-DCTStart
1496: FBD9         ;-----------------------------------------
1497: FBD9         ;WriteAllocated		EQU	00H		W_NORMAL
1498: FBD9         ;WriteDirectory		EQU	01H		W_DIRECTORY
1499: FBD9         ;WriteCleanBuffer	EQU	02H		W_NEW_BLOCK
1500: FBD9         ;-----------------------------------------
1501: FBD9
1502: FBD9 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1503: FBDA
1504: FBDA         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1505: FBDA             IOBufferState:
1506: FBDA 00          IOBufferDisk: DB     00H
1507: FBDB 00 00       IOBufferTrack: DW     00H
1508: FBDD 00          IOBufferSector: DB     00H
1509: FBDE 00          DataInBufferFlag: DB     00H                  ; when non-zero, the disk buffer has data from disk
1510: FBDF 00          DirtyBufferFlag: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1511: FBE0         ;   but not yet written out to the disk
1512: FBE0         ;---------------------------------------------------------------------------
1513: FBE0         ;	Disk Storage area
1514: FBE0         ;---------------------------------------------------------------------------
1515: FBE0         ;     variables for selected disk, track and sector
1516: FBE0         ; These are moved and compared as a group, DO NOT ALTER
1517: FBE0
1518: FBE0 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1519: FBE1
1520: FBE1             SelectedState:
1521: FBE1 00          SelectedDisk: DB     00H
1522: FBE2 00 00       SelectedTrack: DW     0000H
1523: FBE4 00          SelectedRecord: DB     00H
1524: FBE5
1525: FBE5             SelectedDiskStateEnd:
1526: FBE5             SelectedDiskStateSize EQU    SelectedDiskStateEnd - SelectedDisk
1527: FBE5
1528: FBE5 00 00       DMAAddress: DW     0000H                ; DMA address
1529: FBE7
1530: FBE7 00          SelectedSector: DB     00H
1531: FBE8
1532: FBE8         ; Parameters for the records in the Deblocking Buffer
1533: FBE8         ; These are moved and compared as a group, DO NOT ALTER
1534: FBE8
1535: FBE8             HostBufferState:
1536: FBE8 00          HostBufferDisk: DB     00H
1537: FBE9 00 00       HostBufferTrack: DW     0000H
1538: FBEB 00          HostBufferRecord: DB     00H
1539: FBEC
1540: FBEC 00          ModifiedlRecordsCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1541: FBED 00          DiskStatus: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1542: FBEE         ; Flags used inside the de-blocking code
1543: FBEE 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1544: FBEF         ; either before a write to a allocated block can occur, or
1545: FBEF         ; for a normal cpmRecord read
1546: FBEF 00          ReadWriteFlag: DB     00H                  ; 0 => Write-  Non-zero =>read
1547: FBF0
1548: FBF0         ;---------------------------------------------------------------------------
1549: FBF0
1550: FBF0         ;---------------------------------------------------------------------------
1551: FBF0         ;	Disk Definition Tables
1552: FBF0         ; These consists of disk parameter headers, with one entry
1553: FBF0         ; per logical disk driver, and disk parameter blocks, with
1554: FBF0         ; either one parameter block per logical disk or the same
1555: FBF0         ; parameter block for several logical disks.
1556: FBF0         ;---------------------------------------------------------------------------
1557: FBF0         ;---------------------------------------------------------------------------
1558: FBF0             DiskParameterHeaders:
1559: FBF0
1560: FBF0         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1561: FBF0 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1562: FBF2 00 00                  DW     0000H                ; Rel pos for file (0-3)
1563: FBF4 00 00                  DW     0000H                ; Last Selected Track #
1564: FBF6 00 00                  DW     0000H                ; Last Selected Sector #
1565: FBF8 24 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1566: FBFA 30 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1567: FBFC 40 FC                  DW     DiskAWorkArea
1568: FBFE C0 FC                  DW     DiskAAllocationVector
1569: FC00
1570: FC00         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1571: FC00 00 00                  DW     0000H                ; No Skew table
1572: FC02 00 00                  DW     0000H                ; Rel pos for file (0-3)
1573: FC04 00 00                  DW     0000H                ; Last Selected Track #
1574: FC06 00 00                  DW     0000H                ; Last Selected Sector #
1575: FC08 24 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1576: FC0A 30 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1577: FC0C 60 FC                  DW     DiskBWorkArea
1578: FC0E 19 FD                  DW     DiskBAllocationVector
1579: FC10
1580: FC10         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1581: FC10 00 00                  DW     0000H                ; No Skew table
1582: FC12 00 00                  DW     0000H                ; Rel pos for file (0-3)
1583: FC14 00 00                  DW     0000H                ; Last Selected Track #
1584: FC16 00 00                  DW     0000H                ; Last Selected Sector #
1585: FC18 24 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1586: FC1A 30 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1587: FC1C 80 FC                  DW     DiskCWorkArea
1588: FC1E 72 FD                  DW     DiskCAllocationVector
1589: FC20
1590: FC20         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1591: FC20 00 00                  DW     0000H                ; No Skew table
1592: FC22 00 00                  DW     0000H                ; Rel pos for file (0-3)
1593: FC24 00 00                  DW     0000H                ; Last Selected Track #
1594: FC26 00 00                  DW     0000H                ; Last Selected Sector #
1595: FC28 24 FE                  DW     DirectoryBuffer      ; all disks use this buffer
1596: FC2A 30 FC                  DW     ParameterBlock3HD    ; specific to disk's parameters
1597: FC2C A0 FC                  DW     DiskDWorkArea
1598: FC2E CB FD                  DW     DiskDAllocationVector
1599: FC30
1600: FC30
1601: FC30         ;-----------------------------------------------------------
1602: FC30
1603: FC30             ParameterBlock3HD:
1604: FC30 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1605: FC32 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1606: FC33 0F                     DB     dpb3hdBLM            ; Block mask
1607: FC34 00                     DB     dpb3hdEXM            ; Extent mask
1608: FC35 C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1609: FC37 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1610: FC39 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1611: FC3A 00                     DB     dpb3hdAL1            ;  for file directory
1612: FC3B 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1613: FC3D 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1614: FC3F
1615: FC3F 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1616: FC40
1617: FC40
1618: FC40
1619: FC40         ;---------------------------------------------------------------------------
1620: FC40         ;	Disk work area
1621: FC40         ;---------------------------------------------------------------------------
1622: FC40         ; These are used by the BDOS to detect any unexpected
1623: FC40         ; change of diskette. The BDOS will automatically set
1624: FC40         ; such a changed diskette to read-only status.
1625: FC40
1626: FC40             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1627: FC60             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1628: FC80             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1629: FCA0             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1630: FCC0
1631: FCC0         ;---------------------------------------------------------------------------
1632: FCC0         ;	Disk allocation vectors
1633: FCC0         ;---------------------------------------------------------------------------
1634: FCC0         ; Disk allocation vectors
1635: FCC0         ; These are used by the BDOS to maintain a bit map of
1636: FCC0         ; which allocation blocks are used and which are free.
1637: FCC0         ; One byte is used for eight allocation blocks, hence the
1638: FCC0         ; expression of the form (allocation blocks/8)+1
1639: FCC0
1640: FCC0             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1641: FD19             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1642: FD72
1643: FD72             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1644: FDCB             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1645: FE24         ;---------------------------------------------------------------------------
1646: FE24         ;	Disk Buffer
1647: FE24         ;---------------------------------------------------------------------------
1648: FE24             DirectoryBuffer: DS     DirBuffSize
           ************************   Xref   ************************
0000: $               FE24   0323
0714: AddressDataIn   F9AB   0712
0729: AddressDataOut  F9BB   0726
0739: AddressStatus   F9C4   0737
0327: AfterDiskBuffer F840
0090: ASCII_A         0041
0091: ASCII_C         0043
0092: ASCII_K         004B
0099: ASCII_LO_A      0061
0100: ASCII_LO_K      006B
0101: ASCII_LO_P      0070
0042: ASCII_MASK      007F   0720
0093: ASCII_N         004E
0094: ASCII_Q         0051
0095: ASCII_R         0052
0096: ASCII_W         0057
0097: ASCII_Y         0059
0077: ASCII_ZERO      0030
0071: ASTERISK        002A
0400: BadBootMessage  F890   0364
0156: BDOSBase        E800   0157 0159
0125: BDOSE           0005   0126 0486 0488
0157: BDOSEntry       E806   0487
0146: BDOSLength      0E00   0149 0159 0160 0505
0060: BELL            0007
0159: BIOSBase        F600
0147: BIOSLength      0A00   0149
0119: BIOSPAGE        0002
0160: BIOSStart       F600   0299 0375
0256: BlockSize       0800   0278
0356: BOOT            F840   0303
0368: BOOTControl     F856   0360
0392: BootMessage     F863   0357
1302: BufferMove      FB35   1293
0038: BYTE            0001
0098: CARET           005E
0154: CCPEntry        E000   0156 0160 0468 0496 0506
0145: CCPLength       0800   0149 0156 0160 0505
1158: CheckDirtyBuffer FAA7   1147
0301: CodeStart       F600
0078: COLON           003A
0782: COM_DataPort    00EC   0826
0784: COM_InputMask   0002   0828
0783: COM_OutputMask  0001   0827
0781: COM_StatusPort  00ED   0825
0824: COM_Table       F9F3   0856 0866
0073: COMMA           002C
1200: CommonDiskIO    FABF   1093 1190
1362: CommonPhysical  FB68   1356
1323: CompareDkTrk    FB50   1225
1326: CompareDkTrkSec FB55   1166
1328: CompareDkTrkSecLoop FB58   1325 1333
0131: ComTail         0080   0132
0133: ComTailChars    0082
0132: ComTailCount    0081   0133
0853: CON_Vector      FA11   0527 0571
0549: ConIn           F932   0551
0548: CONIN           F932   0307
0568: CONOUT          F93E   0308
0569: CONOut          F93E
0524: CONST           F920   0306
0525: ConStatus       F920   0550
0233: cpmRecordSize   0080   0235 0238 0240 1276 1277 1303
0063: CR              000D   0397 0399 0401 0405 0408
0777: CRT_DataPort    0001   0818
0779: CRT_InputMask   007F   0820
0778: CRT_OutputMask  0080   0819
0776: CRT_StatusPort  0002   0817
0816: CRT_Table       F9E9   0855 0860 0867 0870
0046: CTRL_C          0003
0047: CTRL_E          0005
0048: CTRL_H          0008
0049: CTRL_K          000B
0050: CTRL_L          000C
0051: CTRL_P          0010
0052: CTRL_R          0012
0053: CTRL_S          0013
0054: CTRL_U          0015
0055: CTRL_X          0018
0056: CTRL_Z          001A
0074: DASH            002D
0267: DataBlocks      02C7   0277
1509: DataInBufferFlag FBDE   0922 1215
1271: DataIsInBuffer  FB11   1233
1237: DataNotInBuffer FAED   1226
0798: DataPortIndex   0001   0711 0725
0710: DataRead        F9A4   0719 0822 0830 0838
0718: DataReadASCII   F9AD   0813
0802: DataReadIndex   0006   0553 0554 0654 0655
0266: DataSectors     0B1C   0267
0724: DataWrite       F9B3   0814 0823 0831 0839
0803: DataWriteIndex  0008   0578 0579
1490: DCTByteCount    FBD1   1398
1485: DCTCommand      FBCC   1364 1413
1486: DCTDisk         FBCD   1368
1491: DCTDMAAddress   FBD3   1401
1494: DCTEnd          FBD9   1495
1487: DCTHead         FBCE   1395
1493: DCTNextControlLocation FBD7   1410
1492: DCTNextStatusBlock FBD5   1407
1489: DCTSector       FBD0   1392
1495: DCTSize         000D
1484: DCTStart        FBCC   1495
1488: DCTTrack        FBCF   1372
1377: DetermineHead   FB7A
1381: DetermineHead1  FB82   1387
0238: DirBuffSize     0080   1648
0253: DirectoryBlockCount 0002   0278
1648: DirectoryBuffer FE24   1565 1575 1585 1595
0240: DirectoryEntryPerRecord 0004   0281
0237: DirEntrySize    0020   0240 0278
1510: DirtyBufferFlag FBDF   0919 1238 1264 1296 1315
1640: DiskAAllocationVector FCC0   1568
1626: DiskAWorkArea   FC40   1567
1641: DiskBAllocationVector FD19   1578
0325: DiskBuffer      F640   1282 1400
1627: DiskBWorkArea   FC60   1577
1643: DiskCAllocationVector FD72   1588
0225: DiskCommandBlock 0046   0413 1414
0224: DiskControlByte 0045   0415 0508 1409 1416
0227: DiskControlTable 0040   0377
1628: DiskCWorkArea   FC80   1587
1644: DiskDAllocationVector FDCB   1598
1629: DiskDWorkArea   FCA0   1597
1434: DiskError       FBC6   1428
1558: DiskParameterHeaders FBF0   0959
0229: DiskReadCode    0001   0369 0500 1359
0234: diskSectorSize  0200   0235 0256 0264 0326 1397
1541: DiskStatus      FBED   1202 1308 1317 1430 1436
0223: DiskStatusLocation 0043   0376 0425 0507 1406 1427
0230: DiskWriteCode   0002   1355
0430: DisplayMessage  F8D2   0358 0365 0439 0474
1528: DMAAddress      FBE5   1026 1284
0136: DMABuffer       0080   0490
0067: DOLLAR          0024
0279: dpb3hdAL0       00C0   1610
0280: dpb3hdAL1       0000   1611
0275: dpb3hdBLM       000F   1606
0274: dpb3hdBSH       0004   1605
0281: dpb3hdCKS       0020   1612 1626 1627 1628 1629
0278: dpb3hdDRM       007F   0281 1609
0277: dpb3hdDSM       02C6   1608 1640 1641 1643 1644
0276: dpb3hdEXM       0000   1607
0283: dpb3hdNOH       0002   1615
0282: dpb3hdOFF       0001   1613
0273: dpb3hdSPT       0090   1604 1615
0792: DUMMY_DataPort  0010   0842
0794: DUMMY_InputMask 007F   0844
0793: DUMMY_OutputMask 00FF   0843
0791: DUMMY_StatusPort 0011   0841
0840: DUMMY_Table     FA07   0857 0861 0862 0865 0872
0748: DUMMYCheck      F9C9   0845
0744: DUMMYRead       F9C7   0846
0746: DUMMYWrite      F9C8   0847
0140: END_OF_FILE     001A
0044: EndOfMessage    0000   0399 0403 0408
0082: EQUAL_SIGN      003D
0065: EXCLAIM_POINT   0021
0033: FALSE           0000
0128: FCB1            005C   0129
0129: FCB2            006C
0173: fCloseFile      0010
0164: fConsoleIn      0001
0165: fConsoleOut     0002
0176: fDeleteFile     0013
0168: fGetConsoleStatus 000B
0182: fGetCurrentDisk 0019
0181: fGetLoginVector 0018
0184: fGetSetUserNumber 0020
0169: fGetVersion     000C
0179: fMakeFile       0016
0172: fOpenFile       000F
0166: fPrintString    0009
0177: fReadSeq        0014
0167: fReadString     000A
0180: fRenameFile     0017
0170: fResetSystem    000D
0174: fSearchFirst    0011
0175: fSearchNext     0012
0171: fSelectDisk     000E
0183: fSetDMA         001A
0178: fWriteSeq       0015
0529: GenericInStatus F927   0651
0573: GenericOutStatus F945   0598 0627
0575: GenericOutStatus1 F948   0577
0701: GetInStatus     F99A   0531
0697: GetOutStatus    F995   0576 0687
0703: GetStatus       F99D   0700
0083: GREATER_THAN    003E
0066: HASH_TAG        0023
1390: HeadFound       FB8B   1383
0918: HOME            FA31   0312
0923: HomeNoWrite     FA3A   0921
1536: HostBufferDisk  FBE8
1538: HostBufferRecord FBEB
1535: HostBufferState FBE8   1154 1165
1537: HostBufferTrack FBE9
0294: IN_OPCODE       00DB   0713 0738
0800: InputMaskIndex  0003   0702
1506: IOBufferDisk    FBDA   1247 1366
1508: IOBufferSector  FBDD   1230 1252 1380
1505: IOBufferState   FBDA   1223
1507: IOBufferTrack   FBDB   1249 1370
0120: IOBYTE          0003   0526 0570 0594 0621 0646 0682
0296: JP_OPCODE       00C3   0480
0069: L_PAREN         0028
0086: LEFT_ARROW      005F
0102: LEFT_CURLY      007B
0149: LengthInBytes   2000   0150 0154 0264
0150: LengthInK       0009
0081: LESS_THAN       003C
0062: LF              000A   0397 0399 0401 0405 0408
0593: LIST            F954   0309
0681: LISTST          F981   0319
0036: LO_NIBBLE_MASK  000F
0479: LoadPage0       F8F1   0471
0787: LPT_DataPort    0010   0834
0789: LPT_InputMask   007F   0836
0788: LPT_OutputMask  00FF   0835
0786: LPT_StatusPort  0011   0833
0832: LPT_Table       F9FD   0869 0871
0868: LST_Vector      FA29   0597 0685
0152: MemorySize      0040   0154
1540: ModifiedlRecordsCount FBEC   1087
0265: myOffset        0001   0266 0282
1187: NoTrackChange   FAB3
0058: NULL            0000
0249: NumberOfHeads   0002   0260 0262 0273 0283
0246: NumberOfLogicalDisks 0004   0948
0035: OFF             0000
0034: ON              FFFF
0295: OUT_OPCODE      00D3   0728
0799: OutputMaskIndex 0002   0699
1603: ParameterBlock3HD FC30   1566 1576 1586 1596
0068: PERCENT         0025
0075: PERIOD          002E
0123: Pg0CurentDisk   0004   0494
0122: Pg0CurentUser   0004   0123
0072: PLUS_SIGN       002B
1543: PrereadSectorFlag FBEE   1090 1189 1196 1256
0863: PUN_Vector      FA21   0626
0620: PUNCH           F95F   0310
0084: QMARK           003F
0070: R_PAREN         0029
0116: RAM             0000   0118 0119 0120 0122 0125 0128 0131 0136 0138
0412: RawDiskRead     F8C0   0361 0470
0858: RDR_Vector      FA19   0649
1085: READ            FA7C   0317
0645: READER          F96C   0311
0650: READER1         F975   0652
1358: ReadPhysical    FB66   1258
1546: ReadWriteFlag   FBEF   1089 1142 1291
0258: RecordsPerBlock 0010
0242: RecordsPerExtent 0080
0235: recordsPerSector 0004   0258 0273
1192: RequestPreread  FABA   1167
0087: RUBOUT          007F
1278: SectorInBuffer1 FB1E   1280
0287: SectorMask      0003   1273
0252: SectorsPerBlock 0004   0256 0258 0261 0267 0287
0262: SectorsPerCylinder 0024   0265 0266
0251: SectorsPerTrack 0012   0260 0262 0273
1046: SECTRAN         FA79   0320
0945: SELDSK          FA40   0313
1521: SelectedDisk    FBE1   0951 1246 1526
1525: SelectedDiskStateEnd FBE5   1526
1526: SelectedDiskStateSize 0004   1155
1518: SelectedDskSecsPerHead FBE0   0969 1379
1523: SelectedRecord  FBE4   1012 1205 1272
1530: SelectedSector  FBE7   1209 1231 1251
1520: SelectedState   FBE1   1153 1164 1224
1522: SelectedTrack   FBE2   0992 1248
0080: SEMICOLON       003B
0754: SetDeviceVector F9CD   0530 0574 0686
1025: SETDMA          FA74   0316 0491
1244: SetIOBufferState FAF4   1219
1010: SETSEC          FA6F   0315
0988: SETTRK          FA6A   0314 0925
0076: SLASH           002F
0059: SOH             0001
0064: SPACE           0020
0797: StatusPortIndex 0000   0736
0735: StatusRead      F9BD   0812 0821 0829 0837
0801: StatusReadIndex 0004   0704 0705
0264: SystemSectors   0011   0265
0061: TAB             0009
0126: TopRAM          0007
0261: TotalNumberOfBlocks 02D0
0260: TotalNumberOfSectors 0B40   0261 0266
0138: TPA             0100
0250: TracksPerHead   0050   0260
0032: TRUE            FFFF   1217
0772: TTY_DataPort    00EC   0436 0809
0774: TTY_InputMask   007F   0811
0773: TTY_OutputMask  0080   0810
0771: TTY_StatusPort  00ED   0808
0807: TTY_Table       F9DF   0854 0859 0864
0085: UNDER_SCORE     005F
1420: WaitForDiskComplete FBB6   1423
0419: WaitForReadDone F8C8   0422
0118: WarmBoot        0000   0482 0484
0304: WarmBootEntry   F603   0483
0404: WarmBootErroMessage F8A6   0473
0467: WBOOT           F8DD   0305 0363 0475
0499: WBOOTControl    F913   0469
0039: WORD            0002
1139: WRITE           FA8F   0318
0198: WriteAllocated  0000
0200: WriteCleanBuffer 0002   1091 1146
0199: WriteDirectory  0001   1307
1354: WritePhysical   FB61   1240 1316
1502: WriteType       FBD9   1092 1144 1306
0043: ZERO            0000
