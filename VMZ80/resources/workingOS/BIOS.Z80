;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
 ; BIOS.Z80
 
 ; 2017-03-31 Added List out functionality for List Device
 ; 2017-03-02 Refactored the CP/M Suite
 ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
 ; 2014-01-16
 ; 2014-03-14  :  Frank Martyn
 
 	$Include ./stdHeader.Z80
 	$Include ./osHeader.Z80
 	$Include ./diskHeader.Z80
 	
 	
 IN_OPCODE	EQU	0DBH
 OUT_OPCODE	EQU	0D3H
 
 
 	ORG	BIOSStart							; Assemble code at BIOS address
 											; BIOS jum Vector
 CodeStart:
 
 	JP		BOOT							; 00  Not Yet Checked
 WarmBootEntry:
 	JP		WBOOT							; 01 Not Yet Checked
 	JP		CONST							; 02 Checked
 	JP		CONIN							; 03 Checked
 	JP		CONOUT							; 04 Checked
 	JP		LIST							; 05 Checked
 	JP		PUNCH							; 06 Not Yet Checked *
 	JP		READER							; 07 Not Yet Checked *
 	JP		HOME							; 08 Checked
 	JP		SELDSK							; 09 Checked
 	JP		SETTRK							; 0A Checked
 	JP		SETSEC							; 0B Checked
 	JP		SETDMA							; 0C Checked
 	JP		READ							; 0D Not Yet Checked
 	JP		WRITE							; 0E Not Yet Checked
 	JP		LISTST							; 0F Not Yet Checked *
 	JP		SECTRAN							; 10 Checked
 
 ;-------------------------------------------------
 	ORG		(($+10H)/10H) * 10H
 
 DiskBuffer:
 	DS		diskSectorSize
 AfterDiskBuffer	EQU	$
 ;-------------------------------------------------
 
 
 
 ;	ORG AfterDiskBuffer				; reset Location Counter
 
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 ;---------------------------------------------------------------------------
;	Console Status:		BIOS 02
;  CONST simply returns an indicator showing whether there is an incoming
; character from the console device. The convention is that A = OFFH if a character
; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
; to reflect the contents of the A register - it is the contents that are important.
; CONST is called by the CCP whenever the CCP is in the middle of an
; operation that can be interrupted by pressing a keyboard character.
; 
; The BDOS will call CONST if a program makes a Read Console Status
; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
; routine, CONIN
CONST:	
ConStatus:
	LD		A,(IOBYTE)
	LD		IX,CON_Vector
	
GenericInStatus:					; Entry point for generic input status
	CALL	SetDeviceVector		; IX has the vector for the Physical Device
	CALL	GetInStatus
	OR	A
	RET		Z					; 00 => No data pending
	LD		A,0FFH
	RET							; OFFH => Data in Buffer
;---------------------------------------------------------------------
;	Console In:		BIOS 03
;  CONIN reads the next character from the console to the A register and sets the
; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
; until it detects A = OFFH. Only then will it input the data character and mask off
; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
; Read Console Byte function (B$CONIN, code 1).
; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
 
 ; This is a blocking routine
CONIN:
 ConIn:
	CALL	ConStatus
	JR		Z,ConIn				; loop until there is some data to read
								; Call to ConStatus Sets up IX with Physical Table
	LD		L,(IX + DataReadIndex)
	LD		H,(IX +(DataReadIndex +1 ))
	JP		(HL)
;---------------------------------------------------------------------------
;	Console Out:		BIOS 04
;  CONOUT outputs the character (in ASCII) in register C to the console. The
; most significant (parity) bit of the character will always be O.
; CONOUT must first check that the console device is ready to receive more
; data, delaying if necessary until it is, and only then sending the character to the
; device. CONOUT is called by the CCP and by the BDOS when a program executes a
; Write Console Byte function (B$CONOUT, code 2).

; This is a blocking routine
CONOUT:
CONOut:
	LD		A,(IOBYTE)
	LD		IX,CON_Vector
	
GenericOutStatus:					; entry point for standard blocking write
	CALL	SetDeviceVector			; IX has the vector for the Physical Device
GenericOutStatus1:
	CALL	GetOutStatus
	JR		Z,GenericOutStatus1		; wait until ready
	LD		L,(IX +DataWriteIndex)
	LD		H,(IX +(DataWriteIndex + 1))
	JP		(HL)
	
;---------------------------------------------------------------------------
;	List output  BIOS 05
; LIST is similar to CONOUT except that it sends the character in register C to
; the list device. It too checks first that the list device is ready to receive
; the character. LIST is called by the CCP in response to the CONTROL-P toggle
; for printer echo of console output, and by the BDOS when a program makes a
; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).

; This is a blocking routine

 LIST:
 	LD		A,(IOBYTE)
 	RLCA										; move bits 7,6
 	RLCA										; to 1,0
 	LD		IX,LST_Vector
	JR		GenericOutStatus					; go to generic blocking out routine
 
;---------------------------------------------------------------------------
;	Punch output  BIOS 06	
;  PUNCH sends the character in register C to the "punch" device. As mentioned
; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
; entry point either returns immediately and is effectively a null routine, or it outputs
; the character to a communications device, such as a modem, on your computer.
; PUNCH must check that the "punch" device is indeed ready to accept another
; character for output, and must wait if it is not.
; 
; Digital Research's documentation states that the character to be output will
; always have its most significant bit set to O. This is not true. The BDOS simply
; transfers control over to the PUNCH entry point in the BIOS; the setting of the
; most significant bit will be determined by the program making the BDOS function
; request (B$PUNOUT, code 4). This is important because the requirement of a zero
; would preclude being able to send pure binary data via the BIOS PUNCH
; function

; This is a blocking routine

PUNCH:				; Punch output
 	LD		A,(IOBYTE)
 	RRCA
 	RRCA
 	RRCA										; move bits 5,4
 	RRCA										; to 1,0
  	LD		IX,PUN_Vector
	JR		GenericOutStatus					; go to generic blocking out routine

;---------------------------------------------------------------------------
;	Reader input  BIOS 07	-
; As with the PUNCH entry point, the READER entry point rarely connects to
; a real paper tape reader.
; The READER function must return the next character from the reader device
; in the A register, waiting, if need be, until there is a character.
; 
; Digital Research's documentation again says that the most significant bit of
; the A register must be 0, but this is not the case if you wish to receive pure binary
; information via this function.
; READER is called whenever a program makes a Read "Reader" Byte function
; request (B$READIN, code 3).

; This is a blocking routine

 READER:				; Reader Input
 	LD		A,(IOBYTE)
 	RRCA
 	RRCA										; move bits 3,2  to 1,0
	LD		IX,RDR_Vector
READER1:
	CALL	GenericInStatus
	JR		Z,READER1							; loop until there is some data to read
												
	LD		L,(IX + DataReadIndex)
	LD		H,(IX +(DataReadIndex +1 ))
	JP		(HL)

	
;---------------------------------------------------------------------------
;	List Status:  BIOS 0F
 
;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
; This function returns the current status of the list device, using the IOBYTE if
; necessary to select the correct physical device. It sets the A register to OFFH if the
; list device can accept another character for output or to OOH if it is not ready.
; Digital Research's documentation states that this function is used by the
; DESPOOL utility program (which allows you to print a file "simultaneously" with
; other operations) to improve console response during its operation, and that it is
; acceptable for the routine always to return OOH if you choose not to implement it
; fully.
; Unfortunately, this statement is wrong. Many other programs use the LISTST
; function to "poll" the list device to make sure it is ready, and if it fails to come
; ready after a predetermined time, to output a message to the console indicating
; that the printer is not ready. If you ever make a call to the BDOS list output
; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
; not ready, then CP/M will wait forever-and your program will have lost control
; so it cannot even detect that the problem has occurred. If LISTST always returns a
; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
; out of the LISTST function, but it also causes a stream of false "Printer
; not Ready" error messages to appear on the console.
;  
 LISTST:
;?GetLSTStatus:
	LD		A,(IOBYTE)				; Get Physical device
	RLCA
	RLCA						; Move bits 6 & 7 to bits 0 & 1
	LD		IX,LST_Vector		; Set th vector base 
	CALL	SetDeviceVector		; IX has the vector for the Physical Device
	CALL	GetOutStatus

	OR	A
	RET		Z					; 00 => Device Ready
	LD		A,0FFH
	RET							; OFFH => Device No Ready

;---------------------------------------------------------------------------

;---------------------------------------------------------------------
GetOutStatus:
				; vector to CON Devices
	LD		D,(IX + OutputMaskIndex)	; setup Output mask	
	JR		GetStatus
GetInStatus:
	LD		D,(IX + InputMaskIndex)		; setup Input mask
GetStatus:	
	LD		L,(IX + StatusReadIndex)
	LD		H,(IX + (StatusReadIndex + 1))	; Load HL with address for Status Read
	JP		(HL)						; jump to the stats read routine
	
;---------------------------------------------------------------------

DataRead:
	LD		A,(IX + DataPortIndex)
	LD		(AddressDataIn),A			; modify code with the Data port
	DB		IN_OPCODE
AddressDataIn:
	DB		00							; perform the read
	RET

DataReadASCII:
	CALL	DataRead
	AND		ASCII_MASK				; Strip off MSB
	RET								; AND		ASCII_MASK

; Enter DataWrite the value to be output in C
DataWrite:
	LD		A,(IX + DataPortIndex)
	LD		(AddressDataOut),A			; modify code with the Data port
	LD		A,C							; get value into ACC
	DB		OUT_OPCODE
AddressDataOut:
	DB		00							; perform the write
	RET

	
; Enter Status Read with Target mask in D	
StatusRead:
	LD		A,(IX + StatusPortIndex)
	LD		(AddressStatus),A			; modify code with the status port
	DB		IN_OPCODE
AddressStatus:
	DB		00
	AND		D							; Check return vale with the mask
	RET
	
DUMMYRead:
	RET	
DUMMYWrite:
	RET	
DUMMYCheck:
	LD		A,0FFH						; Always return 0FFH
	OR		A							; Set flags
	RET

;=============================================================================	
SetDeviceVector:
	AND		03H					; Get bits 0 & 1;
	ADD		A,A					; Double for word size index
	LD		D,00H
	LD		E,A					; load byte index int DE
	ADD		IX,DE				; add to the value vector base
								; IX points at correct entry in vector
	LD		E,(IX + 0)
	LD		D,(IX + 1)			; DE now has the Vector for the device
;	LD		IX,0000H
;	ADD		IX,DE				; Move it to IX
	PUSH	DE
	POP		IX					; Move it to IX
	RET


;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Physical Device Attributes

TTY_StatusPort		EQU		0EDH
TTY_DataPort		EQU		0ECH
TTY_OutputMask		EQU		80H		; Status Mask
TTY_InputMask		EQU		7FH		; Status Mask

CRT_StatusPort		EQU		02H
CRT_DataPort		EQU		01H
CRT_OutputMask		EQU		80H		; Status Mask - ready for output
CRT_InputMask		EQU		07FH	; Status Mask - bytes yet to have been read

COM_StatusPort		EQU		0EDH
COM_DataPort		EQU		0ECH
COM_OutputMask		EQU		01H		; Status Mask
COM_InputMask		EQU		02H		; Status Mask

LPT_StatusPort		EQU		011H
LPT_DataPort		EQU		010H
LPT_OutputMask		EQU		0FFH	; Status Mask - ready for output
LPT_InputMask		EQU		07FH	; Status Mask - not used

DUMMY_StatusPort	EQU		011H
DUMMY_DataPort		EQU		010H
DUMMY_OutputMask	EQU		0FFH	; Status Mask - ready for output
DUMMY_InputMask		EQU		07FH	; Status Mask - not used

; Device Table Control Block Definition
StatusPortIndex		EQU		0
DataPortIndex		EQU		1	
OutputMaskIndex		EQU		2	
InputMaskIndex		EQU		3		
StatusReadIndex		EQU		4	
DataReadIndex		EQU		6	
DataWriteIndex		EQU		8

;Physical Devices Control Blocks

TTY_Table:
 	DB		TTY_StatusPort
 	DB		TTY_DataPort
 	DB		TTY_OutputMask
 	DB		TTY_InputMask
	DW		StatusRead
	DW		DataReadASCII
	DW		DataWrite
	
CRT_Table:
 	DB		CRT_StatusPort
 	DB		CRT_DataPort
 	DB		CRT_OutputMask
 	DB		CRT_InputMask
	DW		StatusRead
	DW		DataRead
	DW		DataWrite
COM_Table:
 	DB		COM_StatusPort	
 	DB		COM_DataPort	
 	DB		COM_OutputMask	
 	DB		COM_InputMask
	DW		StatusRead
	DW		DataRead
	DW		DataWrite	
LPT_Table:
 	DB		LPT_StatusPort	
 	DB		LPT_DataPort	
 	DB		LPT_OutputMask	
 	DB		LPT_InputMask
	DW		StatusRead
	DW		DataRead
	DW		DataWrite	
DUMMY_Table:
 	DB		DUMMY_StatusPort
 	DB		DUMMY_DataPort	
 	DB		DUMMY_OutputMask
 	DB		DUMMY_InputMask
	DW		DUMMYCheck
	DW		DUMMYRead
	DW		DUMMYWrite
 
;---------------------------------------------------------------------------

; Logical Device Vector, Controlled by IOBYTE

CON_Vector:					; IOBYTE bits 1 & 0
	DW		TTY_Table
	DW		CRT_Table
	DW		COM_Table
	DW		DUMMY_Table
RDR_Vector:					; IOBYTE bits 3 & 2
	DW		TTY_Table
	DW		CRT_Table
	DW		DUMMY_Table	
	DW		DUMMY_Table
PUN_Vector:					; IOBYTE bits 5 & 4
	DW		TTY_Table
	DW		DUMMY_Table
	DW		COM_Table
	DW		CRT_Table
LST_Vector:					; IOBYTE bits 7 & 6
	DW		LPT_Table
	DW		CRT_Table
	DW		LPT_Table
	DW		DUMMY_Table

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 ;-------------------------------------------------
  ;	Disk routines
 ;---------------------------------------------------------------------------
 ;**********************
 ;	Home Disk	BIOS 08
 ;HOME - Home the selected logical disk to track 0.
 ;	Before doing this, a check must be made to see if the
 ;	physical disk buffer has information that must be
 ;	written out. This is indicated by a flag, MustWriteBuffer,
 ;	set in the de-blocking code
 ;**********************
 HOME:
 	LD		A,(MustWriteBuffer)					; check flag
 	OR		A
 	JP	NZ,HomeNoWrite
 	LD		(DataInDiskBuffer),A				; no, so indicate empty buffer
 HomeNoWrite:
 	LD		C,00H							; Set to track 0
 	CALL	SETTRK							; no, physical, only logical
 	RET
 
 ;	Select Disk	BIOS 09
 ; Select disk in C. C=0 for A: 1 for B: etc.
 ; Return the address of the appropriate disk parameter header
 ; in HL, or 0000H if selected disk does not exist
 ;**********************
 SELDSK:
 	LD		HL,00H							; Assume an error
 	LD		A,C
 	CP		NumberOfLogicalDisks
 	RET	NC; return if > max number of Disks
 
 	LD		(SelectedDisk),A					; save disk number
 	LD		L,A								; make disk into word number
 	LD		H,0
 ; Compute offset down disk parameter table by multiplying by parameter
 ; header length (16 bytes)
 	ADD		HL,HL
 	ADD		HL,HL
 	ADD		HL,HL
 	ADD		HL,HL								; pointing at right one
 	LD		DE,DiskParameterHeaders			; get DPH address
 	ADD		HL,DE								; DE -> appropriate DPH
 	PUSH	HL								; Save DPH pointer
 	LD		DE,10							; DiskParameterBlock Index
 	ADD		HL,DE								; ????? -> cpmRecords per track
 	LD		E,(HL)
 	INC		HL
 	LD		D,(HL)								; DE has Parameter Block for selected disk
 	LD		HL,15							; SectorsPerHead Index
 	ADD		HL,DE								; HL is at SecPerHeadPerTrack
 	LD		A,(HL)								; get the value and
 	LD		(SelectedDskSecsPerHead),A			; save for actual IO
 
 	POP	HL									; recover DPH pointer
 	RET
 
 ;**********************
 ;	Set Track	BIOS 0A
 ;SETTRK - Set logical track for next read or write.	Track is in BC
 ;**********************
 SETTRK:
 	LD		H,B								; select track in BC on entry
 	LD		L,C
 	LD	(SelectedTrack),HL					; save for low level driver
 	RET
 ;**********************
 ;	Set Sector	BIOS 0B
 ;SETSEC - Set logical sector for next read or write. Sector is in C
 ;**********************
 SETSEC:
 	LD		A,C
 	LD		(SelectedSector),A					; save for low level driver
 	RET
 ;**********************
 ;	Set Sector	BIOS 0C
 ;SetDMA - Set DMA (input/output) address for next read or write. Address in BC
 ;**********************
 SETDMA:
 	LD		L,C								; select address in BC on entry
 	LD		H,B
 	LD	(DMAAddress),HL						; save for low level driver
 	RET
 ;**********************
 ;	Sector Translate	BIOS 10
 ;SECTRAN - Translate logical sector to physical
 ; on Entry:	BC= logical sector number DE-> appropriate skew table
 ; on Exit:	HL = physical sector number
 ;**********************
 SECTRAN:
 	PUSH	BC
 	POP		HL								; just move the value from BC to HL
 	RET
 
 ;************************************************************************************************
 ;        READ	BIOS
 ; Read in the  CP/M record specified by previous calls to select disk and to set track  and
 ; sector. The sector will be read into the address specified in the previous call to set DMA address
 ;
 ;************************************************************************************************
 READ:
 	XOR		A								; set record count to 0
 	LD		(UnalocatedlRecordCount),A
 	INC		A
 	LD		(ReadFlag),A						; Set to non zero to indicate that this is a read
 	LD		(PrereadSectorFlag),A				; force pre-read
 	LD		A,WriteUnallocated				; fake de-blocking code into responding as if this
 	LD		(WriteType),A						; is the first write to an unallocated allocation block
 	JP		PerformReadWrite				; use common code to execute read
 ;----------------------------------------
 ;************************************************************************************************
 ;	WRITE
 ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
 ;
 ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
 ;	00H [WriteAllocated]	 An already allocated allocation block (which means a pre-read of the sector may be needed),
 ;	01H [WriteDirectory]	 To the directory (in which case the data will be written to the disk immediately),
 ;	02H	[WriteUnallocated]	 To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
 ;
 ; Only writes to the directory take place immediately.
 ; In all other cases, the data will be moved from the DMA address into the disk buffer,
 ; and only written out when circumstance force the transfer.
 ; The number of physical disk operations can therefore be reduced considerably.
 ;************************************************************************************************
 WRITE:
 ; Buffered I/O
 	XOR		A
 	LD		(ReadFlag),A						; Set to zero to indicate that this is not a read
 	LD		A,C
 	LD		(WriteType),A						; save the BDOS write type (0,1,2)
 	CP		WriteUnallocated				; first write to an unallocated allocation block ?
 	JP	NZ,CheckUnallocatedBlock			; No, - in the middle of writing to an unallocated block ?
 ; Yes, It is the first write to unallocated allocation block.
 ; Initialize  variables associated with unallocated writes
 	LD		A,RecordsPerBlock				; Number of records
 	LD		(UnalocatedlRecordCount),A 			; reset Unallocated Record Count to recordsPerBlock
 	LD		HL,SelectedDkTrkSec
 	LD		DE,UnallocatedDkTrkSec
 	CALL 	MoveDkTrkSec					; copy disk, track & sector into unallocated variables
 
 ; Check if this is not the first write to an unallocated allocation block -- if it is,
 ; the unallocated record count has just been set to the number of records in the allocation block
 CheckUnallocatedBlock:
 	LD		A,(UnalocatedlRecordCount)
 	OR		A
 	JP	Z,RequestPreread					; No - write to an unallocated block
 	DEC		A
 	LD		(UnalocatedlRecordCount),A			; decrement records left
 
 	LD		HL,SelectedDkTrkSec				; same Disk, Track & sector as for those in an unallocated block
 	LD		DE,UnallocatedDkTrkSec
 	CALL	CompareDkTrkSec					; are they the same
 	JP	NZ,RequestPreread					; NO - do a pre-read
 	EX	DE,HL 
 	INC		M								; increment UnalocatedlRecordCount
 	LD		A,(HL)
 	CP		SectorsPerTrack					; Sector > maximum on track ?
 	JP	C,NoTrackChange					; No ( A < M)
 	LD		(HL),00H							; Yes
 	LD	HL,(UnallocatedTrack)
 	INC		HL								; increment track
 	LD	(UnallocatedTrack),HL
 NoTrackChange:
 	XOR		A
 	LD		(PrereadSectorFlag),A				; clear flag
 	JP		PerformReadWrite
 
 RequestPreread:
 	XOR		A
 	LD		(UnalocatedlRecordCount),A			; not a write into an unallocated block
 	INC		A
 	LD		(PrereadSectorFlag),A				; set flag
 ;*******************************************************
 ; Common code to execute both reads and writes of 128-byte records
 ;*******************************************************
 PerformReadWrite:
 	XOR		A								; Assume no disk error will occur
 	LD		(DiskErrorFlag),A
 	LD		A,(SelectedSector)
 	RRA										; Convert selected record
 	RRA										; into physical sector by dividing by 4
 	AND		03FH							; remove unwanted bits
 	LD		(SelectedPhysicalSector),A
 	LD		HL,DataInDiskBuffer				; see if there is any data here ?
 	LD		A,(HL)
 	LD		(HL),001H							; force there is data here for after the actual read
 	OR		A								; really is there any data here ?
 	JP	Z,ReadSectorIntoBuffer			; NO ?- go read into buffer
 ;
 ; The buffer does have a physical sector in it, Note: The disk, track, and PHYSICAL sector
 ; in the buffer need to be checked, hence the use of the CompareDkTrk subroutine.
 	LD		DE,InBufferDkTrkSec
 	LD		HL,SelectedDkTrkSec				; get the requested sector
 	CALL	CompareDkTrk					; is it in the buffer ?
 	JP	NZ,SectorNotInBuffer				; NO,jump - it must be read
 ; Yes, it is in the buffer
 	LD		A,(InBufferSector)					; get the sector
 	LD		HL,SelectedPhysicalSector
 	CP		M								; Check if correct physical sector
 	JP	Z,SectorInBuffer					; Yes - it is already in memory
 ; No, it will have to be read in over current contents of buffer
 SectorNotInBuffer:
 	LD		A,(MustWriteBuffer)
 	OR		A								; do we need to write ?
 	CALL	NZ,WritePhysical					; if yes - write it out
 
 ReadSectorIntoBuffer:
 ; indicate the  selected disk, track, and sector now residing in buffer
 	LD		A,(SelectedDisk)
 	LD		(InBufferDisk),A
 	LD	HL,(SelectedTrack)
 	LD	(InBufferTrack),HL
 	LD		A,(SelectedPhysicalSector)
 	LD		(InBufferSector),A
 
 	LD		A,(PrereadSectorFlag)				; do we need to pre-read
 	OR		A
 	CALL	NZ,ReadPhysical					; yes - pre-read the sector
 
 ; At this point the data is in the buffer.
 ; Either it was already here, or we returned from ReadPhysical
 
 	XOR		A								; reset the flag
 	LD		(MustWriteBuffer),A					; and store it away
 
 ; Selected sector on correct track and  disk is already 1n the buffer.
 ; Convert the selected cpmRecord into relative address down the buffer.
 SectorInBuffer:
 	LD		A,(SelectedSector)
 	AND		SectorMask						; only want the least bits
 	LD		L,A								; to calculate offset into 512 byte buffer
 	LD		H,00H							; Multiply by 128 - cpmRecordSize
 	ADD		HL,HL								; *2
 	ADD		HL,HL								; *4
 	ADD		HL,HL								; *8
 	ADD		HL,HL								; *16
 	ADD		HL,HL								; *32
 	ADD		HL,HL								; *64
 	ADD		HL,HL								; *128
 	LD		DE,DiskBuffer
 	ADD		HL,DE								; HL -> record number start address
 	EX	DE,HL ; DE -> sector in the disk buffer
 	LD	HL,(DMAAddress)						; Get DMA address (set in SETDMA)
 	EX	DE,HL ; assume a read so :
 ; DE -> DMA Address & HL -> sector in disk buffer
 	LD		C,cpmRecordSize/8				; 8 bytes per move (loop count)
 ;
 ;  At this point -
 ;	C	->	loop count
 ;	DE	->	DMA address
 ;	HL	->	sector in disk buffer
 ;
 	LD		A,(ReadFlag)						; Move into or out of buffer /
 	OR		A								; 0 => Write, non Zero => Read
 	JP	NZ,BufferMove						; Move out of buffer
 
 	INC		A								; going to force a write
 	LD		(MustWriteBuffer),A
 	EX	DE,HL ; DE <--> HL
 
 ;The following move loop moves eight bytes at a time from (HL> to (DE), C contains the loop count
 BufferMove:
 	LD		A,(HL)								; Get byte from source
 	LD	(DE),A								; Put into destination
 	INC		DE								; update pointers
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 
 	DEC		C								; count down on loop counter
 	JP	NZ,BufferMove						; repeat till done (CP/M sector moved)
 ; end of loop
 
 	LD		A,(WriteType)						; write to directory ?
 	CP		WriteDirectory
 	LD		A,(DiskErrorFlag)					; get flag in case of a delayed read or write
 	RET	NZ; return if delayed read or write
 
 	OR		A								; Any disk errors ?
 	RET	NZ; yes - abandon attempt to write to directory
 
 	XOR		A
 	LD		(MustWriteBuffer),A					; clear flag
 	CALL	WritePhysical
 	LD		A,(DiskErrorFlag)					; return error flag to caller
 	RET
 ;********************************************************************
 ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
 CompareDkTrk:
 	LD		C,03H							; Disk(1), Track(2)
 	JP		CompareDkTrkSecLoop
 CompareDkTrkSec:							;Compares just the disk and track   pointed to by DE and HL
 	LD		C,04H							; Disk(1), Track(2), Sector(1)
 CompareDkTrkSecLoop:
 	LD	A,(DE)
 	CP		M
 	RET	NZ; Not equal
 	INC		DE
 	INC		HL
 	DEC		C
 	RET	Z; return they match (zero flag set)
 	JP		CompareDkTrkSecLoop				; keep going
 
 ;********************************************************************
 ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE
 MoveDkTrkSec:
 	LD		C,04H							; Disk(1), Track(2), Sector(1)
 MoveDkTrkSecLoop:
 	LD		A,(HL)
 	LD	(DE),A
 	INC		DE
 	INC		HL
 	DEC		C
 	RET	Z
 	JP		MoveDkTrkSecLoop
 ;********************************************************************
 
 ;********************************************************************
 ;Write contents of disk buffer to correct sector
 WritePhysical:
 	LD		A,DiskWriteCode					; get write function
 	JP		CommonPhysical
 
 ReadPhysical:
 	LD		A,DiskReadCode					; get read function
 
 CommonPhysical:
 	LD		(DCTCommand),A						; set the command
 	LD		A,(InBufferDisk)
 	AND		03H								; only units 0 to 3
 	LD		(DCTUnit),A							; set disk
 	LD	HL,(InBufferTrack)
 	LD		A,L								; for this controller it is a byte value
 	LD		(DCTTrack),A						; set track
 ;  The sector must be converted into a head number and sector number.
 ; This set of disks and Diskettes only have two Heads ******
 	LD		B,0								; assume head 0
 	LD		HL,SelectedDskSecsPerHead		; Point at track counts
 	LD		A,(InBufferSector)					; get target sector
 Head0:
 	CP		M								; Need another Head?
 	JP	C,Head1							; nope Acc < M
 
 	SUB		M								; subtrack track value
 	INC		B								; Increment head
 	JP		Head0							; loop til done
 
 Head1:
 	INC		A								; physical sectors start at 1
 	LD		(DCTSector),A
 	LD		A,B
 	LD		(DCTHead),A							; set head number
 
 	LD		HL,diskSectorSize
 	LD	(DCTByteCount),HL					; set byte count
 	LD		HL,DiskBuffer
 	LD	(DCTDMAAddress),HL					; set transfer address
 
 ;	As only one control table is in use, close the status and busy chain pointers
 ;  back to the main control bytes
 	LD		HL,DiskStatusLocation
 	LD	(DCTNextStatusBlock),HL
 	LD		HL,DiskControlByte
 	LD	(DCTNextControlLocation),HL
 	LD		HL,DCTCommand
 	LD	(DiskCommandBlock),HL
 
 	LD		HL,DiskControlByte				; activate disk controller
 	LD		(HL),080H
 
 ;Wait until Disk Status Block indicates , operation complete, then check
 ; if any errors occurred. ,On entry HL -> disk control byte
 WaitForDiskComplete:
 	LD		A,(HL)								; get control bytes
 	OR		A
 	JP	NZ,WaitForDiskComplete				; operation not done
 
 	LD		A,(DiskStatusLocation)				; done , so now check status
 	CP		080H
 	JP	C,DiskError
 	XOR		A
 	LD		(DiskErrorFlag),A					; clear the flag
 	RET
 
 DiskError:
 	LD		A,1
 	LD		(DiskErrorFlag),A					; set the error flag
 	RET
 
 ;********************************************************************
 ;********************************************************************
 ;********************************************************************
 
 ;---------------------------------------------------------------------------
 ;	Disk Data
 ;---------------------------------------------------------------------------
 ;	Disk Equates
 ;---------------------------------------------------------------------------
 ; Disk Types
 ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
 ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
 ;;HardDisk	EQU	2						; hard disk
 ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
 
 
 ;**************************************************************************************************
 ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
 ;
 ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
 ; perform some disk operation.  These are called its disk control byte.
 ; If the most significant bit of  disk control byte is set, the controller will look at the word
 ; following the respective control bytes. This word must contain the address of  valid disk control
 ; table that specifies the exact disk operation to be performed.
 ;
 ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
 ; This indicates completion to the disk driver code.
 ;
 ;  The controller also sets a return code in a disk status block - location 0X43H.
 ; If the first byte of this status block is less than 80H. then a disk error
 ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
 ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
 ; ten times before the controller returns an error
 ;
 ;  The disk control table layout is shown below. Note that the controller has the capability
 ; for control tables to be chained together so that a sequence of disk operations can be initiated.
 ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
 ; in the disk control tables be pointed back to the main control bytes in order to indicate
 ; the end of the chain
 ;**************************************************************************************************
 
 ;***************************************************************************
 ;	Disk Control tables
 ;***************************************************************************
 ;;DiskControlTable:
 DCTStart:
 DCTCommand:				DB		00H			; Command
 DCTUnit:				DB		00H			; unit (drive) number = 0 or 1
 DCTHead:				DB		00H			; head number = 0 or 1
 DCTTrack:				DB		00H			; track number
 DCTSector:				DB		00H			; sector number
 DCTByteCount:			DW		0000H		; number of bytes to read/write
 DCTDMAAddress:			DW		0000H		; transfer address
 DCTNextStatusBlock:		DW		0000H		; pointer to next status block
 DCTNextControlLocation:	DW		0000H		; pointer to next control byte
 DCTSize					EQU		$-DCTStart
 ;-----------------------------------------
 ;WriteAllocated		EQU	00H		W_NORMAL
 ;WriteDirectory		EQU	01H		W_DIRECTORY
 ;WriteUnallocated	EQU	02H		W_NEW_BLOCK
 ;-----------------------------------------
 
 WriteType:				DB		00H			; The type of write indicated by BDOS
 
 ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
 InBufferDkTrkSec:
 InBufferDisk:			DB		00H
 InBufferTrack:			DW		00H
 InBufferSector:			DB		00H
 DataInDiskBuffer:		DB		00H			; when non-zero, the disk buffer has data from disk
 MustWriteBuffer:		DB		00H			; Non-zero when data has been written into DiskBuffer,
 											;   but not yet written out to the disk
 ;---------------------------------------------------------------------------
 ;	Disk Storage area
 ;---------------------------------------------------------------------------
 ;     variables for selected disk, track and sector
 ; These are moved and compared as a group, DO NOT ALTER
 SelectedDskSecsPerHead:	DB		00H			; Sectors / head
 
 SelectedDkTrkSec:
 SelectedDisk:			DB		00H
 SelectedTrack:			DW		00H
 SelectedSector:			DB		00H
 DMAAddress:				DW		00H			; DMA address
 
 SelectedPhysicalSector:
 						DB	00H
 
 ; Parameters for writing to a previously unallocated allocation block
 ; These are moved and compared as a group, DO NOT ALTER
 UnallocatedDkTrkSec:
 UnallocatedDisk:		DB	00H
 UnallocatedTrack:		DW	00H
 UnallocatedSector:		DB	00H
 UnalocatedlRecordCount:	DB	00H				; Number of unallocated "records"in current previously unallocated allocation block.
 DiskErrorFlag:			DB	00H				; Non-Zero - unrecoverable error output "Bad Sector" message
 											; Flags used inside the de-blocking code
 PrereadSectorFlag:		DB	00H				; non-zero if physical sector must be read into the disk buffer
 											; either before a write to a allocated block can occur, or
 											; for a normal cpmRecord read
 ReadFlag:				DB	00H				; Non-zero when a cpmRecord is to be read
 
 ;---------------------------------------------------------------------------
 
 ;---------------------------------------------------------------------------
 ;	Disk Definition Tables
 ; These consists of disk parameter headers, with one entry
 ; per logical disk driver, and disk parameter blocks, with
 ; either one parameter block per logical disk or the same
 ; parameter block for several logical disks.
 ;---------------------------------------------------------------------------
 ;---------------------------------------------------------------------------
 DiskParameterHeaders:
 
 ; Logical Disk A: (3.25" HD 1.44MB Diskette)
 	DW		0000H							; Floppy5SkewTable  - No Skew table
 	DW		0000H							; Rel pos for file (0-3)
 	DW		0000H							; Last Selected Track #
 	DW		0000H							; Last Selected Sector #
 	DW		DirectoryBuffer					; all disks use this buffer
 	DW		ParameterBlock3HD				; specific to disk's parameters
 	DW		DiskAWorkArea
 	DW		DiskAAllocationVector
 
 ; Logical Disk B: (3.25" HD 1.44MB Diskette)
 	DW		0000H							; No Skew table
 	DW		0000H							; Rel pos for file (0-3)
 	DW		0000H							; Last Selected Track #
 	DW		0000H							; Last Selected Sector #
 	DW		DirectoryBuffer					; all disks use this buffer
 	DW		ParameterBlock3HD				; specific to disk's parameters
 	DW		DiskBWorkArea
 	DW		DiskBAllocationVector
 
 ; Logical Disk C: (3.25" HD 1.44MB Diskette)
 	DW		0000H							; No Skew table
 	DW		0000H							; Rel pos for file (0-3)
 	DW		0000H							; Last Selected Track #
 	DW		0000H							; Last Selected Sector #
 	DW		DirectoryBuffer					; all disks use this buffer
 	DW		ParameterBlock3HD				; specific to disk's parameters
 	DW		DiskCWorkArea
 	DW		DiskCAllocationVector
 
 ; Logical Disk D: (3.25" HD 1.44MB Diskette)
 	DW		0000H							; No Skew table
 	DW		0000H							; Rel pos for file (0-3)
 	DW		0000H							; Last Selected Track #
 	DW		0000H							; Last Selected Sector #
 	DW		DirectoryBuffer					; all disks use this buffer
 	DW		ParameterBlock3HD				; specific to disk's parameters
 	DW		DiskDWorkArea
 	DW		DiskDAllocationVector
 
 
 ;-----------------------------------------------------------
 
 ParameterBlock3HD:
 	DW		dpb3hdSPT						; cpmRecords per track- (144)
 	DB		dpb3hdBSH						; Block shift ( 4=> 2K)
 	DB		dpb3hdBLM						; Block mask
 	DB		dpb3hdEXM						; Extent mask
 	DW		dpb3hdDSM						; Maximum allocation block number (710)
 	DW		dpb3hdDRM						; Number of directory entries - 1 (127)
 	DB		dpb3hdAL0						; Bit map for reserving 1 alloc. block
 	DB		dpb3hdAL1						;  for file directory
 	DW		dpb3hdCKS						; Disk change work area size (32)
 	DW		dpb3hdOFF						; Number of tracks before directory
 
 	DB		(dpb3hdSPT/4)/dpb3hdNOH			; number of Sectors/Head
 
 
 
 ;---------------------------------------------------------------------------
 ;	Disk work area
 ;---------------------------------------------------------------------------
 ; These are used by the BDOS to detect any unexpected
 ; change of diskette. The BDOS will automatically set
 ; such a changed diskette to read-only status.
 
 DiskAWorkArea:	DS	dpb3hdCKS				; A:  020H
 DiskBWorkArea:	DS	dpb3hdCKS				; B:  020H
 DiskCWorkArea:	DS	dpb3hdCKS				; C:  020H
 DiskDWorkArea:	DS	dpb3hdCKS				; D:  020H
 
 ;---------------------------------------------------------------------------
 ;	Disk allocation vectors
 ;---------------------------------------------------------------------------
 ; Disk allocation vectors
 ; These are used by the BDOS to maintain a bit map of
 ; which allocation blocks are used and which are free.
 ; One byte is used for eight allocation blocks, hence the
 ; expression of the form (allocation blocks/8)+1
 
 DiskAAllocationVector:	DS	(dpb3hdDSM/8)+1 ; A:
 DiskBAllocationVector:	DS	(dpb3hdDSM/8)+1 ; B:
 
 DiskCAllocationVector:	DS	(dpb3hdDSM/8)+1 ; C:
 DiskDAllocationVector:	DS	(dpb3hdDSM/8)+1 ; D:
 ;---------------------------------------------------------------------------
 ;	Disk Buffer
 ;---------------------------------------------------------------------------
 DirectoryBuffer:	DS		DirBuffSize
 ;---------------------------------------------------------------------------
 ;**********************************************************************************
 ;	Disk Control table image for warm boot
 ;**********************************************************************************
 BootControl:
 	DB		DiskReadCode					; Read function
 	DB		00H								; unit number
 	DB		00H								; head number
 	DB		00H								; track number
 	DB		02H								; Starting sector number (skip cold boot sector)
 	DW		CCPLength + BDOSLength			; Number of bytes to read ( rest of the head)
 	DW		CCPEntry						; read into this address
 	DW		DiskStatusLocation				; pointer to next block - no linking
 	DW		DiskControlByte					; pointer to next table- no linking
 
 ;
 ;**********************************************************************************
 ;	Warm Boot
 ;  On warm boot. the CCP and BDOS must be reloaded into memory.
 ; This code is hardware specific to the 3.5 HD controller.
 ;**********************************************************************************
 
 WBOOT:
 	LD		SP,CCPEntry -1
 	LD		HL,BootControl					; point at the disk control table
 	LD	(DiskCommandBlock),HL
 	
 	LD		HL,DiskControlByte
 	LD		(HL),080H							; activate the controller
 	
 WaitTillDone:
 	LD		A,(HL)								; Get the control byte
 	OR		A								; Reset to 0 (Completed operation) ?
 	JP	NZ,WaitTillDone					; if not try again
 	
 	LD		A,(DiskStatusLocation)				; after operation what's the status?
 	CP		080H							; any errors ?
 	JP	NC,EnterCPM						; Nope
 											; yes
 WarmBootError:
 	LD		HL,WarmBootErroMessage			; point at error message
 	CALL	DisplayMessage					; sent it. and
 	JP		WBOOT							; try again.
 	
 ;---------------------------------------------------------------------------
 DisplayMessage:
 	LD		A,(HL)								; get next message byte
 	OR		A								; terminator (a = 0)?
 	RET	Z; Yes, thes return to caller
 
 	LD		C,A								; prepare for output
 	PUSH	HL								; save message pointer
 	CALL	CONOUT							; go to main console output routine *******
 	POP		HL
 	INC		HL 								; point at next character
 	JP		DisplayMessage					; loop till done
 	
 WarmBootErroMessage:
 	DB		CR,LF
 	DB		'Warm Boot -'
 	DB		' Retrying.'
 	DB		CR,LF
 	DB		EndOfMessage
 
 ;--------------------BOOT-----------------------------
 
 						; entered directly from the BIOS JMP vector
 						; Control transfered by the CP/M bootstrap loader
 						; Sets up Page Zero
 ;---------------End of Cold Boot Initialization Code--------------
 
 BOOT:
 EnterCPM:
 	LD		A,0C3H							; JMP op code
 	LD		(0000H),A							; set up the jump in location 0000H
 	LD		(0005H),A							; and at location 0005H
 
 	LD		HL,WarmBootEntry					; get BIOS vector address
 	LD	(0001H),HL							; put address in location 1
 
 	LD		HL,BDOSEntry						; Get BDOS entry point address
 	LD	(0006H),HL							; put address at location 5
 
 	LD		BC,DMABuffer						; DefaultDiskBuffer set disk I/O address to default
 	CALL	SETDMA							; use normal BIOS routine
 
 	EI
 	LD		A,(Pg0CurentDisk)					; DefaultDisk  Transfer current default disk to
 	LD		C,A								; Console Command Processor
 	JP		CCPEntry						; transfer to CCP
 
 ;-------------------------------------------------
 
