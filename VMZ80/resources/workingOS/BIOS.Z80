;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
; BIOS.Z80

; 2018 12-11 Adjusted BOOT & WBOOT
; 2018-12-10 Refactored  character device routines;
; 2017-03-31 Added List out functionality for List Device
; 2017-03-02 Refactored the CP/M Suite
; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
; 2014-01-16
; 2014-03-14  :  Frank Martyn

; BIOS Function Descriptions are from THE PROGRAMMER'S CP/MÂ® HANDBOOK
; by Andy Johnson-Laird
;
; Published by
; Osborne/McGraw-Hill
; 2600 Tenth Street
; Berkeley, California 94710
; U.S.A.

	$Include ./stdHeader.Z80
	$Include ./osHeader.Z80
	$Include ./diskHeader.Z80

BOOT_CON_ADDRESS	EQU	0ECH				; tty data address

IN_OPCODE	EQU	0DBH
OUT_OPCODE	EQU	0D3H
JP_OPCODE	EQU	0C3H


	ORG		BIOSStart						; Assemble code at BIOS address
											; BIOS jump Vector
CodeStart:

	JP		BOOT							; 00 Cold/Hard Boot
WarmBootEntry:
	JP		WBOOT							; 01 Warm/Soft Boot
	JP		CONST							; 02 Get Console Status - CON:
	JP		CONIN							; 03 Get Character from Console - CON:
	JP		CONOUT							; 04 Send Character to Console - CON:
	JP		LIST							; 05 Send Character to List device - LST:
	JP		PUNCH							; 06 Send Character to Punch device - PUN:
	JP		READER							; 07 Get Character from Reader - RDR:
	JP		HOME							; 08 Position the disk to absolute track 00
	JP		SELDSK							; 09 Establish disk to be used by subsequent Read/Write
	JP		SETTRK							; 0A Establish track to be used by subsequent Read/Write
	JP		SETSEC							; 0B Establish sector to be used by subsequent Read/Write
	JP		SETDMA							; 0C Establish buffer location to be used by subsequent Read/Write
	JP		READ							; 0D Not Yet Checked
	JP		WRITE							; 0E Not Yet Checked
	JP		LISTST							; 0F Get List device Status - LST:
	JP		SECTRAN							; 10 De-skew sector number (null implementation)

;-------------------------------------------------
	ORG		(($+10H)/10H) * 10H

DiskBuffer:
	DS		diskSectorSize
AfterDiskBuffer	EQU	$
;-------------------------------------------------



;	ORG AfterDiskBuffer				; reset Location Counter

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;---------------------------------------------------------------------------
;	BOOT:  BIOS 00		Hard Boot/Cold Boot

;  The BOOT jump instruction is the first instruction executed in CP/M. The
; bootstrap sequence must transfer control to the BOOT entry point in order to
; bring up CP/M.
;  This reads in the CP/M loader on the first sector of the physical disk drive
; chosen to be logical disk A. This CP/M loader program reads the binary image
; of the CCP, BOOS, and BIOS into memory at some predetermined address.
; Then it transfers control to the BOOT entry point in the BIOS jump vector.
;  This BOOT routine must initialize all of the required computer hardware.
;
; Most BOOT routines sign on by displaying a short message on the console,
; indicating the current version ofCP/M and the computer hardware that this BIOS
; can support. The BOOT routine terminates by transferring control to the start of the CCP
; +6 bytes (the CCP has its own smalljump vector at the beginning). Just before the
; BOOT routine jumps into the CCP, it sets the C register to 0 to indicate that logical
; disk A is to be the default disk drive. This is what causes "A>" to be the CCP's
; initial prompt.

BOOT:
;CodeStart:
 	LD		HL,ROMControl
 	CALL	ReadRawDisk
  	JP		NC,TPA						; now execute the boot loader;

	CALL	NoDisk;
	HALT
		
ReadRawDisk:							; Enter with DiskControlBlock pointer in HL	
 	LD		(DiskCommandBlock),HL		; put it into the Command block for drive A:
 
 	LD		HL,DiskControlByte
 	LD		(HL),080H					; activate the controller
 
WaitForBootComplete:
 	LD		A,(HL)						; Get the control byte
 	OR		A							; is it set to 0 (Completed operation) ?
 	JR	NZ,WaitForBootComplete			; if not try again
 
 	LD		A,(DiskStatusLocation)		; after operation what's the status?
 	CP		080H						; any errors ?
 	RET									; exit with result in the CCs


;---------------------------- ROM Disk Control Block -------------------------;
ROMControl:                                                                   ;
 	DB		DiskReadCode				; Read function                       ;
 	DB		00H							; unit number                         ;
 	DB		00H							; head number                         ;
 	DB		00H							; track number                        ;
 	DB		01H							; Starting sector number ()           ;
 	DW		diskSectorSize				; Number of bytes to read ( 1 Sector) ;
 	DW		TPA							; read into this address              ;
 	DW		DiskStatusLocation			; pointer to next block - no linking  ;
 	DW		DiskControlTable			; pointer to next table- no linking   ;
;---------------------------- ROM Disk Control Block -------------------------;

 
NoDisk:
 	LD		HL,NoDiskMessage
DisplayMessage:
 	LD		A,(HL)
 	OR		A
 	RET	Z
 	OUT		(BOOT_CON_ADDRESS),A				; Console address
 	INC		HL
 	JR		DisplayMessage
	
NoDiskMessage:
 	DB		CR,LF
 	DB		'No System Disk Mounted'
 	DB		CR,LF,EndOfMessage 
WarmBootErroMessage:
	DB		CR,LF
	DB		'Warm Boot -'
	DB		' Retrying.'
	DB		CR,LF,EndOfMessage

	
;?	LD		HL,BootMessage
;?	CALL	DisplayMessage
;?
;?	LD		HL,BOOTControl
;?	CALL	RawDiskRead
;?
;?	JP		WBOOT				; do Warm boot if no errors
;?	LD		HL,BadBootMessage
;?	CALL	DisplayMessage		; Show Boot failure message
;?	HALT
;?
;?BOOTControl:
;?	DB		DiskReadCode					; Read function
;?	DB		00H								; unit number
;?	DB		00H								; head number
;?	DB		00H								; track number
;?	DB		0DH								; Starting sector number (13)
;?	DW		5 * 512							; Number of bytes to read ( 0A00 All of BIOS)
;?	DW		BIOSStart						; read into this address
;?	DW		DiskStatusLocation				; pointer to next block - no linking
;?	DW		DiskControlTable				; pointer to next table- no linking
;?
;?
;?;BOOTControl:
;?; 	DB		DiskReadCode		; Read function
;?; 	DB		00H					; unit number
;?; 	DB		00H					; head number
;?; 	DB		00H					; track number
;?; 	DB		01H					; Starting sector number ()
;?; 	DW		diskSectorSize		; Number of bytes to read ( 1 Sector)
;?; 	DW		TPA					; read into this address
;?; 	DW		DiskStatusLocation	; pointer to next block - no linking
;?; 	DW		DiskControlTable	; pointer to next table- no linking
;?
;?; Boot Messages and routine
;?BootMessage:
;?;	DB		'CP/M 2.2 (Z80) '
;?;	DB		'BootStrap Loader'
;?;	DB		CR,LF
;?	DB		'Build 0.A '
;?	DB		CR,LF
;?	DB		'CCP 0.A |  BDOS 0.A | BIOS 0.B'
;?	DB		CR,LF,EndOfMessage
;?BadBootMessage:
;?	DB		CR,LF
;?	DB		'****   Boot Failure'
;?	DB		EndOfMessage
;?WarmBootErroMessage:
;?	DB		CR,LF
;?	DB		'Warm Boot -'
;?	DB		' Retrying.'
;?	DB		CR,LF,EndOfMessage
;?;..................Boot Support....................
;?
;?; Entered with DiskControlBlock pointer in HL
;?RawDiskRead:
;?	LD		(DiskCommandBlock),HL
;?
;?	LD		HL,DiskControlByte
;?	LD		(HL),080H
;?
;?; wait for the read to complete
;?WaitForReadDone:
;?	LD		A,(HL)
;?	OR		A
;?	JR		NZ,WaitForReadDone
;?
;?; is it a clean read ?
;?	LD		A,(DiskStatusLocation)
;?	CP		080H				; any errors NC = good read?
;?	RET
;?
;?; entered with pointer to message in HL
;?DisplayMessage:
;?	LD		A,M					; get  character
;?	OR		A					; is it NULL
;?	RET		Z					; return if it is NULL (00)
;?	LD		C,A
;?	PUSH	HL					; save the pointer
;?	OUT		TTY_DataPort
;?	POP		HL					; retrieve the pointer
;?	INC		HL					; point at next character
;?	JR		DisplayMessage
;?
;....................................................

;---------------------------------------------------------------------------
;	WBOOT:  BIOS 01		SoftBoot/Warm Boot
;
;  Unlike the "cold" bootstrap entry point, which executes only once, the WBOOT
; or warm boot routine will be executed every time a program terminates by
; jumping to location OOOOH, or whenever you type a CONTROL-C on the console as
; the first character of an input line.
;  The WBOOT routine is responsible for reloading the CCP into memory.
; Programs often use all of memory up to the starting point of the BDOS, overwriting
; the CCP in the process. The underlying philosophy is that while a program is
; executing, the CCP is not needed, so the program can use the memory previously
; occupied by the CCP. The CCP occupies 800H (2048) bytes ofmemory-and this
; is frequently just enough to make the difference between a program that cannot
; run and one that can.
; A few programs that are self-contained and do not require the BDOS's
; facilities will also overwrite the BDOS to get another 1600H (5632) bytes of
; memory. Therefore, to be really safe, the WBOOT routine should read in both the
; CCP and the BDOS. It also needs to set up the two JMPs at location OOOOH (to
; WBOOT itself) and at location 0005H (to the BOOS). Location 0003H should be
; set to the initial value of the 10BYTE if this is implemented in the BIOS.
; As its last act, the WBOOT routine sets register C to indicate which logical disk
; is to be selected (C= 0 for A, I for B, and so on). It then transfers control into the
; CCP at the first instruction in order to restart the CCP.

WBOOT:
	LD		SP,CCPEntry-1		; put stack at top of User area
	LD		HL,WBOOTControl		; get the WBOOT Control Block
	CALL	ReadRawDisk			; read CCP & BDOS
	JR		NC, LoadPage0		; set up page 0 if good read

	LD		HL,WarmBootErroMessage
	CALL	DisplayMessage		; send bad warm boot message
	JP		WBOOT				; keep trying


; Set up page Zero
LoadPage0:
	LD		A,JP_OPCODE			; Get JP opCode

	LD		(WarmBoot),A
	LD		HL,WarmBootEntry	; Warm Boot entry point
	LD		(WarmBoot + 1),HL		; Warm Boot Vector

	LD		(BDOSE),A
	LD		HL,BDOSEntry		; BDOS entry point
	LD		(BDOSE + 1),HL		; BDOS Vector

	LD		BC,DMABuffer		; Default Disk Buffer
	CALL	SETDMA				; use normal BDOS  routine
	EI							; Enable interrupts

	LD		A,(Pg0CurentDisk)	; Let CCP know what disk is current
	LD		C,A
	JP		CCPEntry			; transfer control to CCP


WBOOTControl:
	DB		DiskReadCode		; Read function
	DB		00H					; unit number
	DB		00H					; head number
	DB		00H					; track number
	DB		02H					; Starting sector number (skip cold boot sector)
	DW		CCPLength + BDOSLength	; Number of bytes to read ( rest of the head)
	DW		CCPEntry			; read into this address
	DW		DiskStatusLocation	; pointer to next block - no linking
	DW		DiskControlByte		; pointer to next table- no linking
	
;---------------------------------------------------------------------------
;	Console Status:		BIOS 02
;
;  CONST simply returns an indicator showing whether there is an incoming
; character from the console device. The convention is that A = OFFH if a character
; is waiting to be processed, A = 0 if one is not. Note that the zero flag need not be set
; to reflect the contents of the A register - it is the contents that are important.
; CONST is called by the CCP whenever the CCP is in the middle of an
; operation that can be interrupted by pressing a keyboard character.
;
; The BDOS will call CONST if a program makes a Read Console Status
; function call (B$CONST, code 11, OBH). It is also called by the console input BIOS
; routine, CONIN

CONST:
ConStatus:
	LD		A,(IOBYTE)
	LD		IX,CON_Vector

GenericInStatus:				; Entry point for generic input status
	CALL	SetDeviceVector		; IX has the vector for the Physical Device
	CALL	GetInStatus
	OR		A
	RET		Z					; 00 => No data pending
	LD		A,0FFH
	RET							; OFFH => Data in Buffer
;---------------------------------------------------------------------
;	Console In:		BIOS 03
;
;  CONIN reads the next character from the console to the A register and sets the
; most significant (parity) bit to O. ; Normally, CONIN will call the CONST routine
; until it detects A = OFFH. Only then will it input the data character and mask off
; the parity bit. CONIN is called by the CCP and by the BDOS when a program executes a
; Read Console Byte function (B$CONIN, code 1).
; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.

; This is a blocking routine

CONIN:
ConIn:
	CALL	ConStatus
	JR		Z,ConIn				; loop until there is some data to read
								; Call to ConStatus Sets up IX with Physical Table
	LD		L,(IX + DataReadIndex)
	LD		H,(IX +(DataReadIndex +1 ))
	JP		(HL)
;---------------------------------------------------------------------------
;	Console Out:		BIOS 04
;
;  CONOUT outputs the character (in ASCII) in register C to the console. The
; most significant (parity) bit of the character will always be O.
; CONOUT must first check that the console device is ready to receive more
; data, delaying if necessary until it is, and only then sending the character to the
; device. CONOUT is called by the CCP and by the BDOS when a program executes a
; Write Console Byte function (B$CONOUT, code 2).

; This is a blocking routine

CONOUT:
CONOut:
	LD		A,(IOBYTE)
	LD		IX,CON_Vector

GenericOutStatus:					; entry point for standard blocking write
	CALL	SetDeviceVector			; IX has the vector for the Physical Device
GenericOutStatus1:
	CALL	GetOutStatus
	JR		Z,GenericOutStatus1		; wait until ready
	LD		L,(IX +DataWriteIndex)
	LD		H,(IX +(DataWriteIndex + 1))
	JP		(HL)

;---------------------------------------------------------------------------
;	List output  BIOS 05
;
; LIST is similar to CONOUT except that it sends the character in register C to
; the list device. It too checks first that the list device is ready to receive
; the character. LIST is called by the CCP in response to the CONTROL-P toggle
; for printer echo of console output, and by the BDOS when a program makes a
; Write Printer Byte or Display String call (B$LISTOUT and B$PRINTS, codes 5 and 9).

; This is a blocking routine

LIST:
	LD		A,(IOBYTE)
	RLCA							; move bits 7,6
	RLCA							; to 1,0
	LD		IX,LST_Vector
	JR		GenericOutStatus		; go to generic blocking out routine

;---------------------------------------------------------------------------
;	Punch output  BIOS 06
;
;  PUNCH sends the character in register C to the "punch" device. As mentioned
; earlier, the "punch" is rarely a real paper tape punch. In most BIOS's, the PUNCH
; entry point either returns immediately and is effectively a null routine, or it outputs
; the character to a communications device, such as a modem, on your computer.
; PUNCH must check that the "punch" device is indeed ready to accept another
; character for output, and must wait if it is not.
;
; Digital Research's documentation states that the character to be output will
; always have its most significant bit set to O. This is not true. The BDOS simply
; transfers control over to the PUNCH entry point in the BIOS; the setting of the
; most significant bit will be determined by the program making the BDOS function
; request (B$PUNOUT, code 4). This is important because the requirement of a zero
; would preclude being able to send pure binary data via the BIOS PUNCH
; function

; This is a blocking routine

PUNCH:				; Punch output
	LD		A,(IOBYTE)
	RRCA
	RRCA
	RRCA							; move bits 5,4
	RRCA							; to 1,0
	LD		IX,PUN_Vector
	JR		GenericOutStatus		; go to generic blocking out routine

;---------------------------------------------------------------------------
;	Reader input  BIOS 07
;
; As with the PUNCH entry point, the READER entry point rarely connects to
; a real paper tape reader.
; The READER function must return the next character from the reader device
; in the A register, waiting, if need be, until there is a character.
;
; Digital Research's documentation again says that the most significant bit of
; the A register must be 0, but this is not the case if you wish to receive pure binary
; information via this function.
; READER is called whenever a program makes a Read "Reader" Byte function
; request (B$READIN, code 3).

; This is a blocking routine

READER:				; Reader Input
	LD		A,(IOBYTE)
	RRCA
	RRCA							; move bits 3,2  to 1,0
	LD		IX,RDR_Vector
READER1:
	CALL	GenericInStatus
	JR		Z,READER1				; loop until there is some data to read
											
	LD		L,(IX + DataReadIndex)
	LD		H,(IX +(DataReadIndex +1 ))
	JP		(HL)

;---------------------------------------------------------------------------
;	List Status:  BIOS 0F

;  LISTST was added when CP/M was upgraded from version 1.4 to version 2.0.
; This function returns the current status of the list device, using the IOBYTE if
; necessary to select the correct physical device. It sets the A register to OFFH if the
; list device can accept another character for output or to OOH if it is not ready.
; Digital Research's documentation states that this function is used by the
; DESPOOL utility program (which allows you to print a file "simultaneously" with
; other operations) to improve console response during its operation, and that it is
; acceptable for the routine always to return OOH if you choose not to implement it
; fully.
; Unfortunately, this statement is wrong. Many other programs use the LISTST
; function to "poll" the list device to make sure it is ready, and if it fails to come
; ready after a predetermined time, to output a message to the console indicating
; that the printer is not ready. If you ever make a call to the BDOS list output
; functions, Write Printer Byte and Print String (codes 5 and 9), and the printer is
; not ready, then CP/M will wait forever-and your program will have lost control
; so it cannot even detect that the problem has occurred. If LISTST always returns a
; OOH, then the printer will always appear not to be ready. Not only does this make nonsense
; out of the LISTST function, but it also causes a stream of false "Printer
; not Ready" error messages to appear on the console.

LISTST:
	LD		A,(IOBYTE)				; Get Physical device
	RLCA
	RLCA							; Move bits 6 & 7 to bits 0 & 1
	LD		IX,LST_Vector			; Set th vector base
	CALL	SetDeviceVector			; IX has the vector for the Physical Device
	CALL	GetOutStatus

	OR		A
	RET		Z						; 00 => Device Ready
	LD		A,0FFH
	RET								; OFFH => Device No Ready

;---------------------------------------------------------------------------

;---------------------------------------------------------------------
GetOutStatus:
				; vector to CON Devices
	LD		D,(IX + OutputMaskIndex)	; setup Output mask
	JR		GetStatus
GetInStatus:
	LD		D,(IX + InputMaskIndex)		; setup Input mask
GetStatus:
	LD		L,(IX + StatusReadIndex)
	LD		H,(IX + (StatusReadIndex + 1))	; Load HL with address for Status Read
	JP		(HL)						; jump to the stats read routine

;---------------------------------------------------------------------

DataRead:
	LD		A,(IX + DataPortIndex)
	LD		(AddressDataIn),A		; modify code with the Data port
	DB		IN_OPCODE
AddressDataIn:
	DB		00						; perform the read
	RET

DataReadASCII:
	CALL	DataRead
	AND		ASCII_MASK				; Strip off MSB
	RET								; AND		ASCII_MASK

; Enter DataWrite the value to be output in C
DataWrite:
	LD		A,(IX + DataPortIndex)
	LD		(AddressDataOut),A		; modify code with the Data port
	LD		A,C						; get value into ACC
	DB		OUT_OPCODE
AddressDataOut:
	DB		00						; perform the write
	RET


; Enter Status Read with Target mask in D
StatusRead:
	LD		A,(IX + StatusPortIndex)
	LD		(AddressStatus),A		; modify code with the status port
	DB		IN_OPCODE
AddressStatus:
	DB		00
	AND		D						; Check return vale with the mask
	RET

DUMMYRead:
	RET
DUMMYWrite:
	RET
DUMMYCheck:
	LD		A,0FFH					; Always return 0FFH
	OR		A						; Set flags
	RET

;=============================================================================
SetDeviceVector:
	AND		03H						; Get bits 0 & 1;
	ADD		A,A						; Double for word size index
	LD		D,00H
	LD		E,A						; load byte index int DE
	ADD		IX,DE					; add to the value vector base
									; IX points at correct entry in vector
	LD		E,(IX + 0)
	LD		D,(IX + 1)				; DE now has the Vector for the device
	PUSH	DE
	POP		IX						; Move it to IX
	RET


;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Physical Device Attributes

TTY_StatusPort		EQU		0EDH
TTY_DataPort		EQU		0ECH
TTY_OutputMask		EQU		80H		; Status Mask
TTY_InputMask		EQU		7FH		; Status Mask

CRT_StatusPort		EQU		02H
CRT_DataPort		EQU		01H
CRT_OutputMask		EQU		80H		; Status Mask - ready for output
CRT_InputMask		EQU		07FH	; Status Mask - bytes yet to have been read

COM_StatusPort		EQU		0EDH
COM_DataPort		EQU		0ECH
COM_OutputMask		EQU		01H		; Status Mask
COM_InputMask		EQU		02H		; Status Mask

LPT_StatusPort		EQU		011H
LPT_DataPort		EQU		010H
LPT_OutputMask		EQU		0FFH	; Status Mask - ready for output
LPT_InputMask		EQU		07FH	; Status Mask - not used

DUMMY_StatusPort	EQU		011H
DUMMY_DataPort		EQU		010H
DUMMY_OutputMask	EQU		0FFH	; Status Mask - ready for output
DUMMY_InputMask		EQU		07FH	; Status Mask - not used

; Device Table Control Block Definition
StatusPortIndex		EQU		0
DataPortIndex		EQU		1
OutputMaskIndex		EQU		2
InputMaskIndex		EQU		3	
StatusReadIndex		EQU		4
DataReadIndex		EQU		6
DataWriteIndex		EQU		8

;Physical Devices Control Blocks

TTY_Table:
	DB		TTY_StatusPort
	DB		TTY_DataPort
	DB		TTY_OutputMask
	DB		TTY_InputMask
	DW		StatusRead
	DW		DataReadASCII
	DW		DataWrite

CRT_Table:
	DB		CRT_StatusPort
	DB		CRT_DataPort
	DB		CRT_OutputMask
	DB		CRT_InputMask
	DW		StatusRead
	DW		DataRead
	DW		DataWrite
COM_Table:
	DB		COM_StatusPort
	DB		COM_DataPort
	DB		COM_OutputMask
	DB		COM_InputMask
	DW		StatusRead
	DW		DataRead
	DW		DataWrite
LPT_Table:
	DB		LPT_StatusPort
	DB		LPT_DataPort
	DB		LPT_OutputMask
	DB		LPT_InputMask
	DW		StatusRead
	DW		DataRead
	DW		DataWrite
DUMMY_Table:
	DB		DUMMY_StatusPort
	DB		DUMMY_DataPort
	DB		DUMMY_OutputMask
	DB		DUMMY_InputMask
	DW		DUMMYCheck
	DW		DUMMYRead
	DW		DUMMYWrite

;---------------------------------------------------------------------------

; Logical Device Vector, Controlled by IOBYTE

CON_Vector:					; IOBYTE bits 1 & 0
	DW		TTY_Table
	DW		CRT_Table
	DW		COM_Table
	DW		DUMMY_Table
RDR_Vector:					; IOBYTE bits 3 & 2
	DW		TTY_Table
	DW		CRT_Table
	DW		DUMMY_Table
	DW		DUMMY_Table
PUN_Vector:					; IOBYTE bits 5 & 4
	DW		TTY_Table
	DW		DUMMY_Table
	DW		COM_Table
	DW		CRT_Table
LST_Vector:					; IOBYTE bits 7 & 6
	DW		LPT_Table
	DW		CRT_Table
	DW		LPT_Table
	DW		DUMMY_Table

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

;---------------------------------------------------------------------------
;	Disk routines
;---------------------------------------------------------------------------

;  All of the disk functions that follow were originally designed to operate on the
; 128-byte sectors used on single-sided, single-density, 8-inch floppy diskettes that
; were standard in the industry at the time. Now that CP/M runs on many different
; types of disks, some of the BIOS disk functions seem strange because most of the
; new disk drives use sector sizes other than 128 bytes.
; To handle larger sector sizes, the BIOS has some additional code that makes
; the BDOS respond as if it were still handling 128-byte sectors. This code is referred
; to as the blocking/deblocking code.
;  As its name implies, it blocks together several 128-byte "sectors" and only writes
; to the disk when a complete physical sector has been assembled.
;  When reading, it reads in a physical sector and then deblocks it,handing back
; several 128-byte "sectors" to the BDOS.
;  To do all of this, the blocking/deblocking code uses a special buffer area of the
; same size as the physical sectors on the disk. This is known as the host disk buffer
; or HSTBUE Physical sectors are read into this buffer and written to the disk
; from it. In order to optimize this blocking/deblocking routine, the BIOS has code in it
; to reduce the number of times that an actual disk read or write occurs. A side effect
; is that at any given moment, several 128-byte "sectors" may be stored in the
; HSTBUF, waiting to be written out to the disk when HSTBUF becomes full. This
; sometimes complicates the logic of the BIOS disk functions. You cannot simply
; select a new disk drive, for example, when the HSTBUF contains data destined for
; another disk drive. You will see this complication in the BIOS only in the form of
; added logical operations; the BIOS disk functions rarely trigger immediate physical
; operations. It is easier to understand these BIOS functions if you consider that
; they make requests-and that these requests are satisfied only when it makes
; sense to do so, taking into account the blocking/ deblocking logic.

;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;---------------------------------------------------------------------------

;---------------------------------------------------------------------------
;	Home Disk	BIOS 08
;
;  HOME - Home the selected logical disk to track 0. Before doing this, a check
; must be made to see if the physical disk buffer has information that must be
; written out. This is indicated by a flag, DirtyBufferFlag,set in the de-blocking code

HOME:
	LD		A,(DirtyBufferFlag)		; Check for Dirty Buffer
	OR		A
	JR		NZ,HomeNoWrite
	LD		(DataInBufferFlag),A	; Clear DataInBufferFlag if Buffer not dirty
HomeNoWrite:
	LD		C,00H					; Set to track 0
	CALL	SETTRK					; no, physical, only logical
	RET

;---------------------------------------------------------------------------
;	Select Disk	BIOS 09

;  SELDSK does not do what its name implies. It does not (and must not)
; physically select a logical disk. Instead, it returns a pointer in the
; HL register pair to the disk parameter header for the logical disk specified
; in register C on entry. C=0 for drive A, 1for drive B, and so on. SELDSK also
; stores this code for the requested disk to be used later in the READ and WRITE functions.
; If the logical disk code in register C refers to a nonexistent disk or to one for
; which no disk parameter header exists, then SELDSK must return with HL set to
; OOOOH. Then the BDOS will output a message of the form "BDOS Err on XI Select"
; Note that SELDSK not only does not select the disk, but also does not indicate
; whether or not the requested disk is physically present -merely whether or not
; there are disk tables present for the disk.
;  SELDSK is called by the BDOS either during disk file operations or by a
; program issuing a Select Disk request (B$SELDSK, code 14).

SELDSK:
	LD		HL,00H					; Assume an error
	LD		A,C
	CP		NumberOfLogicalDisks
	RET	NC							; return if > max number of Disks

	LD		(SelectedDisk),A		; save disk number

	RLCA							; X2
	RLCA							; X4
	RLCA							; X8
	RLCA							; X16
	LD		D,0
	LD		E,A						; put index int DE
	LD		IX,DiskParameterHeaders	; get DPH address Base
	ADD		IX,DE					; get the specific DiskParameterHeader
	PUSH	IX						; save for return in HL

	LD		D,(IX + 11)				; LSB for Disk Parameter Block
	LD		E,(IX + 10)				; MSB for Disk Parameter Block

	PUSH	DE
	POP		IX
	LD		A,(IX + 15)				; Disk Parameter Block in IY	
	LD		(SelectedDskSecsPerHead),A

	POP	HL							; recover DPH pointer
	RET



;---------------------------------------------------------------------------
;	Set Track	BIOS 0A

;  SETTRK saves the requested disk track that is in the BC register pair when
; SETTRK gets control. Note that this is an absolute track number; that is, the
; number of reserved tracks before the file directory will have been added to the
; track number relative to the start of the logical disk.
;  The number of the requested track will be used in the next BIOS READ or
; WRITE function.
;  SETTRK is called by the BDOS when it needs to read or write a 128-byte
; sector. Legitimate track numbers are from 0 to OFFFFH (65,535).

SETTRK:
;	LD		H,B								; select track in BC on entry
;	LD		L,C
;	LD	(SelectedTrack),HL					; save for low level driver
	LD	(SelectedTrack),BC					; save for low level driver	
	RET

;---------------------------------------------------------------------------
;	Set Sector	BIOS 0B  (Set Record)

; Sector  = Record for disk with 128 byte sectors
; Sector contains 4 records for disks with 512 byte sectors
; this routine is missed named it should be called Set Record

;  SETSEC is similar to SETTRK in that it stores the requested Record (sector) number
; for later use in BIOS READ or WRITE functions. The requested Record (sector) number is
; handed to SETSEC in the A register; legitimate values are from 0 to OFFH (255).
; The Record (sector) number is a logical Record (sector) number. It does not take into account any
; sector skewing that might be used to improve disk performance.
;  SETSEC is called by the BDOS when it needs to read or write a 128-byte
; Record (sector).

SETSEC:						; SETRECORD
	LD		A,C
	LD		(SelectedRecord),A					; save for low level driver
	RET

;---------------------------------------------------------------------------
;	Set Sector	BIOS 0C

;  SETDMA saves the address in the BC register pair in the requested DMA
; address. The next BIOS READ or WRITE function will use the DMA address as
; a pointer to the 128-byte sector buffer into which data will be read or from which
; data will be written.
;  The default DMA address is 0080H. SETDMA is called by the BDOS when it
; needs to READ or WRITE a 128-byte sector.

SETDMA:
	LD	(DMAAddress),BC						; save for low level driver
	RET

;---------------------------------------------------------------------------
;	Sector Translate	BIOS 10

;  SECTRAN, given a logical sector number, locates the correct physical sector
; number in the sector translate table for the previously selected (via SELDSK)
; logical disk drive. Note that both logical and physical sector numbers are
; l28-byte sectors, so if you are working with a hard disk system, it is not
; too efficient to impose a sector interlace at the l28-byte sector level.
; It is better to impose the sector interlace right inside the hard disk driver,
; if at all. In general, hard disks spin so rapidly that CP/M simply cannot take
; advantage of sector interlace.
;  The BDOS hands over the logical sector number in the BC register pair, with
; the address of the sector translate table in the DE register pair. SECTRAN must
; return the physical sector number in HL.
;  If SECTRAN is to be a null routine, it must move the contents of BC to HL
; and return.

SECTRAN:
	PUSH	BC
	POP		HL								; just move the value from BC to HL
	RET

;---------------------------------------------------------------------------
;	READ			BIOS 0D

;  READ reads in a 128-byte sector provided that there have been previous BIOS
; function calls to:
; 				- SELDSK	"select" the disk
; 				- SETDMA	set the DMA address
; 				- SETTRK	set the track number
; 				- SETSEC	set the sector number.
; 			
; Because of the blocking/ deblocking code in the BIOS, there are frequent occasions
; when the requested sector will already be in the host buffer (HSTBUF), so that a
; physical disk read is not required. All that is then required is for the BIOS to move
; the appropriate 128 bytes from the HSTBUF into the buffer pointed at by the DMA address.
; Only during the READ function will the BIOS normally communicate with the physical disk
; drive, selecting it and seeking to read the requested track and sector. During this process,
; the READ function must also handle any hardware errors that occur, trying an operation again
; if a "soft," or recoverable, error occurs.
;  The READ function must return with the A register set to OOH if the read operation has completed
; successfully. If the READ function returns with the A register set to 01 H, the BDOS will
; display an error message of the form BDOS Err on X: Bad Sector. Under these circumstances,
; you have only two choices. You can enter a CARRIAGE RETURN, ignore the fact that there was an
; error, and attempt to make sense of the data in the DMA buffer. Or you can type a CONTROL-C
; to abort the operation, perform a warm boot, and return control to the CCP. As you can see,
; CP/M's error handling is not particularly helpful, so most BIOS writers add more sophisticated
; error recovery right in the disk driver. This can include some interaction with the console so
; that a more determined effort can be made to correct errors or, if nothing else, give you more
; information as to what has gone wrong. Such error handling is discussed in Chapter 9.
;  If you are working with a hard disk system, the BIOS driver must also handle the management of
; bad sectors. You cannot simply replace a hard disk drive if one or two sectors become unreadable.
; This bad sector management normally requires that a directory of "spare" sectors be put on the
; hard disk before it is used to store data. Then, when a sector is found to be bad,
; one of the spare sectors is substituted in its place.

READ:
	XOR		A							
	LD		(ModifiedlRecordsCount),A	; 1. Set ModifiedlRecordsCount to 0
	INC		A
	LD		(ReadWriteFlag),A			; 2. Set to Flag to read (non-zero)	
	LD		(PrereadSectorFlag),A		; 3. Force a preread
	LD		A,WriteCleanBuffer
	LD		(WriteType),A				; 4. Fake a clean sector Write type = 02
	JP		CommonDiskIO				; Use common code to execute read
;---------------------------------------------------------------------------
;	WRITE			BIOS 0E
;
;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
;
; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
;	00H [WriteAllocated]	An already allocated allocation block (which means a pre-read of the sector may be needed),
;	01H [WriteDirectory]	To the directory (in which case the data will be written to the disk immediately),
;	02H [WriteCleanBuffer]	To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).

;  WRITE is similar to READ but with the obvious difference that data is transferred from the DMA buffer
; to the specified 128-byte sector. Like READ, this function requires that the following function calls
; have already been made:
; 				- SELDSK	"select" the disk
; 				- SETDMA	set the DMA address
; 				- SETTRK	set the track number
; 				- SETSEC	set the sector number.
; 			
;  Again, it is only in the WRITE routine that the driver will start to talk directly to the physical hardware,
; selecting the disk unit, track, and sector, and transferring the data to the disk. With the blocking/deblocking code,
; the BDOS optimizes the number of disk writes that are needed by indicating in register C the type of disk write
; that is to be performed:
; 				0= normal sector write
; 				1= write to file directory sector
; 				2 = write to sector of previously unchanged Deblocking Buffer
; 			
;  Type 0 occurs whenever the BDOS is writing to a data sector in an already used allocation block.
; Under these circumstances, the disk driver must preread the appropriate host sector because there
; may be previously stored information on it.
;
;  Type 1 occurs whenever the BDOS is writing to a file directory sector-in this case, the BIOS must not defer
; writing the sector to the disk, as the information is too valuable to hold in memory until the HSTBUF is full.
; The longer the information resides in the HSTBUF, the greater the chance of a power failure or glitch,
; making file data already physically written to the disk inaccessible because the file directory is out of date.
;
;  Type 2 occurs whenever the BDOS needs to write to the first sector of a previously unused allocation block.
; Unused, in this context, includes an allocation block that has become available as a result of a file being erased.
; In this case, there is no need for the disk driver to preread an entire host-sized sector into the HSTBUF,
; as there is no data of value in the physical sector.
;
;  As with the READ routine, the WRITE function returns with A set to OOH if the operation has been completed successfully.
; If the WRITE function returns with A set to 01H, then the BDOS will display the same message as for READ:
; BDOS Err on X: Bad Sector


WRITE:
; BlockingBuffer I/O
	XOR		A
	LD		(ReadWriteFlag),A			; Set to zero to indicate that this is a Write
	LD		A,C
	LD		(WriteType),A				; save the BDOS write type (0,1,2)

	CP		WriteCleanBuffer			; first, is this a clean Allocation Buffer block ?
	JP		NZ,CheckDirtyBuffer			; No

;Write from a clean Host Buffer
	LD		HL,SelectedState
	LD		DE,HostBufferState
	LD		BC,SelectedDiskStateSize
	LDIR								; copy Selected State to Host Buffer state

CheckDirtyBuffer:

	LD		HL,SelectedState
	LD		DE,HostBufferState
	CALL	CompareDkTrkSec				; is it in Host Buffer?
	LD		A,TRUE				;......
	JP		NZ,SetPreread			; NO - Then we need to load the Host Buffer

	XOR		A
SetPreread:
	LD		(PrereadSectorFlag),A		; clear preread flag
;*******************************************************
; Common code to execute both reads and writes of 128-byte records
;*******************************************************
CommonDiskIO:
	XOR		A							; Assume no disk error will occur
	LD		(DiskStatus),A
	
;-------------------------Convert selected record into physical sector-----------;
	LD		A,(SelectedRecord)                                                   ;
	RRA									; Convert selected record                ;
	RRA									; into physical sector by dividing by 4  ;
	AND		03FH						; Remove unwanted bits                   ;
	LD		(SelectedSector),A                                                   ;
;-------------------------Convert selected record into physical sector-----------;

;------------------------- Any Data in Buffer -----------------------------------;
;Flag is ONLY reset by BIOS HOME Function. otherwise it is set by all passes 		 ;

	LD		HL,DataInBufferFlag			; See if there is any data here ?        ;
	LD		A,(HL)                                                               ;
	LD		(HL),TRUE					; Force flag true                        ;
	OR		A							; Was  any data here ?                   ;
	JP		Z,SetIOBufferState			; NO ?- go read into buffer              ;
;------------------------- Any Data in Buffer -----------------------------------;

;-----------------------------test for  the sector in the buffer-----------------;
	LD		DE,IOBufferState			; get the Buffer Disk and Track          ;
	LD		HL,SelectedState			; get the requested Disk and Track       ;
	CALL	CompareDkTrk				; Are they the same ?                    ;
	JP		NZ,DataNotInBuffer		; NO,jump - it must be read 				 ;
			                                                                     ;
; Yes, the disk, track are the same are the sectors the same ?                   ;
                                                                                 ;
	LD		A,(IOBufferSector)			; get the sector                         ;
	LD		HL,SelectedSector                                                    ;
	CP		M							; Check if correct physical sector       ;
	JP		Z,DataIsInBuffer			; Yes - it is already in memory          ;
;-----------------------------test for  the sector in the buffer-----------------;

;------------------------- Do we have to write out the buffer ?------------------;
DataNotInBuffer:                                                                 ;
	LD		A,(DirtyBufferFlag)                                              ;
	OR		A							; do we need to write ?                  ;
	CALL	NZ,WritePhysical			; if yes - write it out                  ;
;------------------------- Do we have to write out the buffer ?------------------;

;------------------------- prepare for physical IO ------------------------------;
SetIOBufferState:                                                                ;
; indicate the  selected disk, track, and sector not residing in buffer          ;
	LD		A,(SelectedDisk)                                                     ;
	LD		(IOBufferDisk),A                                                     ;
	LD		HL,(SelectedTrack)                                                   ;
	LD		(IOBufferTrack),HL                                                   ;
                                                                                 ;
	LD		A,(SelectedSector)                                                   ;
	LD		(IOBufferSector),A                                                   ;
;------------------------- prepare for physical IO ------------------------------;

;------------------------- Read the data if needed, or its already in the buffer -;
	LD		A,(PrereadSectorFlag)		; do we need to preread ?                 ;
	OR		A                                                                     ;
	CALL	NZ,ReadPhysical				; yes - preread the sector                ;
	                                                                              ;
; At this point the data is in the buffer.                                        ;
; Either it was already here, or we returned from ReadPhysical                    ;
                                                                                  ;
	XOR		A                                                                     ;
	LD		(DirtyBufferFlag),A		; Reset the DirtyBufferFlag	          ;
;------------------------- Read the data if needed, or its already in the buffer -;


; The Buffer now has the data we want to Read/Write
;-------------------------Calculate the address of the record in the sector ------;
	                                                                              ;
DataIsInBuffer:                                                                   ;
	LD		A,(SelectedRecord)                                                    ;
	AND		SectorMask					; Want relative record number in Sector   ;
	INC		A							; Adjust for DJNZ                         ;
	LD		B,A                                                                   ;
	LD		DE,cpmRecordSize                                                      ;
	LD		HL,-cpmRecordSize                                                     ;
SectorInBuffer1:                                                                  ;
	ADD		HL,DE						; RecordNumber * recordSize               ;
	DJNZ	SectorInBuffer1				;  yields index into the Sector           ;
                                                                                  ;
	LD		DE,DiskBuffer				; Start of sector                         ;
	ADD		HL,DE						; HL -> start of record in buffer 		  ;
	LD		DE,(DMAAddress)				; Callers  DMA Address                    ;
																				  ;
;-------------------------Calculate the address of the record in the sector ------;


;------------------------- Determine if its a Read or Write and set HL & DE ------;
                                                                                  ;
	LD		A,(ReadWriteFlag)			; 0 => Write, non Zero => Read            ;
	OR		A							; Write: move data from DMA to Buffer     ;
	JP		NZ,BufferMove				; Read : move data from Buffer to DMA     ;
                                                                                  ;
	INC		A							; Set the flag to indicate dirty buffer   ;
	LD		(DirtyBufferFlag),A                                                   ;
	EX		DE,HL						; Swap source and destination for write   ;
                                                                                  ;
;------------------------- Determine if its a Read or Write and set HL & DE ------;


BufferMove:
	LD		BC,cpmRecordSize
	LDIR								; Move data to/from Host Buffer

	LD		A,(WriteType)				; Is this a write to the directory ?
	CP		WriteDirectory
	LD		A,(DiskStatus)				; Set ACC with disk status if an immediate return
	RET		NZ							; Return if not updating a directory entry

	OR		A							; Check for any disk errors ?
	RET		NZ							; If yes - abandon attempt to write to directory

	XOR		A
	LD		(DirtyBufferFlag),A			; Clear the dirty buffer flag
	CALL	WritePhysical				; do an immediate update of the directory to disk
	LD		A,(DiskStatus)				; Set ACC with disk status 
	RET
;********************************************************************


; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
CompareDkTrk:
	LD		BC,03H
	JR		CompareDkTrkSecLoop
CompareDkTrkSec:
	LD		BC,04H
CompareDkTrkSecLoop:
	LD		A,(DE)						; Get value
	INC		DE							; anticipate next iteration
	CPI									; does A = (HL)
	RET		NZ							; Not a match exit
	JP		PE,CompareDkTrkSecLoop		; Loop if not done
	RET


;************************************************
;			Physical Disk IO					*
;************************************************

;Write contents of disk buffer to correct sector
WritePhysical:
	LD		A,DiskWriteCode				; get write function
	JP		CommonPhysical

ReadPhysical:
	LD		A,DiskReadCode				; get read function

; Set up the Dick Control Table DCT
CommonPhysical:
;Command
	LD		(DCTCommand),A				; set the command for Read or Write
;Disk
	LD		A,(IOBufferDisk)
	AND		03H							; only units 0 to 3
	LD		(DCTDisk),A					; set disk
;Track
	LD		HL,(IOBufferTrack)
	LD		A,L							; for this controller it is a byte value
	LD		(DCTTrack),A				; set track
;Head and Track	Calculations
; The sector must be converted into a head number and sector number.
;	Head = (int) Sector / SectorsPerHead
;	Sector = Sector MOD SectorsPerHead
DetermineHead:
	LD		B,0							; Start at head 0
	LD		HL,SelectedDskSecsPerHead	; Point at track counts
	LD		A,(IOBufferSector)			; get target sector
DetermineHead1:
	CP		M							; Need another Head?
	JP		C,HeadFound					; nope done with head calculation

	SUB		M							; subtract track value
	INC		B							; Increment head
	JP		DetermineHead1				; loop for next head value

;Sector
HeadFound:								; ACC now has Sector MOD SectorsPerHead
	INC		A							; physical sectors start at 1
	LD		(DCTSector),A				; set sector
;Head
	LD		A,B
	LD		(DCTHead),A					; set head number
;Byte Count
	LD		HL,diskSectorSize
	LD		(DCTByteCount),HL			; set byte count
;DMA
	LD		HL,DiskBuffer
	LD		(DCTDMAAddress),HL			; set transfer address

; Since only one control table is in use, close the status and busy chain pointers
; back to the main control bytes
;NextStatusBlock
	LD		HL,DiskStatusLocation
	LD		(DCTNextStatusBlock),HL
;NextControlLocation
	LD		HL,DiskControlByte
	LD		(DCTNextControlLocation),HL

;Put  DCT pointer in page0
	LD		HL,DCTCommand
	LD		(DiskCommandBlock),HL
; Make the IO happen
	LD		HL,DiskControlByte			; activate disk controller
	LD		(HL),080H

;Wait until Disk Status Block indicates the operation is complete,
WaitForDiskComplete:
	LD		A,(HL)						; get control bytes
	OR		A
	JP		NZ,WaitForDiskComplete		; operation not done


;Check if any errors occurred.
	LD		A,(DiskStatusLocation)
	JP		C,DiskError
	XOR		A
	LD		(DiskStatus),A			; clear the flag
	RET

; set error flag and return
DiskError:
	LD		A,1
	LD		(DiskStatus),A			; set the error flag
	RET

;********************************************************************
;********************************************************************
;********************************************************************

;---------------------------------------------------------------------------
;	Disk Data
;---------------------------------------------------------------------------
;	Disk Equates
;---------------------------------------------------------------------------
; Disk Types
;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
;;HardDisk	EQU	2						; hard disk
;NumberOfLogicalDisks	EQU 4			; max number of disk in this system


;**************************************************************************************************
;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
;
;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
; perform some disk operation.  These are called its disk control byte.
; If the most significant bit of  disk control byte is set, the controller will look at the word
; following the respective control bytes. This word must contain the address of  valid disk control
; table that specifies the exact disk operation to be performed.
;
;  Once the operation has been completed. the controller resets its disk control byte to OOH.
; This indicates completion to the disk driver code.
;
;  The controller also sets a return code in a disk status block - location 0X43H.
; If the first byte of this status block is less than 80H. then a disk error
; has occurred. For this simple BIOS. no further details of the status settings are relevant.
; Note that the disk controller has built-in retry logic -- reads and writes are attempted
; ten times before the controller returns an error
;
;  The disk control table layout is shown below. Note that the controller has the capability
; for control tables to be chained together so that a sequence of disk operations can be initiated.
; In this BIOS this feature is not used. However. the controller requires that the chain pointers
; in the disk control tables be pointed back to the main control bytes in order to indicate
; the end of the chain
;**************************************************************************************************

;***************************************************************************
;	Disk Control tables
;***************************************************************************
;;DiskControlTable:
DCTStart:
DCTCommand:				DB		00H			; Command
DCTDisk:				DB		00H			; unit (drive) number = 0 or 1
DCTHead:				DB		00H			; head number = 0 or 1
DCTTrack:				DB		00H			; track number
DCTSector:				DB		00H			; sector number
DCTByteCount:			DW		0000H		; number of bytes to read/write
DCTDMAAddress:			DW		0000H		; transfer address
DCTNextStatusBlock:		DW		0000H		; pointer to next status block
DCTNextControlLocation:	DW		0000H		; pointer to next control byte
DCTEnd:
DCTSize					EQU		DCTEnd-DCTStart
;-----------------------------------------
;WriteAllocated		EQU	00H		W_NORMAL
;WriteDirectory		EQU	01H		W_DIRECTORY
;WriteCleanBuffer	EQU	02H		W_NEW_BLOCK
;-----------------------------------------

WriteType:				DB		00H			; The type of write indicated by BDOS

; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
IOBufferState:
IOBufferDisk:			DB		00H
IOBufferTrack:			DW		00H
IOBufferSector:			DB		00H
DataInBufferFlag:		DB		00H			; when non-zero, the disk buffer has data from disk
DirtyBufferFlag:	DB		00H			; Non-zero when data has been written into DiskBuffer,
											;   but not yet written out to the disk
;---------------------------------------------------------------------------
;	Disk Storage area
;---------------------------------------------------------------------------
;     variables for selected disk, track and sector
; These are moved and compared as a group, DO NOT ALTER

SelectedDskSecsPerHead:	DB		00H			; Sectors / head

SelectedState:
SelectedDisk:			DB		00H
SelectedTrack:			DW		0000H
SelectedRecord:			DB		00H

SelectedDiskStateEnd:
SelectedDiskStateSize	EQU		SelectedDiskStateEnd - SelectedDisk

DMAAddress:				DW		0000H			; DMA address

SelectedSector:			DB		00H

; Parameters for the records in the Fresh Allocation Block
; These are moved and compared as a group, DO NOT ALTER

HostBufferState:
HostBufferDisk:			DB		00H
HostBufferTrack:		DW		0000H
HostBufferRecord:		DB		00H
		
ModifiedlRecordsCount:	DB		00H			; Number of unallocated "records"in current previously unallocated allocation block.
DiskStatus:				DB		00H			; Non-Zero - unrecoverable error output "Bad Sector" message
											; Flags used inside the de-blocking code
PrereadSectorFlag:		DB		00H			; non-zero if physical sector must be read into the disk buffer
											; either before a write to a allocated block can occur, or
											; for a normal cpmRecord read
ReadWriteFlag:				DB	00H			; 0 => Write-  Non-zero =>read

;---------------------------------------------------------------------------

;---------------------------------------------------------------------------
;	Disk Definition Tables
; These consists of disk parameter headers, with one entry
; per logical disk driver, and disk parameter blocks, with
; either one parameter block per logical disk or the same
; parameter block for several logical disks.
;---------------------------------------------------------------------------
;---------------------------------------------------------------------------
DiskParameterHeaders:

; Logical Disk A: (3.25" HD 1.44MB Diskette)
	DW		0000H							; Floppy5SkewTable  - No Skew table
	DW		0000H							; Rel pos for file (0-3)
	DW		0000H							; Last Selected Track #
	DW		0000H							; Last Selected Sector #
	DW		DirectoryBuffer					; all disks use this buffer
	DW		ParameterBlock3HD				; specific to disk's parameters
	DW		DiskAWorkArea
	DW		DiskAAllocationVector

; Logical Disk B: (3.25" HD 1.44MB Diskette)
	DW		0000H							; No Skew table
	DW		0000H							; Rel pos for file (0-3)
	DW		0000H							; Last Selected Track #
	DW		0000H							; Last Selected Sector #
	DW		DirectoryBuffer					; all disks use this buffer
	DW		ParameterBlock3HD				; specific to disk's parameters
	DW		DiskBWorkArea
	DW		DiskBAllocationVector

; Logical Disk C: (3.25" HD 1.44MB Diskette)
	DW		0000H							; No Skew table
	DW		0000H							; Rel pos for file (0-3)
	DW		0000H							; Last Selected Track #
	DW		0000H							; Last Selected Sector #
	DW		DirectoryBuffer					; all disks use this buffer
	DW		ParameterBlock3HD				; specific to disk's parameters
	DW		DiskCWorkArea
	DW		DiskCAllocationVector

; Logical Disk D: (3.25" HD 1.44MB Diskette)
	DW		0000H							; No Skew table
	DW		0000H							; Rel pos for file (0-3)
	DW		0000H							; Last Selected Track #
	DW		0000H							; Last Selected Sector #
	DW		DirectoryBuffer					; all disks use this buffer
	DW		ParameterBlock3HD				; specific to disk's parameters
	DW		DiskDWorkArea
	DW		DiskDAllocationVector


;-----------------------------------------------------------

ParameterBlock3HD:
	DW		dpb3hdSPT						; cpmRecords per track- (144)
	DB		dpb3hdBSH						; Block shift ( 4=> 2K)
	DB		dpb3hdBLM						; Block mask
	DB		dpb3hdEXM						; Extent mask
	DW		dpb3hdDSM						; Maximum allocation block number (710)
	DW		dpb3hdDRM						; Number of directory entries - 1 (127)
	DB		dpb3hdAL0						; Bit map for reserving 1 alloc. block
	DB		dpb3hdAL1						;  for file directory
	DW		dpb3hdCKS						; Disk change work area size (32)
	DW		dpb3hdOFF						; Number of tracks before directory

	DB		(dpb3hdSPT/4)/dpb3hdNOH			; number of Sectors/Head



;---------------------------------------------------------------------------
;	Disk work area
;---------------------------------------------------------------------------
; These are used by the BDOS to detect any unexpected
; change of diskette. The BDOS will automatically set
; such a changed diskette to read-only status.

DiskAWorkArea:	DS	dpb3hdCKS				; A:  020H
DiskBWorkArea:	DS	dpb3hdCKS				; B:  020H
DiskCWorkArea:	DS	dpb3hdCKS				; C:  020H
DiskDWorkArea:	DS	dpb3hdCKS				; D:  020H

;---------------------------------------------------------------------------
;	Disk allocation vectors
;---------------------------------------------------------------------------
; Disk allocation vectors
; These are used by the BDOS to maintain a bit map of
; which allocation blocks are used and which are free.
; One byte is used for eight allocation blocks, hence the
; expression of the form (allocation blocks/8)+1

DiskAAllocationVector:	DS	(dpb3hdDSM/8)+1 ; A:
DiskBAllocationVector:	DS	(dpb3hdDSM/8)+1 ; B:

DiskCAllocationVector:	DS	(dpb3hdDSM/8)+1 ; C:
DiskDAllocationVector:	DS	(dpb3hdDSM/8)+1 ; D:
;---------------------------------------------------------------------------
;	Disk Buffer
;---------------------------------------------------------------------------
DirectoryBuffer:	DS		DirBuffSize
