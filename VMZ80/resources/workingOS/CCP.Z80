;     File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm

; Entering CCP

; CCP.Z80
;
; 2019-02-19 Started to refactor to Z80 idiom

; 2017-03-02 Refactored the CP/M Suite
; 2014-01-16
; 2014-05-01  :  Frank Martyn
 
; replace systemFile with fcbSystemFileIndex
 
 	$Include ./stdHeader.Z80
 	$Include ./osHeader.Z80
 	$Include ./diskHeader.Z80

BDOS		EQU		0005H		; BDOS Vector in Page 00000	
 
fcbSystemFileIndex		EQU		0AH			; extent number field index
 
 
 
 					ORG	CCPEntry
CcpBoundary			EQU	$
;========================== CCP Entry ======================================; 
 
; 	JP		CcpStart						;start ccp with possible initial command
;*****************************************************************
;enter here from boot loader
; On Entry	C(HiNibble) = User Number
;			C(LoNibble) = Disk (0=A, 1=B...F=P)
CcpStart:
	LD		SP,Stack					; Set CCP's Stack
	PUSH	BC							; Save Disk Number
	LD		E,C							; Get User Number
	SRL		E
	SRL		E							; Move user number
	SRL		E							;  to Lo Nibble
	SRL		E
	CALL	SetUser						; Set initial User
	CALL	Initialize					; Completely reset the disk file system					
	LD		(submitFlag),A	; submit flag set if $ file present - ???????
	POP		BC							; Recall disk number
	LD		A,C							; Put into Acc
	AND		LO_NIBBLE_MASK				; Remove User Number
	LD		(Pg0CurentDisk),A			; Puts disk number into Page 0
	CALL	SelectDisk					; Set default Disk From Acc											; check for initial command
	LD		A,(commandLength)
	OR		A							; See if there is a Command
	JR		NZ,CcpParseCommand			;  Skip if yes

ccpMainEntry:
	LD		SP,Stack					; (re)Establish CCP's Stack
	CALL	CrLf						; Send CRLF to the Console
	CALL	GetSelectedDrive			; Get current disk number
	ADD		A,ASCII_A					; Make ASCII form of Drive
	CALL	PrintCharInA					; Send Drive letter to console
	LD		A,GREATER_THAN				; Load '>'
	CALL	PrintCharInA					; Send to Console
	CALL	ReadCommand					; Command Buffer filled, Pointer set
	
CcpParseCommand:
	LD		DE,DMABuffer				; Default in page 0
	CALL	SetDMA						; Set the DMA address
	CALL	GetSelectedDrive			; Get current drive
	LD		(currentDisk),A				; Save
	CALL	ParseToken1					; Get first token in command buffer
	CALL	NZ,CommandError				; The name must be unambiguous
	LD		A,(selectedDisk)			; Get the Disk:
	OR		A							; If not default,
	JP		NZ,ccpUserFunction			;   must be user CMD
	
	CALL	IntrinsicFunction			; Get CMD index into ACC
	LD		HL,builtInCMDVector			; Base of Vector
	LD		E,A
	LD		D,0							; Index in DE
	ADD		HL,DE
	ADD		HL,DE						; Vector is a word, need 2 ADDs
	LD		A,(HL)						; Pointing at Address
	INC		HL
	LD		H,(HL)
	LD		L,A							; Get address to HL
	JP		(HL)						;  Go to the Function
 

 ;----------------------------------------------------------------
;------------------------------ Read Command -------------------------------;

 ;read the next command into the command buffer
 ;check for submit file
ReadCommand:
	LD		A,(submitFlag)				; Get the Submit File Flag
	OR		A							; Is it Set ?
	JP		Z,NotSubmitFile				;  skip if not
; scanning a submit file change drives to open and read the file
	LD		A,(currentDisk)
	OR		A
	LD		A,0
	CALL	NZ,SelectDisk
; have to open again in case xsub present
	LD		DE,submitFCB
	CALL	OpenFile
	JP		Z,NotSubmitFile					; skip if no submit file
	LD		A,(submitRC)
	DEC		A								; read last record(s) first
	LD		(submitCR),A				; current record to read
	LD		DE,submitFCB
	CALL	DiskRead						; end of file if last record
	JP		NZ,NotSubmitFile
; disk read is ok, transfer to commandBuffer
	LD		DE,commandLength
	LD		HL,DMABuffer
	LD		B,cpmRecordSize					; number of bytes to Copy
	CALL	CopyHL2DEforB
; line is transferred, close the file with a deleted record
	LD		HL,submitS2
	LD		(HL),0								; clear fwflag
	INC		HL
	DEC		M								; one less record
	LD		DE,submitFCB
	CALL	CloseFile
	JP		Z,NotSubmitFile
; CloseFile went ok, return to original drive
	LD		A,(currentDisk)
	OR		A
	CALL	NZ,SelectDisk
; print to the 00
	LD		HL,commandBuffer
	CALL	PrintStringNull
	CALL	CheckForConsoleChar
	JP		Z,NoRead
	CALL	DeleteSubmitFile
	JP		DeleteSubmitFile				; break key depressed
;--------------------------------------------------------------------------------
NotSubmitFile:
	CALL	DeleteSubmitFile			; Delete any submit file
	CALL	SaveUserAndDisk				; Save User & Disk to page 0
	LD		DE,commandMaxLength			; Point to Start of Buffer
	LD		C,fReadString				; Load Function Number	
 	CALL	BDOS						;  and let BDOS do its work	
	CALL	SetPage0CurDisk				; No Cntl C, so restore Pg0CurentDisk

NoRead:
; set the last character to zero for later scans
	LD		HL,commandLength			; Point to length of command
	LD		B,(HL)						; Put it into B
UpCaseLoop:
	INC		HL							; Point at next byte in buffer
	LD		A,(HL)						; Get the Character
	CALL	UpCase						; If between a-z, up-case it
	LD		(HL),A						; Replace character
	DJNZ	UpCaseLoop					; go thru all of the CMD buffer
;end of scan, h,l address end of command
;ReadCommand2:
	INC		HL							; Point at last char + 1
	LD		(HL),B						; Stuff Zero to terminate the CMD
	LD		HL,commandBuffer			; go back to start of com
	LD		(commandBufferPointer),HL	; Place in current CMD address
	RET
;------------------------------ Read Command -------------------------------;

;--------------------------------- UpCase ----------------------------------;
;convert character in register A (a to z) to upper case                     ;
UpCase:                                                                     ;
 	CP		061H                                                            ;
 	RET		C							; Return if below lower case 'a'    ;
 	CP		07BH                                                            ;
 	RET		NC							; Return if above lower case 'z'    ;
 	AND		05FH						; Drop bit 5/ makes q->Q etc        ;
 	RET                                                                     ;
;--------------------------------- UpCase ----------------------------------;
;---------------------------- Delete SubmitFile ----------------------------;
;delete the submit file, and set submit flag to false                       ;
DeleteSubmitFile:                                                           ;
	LD		HL,submitFlag				; Point at Submit flag              ;
	LD		A,(HL)						; Get the Flag                      ;
	OR		A							; Is it Set ?                       ;
	RET		Z							;  return if not set                ;
	LD		(HL),0						; Clear Flag                        ;
	XOR		A							; Drive 0 = A:                      ;
	CALL	SelectDisk					; Select drive                      ;
	LD		DE,submitFCB				; Load the submits FCB              ;
	CALL	DeleteFile					; Go delete it                      ;
	LD		A,(currentDisk)				; Determine the current disk        ;
	JP		SelectDisk					; Reselect back to original drive   ;
;---------------------------- Delete SubmitFile ----------------------------;
;-------------------------------- Save User --------------------------------;
;save user#/disk# before possible ^c or transient                           ;
SaveUserAndDisk:                                                            ;
	CALL	GetUser						; Get the user number into Acc      ;
	ADD		A,A                                                             ;
	ADD		A,A                                                             ;
	ADD		A,A                                                             ;
	ADD		A,A							; Move user to Hi Nibble            ;
	LD		HL,currentDisk				; Current disk (Lo Nibble)          ;
	OR		M							; Acc -> User & Disk                ;
	LD		(Pg0CurentDisk),A			; Stored in Page0 for later         ;
	RET                                                                     ;
;-------------------------------- Save User --------------------------------;
;------------------------- Set Page 0 Current Disk -------------------------;
;set Pg0CurentDisk to current disk                                          ;
SetPage0CurDisk:                                                            ;
 	LD		 A,(currentDisk)			; Get CCP's current disk            ;
 	LD		(Pg0CurentDisk),A			; Put into Page 0	                ;
 	RET                                                                     ;
;------------------------- Set Page 0 Current Disk -------------------------;
;------------------------------ Command Error ------------------------------;
;error in command string starting at position;'tokenStart' and ending     ;
; with first delimiter                                                      ;
                                                                            ;
CommandError:                                                               ;
	CALL	CrLf						; Next Line                         ;
	LD		HL,(tokenStart)			; Start of error token              ;
CommandErrorLoop:                                                           ;
	LD		A,(HL)						; Get character                     ;
	CP		SPACE						; Past offending token ?            ;
	JP		Z,CommandErrorExit			;  done if yes                      ;
	OR		A							; At end of command ?               ;
	JP		Z,CommandErrorExit			;  done if yes                      ;
	PUSH	HL							; Save pointer                      ;
	CALL	PrintCharInA				; Display on console                ;
	POP		HL							; Restore pointer                   ;
	INC		HL							; Update it                         ;
	JR		CommandErrorLoop			; Keep going                        ;
	                                                                        ;
CommandErrorExit:                                                           ;
	LD		A,QMARK                                                         ;
	CALL	PrintCharInA				; Send '?' to console               ;
	CALL	CrLf						; Next Line                         ;
	CALL	DeleteSubmitFile			; Remove any submit file            ;
	JP		ccpMainEntry				; Go back for another command       ;
;------------------------------ Command Error ------------------------------;
;---------------------------- Intrinsic Function ---------------------------;
;look for intrinsic functions (Token1 has been filled)                  ;
IntrinsicFunction:                                                          ;
	LD		HL,builtInCMDNames			; Point at List of CMDs             ;
	LD		C,0							; Initialize counter                ;
IntrinsicFunction1:                                                         ;
	LD		A,C							; Get Counter                       ;
	CP		builtInCMDCount				; Past number of commands ?         ;
	RET		NC							;  exit if yes                      ;
	LD		DE,Token1 + 1			; Beginning of name                 ;
	LD		B,builtInCMDNameSize		; Length of match                   ;
IntrinsicFunction2:                                                         ;
	LD		A,(DE)                                                          ;
	CP		M							; Is there a match ?                ;
	JP		NZ,IntrinsicFunction3		;  skip if no match                 ;
	INC 	DE                                                              ;
	INC		HL							; Point at next characters          ;
	DEC		B							; Decrement the counter             ;
	JP		NZ,IntrinsicFunction2		; Loop while matching               ;
; complete match on name, check for blank in fcb                            ;
	LD		A,(DE)                                                          ;
	CP		SPACE						; Blank in CMD ?                    ;
	JP		NZ,IntrinsicFunction4		;  No ,then no match                ;
	LD		A,C							;  Else they match,                 ;
	RET									; Return with index in A            ;
                                                                            ;
IntrinsicFunction3:                                                         ;
	INC		HL							; Move to next in list              ;
	DEC		B							                                    ;
	JP		NZ,IntrinsicFunction3		; Loop thru this one                ;
                                                                            ;
IntrinsicFunction4:                                                         ;
	INC		C							; Update the index                  ;
	JP		IntrinsicFunction1			;  loop for another round           ;
;---------------------------- Intrinsic Function ---------------------------;

 ; cmd
;------------------------------ Command Buffer -----------------------------;
maximumBufferSize	EQU	07FH				; Max Length of Buffer          ;
commandMaxLength:	DB	maximumBufferSize                                   ;
commandLength:		DB	00H					; Actual size of input          ;
commandBuffer:		DS	maximumBufferSize + 1; The Command Buffer           ;
                                                                            ;
commandBufferPointer:	DW	commandBuffer	; Address of next to char       ;
;------------------------------ Command Buffer -----------------------------;
;------------------------- Submit File Control Block -----------------------;
;	                                                                        ;
submitFlag:			DB		00H			; 00 if no submit file,             ;
										;  0FFH if submitting               ;
submitFCB:			DB		'$$$     '	; File name is $$$                  ;
submitType:			DB		'SUB'		; Type is 'SUB'                     ;
submitExtent:		DB		00H			; Extent                            ;
submitS1:			DB		00H			; S1                                ;
submitS2:			DB		00H			; S2                                ;
submitRC:			DB		00H			; RC                                ;
submitMap:			DS		010H		; Allocation Map                    ;
submitCR:			DB		00H			; Current Record                    ;
;------------------------- Submit File Control Block -----------------------;
;--------------------------- Built In Command Data -------------------------;
;intrinsic function names four characters each                              ;
builtInCMDNameSize	EQU		04			; Size of intrinsic function names  ;
                                                                            ;
builtInCMDNames:                                                            ;
	DB		'DIR '                                                          ;
	DB		'ERA '                                                          ;
	DB		'TYPE'                                                          ;
	DB		'SAVE'                                                          ;
	DB		'REN '                                                          ;
	DB		'USER'                                                          ;
builtInCMDCount	EQU	(($-builtInCMDNames)/builtInCMDNameSize) + 1            ;
                                                                            ;
builtInCMDVector:                                                           ;
	DW		ccpDirectory				; Directory List                    ;
	DW		ccpErase					; File erase                        ;
	DW		ccpType						; Type file on Console              ;
	DW		ccpSave						; Save memory image                 ;
	DW		ccpRename					; File rename                       ;
	DW		ccpUser						; User number                       ;
	DW		ccpUserFunction				; User-defined function             ;
                                                                            ;
;--------------------------- Built In Command Data -------------------------;
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
;================================ BDOS API =================================;
;------------------------------ Get/Set User -------------------------------;
;return current user code in A                                              ;
GetUser:                                                                    ;
 	LD		E,0FFH						; Set Entry Parameter for Get       ;
; If E <> -1 then Set user number found in E                                ;
SetUser:                                                                    ;
 	LD		C,fGetSetUserNumber			; Load Function Number              ;
 	JP		BDOS						;  and let BDOS do its work         ;
;------------------------------ Get/Set User -------------------------------;
;------------------------------- Initialize --------------------------------;
Initialize:                                                                 ;
 	LD		C,fResetSystem				; Load Function Number              ;
 	JP		BDOS						;  and let BDOS do its work         ;
;------------------------------- Initialize --------------------------------;
;------------------------------- Select Disk -------------------------------;
SelectDisk:                                                                 ;
	LD		E,A							; Load Target disk                  ;
	LD		C,fSelectDisk				; Load Function Number              ;
 	JP		BDOS						;  and let BDOS do its work         ;
;------------------------------- Select Disk -------------------------------;
;----------------------------- Get Current Disk ----------------------------;
;Exits with current drive number to A (0=A,1=B....F=P)                      ;
GetSelectedDrive:                                                           ;
 	LD		C,fGetCurrentDisk				; Load Function Number          ;
 	JP		BDOS						;  and let BDOS do its work         ;
;----------------------------- Get Current Disk ----------------------------;

;  AP i

 ;-----------------------------
 ;open the file given by (DE)
 OpenFile:
 	LD		C,fOpenFile
 	JP		BDOSandIncA
 ;--------
 ;open file for Command FCB
 OpenFile4CmdFCB:
 	XOR		A
 	LD		(currentRecord),A					; clear next record to read
 	LD		DE,Token1
 	JP		OpenFile
 ;-----------------------------
 ;close the file given by (DE)
 CloseFile:
 	LD		C,fCloseFile
 	JP		BDOSandIncA
 ;-----------------------------
 ;delete the file given by (DE)
 DeleteFile:
 	LD		C,fDeleteFile
 	JP		BDOS
 ;-----------------------------
 ;make the file given by (DE)
 MakeFile:
 	LD		C,fMakeFile
 	JP		BDOSandIncA
 ;-----------------------------
 ;read the next record from the file given by d,e
 DiskRead:
 	LD		C,fReadSeq
 	JP		BDOSsetFlags
 ;-----------
 ;read next record from Command FCB
 DiskReadCmdFCB:
 	LD		DE,Token1
 	JP		DiskRead
 ;-----------------------------
 ;write the next record to the file given by (DE)
 DiskWrite:
 	LD		C,fWriteSeq
 	JP		BDOSsetFlags
 ;-----------------------------
 ;search for the file given by d,e
 SearchForFirst:
 	LD		C,fSearchFirst
 	JP		BDOSandIncA
 ;-----
 ;search for Token1 file
 Searc4CmdFcbFile:
 	LD		DE,Token1
 	JP		SearchForFirst
 ;-----------------------------
 ;search for the next occurrence of the file given by d,e
 SearchForNext:
 	LD		C,fSearchNext
 	JP		BDOSandIncA
 ;-----------------------------
 ; rename a file give bu (DE)
 RenameFile:
 	LD		C,fRenameFile
 	JP		BDOS
 ;-----------------------------
 ;set default buffer dma address
 SetDefaultDMA:
 	LD		DE,DMABuffer
 ;---------
 ;set dma address to d,e
 SetDMA:
 	LD		C,fSetDMA
 	JP		BDOS
 ;-----------------------------
 ; call B DOS and set Flags
 BDOSsetFlags:
 	CALL	BDOS
 	OR		A								; set return code flags
 	RET
 ;-----------------------------
 ;call B DOS  - increment result - store in directory count
 BDOSandIncA:
 	CALL	BDOS
 	LD		(directoryCount),A
 	INC		A
 	RET
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;check for a character ready at the console
 CheckForConsoleChar:
 	LD		C,fGetConsoleStatus
 	CALL	BDOS
 	OR		A
 	RET	Z; return no char waiting
 	LD		C,fConsoleIn
 	CALL	BDOS							; character cleared
 	OR		A
 	RET
 ;-----------------------------
;--------------------------------- Fill Token ------------------------------;
 ;equivalent to fillfcb(0)
; Exits with  Z-flag set if File name unambiguous

ParseToken2:
	LD		HL,Token2				; Point at Token2 start
	JR		ParseToken
ParseToken1:
	LD		HL,Token1				; Point at Token1 start
ParseToken:
	PUSH	HL							; Start of Token's Pointer
	PUSH	HL							; Start of Token's Pointer
	XOR		A							; Set A to 0
	LD		(selectedDisk),A			; Assume default disk
	LD		HL,(commandBufferPointer)	; Buffer's Pointer
	EX		DE,HL						; DE-> Buffer, HL -> Token
	CALL	NextNonBlankChar			; Buffer's next non-blank character
	EX		DE,HL						; DE-> Token , HL -> Buffer
	LD		(tokenStart),HL				; Save token's address
	EX		DE,HL						; DE -> Buffer
	POP		HL							; DE -> Buffer, HL -> Start of Token's Pointer
; Disk ?
	LD		A,(DE)						; Get 1st character from buffer
	OR		A							; Is it the default Disk ?
	JP		Z,UseCurrentDisk			; Use current disk if empty
	SBC		A,040H						; Convert to number 
	LD		B,A							; Hold disk number in B
	INC		DE
	LD		A,(DE)						; Look at next character
	CP		COLON						; Is it a ':' ?
	JP		Z,UseTokensDisk				;  if yes, set disk number
; No Disk
	DEC		DE							; Back to start of buffer

UseCurrentDisk:
	LD		A,(currentDisk)				; Get current Disk
	LD		(HL),A						; put into the Token
	JP		SetFileName

UseTokensDisk:
	LD		A,B
	LD		(selectedDisk),A					; mark as disk selected
	LD		(HL),B
	INC		DE								; past the :
;set the file name field
SetFileName:
	LD		B,8							; File name length (max)
SetFileNameLoop:
	CALL	IsItADelimiter				; Is character a delimiter ?
	JP		Z,PadTheName				;  yes, pad rest of name
	INC		HL							;  else move the Token's pointer
	CP		ASTERISK					; Is it an '*'					
	JP		NZ,SetFileName2				;  no, then just put in Token
	LD		(HL),QMARK					;  else Put a '?' in token
	JP		SetFileName3				;  for rest of Name

SetFileName2:
	LD		(HL),A						; Put character in token
	INC		DE							; Increment the buffer pointer
SetFileName3:
	DJNZ	SetFileNameLoop				; Loop if more
	
TruncateName:
	CALL	IsItADelimiter				; We expect a delimiter
	JP		Z,SetType					; If we get one, move to type
	INC		DE							;  skip forward in buffer
	JP		TruncateName				; Keep looking for delimiter

PadTheName:
	CALL	FillWithSpace				; Pad the rest of the name
	
SetType:
	LD		B,3							; File type length (max)
	CP		PERIOD						; is it a '.' ?
	JP		NZ,PadTypeField				; no, no type in buffer
	INC		DE							; Move past the .
SetTypeField1:
	CALL	IsItADelimiter				; Is character a delimiter ?
	JP		Z,PadTypeField				;  yes, pad rest of type
	INC		HL							;  else move the Token's pointer
	CP		ASTERISK					; Is it an '*'	
	JP		NZ,SetTypeField2			;  no, then just put in Token
	LD		(HL),QMARK					;  else Put a '?' in token
	JP		SetTypeField3				;  for rest of type

;  not a *, so copy to type field
SetTypeField2:
	LD		(HL),A						; Put character in token
	INC		DE							; Increment the buffer pointer
SetTypeField3:
;	DEC		B
;	JP		NZ,SetTypeField1
	DJNZ	SetTypeField1
											; end of type field, truncate the rest
TruncateType:
	CALL	IsItADelimiter
	JP	Z,FillRestofFCB
	INC		DE
	JP		TruncateType

PadTypeField:
	CALL	FillWithSpace
FillRestofFCB:
	LD		B,3
	XOR		A
	CALL	FillWithAcc
	EX	DE,HL 
	LD	(commandBufferPointer),HL					; set new starting point
; recover the start address of the fcb and count ?'s
	POP		HL
	LD		BC,11							; b=0, c=8+3
QuestionMarkCount:
	INC		HL
	LD		A,(HL)
	CP		QMARK
	JP	NZ,QuestionMarkCount1
; ? found, count it in b
	INC		B
QuestionMarkCount1:
	DEC		C
	JP	NZ,QuestionMarkCount
; number of ?'s in c, move to a and return with flags set
	LD		A,B
	OR		A
	RET
;-----------------------------


;-------------------------- Fill With Space/Acc ----------------------------;
; fills buffer with SPACE or contents of Acc.                               ;
; Enters with:	HL = less than start of fill area                           ;
;				B  = fill Count                                             ;
;				A  = fill character (FillWithAcc)                           ;
FillWithSpace:                                                              ;
	LD		A,SPACE                                                         ;
FillWithAcc:                                                                ;
	INC		HL                                                              ;
	LD		(HL),A                                                          ;
	DJNZ	FillWithAcc                                                     ;
	RET                                                                     ;
;-------------------------- Fill With Space/Acc ----------------------------;
;------------------------ Next Non Blank Character -------------------------;
;find the next non blank character in line pointed to by DE                 ;
NextNonBlankChar:                                                           ;
	LD		A,(DE)						; Get the character                 ;
	OR		A							; Is it End of buffer ?             ;
	RET		Z							;  if yes, return                   ;
	CP		SPACE						; is it a blank ?                   ;
	RET		NZ							;  if not, return                   ;
	INC		DE							;  else increment pointer           ;
	JP		NextNonBlankChar			; Loop for next character           ;
;------------------------ Next Non Blank Character -------------------------;
;---------------------------- Is It A Delimiter ----------------------------;
; Returns with Z-flag set if (DE) pointing at a delimiter                   ;
; Does an error exit if not valid ASCII character                           ;
IsItADelimiter:                                                             ;
	LD		A,(DE)						; Get the character                 ;
	OR		A                                                               ;
	RET		Z							; End of Buffer is a delimiter      ;
	CP		SPACE                                                           ;
	JP		C,CommandError				; Error exit if not ASCII           ;
	RET		Z							; SPACE is a delimiter              ;
	CP		EQUAL_SIGN                                                      ;
	RET		Z							; '=' is a delimiter                ;
	CP		UNDER_SCORE					                                    ;
	RET		Z							; '_' is a delimiter                ;
	CP		PERIOD                                                          ;
	RET		Z							; '.' is a delimiter                ;
	CP		COLON                                                           ;
	RET		Z							; ':' is a delimiter                ;
	CP		SEMICOLON                                                       ;
	RET		Z							; ';' is a delimiter                ;
	CP		LESS_THAN                                                       ;
	RET		Z							; '<' is a delimiter                ;
	CP		GREATER_THAN                                                    ;
	RET		Z							; '>' is a delimiter                ;
	RET									; Not a delimiter                   ;
;---------------------------- Is It A Delimiter ----------------------------;
;-----------------------------
; get number from the command line
GetNumberFromCmdLine:
	CALL	ParseToken1						; should be number
	LD		 A,(selectedDisk)
	OR		A
	JP	NZ,CommandError					; cannot be prefixed
; convert the byte value in Token1 to binary
	LD		HL,Token1 + 1
	LD		BC,11							;(b=0, c=11)
											; value accumulated in b, c counts name length to zero
GetNumericValue:
	LD		A,(HL)
	CP		SPACE
	JP	Z,GetNumericValue1
; more to scan, convert char to binary and add
	INC		HL
	SUB		ASCII_ZERO
	CP		10
	JP	NC,CommandError					; valid?
	LD		D,A								; save value
	LD		A,B								; mult by 10
	AND		11100000B
	JP	NZ,CommandError
	LD		A,B								; recover value
	RLCA
	RLCA
	RLCA										; *8
	ADD		A,B
	JP	C,CommandError
	ADD		A,B
	JP	C,CommandError					; *8+*2 = *10
	ADD		A,D
	JP	C,CommandError					 ; +digit
	LD		B,A
	DEC		C
	JP	NZ,GetNumericValue					; for another digit
	RET
GetNumericValue1:							; conv1 end of digits, check for all blanks
	LD		A,(HL)
	CP		SPACE
	JP	NZ,CommandError					;blanks?
	INC		HL
	DEC		C
	JP	NZ,GetNumericValue1
	LD		A,B								;recover value
	RET
;-----------------------------
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 
 ;-----------------------------
 ;*****************************************************************
 
;=============================== Utilities =================================;
;-------------------------------- CR / LF ----------------------------------;
;Sent Carriage Return Line Feed to Console                                  ;
CrLf:                                                                       ;
 	LD		E,CR						; Carriage Return                   ;
	CALL	PrintCharInE                                                    ;
 	LD		E,LF						; Line Feed                         ;
	JR		PrintCharInE                                                    ;
;-------------------------------- CR / LF ----------------------------------;
;------------------------------- PrintCharInA ------------------------------;
; Print character                                                           ;
; On Entry A = Character to Send to Console                                 ;
PrintCharInA:                                                               ;
	LD		E,A							; move char to E                    ;
	JR		PrintCharInE                                                    ;
;------------------------------- PrintCharInA -------------------------------;
;------------------------------- PrintCharInE ------------------------------;
; Print character                                                           ;
; On Entry E = Character to Send to Console                                 ;
; Preserves BC                                ;                             ;
PrintCharInE:                                                               ;
	PUSH	BC							; Preserve BC                       ;
 	LD		C,fConsoleOut				; Load Function Number         		;
 	CALL	BDOS						;  and let BDOS do its work         ;
	POP		BC							; Restore BC                        ;
	RET                                                                     ;
;------------------------------- PrintCharInE ------------------------------;

; UT
 PrintSpace:
 	LD		A,SPACE
 	JP		PrintSaveBC
 ;-----------------------------
  ;print character, but save b,c registers
 PrintSaveBC:
 	PUSH	BC
 	CALL	PrintCharInA
 	POP		BC
 	RET
 ;-----------------------------
 ;print CRLF then null terminated string at (BC)
 PrintCrLfStringNull:
 	PUSH	BC
 	CALL	CrLf
 	POP		HL 								;now print the string
 ;print null terminated string at (HL)
 PrintStringNull:
 	LD		A,(HL)
 	OR		A
 	RET	Z; stop on 00
 	INC		HL
 	PUSH	HL								; ready for next
 	CALL	PrintCharInA
 	POP		HL								; character printed
 	JP		PrintStringNull 				;for
 ;-----------------------------
 ;print no file message
 PrintNoFile:
 	LD		BC,msgNoFile
 	JP		PrintCrLfStringNull
 
 msgNoFile: DB 'NO FILE',0
 ;-----------------------------
 ;move 3 characters from h,l to d,e addresses
 CopyHL2DE3:
 	LD		B,3
 CopyHL2DEforB:
 	LD		A,(HL)
 	LD	(DE),AE
 	INC		HL
 	INC		DE
 	DEC		B
 	JP	NZ,CopyHL2DEforB
 	RET
 ;-----------------------------
 ;return (HL) = (A) + (HL)
 AddA2HL:
 	ADD		A,L
 	LD		L,A
 	RET	NC
 	INC		H
 	RET
 ;-----------------------------
 ;DMABuffer + a + c to h,l followed by fetch
 GetByteAtAandCandDMA:
 	LD		HL,DMABuffer					; 0080H
 	ADD		A,C
 	CALL	AddA2HL
 	LD		A,(HL)
 	RET
 ;-----------------------------
 ;-----------------------------
 ;*****************************************************************
 ;************************ Error messages ******************************
 ;*****************************************************************
 ;print the read error message
 PrintReadError:
 	LD		BC,msgReadErr
 	JP		PrintCrLfStringNull
 msgReadErr:
 	DB		'READ ERROR',0
 ;-----------------------------
 
 
 ;*****************************************************************
 ;--------------------------------------------------------
 ;reset disk
 ResetDisk:
 	LD		 A,(selectedDisk)
 	OR		A
 	RET	Z; no action if not selected
 	DEC		A
 	LD		HL,currentDisk
 	CP		M
 	RET	Z; same disk
 	LD		 A,(currentDisk)
 	JP		SelectDisk
 ;--------------------------------------------------------
 ;reset disk before end of command check
 ResetDiskAtCmdEnd:
 	CALL	ResetDisk
 ;end of intrinsic command
 EndCommand:
 	CALL	ParseToken1						; to check for garbage at end of line
 	LD		 A,(Token1) + 1
 	SUB		SPACE
 	LD		HL,selectedDisk
 	OR		M
 ; 0 in accumulator if no disk selected, and blank fcb
 	JP	NZ,CommandError
 	JP		ccpMainEntry
 ;*****************************************************************
 ;************************ CCP Commands ***************************
 ;*****************************************************************
 
 ;******************** Directory Listing ***************************
 ;Directory Listing
 ccpDirectory:
 	CALL	ParseToken1						; Token1 gets file name
 	CALL	SetDisk4Cmd						; change disk drives if requested
 	LD		HL,Token1+1
 	LD		A,(HL)								; may be empty request
 	CP		SPACE
 	JP	NZ,ccpDir2							; skip fill of ??? if not blank
 											; set Token1 to all ??? for current disk
 	LD		B,11							; length of fill ????????.???
 ccpDir1:
 	LD		(HL),QMARK
 	INC		HL
 	DEC		B
 	JP	NZ,ccpDir1
 ; not a blank request, must be in Token1
 ccpDir2:
 	LD		E,0
 	PUSH	DE								; E counts directory entries
 	CALL	Searc4CmdFcbFile				; first one has been found
 	CALL	Z,PrintNoFile						; not found message
 ccpDir3:
 	JP	Z,ccpDirEnd
 ; found, but may be system file
 	LD		 A,(directoryCount)					; get the location of the element
 	RRCA
 	RRCA
 	RRCA
 	AND		1100000B
 	LD		C,A
 ; c contains base index into DMABuffer for dir entry
 	LD		A,fcbSystemFileIndex			; System File Location in FCB
 	CALL	GetByteAtAandCandDMA			; value to A
 	RLA
 	JP	C,ccpDir7							; skip if system file c holds index into buffer
 ;  another fcb found, new line?
 	POP		DE								; get directory entry count (E)
 	LD		A,E
 	INC		E
 	PUSH	DE								; save dir entry count
 	AND		11B								; e=0,1,2,3,...new line if mod 4 = 0
 	PUSH	AF								; and save the test
 	JP	NZ,ccpDirHeader					; header on current line
 ; print the header drive with Colon ie A:
 	CALL	CrLf
 	PUSH	BC
 	CALL	GetSelectedDrive
 	POP		BC
 	ADD	A,ASCII_A
 	CALL	PrintSaveBC
 	LD		A,COLON
 	CALL	PrintSaveBC						; just printed drive with Colon ie A:
 	JP		ccpDirHeader1					; skip current line hdr
 
 ccpDirHeader:
 	CALL	PrintSpace						; after last one
 	LD		A,COLON
 	CALL	PrintSaveBC
 ccpDirHeader1:
 	CALL	PrintSpace
 ; compute position of name in buffer
 	LD		B,1								; start with first character of name
 ccpDir4:
 	LD		A,B
 	CALL	GetByteAtAandCandDMA			; DMABuffer+a+c fetched
 	AND		ASCII_MASK						; mask flags
 ; may delete trailing blanks
 	CP		SPACE
 	JP	NZ,ccpDir5							; check for blank type
 	POP		AF
 	PUSH	AF								; may be 3rd item
 	CP		3
 	JP	NZ,ccpDirSpace						; place blank at end if not
 	LD		A,9
 	CALL	GetByteAtAandCandDMA			; first char of type
 	AND		ASCII_MASK
 	CP		SPACE
 	JP	Z,ccpDir6
 ; not a blank in the file type field
 ccpDirSpace:
 	LD		A,SPACE							; restore trailing filename chr
 ccpDir5:
 	CALL	PrintSaveBC						; char printed
 	INC		B
 	LD		A,B
 	CP		12
 	JP	NC,ccpDir6
 											; check for break between names
 	CP		9
 	JP	NZ,ccpDir4							; for another char
 
 	CALL	PrintSpace						; print a blank between names
 	JP		ccpDir4
 
 ccpDir6:									; end of current entry
 	POP		AF								; discard the directory counter (mod 4)
 ccpDir7:
 	CALL	CheckForConsoleChar				; check for interrupt at keyboard
 	JP	NZ,ccpDirEnd						; abort directory search
 	CALL	SearchForNext
 	JP		ccpDir3							; for another entry
 ccpDirEnd:
 	POP		DE								; discard directory counter
 	JP		ResetDiskAtCmdEnd
 ;
 
 ;*****************************************************************
 ccpErase:
 	CALL	ParseToken1						; cannot be all ???'s
 	CP		11
 	JP	NZ,ccpEraseAll
 											; erasing all of the disk
 	LD		BC,msgEraseAll
 	CALL	PrintCrLfStringNull
 
 	CALL	ReadCommand
 	LD		HL,commandLength
 	DEC		M
 	JP	NZ,ccpMainEntry ;bad input
 	INC		HL
 	LD		A,(HL)
 	CP		ASCII_Y
 	JP	NZ,ccpMainEntry
 ; ok, erase the entire diskette
 	INC		HL
 	LD	(commandBufferPointer),HL					; otherwise error at ResetDiskAtCmdEnd
 ccpEraseAll:
 	CALL	SetDisk4Cmd
 	LD		DE,Token1
 	CALL	DeleteFile
 	INC		A								; 255 returned if not found
 	CALL	Z,PrintNoFile						; no file message if so
 	JP		ResetDiskAtCmdEnd
 ;
 msgEraseAll:
 	DB	'ALL (Y/N)?',0
 ;*****************************************************************
 ; Type file
 ccpType:
 	CALL	ParseToken1
 	JP	NZ,CommandError					; don't allow ?'s in file name
 	CALL	SetDisk4Cmd
 	CALL	OpenFile4CmdFCB					; open the file
 	JP	Z,ccpTypeError					; zero flag indicates not found
 ; file opened, read 'til eof
 	CALL	CrLf
 	LD		HL,bufferPointer
 	LD		(HL),255 							; read first buffer
 ccpType1:									; loop on bufferPointer
 	LD		HL,bufferPointer
 	LD		A,(HL)
 	CP		128								; end buffer
 	JP	C,ccpType2
 	PUSH	HL								; carry if 0,1,...,127
 ; read another buffer full
 	CALL	DiskReadCmdFCB
 	POP		HL								; recover address of bufferPointer
 	JP	NZ,ccpTypeEOF						; hard end of file
 	XOR		A
 	LD		(HL),A								; bufferPointer = 0
 ; read character at bufferPointer and print
 ccpType2:
 	INC		M								; bufferPointer = bufferPointer + 1
 	LD		HL,DMABuffer
 	CALL	AddA2HL							; h,l addresses char
 	LD		A,(HL)
 	CP		END_OF_FILE
 	JP	Z,ResetDiskAtCmdEnd
 	CALL	PrintCharInA
 	CALL	CheckForConsoleChar
 	JP	NZ,ResetDiskAtCmdEnd				; abort if break
 	JP		ccpType1						; for another character
 
 ccpTypeEOF:
 	DEC		A
 	JP	Z,ResetDiskAtCmdEnd
 	CALL	PrintReadError
 ccpTypeError:
 	CALL	ResetDisk
 	JP		CommandError
 ;*****************************************************************
 ; save save memory image
 ;*****************************************************************
 ccpSave:
 	CALL	GetNumberFromCmdLine			; value to register a
 	PUSH	AF								; save it for later
 											; should be followed by a file to save the memory image
 	CALL	ParseToken1
 	JP	NZ,CommandError					; cannot be ambiguous
 	CALL	SetDisk4Cmd						; may be a disk change
 	LD		DE,Token1
 	PUSH	DE
 	CALL	DeleteFile						; existing file removed
 	POP 	DE
 	CALL	MakeFile						; create a new file on disk
 	JP	Z,ccpSaveError					; no directory space
 	XOR		A
 	LD		(currentRecord),A					; clear next record field
 	POP		AF								; #pages to write is in a, change to #sectors
 	LD		L,A
 	LD		H,0
 	ADD		HL,HL
 
 	LD		DE,TPA							; h,l is sector count, d,e is load address
 ccpSave1:									; save0 check for sector count zero
 	LD		A,H
 	OR		L
 	JP	Z,ccpSave2						; may be completed
 	DEC		HL								; sector count = sector count - 1
 	PUSH	HL								; save it for next time around
 	LD		HL,cpmRecordSize
 	ADD		HL,DE
 	PUSH	HL								; next dma address saved
 	CALL	SetDMA							; current dma address set
 	LD		DE,Token1
 	CALL	DiskWrite
 	POP		DE
 	POP		HL								; dma address, sector count
 	JP	NZ,ccpSaveError					; may be disk full case
 	JP		ccpSave1						; for another sector
 
 ;  end of dump, close the file
 ccpSave2:
 	LD		DE,Token1
 	CALL	CloseFile
 	INC		A								; 255 becomes 00 if error
 	JP	NZ,ccpSaveExit						; for another command
 ccpSaveError:								; saverr must be full or read only disk
 	LD		BC,msgNoSpace
 	CALL	PrintCrLfStringNull
 ccpSaveExit:
 	CALL	SetDefaultDMA					; reset dma buffer
 	JP		ResetDiskAtCmdEnd
 
 msgNoSpace:
 	DB 'NO SPACE',0
 ;*****************************************************************
 ccpRename:
 	CALL	ParseToken1
 	JP	NZ,CommandError					; must be unambiguous
 	LD		 A,(selectedDisk)
 	PUSH	AF								; save for later compare
 	CALL	SetDisk4Cmd						; disk selected
 	CALL	Searc4CmdFcbFile				; is new name already there?
 	JP	NZ,ccpRenameError3
 ; file doesn't exist, move to second half of fcb
 	LD		HL,Token1
 	LD		DE,Token2
 	LD		B,16
 	CALL	CopyHL2DEforB
 ; check for = or left arrow
 	LD	HL,(commandBufferPointer)
 	EX	DE,HL 
 	CALL	NextNonBlankChar
 	CP		EQUAL_SIGN
 	JP	Z,ccpRename1						; ok if =
 	CP		LEFT_ARROW						; la
 	JP	NZ,ccpRenameError2
 ccpRename1:
 	EX	DE,HL 
 	INC		HL
 	LD	(commandBufferPointer),HL					; past delimiter
 ; proper delimiter found
 	CALL	ParseToken1
 	JP	NZ,ccpRenameError2
 ; check for drive conflict
 	POP		AF
 	LD		B,A								; previous drive number
 	LD		HL,selectedDisk
 	LD		A,(HL)
 	OR		A
 	JP	Z,ccpRename2
 ; drive name was specified.  same one?
 	CP	B
 	LD	(HL),B
 	JP	NZ,ccpRenameError2
 ccpRename2:
 	LD		(HL),B								; store the name in case drives switched
 	XOR		A
 	LD		(Token1),A
 	CALL	Searc4CmdFcbFile				; is old file there?
 	JP	Z,ccpRenameError1
 ; everything is ok, rename the file
 	LD		DE,Token1
 	CALL	RenameFile
 	JP		ResetDiskAtCmdEnd
 
 ccpRenameError1:							; no file on disk
 	CALL	PrintNoFile
 	JP		ResetDiskAtCmdEnd
 ccpRenameError2:							; ambigous reference/name conflict
 	CALL	ResetDisk
 	JP		CommandError
 ccpRenameError3:							; file already exists
 	LD		BC,msgFileExists
 	CALL	PrintCrLfStringNull
 	JP		ResetDiskAtCmdEnd
 
 msgFileExists:
 	DB	'FILE EXISTS',0
 
 ;*****************************************************************
 ccpUser:
 	CALL	GetNumberFromCmdLine			; leaves the value in the accumulator
 	CP		16
 	JP	NC,CommandError					; must be between 0 and 15
 	LD		E,A								; save for SetUser call
 	LD		 A,(Token1) + 1
 	CP		SPACE
 	JP	Z,CommandError
 	CALL	SetUser 						;new user number set
 	JP		EndCommand
 ;*****************************************************************
 ;User defined function
 ;*****************************************************************
 ccpUserFunction:
 
 	LD		 A,(Token1) + 1
 	CP		SPACE
 	JP	NZ,ccpUserFunction1
 ; no file name, but may be disk switch
 	LD		 A,(selectedDisk)
 	OR		A
 	JP	Z,EndCommand						; no disk named if 0
 	DEC		A								; adjust so A=>0, B=>1, C=>2 ......
 	LD		(currentDisk),A						; update current Disk indicator
 	CALL	SetPage0CurDisk					; set user/disk
 	CALL	SelectDisk
 	JP		EndCommand
 
 ;  file name is present
 ccpUserFunction1:
 	LD		DE,Token1 + 9
 	LD	A,(DE)
 	CP		SPACE
 	JP	NZ,CommandError					; type SPACE
 	PUSH	DE
 	CALL	SetDisk4Cmd
 	POP		DE
 	LD		HL,comFileType					; .com
 	CALL	CopyHL2DE3						; file type is set to .com
 	CALL	OpenFile4CmdFCB
 	JP	Z,ccpUserFunctionError1
 ; file opened properly, read it into memory
 	LD		HL,TPA							; transient program base
 ccpUserFunction2:
 	PUSH	HL 								;save dma address
 	EX	DE,HL 
 	CALL	SetDMA
 	LD		DE,Token1
 	CALL	DiskRead
 	JP	NZ,ccpUserFunction3
 ; sector loaded, set new dma address and compare
 	POP		HL
 	LD		DE,cpmRecordSize
 	ADD		HL,DE
 	LD		DE,CcpBoundary					; has the load overflowed?
 	LD		A,L
 	SUB		E
 	LD		A,H
 	SBC		A,D
 	JP	NC,ccpUserFunctionError2
 	JP		ccpUserFunction2				; for another sector
 
 ccpUserFunction3:
 	POP		HL
 	DEC		A
 	JP	NZ,ccpUserFunctionError2			; end file is 1
 	CALL	ResetDisk						; back to original disk
 	CALL	ParseToken1
 	LD		HL,selectedDisk
 	PUSH	HL
 	LD		A,(HL)
 	LD		(Token1),A						; drive number set
; 	LD		A,16
 	CALL	ParseToken2							; move entire fcb to memory
 	POP		HL
 	LD		A,(HL)
 	LD		(Token2),A
 	XOR		A
 	LD		(currentRecord),A					; record number set to zero
 	LD		DE,FCB1							; default FCB in page 0
 	LD		HL,Token1
 	LD		B,33
 	CALL	CopyHL2DEforB
 ; move command line to buff
 	LD		HL,commandBuffer
 ccpUserFunction4:
 	LD		A,(HL)
 	OR		A
 	JP	Z,ccpUserFunction5
 	CP		SPACE
 	JP	Z,ccpUserFunction5
 	INC		HL
 	JP		ccpUserFunction4				; for another scan
 ; first blank position found
 ccpUserFunction5:
 	LD		B,0
 	LD		DE,DMABuffer + 1
 ; ready for the move
 ccpUserFunction6:
 	LD		A,(HL)
 	LD	(DE),AE
 	OR		A
 	JP	Z,ccpUserFunction7
 ;more to move
 	INC		B
 	INC		HL
 	INC		DE
 	JP		ccpUserFunction6
 ccpUserFunction7:							; B has character count
 	LD		A,B
 	LD		(DMABuffer),A
 	CALL	CrLf
 ; now go to the loaded program
 	CALL	SetDefaultDMA					; default dma
 	CALL	SaveUserAndDisk						; user code saved
 ; low memory diska contains user code
 	CALL	TPA								; gone to the loaded program
 	LD		SP,Stack						; may come back here
 	CALL	SetPage0CurDisk
 	CALL	SelectDisk
 	JP		ccpMainEntry
 
 ccpUserFunctionError1:
 	CALL	ResetDisk
 	JP		CommandError
 
 ccpUserFunctionError2:						; cannot load the program
 	LD		BC,msgBadLoad
 	CALL	PrintCrLfStringNull
 	JP		ResetDiskAtCmdEnd
 
 msgBadLoad:
 	DB		'BAD LOAD',0
 comFileType:
 	DB		'COM' ;for com files
 ;
 
 ;*****************************************************************
 ;*****************************************************************
 ;change disks for this command, if requested
 SetDisk4Cmd:
 	XOR		A
 	LD		(Token1),A						; clear disk name from fcb
 	LD		 A,(selectedDisk)
 	OR		A
 	RET	Z; no action if not specified
 	DEC		A
 	LD		HL,currentDisk
 	CP		M
 	RET	Z;already selected
 	JP		SelectDisk
 ;*****************************************************************
 
 ;*****************************************************************
 ;************************ Data Area ******************************
 ;*****************************************************************
;------------------------------ Command Buffer -----------------------------;
 ;;
 ;;	
Token1:			DS		16				; Command Token
Token2:			DS		16				; Command Token

 currentRecord:		DB		00H				; current record to read/write
 directoryCount:		DB		00H				; disk directory count (used for error codes)
currentDisk:		DB		00H				; Current disk
 selectedDisk:		DB		00H				; selected disk for current operation none=0, a=1, b=2 ...
 ;
 bufferPointer:		DB		00H				; buffer pointer
 ;------------------------------------
 tokenStart:		DW		0000H			; staddr starting address of current Fill FCB request
 ;----------------------------
 ; (command executed initially if commandLength non zero)
;  Command Buffer

 
endOfCode:
 				ORG		BDOSBase-10H
Stack:											; Top Of Stack

;Z_HighestLocation:
ZZ_MemoryLeft EQU    (BDOSBase-1) - endOfCode
 
 
 
 
 
